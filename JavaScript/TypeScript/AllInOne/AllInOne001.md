# Basics
## 2022-08-19 Fri
### TS 문법만큼 중요한 것
* TS를 공부하는 경우, JS의 슈퍼셋으로서 추가된 신규 문법에만 집중하는 경향이 있다.
* 그러나 TS는 TS 문법 만큼이나 **이미 작성되어 있는 써드파티 라이브러리의 타입들을 분석할 수 있는 역량 역시 매우 중요**하다.

### TS 기본 지식 되돌아보기
* **TS는 결국에는 JS로 변환되며, 브라우저와 Node.js는 런타임 자체적으로 TS를 지원하지는 않는다**.
  * 때문에 TS에서는 말이 되지만, JS에서는 불가능한 코드란 본질적으로 존재할 수 없다.
* TS는 언어임과 동시에 컴파일러이기도 하며, TSC는 TS 코드를 JS 코드로 변환해준다.
  * 이에 따라 TS 코드가 아닌 결과물인 JS 코드를 실행해야 한다. 
* 또한, TSC는 코드 자체에 대한 강력한 타입 검사 기능을 포함한다.
  * 즉, **TSC의 핵심은 코드 변환과 타입 검사라고 볼 수 있다**.
* 이 때, **TSC의 두 핵심 기능은 각각 별개의 개념이므로 각자 동작할 수 있다**.
  * 때문에 타입 검사에 실패해도 JS 코드로 변환 자체는 가능할 수 있다.
  * 그러나 이는 어디까지나 타입 검사가 강제가 아니라는 TSC의 특징일 뿐이며, 실무에서는 타입 검사가 실패한 코드를 굳이 JS로 변환하여 사용할 필요가 없다. 
* **TSC는 tsconfig.json의 설정에 따라 JS 코드로 변환하므로, TS 작업 시에는 반드시 tsconfig.json 설정을 분석할 수 있어야 한다**.

## 2022-08-20 Sat
### tsconfig.json 생성하기 
* `tsc --init` 명령어를 통해 기본 설정이 적용된 tsconfig.json 파일을 생성할 수 있다.
  * TS 프로젝트를 시작하는 경우, package.json과 tsconfig.json의 생성은 필수적이다.
* **tsconfig.json의 경우 기본적으로 `strict: true` 를 반드시 설정해두는 것이 바람직**하다.
  * 해당 옵션을 false로 설정하는 경우, 사실 상 TS를 사용하는 의미가 크게 퇴색된다.
* `tst --init` 명령어를 적용한 경우에 기본적으로 활성화되는 설정은 다음과 같다.
  1. target: tsc가 JS 코드로 변환하는 경우에 사용할 ES 버전이 명시된다.
  2. module: 상대적으로 다양한 모듈 시스템을 갖는 JS의 특성 상, 어떤 모듈 시스템을 활용할지 명시할 수 있다.
  3. forceConsistentCasingInFileNames: import 구문의 경우, Windows 환경은 임포트 대상 파일의 대소문자를 구분하지 않는다.
     * 그러나 MacOS와 Linux 기반 환경의 경우 대소문자를 구분하므로, 서로 다른 OS를 사용하는 개발자들끼리 협업하는 경우 버그를 발생시킬 수 있다.
     * **해당 옵션은 모듈 임포트시 반드시 대소문자를 정확히 명시하도록 강제하며, 일반적으로 true로 설정하는 것이 권장**된다.
  4. skipLibCheck: 라이브러리에 대한 체킹을 건너뛰도록 하는 옵션에 해당한다.
     * 해당 옵션이 활성화된 경우, 각 라이브러리 패키지의 d.ts 파일을 무시한다.
     * 이 때, **d.ts 파일은 해당 패키지에서 사용되는 타입을 정리해둔 파일에 해당**한다. 
     * TS 기반으로 개발하게 되는 경우 필연적으로 매우 많은 패키지를 사용하지만, 모든 패키지 파일을 검사하는 경우에는 컴파일 시간이 너무 길어지게 된다.
     * 이러한 **문제를 방지하기 위해 해당 옵션은 정말 개발자 자신이 작성한 TS 코드에 대해서만 동작하도록 보장**한다.
* 이 밖에도 여러 옵션이 있지만, tsconfig.json의 핵심은 상술한 `strict: true`에 있다.

### tsc 명령어로 컴파일하기
* 아래와 같은 TS 파일은 `tsc --noEmit`을 통해 명시적으로 타입 검사를 수행할 경우, 에러가 발생한다.
  * 그러나 **TSC의 타입 검사와 코드 변환은 서로 별개의 기능이므로, 실제로는 결과물로서의 JS 파일이 생성되는 것을 확인할 수 있다**.
```
let a = 1;
a = 'hello';

[~] tsc --noEmit
tsc --noEmit                                                                                                                                                                                
first/first.ts:3:1 - error TS2322: Type 'string' is not assignable to type 'number'.

3 a = 'hello';
  ~
[~] ls first                                                                                                                                                                                    
first.js first.ts
```

### TS 문법
* **TS는 JS 코드 상에서 변수, 매개 변수, 반환형 등의 대상에 타입을 명시한 것**이다.
  * 사실 상 TS의 모든 개념은 이게 전부이다!
```
// 변수
const num: number = 1;

// 매개 변수와 반환형
function add(a: number, b: number): number {
    return a + b;
}
```
* **TS의 경우, 최종 목적은 JS 코드로 변환되는 것이므로 콜론 뒤에 타이핑된 모든 타입 정보를 제거했을 때도 실행 가능한 JS 코드의 형태를 띄어야** 한다.
  * 이는 사실 상 TS의 기본 규칙에 해당한다.
* 또한, 원시 타입에 변하지 않는 상수를 활용하는 경우 다음과 같이 타이핑을 적용할 수도 있다.
  * 이는 **const 키워드로 정의된 변수는 어차피 값이 변하지 않으며, 가능한 한 상세한 타입을 정의해야하는 TS의 특성으로부터 기인하는 타이핑 방식**이다.
```
const i_am_42: 42 = 42;
```

### any 형
* TS에서, 타입에 any를 명시할 경우 어떠한 형태의 데이터도 받아들일 수 있는 변수가 된다.
  * 그러나 **모든 것을 any로 적용할 경우 TS가 아닌 JS와 같은 약타입 언어로서 동작하므로, any의 사용은 가능한 한 지양하는 것이 바람직**하다.
* **이러한 측면에서, TS는 모든 것이 any 형으로 설정된 TS 코드로부터 모든 any를 제거하는 것으로 볼 수도 있다**.
  * 즉, TS의 주 목적 중 하나는 any 형을 없애는 것에 있다.

### type alias와 interface
* `type` 키워드를 활용하여 복잡한 타입을 다음과 같이 정의할 수 있으며, 이는 타입 별칭이라고도 지칭할 수 있다.
```
type Add = (x: number, y: number) => number;
const add: Add = (a, b) => {
    return a + b;
}
```
* 또한, 타입 별칭 대신 `interfcae` 키워드를 활용하여 다음과 같이 타입을 정의할 수도 있다.
```
interface Multiply {
    (x: number, y: number): number;
}
const multi: Multiply = (a, b) => {
    return a * b;
}
```
* 이와 같이, TS의 타이핑은 세 가지 방식이 존재한다.
  1. 변수 또는 매개 변수, 또는 함수 자체에 타입을 직접 명시하기
  2. 또는 타입 별칭 적용하기
  3. 또는 인터페이스 적용하기

### 객체와 배열 타이핑하기
* 객체의 경우, 다음과 같이 객체에 해당될 프로퍼티와 타입을 동시에 명시해야 한다.
```
const obj: { name: string, age: number } = {
    name: 'ingnoh', age: 14,
};
```
* 반면, 배열의 경우 `[]` 키워드를 활용하여 다음과 같이 타이핑을 적용한다.
```
const arr: string[] = [ 'a', 'b' ];
```

### 튜플 정의하기
* **튜플은 길이가 고정된 배열을 의미하며, 일반적으로 JS에서 사용되는 개념은 아니다**.
  * 이 때, 튜플은 배열의 길이 역시 맞추어주어야 하며 다음과 같이 타이핑을 정의할 수 있다.
```
const tuple: [number, boolean, string] = [ 1, true, 'hello' ];
```
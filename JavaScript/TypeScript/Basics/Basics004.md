# Basics
## 2022-05-31 Tue

### 타입 별칭이란?
* **타입 별칭이란 임의의 타입 또는 인터페이스를 참조할 수 있는 유형의 타입 변수**이다.
  * 예를 들어, 아래의 코드는 number 타입을 sutJa 타입 별칭으로 참조한다.
```
type sutJa = number;
const num: sutJa = 1;
```
* **임의의 타입에 대한 참조와 마찬가지로, 복잡한 객체 구조 역시 다음과 같이 타입 별칭으로 참조할 수 있다**.
  * 사실상 타입을 정의할 수 있는 모든 곳에 대해 타입 별칭을 할당할 수 있다.
```
type Student = {
    name: string;
    age: number;
    grade: number;
}
const injuk: Student = {
    name: 'injuk',
    age: 3,
    grade: 1,
}; 
```
* 자주 사용되는 **데이터 구조의 형태가 복잡한 경우, 타입 별칭을 활용하여 한 곳에서 관리하는 것으로 다음과 같은 이점**을 얻을 수 있다.
  1. 데이터 구조에 포함되는 속성이 변경되는 경우, 변경 사항을 반영하기 쉬우므로 유지보수성이 높아진다.
  2. 긴 데이터 구조를 명시적인 별칭으로 참조할 수 있으므로, 코드의 가독성이 높아진다.

### 타입 별칭과 인터페이스의 차이
* **타입 별칭의 경우 새로운 타입 유형을 정의하거나 추가하는 것이 아닌, 기존에 정의된 타입에 대한 별칭을 부여하는 개념**이다.
* **인터페이스는 extends 키워드를 활용한 기능 확장이 가능하나, 타입 별칭은 확장이 불가능**하다.
  * 이는 타입 별칭과 인터페이스의 가장 주요한 차이점이기도 하다.
  * **애플리케이션은 가능한 한 쉽게 확장할 수 있는 상태를 유지하는 것이 바람직하므로, 일반적으로는 타입 별칭보다 인터페이스의 사용이 권장**된다.

### Union 타입이란?
* 유니온 타입은 연산자를 활용하여 정의하는 타입이며, | 기호를 사용한다.
  * 이렇듯 **유니온 타입은 특정 변수 또는 인자에 하나 이상의 타입을 사용할 수 있도록 허용하는 역할을 맡는다**.
```
function log(param: string | number): void {
    console.log(param);
}

log('hello world!'); // 유니온 타입에 의해 문자열과 숫자 모두를 처리할 수 있게 되었다.
log(3);
```
* 모든 타입을 받아들일 수 있는 **any 타입을 사용하는 경우와 달리, 유니온에 타입 검사가 포함된 코드의 경우 변수의 타입 추론이 가능**해진다.
  * 타입 가드에 의해 타입이 성공적으로 추론된 경우, IDE에 의한 자동 완성의 이점도 누릴 수 있게 된다.
  * 타입 가드란, 특정한 타입으로 타입의 범위를 필터링해나가는 과정 전반을 일컫는다.
  * **유니온 타입과 타입 가드, 나아가 타입 가드에 의해 필터링되지 않은 경우에 대한 throw 문의 조합을 통해 TS는 더 큰 타입 안정성을 취할 수 있게 된다**.

### Union 타입의 특징
* 두 인터페이스를 유니온 타입으로 전달받을 수 있는 함수의 경우, 두 인터페이스의 공통 부분에 대해서만 지원받을 수 있다.
```
interface Dev {
    name: string;
    skill: string;
}
interface Design {
    name: string;
    age: number;
}
function doSomething(who: Dev | Design) {
    who.name;
    // who.skill; // Dev와 Design의 공통 부분이 아니므로 에러를 발생시킨다.
    // who.age; // Dev와 Design의 공통 부분이 아니므로 에러를 발생시킨다.
}
```
* 유니온 타입이므로 각 타입이 제공하는 모든 기능을 사용할 수 있어야 할 것 처럼 보이지만, 실제로는 두 인터페이스의 교집합만을 사용할 수 있다.
  * 즉, **두 인터페이스의 유니온 타입은 공통 기능만을 제공하는 특징**을 갖는다.
* TS의 관점에서, doSomething 함수에는 Dev 또는 Design 쪽 어느 타입이 전달될지 알 수 없으므로 두 타입 간의 공통 속성에 대해서만 자동 완성이 가능하다.

### Intersection 타입
* 인터섹션 타입은 유니온 타입과 달리 & 연산자를 사용하여 작성한다.
* 유니온 타입인 | 연산자의 경우 명시된 타입 중 하나를 의미하지만, & 연산자는 명시된 모든 타입을 만족해야 한다.
  * 때문에 **아래의 코드는 number이면서 string일 수 없으므로 never 타입으로 추론**된다.
```
let never: string & number; // string이자 number 타입이어야 한다.
```
* 반면, Dev와 Designer 예제로 돌아가면 인터섹션 타입의 사용성을 쉽게 이해할 수 있다.
  * 인자로 전달되는 who는 인터페이스 Dev의 기능을 모두 만족하면서도 인터페이스 Design의 기능까지 만족할 수 있어야 한다.
  * 결국 **who는 두 인터페이스의 모든 기능을 갖는 타입으로 추론되므로, IDE에 의해 다음과 같은 지원을 받을 수 있게 된다**.
```
function doManyThing(who: Dev & Design) {
    who.name;
    who.age
    who.skill;
}
```

### Union 타입과 Intersection 타입
* **유니온 타입을 전달받는 함수의 경우, 유니온 타입으로 명시된 인자는 타입 가드에 의한 추가 처리를 통해서만 각 필드에 접근이 가능**해진다.
* 반면 **인터섹션 타입으로 정의된 함수의 경우, 타입 가드 필요 없이 인자 자체가 인터섹션 타입에 명시된 모든 타입의 기능을 포함하는 것으로 추론**된다.
  * 즉, 인터섹션 타입에 명시된 모든 타입의 기능 또는 속성에 에러 없이 접근할 수 있게 된다.
* **실무 관점에서, 다음과 같은 이유로 인해 인터섹션 타입에 비해 유니온 타입이 더 상대적으로 더 권장**된다.
  1. 유니온 타입을 전달받는 함수는 명시된 타입 중 하나의 조건만 만족해도 무방하다.
  2. 반면, 인터섹션 타입을 전달받는 함수는 명시된 타입 모두의 조건을 반드시 만족해야 한다.
```
interface Dev {
    name: string;
    skill: string;
}
interface Design {
    name: string;
    age: number;
}
function union(who: Dev | Design) {}
function intersection(who: Dev & Design) {}

union({ name: '개발자', skill: 'TS' });
union({ name: '디자이너', age: 3 });

intersection({ name: '개발자', skill: 'TS', age: 10 });
intersection({ name: '디자이너', age: 3, skill: 'UI/UX' });
```
* 그러나 **이는 유니온 타입만 사용되고, 인터섹션 타입은 반드시 사용을 지양해야한다는 의미가 아니다**.
* 단지 유니온 타입을 사용하는 이유는 명시된 타입 중 하나의 특징을 갖는 타입을 의도하지만, 인터섹션의 경우 모든 타입의 특징을 만족할 것을 강요한다.
  * 반면, **유니온 타입의 경우 인자로 전달하는 것이 상대적으로 자유롭지만 함수 내적으로 타입 가드가 요구되는 상황이 많다는 점에서 차이가 존재**한다.
  * 반대로 **인터섹션 타입의 경우 두 타입의 합집합인 새로운 타입을 명시하게 되는 점에서 유니온 타입과 차이가 있다**.

## 2022-06-01 Wed
### enum이란?
* 이넘은 임의의 값들의 집합을 의미하는 타입이며, 크게 숫자형과 문자형으로 분류해볼 수 있다.
* 숫자형 이넘은 다음과 같이 정의할 수 있으며, 대응되는 값을 작성하지 않은 경우에는 0부터 시작하는 인덱스 값이 할당된다.
  * 이렇듯 **이넘을 정의하되 아무런 값을 할당하지 않은 경우, 기본적으로 숫자형 이넘**이 된다.
  * 또한, 이넘은 서로 다른 항목에 같은 값을 할당하는 것이 허용된다.
```
export enum Bytes {
    _1KB, // 0이 할당된다.
    _1MB, // 1이 할당된다.
    _1GB, // 2이 할당된다.
    _1TB, // 3이 할당된다.
}

const bytes = Bytes._1KB;
console.log(bytes); // 0
```
* 대응되는 값을 정의한 경우, 값을 아직 정의하지 않은 다음 값은 해당 값부터 1씩 늘어난 값이 자동으로 할당된다.
```
export enum Bytes {
    _Byte = 12,
    _1KB, // 13이 할당된다.
    _1MB = 3 ,
    _1GB, // 4가 할당된다.
    _1TB , // 5가 할당된다.
}
```
* 반면 문자형 이넘은 다음과 같이 정의하며, 사용법은 숫자형 이넘과 같다.
```
export enum CRUD {
    CREATE = 'create',
    READ = 'read',
    UPDATE = 'update',
    DELETE = 'delete',
}

console.log(CRUD.READ); // read가 출력된다.
```
# EffectiveTS
## 2022-11-12 Sat

### 특이한 TS의 특징
* TS는 사용 방식 측면에서 다음과 같은 이유로 다른 언어와는 차이를 보이는 특이한 언어이다.
    1. 인터프리터로 실행되지 않는다.
    2. **Java나 C 처럼 저수준 언어로 컴파일되지 않는 대신, 또 다른 고수준 언어인 JS로 컴파일**된다.
    3. TS 자체로 실행되지 못한다.
* 이러한 이유에서 TS는 JS와 뗄래야 뗄 수 없는 관계를 갖고, 때로는 이러한 연관성이 혼란을 주기도 한다.
    * 하지만 바꿔말하자면 이러한 TS와 JS의 밀접한 관계를 이해한다면 TS 개발자로서 한 단계 성장할 수 있게 된다.

### TS와 JS의 관계
```
> TS는 타입이 정의된, JS의 슈퍼셋이다.
> 바꿔 말해, JS는 TS의 부분집합이다.
```
* TS는 JS와 매우 밀접한 관계를 가지므로, 이러한 연관성을 정확히 이해하는 것은 매우 중요하다.
* TS와 JS는 각기 다른 확장자를 사용하지만, 이는 두 언어가 완전히 다름을 의미하지 않는다.
    * 예를 들어 **TS는 문법적으로도 JS의 슈퍼셋이므로, JS 애플리케이션에 문제가 없다면 이는 유효한 TS 애플리케이션**으로도 볼 수 있다.
    * 이러한 특징은 이미 JS로 작성된 코드를 TS로 마이그레이션 하는 과정에서 기존 코드를 유지하면서도 필요한 부분에만 TS를 적용할 수 있도록 지원한다.
* 상술한 바와 같이 모든 JS 애플리케이션은 TS 애플리케이션이기도 하지만, 그 역은 성립하지 않는다.
    * 이는 **TS가 JS에는 존재하지 않는 추가적인 문법을 갖기 때문**으로, TS 애플리케이션을 JS 런타임에서 바로 실행할 수는 없다.
    * 때문에 `:string`과 같은 타입 명시 구문을 사용하는 시점부터 JS로 작성된 애플리케이션은 TS의 영역에 들어서게 된다.
* 반면, **문법의 유효성과 런타임 상의 문제는 완전히 독립적인 문제**이다.
    * 이 경우에도 TS는 여전히 코드를 파싱하고, JS로 변환하는 작업을 적용할 수 있다.

### TS의 유용성
* TS 컴파일러는 타입 체커를 통해 일반적인 JS 애플리케이션에서도 유용하게 사용될 수 있다.
    * 예를 들어, TS의 타입 체커는 타입 추론을 통해 초기값으로부터 변수의 타입을 추론할 수 있다.
* 이렇듯 **타입 시스템의 목표 중 하나는 런타임에서 오류가 될만한 코드를 미리 찾아내는 것에 있으며, TS는 정적 타입 시스템으로서 이러한 특징을 갖는다**.
    * 그러나 아쉽게도 타입 체커는 모든 문제를 사전에 찾아낼 수 있는 것은 아니다.
* **JS의 경우 객체 프로퍼티를 참조하는 과정에서 발생한 undefined의 반환 등, 오류가 발생하지는 않지만 정상적으로 동작하지도 않는 코드가 발생하기 쉽다**.
    * 이러한 유형의 코드는 올바른 JS 문법을 준수하므로 오류가 항상 런타임에서 발생하게 된다.
    * 반면, **TS의 타입 체커는 별도의 타입 구문 없이도 이러한 오류를 사전에 발견하여 해결책을 제안**한다.
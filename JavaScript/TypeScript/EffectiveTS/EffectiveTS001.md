# EffectiveTS
## 2022-11-12 Sat

### 특이한 TS의 특징
* TS는 사용 방식 측면에서 다음과 같은 이유로 다른 언어와는 차이를 보이는 특이한 언어이다.
    1. 인터프리터로 실행되지 않는다.
    2. **Java나 C 처럼 저수준 언어로 컴파일되지 않는 대신, 또 다른 고수준 언어인 JS로 컴파일**된다.
    3. TS 자체로 실행되지 못한다.
* 이러한 이유에서 TS는 JS와 뗄래야 뗄 수 없는 관계를 갖고, 때로는 이러한 연관성이 혼란을 주기도 한다.
    * 하지만 바꿔말하자면 이러한 TS와 JS의 밀접한 관계를 이해한다면 TS 개발자로서 한 단계 성장할 수 있게 된다.

### TS와 JS의 관계
```
> TS는 타입이 정의된, JS의 슈퍼셋이다.
> 바꿔 말해, JS는 TS의 부분집합이다.
```
* TS는 JS와 매우 밀접한 관계를 가지므로, 이러한 연관성을 정확히 이해하는 것은 매우 중요하다.
* TS와 JS는 각기 다른 확장자를 사용하지만, 이는 두 언어가 완전히 다름을 의미하지 않는다.
    * 예를 들어 **TS는 문법적으로도 JS의 슈퍼셋이므로, JS 애플리케이션에 문제가 없다면 이는 유효한 TS 애플리케이션**으로도 볼 수 있다.
    * 이러한 특징은 이미 JS로 작성된 코드를 TS로 마이그레이션 하는 과정에서 기존 코드를 유지하면서도 필요한 부분에만 TS를 적용할 수 있도록 지원한다.
* 상술한 바와 같이 모든 JS 애플리케이션은 TS 애플리케이션이기도 하지만, 그 역은 성립하지 않는다.
    * 이는 **TS가 JS에는 존재하지 않는 추가적인 문법을 갖기 때문**으로, TS 애플리케이션을 JS 런타임에서 바로 실행할 수는 없다.
    * 때문에 `:string`과 같은 타입 명시 구문을 사용하는 시점부터 JS로 작성된 애플리케이션은 TS의 영역에 들어서게 된다.
* 반면, **문법의 유효성과 런타임 상의 문제는 완전히 독립적인 문제**이다.
    * 이 경우에도 TS는 여전히 코드를 파싱하고, JS로 변환하는 작업을 적용할 수 있다.

### TS의 유용성
* TS 컴파일러는 타입 체커를 통해 일반적인 JS 애플리케이션에서도 유용하게 사용될 수 있다.
    * 예를 들어, TS의 타입 체커는 타입 추론을 통해 초기값으로부터 변수의 타입을 추론할 수 있다.
* 이렇듯 **타입 시스템의 목표 중 하나는 런타임에서 오류가 될만한 코드를 미리 찾아내는 것에 있으며, TS는 정적 타입 시스템으로서 이러한 특징을 갖는다**.
    * 그러나 아쉽게도 타입 체커는 모든 문제를 사전에 찾아낼 수 있는 것은 아니다.
* **JS의 경우 객체 프로퍼티를 참조하는 과정에서 발생한 undefined의 반환 등, 오류가 발생하지는 않지만 정상적으로 동작하지도 않는 코드가 발생하기 쉽다**.
    * 이러한 유형의 코드는 올바른 JS 문법을 준수하므로 오류가 항상 런타임에서 발생하게 된다.
    * 반면, **TS의 타입 체커는 별도의 타입 구문 없이도 이러한 오류를 사전에 발견하여 해결책을 제안**한다.

### 타입 구문 사용하기
* **TS에서는 타입 구문 없이도 많은 오류를 잡을 수 있으나, 타입 구문을 작성한다면 훨씬 더 많은 오류를 사전에 찾아낼 수 있다**.
    * 이는 명시적인 타입 구문을 통해 코드의 의도를 TS에게 알려줄 수 있기 때문이다.
    * 또한, **명시적인 타입 구문을 선언하는 경우 interface 또는 type 정의를 적극적으로 활용하는 것으로 코드의 의도를 더욱 더 명확히**할 수 있다.
    * 이렇듯 **TS 상에서 명시하는 타입 구문은 코드의 의도를 TS에게 명확히 드러내는 과정으로 이해**할 수도 있다.

### TS와 JS 런타임 동작 모델링
* **TS의 타입 시스템은 JS의 런타임 동작을 모델링하며, 런타임 오류가 될 법한 코드를 정상으로 인식하거나 정상 동작하는 코드를 오류 상황으로 표시**한다.
    * 이렇듯 **JS의 런타임 동작을 모델링하는 것은 TS 타입 시스템의 기본 원칙이자 핵심**이다.
    * 그러나 이 경우, 단순한 런타임 동작의 모델링뿐만 아니라 의도치 않은 코드가 오류로 이어질 수 있다는 점까지 충분히 고려하는 것이 바람직하다.
* **언제 JS 런타임의 동작을 그대로 모델링하여 언뜻 오류로 보이는 코드를 그대로 실행할지, 또는 타입 체크를 명확히할지 분명히 결정할 수 있어야 한다**.
    * 이렇듯 TS를 사용하는 것은 온전히 개발자의 선택에 달렸으며, JS의 이상한 동작을을 당연시하는 경우에는 차라리 TS를 사용하지 않는 것이 나을 수 있다.

### 런타임 오류의 가능성
* **TS에 의해 타입 체크를 통과했더라도, 여전히 런타임 상에서는 오류가 발생할 수 있다는 점을 이해하는 것이 바람직**하다.
    * 예를 들어 TS의 any 타입을 사용하는 경우에도 예상치 못한 오류가 자주 발생할 가능성이 존재한다.
    * 일견 TS의 타입 시스템이 정적 타입의 정확성을 항상 보장할 수 있을 것 같지만, 실제로는 그렇지 않으며 이는 타입 시스템의 목적과 부합하지도 않는다.

### JS와 TS의 관계 - 결론
* TS는 JS의 슈퍼셋이며, 모든 JS 애플리케이션은 이미 TS 애플리케이션이다.
    * 그러나, TS는 JS가 제공하지 않는 문법을 제공하므로 일반적으로 유효한 JS 애플리케이션이 아니다.
* TS는 JS 런타임의 동작을 모델링하는 타입 시스템을 가지며, 런타임 오류를 발생시킬 수 있는 코드를 가능한 한 찾아내려 한다.
    * 그러나 타입 체커를 통과했음에도 런타임에서 발생할 수 있는 오류 상황이 있으므로, 모든 오류를 사전에 찾아낼 수 있는 것은 아니다.
* **TS의 타입 시스템은 전반적으로 JS의 동작성을 모델링하지만, JS에서는 허용되는 반면 TS에서는 오류를 발생시키는 상황이 언제든지 존재할 수 있다**.
    * 그러나 **이러한 엄격함은 취향의 차이이며, JS의 간편한 사용성과 우열을 가릴 수는 없다**.

## 2022-11-13 Sun
### TS의 설정들
* TSC는 현 시점에서 매우 많은 설정을 가지며, 그 개수는 사실 상 100개에 이른다.
  * 이러한 설정들은 `--noImplicitAny`와 같이 CLI 기반 옵션으로 전달할 수 있는 반면, `tsconfig.json`에 명시할 수도 있다.
* **일반적으로는 TS를 어떻게 사용할지 동료와 다른 도구들에게 명확히 알려주는 tsconfig.json 설정 파일을 작성하는 것이 바람직**하다.
  * 이러한 TS 설정 파일은 `tsc --init` 명령어를 통해 간단하게 생성할 수 있다.
* TS가 제공하는 설정들은 대부분 소스 파일의 위치와, 어떤 종류의 출력을 생성할지 제어하는 내용으로 구성된다.
  * 그러나 언어 자체의 핵심적인 내용을 제어하는 고수준의 설정도 존재하며, 이러한 설정 방법에 따라서는 TS가 완전히 다른 언어처럼 느껴질 수도 있다.
* **여러 설정 중 가장 중요하면서도 명확한 이해가 필요한 것은 `noImplicitAny`와 `stringNullChecks`**이다.
  * 이 외에도 언어에 의미적으로 영향을 미치는 설정은 많지만, 상술한 두 옵션만큼 중요한 옵션은 없다.
  * 이러한 모든 체크를 설정하고자 하는 경우 `strict` 설정을 명시할 수 있으며, TS에 해당 옵션을 활성화할 경우 대부분의 오류를 찾아낼 수 있다.
* **TS 애플리케이션으로 협업하던 도중 에러가 재현되지 않는 경우, 우선 TSC 설정이 동일한지 반드시 확인해보는 것이 바람직**하다.

### noImplicitAny 설정
* **해당 설정은 변수들이 미리 정의된 타입을 가져야하는지 여부를 제어하며, 설정이 해제된 경우 암시적인 any 타입의 추론을 허용**한다.
* **any 타입을 허용할 경우 타입 체커를 사용하는 의미가 없으며, 일반적으로는 JS로 작성된 애플리케이션을 TS로 마이그레이션하는 경우에만 사용**해야 한다.
  * 이렇듯 **any 타입은 편리하지만 사용에는 반드시 큰 주의를 기울여야 한다**.
* 해당 옵션이 설정된 경우, 암시적으로 any 타입으로 추론되는 모든 경우에 대해 오류를 발생시킨다.
  * 이러한 오류들은 any 타입을 명시하거나 더 분명한 타입 구문을 작성하는 것으로 해결할 수 있다.
* **TS는 명확한 타입 정보를 가질수록 효과적이므로, 새로운 프로젝트를 시작하는 경우에는 가능한 한 해당 옵션을 활성화하는 것이 바람직**하다.
  * 이를 통해 TS는 더 많은 문제를 쉽게 발견하며, 코드의 가독성과 개발 생산성은 향상된다.

### stringNullChecks 설정
* **해당 설정은 null과 undefined가 모든 타입에서 허용되는지 확인하기 위해 명시하는 설정**이다.
  * **예를 들어, `const num: number = null;`이라는 코드는 해당 옵션이 해제된 경우에 유효**하다.
  * 반면 옵션을 활성화한 경우, null 형식을 number 형식에 할당할 수 없다는 오류가 발생한다.
  * 이는 undefined에 대해서도 마찬가지이며, null을 허용하고자 하는 경우에는 `const num: number | null = null;`과 같이 작성해야 한다.
* 반면, 해당 옵션 없이 코드 상에서 null을 허용하지 않으려 하는 경우에는 대상 변수의 값에 대해 null 여부를 체크하거나 `!.`와 같은 단언을 작성해야 한다.
* **해당 옵션은 null 및 undefined 관련 오류를 사전에 찾아내는 데에 지대한 도움을 주지만, 코드의 작성을 어렵게하는 단점이 수반**된다.
  * 때문에 가능하다면 해당 옵션을 활성화하되, TS 초심자이거나 JS 코드를 마이그레이션하는 도중에는 비활성화해두어도 무방하다.
  * 또한, **해당 옵션을 활성화하기 위해서는 noImplicitAny 옵션의 활성화가 전제**되어야 한다.
* 그러나 **해당 옵션을 비활성화할 경우, JS의 런타임에서 가장 마주치기 쉬운 `undefined는 객체가 아니다` 오류에 끊임없이 직면**하기 쉽다.
  * 결국은 이로 인해 옵션을 활성화할 수 밖에 없으며, **프로젝트가 커질수록 설정 변경은 어려워지므로 가능한 한 프로젝트 초기에 설정하는 것이 바람직**하다.

### TSC - 결론
* TSC는 언어의 핵심 요소에 영향을 주는 몇 가지 설정을 포함한다.
  * 이러한 설정은 CLI 기반의 옵션보다는 tsconfig.json으로 명시하는 것이 바람직하다.
* 일반적으로 **JS 애플리케이션을 TS로 마이그레이션하는 경우가 아니라면 noImplicitAny와 strictNullChecks 옵션을 설정하는 것이 바람직**하다.
  * 반면, TS 상에서 엄격한 체크를 적용하고자 하는 경우에는 strict 설정도 고려할 수 있다.
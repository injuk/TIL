# EffectiveTS
## 2022-11-12 Sat

### 특이한 TS의 특징
* TS는 사용 방식 측면에서 다음과 같은 이유로 다른 언어와는 차이를 보이는 특이한 언어이다.
    1. 인터프리터로 실행되지 않는다.
    2. **Java나 C 처럼 저수준 언어로 컴파일되지 않는 대신, 또 다른 고수준 언어인 JS로 컴파일**된다.
    3. TS 자체로 실행되지 못한다.
* 이러한 이유에서 TS는 JS와 뗄래야 뗄 수 없는 관계를 갖고, 때로는 이러한 연관성이 혼란을 주기도 한다.
    * 하지만 바꿔말하자면 이러한 TS와 JS의 밀접한 관계를 이해한다면 TS 개발자로서 한 단계 성장할 수 있게 된다.

### TS와 JS의 관계
```
> TS는 타입이 정의된, JS의 슈퍼셋이다.
> 바꿔 말해, JS는 TS의 부분집합이다.
```
* TS는 JS와 매우 밀접한 관계를 가지므로, 이러한 연관성을 정확히 이해하는 것은 매우 중요하다.
* TS와 JS는 각기 다른 확장자를 사용하지만, 이는 두 언어가 완전히 다름을 의미하지 않는다.
    * 예를 들어 **TS는 문법적으로도 JS의 슈퍼셋이므로, JS 애플리케이션에 문제가 없다면 이는 유효한 TS 애플리케이션**으로도 볼 수 있다.
    * 이러한 특징은 이미 JS로 작성된 코드를 TS로 마이그레이션 하는 과정에서 기존 코드를 유지하면서도 필요한 부분에만 TS를 적용할 수 있도록 지원한다.
* 상술한 바와 같이 모든 JS 애플리케이션은 TS 애플리케이션이기도 하지만, 그 역은 성립하지 않는다.
    * 이는 **TS가 JS에는 존재하지 않는 추가적인 문법을 갖기 때문**으로, TS 애플리케이션을 JS 런타임에서 바로 실행할 수는 없다.
    * 때문에 `:string`과 같은 타입 명시 구문을 사용하는 시점부터 JS로 작성된 애플리케이션은 TS의 영역에 들어서게 된다.
* 반면, **문법의 유효성과 런타임 상의 문제는 완전히 독립적인 문제**이다.
    * 이 경우에도 TS는 여전히 코드를 파싱하고, JS로 변환하는 작업을 적용할 수 있다.

### TS의 유용성
* TS 컴파일러는 타입 체커를 통해 일반적인 JS 애플리케이션에서도 유용하게 사용될 수 있다.
    * 예를 들어, TS의 타입 체커는 타입 추론을 통해 초기값으로부터 변수의 타입을 추론할 수 있다.
* 이렇듯 **타입 시스템의 목표 중 하나는 런타임에서 오류가 될만한 코드를 미리 찾아내는 것에 있으며, TS는 정적 타입 시스템으로서 이러한 특징을 갖는다**.
    * 그러나 아쉽게도 타입 체커는 모든 문제를 사전에 찾아낼 수 있는 것은 아니다.
* **JS의 경우 객체 프로퍼티를 참조하는 과정에서 발생한 undefined의 반환 등, 오류가 발생하지는 않지만 정상적으로 동작하지도 않는 코드가 발생하기 쉽다**.
    * 이러한 유형의 코드는 올바른 JS 문법을 준수하므로 오류가 항상 런타임에서 발생하게 된다.
    * 반면, **TS의 타입 체커는 별도의 타입 구문 없이도 이러한 오류를 사전에 발견하여 해결책을 제안**한다.

### 타입 구문 사용하기
* **TS에서는 타입 구문 없이도 많은 오류를 잡을 수 있으나, 타입 구문을 작성한다면 훨씬 더 많은 오류를 사전에 찾아낼 수 있다**.
    * 이는 명시적인 타입 구문을 통해 코드의 의도를 TS에게 알려줄 수 있기 때문이다.
    * 또한, **명시적인 타입 구문을 선언하는 경우 interface 또는 type 정의를 적극적으로 활용하는 것으로 코드의 의도를 더욱 더 명확히**할 수 있다.
    * 이렇듯 **TS 상에서 명시하는 타입 구문은 코드의 의도를 TS에게 명확히 드러내는 과정으로 이해**할 수도 있다.

### TS와 JS 런타임 동작 모델링
* **TS의 타입 시스템은 JS의 런타임 동작을 모델링하며, 런타임 오류가 될 법한 코드를 정상으로 인식하거나 정상 동작하는 코드를 오류 상황으로 표시**한다.
    * 이렇듯 **JS의 런타임 동작을 모델링하는 것은 TS 타입 시스템의 기본 원칙이자 핵심**이다.
    * 그러나 이 경우, 단순한 런타임 동작의 모델링뿐만 아니라 의도치 않은 코드가 오류로 이어질 수 있다는 점까지 충분히 고려하는 것이 바람직하다.
* **언제 JS 런타임의 동작을 그대로 모델링하여 언뜻 오류로 보이는 코드를 그대로 실행할지, 또는 타입 체크를 명확히할지 분명히 결정할 수 있어야 한다**.
    * 이렇듯 TS를 사용하는 것은 온전히 개발자의 선택에 달렸으며, JS의 이상한 동작을을 당연시하는 경우에는 차라리 TS를 사용하지 않는 것이 나을 수 있다.

### 런타임 오류의 가능성
* **TS에 의해 타입 체크를 통과했더라도, 여전히 런타임 상에서는 오류가 발생할 수 있다는 점을 이해하는 것이 바람직**하다.
    * 예를 들어 TS의 any 타입을 사용하는 경우에도 예상치 못한 오류가 자주 발생할 가능성이 존재한다.
    * 일견 TS의 타입 시스템이 정적 타입의 정확성을 항상 보장할 수 있을 것 같지만, 실제로는 그렇지 않으며 이는 타입 시스템의 목적과 부합하지도 않는다.

### JS와 TS의 관계 - 결론
* TS는 JS의 슈퍼셋이며, 모든 JS 애플리케이션은 이미 TS 애플리케이션이다.
    * 그러나, TS는 JS가 제공하지 않는 문법을 제공하므로 일반적으로 유효한 JS 애플리케이션이 아니다.
* TS는 JS 런타임의 동작을 모델링하는 타입 시스템을 가지며, 런타임 오류를 발생시킬 수 있는 코드를 가능한 한 찾아내려 한다.
    * 그러나 타입 체커를 통과했음에도 런타임에서 발생할 수 있는 오류 상황이 있으므로, 모든 오류를 사전에 찾아낼 수 있는 것은 아니다.
* **TS의 타입 시스템은 전반적으로 JS의 동작성을 모델링하지만, JS에서는 허용되는 반면 TS에서는 오류를 발생시키는 상황이 언제든지 존재할 수 있다**.
    * 그러나 **이러한 엄격함은 취향의 차이이며, JS의 간편한 사용성과 우열을 가릴 수는 없다**.

## 2022-11-13 Sun
### TS의 설정들
* TSC는 현 시점에서 매우 많은 설정을 가지며, 그 개수는 사실 상 100개에 이른다.
  * 이러한 설정들은 `--noImplicitAny`와 같이 CLI 기반 옵션으로 전달할 수 있는 반면, `tsconfig.json`에 명시할 수도 있다.
* **일반적으로는 TS를 어떻게 사용할지 동료와 다른 도구들에게 명확히 알려주는 tsconfig.json 설정 파일을 작성하는 것이 바람직**하다.
  * 이러한 TS 설정 파일은 `tsc --init` 명령어를 통해 간단하게 생성할 수 있다.
* TS가 제공하는 설정들은 대부분 소스 파일의 위치와, 어떤 종류의 출력을 생성할지 제어하는 내용으로 구성된다.
  * 그러나 언어 자체의 핵심적인 내용을 제어하는 고수준의 설정도 존재하며, 이러한 설정 방법에 따라서는 TS가 완전히 다른 언어처럼 느껴질 수도 있다.
* **여러 설정 중 가장 중요하면서도 명확한 이해가 필요한 것은 `noImplicitAny`와 `stringNullChecks`**이다.
  * 이 외에도 언어에 의미적으로 영향을 미치는 설정은 많지만, 상술한 두 옵션만큼 중요한 옵션은 없다.
  * 이러한 모든 체크를 설정하고자 하는 경우 `strict` 설정을 명시할 수 있으며, TS에 해당 옵션을 활성화할 경우 대부분의 오류를 찾아낼 수 있다.
* **TS 애플리케이션으로 협업하던 도중 에러가 재현되지 않는 경우, 우선 TSC 설정이 동일한지 반드시 확인해보는 것이 바람직**하다.

### noImplicitAny 설정
* **해당 설정은 변수들이 미리 정의된 타입을 가져야하는지 여부를 제어하며, 설정이 해제된 경우 암시적인 any 타입의 추론을 허용**한다.
* **any 타입을 허용할 경우 타입 체커를 사용하는 의미가 없으며, 일반적으로는 JS로 작성된 애플리케이션을 TS로 마이그레이션하는 경우에만 사용**해야 한다.
  * 이렇듯 **any 타입은 편리하지만 사용에는 반드시 큰 주의를 기울여야 한다**.
* 해당 옵션이 설정된 경우, 암시적으로 any 타입으로 추론되는 모든 경우에 대해 오류를 발생시킨다.
  * 이러한 오류들은 any 타입을 명시하거나 더 분명한 타입 구문을 작성하는 것으로 해결할 수 있다.
* **TS는 명확한 타입 정보를 가질수록 효과적이므로, 새로운 프로젝트를 시작하는 경우에는 가능한 한 해당 옵션을 활성화하는 것이 바람직**하다.
  * 이를 통해 TS는 더 많은 문제를 쉽게 발견하며, 코드의 가독성과 개발 생산성은 향상된다.

### stringNullChecks 설정
* **해당 설정은 null과 undefined가 모든 타입에서 허용되는지 확인하기 위해 명시하는 설정**이다.
  * **예를 들어, `const num: number = null;`이라는 코드는 해당 옵션이 해제된 경우에 유효**하다.
  * 반면 옵션을 활성화한 경우, null 형식을 number 형식에 할당할 수 없다는 오류가 발생한다.
  * 이는 undefined에 대해서도 마찬가지이며, null을 허용하고자 하는 경우에는 `const num: number | null = null;`과 같이 작성해야 한다.
* 반면, 해당 옵션 없이 코드 상에서 null을 허용하지 않으려 하는 경우에는 대상 변수의 값에 대해 null 여부를 체크하거나 `!.`와 같은 단언을 작성해야 한다.
* **해당 옵션은 null 및 undefined 관련 오류를 사전에 찾아내는 데에 지대한 도움을 주지만, 코드의 작성을 어렵게하는 단점이 수반**된다.
  * 때문에 가능하다면 해당 옵션을 활성화하되, TS 초심자이거나 JS 코드를 마이그레이션하는 도중에는 비활성화해두어도 무방하다.
  * 또한, **해당 옵션을 활성화하기 위해서는 noImplicitAny 옵션의 활성화가 전제**되어야 한다.
* 그러나 **해당 옵션을 비활성화할 경우, JS의 런타임에서 가장 마주치기 쉬운 `undefined는 객체가 아니다` 오류에 끊임없이 직면**하기 쉽다.
  * 결국은 이로 인해 옵션을 활성화할 수 밖에 없으며, **프로젝트가 커질수록 설정 변경은 어려워지므로 가능한 한 프로젝트 초기에 설정하는 것이 바람직**하다.

### TSC - 결론
* TSC는 언어의 핵심 요소에 영향을 주는 몇 가지 설정을 포함한다.
  * 이러한 설정은 CLI 기반의 옵션보다는 tsconfig.json으로 명시하는 것이 바람직하다.
* 일반적으로 **JS 애플리케이션을 TS로 마이그레이션하는 경우가 아니라면 noImplicitAny와 strictNullChecks 옵션을 설정하는 것이 바람직**하다.
  * 반면, TS 상에서 엄격한 체크를 적용하고자 하는 경우에는 strict 설정도 고려할 수 있다.

## 2022-11-14 Mon
### TSC의 역할
* TSC는 거시적으로 봤을 때 크게 다음과 같은 두 가지 역할을 수행한다.
  1. **최신 TS 또는 JS가 브라우저에서 동작할 수 있도록 구버전 JS로 트랜스파일** 한다.
  2. 코드 상에 존재하는 타입 오류를 체크한다.
* 이 때, **상술한 두 역할은 서로 완벽히 독립적이며 서로에게 영향을 주지 않는다**.
  * 이러한 사실을 토대로 두 역할을 되짚어 봤을 때, TS가 할 수 있는 일과 할 수 없는 일을 짐작해볼 수 있다.

### TS는 타입 오류가 있는 코드 역시 컴파일이 가능하다
* **TSC에 의한 컴파일은 타입 체크와는 완전히 독립적으로 동작하므로, 타입 오류가 있는 코드 역시 컴파일이 가능**하다.
  * 이는 C 또는 Java와 같이 타입 체크를 컴파일과 함께 처리하는 언어와는 다르며, TS의 오류는 오히려 이러한 언어들의 경고와 유사하다.
  * 때문에 **TS는 타입 오류가 존재하는 경우에 이를 경고하지만, 그로 인해 빌드를 중지하지는 않는다**.
* 컴파일과 타입 체크는 서로 다른 개념이며, 코드에 오류가 있는 경우에는 컴파일에 문제가 있다는 표현보다는 타입 체크에 문제가 있다고 지칭하는 것이 바람직하다.
  * 반면, 컴파일은 오직 코드 생성만을 가리키는 개념이다.
* 이러한 TS의 특징은 엉성한 언어처럼 보일 수 있지만, 코드에 오류가 있더라도 산출물이 존재하는 점은 트러블 슈팅에 도움이될 수 있다.
  * 예를 들어 문제의 원인이 된 오류를 수정하지 않았더라도 TS는 산출물을 생성하므로 여전히 애플리케이션의 다른 부분을 테스트할 수 있다.
  * 그러나 오류가 발생했을 때 컴파일을 수행하지 않고자 하는 경우, tsconfig.json에 noEmitOnError를 설정할 수 있다.

### TS는 런타임에서는 타입 체크가 불가능하다
* **TS의 타입은 제거 가능한 개념이며, 실제로도 JS로 컴파일되는 과정에서 모든 인터페이스나 타입 및 타입 구문은 제거**된다.
* 때문에 타입 추론을 명확히 처리하기 위해서는 떄로는 타입 정보를 런타임에서도 유지해야할 수 있다.
  1. 사용자가 명시한 type 또는 interface 대신 객체의 접근 가능한 속성을 기반으로 타입을 체크하도록 코드를 작성할 수 있다.
  2. type 또는 interface 자체에 포함되는 속성으로 구분할 수 있도록 태그를 정의할 수 있으며, 이는 런타임에 타입 정보를 손쉽게 유지할 수 있도록 한다.
  3. 또는 **런타임에 접근 불가능한 타입 정보와 접근 가능한 값을 둘 다 사용할 수 있도록 타입을 클래스로 정의**할 수도 있다.
* **TS의 interface는 타입으로만 사용 가능하지만, 이를 클래스로 선언하는 경우 타입과 값 모두로 사용할 수 있으므로 코드에 오류가 발생하지 않는다**.

### TS의 타입 연산은 런타임에 영향을 주지 않는다
* 예를 들어 문자열이거나 숫자인 값을 항상 number로 변환하는 코드를 가정할 경우, 다음과 같은 코드를 작성해볼 수 있다.
```typescript
function refineToNumber(param: string | number): number {
    return param as number;
}
```
* 그러나 이러한 코드는 실제로는 다음과 같은 JS 코드로 변환되며, 실제로는 아무런 변환 작업을 적용하지 않는다.
  * 이는 **TS의 `as number`문이 TS에서 제공하는 타입 연산이기 때문이며, 이는 JS 코드 상에서는 제거되어 런타임에 아무런 영향을 주지 못하기 때문**이다.
```javascript
function refineToNumber(param) {
    return param;
}
```
* 때문에 **값의 타입을 실제로도 변환하고자 하는 경우, 런타임 상의 타입을 반드시 체크하여 JS가 제공하는 연산을 통해 변환을 처리**해야 한다.

## 2022-11-15 Tue
### 런타임의 타입은 선언된 타입과는 달라질 수 있다
* 설령 함수가 boolean 매개변수를 받아 값에 따라 분기하여 동작하는 TS 애플리케이션의 경우에도 런타임에 다른 타입의 값이 전달될 가능성은 존재한다.
  * 이는 함수의 인자가 네트워크 등 외부로부터 전달된 값을 받아 실행되는 경우를 예로 들 수 있다.
* 이렇듯 **TS 상에서는 런타임의 타입과 컴파일 시점의 타입이 일치하지 않을 수 있다는 점을 반드시 명심**해야 한다.
  * 또한, 타입이 달라질 수 있는 혼란스러운 상황은 가능한 한 피해야 한다.

### TS의 타입으로는 함수를 오버로드할 수 없다
* C++ 등의 언어는 동일한 이름을 갖지만 메소드 시그니쳐는 다른 여러 버전의 함수를 허용하며, 이를 함수 오버로딩이라고 지칭한다.
* 반면 **TS의 경우, 타입과 런타임 시점의 동작은 무관하므로 함수 오버로딩은 근본적으로 불가능**하다.
  * **TS가 제공하는 함수 오버로딩은 온전히 타입 수준에서만 동작하며, 하나의 함수에 대해 여러 시그니쳐를 작성하더라도 구현체는 오직 하나만 존재**할 수 있다.
  * 이 경우, **함수의 오버로딩은 단지 서로 다른 종류의 타입 정보를 제공하기 위해서만 정의되므로 JS로 변환되는 과정에서는 제거**된다.

### TS 타입 구문은 런타임 성능에는 영향을 주지 않는다.
* **TS의 타입과 타입 연산자는 JS로 변환되는 과정에서 모두 제거되므로, 런타임 성능에는 전혀 영향을 주지 않는다**.
  * 실제로도 TS의 정적 타입은 비용이 전혀 들지 않는다.
* 반면, **이렇듯 런타임 오버헤드가 없는 대신 TSC에는 빌드타임 오버헤드가 존재**한다.
  * 그러나 TS 개발 팀은 컴파일러 성능을 매우 중요하게 생각하였기에 컴파일은 일반적으로 빠르며, 특히 증분 빌드시에 더욱 그렇다.
  * 그럼에도 **빌드타임 오버헤드가 너무 커졌다고 판단되는 경우에는 빌드 도구로부터 트랜스파일만 진행하는 옵션을 활성화하여 타입 체크를 생략**할 수 있다.
* 또한, **TS가 컴파일하는 코드는 오래된 런타임 환경을 지원하기 위해 호환성을 높이고 성능 오버헤드를 감안할지 결정해야하는 문제와 마주할 수도 있다**.
  * 예를 들어 제너레이터 함수를 ES5 타겟으로 컴파일하는 경우가 이에 해당한다.
  * 그러나 **어떠한 경우에서든지 호환성과 성능 사이의 선택은 컴파일 타겟 버전과 언어 차원의 문제이며, 여전히 TS의 타입과는 무관**하다.

### 코드 생성과 타입의 관계 - 결론
* **코드의 생성은 타입 시스템과는 무관하며, TS의 타입은 런타임 동작성이나 성능에 아무런 영향을 주지 못한다**.
* 타입 오류가 존재하는 TS 애플리케이션이라도 컴파일을 통한 코드의 생성은 가능하다.
* TS의 타입 구문은 런타임에 사용할 수 없으며, 런타임에 타입을 지정하려면 타입 정보를 유지하기 위한 별도의 방법을 적용해야 한다.
  * 예를 들어 **태그된 유니온 또는 속성 체크 방식, 나아가 TS 타입과 런타임 값을 모두 제공할 수 있는 클래스를 사용**할 수 있다.
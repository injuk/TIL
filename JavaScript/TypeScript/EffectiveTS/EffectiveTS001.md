# EffectiveTS
## 2022-11-12 Sat

### 특이한 TS의 특징
* TS는 사용 방식 측면에서 다음과 같은 이유로 다른 언어와는 차이를 보이는 특이한 언어이다.
    1. 인터프리터로 실행되지 않는다.
    2. **Java나 C 처럼 저수준 언어로 컴파일되지 않는 대신, 또 다른 고수준 언어인 JS로 컴파일**된다.
    3. TS 자체로 실행되지 못한다.
* 이러한 이유에서 TS는 JS와 뗄래야 뗄 수 없는 관계를 갖고, 때로는 이러한 연관성이 혼란을 주기도 한다.
    * 하지만 바꿔말하자면 이러한 TS와 JS의 밀접한 관계를 이해한다면 TS 개발자로서 한 단계 성장할 수 있게 된다.

### TS와 JS의 관계
```
> TS는 타입이 정의된, JS의 슈퍼셋이다.
> 바꿔 말해, JS는 TS의 부분집합이다.
```
* TS는 JS와 매우 밀접한 관계를 가지므로, 이러한 연관성을 정확히 이해하는 것은 매우 중요하다.
* TS와 JS는 각기 다른 확장자를 사용하지만, 이는 두 언어가 완전히 다름을 의미하지 않는다.
    * 예를 들어 **TS는 문법적으로도 JS의 슈퍼셋이므로, JS 애플리케이션에 문제가 없다면 이는 유효한 TS 애플리케이션**으로도 볼 수 있다.
    * 이러한 특징은 이미 JS로 작성된 코드를 TS로 마이그레이션 하는 과정에서 기존 코드를 유지하면서도 필요한 부분에만 TS를 적용할 수 있도록 지원한다.
* 상술한 바와 같이 모든 JS 애플리케이션은 TS 애플리케이션이기도 하지만, 그 역은 성립하지 않는다.
    * 이는 **TS가 JS에는 존재하지 않는 추가적인 문법을 갖기 때문**으로, TS 애플리케이션을 JS 런타임에서 바로 실행할 수는 없다.
    * 때문에 `:string`과 같은 타입 명시 구문을 사용하는 시점부터 JS로 작성된 애플리케이션은 TS의 영역에 들어서게 된다.
* 반면, **문법의 유효성과 런타임 상의 문제는 완전히 독립적인 문제**이다.
    * 이 경우에도 TS는 여전히 코드를 파싱하고, JS로 변환하는 작업을 적용할 수 있다.

### TS의 유용성
* TS 컴파일러는 타입 체커를 통해 일반적인 JS 애플리케이션에서도 유용하게 사용될 수 있다.
    * 예를 들어, TS의 타입 체커는 타입 추론을 통해 초기값으로부터 변수의 타입을 추론할 수 있다.
* 이렇듯 **타입 시스템의 목표 중 하나는 런타임에서 오류가 될만한 코드를 미리 찾아내는 것에 있으며, TS는 정적 타입 시스템으로서 이러한 특징을 갖는다**.
    * 그러나 아쉽게도 타입 체커는 모든 문제를 사전에 찾아낼 수 있는 것은 아니다.
* **JS의 경우 객체 프로퍼티를 참조하는 과정에서 발생한 undefined의 반환 등, 오류가 발생하지는 않지만 정상적으로 동작하지도 않는 코드가 발생하기 쉽다**.
    * 이러한 유형의 코드는 올바른 JS 문법을 준수하므로 오류가 항상 런타임에서 발생하게 된다.
    * 반면, **TS의 타입 체커는 별도의 타입 구문 없이도 이러한 오류를 사전에 발견하여 해결책을 제안**한다.

### 타입 구문 사용하기
* **TS에서는 타입 구문 없이도 많은 오류를 잡을 수 있으나, 타입 구문을 작성한다면 훨씬 더 많은 오류를 사전에 찾아낼 수 있다**.
    * 이는 명시적인 타입 구문을 통해 코드의 의도를 TS에게 알려줄 수 있기 때문이다.
    * 또한, **명시적인 타입 구문을 선언하는 경우 interface 또는 type 정의를 적극적으로 활용하는 것으로 코드의 의도를 더욱 더 명확히**할 수 있다.
    * 이렇듯 **TS 상에서 명시하는 타입 구문은 코드의 의도를 TS에게 명확히 드러내는 과정으로 이해**할 수도 있다.

### TS와 JS 런타임 동작 모델링
* **TS의 타입 시스템은 JS의 런타임 동작을 모델링하며, 런타임 오류가 될 법한 코드를 정상으로 인식하거나 정상 동작하는 코드를 오류 상황으로 표시**한다.
    * 이렇듯 **JS의 런타임 동작을 모델링하는 것은 TS 타입 시스템의 기본 원칙이자 핵심**이다.
    * 그러나 이 경우, 단순한 런타임 동작의 모델링뿐만 아니라 의도치 않은 코드가 오류로 이어질 수 있다는 점까지 충분히 고려하는 것이 바람직하다.
* **언제 JS 런타임의 동작을 그대로 모델링하여 언뜻 오류로 보이는 코드를 그대로 실행할지, 또는 타입 체크를 명확히할지 분명히 결정할 수 있어야 한다**.
    * 이렇듯 TS를 사용하는 것은 온전히 개발자의 선택에 달렸으며, JS의 이상한 동작을을 당연시하는 경우에는 차라리 TS를 사용하지 않는 것이 나을 수 있다.

### 런타임 오류의 가능성
* **TS에 의해 타입 체크를 통과했더라도, 여전히 런타임 상에서는 오류가 발생할 수 있다는 점을 이해하는 것이 바람직**하다.
    * 예를 들어 TS의 any 타입을 사용하는 경우에도 예상치 못한 오류가 자주 발생할 가능성이 존재한다.
    * 일견 TS의 타입 시스템이 정적 타입의 정확성을 항상 보장할 수 있을 것 같지만, 실제로는 그렇지 않으며 이는 타입 시스템의 목적과 부합하지도 않는다.

### JS와 TS의 관계 - 결론
* TS는 JS의 슈퍼셋이며, 모든 JS 애플리케이션은 이미 TS 애플리케이션이다.
    * 그러나, TS는 JS가 제공하지 않는 문법을 제공하므로 일반적으로 유효한 JS 애플리케이션이 아니다.
* TS는 JS 런타임의 동작을 모델링하는 타입 시스템을 가지며, 런타임 오류를 발생시킬 수 있는 코드를 가능한 한 찾아내려 한다.
    * 그러나 타입 체커를 통과했음에도 런타임에서 발생할 수 있는 오류 상황이 있으므로, 모든 오류를 사전에 찾아낼 수 있는 것은 아니다.
* **TS의 타입 시스템은 전반적으로 JS의 동작성을 모델링하지만, JS에서는 허용되는 반면 TS에서는 오류를 발생시키는 상황이 언제든지 존재할 수 있다**.
    * 그러나 **이러한 엄격함은 취향의 차이이며, JS의 간편한 사용성과 우열을 가릴 수는 없다**.
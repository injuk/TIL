# EffectiveTS
## 2022-11-12 Sat

### 특이한 TS의 특징
* TS는 사용 방식 측면에서 다음과 같은 이유로 다른 언어와는 차이를 보이는 특이한 언어이다.
    1. 인터프리터로 실행되지 않는다.
    2. **Java나 C 처럼 저수준 언어로 컴파일되지 않는 대신, 또 다른 고수준 언어인 JS로 컴파일**된다.
    3. TS 자체로 실행되지 못한다.
* 이러한 이유에서 TS는 JS와 뗄래야 뗄 수 없는 관계를 갖고, 때로는 이러한 연관성이 혼란을 주기도 한다.
    * 하지만 바꿔말하자면 이러한 TS와 JS의 밀접한 관계를 이해한다면 TS 개발자로서 한 단계 성장할 수 있게 된다.

### TS와 JS의 관계
```
> TS는 타입이 정의된, JS의 슈퍼셋이다.
> 바꿔 말해, JS는 TS의 부분집합이다.
```
* TS는 JS와 매우 밀접한 관계를 가지므로, 이러한 연관성을 정확히 이해하는 것은 매우 중요하다.
* TS와 JS는 각기 다른 확장자를 사용하지만, 이는 두 언어가 완전히 다름을 의미하지 않는다.
    * 예를 들어 **TS는 문법적으로도 JS의 슈퍼셋이므로, JS 애플리케이션에 문제가 없다면 이는 유효한 TS 애플리케이션**으로도 볼 수 있다.
    * 이러한 특징은 이미 JS로 작성된 코드를 TS로 마이그레이션 하는 과정에서 기존 코드를 유지하면서도 필요한 부분에만 TS를 적용할 수 있도록 지원한다.
* 상술한 바와 같이 모든 JS 애플리케이션은 TS 애플리케이션이기도 하지만, 그 역은 성립하지 않는다.
    * 이는 **TS가 JS에는 존재하지 않는 추가적인 문법을 갖기 때문**으로, TS 애플리케이션을 JS 런타임에서 바로 실행할 수는 없다.
    * 때문에 `:string`과 같은 타입 명시 구문을 사용하는 시점부터 JS로 작성된 애플리케이션은 TS의 영역에 들어서게 된다.
* 반면, **문법의 유효성과 런타임 상의 문제는 완전히 독립적인 문제**이다.
    * 이 경우에도 TS는 여전히 코드를 파싱하고, JS로 변환하는 작업을 적용할 수 있다.

### TS의 유용성
* TS 컴파일러는 타입 체커를 통해 일반적인 JS 애플리케이션에서도 유용하게 사용될 수 있다.
    * 예를 들어, TS의 타입 체커는 타입 추론을 통해 초기값으로부터 변수의 타입을 추론할 수 있다.
* 이렇듯 **타입 시스템의 목표 중 하나는 런타임에서 오류가 될만한 코드를 미리 찾아내는 것에 있으며, TS는 정적 타입 시스템으로서 이러한 특징을 갖는다**.
    * 그러나 아쉽게도 타입 체커는 모든 문제를 사전에 찾아낼 수 있는 것은 아니다.
* **JS의 경우 객체 프로퍼티를 참조하는 과정에서 발생한 undefined의 반환 등, 오류가 발생하지는 않지만 정상적으로 동작하지도 않는 코드가 발생하기 쉽다**.
    * 이러한 유형의 코드는 올바른 JS 문법을 준수하므로 오류가 항상 런타임에서 발생하게 된다.
    * 반면, **TS의 타입 체커는 별도의 타입 구문 없이도 이러한 오류를 사전에 발견하여 해결책을 제안**한다.

### 타입 구문 사용하기
* **TS에서는 타입 구문 없이도 많은 오류를 잡을 수 있으나, 타입 구문을 작성한다면 훨씬 더 많은 오류를 사전에 찾아낼 수 있다**.
    * 이는 명시적인 타입 구문을 통해 코드의 의도를 TS에게 알려줄 수 있기 때문이다.
    * 또한, **명시적인 타입 구문을 선언하는 경우 interface 또는 type 정의를 적극적으로 활용하는 것으로 코드의 의도를 더욱 더 명확히**할 수 있다.
    * 이렇듯 **TS 상에서 명시하는 타입 구문은 코드의 의도를 TS에게 명확히 드러내는 과정으로 이해**할 수도 있다.

### TS와 JS 런타임 동작 모델링
* **TS의 타입 시스템은 JS의 런타임 동작을 모델링하며, 런타임 오류가 될 법한 코드를 정상으로 인식하거나 정상 동작하는 코드를 오류 상황으로 표시**한다.
    * 이렇듯 **JS의 런타임 동작을 모델링하는 것은 TS 타입 시스템의 기본 원칙이자 핵심**이다.
    * 그러나 이 경우, 단순한 런타임 동작의 모델링뿐만 아니라 의도치 않은 코드가 오류로 이어질 수 있다는 점까지 충분히 고려하는 것이 바람직하다.
* **언제 JS 런타임의 동작을 그대로 모델링하여 언뜻 오류로 보이는 코드를 그대로 실행할지, 또는 타입 체크를 명확히할지 분명히 결정할 수 있어야 한다**.
    * 이렇듯 TS를 사용하는 것은 온전히 개발자의 선택에 달렸으며, JS의 이상한 동작을을 당연시하는 경우에는 차라리 TS를 사용하지 않는 것이 나을 수 있다.

### 런타임 오류의 가능성
* **TS에 의해 타입 체크를 통과했더라도, 여전히 런타임 상에서는 오류가 발생할 수 있다는 점을 이해하는 것이 바람직**하다.
    * 예를 들어 TS의 any 타입을 사용하는 경우에도 예상치 못한 오류가 자주 발생할 가능성이 존재한다.
    * 일견 TS의 타입 시스템이 정적 타입의 정확성을 항상 보장할 수 있을 것 같지만, 실제로는 그렇지 않으며 이는 타입 시스템의 목적과 부합하지도 않는다.

### JS와 TS의 관계 - 결론
* TS는 JS의 슈퍼셋이며, 모든 JS 애플리케이션은 이미 TS 애플리케이션이다.
    * 그러나, TS는 JS가 제공하지 않는 문법을 제공하므로 일반적으로 유효한 JS 애플리케이션이 아니다.
* TS는 JS 런타임의 동작을 모델링하는 타입 시스템을 가지며, 런타임 오류를 발생시킬 수 있는 코드를 가능한 한 찾아내려 한다.
    * 그러나 타입 체커를 통과했음에도 런타임에서 발생할 수 있는 오류 상황이 있으므로, 모든 오류를 사전에 찾아낼 수 있는 것은 아니다.
* **TS의 타입 시스템은 전반적으로 JS의 동작성을 모델링하지만, JS에서는 허용되는 반면 TS에서는 오류를 발생시키는 상황이 언제든지 존재할 수 있다**.
    * 그러나 **이러한 엄격함은 취향의 차이이며, JS의 간편한 사용성과 우열을 가릴 수는 없다**.

## 2022-11-13 Sun
### TS의 설정들
* TSC는 현 시점에서 매우 많은 설정을 가지며, 그 개수는 사실 상 100개에 이른다.
  * 이러한 설정들은 `--noImplicitAny`와 같이 CLI 기반 옵션으로 전달할 수 있는 반면, `tsconfig.json`에 명시할 수도 있다.
* **일반적으로는 TS를 어떻게 사용할지 동료와 다른 도구들에게 명확히 알려주는 tsconfig.json 설정 파일을 작성하는 것이 바람직**하다.
  * 이러한 TS 설정 파일은 `tsc --init` 명령어를 통해 간단하게 생성할 수 있다.
* TS가 제공하는 설정들은 대부분 소스 파일의 위치와, 어떤 종류의 출력을 생성할지 제어하는 내용으로 구성된다.
  * 그러나 언어 자체의 핵심적인 내용을 제어하는 고수준의 설정도 존재하며, 이러한 설정 방법에 따라서는 TS가 완전히 다른 언어처럼 느껴질 수도 있다.
* **여러 설정 중 가장 중요하면서도 명확한 이해가 필요한 것은 `noImplicitAny`와 `stringNullChecks`**이다.
  * 이 외에도 언어에 의미적으로 영향을 미치는 설정은 많지만, 상술한 두 옵션만큼 중요한 옵션은 없다.
  * 이러한 모든 체크를 설정하고자 하는 경우 `strict` 설정을 명시할 수 있으며, TS에 해당 옵션을 활성화할 경우 대부분의 오류를 찾아낼 수 있다.
* **TS 애플리케이션으로 협업하던 도중 에러가 재현되지 않는 경우, 우선 TSC 설정이 동일한지 반드시 확인해보는 것이 바람직**하다.

### noImplicitAny 설정
* **해당 설정은 변수들이 미리 정의된 타입을 가져야하는지 여부를 제어하며, 설정이 해제된 경우 암시적인 any 타입의 추론을 허용**한다.
* **any 타입을 허용할 경우 타입 체커를 사용하는 의미가 없으며, 일반적으로는 JS로 작성된 애플리케이션을 TS로 마이그레이션하는 경우에만 사용**해야 한다.
  * 이렇듯 **any 타입은 편리하지만 사용에는 반드시 큰 주의를 기울여야 한다**.
* 해당 옵션이 설정된 경우, 암시적으로 any 타입으로 추론되는 모든 경우에 대해 오류를 발생시킨다.
  * 이러한 오류들은 any 타입을 명시하거나 더 분명한 타입 구문을 작성하는 것으로 해결할 수 있다.
* **TS는 명확한 타입 정보를 가질수록 효과적이므로, 새로운 프로젝트를 시작하는 경우에는 가능한 한 해당 옵션을 활성화하는 것이 바람직**하다.
  * 이를 통해 TS는 더 많은 문제를 쉽게 발견하며, 코드의 가독성과 개발 생산성은 향상된다.

### stringNullChecks 설정
* **해당 설정은 null과 undefined가 모든 타입에서 허용되는지 확인하기 위해 명시하는 설정**이다.
  * **예를 들어, `const num: number = null;`이라는 코드는 해당 옵션이 해제된 경우에 유효**하다.
  * 반면 옵션을 활성화한 경우, null 형식을 number 형식에 할당할 수 없다는 오류가 발생한다.
  * 이는 undefined에 대해서도 마찬가지이며, null을 허용하고자 하는 경우에는 `const num: number | null = null;`과 같이 작성해야 한다.
* 반면, 해당 옵션 없이 코드 상에서 null을 허용하지 않으려 하는 경우에는 대상 변수의 값에 대해 null 여부를 체크하거나 `!.`와 같은 단언을 작성해야 한다.
* **해당 옵션은 null 및 undefined 관련 오류를 사전에 찾아내는 데에 지대한 도움을 주지만, 코드의 작성을 어렵게하는 단점이 수반**된다.
  * 때문에 가능하다면 해당 옵션을 활성화하되, TS 초심자이거나 JS 코드를 마이그레이션하는 도중에는 비활성화해두어도 무방하다.
  * 또한, **해당 옵션을 활성화하기 위해서는 noImplicitAny 옵션의 활성화가 전제**되어야 한다.
* 그러나 **해당 옵션을 비활성화할 경우, JS의 런타임에서 가장 마주치기 쉬운 `undefined는 객체가 아니다` 오류에 끊임없이 직면**하기 쉽다.
  * 결국은 이로 인해 옵션을 활성화할 수 밖에 없으며, **프로젝트가 커질수록 설정 변경은 어려워지므로 가능한 한 프로젝트 초기에 설정하는 것이 바람직**하다.

### TSC - 결론
* TSC는 언어의 핵심 요소에 영향을 주는 몇 가지 설정을 포함한다.
  * 이러한 설정은 CLI 기반의 옵션보다는 tsconfig.json으로 명시하는 것이 바람직하다.
* 일반적으로 **JS 애플리케이션을 TS로 마이그레이션하는 경우가 아니라면 noImplicitAny와 strictNullChecks 옵션을 설정하는 것이 바람직**하다.
  * 반면, TS 상에서 엄격한 체크를 적용하고자 하는 경우에는 strict 설정도 고려할 수 있다.

## 2022-11-14 Mon
### TSC의 역할
* TSC는 거시적으로 봤을 때 크게 다음과 같은 두 가지 역할을 수행한다.
  1. **최신 TS 또는 JS가 브라우저에서 동작할 수 있도록 구버전 JS로 트랜스파일** 한다.
  2. 코드 상에 존재하는 타입 오류를 체크한다.
* 이 때, **상술한 두 역할은 서로 완벽히 독립적이며 서로에게 영향을 주지 않는다**.
  * 이러한 사실을 토대로 두 역할을 되짚어 봤을 때, TS가 할 수 있는 일과 할 수 없는 일을 짐작해볼 수 있다.

### TS는 타입 오류가 있는 코드 역시 컴파일이 가능하다
* **TSC에 의한 컴파일은 타입 체크와는 완전히 독립적으로 동작하므로, 타입 오류가 있는 코드 역시 컴파일이 가능**하다.
  * 이는 C 또는 Java와 같이 타입 체크를 컴파일과 함께 처리하는 언어와는 다르며, TS의 오류는 오히려 이러한 언어들의 경고와 유사하다.
  * 때문에 **TS는 타입 오류가 존재하는 경우에 이를 경고하지만, 그로 인해 빌드를 중지하지는 않는다**.
* 컴파일과 타입 체크는 서로 다른 개념이며, 코드에 오류가 있는 경우에는 컴파일에 문제가 있다는 표현보다는 타입 체크에 문제가 있다고 지칭하는 것이 바람직하다.
  * 반면, 컴파일은 오직 코드 생성만을 가리키는 개념이다.
* 이러한 TS의 특징은 엉성한 언어처럼 보일 수 있지만, 코드에 오류가 있더라도 산출물이 존재하는 점은 트러블 슈팅에 도움이될 수 있다.
  * 예를 들어 문제의 원인이 된 오류를 수정하지 않았더라도 TS는 산출물을 생성하므로 여전히 애플리케이션의 다른 부분을 테스트할 수 있다.
  * 그러나 오류가 발생했을 때 컴파일을 수행하지 않고자 하는 경우, tsconfig.json에 noEmitOnError를 설정할 수 있다.

### TS는 런타임에서는 타입 체크가 불가능하다
* **TS의 타입은 제거 가능한 개념이며, 실제로도 JS로 컴파일되는 과정에서 모든 인터페이스나 타입 및 타입 구문은 제거**된다.
* 때문에 타입 추론을 명확히 처리하기 위해서는 떄로는 타입 정보를 런타임에서도 유지해야할 수 있다.
  1. 사용자가 명시한 type 또는 interface 대신 객체의 접근 가능한 속성을 기반으로 타입을 체크하도록 코드를 작성할 수 있다.
  2. type 또는 interface 자체에 포함되는 속성으로 구분할 수 있도록 태그를 정의할 수 있으며, 이는 런타임에 타입 정보를 손쉽게 유지할 수 있도록 한다.
  3. 또는 **런타임에 접근 불가능한 타입 정보와 접근 가능한 값을 둘 다 사용할 수 있도록 타입을 클래스로 정의**할 수도 있다.
* **TS의 interface는 타입으로만 사용 가능하지만, 이를 클래스로 선언하는 경우 타입과 값 모두로 사용할 수 있으므로 코드에 오류가 발생하지 않는다**.

### TS의 타입 연산은 런타임에 영향을 주지 않는다
* 예를 들어 문자열이거나 숫자인 값을 항상 number로 변환하는 코드를 가정할 경우, 다음과 같은 코드를 작성해볼 수 있다.
```typescript
function refineToNumber(param: string | number): number {
    return param as number;
}
```
* 그러나 이러한 코드는 실제로는 다음과 같은 JS 코드로 변환되며, 실제로는 아무런 변환 작업을 적용하지 않는다.
  * 이는 **TS의 `as number`문이 TS에서 제공하는 타입 연산이기 때문이며, 이는 JS 코드 상에서는 제거되어 런타임에 아무런 영향을 주지 못하기 때문**이다.
```javascript
function refineToNumber(param) {
    return param;
}
```
* 때문에 **값의 타입을 실제로도 변환하고자 하는 경우, 런타임 상의 타입을 반드시 체크하여 JS가 제공하는 연산을 통해 변환을 처리**해야 한다.

## 2022-11-15 Tue
### 런타임의 타입은 선언된 타입과는 달라질 수 있다
* 설령 함수가 boolean 매개변수를 받아 값에 따라 분기하여 동작하는 TS 애플리케이션의 경우에도 런타임에 다른 타입의 값이 전달될 가능성은 존재한다.
  * 이는 함수의 인자가 네트워크 등 외부로부터 전달된 값을 받아 실행되는 경우를 예로 들 수 있다.
* 이렇듯 **TS 상에서는 런타임의 타입과 컴파일 시점의 타입이 일치하지 않을 수 있다는 점을 반드시 명심**해야 한다.
  * 또한, 타입이 달라질 수 있는 혼란스러운 상황은 가능한 한 피해야 한다.

### TS의 타입으로는 함수를 오버로드할 수 없다
* C++ 등의 언어는 동일한 이름을 갖지만 메소드 시그니쳐는 다른 여러 버전의 함수를 허용하며, 이를 함수 오버로딩이라고 지칭한다.
* 반면 **TS의 경우, 타입과 런타임 시점의 동작은 무관하므로 함수 오버로딩은 근본적으로 불가능**하다.
  * **TS가 제공하는 함수 오버로딩은 온전히 타입 수준에서만 동작하며, 하나의 함수에 대해 여러 시그니쳐를 작성하더라도 구현체는 오직 하나만 존재**할 수 있다.
  * 이 경우, **함수의 오버로딩은 단지 서로 다른 종류의 타입 정보를 제공하기 위해서만 정의되므로 JS로 변환되는 과정에서는 제거**된다.

### TS 타입 구문은 런타임 성능에는 영향을 주지 않는다.
* **TS의 타입과 타입 연산자는 JS로 변환되는 과정에서 모두 제거되므로, 런타임 성능에는 전혀 영향을 주지 않는다**.
  * 실제로도 TS의 정적 타입은 비용이 전혀 들지 않는다.
* 반면, **이렇듯 런타임 오버헤드가 없는 대신 TSC에는 빌드타임 오버헤드가 존재**한다.
  * 그러나 TS 개발 팀은 컴파일러 성능을 매우 중요하게 생각하였기에 컴파일은 일반적으로 빠르며, 특히 증분 빌드시에 더욱 그렇다.
  * 그럼에도 **빌드타임 오버헤드가 너무 커졌다고 판단되는 경우에는 빌드 도구로부터 트랜스파일만 진행하는 옵션을 활성화하여 타입 체크를 생략**할 수 있다.
* 또한, **TS가 컴파일하는 코드는 오래된 런타임 환경을 지원하기 위해 호환성을 높이고 성능 오버헤드를 감안할지 결정해야하는 문제와 마주할 수도 있다**.
  * 예를 들어 제너레이터 함수를 ES5 타겟으로 컴파일하는 경우가 이에 해당한다.
  * 그러나 **어떠한 경우에서든지 호환성과 성능 사이의 선택은 컴파일 타겟 버전과 언어 차원의 문제이며, 여전히 TS의 타입과는 무관**하다.

### 코드 생성과 타입의 관계 - 결론
* **코드의 생성은 타입 시스템과는 무관하며, TS의 타입은 런타임 동작성이나 성능에 아무런 영향을 주지 못한다**.
* 타입 오류가 존재하는 TS 애플리케이션이라도 컴파일을 통한 코드의 생성은 가능하다.
* TS의 타입 구문은 런타임에 사용할 수 없으며, 런타임에 타입을 지정하려면 타입 정보를 유지하기 위한 별도의 방법을 적용해야 한다.
  * 예를 들어 **태그된 유니온 또는 속성 체크 방식, 나아가 TS 타입과 런타임 값을 모두 제공할 수 있는 클래스를 사용**할 수 있다.

### TS와 구조적 타이핑
* JS는 본질적으로 덕 타이핑 기반의 언어이며, 함수는 매개변수의 값이 적절히 주어진다면 값의 출처를 따지지 않고 실행된다.
  * **TS 역시 이러한 동작을 그대로 모델링하지만, 타입 체커의 이해도가 개발자와 달라 때로는 예상치 못한 결과를 낳을 수 있다**.
  * 그러나 구조적 타이핑을 명확히 이해한다면 정말 오류인 경우와 오류가 아닌 경우의 차이를 이해하고, 더욱 견고한 코드를 작성할 수 있게 된다.
* 다음과 같은 코드에서, 두 인터페이스 A와 B 사이에 전혀 관계가 없음에도 코드는 정상적으로 동작한다.
  * 이 경우, A 타입을 매개 변수로 전달 받는 함수에 B를 사용할 수 있으며 별도의 함수를 작성할 필요가 없다.
  * **이는 인터페이스 B의 구조가 인터페이스 A의 구조와 호환되기 때문이며, 여기서 구조적 타이핑이라는 개념이 등장**한다.
  * 즉, 아래의 예제는 **구조적 타이핑 관점에서 두 인터페이스가 서로 호환된다고 볼 수 있다**.
```typescript
interface A {
    name: string;
    age: number;
}
const concreteA: A = { name: 'a', age: 0 };

interface B {
    name: string;
    age: number;
    alias: string;
}
const concreteB: B = { name: 'b', age: 1, alias: 'T.H.E.B' };

function showA(a: A): void {
    console.log(a.name);
    console.log(a.age);
}

showA(concreteA);
showA(concreteB); // 정상적으로 실행된다!
```
* 상술한 바와 같이 **구조적 타이핑 관점에서 호환되는 타입을 함수로 전달하는 경우 타입 체커는 이를 문제로 인식하지 않으며, 오류 역시 발생하지 않는다**.
* 다음과 같은 간단한 클래스의 경우에도 구조적 타이핑으로 인해 당황한 결과를 마주할 수도 있다.
  * **이는 구조적으로 객체 temp2가 Object.prototype으로부터 비롯된 생성자와 클래스의 조건을 만족하는 필드인 name을 갖기 때문에 가능**하다.
  * 이는 매개변수에 타입을 엄격하게 선언하여 클래스를 보장하는 C++ 또는 Java와 같은 언어와 비교했을 때 매우 큰 차이점이 된다.
```typescript
class Temp {
  name: string;
  constructor(name: string) {
    this.name = name;
  }
}

const temp1 = new Temp('instance!');
console.log(temp1); // Temp { name: 'instance!' }

const temp2: Temp = { name: 'object!' };
console.log(temp2); // { name: 'object!' }
```
* 즉, 이러한 구조적 타이핑 개념으로 인해 TS에서는 다음과 같은 결과가 발생할 수 있다.
  1. 함수의 매개변수의 타입을 확장하는 타입이 전달될 수도 있다.
  2. 매우 단순한 클래스 타입에 인스턴스 대신 객체 리터럴이 할당될 수도 있다.
  3. 반면, 테스트에서 데이터베이스와 같은 외부 종속성에 대한 모킹을 간단하게 구현하기 위해 구조적 타이핑이 적용될 수도 있다.

### 봉인된 타입과 열린 타입
* **함수를 작성하는 경우, 호출에 사용되는 매개변수의 속성들이 매개변수 타입에 선언된 속성만을 가질거라 오판하기 쉽다**.
  * **이러한 타입을 봉인된, 또는 정확한 타입이라고 지칭**한다.
* 반면, **TS 타입 시스템은 봉인된 타입을 표현할 수 없으며 타입은 항상 열려있게 된다**.
  * **타입이 열려있다는 것은 타입이 확장에 열려있다는 의미**와 같다.
  * 즉, 상술한 예제에서 **인터페이스 A와 B의 관계와 같이 타입에 선언된 속성 이외에 마음대로 속성을 추가하더라도 오류는 발생하지 않는다**.

### 구조적 타이핑 - 결론
* JS가 덕 타이핑 기반의 언어이므로, TS는 이를 모델링하기 위해 구조적 타이핑을 활용한다.
  * 즉, **어떠한 인터페이스에 할당 가능한 값이라면 타입 선언에 명시적으로 나열된 속성을 갖게 되는 식으로 타입은 열려 있다**.
* 클래스 역시 구조적 타이핑 규칙을 따르며, 클래스의 인스턴스는 예상과 다를 수 있다.
* **구조적 타이핑을 적절히 활용하는 것으로 유닛 테스팅 및 모킹을 손쉽게 진행**할 수 있다.

## 2022-11-16 Wed
### any 타입은 지양하기
* **TS의 타입 시스템은 다음과 같은 이유에서 점진적이면서도 선택적이라고 볼 수 있으며, 그 핵심은 any 타입**에 있다.
  1. 점진적: 코드에 타입을 조금씩 추가해나갈 수 있다.
  2. 선택적: 언제든지 타입 체커를 해제할 수 있다.
* **any 타입은 일견 코드 작성을 편리하게 만들어주는 것처럼 보일 수 있으나, 특별한 경우를 제외하고는 any 타입의 사용을 지양하는 것이 바람직**하다.
  * 일반적으로는 any 타입을 사용할 경우, TS가 제공하는 수많은 장점을 누릴 수 없게 된다.
  * 때문에 any 타입을 어쩔 수 없이 사용하는 상황에서도 그 위험성을 충분히 인지하는 것이 바람직하다.

### 타입 안정성이 없는 any 타입
* **`as any`와 같은 타입 구문을 사용할 경우, 이미 타입이 명시된 변수에 전혀 다른 타입을 할당**할 수 있게 된다.
  * 그러나 타입 체커는 변수의 선언에 따라 여전히 기존에 명시된 타입을 따르므로, 애플리케이션의 오류는 걷잡을 수 없이 번지게 된다.

### any 타입과 메소드 시그니쳐
* 함수를 작성하는 경우에는 시그니쳐를 명시해야 하며, 클라이언트 코드는 이를 준수해야 한다.
  * 이렇듯 **이상적인 경우에 클라이언트는 함수에게 사전에 정의된 타입을 입력하고, 함수는 적절히 처리되어 약속된 타입을 반환**한다.
* 그러나 **any 타입을 무분별하게 사용할 경우, 이러한 메소드 시그니쳐가 완전히 무시되는 상황이 발생하기 쉽다**.
* **JS에서는 종종 암시적인 타입 변환이 발생하므로, any 타입은 이러한 경우에 특히 문제**가 될 수 있다.
  * 예를 들어, string 타입은 number 타입을 사용하는 위치에서 문제 없이 실행되는 경우가 많지만 이는 런타임에서 오류로 이어지는 경우가 많다.

### any 타입과 언어 서비스
* TS는 언어 서비스 차원에서 임의의 변수에 정의된 타입에 대한 적절한 자동완성 기능과 도움말을 제공한다.
  * 그러나 any 타입의 변수는 이러한 언어 서비스 차원의 도움을 전혀 받을 수 없다.
* TS의 모토는 확장 가능한 JS이며, TS 경험의 핵심 요소 중 하나인 언어 서비스는 확장의 중요한 부분 중 하나이다.
  * 이러한 **언어 서비스를 제대로 누릴 수 있을 때 개발자의 생산성이 향상될 수 있는 반면, 무분별한 any 타입의 사용은 이러한 도움을 받을 수 없게 한다**.

### any 타입과 코드 리팩토링
* 우선 생산성을 높이기 위해 any 타입을 적용하고 넘어가는 경우, 리팩토링 과정에서 이러한 위치는 잘 드러나지 않는다.
  * 즉, any 타입을 모두 수정했다고 생각했지만 실제로는 몇몇 위치에 수정되지 않은 타입이 남은 경우 타입 체커를 통과함에도 런타임에서는 오류가 발생할 수 있다.
  * **이러한 문제점은 any 타입 대신 구체적인 타입을 사용한 경우에 타입 체커가 오류를 발견할 것이므로 미연에 방지**될 수 있다.

### any 타입과 TS 타입 설계
* 애플리케이션 상태 등의 객체를 정의하는 경우, 수많은 속성의 타입을 하나하나 작성하는 과정은 꽤 복잡해질 수 있다.
  * 반면 any 타입을 사용하면 이를 쉽게 넘어갈 수 있으므로, 때로는 any 타입을 명시하고 싶은 유혹에 빠질 수 있다.
* 그러나 **any 타입은 상태 객체의 설계 자체를 감추는 꼴과 같으므로, 이러한 경우에도 any 타입을 명시하는 것은 지양하는 것이 바람직**하다.
  * **깔끔하고 정확하면서도 명확한 코드 작성을 위해서는 제대로 된 타입 설계는 필수적으로 선행**되어야 한다.
  * 그러나 any 타입은 이러한 타입 설계를 불분명하게 감추므로, 설계가 잘 되었는지는 커녕 어떤 형태의 설계를 선택했는지조차 드러나지 않게 된다.
  * **이는 TS를 활용하는 협업 효율성 역시 떨어트리므로, 항상 설계가 가능한 한 명확해지도록 타입을 일일이 작성하는 것이 바람직**하다.

### any 타입과 타입 신뢰도
* **개발 과정에서 휴먼 에러의 발생 가능성은 항상 존재하며, 타입 체커는 이러한 실수를 감지하여 코드의 신뢰성을 높여주는 역할을 수행**한다.
  * 이는 바꿔 말해, 런타임에 발견된 오류는 타입 체커에 대한 신뢰도를 떨어트리는 것으로 이해할 수도 있다.
  * 이렇듯 대규모 프로젝트에서 TS를 도입하는 경우 타입 체커를 신뢰할 수 없는 것은 큰 문제로 이어질 수 있다.
* **any 타입을 사용하지 않을 경우 런타임에 발견될 오류는 미연에 방지되므로 코드의 신뢰성 역시 높아질 수 있다**.
* **TS는 개발 과정을 편하게 하는데에 그 목적이 있지만, any 타입을 무분별하게 사용할 경우 순수 JS를 사용하는 경우보다 일을 더 어렵게 만들 수도 있다**.
  * 이는 타입 오류 및 그와 관련된 실제 타입을 일일이 기억해야하기 때문이므로, 타입이 실제 값과 일치하게만 작업한다면 이러한 수고를 TS에 맡길 수 있다.

### any 타입 지양하기 - 결론
* **any 타입을 무분별하게 사용할 경우, TS의 타입 체커와 언어 서비스를 무력화**하기 쉽다.
* **any 타입은 진짜 문제점을 감춰버리며, 이로 인해 개발 경험과 타입 시스템의 신뢰도를 크게 떨어트리므로 가능한 한 사용을 지양**해야 한다.
* 어쩔 수 없이 any 타입을 사용해야만 하는 상황이 발생할 수 있으나, 이 경우에도 다시 한 번 신중하게 고민해볼 필요가 있다.
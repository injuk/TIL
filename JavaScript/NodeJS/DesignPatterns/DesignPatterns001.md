# DesignPatterns
## 2022-05-05 Thu

## Node.js의 철학
```
> Node.js를 특별하게 만드는 것 중 하나는 그것이 가진 철학이다.
> Node.js를 알아가는 것은 단순히 새로운 기술을 배우는 것이 아닌, Node.js의 문화와 커뮤니티를 받아들이는 것이다.
```
* 모든 프로그래밍 플랫폼흔 여러 원칙으로부터 기인하는 이데올로기를 갖는다.
  * Node.js의 경우 제작자, 기여자, 커뮤니티 구성원, JS의 추세로부터 발생했다.
  * **이러한 규칙들은 강제적이지 않지만, 소프트웨어를 디자인할 때에 필요한 영감을 얻을 수 있다**.

### 경량 코어
```
> Node.js의 코어는 최소한의 기능 세트를 갖되, 코어의 바깥에 사용자 전용 모듈 생태계를 둔다.
```
* 상술한 내용은 Node.js의 문화에 지대한 영향을 준 원칙 중 하나이다.
* 이로 인해 **엄격하게 관리되며 안정적이지만 느리게 진화하는 해결책 대신, 커뮤니티가 사용자 관점에서 여러 해결책을 실험해볼 수 있는 자유**를 얻게 되었다.
  * 이렇게 **코어를 최소한의 기능 세트로 관리하는 것은 관리적인 측면에서 편리할 뿐만 아니라, 전체 생태계의 진화에도 긍정적인 영향**을 줄 수 있다.

### 경량 모듈
```
> Unix의 철학: 1. 작은 것이 아름답다. 2. 각 프로그램은 하나의 역할만 잘 하도록 만들어져야 한다.
```
* Node.js는 코드를 구성하는 기본 수단으로서 모듈 개념을 사용한다.
  * **모듈은 애플리케이션이나, 재사용이 가능한 라이브러리를 만들기 위한 구성 요소**이다.
* **Node.js에서 가장 널리 통용되는 원칙 중 하나는 코드의 양 뿐만 아니라 범위 측면에서도 작은 모듈을 디자인하는 것**이다.
* Node.js는 npm, yarn과 같은 패키지 관리자의 도움을 받아 각각의 패키지가 자신이 필요로 하는 종속성 버전의 패키지를 갖도록 한다.
  * 이를 통해 개발자는 종속성 지옥으로부터 벗어날 수 있으며, 패키지가 충돌 위험 없이 잘 집중화되고 많은 수의 작은 종속성을 가질 수 있도록 한다.
  * **이러한 관행은 다른 플랫폼에서는 실용적이지 못하고, 심지어 적용 불가능하지만 Node.js에서는 표준**이다.
* 경량 모듈을 도입하는 것으로 다음의 이점을 누릴 수 있다.
  1. 재사용성이 높아진다.
  2. 이해하기 쉽고 사용성도 좋아진다.
  3. 테스트와 유지보수가 쉽다.
  4. 사이즈가 작아지므로, 브라우저에서 활용하기에 완벽하다.
* **더 작지만 집중화된 모듈을 갖는 것은 모두에게 공유와 재사용을 가능케하며, 이는 완전히 다른 수준에서 적용되는 DRY 원칙의 일종**이다.

### 작은 외부 인터페이스
```
> 많은 경우에 컴포넌트 사용자는 기능의 확장이나 부가적인 고급 기능의 활용보다는 제한되고 집중화된 기능에만 관심이 있다.
```
* **Node.js의 모듈들이 갖는 장점은 작은 사이즈와 작은 범위, 그리고 최소한의 기능만을 노출하는 것**이다.
  * 이를 통해 모듈은 명확하게 사용되고, 잘못된 사용에 덜 노출되도록 하는 API 생산 효과를 갖는다.
* **Node.js에서 모듈을 정의하는 가장 일반적인 패턴은 명백한 단일 진입점을 제공하기 위해 단 하나의 함수나 클래스만을 노출시키는 것**이다.
* **Node.js가 갖는 많은 모듈들의 특징 중 하나는, 모듈이 확장보다는 사용을 위해 정의된다는 것**이다.
  * 확장의 가능성을 금지하기 위해 모듈 내부로의 접근을 제한하는 것은 일견 유연하지 못해 보일 수 있다.
  * 그러나 **실제로는 유즈케이스를 줄이고, 구현을 단순화하고, 유지보수성과 가용성을 높이는 장점들을 갖는다**.
* **모듈은 내부를 외부에 노출시키지 않기 위해, 클래스보다는 함수를 노출시키는 것을 선호**한다.

### 간결성과 실용주의
```
> Keep It Simple, Stupid!
> 단순함이야말로 궁극의 정교함이다.
```
* 여러 이유에서 **완벽하고 모든 기능을 갖춘 소프트웨어보다는 단순하게 설계하는 것이 좋은 실천 방법**이다.
  * 이러한 방식은 구현을 위해 적은 노력이 드는 반면 보급은 쉽고, 유지보수성과 가독성도 높다.
  * **이러한 요인들은 커뮤니티의 기여도를 높이고, 소프트웨어 자체의 성장과 향상을 돕는다**.
* 소프트웨어를 현실에 가깝게 만들고, 많은 코드로 완벽에 가까운 소프트웨어를 만드는 것보다 합리적인 복잡성을 기반으로 빠르게 일하는 것이 더 많은 성공을 이룬다.
* **Node.js에서는 대부분의 경우에 완전하고 완벽한 설계보다는 복잡하지 않은 실용적인 접근 방식이 선호**된다.

## 2022-05-06 Fri
## Node.js는 어떻게 동작하는가?
* Node.js 플랫폼의 전체 기반은 크게 다음과 같이 분류된다.
  1. 비동기 특성의 핵심인 리액터 패턴
  2. 단일 스레드 아키텍쳐
  3. 논 블로킹 I/O

### I/O는 느리다
* I/O는 컴퓨터가 제공하는 기본적인 동작들 중에서도 가장 느리다.
* CPU 관점에서 I/O 자체는 많은 비용을 요구하는 작업이 아니지만, 요청과 작업 완료 시점 사이에는 지연이 필연적으로 발생한다.
  * 더군다나 사용자의 마우스 클릭 등과 같은 입력의 경우, 디스크와 네트워크보다도 느릴 수 있다.

### 블로킹 I/O의 경우
* 블로킹 I/O 프로그래밍에서 I/O를 요청하는 함수의 호출은 작업이 완료될 때까지 스레드의 실행을 차단한다.
  * 때문에 블로킹 I/O를 활용하여 구현된 웹 서버는 같은 스레드 내에서 여러 연결을 처리하지 못한다.
* 이를 해결하기 위한 **전통적인 접근 방법은 각각의 동시 연결을 처리하기 위해 개별 스레드, 또는 프로세스를 사용하는 것**이다.
  * 이 경우, I/O 작업은 각각의 스레드에서 처리되므로 I/O로 인해 블로킹된 스레드가 다른 연결들의 가용성에 영향을 주지 않는다.
  * 그러나 모든 유형의 I/O가 요청의 처리를 차단할 수 있으며, 이로 인해 I/O 작업을 위해서 스레드는 꽤 많이 블로킹된다.
  * **스레드는 I/O와 달리 시스템 리소스 관점에서의 비용이 저렴하지 않으며, 많은 경우에 메모리와 CPU 사이클을 낭비**하게 된다.

### 논 블로킹 I/O의 경우
* 대부분의 최신 운영체제는 리소스에 접근하기 위한 블로킹 I/O 이외에도 논 블로킹 I/O 메커니즘을 지원한다.
* **논 블로킹 I/O 모드에서의 시스템 호출은 데이터가 읽혀지거나 쓰여지기를 기다리지 않으며, 항상 즉시 반환**된다.
  * **호출 순간에 사용 가능한 결과가 없는 경우, 함수는 단순히 사전 정의된 임의의 상수를 반환**한다.
* **호출 시점에 리소스 대신 상수를 얻을 수 있으므로, 이러한 종류의 논 블로킹 I/O를 다루는 기본적인 기법은 바쁜 대기**이다.
  * **바쁜 대기란, 실제 데이터가 반환될 때까지 루프를 통해 리소스를 적극적으로 폴링하는 것**이다.
  * 리소스를 사용 가능할 때까지 대기하는 블로킹 I/O와 달리, 논 블로킹 I/O는 적극적인 폴링이 필수적이다.
* 이러한 유형의 논 블로킹 I/O는 다음과 같은 장단점을 갖는다.
  1. 장점: 간단한 기법으로 같은 스레드 내부에서 서로 다른 리소스를 처리할 수 있다.
  2. 단점: **루프는 사용할 수 없는 리소스를 반복하는 데에 엄청난 CPU 시간을 낭비**하며, 이는 폴링 알고리즘의 특징에서 기인한다.
```
> 바쁜 대기는 논 블로킹 리소스 처리를 위한 이상적인 기법이 될 수 없다.
```

### 이벤트 디멀티플렉싱
* 대부분의 운영체제에서는 논 블로킹 리소스를 효율적으로 처리하기 위해 제공하는 별도의 기본 메커니즘이 존재한다.
  * **이러한 메커니즘을 동기 이벤트 디멀티플렉서, 또는 이벤트 통지 인터페이스**라고 한다.
* 동기 이벤트 디멀티플렉서는 일반적으로 다음과 같은 동작을 수행한다.
  1. 여러 리소스를 관찰한다.
  2. **관찰 대상 리소스 중 읽기 또는 쓰기 연산의 실행이 완료된 시점에 새로운 이벤트를 반환**한다.
     * **반환된 이벤트는 순차적으로 처리되며, 이를 이벤트 루프**라고 한다.
  3. **동기 이벤트 디멀티플렉서는 처리할 수 있는 새로운 이벤트가 발생할 때까지 블로킹**된다.
* **동기 이벤트 디멀티플렉서 패턴을 활용하는 경우, 바쁜 대기를 사용하지 않고도 여러 I/O 작업을 단일 스레드 내에서 다룰 수 있게 된다**.
  * 즉, 단일 스레드 내에서 여러 리소스를 다룰 수 있게 된다.
  * 이 경우 **단일 스레드를 사용하는 것이 동시적인 다중 I/O 작업에 악영향을 주지 않으며, 다중 스레드 분할 대신 시분할**된다. 
  * 때문에 이러한 방식은 전체적인 유휴시간을 최소화하는 데에 확실한 이점을 갖는다.
* **Node.js가 해당 I/O 모델을 선택한 이유는 여기에 더해 개발자가 동시성에 접근하는 방식에 이로운 영향을 주기 때문**이다.
  * 경쟁 상태의 발생 문제나 다중 스레드의 동기화 문제가 없다는 것은 간단한 동시성 전략을 사용할 수 있게 해준다.

### 리액터 패턴
* **리액터 패턴은 이벤트 디멀티플렉싱 알고리즘에 특화된 패턴이며, 주된 아이디어는 각각의 I/O 작업에 대응되는 핸들러를 갖는다는 것**이다.
  * Node.js의 경우, 핸들러는 콜백 함수에 해당된다.
* **각 I/O 작업과 연관된 핸들러는 이벤트가 생성되고, 이벤트 루프에 의해 처리되는 즉시 호출**된다.
* 리액터 패턴을 활용하는 애플리케이션은 다음과 같은 방식으로 작업을 수행한다.
  1. 애플리케이션은 이벤트 디멀티플렉서에 요청을 전달하여 새로운 I/O 작업을 생성한다.
     * 이 때, 애플리케이션은 작업이 완료되었을 때 호출될 핸들러를 명시한다.
     * **해당 작업은 논 블로킹 호출이므로, 제어권은 애플리케이션으로 즉시 반환**된다.
  2. **일련의 I/O 작업이 완료되면, 이벤트 디멀티플렉서는 대응하는 이벤트 작업들을 이벤트 큐에 삽입**한다.
     * 이벤트 디멀티플렉서는 관찰 대상 리소스 중 읽을 수 있는 리소스가 생길 때까지 블로킹된다.
     * 준비된 리소스가 생기면 이를 처리하기 위한 새로운 이벤트 작업을 반환한다.
     * 이벤트 큐에 추가될 이벤트 작업은 일반적으로 Event - Handler 페어로 구성된다.
  3. **이벤트 큐에 새로운 이벤트 작업이 추가된 경우, 이벤트 루프가 이벤트 큐의 항목들에 대해 순환을 시작**한다.
  4. **이벤트 루프가 이벤트 큐를 순회하는 과정에서 각 이벤트와 대응되는 핸들러가 호출**된다.
     * 핸들러는 애플리케이션 코드의 일부이므로, 핸들러 호출시 제어권은 애플리케이션으로 돌아간다.
  5. **애플리케이션 코드의 일부인 핸들러의 실행이 완료되는 경우, 제어권은 이벤트 루프로 돌아간다**.
     * 핸들러의 코드가 다른 비동기 작업을 요청할 수 있으며, 이는 이벤트 디멀티플렉서에 새로운 항목을 추가하는 것과 같다.
  6. **이벤트 큐의 모든 항목이 처리된 후, 이벤트 루프는 이벤트 디멀티플렉서에서 블로킹**된다.
  7. 처리 가능한 새로운 이벤트가 발생한 경우에 2.의 과정부터 다시 트리거된다.
* 이렇듯 **애플리케이션은 블로킹이 없는 대신 임의의 시점에 리소스로 접근하고 싶다는 요청을 전달하며, 요청 완료시 호출될 핸들러도 함께 제공**한다.
* **Node.js 애플리케이션은 이벤트 디멀티플렉서에서 보류중인 작업이 없고, 이벤트 큐에 더 이상 처리 중인 작업도 없는 경우에 종료**된다.
```
> 리액터 패턴은 일련의 관찰 대상 리소스에서 새로운 이벤트를 사용할 수 있을 때까지 블로킹하여 I/O 작업을 처리한다.
> 이 때, 각각의 이벤트를 대응되는 핸들러에 전달하여 반응한다.
```

### Node.js의 I/O 엔진, libuv
```
> libuv는 Node.js가 주요 운영체제에서 호환되도록 서로 다른 유형의 논 블로킹 동작을 표준화하는 C 라이브러리이다.
```
* 각각의 운영체제는 이벤트 디멀티플렉서를 위한 자체 인터페이스를 갖는다.
  * 심지어 각각의 I/O 작업은 동일한 운영체제 내에서도 리소스 유형에 따라 매우 다르게 동작할 수 있다.
  * 즉, **서로 다른 운영체제의 불일치성으로 인해 Node.js는 운영체제가 제공하는 이벤트 디멀티플렉서를 그대로 사용할 수 없다**.
* 상술한 문제로 인해 Node.js 코어 팀은 이벤트 디멀티플렉서를 위한 보다 높은 레벨의 추상화가 필요했으며, libuv는 이러한 이유에서 작성되었다.
  * **libuv는 Node.js 하위 수준의 I/O 엔진을 대표하며, Node.js의 가장 중요한 구성 요소**이다.
* libuv는 리액터 패턴을 구현하고 있으며, 주로 다음과 같은 기능들을 제공한다.
  1. 기본 시스템 호출을 추상화한다.
  2. 이벤트 루프를 생성하기 위한 API를 제공한다.
  3. 이벤트 큐를 관리하기 위한 API를 제공한다.
  4. 비동기 I/O 작업의 실행을 위한 API를 제공한다.
  5. 서로 다른 유형의 작업을 큐에 담기 위한 API를 제공한다.

### Node.js를 위한 구성
* Node.js는 전체 플랫폼의 구축을 위해 리액터 패턴과 libuv 이외에도 다음과 같은 구성 요소를 필요로 한다.
  1. 바인딩 세트: libuv와, 다른 저수준 기능들을 랩핑하고 표출한다.
  2. V8: 구글이 개발한 JS 엔진이며, 혁신적인 설계와 속도 및 효율적인 메모리 관리로 높은 평가를 받는다.
  3. 코어 JS 라이브러리: 고수준의 Node.js API를 구현한다.

## Node.js에서의 JS
* Node.js에서 사용되는 JS는 브라우저에서 사용하는 JS와 비교했을 때 다음과 같은 차이점을 갖는다.
  1. Node.js는 DOM을 갖지 않는다.
  2. Node.js는 window와 document 객체를 갖지 않는다.
  3. 반면, Node.js는 운영체제에서 기본적으로 제공하는 서비스들에 접근이 가능하다.

### 최신 JS의 실행
* 브라우저 상에서 동작하는 JS와 비교하였을 때 가장 큰 차이점은 JS나 Node.js의 특정 버전에서 동작하는 코드를 사용할 수 있다는 것이다.
  * 브라우저를 사용하는 경우, 브라우저 별 지원 차이가 존재한다.
* 또한 **Node.js는 최신 버전의 V8을 기반으로 하기에 추가적인 소스의 변환 없이 최신 ES 사양의 특성 대부분을 사용할 수 있다**. 
* 그러나 이는 개발 과정에서 버전을 전혀 신경쓰지 말아야한다는 의미는 아니다.
  * 예를 들어 서드 파티에서 사용하기 위한 라이브러리를 개발하는 경우, 코드가 다양한 버전의 Node.js에서 실행될 수 있음을 고려해야 한다.
  * 일반적으로 Node.js의 LTS 중 가장 낮은 버전을 기준으로 하되, package.json의 engines 섹션을 두어 이를 명시한다.

### 모듈 시스템
* JS가 어떠한 형식을 지원하지 않았을 때, Node.js는 CommonJS라고 불리우는 모듈 시스템과 함께 시작되었다.
  * 이는 내장 모듈 또는 로컬 파일 시스템에 위치한 모듈로부터 함수 또는 변수, 클래스를 임포트하기 위해 require 키워드를 사용한다.
* 오늘 날의 JS는 ES 모듈 문법을 갖고 있으며, Node.js에서는 문법만을 상속받는다.
* 실제로도 브라우저는 원격지에 위치한 모듈을 주로 다루는 반면, Node.js는 현재로서는 오직 로컬 파일 시스템의 모듈만을 다룰 수 있다.

### 운영체제 기능에 대한 모든 접근
* **Node.js는 JS를 사용하지만 브라우저 상에서 실행되지는 않으므로, 운영체제에서 기본적으로 제공하는 주된 서비스들에 바인딩할 수 있다**.
  * 예를 들어 fs 모듈을 활용한 파일 시스템 접근, net 모듈을 활용한 저수준 TCP 소켓 사용 등이 가능하다.
  * 또한 child_process 모듈을 활용한 다른 프로세스의 실행 및 전역 변수 process를 통한 환경 변수 접근 역시 가능하다.

### 네이티브 코드 실행
* **Node.js가 제공하는 강력한 능력 중 하나는 네이티브 코드에 바인딩할 수 있는 사용자 측 모듈을 만들 수 있다는 점**이다.
  * 이는 C나 C++로 이미 작성되어 있는 레거시 코드나, 앞으로 작성될 컴포넌트를 사용할 수 있다는 이점을 플랫폼에 부여한다.
* 이를 통해 **적은 노력으로도 막대한 양의 오픈 소스나, 기업이 걱정 없이 C나 C++ 레거시를 재사용**할 수 있도록 한다.
* V8의 경우 JS의 실행에 있어서는 매우 빠른 동작을 보장하지만, 네이티브 코드와 비교했을 때에는 여전히 수행 능력에 손실이 따른다.
  * 이는 드문 문제이나, 엄청난 양의 데이터를 처리하고 조작하여 네이티브 코드에 위임하는 CPU 집약적 애플리케이션에서는 충분히 발생할 수 있는 문제이다.
* 또한 Node.js를 포함하는 대부분의 JS 가상 머신은 웹 어셈블리를 지원한다.
  * 이는 C++이나 Rust와 같은 JS 이외의 언어를 JS 가상 머신이 이해할 수 있는 형식으로 컴파일할 수 있도록 하는 저수준 명령 형식이다.

## 결론
* Node.js는 최소한의 코어를 갖는다.
* **Node way란, 더 작고 간단하며 필요 최소한의 기능만을 노출한다는 의미**를 갖는다.
* Node.js의 내부 아키텍쳐에 의한 기술적인 이점과, 방대한 커뮤니티로 인해 Node.js는 많은 관심을 이끌어낼 수 있었다.
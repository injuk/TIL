# DesignPatterns
## 2022-05-16 Mon

### ECMAScript 모듈
* ESM으로도 알려진 ECMAScript 모듈은 ECMAScript 2015 명세의 일부분으로 도입되었다.
  * **ESM은 서로 다른 실행 환경에서도 적절하게 동작하는 공식 모듈 시스템을 JS에 부여**한다.
  * ESM 명세는 CommonJS나 AMD와 같은 기존 모듈 시스템의 장점을 계승하고자 하였으며, 문법은 간단하고 짜임새를 갖춘다.
  * 또한, **ESM은 비동기적으로 모듈을 로드할 수 있는 방법과 순환 종속성에 대한 지원을 제공**한다.
* ESM은 static 방식을 택한다는 점에서 CommonJS와는 큰 차이점을 갖는다.
  * 이로 인해 임포트는 모든 모듈의 최상위 레벨과 제어 흐름 구문의 바깥쪽에 정의된다.
  * 또한, **모듈의 이름을 코드 상에서 동적으로 결정할 수 없으므로 임포트 대상 모듈은 반드시 상수 문자열로 표현**해야 한다.
* 이러한 ESM의 특징은 불필요한 제약으로 보일 수도 있지만, 정적 임포트를 지원하는 것으로 다음과 같은 시나리오에 대응할 수 있게 된다.
  1. 종속성 트리의 정적 분석을 가능하게 한다. 
  2. 이로 인해 tree shaking과 같이 사용하지 않는 코드 제거 등의 코드 최적화를 지원할 수 있다.

### Node.js에서 ESM 사용하기
* **Node.js는 기본적으로 모든 js 확장자 파일이 CommonJS 문법을 사용한다고 판단**한다.
  * 때문에 js 확장자 파일에 곧장 ESM 문법을 도입하면 인터프리터는 에러를 발생시킨다.
* Node.js 인터프리터가 CommonJS 모듈 대신 ESM을 받아들일 수 있도록 하려면 다음과 같은 방식을 적용할 수 있다.
  1. 모듈 파일의 확장자를 .mjs로 정의한다.
  2. **모듈과 가장 근접한 package.json의 type 필드에 module을 기재**한다.

### named exports, named imports
* **CommonJS에서 exports와 module.exports를 제공하는 것과 달리, ESM에서는 export 키워드만을 사용하여 모듈의 기능을 내보낸다**.
* **ESM에서는 기본적으로 모든 것이 private이며, export된 개체들만 공개되어 다른 모듈로부터 접근이 가능**해진다.
```
// moduleA.js
export function hello() {
  console.log('hello world');
}

export const NAME = 'injuk';

export const info = { age: 3, isMale: true };

export class Injuk {
  constructor(name) {
    this.name = name;
  }
  sayHello() {
    console.log(`my name is ${this.name}`);
  }
}
```
* 다른 모듈로부터 임의의 개체를 임포트하고자 하는 경우에는 import 키워드를 활용한다.
  * 해당 **문법은 유연하며, 하나 이상의 개체를 한 번에 임포트하거나 다른 네임스페이스를 할당할 수도 있다**.
  * 아래 예시에서 moduleA.js의 모든 멤버를 임포트하며 moduleA 변수에 할당한다.
  * **import * 구문은 네임스페이스 임포트에 해당하며, 해당 모듈의 모든 멤버를 임포트하는 동시에 as 구문에 정의된 네임스페이스를 할당**한다.
```
// main.js
import * as moduleA from './moduleA.js'

console.log(moduleA);
console.log(moduleA.hello());
```
* **CommonJS와 달리 ESM에서는 반드시 모듈의 파일 확장자를 구체적으로 명시**해야 한다.
* 규모가 큰 모듈을 임포트하는 과정에서 모듈의 모든 기능을 임포트하지 않고, 하나 또는 몇 개의 객체만 임포트하고 싶은 경우에는 다음과 같이 작성한다.
```
import { hello, NAME } from './moduleA.js';

hello();
console.log(NAME);
```
* 그러나 해당 임포트 구문은 임포트되는 대상이 현재의 스코프로 임포트되므로 이름의 충돌 가능성이 존재한다.
  * 동일한 이름의 변수가 존재하는 경우, 인터프리터는 문법 에러를 반환하며 동작을 멈추게 된다.
  * 이러한 **이슈를 해결하기 위해 as 구문을 활용하여 임포트되는 개체의 이름을 변경**해줄 수 있다.
```
import { hello, NAME as name } from './moduleA.js';

const NAME = 'monkey';

hello();
console.log(NAME);
console.log(name);
```
* **as 키워드를 활용하는 방식은 서로 다른 모듈에서 동일한 이름을 갖는 개체의 임포트로 인해 충돌이 발생한 경우에 유용**하다.
  * 이로 인해 모듈 클라이언트는 모듈의 원래 이름을 바꿀 것인지 고려할 필요가 없다.

### default export, default import
* CommonJS에서 자주 사용되는 특성은 이름이 없는 임의의 개체를 module.exports에 할당하여 익스포트하는 것이다.
  * 이는 모듈 개발자에게 단일 책임 원칙을 권장하며, 깔끔한 하나의 인터페이스만을 공개한다는 점에서 매우 편리한 기능이다.
* ESM에서는 default export가 유사한 기능을 수행하며, export default 키워드를 사용한다.
```
// default.js
export default (message) => {
  console.log(message);
}
```
* 해당 방식의 경우 **익스포트되는 개체는 이름이 무시되며, default라는 이름에 등록**된다.
* 익스포트된 이름은 다음과 같은 방식으로 임포트할 수 있다.
  * **default export는 이름이 없는 것으로 간주되므로, ESM의 named import와는 다른 방식으로 임포트**해야 한다.
  * 임포트와 동시에 모듈 클라이언트가 정의한 이름으로 할당되며, 클라이언트 개발자는 임의의 이름을 정의할 수 있다.
```
import log from './default.js';

log('hello');
```
* **default export 방식은 내부적으로 default라는 이름으로 익스포트되는 것과 동일하게 취급**된다.
  * 그러나 **default 키워드는 변수의 이름으로 명명할 수 없으므로, 명시적으로 default 개체를 임포트할 수는 없다**.
  * default 키워드는 객체의 속성으로는 정의가 가능하지만, 변수의 이름으로 설정할 수는 없다.
```
import * as log from './default.js';
// 아래의 방식은 default 변수를 정의할 수 없으므로 불가능하다.
// import { default } from './default.js'; 

console.log(log);
log.default('hello');
```

### mixed exports
* **ESM에서는 named export와 default export를 혼합하여 사용할 수도 있다**.
```
export default function(message) {
  console.log(message);
}

export function hello(name) {
  console.log(`hello, ${name}!`);
}
```
* default export와 named export를 임포트하는 경우, 다음과 같은 방식을 활용할 수 있다.
```
// 한 번에 import할 수 있다.
// import * as mixed from './mixed.js';
//
// console.log(mixed);
// mixed.hello('ingnoh');
// mixed.default('hello');

// 또는 default export와 named export를 따로 import할 수도 있다.
import log, { hello } from './mixed.js';

log('hello');
hello('ingnoh');
```

### default export와 named export의 차이점
* 두 방식은 다음과 같은 주목할만한 차이점을 갖는다.
  1. named export는 명확하지만, default export는 모든 면에서 상대적으로 복잡하다.
     * named export는 지정된 이름을 갖기 때문에 IDE의 지원을 받기 쉽다.
     * 반면, **default export는 클라이언트 모듈마다 서로 다른 이름을 가질 수 있기에 주어진 이름에 대해 실제로 어떠한 모듈이 적용될지 추론이 어렵다**.
  2. default export는 모듈의 가장 핵심적인 하나의 기능을 연결시키는 편리한 방법이다.
     * **사용자 관점에서, 바인딩을 위한 정확한 이름을 알 필요가 없이 해당 모듈이 확실히 제공하는 기능을 쉽게 임포트**할 수 있다.
  3. **default export는 특정한 상황에서 tree shaking을 어렵게 만든다**.
     * 예를 들어, **모듈의 기능을 객체로 포함하여 default export로 제공하는 경우**가 있다.
     * 해당 객체를 임포트한 경우, 모듈 번들러는 객체 전체가 사용되는 것으로 간주하여 실제로는 사용되지 않는 코드를 제거할 수 없다.
```
// 3.의 예시
// bad.js
export default {
  hello: (name) => {
    console.log(`hello, ${name}!`);
  },
  bye: (name) => {
    console.log(`bye ${name}...`);
  },
  log: (message) => {
    console.log(message);
  }
};

// main.js
import bad from './bad.js';

bad.hello('injuk');
```
* 따라서 **명확한 하나의 기능을 내보내는 경우에는 default export를 사용하되, 그 외에는 named export 사용을 지향하는 것이 일반적으로 바람직**하다.
  * 이는 엄격히 합의된 규칙이 아니며, Node.js의 코어 모듈과 React는 모두 혼합된 방식을 사용한다.
* 두 방식 중 자신의 모듈에 어떠한 것이 최선의 방식일지, 나아가 모듈 클라이언트에게 어떠한 개발자 경험을 제공하고 싶은지 고려하여 결정할 수 있어야 한다.

### 모듈 식별자
* 모듈 식별자는 import 구문에서 로드하고자하는 모듈의 경로를 명시하기 위해 사용되는 값이다.
* 모듈 식별자는 크게 다음과 같이 분류할 수 있다.
  1. 상대적 식별자: ./logger.js 또는 ../logger.js와 같은 형식이며, 파일의 경로에 상대 경로가 사용된다.
  2. 절대 식별자: 절대 경로가 사용되며, CommonJS의 파일 모듈과는 용례가 다르다.
  3. 노출 식별자: node_modules 폴더에서 사용이 가능하도록 패키지 매니저를 통해 설치된 모듈과 Node.js 코어 모듈을 가리킨다.
     * import * as fs from 'fs'; 와 같은 형식으로 사용된다.
  4. 심층 임포트 식별자: node_modules에 위치한 패키지의 경로를 가리키는 경우를 말한다.
     * import * as logger from 'fastify/lib/logger.js'와 같은 형식으로 사용된다.
* **브라우저 환경에서는 모듈의 URL을 명시하여 직접 임포트할 수 있으나, 이는 Node.js 런타임에서는 지원되지 않는 ESM의 기능**이다.

## 2022-05-17 Tue
### 비동기 임포트
* import 구문은 정적이므로, 다음과 같은 제약이 존재한다.
  1. 모듈 식별자를 실행 중에 생성할 수 없다.
  2. 모듈의 임포트는 모든 파일의 최상위에 선언되므로, 제어 구문 내에 포함될 수 없다.
* 또는 상대적으로 무거운 모듈을 사용하고자 하는 경우, 기능의 특정 부분에만 집중하기 위해 ESM은 비동기 임포트를 제공한다.
  * **비동기 임포트는 동적 임포트이기도 하며, import() 연산자를 활용하여 실행 중에 수행**된다.
* **import() 연산자는 문법적으로 모듈 식별자를 인자로 받아 모듈 객체를 프로미스로 반환하는 함수와 동일**하다.
  * **모듈이 사용될 준비를 알기 위해 .then()을 활용할 수 있으며, then에 전달된 함수의 인자는 동적 임포트된 모듈의 네임스페이스**가 된다.

### 모듈 적재의 이해 - 로딩 단계
* **인터프리터의 목표는 필요한 모든 모듈의 종속성 그래프를 만들어내는 것**이다.
* **인터프리터는 모듈이 실행되어야 할 코드의 순서와 함께, 모듈 간에 어떠한 종속성을 갖는지 이해하기 위해 종속성 그래프를 필요로 한다**.
* Node 인터프리터가 실행되면 JS 파일 형식으로 실행할 코드가 전달되며, 이 파일은 종속성 확인을 위한 진입점 역할을 맡는다.
  * **인터프리터는 진입점으로부터 필요한 모든 코드가 탐색되고, 평가될 때까지 import 구문을 재귀적인 깊이 우선 탐색으로 검색**해간다.
* 더 구체적으로, 로딩 단계는 다음과 같은 세 단계에 걸쳐 작업을 진행한다.
  1. 생성 또는 파싱 단계: 모든 import 구문을 찾고, 재귀적으로 각 파일로부터 모든 모듈의 내용을 적재한다.
  2. 인스턴스화 단계: 익스포트된 모든 개체들에 명명된 참조를 메모리에 유지한다.
     * 또한, 모든 import와 export 문에 대한 참조가 생성되어 서로 간의 종속성 관계를 추적한다.
     * **이 단계에서는 어떠한 JS 코드도 실행되지 않는다**.
  3. 평가 단계: 마지막으로 Node.js는 코드를 실행하여 인스턴스화된 모든 개체가 실제 값을 얻을 수 있도록 한다.
     * **이 단계에서 모든 것이 준비되므로, 진입점에서 시작하는 코드를 실행할 수 있게 된다**.
* **CommonJS는 동적인 성질로 인해 종속성 그래프가 탐색되기 전에 모든 파일을 실행시키지만, ESM은 각 세 단계를 완전히 분리하는 차이가 있다**.
  * 따라서 CommonJS는 제어 구문에서도 require 구문을 사용할 수 있으며, 변수에 모듈 식별자를 사용할 수 있다.
  * 반면 **ESM은 종속성 그래프가 완전해지기 전까지는 어떠한 코드도 실행하지 않으며, 이로 인해 모듈의 임포트와 익스포트는 정적**이어야 한다.

### 읽기 전용 라이브 바인딩
* **순환 의존성에 도움이 되는 ESM의 또 다른 특정은 임포트된 모듈이 익스포트된 값에 대해 읽기 전용으로 라이브 바인딩된다는 사실**이다.
  * 예를 들어, export let count = 0;과 같은 코드도 읽기 전용이므로 수정할 수 없다.
* 개체가 임포트된 경우, 사용자 코드의 직접적인 제어 외부에 있는 바인딩 값은 원래 존재하던 모듈에서 바뀌지 않는 이상 기존 값에 대한 바인딩이 변경 불가하다.
* 이러한 접근은 CommonJS와는 근본적으로 다르다.
  * **CommonJS의 경우, exports 객체 전체는 얕은 복사**된다.
  * 이로 인해 **솟자나 문자열과 같은 원시 변수에 있는 값이 바뀐 경우, 이를 제공하는 모듈은 변화를 알아챌 수 없다**.
* **ESM은 모듈 분석을 위해 파싱, 인스턴스화, 평가의 세 단계를 거친다**.

## 2022-05-18 Wed
### 파싱 단계
* 파싱 단계에서는 main.js와 같은 진입점으로부터 코드의 탐색을 시작한다.
  * 이 때, **인터프리터는 필요한 모든 모듈을 검색하는 과정에서 오직 import 구문만을 찾아낸다**.
  * **파싱 단계는 깊이 우선적인 종속성 그래프 탐색 과정이며, 모든 모듈은 단 한 번씩만 방문**된다.
  * 결과, 인터프리터는 트리 형태를 띄는 종속성 그래프의 외관을 구성하게 된다.
* main.js > a.js > b.js > a.js의 형태로 순환 종속성을 갖는 시나리오를 예로 들어, 인터프리터는 다음과 같은 순서로 파싱을 진행한다.
  1. 진입점인 main.js에서 import 구문의 탐색을 시작한다.
  2. import * as a from './a.js'와 같이 main.js에서 a.js로 향하는 import 구문을 발견할 것이므로, a.js를 향해 탐색을 진행한다.
  3. a.js에서 b.js로 향하는 import 구문을 발견하므로, b.js로 탐색을 진행한다.
  4. **b.js에서 다시 a.js로 향하는 import 구문을 발견하지만, a.js는 이미 방문했으므로 다시 탐색하지 않는다**.
  5. **b.js가 a.js 이외의 종속성을 갖지 않는다면, 이 시점에서 탐색은 a.js로 회귀**한다.
  6. a.js 역시 b.js 이외의 종속성을 갖지 않는다면, 탐색은 main.js로 회귀한다.
  7. 만약 **main.js가 a.js 임포트 구문 다음에 b.js를 임포트하고자 한다고 해도, 해당 모듈은 이미 탐색되었으므로 해당 경로는 무시**된다.
  8. **결과로 만들어지는 종속성 그래프는 순환 종속성이 존재하더라도 선형적인 모듈 그래프의 형태**를 갖는다.
     * 즉, 결과 모듈 그래프에서 순환은 제거된다.
     * 실무에서 더욱 많은 모듈을 임포트하는 경우, 모듈 그래프는 완전한 직선이 아닌 트리 구조를 띄게 된다.

### 인스턴스화 단계
* **인터프리터는 이전 단계에서 얻어진 트리 구조를 따라 아래에서 위로 순회하며, 모든 모듈로부터 익스포트된 속성을 찾는다**.
  * 이 단계에서 익스포트된 속성들은 메모리에 익스포트된 속성 이름의 맵 형태로 적재된다.
* 상술한 시나리오의 경우, 모든 모듈은 다음과 같은 순서를 거쳐 인스턴스화된다.
  1. 인터프리터는 트리 구조의 최하단인 b.js에서 시작하며, b.js 모듈이 loaded와 a를 익스포트하는 것을 확인한다.
  2. 인터프리터는 트리 구조를 따라 a.js로 이동하며, loaded와 b를 익스포트하는 것을 확인한다.
  3. 마지막 순서인 main.js로 이동하지만, 더 이상 기능에 대한 익스포트가 없는 것을 확인한다.
  4. **마지막 단계에서 익스포트 맵은 익스포트된 이름만을 유지하며, 연관되는 실체인 값은 인스턴스화 단게에서는 인스턴스화되지 않은 것으로 간주**한다.
* **인터프리터는 상술한 모든 단계를 거치고 나서 만들어진 익스포트 맵의 정보를 토대로 임포트하는 모듈에게 익스포트된 이름의 링크를 전달**한다.
  * 예를 들어, 모듈 b.js는 aModule이라는 이름으로 a.js가 익스포트한 속성과 연결된다.
  * 모듈 a.js는 bModule이라는 이름으로 b.js가 익스포트한 속성과 연결된다.
  * main.js는 b라는 이름으로 b.js의 모든 익스포트를 임포트하고, a.js는 a라는 이름으로 임포트된다.
* **해당 단계에서는 모든 값이 실제로는 인스턴스화되지 않았으며, 다음 단계인 평가 단계의 마지막에서나 사용 가능해질 값에 대한 참조만을 연결**한다.

### 평가 단계
* **평가 단계는 모듈 분석의 마지막 단계이며, 해당 단계에서 실제로 모든 파일에 포함된 코드가 전부 실행**된다. 
* **실행 순서는 후위 깊이 우선 탐색 방식이므로 아래에서 위로 진행하며, 마지막에 실행되는 파일이 main.js**가 된다.
  * 이를 통해 **메인 비즈니스 로직을 실행하기 전에 익스포트된 모든 값이 초기화되는 것이 보장**된다.
* 상술한 시나리오를 예로 들어, 평가 단계는 다음과 같은 순서로 진행된다.
  1. b.js로부터 시작되며, 모듈에서 익스포트되는 loaded 변수의 값이 false로 평가된다.
  2. 마찬가지로 익스포트되는 속성 a가 평가되지만, **a는 exports 맵의 모듈 a.js에 대응되는 모듈 객체에 대한 참조로 평가**된다.
  3. loaded 속성이 true로 변경되며 모듈 b.js의 익스포트 상태가 완전히 평가된다.
  4. 코드의 평가는 다음 단계인 a.js로 이동되며 b.js와 마찬가지의 절차를 거친다.
     * 이 때, **export b는 역시 익스포트 맵에서 모듈 b.js에 대응되는 모듈 객체에 대한 참조로 평가**된다.
  5. a.js의 loaded 속성이 true로 평가되는 것으로 a.js의 익스포트 상태는 완전히 평가된다.
* **모든 단계를 거친 후에 main.js의 코드가 실행되며, 이 때 필요한 모든 익스포트된 속성은 완전히 평가된 상태**이다.
  * **임포트되는 모든 모듈은 참조의 형태로 추적되므로, 순환 종속성이 존재하는 상황에서도 모든 모듈은 다른 모듈의 최신 상태를 갖는 것이 보장**된다.
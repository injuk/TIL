# DesignPatterns
## 2022-05-19 Thu

## 콜백과 이벤트
* 일반적인 개발자들은 동기식 프로그래밍에서, 특정한 문제를 해결하기 위해 일련의 연속 작업 형태를 띄는 코드를 작성하는 데에 익숙하다.
  * 동기식 프로그래밍의 모든 작업은 블로킹이며, 현재 작업이 종료된 후에야 다음 작업을 실행할 수 있다.
* 반면, 비동기식 프로그래밍에서는 IO와 같은 일부 작업을 백그라운드에서 실행할 수 있다.
* 비동기 작업이 호출되면 이전 작업이 완전히 종료되지 않은 상황에서도 다음 작업이 즉시 실행된다.
  * 때문에 작업의 결과를 전달 받아 다음의 작업을 이어나가기 위한 어떠한 메커니즘이 필요하게 된다.
* **Node.js에서 비동기 작업의 완료를 통지받는 가장 기본적인 메커니즘은 콜백**이다.
  * 콜백은 단지 비동기 작업의 결과를 갖고 런타임에 호출되는 함수에 불과하다.
* **콜백은 다른 모든 비동기 메커니즘의 가장 근간을 이루므로, 콜백 없이는 프로미스와 async / await가 존재할 수 없다**.

### 콜백 패턴
* 콜백은 리액터 패턴에서 다루었던 핸들러를 구현한 것이며, Node.js의 독특한 개발 스타일을 제공하는 상징 중 하나이다.
* **콜백은 정확히 작업의 결과를 전달하기 위해 호출하는 함수로, 비동기 작업을 처리하기 위해 반드시 필요**하다.
  * **비동기의 세계에서, 콜백은 동기적인 작업을 위한 return 구문을 대신**한다.
* JS는 크게 다음과 같은 이유에서 콜백에 이상적인 언어이다.
  1. 일급 함수: 함수를 변수에 할당하거나, 인자로 전달하거나, 다른 함수에 의해 반환하거나, 자료 구조에 저장할 수 있다.
  2. 클로저: 실제로 생성된 함수의 환경을 언제든지 참조할 수 있게 한다. 
     * 즉, **콜백이 언제 어디에서 호출되었는지와 관계 없이 비동기 작업이 요청되었던 컨텍스트를 항상 유지**할 수 있다.

### 연속 전달 방식
* JS에서의 콜백은 다른 함수에 인자로 전달되는 함수이며, 전달 받은 함수는 자신의 작업이 완료되면 작업 결과를 가지고 콜백을 호출한다.
  * 함수형 프로그래밍에서, 이러한 결과 전달 방식을 연속 전달 방식(continuation passing style)이라고 한다.
  * 연속 전달 자체는 일반적인 개념이며, 비동기 작업과만 관계가 있는 개념이 아니다.
  * 오히려 **단순하게 결과를 호출자에게 반환하는 대신 콜백과 같은 다른 함수로 전달하는 것에 불과**하다.

### 동기식 연속 전달 방식
```
function add(a, b) { return a + b; }
```
* 상술한 함수와 같이 return 구문을 통해 결과를 호출자에게 반환하는 방식은 직접 스타일이다.
* 직접 스타일은 동기식 프로그래밍에서 결과를 반환하기 위해 사용하는 일반적인 방식이다.
```
function addCps(a, b, callback) { callback(a + b); }

console.log('before');
addCps(1, 2, result => console.log(result));
console.log('after');

/* 실행 결과
before
3
after
*/ 
```
* 반면, addCps는 add 함수와 동일한 처리를 연속 전달 방식으로 처리한다.
  * 이는 동기 CPS 함수에 해당하며, 콜백 또한 작업이 완료되었을 때 작업을 완료한다.
  * 해당 함수는 동기적이므로, 코드는 순서대로 실행된다.

### 비동기 연속 전달 방식
* addCps 함수는 다음과 같은 비동기 방식으로도 구현이 가능하다.
  * 이 때, setTimeout()은 이벤트 큐에 주어진 시간 후에 실행될 작업을 추가한다.
```
function additionAsync(a, b, callback) {
    setTimeout(() => callback(a + b), 100);
}

console.log('before');
additionAsync(1, 2, result => console.log(result));
console.log('after');

/* 실행 결과
before
after
3
*/ 
```
* **setTimeout()이 비동기 작업을 실행시키므로 콜백의 실행이 종료될 때까지 대기하는 대신, 즉시 additionAsync로 제어를 반환**한다.
* **Node.js에서 이러한 특징은 매우 중요하며, 이는 비동기 요청이 전달된 즉시 제어를 이벤트 루프에 반환하고 큐에 있는 새로운 이벤트를 처리할 수 있도록 한다**.
* **비동기 작업이 완료되면 실행은 비동기 함수에 제공된 콜백으로부터 재개**된다.
  * 이 때, **실행은 이벤트 루프에서 실행되므로 새로운 스택을 갖게 된다**.
  * **클로저로 인해 콜백은 다른 시점과 다른 위치에서 호출되더라도 비동기 함수의 호출 컨텍스트를 유지하며, 이는 JS가 정말 유용한 지점에 해당**한다.

### 동기 함수와 비동기 함수
* 동기 함수는 동작을 완료할 때까지 블로킹된다.
* 반면 **비동기 함수는 제어를 즉시 반환하되, 비동기 함수의 실행 결과를 이벤트 루프의 다음 사이클에서 콜백과 같은 핸들러로 전달**한다.

### 비 연속 전달 콜백
* **콜백 인자가 존재하는 경우, 함수가 비동기이거나 연속 전달 방식을 사용한다고 오판하기 쉽다**.
* 그러나 Array.prototype.map과 같은 예외가 존재하며, 이러한 메소드는 실제로는 결과를 동기적으로 반환한다.
```
console.log(
    [1, 5, 7].map(e => e * 2)
);
```
* map()과 같은 함수에서 콜백은 배열 내의 요소에 반복 적용하기 위해 사용될 뿐, 연산 결과를 반환하지는 않는다.
* 이렇듯 **연속 전달 방식과 비 연속 전달 방식에는 문법적 차이가 전무하므로, 콜백의 목적은 API 문서에 명확하게 작성되어야 한다**.

## 2022-05-20 Fri
### 동기와 비동기
* 함수가 동기 또는 비동기 중 어떤 특성을 갖느냐에 따라 실행 순서는 달라지며, 이는 정확성과 효율성 모든 면에 걸쳐 애플리케이션의 흐름에 큰 영향을 미친다.
* **반드시 피해야하는 것은 구현한 API의 특성에 따라 어렵고 재현 불가능한 문제를 일으키는 모순을 만드는 것**이다.
  * 예를 들어, 특정 조건에서는 동기적으로 동작하고 그렇지 않은 경우 비동기적으로 동작하는 API는 예측할 수 없으므로 매우 위험한 축에 속한다.

### 동기 API 사용하기
* 상술한 **예측 불가능한 함수가 초래하는 부작용을 방지하기 위해, API가 갖는 동기 또는 비동기적인 특성은 반드시 명확하게 정의**되어야 한다.
  * 선택 가능한 한 방법은 함수를 완전히 동기화시키는 것이다.
  * 전체 기능이 직접 스타일로 변환되는 경우, 함수는 CPS를 가질 이유가 없어진다.
* **동기식 API의 구현은 직접 스타일을 사용하는 것이 항상 최선의 방법**이다.
  * 이는 애플리케이션을 둘러싸는 환경으로부터 발생하는 혼란을 제거하기 위한 효율적인 방법이다.
  * **순수한 동기식 함수에서는 직접 스타일을 활용하는 것이 바람직**하다!

### 동기 API의 주의사항
```
> 애플리케이션이 비동기적인 동시성 작업을 처리하는 데에 영향을 주지 않는 경우에만 동기 API를 사용하도록 한다.
```
* CPS에서 직접 스타일로 변환하거나, 비동기에서 동기로 API를 변경하는 경우 해당 API의 모든 클라이언트 코드 스타일을 변경해야할 수도 있다.
* 또한, 비동기 API와 비교하여 동기식 API는 다음과 같은 점을 주목할 수 있다.
  1. 임의의 기능에 대해 동기식 API를 항상 활용할 수 있는 것은 아니다.
  2. **동기 API는 이벤트 루프를 블록하고 동시 요청을 보류하므로, JS의 동시성 모델을 깨트려 전체적인 애플리케이션의 속도를 느리게 한다**.
* 대부분의 경우, Node.js에서 동기 IO를 사용하는 것은 권장되지 않는다.
  * 그러나 때로는 이러한 접근이 가장 쉽고 효율적인 해결책이 되어줄 수도 있다.
  * 예를 들어, 애플리케이션의 부팅 과정에서는 동기 API를 활용하여 환경 파일들을 로드할 수 있다.

### process.nextTick()의 지연 실행으로 비동시성 보장하기
* 또 다른 방법은 API를 완전한 비동기로 만드는 것이다.
  * 이 경우, 약간의 트릭을 갖는 process.nextTick()을 활용할 수 있다.
* **process.nextTick()이 갖는 트릭은 동기 콜백 호출이 동일한 이벤트 루프 사이클에서 즉시 실행되지 않고 가까운 미래에 실행되도록 예약하는 것**이다.
  * 이 때, **process.nextTick()을 통해 지연된 콜백은 마이크로태스크라는 용어로 지칭**한다.
* process.nextTick()은 다음과 같은 동작을 수행한다.
  1. **현재 진행 중인 작업의 완료 시점 뒤로 함수의 실행을 지연**시킨다.
  2. 콜백을 인수로 받아 대기 중인 IO 이벤트 대기열의 '앞으로' 추가한 후, 즉시 반환한다.
  3. 때문에 현재 진행 중인 작업이 제어권을 이벤트 루프로 넘기는 순간 콜백이 실행된다.
* 이렇듯 **process.nextTick()을 활용하여 실행을 연기하고 콜백의 비동기적인 호출을 보장**할 수 있다. 

### setImmediate() 사용하기
* setImmediate()은 함수의 실행을 지연시키는 또 다른 API로, 그 목적은 process.nextTick()과 유사하다.
  * 그러나, setImmediate() API가 갖는 의미는 크게 다르다.
* 마이크로태스크는 현재의 작업이 완료된 직후에 실행되며, 다른 IO 이벤트가 발생하기 전에 실행된다.
  * 때문에 재귀 호출과 같은 특정한 상황에서 필연적으로 IO 기아 상태를 발생시킬 수 있다.
* 반면 **setImmediate()는 이미 큐에 존재하는 IO 이벤트들의 '뒤에서' 대기하므로, IO 기아 상태는 절대 발생하지 않는다**.
* setTimeout(callback, 0)으로 setImmediate()와 비슷한 동작을 흉내낼 수 있다.
  * 그러나 **특정한 상황에서는 setImmediate()로 예약된 콜백이 setTimeout()으로 예약된 것보다 빠르게 실행**된다.
  * 이는 이벤트 루프가 모든 콜백을 서로 다른 단계에서 실행시키기 때문으로, 타이머는 IO 콜백 이전에 실행된다.
  * **타이머는 다시 setImmediate()의 콜백 이전에 실행되므로, 특정한 상황에서 setTimeout의 콜백은 이벤트 루프의 다음 사이클을 기다려야**만 한다.

### Node.js의 콜백 규칙
* Node.js의 코어 API 등에서 사용되는 CPS API 및 콜백은 다음과 같은 일련의 규칙을 따라 작성된다.
  1. 콜백은 맨 마지막 인수로 작성한다.
  2. 오류는 콜백의 첫 번째 인수로 작성한다.
  3. 오류는 콜백으로 전달하여 전파한다.
* **이러한 규칙은 Node.js의 코어 API 뿐만 아니라, 대부분의 사용자 영역 모듈과 애플리케이션에도 적용**된다.
  * 때문에 콜백을 사용하는 비동기 API를 설계하는 경우, 이를 반드시 이해하고 준수하는 것이 중요하다.

### 콜백은 맨 마지막에
* **모든 Node.js 코어 함수의 표준 규칙은 함수가 입력으로서의 콜백을 허용하는 경우, 맨 마지막 인자로 콜백을 전달한다는 것**이다.
  * 여러 인자가 존재하는 경우에도 콜백은 항상 마지막에 위치해야 한다.
* 이러한 규칙은 콜백을 적절한 위치에 작성하는 것으로 함수 호출시의 가독성을 높여주는 효과를 준다.

### 오류는 맨 처음에
* CPS에서는 오류가 다른 유형 함수의 결과처럼 전달되므로 콜백을 사용해야 한다.
* **Node.js의 CPS 함수로부터 생성된 오류는 언제나 콜백의 첫 번째 인자로 전달되며, 실제 연산 결과는 두 번째 인자로부터 전달**된다.
  * 때문에 함수가 에러 없이 성공한 경우, 오류를 나타내는 첫 번째 인자는 null 또는 undefined여야 한다.
* **콜백 함수의 첫 번째 인자로 전달되는 에러의 존재 유무를 항상 확인하는 습관을 들이는 것이 바람직**하다.
* 또한, 전달되는 오류는 항상 문자열이나 숫자가 아닌 Error 타입이어야 한다.

### 오류의 전파
* 동기식 직접 스타일 함수의 오류 전파는 일반적으로 throw 문을 통해 전파되어, 오류가 catch될 때까지 호출 스택에서 실행된다.
* 반면, **비동기식 CPS에서 적절한 오류의 전파는 오류를 호출 체인의 다음에서 콜백으로 전달하여 수행**된다.
  * 따라서 **에러를 다시 밖으로 발생시키거나 리턴하지 않고, 다른 결과와 마찬가지로 콜백을 통해 전파**한다.
```
function readJson(fileName, callback) {
  readFile(fileName, 'utf-8', function(error, data) {
    let parsed;
    if(error) 
      return callback(error); // 에러를 전파하고 현재의 함수에서 빠져나온다.
    
    try {
      parsed = JSON.parse(data);
    } catch(e) {
      return callback(e);
    }
    callback(null, parsed);
  });
}
```
* 상술한 코드에서, **readFile 함수를 실행하였을 때 에러는 callback을 통해 전파**된다.
  * 예를 들어, throw error 또는 return error와 같은 형식로 작성하지 않는다.
  * 대신 다른 결과를 반환하듯이 에러를 콜백으로 반환한다.
* 동기식 함수인 JSON.parse의 파싱 에러는 처리하기 위해 전통적인 try - catch 구문을 사용한다.
  * 이 때, 해당 try - catch 구문에서는 의도적으로 callback을 사용하지 않는다.
  * 예를 들어, 콜백 함수 자체가 발생시키는 에러를 catch하는 것은 코드를 개발하는 과정에서 의도된 사항이 아니어야 한다.
* **모든 것이 정상적으로 동작한 경우, 콜백은 에러가 발생하지 않았다는 사실을 콜백의 첫 번째 인자에 null을 전달하여 호출하는 것으로 명시**한다.

### 캐치되지 않는 예외
* 종종 **비동기 함수의 콜백 내부에서 발생한 에러가 밖으로 전파되거나, catch되지 않는 현상이 발생**할 수 있다.
  * **비동기식 콜백 내부에서 예외를 발생시키는 것은 예외가 이벤트 루프로 이동하게 만든다**.
  * 이러한 경우, 에러는 절대로 다음 콜백으로 전파되지 않는다.
  * Node.js에서 이러한 상황은 회복 불가능하며, 애플리케이션은 0 이외의 종료 코드와 함께 종료되어 stderr 인터페이스를 통해 오류를 출력한다.
* **콜백에서 발생하여 처리되지 못한 예외는 콜백에서 스택으로 이동한 후, 즉시 이벤트 루프로 이동되어 콘솔에서 포착**된다.
  * **코드가 동작하는 스택과 콜백이 호출되는 스택이 달라지므로, 에러가 발생하는 코드를 try - catch 구문으로 감싼다고 하더라도 이는 처리**되지 않는다.
  * **이 경우 발생한 에러는 비동기식 실행을 시작하는 함수 내부에서 catch되는 것이 아닌, 이벤트 루프에서 예외가 발생한 별도의 콜 스택을 타고 전파**된다.
* 이렇게 발생한 예외가 이벤트 루프에 도달하는 순간 애플리케이션은 중단된다.
* **애플리케이션이 비정상 종료되기 전에 자원을 정리하거나 로그를 남기기 위해 uncaughtException 이벤트를 잡아 처리할 수 있다**.
```
process.on('uncaughtException', (err) => {
  console.log(err);
  process.exit(1); // 해당 부분이 없으면 애플리케이션은 계속된다.
});
```
* 캐치되지 않는 예외는 애플리케이션의 일관성을 보장할 수 없는 상태로 만들기 때문에 전혀 예상치 못한 문제를 발생시킬 수 있다.
  * 예를 들어, 불완전한 IO 요청이 여전히 실행되거나 클로저가 일치하지 않을 수 있다.
* 캐치되지 않는 예외가 발생한 경우, 특히나 운영 환경에서는 애플리케이션을 실행 상태에 두지 않아야 한다.
  * 필요한 작업을 정리한 후에 프로세스는 즉시 종료되어야 하며, 그 이후에 프로세스 관리자가 애플리케이션을 재시작하는 방식을 취할 수 있다.
  * 이는 **fail fast 접근법에 해당하며, 동시에 Node.js에서 권장되는 사항**이기도 하다.

## 2022-05-21 Sat
### 관찰자 패턴
* **관찰자 패턴은 콜백과 리액터 못지 않게 Node.js에서 기본적으로 사용되는 중요한 패턴**이다.
  * 따라서 관찰자 패턴을 익히는 것은 비동기적인 Node.js의 세계를 숙달하기 위해서는 필수적이다.
* 관찰자 패턴은 Node.js의 반응적 특성을 모델링하고, 콜백을 완벽히 보완하는 이상적인 해결책이다.
* **관찰자 패턴은 상태 변화가 발생했을 경우 리스너와 같은 관찰자에게 통지할 수 있는 객체를 정의하는 것**이다.
* 관찰자 패턴과 전통적인 CPS 콜백은 다음과 같은 차이를 갖는다.
  1. 콜백 패턴은 오직 하나의 리스너에게 결과를 전달한다.
  2. 반면, **관찰자 패턴은 주체가 여러 관찰자에게 통지할 수 있다**.

### EventEmitter
* 전통적인 객체지향 프로그래밍에서 관찰자 패턴을 구현하려면 인터페이스와 구현 클래스, 그리고 계층 구조가 필수적이다.
* 반면 **Node.js의 경우 이미 관찰자 패턴이 코어에 내장되어 있으며, EventEmitter 클래스를 활용하여 사용**할 수 있다.
  * **EventEmitter 클래스를 활용하여 특정한 유형의 이벤트가 발생되면 호출되는 하나 이상의 함수를 리스너로 등록**할 수 있다.
* EventEmitter는 events 코어 모듈로부터 익스포트되므로, 다음과 같이 인스턴스를 생성할 수 있다.
```
import { EventEmitter } from 'events';
const emitter = new EventEmitter();
```
* EventEmitter 클래스는 다음과 같은 필수 메소드를 갖는다.
  1. on(event, listener): 주어진 이벤트 유형에 대해 새로운 리스너인 함수를 등록한다.
  2. once(event, listener): 주어진 이벤트 유형이 처음 전달되면 제거되는 새로운 리스너를 등록한다.
  3. emit(event, [arg1], [...]): 새로운 이벤트를 생성하고, 리스너에게 전달할 추가적인 인자를 제공한다.
  4. removeListener(event, listener): 지정된 이벤트 유형에 설정된 리스너를 제거한다.
* 상술한 **모든 메소드는 메소드 체이닝을 지원하기 위해 EventEmitter 인스턴스를 반환**한다.
* listener 함수는 [arg1], [...]과 같은 시그니쳐 함수를 갖기에 이벤트가 발생한 순간에 전달된 인수들을 쉽게 받아들일 수 있다.
* 이렇듯 리스너 함수와 전통적인 Node.js 콜백 사이에는 다음과 같은 큰 차이점이 존재한다.
  1. 첫 번째 인자가 반드시 error일 필요가 없다.
  2. **emit() 메소드가 호출될 때 어떠한 값이든 전달이 가능**하다.

### EventEmitter의 생성과 사용
* EventEmitter를 실제로 사용하는 가장 쉬운 방법은 인스턴스를 만들어 사용하는 것이다.
```
import { EventEmitter } from 'events';
import { readFile } from 'fs';

function findRegex( files = [], regex ) {
  const emitter = new EventEmitter(); // 함수 실행시 EventEmitter를 신규 생성한다.
  for(const file of files) {
    readFile(file, 'utf8', (err, content) => {
      if(err) // readFile에서 발생한 에러는 error 이벤트로 반환한다.
        return emitter.emit('error', err);

      emitter.emit('fileread', file); // 파일을 읽기 시작할 때 fileread 이벤트를 발생시킨다.
      const match = content.match(regex);
      if(match)
        match.forEach(elem => emitter.emit('found', file, elem)); // 정규표현식 결과에 따라 found 이벤트를 발생시킨다.
    });
  }

  return emitter;
}
```
* findRegex 함수는 다음과 같은 세 가지 이벤트를 발생시키는 EventEmitter 인스턴스를 반환한다.
  1. fileread: 파일을 읽기 시작할 때 발생
  2. found: 일치하는 항목이 발견되었을 때 발생
  3. error: 파일을 읽는 과정에서 에러가 발생했을 때
* **findRegex 함수를 사용하는 경우, 다음과 같이 반환된 EventEmitter 인스턴스에 이벤트 타입 별 리스너를 등록**한다.
```
findRegex([ './input/fileA.txt', './input/fileB.txt' ], /hello \w+/) // EventEmitter 인스턴스를 반환한다.
  .on('fileread', file => console.log(`${file} was read`)) // 반환된 EventEmitter 인스턴스에 리스너를 등록한다.
  .on('found', (file, match) => console.log(`Matched ${match} in ${file}`))
  .on('error', err => console.error(`Error emitted ${err.message}`));
```

### EventEmitter 오류 전파
* EventEmitter는 콜백과 마찬가지로 에러가 발생하였을 때 예외를 throw할 수는 없다.
* 상술한 코드에서, return emitter.emit('error', err)가 아닌 throw new Error()를 작성할 경우 애플리케이션은 비정상 종료된다.
* **예외를 throw하는 대신 error 이벤트를 발생시키고, Error 객체를 error 이벤트의 인자로 전달하는 규약을 따르는 것이 바람직**하다.
  * 상술한 findRegex 함수에서도 이러한 방식이 적용되었다.
* EventEmitter에서 **error 이벤트가 발생했지만 적절한 리스너가 없을 경우, 예외는 throw 되어 애플리케이션이 종료**된다.
  * 이러한 이유에서 **error 이벤트에 대한 리스너는 반드시 등록해주는 것이 권장**된다.

### 관찰 가능한 객체 만들기
* 상술한 방식으로 EventEmitter 인스턴스를 직접 사용하는 것은 Node.js에서는 드문 방식이다.
* **대신 EventEmitter를 확장하는 별도의 클래스를 사용하는 것이 일반적이며, 이로 인해 어떠한 클래스라도 관찰 가능한 객체가 될 수 있다**.
* 상술한 findRegex 함수를 EventEmitter 클래스를 확장하는 신규 클래스로 수정한 결과는 다음과 같다.
  * 이는 Node.js 세계에서는 일반적인 패턴이다.
```
import { EventEmitter } from 'events';
import { readFile } from 'fs';

export default class FindRegex extends EventEmitter {
  #regex
  #files = [];
  #encoding = 'utf8';
  #EVENT = {
    ERROR: 'error',
    FOUND: 'found',
    FILE_READ: 'fileread',
  };

  constructor(regex) {
    super();
    this.#regex = regex;
  }

  addFile(file) {
    this.#files.push(file);
    return this;
  }

  find() {
    for(const file of this.#files) {
      readFile(file, this.#encoding, (error, content) => {
        if(error)
          return this.emit(this.#EVENT.ERROR, error);

        this.emit(this.#EVENT.FILE_READ, file);

        const match = content.match(this.#regex);
        if(match)
          match.forEach(elem => this.emit(this.#EVENT.FOUND, file, elem));
      });
    }

    return this;
  }
}
```
* 해당 클래스는 다음과 같은 형태로 사용할 수 있다.
```
import FindRegex from './FindRegex.js';

new FindRegex(/hello \w+/)
  .addFile('./input/fileA.txt')
  .addFile('./input/fileB.txt')
  .find()
  .on('fileread', file => console.log(`${file} was read`))
  .on('found', (file, match) => console.log(`Matched ${match} in ${file}`))
  .on('error', err => console.error(`Error emitted ${err.message}`));
```

### EventEmitter와 메모리 누수
* 메모리 누수는 메모리가 더 이상 필요하지 않음에도 해제되지 않아 애플리케이션의 메모리 사용량을 점진적으로 증가시키는 소프트웨어 결함이다.
* **관찰 가능한 대상에 대해 오랜 시간에 걸쳐 구독하는 경우, 더 이상 관찰이 필요하지 않는 시점에 구독을 해지하는 것은 매우 중요**하다.
  * 구독 해지는 메모리 누수를 예방하고, 리스너의 스코프에 있는 객체로부터 더 이상 사용되지 않는 메모리 점유를 풀어준다.
  * **Node.js와, 심지어 JS에서도 EventEmitter 리스너의 등록을 해지하지 않는 습관은 메모리 누수의 주된 원인**이다.
```
const thisTakesMemory = 'Big Big ...';
emitter.on('an_event', () => {
  console.log(thisTakesMemory);
});
```
* 상술한 코드는 변수 thisTakesMemory가 리스너에서 참조되며, 리스너가 해제되기 전까지 메모리에 유지된다.
  * 또는 emitter 자체에 대한 참조가 유실되어 도달 불가능한 상태가 되는 것으로 GC되기 전까지 유지된다.
* 이는 즉 **애플리케이션의 전체 주기 동안 EventEmitter는 모든 리스너가 참조하는 메모리와 함께 도달 가능한 상태를 유지함을 의미**한다.
* 이러한 방식은 애플리케이션에 의해 사용되는 메모리를 무한정 증가시키며, 종국에는 애플리케이션을 망가트리게 된다.
* **EventEmitter로 인한 메모리 누수를 미연에 방지하기 위해 EventEmitter가 제공하는 removeListener()로 리스너를 명시적으로 해제**할 수 있다.
  * 또는 첫 번째 이벤트를 수신한 후 자동으로 리스너를 해지하는 once()를 사용할 수도 있다.
  * 그러나 발생하지 않는 이벤트를 명시하는 경우 리스너는 절대로 해지되지 않으며, 이 역시 메모리 누수의 원인이 될 수 있다.
* **EventEmitter는 메모리 누수의 가능성을 경고하기 위해 리스너의 수가 10개를 초과하면 메시지를 발생시키는 내장 메커니즘을 갖고 있다**.
  * 때로는 10개 이상을 등록하더라도 문제가 없는 경우가 있으므로, setMaxListeners() 메소드를 통해 제한을 풀어줄 수 있다.

## 2022-05-22 Sun
### 동기, 비동기 이벤트
* 이벤트 역시 콜백과 마찬가지로 이벤트를 생성하는 작업이 호출되는 순간에 따라 동기적, 또는 비동기적으로 발생될 수 있다.
* **중요한 것은 동일한 EventEmitter에서 두 방식을 혼합하지 않아야한다는 사실**이다.
* **이벤트가 비동기적으로 발생하는 경우, 현재의 스택이 이벤트 루프에 넘어갈 때까지는 이벤트 발생 작업 이후에도 새로운 리스너를 등록할 수 있다**.
  * 이는 **이벤트 루프의 다음 사이클이 될 때까지는 이벤트가 실행되지 않는 것이 보장되기 때문**이다.
  * 이로 인해 어떠한 이벤트도 놓치지 않을 수 있게 된다.
```
new FindRegex(/hello \w+/)
  .addFile('./input/fileA.txt')
  .addFile('./input/fileB.txt')
  .find() // 이벤트를 발생시키는 메소드이다.
  .on('fileread', file => console.log(`${file} was read`)) // 그러나 이벤트 발생 메소드 이후에도 리스너를 등록할 수 있다.
  .on('found', (file, match) => console.log(`Matched ${match} in ${file}`))
  .on('error', err => console.error(`Error emitted ${err.message}`));
```
* 상술한 코드에서, find() 메소드는 메소드 호출 이후에 비동기적으로 이벤트를 발생시킨다.
  * 때문에 이벤트의 손실 없이도 find() 메소드 호출 이후에도 리스너를 등록할 수 있다.
* 반면, **작업이 이벤트를 동기적으로 발생시키는 경우에는 반드시 모든 리스너가 작업 실행 전에 등록되어야 한다**.
  * 이 경우, 동기적으로 수정된 find() 작업 이후에 등록한 리스너는 절대로 호출되지 않는다.
  * 때로는 비동기적 방식 대신 동기적 방식의 이벤트 발생이 적절한 경우도 있다.
* EventEmitter의 본질은 비동기 이벤트를 다루는 데에 있다.
  * 때문에 이벤트를 동기적으로 발생시키는 것은 EventEmitter가 필요하지 않거나, 다른 관찰 가능 객체가 이벤트를 비동기적으로 발생시키고 있다는 신호이다.

### EventEmitter와 콜백
* 비동기식 API를 정의하는 과정에서 발생하기 쉬운 딜레마는 EventEmitter와 콜백 중 하나를 선택하는 것이다.
* 일반적으로 **결과가 비동기적으로 반환되어야하는 경우에는 콜백을 사용하며, 이벤트는 발생한 사건 자체와 연결될 때 사용되곤 한다**.
  * 그러나 대부분의 경우에서 두 방식은 동일한 결과를 얻을 수 있도록 한다.
* 둘 중 어떠한 방식을 사용해야할 지 결정하는 데에 도움을 줄 수 있는 근거는 다음과 같이 분류할 수 있다.
  1. 콜백은 여러 유형의 결과를 전달하는 데에는 한계가 있다.
     * 콭백의 인자로 타입을 전달하거나, 각 이벤트에 적절한 여러 콜백을 취할 수도 있으나 이는 깔끔한 API로 볼 수 없다.
  2. EventEmitter는 같은 이벤트가 여러 번 발생하거나, 발생하지 않을 수도 있는 경우에 적절하다.
     * 반면, 콜백은 작업의 성공 여부와 관계 없이 정확히 한 번만 호출된다.
     * 때문에 **반복 가능성을 갖는 경우는 결과를 알려주는 기능인 이벤트와 더 유사하다고 볼 수 있다**.
  3. 콜백을 사용하는 API는 오직 특정한 하나의 콜백만을 호출할 수 있다.
     * 반면 EventEmitter는 같은 이벤트에 대해 다수의 리스너를 등록할 수 있다.

### EventEmitter와 콜백의 결합
* 두 방식을 함께 사용할 수 있는 상황도 존재할 수 있으며, 이러한 결합 패턴은 매우 강력한 방식이다.
  * 예를 들어, 전통적인 콜백을 통해 결과를 비동기적으로 전달하되 EventEmitter를 반환하여 비동기 처리에 대한 상세한 판단을 제공할 수 있다.
* 전통적인 콜백과 EventEmitter를 결합하는 것은 같은 API에 두 가지 접근을 제공하는 우아한 방법으로 여겨진다.
  * 하나의 접근 방식을 채택하는 것은 더 간단하고 즉각적인 경우에 사용되며, 결합하는 방식은 심화된 시나리오에서 사용될 수 있다.
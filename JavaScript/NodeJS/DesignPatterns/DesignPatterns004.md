# DesignPatterns
## 2022-05-19 Thu

## 콜백과 이벤트
* 일반적인 개발자들은 동기식 프로그래밍에서, 특정한 문제를 해결하기 위해 일련의 연속 작업 형태를 띄는 코드를 작성하는 데에 익숙하다.
  * 동기식 프로그래밍의 모든 작업은 블로킹이며, 현재 작업이 종료된 후에야 다음 작업을 실행할 수 있다.
* 반면, 비동기식 프로그래밍에서는 IO와 같은 일부 작업을 백그라운드에서 실행할 수 있다.
* 비동기 작업이 호출되면 이전 작업이 완전히 종료되지 않은 상황에서도 다음 작업이 즉시 실행된다.
  * 때문에 작업의 결과를 전달 받아 다음의 작업을 이어나가기 위한 어떠한 메커니즘이 필요하게 된다.
* **Node.js에서 비동기 작업의 완료를 통지받는 가장 기본적인 메커니즘은 콜백**이다.
  * 콜백은 단지 비동기 작업의 결과를 갖고 런타임에 호출되는 함수에 불과하다.
* **콜백은 다른 모든 비동기 메커니즘의 가장 근간을 이루므로, 콜백 없이는 프로미스와 async / await가 존재할 수 없다**.

### 콜백 패턴
* 콜백은 리액터 패턴에서 다루었던 핸들러를 구현한 것이며, Node.js의 독특한 개발 스타일을 제공하는 상징 중 하나이다.
* **콜백은 정확히 작업의 결과를 전달하기 위해 호출하는 함수로, 비동기 작업을 처리하기 위해 반드시 필요**하다.
  * **비동기의 세계에서, 콜백은 동기적인 작업을 위한 return 구문을 대신**한다.
* JS는 크게 다음과 같은 이유에서 콜백에 이상적인 언어이다.
  1. 일급 함수: 함수를 변수에 할당하거나, 인자로 전달하거나, 다른 함수에 의해 반환하거나, 자료 구조에 저장할 수 있다.
  2. 클로저: 실제로 생성된 함수의 환경을 언제든지 참조할 수 있게 한다. 
     * 즉, **콜백이 언제 어디에서 호출되었는지와 관계 없이 비동기 작업이 요청되었던 컨텍스트를 항상 유지**할 수 있다.

### 연속 전달 방식
* JS에서의 콜백은 다른 함수에 인자로 전달되는 함수이며, 전달 받은 함수는 자신의 작업이 완료되면 작업 결과를 가지고 콜백을 호출한다.
  * 함수형 프로그래밍에서, 이러한 결과 전달 방식을 연속 전달 방식(continuation passing style)이라고 한다.
  * 연속 전달 자체는 일반적인 개념이며, 비동기 작업과만 관계가 있는 개념이 아니다.
  * 오히려 **단순하게 결과를 호출자에게 반환하는 대신 콜백과 같은 다른 함수로 전달하는 것에 불과**하다.

### 동기식 연속 전달 방식
```
function add(a, b) { return a + b; }
```
* 상술한 함수와 같이 return 구문을 통해 결과를 호출자에게 반환하는 방식은 직접 스타일이다.
* 직접 스타일은 동기식 프로그래밍에서 결과를 반환하기 위해 사용하는 일반적인 방식이다.
```
function addCps(a, b, callback) { callback(a + b); }

console.log('before');
addCps(1, 2, result => console.log(result));
console.log('after');

/* 실행 결과
before
3
after
*/ 
```
* 반면, addCps는 add 함수와 동일한 처리를 연속 전달 방식으로 처리한다.
  * 이는 동기 CPS 함수에 해당하며, 콜백 또한 작업이 완료되었을 때 작업을 완료한다.
  * 해당 함수는 동기적이므로, 코드는 순서대로 실행된다.

### 비동기 연속 전달 방식
* addCps 함수는 다음과 같은 비동기 방식으로도 구현이 가능하다.
  * 이 때, setTimeout()은 이벤트 큐에 주어진 시간 후에 실행될 작업을 추가한다.
```
function additionAsync(a, b, callback) {
    setTimeout(() => callback(a + b), 100);
}

console.log('before');
additionAsync(1, 2, result => console.log(result));
console.log('after');

/* 실행 결과
before
after
3
*/ 
```
* **setTimeout()이 비동기 작업을 실행시키므로 콜백의 실행이 종료될 때까지 대기하는 대신, 즉시 additionAsync로 제어를 반환**한다.
* **Node.js에서 이러한 특징은 매우 중요하며, 이는 비동기 요청이 전달된 즉시 제어를 이벤트 루프에 반환하고 큐에 있는 새로운 이벤트를 처리할 수 있도록 한다**.
* **비동기 작업이 완료되면 실행은 비동기 함수에 제공된 콜백으로부터 재개**된다.
  * 이 때, **실행은 이벤트 루프에서 실행되므로 새로운 스택을 갖게 된다**.
  * **클로저로 인해 콜백은 다른 시점과 다른 위치에서 호출되더라도 비동기 함수의 호출 컨텍스트를 유지하며, 이는 JS가 정말 유용한 지점에 해당**한다.

### 동기 함수와 비동기 함수
* 동기 함수는 동작을 완료할 때까지 블로킹된다.
* 반면 **비동기 함수는 제어를 즉시 반환하되, 비동기 함수의 실행 결과를 이벤트 루프의 다음 사이클에서 콜백과 같은 핸들러로 전달**한다.

### 비 연속 전달 콜백
* **콜백 인자가 존재하는 경우, 함수가 비동기이거나 연속 전달 방식을 사용한다고 오판하기 쉽다**.
* 그러나 Array.prototype.map과 같은 예외가 존재하며, 이러한 메소드는 실제로는 결과를 동기적으로 반환한다.
```
console.log(
    [1, 5, 7].map(e => e * 2)
);
```
* map()과 같은 함수에서 콜백은 배열 내의 요소에 반복 적용하기 위해 사용될 뿐, 연산 결과를 반환하지는 않는다.
* 이렇듯 **연속 전달 방식과 비 연속 전달 방식에는 문법적 차이가 전무하므로, 콜백의 목적은 API 문서에 명확하게 작성되어야 한다**.

## 2022-05-20 Fri
### 동기와 비동기
* 함수가 동기 또는 비동기 중 어떤 특성을 갖느냐에 따라 실행 순서는 달라지며, 이는 정확성과 효율성 모든 면에 걸쳐 애플리케이션의 흐름에 큰 영향을 미친다.
* **반드시 피해야하는 것은 구현한 API의 특성에 따라 어렵고 재현 불가능한 문제를 일으키는 모순을 만드는 것**이다.
  * 예를 들어, 특정 조건에서는 동기적으로 동작하고 그렇지 않은 경우 비동기적으로 동작하는 API는 예측할 수 없으므로 매우 위험한 축에 속한다.

### 동기 API 사용하기
* 상술한 **예측 불가능한 함수가 초래하는 부작용을 방지하기 위해, API가 갖는 동기 또는 비동기적인 특성은 반드시 명확하게 정의**되어야 한다.
  * 선택 가능한 한 방법은 함수를 완전히 동기화시키는 것이다.
  * 전체 기능이 직접 스타일로 변환되는 경우, 함수는 CPS를 가질 이유가 없어진다.
* **동기식 API의 구현은 직접 스타일을 사용하는 것이 항상 최선의 방법**이다.
  * 이는 애플리케이션을 둘러싸는 환경으로부터 발생하는 혼란을 제거하기 위한 효율적인 방법이다.
  * **순수한 동기식 함수에서는 직접 스타일을 활용하는 것이 바람직**하다!

### 동기 API의 주의사항
```
> 애플리케이션이 비동기적인 동시성 작업을 처리하는 데에 영향을 주지 않는 경우에만 동기 API를 사용하도록 한다.
```
* CPS에서 직접 스타일로 변환하거나, 비동기에서 동기로 API를 변경하는 경우 해당 API의 모든 클라이언트 코드 스타일을 변경해야할 수도 있다.
* 또한, 비동기 API와 비교하여 동기식 API는 다음과 같은 점을 주목할 수 있다.
  1. 임의의 기능에 대해 동기식 API를 항상 활용할 수 있는 것은 아니다.
  2. **동기 API는 이벤트 루프를 블록하고 동시 요청을 보류하므로, JS의 동시성 모델을 깨트려 전체적인 애플리케이션의 속도를 느리게 한다**.
* 대부분의 경우, Node.js에서 동기 IO를 사용하는 것은 권장되지 않는다.
  * 그러나 때로는 이러한 접근이 가장 쉽고 효율적인 해결책이 되어줄 수도 있다.
  * 예를 들어, 애플리케이션의 부팅 과정에서는 동기 API를 활용하여 환경 파일들을 로드할 수 있다.

### process.nextTick()의 지연 실행으로 비동시성 보장하기
* 또 다른 방법은 API를 완전한 비동기로 만드는 것이다.
  * 이 경우, 약간의 트릭을 갖는 process.nextTick()을 활용할 수 있다.
* **process.nextTick()이 갖는 트릭은 동기 콜백 호출이 동일한 이벤트 루프 사이클에서 즉시 실행되지 않고 가까운 미래에 실행되도록 예약하는 것**이다.
  * 이 때, **process.nextTick()을 통해 지연된 콜백은 마이크로태스크라는 용어로 지칭**한다.
* process.nextTick()은 다음과 같은 동작을 수행한다.
  1. **현재 진행 중인 작업의 완료 시점 뒤로 함수의 실행을 지연**시킨다.
  2. 콜백을 인수로 받아 대기 중인 IO 이벤트 대기열의 '앞으로' 추가한 후, 즉시 반환한다.
  3. 때문에 현재 진행 중인 작업이 제어권을 이벤트 루프로 넘기는 순간 콜백이 실행된다.
* 이렇듯 **process.nextTick()을 활용하여 실행을 연기하고 콜백의 비동기적인 호출을 보장**할 수 있다. 

### setImmediate() 사용하기
* setImmediate()은 함수의 실행을 지연시키는 또 다른 API로, 그 목적은 process.nextTick()과 유사하다.
  * 그러나, setImmediate() API가 갖는 의미는 크게 다르다.
* 마이크로태스크는 현재의 작업이 완료된 직후에 실행되며, 다른 IO 이벤트가 발생하기 전에 실행된다.
  * 때문에 재귀 호출과 같은 특정한 상황에서 필연적으로 IO 기아 상태를 발생시킬 수 있다.
* 반면 **setImmediate()는 이미 큐에 존재하는 IO 이벤트들의 '뒤에서' 대기하므로, IO 기아 상태는 절대 발생하지 않는다**.
* setTimeout(callback, 0)으로 setImmediate()와 비슷한 동작을 흉내낼 수 있다.
  * 그러나 **특정한 상황에서는 setImmediate()로 예약된 콜백이 setTimeout()으로 예약된 것보다 빠르게 실행**된다.
  * 이는 이벤트 루프가 모든 콜백을 서로 다른 단계에서 실행시키기 때문으로, 타이머는 IO 콜백 이전에 실행된다.
  * **타이머는 다시 setImmediate()의 콜백 이전에 실행되므로, 특정한 상황에서 setTimeout의 콜백은 이벤트 루프의 다음 사이클을 기다려야**만 한다.
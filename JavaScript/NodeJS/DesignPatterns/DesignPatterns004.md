# DesignPatterns
## 2022-05-19 Thu

## 콜백과 이벤트
* 일반적인 개발자들은 동기식 프로그래밍에서, 특정한 문제를 해결하기 위해 일련의 연속 작업 형태를 띄는 코드를 작성하는 데에 익숙하다.
  * 동기식 프로그래밍의 모든 작업은 블로킹이며, 현재 작업이 종료된 후에야 다음 작업을 실행할 수 있다.
* 반면, 비동기식 프로그래밍에서는 IO와 같은 일부 작업을 백그라운드에서 실행할 수 있다.
* 비동기 작업이 호출되면 이전 작업이 완전히 종료되지 않은 상황에서도 다음 작업이 즉시 실행된다.
  * 때문에 작업의 결과를 전달 받아 다음의 작업을 이어나가기 위한 어떠한 메커니즘이 필요하게 된다.
* **Node.js에서 비동기 작업의 완료를 통지받는 가장 기본적인 메커니즘은 콜백**이다.
  * 콜백은 단지 비동기 작업의 결과를 갖고 런타임에 호출되는 함수에 불과하다.
* **콜백은 다른 모든 비동기 메커니즘의 가장 근간을 이루므로, 콜백 없이는 프로미스와 async / await가 존재할 수 없다**.

### 콜백 패턴
* 콜백은 리액터 패턴에서 다루었던 핸들러를 구현한 것이며, Node.js의 독특한 개발 스타일을 제공하는 상징 중 하나이다.
* **콜백은 정확히 작업의 결과를 전달하기 위해 호출하는 함수로, 비동기 작업을 처리하기 위해 반드시 필요**하다.
  * **비동기의 세계에서, 콜백은 동기적인 작업을 위한 return 구문을 대신**한다.
* JS는 크게 다음과 같은 이유에서 콜백에 이상적인 언어이다.
  1. 일급 함수: 함수를 변수에 할당하거나, 인자로 전달하거나, 다른 함수에 의해 반환하거나, 자료 구조에 저장할 수 있다.
  2. 클로저: 실제로 생성된 함수의 환경을 언제든지 참조할 수 있게 한다. 
     * 즉, **콜백이 언제 어디에서 호출되었는지와 관계 없이 비동기 작업이 요청되었던 컨텍스트를 항상 유지**할 수 있다.

### 연속 전달 방식
* JS에서의 콜백은 다른 함수에 인자로 전달되는 함수이며, 전달 받은 함수는 자신의 작업이 완료되면 작업 결과를 가지고 콜백을 호출한다.
  * 함수형 프로그래밍에서, 이러한 결과 전달 방식을 연속 전달 방식(continuation passing style)이라고 한다.
  * 연속 전달 자체는 일반적인 개념이며, 비동기 작업과만 관계가 있는 개념이 아니다.
  * 오히려 **단순하게 결과를 호출자에게 반환하는 대신 콜백과 같은 다른 함수로 전달하는 것에 불과**하다.

### 동기식 연속 전달 방식
```
function add(a, b) { return a + b; }
```
* 상술한 함수와 같이 return 구문을 통해 결과를 호출자에게 반환하는 방식은 직접 스타일이다.
* 직접 스타일은 동기식 프로그래밍에서 결과를 반환하기 위해 사용하는 일반적인 방식이다.
```
function addCps(a, b, callback) { callback(a + b); }

console.log('before');
addCps(1, 2, result => console.log(result));
console.log('after');

/* 실행 결과
before
3
after
*/ 
```
* 반면, addCps는 add 함수와 동일한 처리를 연속 전달 방식으로 처리한다.
  * 이는 동기 CPS 함수에 해당하며, 콜백 또한 작업이 완료되었을 때 작업을 완료한다.
  * 해당 함수는 동기적이므로, 코드는 순서대로 실행된다.

### 비동기 연속 전달 방식
* addCps 함수는 다음과 같은 비동기 방식으로도 구현이 가능하다.
  * 이 때, setTimeout()은 이벤트 큐에 주어진 시간 후에 실행될 작업을 추가한다.
```
function additionAsync(a, b, callback) {
    setTimeout(() => callback(a + b), 100);
}

console.log('before');
additionAsync(1, 2, result => console.log(result));
console.log('after');

/* 실행 결과
before
after
3
*/ 
```
* **setTimeout()이 비동기 작업을 실행시키므로 콜백의 실행이 종료될 때까지 대기하는 대신, 즉시 additionAsync로 제어를 반환**한다.
* **Node.js에서 이러한 특징은 매우 중요하며, 이는 비동기 요청이 전달된 즉시 제어를 이벤트 루프에 반환하고 큐에 있는 새로운 이벤트를 처리할 수 있도록 한다**.
* **비동기 작업이 완료되면 실행은 비동기 함수에 제공된 콜백으로부터 재개**된다.
  * 이 때, **실행은 이벤트 루프에서 실행되므로 새로운 스택을 갖게 된다**.
  * **클로저로 인해 콜백은 다른 시점과 다른 위치에서 호출되더라도 비동기 함수의 호출 컨텍스트를 유지하며, 이는 JS가 정말 유용한 지점에 해당**한다.

### 동기 함수와 비동기 함수
* 동기 함수는 동작을 완료할 때까지 블로킹된다.
* 반면 **비동기 함수는 제어를 즉시 반환하되, 비동기 함수의 실행 결과를 이벤트 루프의 다음 사이클에서 콜백과 같은 핸들러로 전달**한다.

### 비 연속 전달 콜백
* **콜백 인자가 존재하는 경우, 함수가 비동기이거나 연속 전달 방식을 사용한다고 오판하기 쉽다**.
* 그러나 Array.prototype.map과 같은 예외가 존재하며, 이러한 메소드는 실제로는 결과를 동기적으로 반환한다.
```
console.log(
    [1, 5, 7].map(e => e * 2)
);
```
* map()과 같은 함수에서 콜백은 배열 내의 요소에 반복 적용하기 위해 사용될 뿐, 연산 결과를 반환하지는 않는다.
* 이렇듯 **연속 전달 방식과 비 연속 전달 방식에는 문법적 차이가 전무하므로, 콜백의 목적은 API 문서에 명확하게 작성되어야 한다**.
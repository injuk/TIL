# DesignPatterns
## 2022-05-25 Wed

## Promise와 비동기 제어 흐름 패턴
* Node.js에서 콜백은 비동기 프로그래밍의 기본적인 방식이지만, 개발자 친화적인 방법은 아니다.
* **콜백을 사용하여 다양한 제어 흐름을 구현할 수 있으나, 이러한 방식은 대부분 해결하려는 문제에 비해 복잡하고 장황**하다.
  * 제대로 구현한 경우에도 콜백을 통한 순차적인 실행 흐름은 불필요하게 복잡하고, 오류가 발생하기 쉽다.
  * **콜백을 사용하는 경우 오류의 관리는 매우 취약하며, 오류를 다음 실행으로 전달하는 것을 잊는 경우 오류에 대해 처리할 수 없게 된다**.
* Node.js와 JS 진영은 이렇듯 일반적인 문제에 대한 솔루션의 부재로 지탄받아 왔으나, 마침내 콜백 이슈에 대한 적절한 솔루션을 갖게 되었다.
  1. 프로미스: 상태를 전달하는 객체이며, 비동기 작업의 최종 결과를 나타낸다.
  2. async / await: 비동기 코드를 동기 코드처럼 보이게 하여 순차 실행 흐름을 간단하게 만들어준다.
* 현대적인 Node.js 프로그래밍에서 async와 await는 비동기 코드의 처리에 선호되는 구성이다.
  * 그러나 async와 await 문법은 프로미스가 콜백을 기반으로 하듯, 프로미스를 기반으로 한다.
  * 따라서 비동기 프로그래밍과 관련된 문제를 적절히 다루기 위해 모든 기반 지식을 이해할 필요가 있다.

### 프로미스
* **프로미스는 ECMAScript2015의 일부이며, 비동기 결과를 전파하기 위해 사용하는 CPS 콜백을 대체할 강력한 대안**이다.
  * 프로미스는 모든 주요한 비동기 흐름을 제어하는 코드를 콜백 기반 방식에 비해 더 읽기 쉽고, 강력하게 만들어준다.
* 프로미스는 비동기 작업의 최종적인 결과 또는 에러를 담는 객체이며, 다음과 같은 상태를 가질 수 있다.
  1. pending: 비동기 작업이 아직 완료되지 않은 상태이다.
  2. fulfilled: 비동기 작업이 성공적으로 종료된 상태이다.
  3. rejected: 비동기 작업이 에러와 함께 종료된 상태이다.
     * **fulfilled와 rejected는 프로미스의 결과 상태이므로, 둘 모두를 가리켜 settled 상태라고도 부를 수 있다**.
* **이행된 값 또는 거부된 에러와 같은 프로미스의 결과를 전달받기 위해 프로미스 인스턴스의 then() 함수를 사용**할 수 있다.
```
promise.then(onFulfilled, onRejected);
```
* onFulfilled는 최종적인 프로미스의 이행 값을 받기 위해 사용되는 콜백에 해당한다.
* onRejected는 거부된 프로미스의 이유를 받기 위해 사용되는 콜백에 해당한다.
  * 상술한 두 콜백은 모두 선택 사항이며, 생략할 수 있다.
* 프로미스는 전형적인 CPS 코드를 다음과 같이 바꾸어준다.
  * 아래와 같은 형식으로 함수의 최종 결과인 이행 값 또는 거부 사유를 받기 위해 반환되는 프로미스를 사용할 수 있다.
```
asyncOperation()
  .then(res => {}, err=> {});
```
* **then 함수는 또 다른 프로미스를 동기적으로 반환**한다.
* onFulfilled 또는 onRejected가 값 x를 반환하는 경우, then 함수에 의해 반환되는 프로미스는 다음과 같이 동작한다.
  1. x가 값인 경우, x의 값으로 이행한다.
  2. x가 프로미스인 경우, 프로미스 x의 이행 값으로 이행한다.
  3. x가 프로미스인 경우, 프로미스 x의 거부 사유를 최종적인 거부 사유로 하여 거부한다.
* **이러한 프로미스의 특성으로 인해 여러 환경에서 비동기 작업들을 쉽게 통합하고 배치하는 프로미스 체인을 구성**할 수 있다.
* **프로미스 체인에서 onFulfilled 또는 onRejected 핸들러를 명시하지 않은 경우, 이행 값 또는 거부 사유가 체인을 따라 다음 프로미스로 전파**된다.
  * 예를 들어, 에러는 onRejected 핸들러에 의해 catch될 때까지 프로미스 체인을 따라 전파된다.
  * 이렇듯 **프로미스 체인을 활용하는 것으로 비동기 작업들의 순차 실행을 손쉽게 구성할 수 있게 된다**.

### 프로미스 체인의 실행 흐름
* 프로미스 A > then() > 프로미스 B > then() > 프로미스 C와 같은 프로미스 체인은 다음과 같이 동작한다.
  1. 프로미스 A에 대해 호출된 then 함수는 동기적으로 결과인 프로미스 B를 반환한다.
  2. 프로미스 B에 대해 호출된 then 함수는 동기적으로 결과인 프로미스 C를 반환한다.
* 이 때, 프로미스 A가 처리될 때 이행 또는 거부된 상태가 되어 onFulfilled 또는 onRejected 콜백이 호출된다.
* 이러한 **실행 결과는 차례로 프로미스 B의 상태를 결정짓는 것으로 then 함수 호출에 전달된 onFulfilled 또는 onRejected 콜백으로 전파**된다.
* **프로미스의 주요한 특징은 프로미스가 값을 가지고 동기적으로 resolve 되더라도, 적어도 한 번은 적절한 핸들러가 비동기적으로 호출됨이 보장된다는 것**이다.
  * **프로미스 객체의 상태가 then 함수가 호출되는 순간 이미 결정되어 있더라도 onFulfilled 또는 onRejected 콜백은 비동기적으로 호출**된다.
* **onFulfilled 또는 onRejected 핸들러에서 throw 구문을 통해 예외를 발생시킬 경우, then 함수에서 반환되는 프로미스는 자동으로 거부**된다.
  * 즉, 반환되는 프로미스는 throw 문에 의해 발생된 예외를 거부 사유로 하여 자동으로 거부된다.
  * **이러한 특징은 CPS와 비교하여 예외가 프로미스 체인을 따라 자동으로 전파되며, throw 문의 사용 자체가 가능하다는 장점**이 있다.

## 2022-05-26 Thu
### Promise / A+와 thenable
* 기존에는 여러가지 서로 다른 프로미스 구현이 존재했으나, 대부분은 서로 호환되지 않았기에 프로미스 체인을 구성할 수 없었다.
* **커뮤니티는 이러한 한계를 극복하기 위해 Promise / A+ 사양을 정의했으며, 이는 then 함수의 동작을 상세히 설명하여 상호작용 가능한 기반을 제공**하였다.
  * 이를 토대로 서로 다른 라이브러리의 프로미스 객체들을 바로 사용할 수 있게 되었다.
* **Promise / A+ 사양을 채택한 결과 JS 프로미스 API를 포함한 여러 프로미스 구현들은 then 함수가 있는 모든 객체를 thenable로 간주**한다.
  * **thenable은 프로미스와 유사한 객체이며, 서로 다른 프로미스 구현들이 원활하게 연결될 수 있도록 하는 덕 타이핑의 결과**이다.

### 프로미스 API
* 프로미스는 다음과 같은 생성자 형태를 가지며, 결과로 새로운 프로미스 인스턴스를 반환한다.
```
new Promise((resolve, reject) => {}));
```
* **프로미스 인스턴스는 인자로서 주어진 resolve, reject 함수의 동작에 기반하여 이행 또는 거부 상태로 변경**될 수 있다.
  1. resolve(object): 호출 시점에 제공된 이행 값으로 프로미스를 이행 상태로 변경하는 함수이다.
     * object가 값인 경우, 값 자체가 전달된다.
     * **object가 프로미스 또는 thenable인 경우, object의 이행 값이 전달**된다.
  2. reject(error): error의 사유와 함께 프로미스를 거부 상태로 변경하는 함수이다.
     * 이 때, error는 Error 인스턴스를 나타내는 규약이다.
* 프로미스 객체는 또한 다음과 같은 정적 메소드를 갖는다.
  1. Promise.resolve(object): 다른 프로미스나 thenable, 또는 값에서 새로운 프로미스를 생성한다.
     * 프로미스가 전달되는 경우, 해당 프로미스가 있는 그대로 반환된다.
     * thenable이 전달되는 경우, 해당 라이브러리의 프로미스로 변환된다.
     * 값이 전달된 경우, 해당 값으로 프로미스가 이행된다.
  2. Promise.reject(error): error를 사유로 거부하는 새로운 프로미스를 생성한다.
  3. Promise.all(iterable): 이터러블 내의 모든 프로미스가 이행되면 이행된 결과 값들의 배열을 이행 값으로 하여 이행하는 새로운 프로미스를 생성한다.
     * **반복 가능한 객체 중 하나라도 거부되는 경우, Promise.all에 의해 반환된 프로미스 역시 첫 번째 사유로 거부**된다.
  4. Promise.allSettled(iterable): 이터러블 내의 모든 객체가 결정될 때까지 대기한 후에 각각의 이행 값 또는 거부 사유를 담는 객체의 배열을 반환한다.
     * Promise.all은 하나라도 거부되는 경우 거부되는 반면, allSettled는 모든 프로미스가 결정될 때까지 대기한다.
  5. Promise.race(iterable): 이터러블 내에서 처음으로 결정된 프로미스를 반환한다.
* 프로미스 인스턴스는 다음과 같은 함수를 사용할 수 있다.
  1. promise.then(onFulfilled, onRejected): **프로미스의 필수 함수이며, 해당 함수의 동작은 Promise / A+ 표준과 호환**된다.
  2. promise.catch(onRejected): promise.then(undefined, onRejected)에 대한 syntactic sugar이다.
  3. promise.finally(onFinally): **프로미스가 결정될 때 호출될 onFinally 콜백을 설정하는 함수**이다.
     * onFinally 콜백은 onFulfilled, onRejected 콜백과 달리 입력으로 인자를 수신하지 않으며, 반환된 값은 무시된다.
     * **finally에서 반환하는 프로미스는 현재 프로미스 인스턴스의 이행 값 또는 거부 사유로 결정**된다.

### 프로미스 만들기
* 프로미스를 처음부터 생성하는 것은 저수준의 작업이며, 콜백 기반과 같은 다른 비동기 형식을 사용하는 API를 변환하는 경우에 필요한 작업이다.
  * 대부분의 경우에 개발자는 다른 라이브러리의 then 함수를 통해 생성한 프로미스를 사용한다.
* 일부 시나리오에서는 생성자를 활용하여 수동으로 프로미스를 생성할 필요가 있으며, 다음과 같은 형식을 따를 수 있다.
```
function delay(milliseconds) {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve(new Date());
    }, milliseconds);
  });
}

console.log(`Delay... ${new Date().getSeconds()}s`);
delay(1000)
  .then(date => console.log(`Done... ${date.getSeconds()}s`));
```
* Promise / A+ 명세에서, then 함수의 onFulfilled와 onRejected 콜백은 단 한 번만 배타적으로 호출된다.
  * 때문에 **해당 명세에 따르는 프로미스의 경우, resolve 또는 reject를 수 회 호출하더라도 결과적으로 한 번만 이행되거나 거부**된다.
* 콜백 기반 함수의 다음과 같은 특징을 알고 있는 경우, 콜백 기반 함수를 프로미스로 변환하는 프로미스화 함수를 작성할 수 있다.
  1. 콜백은 함수의 마지막 인자이다.
  2. 에러가 있는 경우, 콜백의 첫 번째 인자로 전달된다.
  3. 모든 반환 값은 콜백 함수의 에러 인자 다음에 전달된다.
* 이러한 규칙에 의거한 Node.js 방식의 콜백 기반 함수를 프로미스화하는 함수는 다음과 같다.
```
function promisify(cb) {
  return function promisified(...args) {
    return new Promise((resolve, reject) => {
      const newArgs = [
        ...args,
        (err, result) => {
          if(err) 
            return reject(err);
          resolve(result);
        }
      ];
      cb(...newArgs);
    });
  }
}
```
* **promisify 함수는 또 다른 함수인 promisified를 반환하며, 반환되는 함수는 promisify에 인자로 전달된 cb의 프로미스 버전**이다.
* 이를 활용하여 Node.js의 기반 함수인 readFile을 프로미스화하는 예시는 다음과 같다.
```
import { readFile } from 'fs';

promisify(readFile)('./package.json', 'utf8')
  .then(content => console.log(content));
```
* 상술한 코드는 예시에 불과하며, **실무에서는 Node.js의 콜백 기반 함수를 프로미스화하기 위해 코어 모듈인 util의 promisify() 함수를 사용**한다.
```
import { readFile } from 'fs';
import { promisify } from 'util';

promisify(readFile)('./package.json', 'utf8')
.then(content => console.log(content));
```

## 2022-05-27 Fri
### 프로미스의 에러 처리
* 기존의 콜백 방식은 사용자가 오류를 전파하기 위한 로직을 직접 작성할 필요가 있다.
* 반면 프로미스를 활용하는 경우, catch 핸들러를 활용하는 것으로 전체 프로미스 체인에서 발생하는 모든 에러를 잡아낼 수 있다.
  * **이는 보일러 플레이트 코드를 반드시 작성해야하는 번거로움과 비동기 오류를 놓칠 가능성을 크게 줄여주므로, 엄청난 이점에 해당**한다.

### 프로미스와 병렬 실행
* 프로미스 API의 내장 함수인 Promise.all을 사용하면 병렬 실행 흐름을 간단하게 구현할 수 있다.
  * 해당 함수는 입력으로 받은 모든 프로미스들이 이행됐을 때에만 이행하는 새로운 프로미스를 생성한다.
* **순차 반복 방식과 비교했을 경우, Promise.all은 새로운 작업을 시작하기 전에 이전 작업을 기다리지 않는다는 차이점이 존재**한다.
  * **모든 비동기 작업은 이벤트 루프의 동일한 주기에서 한 번에 반복적으로 시작**된다.
  * 모든 프로미스를 확보한 후, Promise.all 함수에 이를 전달하면 배열 요소 전체의 이행 여부에 따라 이행되는 새로운 프로미스가 반환된다.
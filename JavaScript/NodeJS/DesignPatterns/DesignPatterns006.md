# DesignPatterns
## 2022-05-25 Wed

## Promise와 비동기 제어 흐름 패턴
* Node.js에서 콜백은 비동기 프로그래밍의 기본적인 방식이지만, 개발자 친화적인 방법은 아니다.
* **콜백을 사용하여 다양한 제어 흐름을 구현할 수 있으나, 이러한 방식은 대부분 해결하려는 문제에 비해 복잡하고 장황**하다.
  * 제대로 구현한 경우에도 콜백을 통한 순차적인 실행 흐름은 불필요하게 복잡하고, 오류가 발생하기 쉽다.
  * **콜백을 사용하는 경우 오류의 관리는 매우 취약하며, 오류를 다음 실행으로 전달하는 것을 잊는 경우 오류에 대해 처리할 수 없게 된다**.
* Node.js와 JS 진영은 이렇듯 일반적인 문제에 대한 솔루션의 부재로 지탄받아 왔으나, 마침내 콜백 이슈에 대한 적절한 솔루션을 갖게 되었다.
  1. 프로미스: 상태를 전달하는 객체이며, 비동기 작업의 최종 결과를 나타낸다.
  2. async / await: 비동기 코드를 동기 코드처럼 보이게 하여 순차 실행 흐름을 간단하게 만들어준다.
* 현대적인 Node.js 프로그래밍에서 async와 await는 비동기 코드의 처리에 선호되는 구성이다.
  * 그러나 async와 await 문법은 프로미스가 콜백을 기반으로 하듯, 프로미스를 기반으로 한다.
  * 따라서 비동기 프로그래밍과 관련된 문제를 적절히 다루기 위해 모든 기반 지식을 이해할 필요가 있다.

### 프로미스
* **프로미스는 ECMAScript2015의 일부이며, 비동기 결과를 전파하기 위해 사용하는 CPS 콜백을 대체할 강력한 대안**이다.
  * 프로미스는 모든 주요한 비동기 흐름을 제어하는 코드를 콜백 기반 방식에 비해 더 읽기 쉽고, 강력하게 만들어준다.
* 프로미스는 비동기 작업의 최종적인 결과 또는 에러를 담는 객체이며, 다음과 같은 상태를 가질 수 있다.
  1. pending: 비동기 작업이 아직 완료되지 않은 상태이다.
  2. fulfilled: 비동기 작업이 성공적으로 종료된 상태이다.
  3. rejected: 비동기 작업이 에러와 함께 종료된 상태이다.
     * **fulfilled와 rejected는 프로미스의 결과 상태이므로, 둘 모두를 가리켜 settled 상태라고도 부를 수 있다**.
* **이행된 값 또는 거부된 에러와 같은 프로미스의 결과를 전달받기 위해 프로미스 인스턴스의 then() 함수를 사용**할 수 있다.
```
promise.then(onFulfilled, onRejected);
```
* onFulfilled는 최종적인 프로미스의 이행 값을 받기 위해 사용되는 콜백에 해당한다.
* onRejected는 거부된 프로미스의 이유를 받기 위해 사용되는 콜백에 해당한다.
  * 상술한 두 콜백은 모두 선택 사항이며, 생략할 수 있다.
* 프로미스는 전형적인 CPS 코드를 다음과 같이 바꾸어준다.
  * 아래와 같은 형식으로 함수의 최종 결과인 이행 값 또는 거부 사유를 받기 위해 반환되는 프로미스를 사용할 수 있다.
```
asyncOperation()
  .then(res => {}, err=> {});
```
* **then 함수는 또 다른 프로미스를 동기적으로 반환**한다.
* onFulfilled 또는 onRejected가 값 x를 반환하는 경우, then 함수에 의해 반환되는 프로미스는 다음과 같이 동작한다.
  1. x가 값인 경우, x의 값으로 이행한다.
  2. x가 프로미스인 경우, 프로미스 x의 이행 값으로 이행한다.
  3. x가 프로미스인 경우, 프로미스 x의 거부 사유를 최종적인 거부 사유로 하여 거부한다.
* **이러한 프로미스의 특성으로 인해 여러 환경에서 비동기 작업들을 쉽게 통합하고 배치하는 프로미스 체인을 구성**할 수 있다.
* **프로미스 체인에서 onFulfilled 또는 onRejected 핸들러를 명시하지 않은 경우, 이행 값 또는 거부 사유가 체인을 따라 다음 프로미스로 전파**된다.
  * 예를 들어, 에러는 onRejected 핸들러에 의해 catch될 때까지 프로미스 체인을 따라 전파된다.
  * 이렇듯 **프로미스 체인을 활용하는 것으로 비동기 작업들의 순차 실행을 손쉽게 구성할 수 있게 된다**.

### 프로미스 체인의 실행 흐름
* 프로미스 A > then() > 프로미스 B > then() > 프로미스 C와 같은 프로미스 체인은 다음과 같이 동작한다.
  1. 프로미스 A에 대해 호출된 then 함수는 동기적으로 결과인 프로미스 B를 반환한다.
  2. 프로미스 B에 대해 호출된 then 함수는 동기적으로 결과인 프로미스 C를 반환한다.
* 이 때, 프로미스 A가 처리될 때 이행 또는 거부된 상태가 되어 onFulfilled 또는 onRejected 콜백이 호출된다.
* 이러한 **실행 결과는 차례로 프로미스 B의 상태를 결정짓는 것으로 then 함수 호출에 전달된 onFulfilled 또는 onRejected 콜백으로 전파**된다.
* **프로미스의 주요한 특징은 프로미스가 값을 가지고 동기적으로 resolve 되더라도, 적어도 한 번은 적절한 핸들러가 비동기적으로 호출됨이 보장된다는 것**이다.
  * **프로미스 객체의 상태가 then 함수가 호출되는 순간 이미 결정되어 있더라도 onFulfilled 또는 onRejected 콜백은 비동기적으로 호출**된다.
* **onFulfilled 또는 onRejected 핸들러에서 throw 구문을 통해 예외를 발생시킬 경우, then 함수에서 반환되는 프로미스는 자동으로 거부**된다.
  * 즉, 반환되는 프로미스는 throw 문에 의해 발생된 예외를 거부 사유로 하여 자동으로 거부된다.
  * **이러한 특징은 CPS와 비교하여 예외가 프로미스 체인을 따라 자동으로 전파되며, throw 문의 사용 자체가 가능하다는 장점**이 있다.

## 2022-05-26 Thu
### Promise / A+와 thenable
* 기존에는 여러가지 서로 다른 프로미스 구현이 존재했으나, 대부분은 서로 호환되지 않았기에 프로미스 체인을 구성할 수 없었다.
* **커뮤니티는 이러한 한계를 극복하기 위해 Promise / A+ 사양을 정의했으며, 이는 then 함수의 동작을 상세히 설명하여 상호작용 가능한 기반을 제공**하였다.
  * 이를 토대로 서로 다른 라이브러리의 프로미스 객체들을 바로 사용할 수 있게 되었다.
* **Promise / A+ 사양을 채택한 결과 JS 프로미스 API를 포함한 여러 프로미스 구현들은 then 함수가 있는 모든 객체를 thenable로 간주**한다.
  * **thenable은 프로미스와 유사한 객체이며, 서로 다른 프로미스 구현들이 원활하게 연결될 수 있도록 하는 덕 타이핑의 결과**이다.

### 프로미스 API
* 프로미스는 다음과 같은 생성자 형태를 가지며, 결과로 새로운 프로미스 인스턴스를 반환한다.
```
new Promise((resolve, reject) => {}));
```
* **프로미스 인스턴스는 인자로서 주어진 resolve, reject 함수의 동작에 기반하여 이행 또는 거부 상태로 변경**될 수 있다.
  1. resolve(object): 호출 시점에 제공된 이행 값으로 프로미스를 이행 상태로 변경하는 함수이다.
     * object가 값인 경우, 값 자체가 전달된다.
     * **object가 프로미스 또는 thenable인 경우, object의 이행 값이 전달**된다.
  2. reject(error): error의 사유와 함께 프로미스를 거부 상태로 변경하는 함수이다.
     * 이 때, error는 Error 인스턴스를 나타내는 규약이다.
* 프로미스 객체는 또한 다음과 같은 정적 메소드를 갖는다.
  1. Promise.resolve(object): 다른 프로미스나 thenable, 또는 값에서 새로운 프로미스를 생성한다.
     * 프로미스가 전달되는 경우, 해당 프로미스가 있는 그대로 반환된다.
     * thenable이 전달되는 경우, 해당 라이브러리의 프로미스로 변환된다.
     * 값이 전달된 경우, 해당 값으로 프로미스가 이행된다.
  2. Promise.reject(error): error를 사유로 거부하는 새로운 프로미스를 생성한다.
  3. Promise.all(iterable): 이터러블 내의 모든 프로미스가 이행되면 이행된 결과 값들의 배열을 이행 값으로 하여 이행하는 새로운 프로미스를 생성한다.
     * **반복 가능한 객체 중 하나라도 거부되는 경우, Promise.all에 의해 반환된 프로미스 역시 첫 번째 사유로 거부**된다.
  4. Promise.allSettled(iterable): 이터러블 내의 모든 객체가 결정될 때까지 대기한 후에 각각의 이행 값 또는 거부 사유를 담는 객체의 배열을 반환한다.
     * Promise.all은 하나라도 거부되는 경우 거부되는 반면, allSettled는 모든 프로미스가 결정될 때까지 대기한다.
  5. Promise.race(iterable): 이터러블 내에서 처음으로 결정된 프로미스를 반환한다.
* 프로미스 인스턴스는 다음과 같은 함수를 사용할 수 있다.
  1. promise.then(onFulfilled, onRejected): **프로미스의 필수 함수이며, 해당 함수의 동작은 Promise / A+ 표준과 호환**된다.
  2. promise.catch(onRejected): promise.then(undefined, onRejected)에 대한 syntactic sugar이다.
  3. promise.finally(onFinally): **프로미스가 결정될 때 호출될 onFinally 콜백을 설정하는 함수**이다.
     * onFinally 콜백은 onFulfilled, onRejected 콜백과 달리 입력으로 인자를 수신하지 않으며, 반환된 값은 무시된다.
     * **finally에서 반환하는 프로미스는 현재 프로미스 인스턴스의 이행 값 또는 거부 사유로 결정**된다.
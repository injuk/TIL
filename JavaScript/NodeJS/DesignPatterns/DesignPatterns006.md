# DesignPatterns
## 2022-05-25 Wed

## Promise와 비동기 제어 흐름 패턴
* Node.js에서 콜백은 비동기 프로그래밍의 기본적인 방식이지만, 개발자 친화적인 방법은 아니다.
* **콜백을 사용하여 다양한 제어 흐름을 구현할 수 있으나, 이러한 방식은 대부분 해결하려는 문제에 비해 복잡하고 장황**하다.
  * 제대로 구현한 경우에도 콜백을 통한 순차적인 실행 흐름은 불필요하게 복잡하고, 오류가 발생하기 쉽다.
  * **콜백을 사용하는 경우 오류의 관리는 매우 취약하며, 오류를 다음 실행으로 전달하는 것을 잊는 경우 오류에 대해 처리할 수 없게 된다**.
* Node.js와 JS 진영은 이렇듯 일반적인 문제에 대한 솔루션의 부재로 지탄받아 왔으나, 마침내 콜백 이슈에 대한 적절한 솔루션을 갖게 되었다.
  1. 프로미스: 상태를 전달하는 객체이며, 비동기 작업의 최종 결과를 나타낸다.
  2. async / await: 비동기 코드를 동기 코드처럼 보이게 하여 순차 실행 흐름을 간단하게 만들어준다.
* 현대적인 Node.js 프로그래밍에서 async와 await는 비동기 코드의 처리에 선호되는 구성이다.
  * 그러나 async와 await 문법은 프로미스가 콜백을 기반으로 하듯, 프로미스를 기반으로 한다.
  * 따라서 비동기 프로그래밍과 관련된 문제를 적절히 다루기 위해 모든 기반 지식을 이해할 필요가 있다.

### 프로미스
* **프로미스는 ECMAScript2015의 일부이며, 비동기 결과를 전파하기 위해 사용하는 CPS 콜백을 대체할 강력한 대안**이다.
  * 프로미스는 모든 주요한 비동기 흐름을 제어하는 코드를 콜백 기반 방식에 비해 더 읽기 쉽고, 강력하게 만들어준다.
* 프로미스는 비동기 작업의 최종적인 결과 또는 에러를 담는 객체이며, 다음과 같은 상태를 가질 수 있다.
  1. pending: 비동기 작업이 아직 완료되지 않은 상태이다.
  2. fulfilled: 비동기 작업이 성공적으로 종료된 상태이다.
  3. rejected: 비동기 작업이 에러와 함께 종료된 상태이다.
     * **fulfilled와 rejected는 프로미스의 결과 상태이므로, 둘 모두를 가리켜 settled 상태라고도 부를 수 있다**.
* **이행된 값 또는 거부된 에러와 같은 프로미스의 결과를 전달받기 위해 프로미스 인스턴스의 then() 함수를 사용**할 수 있다.
```
promise.then(onFulfilled, onRejected);
```
* onFulfilled는 최종적인 프로미스의 이행 값을 받기 위해 사용되는 콜백에 해당한다.
* onRejected는 거부된 프로미스의 이유를 받기 위해 사용되는 콜백에 해당한다.
  * 상술한 두 콜백은 모두 선택 사항이며, 생략할 수 있다.
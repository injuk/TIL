# DesignPatterns
## 2022-05-22 Sun

## 콜백과 비동기 제어 흐름
* 동기식 프로그래밍을 사용하는 플랫폼에서 Node.js와 같이 CPS와 비동기 API를 주로 사용하는 플랫폼으로의 적응은 쉽지 않을 수 있다.
  * 비동기 코드는 구문이 실행되는 순서를 예측하기 어렵게 만들거나, 간단한 문제를 해결하는 코드도 가독성이 떨어지기 쉽다.
* 비동기 제어 흐름을 다루는 과정에서 콜백을 사용하는 경우, 가장 흔히 하는 실수는 크게 다음과 같다.
  1. 콜백 지옥에 빠지는 경우
  2. 코드가 간단한 루틴에서도 가독성을 잃게 되는 경우
  3. 유지보수가 어려워지며 수직적보다는 수평적으로 커지는 경우

### 비동기 프로그래밍의 어려움
* JS에서는 비동기 코드에 대한 제어를 놓치는 일이 빈번하게 발생한다.
* 클로저와 익명 함수의 in place 정의는 개발자가 코드의 이곳 저곳을 옮겨다니지 않고서도 원활한 프로그래밍을 가능하도록 돕는다.
* **모듈화나 재사용성, 유지보수성을 희생하는 것은 콜백의 중첩을 통제할 수 없이 급증시키고 함수의 크기와 구성을 엉망으로 만든다**.
  * 대부분의 경우 in place 콜백을 만드는 것이 절대적으로 중요한 것은 아니다.
  * 오히려, 비동기 프로그래밍과 관련된 문제보다는 규칙과 관련된 문제가 더 중요하다.

### 콜백 지옥
* 다음과 같이 구현한 알고리즘 자체가 간단하더라도, 코드에 여러 수준의 들여쓰기가 존재하는 경우 가독성은 매우 낮아질 수 있다.
```
export function spider(url, cb) {
  const filename = urlToFilename(url);
  fs.access(filename, err => {
    if(err && err.code === 'ENOENT') {
      console.log(`Downloading ${url} into ${filename}`);
      superagent.get(url).end((err, res) => {
        if(err) {
          cb(err);
        } else {
          mkdirp(path.dirname(filename), err => {
            if(err) {
              cb(err);
            } else {
              fs.writeFile(filename, res.text, err => {
                if(err) {
                  cb(err);
                } else {
                  cb(null, filename, true);
                }
              });
            }
          });
        }
      });
    } else {
      cb(null, filename, false);
    }
  });
}
```
* 이렇듯 비동기식 CPS에서 in place 콜백 정의를 잘못 사용하는 것은 코드의 가독성을 크게 떨어트리며, 관리할 수 없는 덩어리로 만든다.
  * 이는 **정확히 콜백 지옥에 해당하며, Node.js와 JS에서 잘 알려진 안티 패턴 중 하나**이다.
  * 또는 작성된 코드가 중첩이 깊어져 피라미드 같은 모양을 취하므로, 죽음의 피라미드라고도 부른다.
* **콜백 지옥에서 분명하게 드러나는 문제점은 가독성이며, 중첩이 너무 깊어지므로 함수가 어디에서 끝나고 어디에서 시작하는지 추적하는 것이 거의 불가능**해진다.
* **콜백 지옥의 또 다른 문제는 각 스코프에서 사용되는 변수의 이름이 중복된다는 것과, 클로저가 성능 및 메모리 측면에서 부정적인 영향을 준다는 사실**이다.
  * 특히 **활성화된 클로저에 의해 참조되는 컨텍스트는 GC의 대상이 되지 않으므로, 콜백 지옥은 식별하기가 매우 어려운 메모리 누수를 만들어내기 쉽다**.

## 2022-05-23 Mon
### 콜백 모범 사례 및 제어 흐름 패턴
* 일련의 비동기적인 작업들의 흐름을 제어하기 위해 특정한 패턴과 기법을 사용해야만 하는 상황이 발생할 수 있다.
  * 이는 특히 외부 라이브러리 없이 일반 JS만 사용하는 경우에 더욱 두드러진다.

### 콜백 규칙
* **비동기 코드를 작성하는 경우, 우선적으로 명심할 것은 콜백을 정의하기 위해 in place 함수를 남용하지 않아야 한다**는 것이다.
  * 대부분의 경우 콜백 지옥을 해결하기 위해서 어떠한 라이브러리나 패러다임의 변화가 필요한 것은 아니며, 어디까지나 간단하고 일반적인 상식으로도 충분하다.
* 중첩 수준을 낮게 유지하고, 코드 체계를 개선하기 위해 다음과 같은 원칙을 따를 수 있다.
  1. 가능한 한 빨리 종료하기.
     * 문맥에 따라 return, continue, break 등을 사용하여 if - else를 여럿 중첩하는 대신 빠르게 종료할 수 있다.
     * 이를 통해 코드를 얕은 수준으로 유지할 수 있게 된다.
  2. 콜백을 위해 명명된 함수를 생성하고 클로저 바깥에 배치하기.
     * 이름을 지정한 함수를 사용하여 중간 결과를 인자로 전달할 경우, 스택 트레이스에서도 더 잘 확인할 수 있게 된다.
  3. 코드를 모듈화하기.
     * 가능한 만큼 작고 재사용 가능한 함수들로 분할한다.

### 콜백 규칙의 적용
* 콜백 지옥을 해결하기 위해, 가장 먼저 else 문을 제거하여 오류 검사 패턴을 재구성하도록 한다.
```
if(err)
  cb(err);
else
  // 에러가 없는 경우에 대한 코드
  
// 아래와 같이 수정한다
if(err)
  return cb(err);
// 에러가 없는 경우에 대한 코드
```
* 이를 통해 **오류를 수신한 즉시 함수로부터 복귀가 가능하며, 이는 종종 빠른 반환 원칙으로 일컬어진다**.
  * 이렇듯 아주 쉬운 방식을 통해 함수의 중첩을 즉시 줄여나갈 수 있다.
* 이 때, **콜백이 호출된 후에 함수를 종료하는 것을 반드시 잊지 않아야 한다**.
```
if(err)
  cb(err);

// 아래와 같이 수정한다
if(err)
  return cb(err);
```
* **콜백의 실행 후에도 함수는 계속해서 실행되므로, 나머지 함수의 실행을 차단할 수 있도록 return 구문을 반드시 명시적으로 작성**하도록 한다.
  * 이 때, **실제 결과 또는 오류는 비동기적으로 생성되어 콜백에 전달될 것이므로 함수가 반환하는 값은 대개 중요하지 않다**. 
  * 즉, 콜백으로 전달되지 않은 비동기 함수 자체의 반환값은 대부분의 경우에 무시된다. 
* 이후로는 재사용 가능한 코드를 적절히 명명한 메소드로 추출하여 분리한다.
* 이렇듯 **빠른 반환 원칙을 적용할 수 있도록 코드의 순서를 바꾸고, 메소드를 추출 리팩토링을 적용하는 것만으로도 코드의 중첩을 크게 줄일 수 있다**.
  * 나아가 메소드를 분리하는 과정에서 만들어진 메소드들을 익스포트하는 것으로 다른 모듈에서 재사용을 유도할 수 있다.
  * 또한, 이는 **각각의 기능에 대한 독립적인 테스트를 가능케하므로 테스트 가능성도 높여주는 이점을 제공**한다.
```
> 클로저와 익명 함수를 남용하지 않는 것만으로도 콜백 지옥에서 빠져나올 수 있다.
```

### 순차실행
* 일련의 작업을 순차적으로 실행하는 것은 각 작업을 한 번에 하나씩만 실행하는 것이다.
  * **대부분의 경우 임의의 작업의 결과는 다음 작업의 실행에 영향을 줄 수 있으므로 실행 순서는 중요하며, 이를 보존할 수 있어야 한다**. 
* 일련의 작업에 대한 순차 실행 흐름은 다시 다음과 같은 변형으로 분류할 수 있다.
  1. 데이터의 전달 없이 일련의 작업이 순서대로 실행만 되는 경우.
  2. 작업의 결과를 다음 작업의 입력으로 사용하는 경우.
  3. 순차적으로 각 요소에 대해 비동기 작업을 적용하는 경우.
* **순차 실행은 직접 방식의 블로킹 API를 사용하여 구현하는 경우에는 일반적으로 간단하지만, 비동기 CPS를 사용하는 경우 콜백 지옥의 주요 원인**이 된다.

### 일련의 작업을 순차적으로 실행하기
* 다음의 패턴은 일련의 작업을 순차적인 실행 흐름에서 사용하는 일반화된 방식이다.
```
function task1(cb) {
  setTimeout(() => {
    console.log(`task 1 done`);
    task2(cb);
  }, 1000);
}

function task2(cb) {
  setTimeout(() => {
    console.log(`task 2 done`);
    task3(cb);
  }, 1000);
}

function task3(cb) {
  setTimeout(() => {
    console.log(`task 3 done`);
    cb(); // 모든 작업의 결과로 콜백을 실행한다.
  }, 1000);
}

task1(() => {
  console.log(`task 1, 2, 3 done!!!`);
});

/* 실행 결과
task 1 done
task 2 done
task 3 done
task 1, 2, 3 done!!!
*/ 
```
* 상술한 코드는 일반적인 비동기 작업 완료시 각각의 작업이 다음 작업을 호출하는 방법을 명시적으로 드러낸다.
* 또한, **이러한 패턴은 작업의 모듈화에 중점을 두었으므로 비동기 코드를 처리하기 위해 반드시 클로저를 사용할 필요가 없다는 사실을 보여준다**.

### 순차 반복
* 상술한 방식은 실행될 작업의 수와 양을 사전에 완벽히 알 수 있을 경우에 잘 동작한다.
* 반면 컬렉션의 각 항목에 대해 비동기 작업을 적용하고자 하는 경우, 작업 순서를 하드코딩하는 대신 동적으로 구축해야 한다.
* 컬렉션의 각 요소 또는 일반적인 작업 목록에 대해 비동기 작업을 순차적으로 반복해야 하는 경우, 다음과 같은 일반화된 패턴을 고려할 수 있다.
```
function iterate(index) {
  if(index === tasks.length)
    return finish();
  }
  const task = tasks[index];
  task( () => iterate(index + 1) );
}
function finish() {
  // 반복 완료
}
iterate(0);
```
* task()가 동기적인 작업인 경우, 이러한 유형의 알고리즘은 완전히 재귀적이 된다.
  * 따라서 스택은 매 사이클마다 해제되지 않으므로, 최대 콜 스택 크기의 제한을 초과하기 쉽다.
* 상술한 패턴을 통해 다음과 같은 상황을 해결할 수 있다.
  1. 배열의 값 각각에 대한 비동기적 매핑
  2. 반복문에서 연산의 결과를 다음으로 전달하는 reduce 알고리즘의 구현
  3. 특정 조건이 충족된 경우의 루프 조기 중단
  4. 무한한 요소에 대한 반복 적용
* iterator와 같은 순차 반복 패턴은 컬렉션에서 다음 사용 가능한 작업을 호출하고, 현재 작업이 완료된 시점에 반복의 다음 단계를 호출하도록 동작한다.

### 병렬 실행
* 일련의 비동기 작업들의 실행 순서가 중요하지 않고, 단지 작업이 종료된 경우의 알림만 받으면 적절한 경우가 발생할 수 있다.
  * 이러한 상황에는 병렬 실행 흐름을 적용하여 효과적으로 대응할 수 있다.
* Node.js는 단일 스레드로 동작하지만, Node.js의 논 블로킹 성질 덕분에 단 하나의 스레드만으로도 동시성을 달성할 수 있다.
  * 이러한 경우에는 병렬이라는 용어를 사용하는 것은 적절하지 못한 것이 맞다.
  * **작업이 새로운 비동기 작업을 요청할 때, 이벤트 루프가 새로운 작업을 실행할 수 있도록 제어는 이벤트 루프에 넘겨지게 된다**.
  * **이러한 작업 흐름에는 동시성이라는 표현이 어울리지만, 이를 단순하게 이해하기 위해 병렬이라는 용어를 사용**할 수 있다.
* Node.js 프로그램에서 두 개의 비동기 작업을 병렬로 실행하는 과정은 다음과 같다.
  1. Main 함수는 비동기 작업인 작업 1과 작업 2를 실행한다.
  2. 비동기 작업이 시작되면 제어권은 작업 1, 2 각각에서 Main 함수로 즉시 반환된다.
  3. 2.의 과정에서 **Main 함수가 반환 받은 제어권은 즉시 이벤트 루프로 반환**된다.
  4. 작업 1의 비동기 작업이 완료된 경우, 이벤트 루프는 제어를 작업 1에 반환한다.
  5. **작업 1이 남은 작업을 마무리한 경우, 작업 1은 이 결과를 Main 함수에 통지**한다.
     * 이 과정에서 작업 1의 자체적인 내부 작업 수행은 동기적이다.
  6. **작업 2에 의해 시작된 비동기 작업이 완료된 경우, 이벤트 루프는 대응되는 콜백을 호출하며 제어권을 작업 2에게 반환**한다.
  7. 작업 2가 남은 작업을 마무리한 경우, 작업 2는 이 결과를 Main 함수에 통지한다.
  8. **이 시점에서 Main 함수는 모든 작업이 완료되었음을 인지하며, 자신의 실행을 계속하거나 작업 결과를 다른 콜백으로 반환**할 수 있다.
* 이렇듯 **Node.js에서는 논 블로킹 API에 의해 내부적으로 동시 처리가 가능하므로, 병렬 비동기 작업의 효과**를 누릴 수 있다.
* 반면, **Node.js의 동기 작업은 실행을 비동기 작업에 끼워 넣거나, setTimeout / setImmediate 등으로 지연시키지 않으면 동시에 실행할 수 없다**.
  * 동기 방식의 작업은 블로킹 API라고도 지칭할 수 있다.
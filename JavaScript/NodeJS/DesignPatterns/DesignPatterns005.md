# DesignPatterns
## 2022-05-22 Sun

## 콜백과 비동기 제어 흐름
* 동기식 프로그래밍을 사용하는 플랫폼에서 Node.js와 같이 CPS와 비동기 API를 주로 사용하는 플랫폼으로의 적응은 쉽지 않을 수 있다.
  * 비동기 코드는 구문이 실행되는 순서를 예측하기 어렵게 만들거나, 간단한 문제를 해결하는 코드도 가독성이 떨어지기 쉽다.
* 비동기 제어 흐름을 다루는 과정에서 콜백을 사용하는 경우, 가장 흔히 하는 실수는 크게 다음과 같다.
  1. 콜백 지옥에 빠지는 경우
  2. 코드가 간단한 루틴에서도 가독성을 잃게 되는 경우
  3. 유지보수가 어려워지며 수직적보다는 수평적으로 커지는 경우

### 비동기 프로그래밍의 어려움
* JS에서는 비동기 코드에 대한 제어를 놓치는 일이 빈번하게 발생한다.
* 클로저와 익명 함수의 in place 정의는 개발자가 코드의 이곳 저곳을 옮겨다니지 않고서도 원활한 프로그래밍을 가능하도록 돕는다.
* **모듈화나 재사용성, 유지보수성을 희생하는 것은 콜백의 중첩을 통제할 수 없이 급증시키고 함수의 크기와 구성을 엉망으로 만든다**.
  * 대부분의 경우 in place 콜백을 만드는 것이 절대적으로 중요한 것은 아니다.
  * 오히려, 비동기 프로그래밍과 관련된 문제보다는 규칙과 관련된 문제가 더 중요하다.

### 콜백 지옥
* 다음과 같이 구현한 알고리즘 자체가 간단하더라도, 코드에 여러 수준의 들여쓰기가 존재하는 경우 가독성은 매우 낮아질 수 있다.
```
export function spider(url, cb) {
  const filename = urlToFilename(url);
  fs.access(filename, err => {
    if(err && err.code === 'ENOENT') {
      console.log(`Downloading ${url} into ${filename}`);
      superagent.get(url).end((err, res) => {
        if(err) {
          cb(err);
        } else {
          mkdirp(path.dirname(filename), err => {
            if(err) {
              cb(err);
            } else {
              fs.writeFile(filename, res.text, err => {
                if(err) {
                  cb(err);
                } else {
                  cb(null, filename, true);
                }
              });
            }
          });
        }
      });
    } else {
      cb(null, filename, false);
    }
  });
}
```
* 이렇듯 비동기식 CPS에서 in place 콜백 정의를 잘못 사용하는 것은 코드의 가독성을 크게 떨어트리며, 관리할 수 없는 덩어리로 만든다.
  * 이는 **정확히 콜백 지옥에 해당하며, Node.js와 JS에서 잘 알려진 안티 패턴 중 하나**이다.
  * 또는 작성된 코드가 중첩이 깊어져 피라미드 같은 모양을 취하므로, 죽음의 피라미드라고도 부른다.
* **콜백 지옥에서 분명하게 드러나는 문제점은 가독성이며, 중첩이 너무 깊어지므로 함수가 어디에서 끝나고 어디에서 시작하는지 추적하는 것이 거의 불가능**해진다.
* **콜백 지옥의 또 다른 문제는 각 스코프에서 사용되는 변수의 이름이 중복된다는 것과, 클로저가 성능 및 메모리 측면에서 부정적인 영향을 준다는 사실**이다.
  * 특히 **활성화된 클로저에 의해 참조되는 컨텍스트는 GC의 대상이 되지 않으므로, 콜백 지옥은 식별하기가 매우 어려운 메모리 누수를 만들어내기 쉽다**.

## 2022-05-23 Mon
### 콜백 모범 사례 및 제어 흐름 패턴
* 일련의 비동기적인 작업들의 흐름을 제어하기 위해 특정한 패턴과 기법을 사용해야만 하는 상황이 발생할 수 있다.
  * 이는 특히 외부 라이브러리 없이 일반 JS만 사용하는 경우에 더욱 두드러진다.

### 콜백 규칙
* **비동기 코드를 작성하는 경우, 우선적으로 명심할 것은 콜백을 정의하기 위해 in place 함수를 남용하지 않아야 한다**는 것이다.
  * 대부분의 경우 콜백 지옥을 해결하기 위해서 어떠한 라이브러리나 패러다임의 변화가 필요한 것은 아니며, 어디까지나 간단하고 일반적인 상식으로도 충분하다.
* 중첩 수준을 낮게 유지하고, 코드 체계를 개선하기 위해 다음과 같은 원칙을 따를 수 있다.
  1. 가능한 한 빨리 종료하기.
     * 문맥에 따라 return, continue, break 등을 사용하여 if - else를 여럿 중첩하는 대신 빠르게 종료할 수 있다.
     * 이를 통해 코드를 얕은 수준으로 유지할 수 있게 된다.
  2. 콜백을 위해 명명된 함수를 생성하고 클로저 바깥에 배치하기.
     * 이름을 지정한 함수를 사용하여 중간 결과를 인자로 전달할 경우, 스택 트레이스에서도 더 잘 확인할 수 있게 된다.
  3. 코드를 모듈화하기.
     * 가능한 만큼 작고 재사용 가능한 함수들로 분할한다.

### 콜백 규칙의 적용
* 콜백 지옥을 해결하기 위해, 가장 먼저 else 문을 제거하여 오류 검사 패턴을 재구성하도록 한다.
```
if(err)
  cb(err);
else
  // 에러가 없는 경우에 대한 코드
  
// 아래와 같이 수정한다
if(err)
  return cb(err);
// 에러가 없는 경우에 대한 코드
```
* 이를 통해 **오류를 수신한 즉시 함수로부터 복귀가 가능하며, 이는 종종 빠른 반환 원칙으로 일컬어진다**.
  * 이렇듯 아주 쉬운 방식을 통해 함수의 중첩을 즉시 줄여나갈 수 있다.
* 이 때, **콜백이 호출된 후에 함수를 종료하는 것을 반드시 잊지 않아야 한다**.
```
if(err)
  cb(err);

// 아래와 같이 수정한다
if(err)
  return cb(err);
```
* **콜백의 실행 후에도 함수는 계속해서 실행되므로, 나머지 함수의 실행을 차단할 수 있도록 return 구문을 반드시 명시적으로 작성**하도록 한다.
  * 이 때, **실제 결과 또는 오류는 비동기적으로 생성되어 콜백에 전달될 것이므로 함수가 반환하는 값은 대개 중요하지 않다**. 
  * 즉, 콜백으로 전달되지 않은 비동기 함수 자체의 반환값은 대부분의 경우에 무시된다. 
* 이후로는 재사용 가능한 코드를 적절히 명명한 메소드로 추출하여 분리한다.
* 이렇듯 **빠른 반환 원칙을 적용할 수 있도록 코드의 순서를 바꾸고, 메소드를 추출 리팩토링을 적용하는 것만으로도 코드의 중첩을 크게 줄일 수 있다**.
  * 나아가 메소드를 분리하는 과정에서 만들어진 메소드들을 익스포트하는 것으로 다른 모듈에서 재사용을 유도할 수 있다.
  * 또한, 이는 **각각의 기능에 대한 독립적인 테스트를 가능케하므로 테스트 가능성도 높여주는 이점을 제공**한다.
```
> 클로저와 익명 함수를 남용하지 않는 것만으로도 콜백 지옥에서 빠져나올 수 있다.
```

### 순차실행
* 일련의 작업을 순차적으로 실행하는 것은 각 작업을 한 번에 하나씩만 실행하는 것이다.
  * **대부분의 경우 임의의 작업의 결과는 다음 작업의 실행에 영향을 줄 수 있으므로 실행 순서는 중요하며, 이를 보존할 수 있어야 한다**. 
* 일련의 작업에 대한 순차 실행 흐름은 다시 다음과 같은 변형으로 분류할 수 있다.
  1. 데이터의 전달 없이 일련의 작업이 순서대로 실행만 되는 경우.
  2. 작업의 결과를 다음 작업의 입력으로 사용하는 경우.
  3. 순차적으로 각 요소에 대해 비동기 작업을 적용하는 경우.
* **순차 실행은 직접 방식의 블로킹 API를 사용하여 구현하는 경우에는 일반적으로 간단하지만, 비동기 CPS를 사용하는 경우 콜백 지옥의 주요 원인**이 된다.

### 일련의 작업을 순차적으로 실행하기
* 다음의 패턴은 일련의 작업을 순차적인 실행 흐름에서 사용하는 일반화된 방식이다.
```
function task1(cb) {
  setTimeout(() => {
    console.log(`task 1 done`);
    task2(cb);
  }, 1000);
}

function task2(cb) {
  setTimeout(() => {
    console.log(`task 2 done`);
    task3(cb);
  }, 1000);
}

function task3(cb) {
  setTimeout(() => {
    console.log(`task 3 done`);
    cb(); // 모든 작업의 결과로 콜백을 실행한다.
  }, 1000);
}

task1(() => {
  console.log(`task 1, 2, 3 done!!!`);
});

/* 실행 결과
task 1 done
task 2 done
task 3 done
task 1, 2, 3 done!!!
*/ 
```
* 상술한 코드는 일반적인 비동기 작업 완료시 각각의 작업이 다음 작업을 호출하는 방법을 명시적으로 드러낸다.
* 또한, **이러한 패턴은 작업의 모듈화에 중점을 두었으므로 비동기 코드를 처리하기 위해 반드시 클로저를 사용할 필요가 없다는 사실을 보여준다**.
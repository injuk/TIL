# DesignPatterns
## 2022-05-22 Sun

## 콜백과 비동기 제어 흐름
* 동기식 프로그래밍을 사용하는 플랫폼에서 Node.js와 같이 CPS와 비동기 API를 주로 사용하는 플랫폼으로의 적응은 쉽지 않을 수 있다.
  * 비동기 코드는 구문이 실행되는 순서를 예측하기 어렵게 만들거나, 간단한 문제를 해결하는 코드도 가독성이 떨어지기 쉽다.
* 비동기 제어 흐름을 다루는 과정에서 콜백을 사용하는 경우, 가장 흔히 하는 실수는 크게 다음과 같다.
  1. 콜백 지옥에 빠지는 경우
  2. 코드가 간단한 루틴에서도 가독성을 잃게 되는 경우
  3. 유지보수가 어려워지며 수직적보다는 수평적으로 커지는 경우

### 비동기 프로그래밍의 어려움
* JS에서는 비동기 코드에 대한 제어를 놓치는 일이 빈번하게 발생한다.
* 클로저와 익명 함수의 in place 정의는 개발자가 코드의 이곳 저곳을 옮겨다니지 않고서도 원활한 프로그래밍을 가능하도록 돕는다.
* **모듈화나 재사용성, 유지보수성을 희생하는 것은 콜백의 중첩을 통제할 수 없이 급증시키고 함수의 크기와 구성을 엉망으로 만든다**.
  * 대부분의 경우 in place 콜백을 만드는 것이 절대적으로 중요한 것은 아니다.
  * 오히려, 비동기 프로그래밍과 관련된 문제보다는 규칙과 관련된 문제가 더 중요하다.

### 콜백 지옥
* 다음과 같이 구현한 알고리즘 자체가 간단하더라도, 코드에 여러 수준의 들여쓰기가 존재하는 경우 가독성은 매우 낮아질 수 있다.
```
export function spider(url, cb) {
  const filename = urlToFilename(url);
  fs.access(filename, err => {
    if(err && err.code === 'ENOENT') {
      console.log(`Downloading ${url} into ${filename}`);
      superagent.get(url).end((err, res) => {
        if(err) {
          cb(err);
        } else {
          mkdirp(path.dirname(filename), err => {
            if(err) {
              cb(err);
            } else {
              fs.writeFile(filename, res.text, err => {
                if(err) {
                  cb(err);
                } else {
                  cb(null, filename, true);
                }
              });
            }
          });
        }
      });
    } else {
      cb(null, filename, false);
    }
  });
}
```
* 이렇듯 비동기식 CPS에서 in place 콜백 정의를 잘못 사용하는 것은 코드의 가독성을 크게 떨어트리며, 관리할 수 없는 덩어리로 만든다.
  * 이는 **정확히 콜백 지옥에 해당하며, Node.js와 JS에서 잘 알려진 안티 패턴 중 하나**이다.
  * 또는 작성된 코드가 중첩이 깊어져 피라미드 같은 모양을 취하므로, 죽음의 피라미드라고도 부른다.
* **콜백 지옥에서 분명하게 드러나는 문제점은 가독성이며, 중첩이 너무 깊어지므로 함수가 어디에서 끝나고 어디에서 시작하는지 추적하는 것이 거의 불가능**해진다.
* **콜백 지옥의 또 다른 문제는 각 스코프에서 사용되는 변수의 이름이 중복된다는 것과, 클로저가 성능 및 메모리 측면에서 부정적인 영향을 준다는 사실**이다.
  * 특히 **활성화된 클로저에 의해 참조되는 컨텍스트는 GC의 대상이 되지 않으므로, 콜백 지옥은 식별하기가 매우 어려운 메모리 누수를 만들어내기 쉽다**.
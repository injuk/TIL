# DesignPatterns
## 2022-05-13 Fri

## 모듈 시스템
```
> 모듈은 주요 애플리케이션들을 구조화하기 위한 부품이다.
```
* 모듈을 사용할 경우, 애플리케이션은 다음과 같은 이점을 가질 수 있게 된다.
  1. **코드베이스를 개별적으로 개발 및 테스트 가능한 작은 유닛들로 분할**할 수 있다.
  2. **의도적으로 노출시키지 않은 모든 함수들과 변수들을 비공개로 유지하여 정보에 대한 은닉성을 강화**시킬 수 있다.
* 하나의 모듈 시스템을 갖는 다른 언어들과 달리, **Node.js는 다음과 같은 두 가지 모듈 시스템을 사용**한다.
  1. CommonJS
  2. ECMAScript modules

### 모듈의 필요성
* **모듈과 모듈 시스템은 별개의 것**이며, 다음과 같은 차이를 갖는다.
  1. 모듈 시스템이란, 문법이자 프로젝트에서 모듈을 정의하고 사용할 수 있도록 하는 도구이다.
  2. 모듈이란, 소프트웨어를 구성하는 실제 유닛을 말한다.
* 좋은 모듈 시스템은 소프트웨어 작성 과정에서 다음과 같은 몇 가지 요구사항을 만족시키는 데에 도움을 준다.
  1. 코드베이스를 나누어 여러 파일로 분할하는 방법을 제시한다.
     * 이를 통해 코드를 구조적으로 관리할 수 있다.
     * 덕분에 **독립적인 기능 조각을 개발 및 테스트할 수 있으며, 모듈 별 가독성은 높아진다**.
  2. 다른 프로젝트에서도 코드를 재사용할 수 있도록 한다.
     * 모듈은 다른 프로젝트에서도 유용할만한 특성을 구현할 수 있게 한다.
     * **모듈 형태로 구조화된 기능은 다른 프로젝트에서도 쉽게 재사용**할 수 있다.
  3. 은닉성을 제공한다.
     * 모듈을 통해 복잡한 구현은 외부로부터 숨기고, 명확한 책임을 갖는 간단한 인터페이스만 노출할 수 있다.
     * 대부분의 **모듈 시스템은 모듈 클라이언트가 사용할 수 있는 공개 인터페이스를 노출시키며, 세부 사항은 선택적으로 숨길 수 있도록 지원**한다.
  4. 종속성을 관리한다.
     * **모듈 시스템은 모듈 클라이언트가 접근하는 모듈의 실행에 필요한 종속성을 쉽게 임포트할 수 있도록 돕는다**.

### JS 모듈 시스템의 시작
```
> JS는 모듈 시스템이 없이도 관리에 어려움이 없는 상태가 길었기 때문에 내장 모듈 시스템이 존재하지 않았다.
```
* JS는 다른 언어와 달리 다음과 같은 이유에서 내장된 모듈 시스템이 오랫동안 존재하지 않았다.
  1. 브라우저 관점에서, 코드는 여러 파일로 분할될 수 있다.
  2. 단지 script 태그를 활용하는 것만으로도 분할된 코드베이스를 임포트할 수 있다.
  3. 웹사이트가 복잡하지 않았으므로, 몇 년간은 이러한 접근만으로도 웹 사이트를 빌드하는 것이 가능했다.
* 그러나 **웹 애플리케이션이 점차 복잡해지고, 프레임워크들이 생태계를 점유해나가며 점차 JS 프로젝트에 효율적으로 사용될 모듈 시스템의 필요성이 대두**되었다.
  * 이로 인해 JS 커뮤니티에서도 프로젝트에서 효율적으로 사용될 모듈 시스템을 정의하고자 하는 여러 시도가 나타나기 시작했다.

### Node.js 모듈 시스템
* Node.js가 처음 만들어진 시점에서, Node.js는 운영체제의 파일 시스템에 직접 접근하는 JS를 위한 서버 런타임으로 구상되었다.
  * 때문에 모듈 관리에 있어서 다른 방법을 도입해볼 수 있는 기회가 있었다.
* Node.js가 모듈을 관리하기 위해 도입한 방법은 다음과 같은 특징을 갖는다.
  1. script 태그와 URL을 통한 리소스 접근에 의존하지 않는다.
  2. **오직 로컬 파일 시스템의 JS 파일들에만 의존**한다.
* 때문에 **Node.js는 상술한 특징을 준수하여 브라우저가 아닌 환경에서 JS 모듈 시스템을 제공할 수 있도록 고안된 CommonJS의 명세를 구현**하게 되었다.
  * CommonJS는 시작과 더불어 Node.js에서의 주 모듈 시스템이 되었으며, Webpack과 같은 모듈 번들러 덕분에 브라우저 환경에서도 유명세를 탔다.

### ES6의 등장
```
> 지속 가능한 모듈을 작성하려면 CommonJS보다 ESM을 사용하는 것이 바람직하다.
```
* 2015년에 발표된 ECMAScript 6는 ECMAScript Modules라고 불리우는 표준 모듈 시스템을 위한 공식 제안을 포함하였다.
  * ESM은 JS 생태계에 큰 혁신을 불러왔으며, 특히 모듈 관리 관점에서 브라우저와 서버의 차이점을 연결하기 위해 노력하였다.
  * 그러나 ES6는 문법과 의미론적 관점에서 ESM을 위한 명세만을 정의하였고, 실제 구현을 제공하지는 않았다.
  * 이로 인해 여러 브라우저 회사들과 마찬가지로 Node.js 커뮤니티 역시 ESM 명세를 구현하기 위해 많은 시간을 소요하게 되었다. 
  * 그 결과, **Node.js는 13.2 버전부터 ESM을 안정적으로 지원**할 수 있게 되었다.
* **현재로서는 브라우저와 서버 환경 모두에서 ESM이 JS 모듈을 관리하는 실질적인 방법으로 사용된다**.
  * 그러나 **여전히 많은 Node.js 프로젝트들이 CommonJS에 의존하고 있으므로, ESM이 완전히 지배적인 표준이 되기까지는 더 많은 시간이 필요**하다.

## 2022-05-14 Sat
## 모듈 시스템과 패턴
* JS의 주요 문제점 중 하나는 네임스페이스가 없다는 점이며, 모든 스크립트는 전역 범위에서 실행된다.
* 이로 인해 내부 애플리케이션 코드 또는 종속성 라이브러리가 기능을 노출할 때마다 스코프를 오염시킬 가능성이 발생한다.
  * 예를 들어, 종속성 라이브러리가 선언한 변수의 이름이 외부에 선언된 변수의 이름과 같은 경우 애플리케이션은 오동작할 수 있다.
* 이는 매우 위험한 상황이므로, 전역 범위에 의존하는 것은 언제나 위험한 작업이다.
* 이러한 문제를 해결하기 위한 보편적인 기법에는 노출식 모듈 패턴이 있다.

### 노출식 모듈 패턴
```
const revealingModule = (() => {
    const name = 'injuk';
    const sayHello = () => { console.log('Hello!'); };
    
    return {
        publicName: name, 
        publicSayHello: sayHello,
    };
})();

console.log(revealingModule);
console.log(revealingModule.name, revealingModule.sayHello);
console.log(revealingModule.publicName, revealingModule.publicSayHello);
```
* 해당 패턴은 즉시 실행 함수를 사용하며, 함수 내부에 private한 범위를 만든 후 공개할 부분만 반환한다.
* **JS는 함수 내부에서 선언한 변수를 외부 범위에서 접근할 수 없으므로, 노출식 모듈 패턴은 외부에 공개할 정보만을 return 구문으로 명시**한다.
  * 상술한 코드의 경우, return 구문을 통해 외부로 반환된 객체의 속성만을 사용할 수 있게 된다.
* **노출식 모듈 패턴은 비공개 정보는 은닉하고 공개될 API만을 내보낼 수 있으며, CommonJS 모듈 시스템은 이 패턴을 기반으로 한 아이디어에서 시작**한다.

### CommonJS 명세
* CommonJS는 Node.js의 첫 번째 내장 모듈 시스템이다. 
* Node.js의 CommonJS는 실제 CommonJS의 명세를 고려하며 덧붙인 추가적인 자체 확장 기능과 함께 구현되었다.
* CommonJS 명세 중 주요한 개념은 크게 다음과 같이 요약할 수 있다.
  1. require 구문은 로컬 파일 시스템으로부터 모듈을 임포트하는 데에 사용된다.
  2. exports와 module.exports는 특별한 변수로서 현재 모듈에서 공개된 기능들을 내보내기 위해 사용된다.

### CommonJS 모듈 로더 구현하기
```
const fs = require('fs');

function loadModule(filename, module, require) {
  const wrappedSrc =
    `(function (module, exports, require) {
        ${fs.readFileSync(filename, 'utf8')}
      })(module, module.exports, require)`
  ;
  eval(wrappedSrc);
}
```
* 상술한 코드는 다음과 같은 특징을 갖는다.
  1. 모듈의 내용을 읽어들인 후 private 범위로 감싸 평가한다.
  2. 이 때, module, exports, require 변수들은 모듈에 전달된다.
  3. 래핑 함수의 exports 인자는 module.exports의 내용으로 초기화된다.
* 모듈의 내용을 읽어들일 때 비동기 방식이 아닌 동기 방식의 readFileSync가 사용되었다.
  * 파일 시스템의 동기 방식을 사용하는 것은 일반적으로 권장되지 않지만, **CommonJS의 모듈을 로드하는 것은 동기 방식에 해당**한다.
  * 때문에 **CommonJS에서는 여러 모듈의 임포트에 적절한 순서를 지키는 것이 중요**하다.

### require 함수 구현하기
```
function require(moduleName) {
  console.log(`Require invoked for module: ${moduleName}`);
  // 1.
  const id = require.resolve(moduleName);
  
  // 2.
  if(require.cache[id])
    return require.cache[id].exports;
  
  // 3.
  const module = {
    exports: {},
    id,
  };
  
  // 4.
  require.cache[id] = module;
  
  // 5.
  loadModule(id, module, require);
  
  // 6.
  return module.exports;
}
require.cache = {};
require.resolve = (moduleName) => {
  // 모듈 이름을 기반으로 id로 사용될 모듈의 전체 경로를 찾아낸다.
}
```
* 상술한 코드는 다음과 같은 특징을 갖는다.
  1. 우선 모듈의 전체 경로를 resolve 하고, 이를 id 변수로 초기화한다.
     * 모듈의 전체 경로 해석은 실제 알고리즘을 구현하는 require.resolve에 위임된다.
  2. 모듈이 이미 로드되어 있는 경우, 캐시된 모듈을 즉시 반환한다.
  3. 모듈이 아직 로드되어 있지 않은 경우, 최초 로드를 위한 환경인 모듈 메타데이터를 설정한다.
     * exports 속성은 빈 객체 리터럴로 정의된다.
     * **module 객체는 불러올 모듈의 코드에서 public API를 익스포트하는 데에 사용**된다.
  4. **최초 로드 과정을 마친 후에는 모듈 객체를 캐시**한다.
  5. **모듈 소스 코드는 파일에서 직접 읽어들이며, 이를 위해 앞서 생성한 module 객체와 require 함수의 참조를 전달**한다. 
     * 이렇게 **전달된 module 객체는 모듈의 코드가 실행되는 과정에서 module.exports 객체를 조작하기 위해 사용**된다.
     * module.exports 객체를 조작하거나 대체하는 과정을 통해 모듈은 public API를 내보낼 수 있다.
  6. 모듈이 내보낸 public API를 의미하는 module.exports의 내용은 클라이언트에게 반환된다.

### 모듈 정의 해보기
```
// 각 모듈은 또 다른 모듈 종속성을 로드할 수도 있다.
const anotherDependency = require('./anotherModule');

// private 멤버
function log() { console.log('helloooo'); }

// 공개적으로 사용되기 위해 익스포트되는 API
module.exports.run = () => { log(); };
```
* **module.exports 변수에 할당되지 않는 이상 모듈 내부의 모든 내용은 비공개**된다.
* **앞선 require 함수의 동작 방식에 따라, 모듈을 로드할 때 변수의 내용은 캐시된 후에 리턴**된다.

### module.exports와 exports
* **변수 exports는 module.exports의 초기 값에 대한 참조에 불과**하다.
  * 상술한 require 함수의 내용을 토대로, exports는 본질적으로 빈 객체 리터럴이다.
* 때문에 exports가 참조하는 객체에는 새로운 속성을 추가할 수 있다.
```
// exports = { hello: 'world' } 를 반환
exports.hello = 'world';
```
* exports 변수 자체에 대한 재할당은 지역 변수인 exports의 내용을 변경하므로, 실제 module.exports 객체에는 영향을 주지 못한다.
  * 즉, 실제로는 module.exports의 내용을 변경하지 않고 exports라는 지역 변수 자체만을 재할당한다.
  * 때문에 다음과 같은 exports의 재할당은 잘못된 사용 예시에 속한다.
```
exports = 'world';
```
* 이로 미루어 **exports는 모듈로부터 익스포트된 속성을 포함하는 객체를 반환하기 위해 사용하는 것으로 이해**할 수 있다.
* 반면 객체가 아닌 함수나 인스턴스, 또는 문자열을 익스포트하고자 하는 경우 전달된 module.exports 자체를 재할당해야 한다.
```
// exports = 'hello world' 를 반환
module.exports = 'hello world';
```
* 결국 **모듈 내에서 사용되는 module.exports 키워드는 module이 갖는 exports 객체의 실체인 반면, exports 키워드는 실제로는 지역 변수**다.

## 2022-05-15 Sun
### 동기적으로 동작하는 require 함수
* **Node.js의 require 함수는 동기적으로 동작하므로, module.exports에 대한 할당 역시 동기적이어야 한다**.
  * **require 함수는 이러한 동기적인 특성으로 인해, 모듈을 정의할 때 동기적으로 코드를 사용하도록 제한**한다.
  * 모듈을 비동기적으로 초기화했다면 require 함수로 모듈을 로드했다고 해도 사용할 준비가 되었다는 보장을 할 수 없었을 것이다.
* Node.js의 초기에는 비동기적인 특성을 갖는 require 함수를 제공하였으나, 장점보다 큰 복잡성을 가졌기에 제거되었다.

### resolving(해결) 알고리즘
```
> 해결 알고리즘은 Node.js 종속성 관리의 견고함을 뒷받침하는 핵심이며, 충돌 또는 버전 호환성 문제 없이 수백 또는 수천 개의 패키지를 가질 수 있도록 한다.
```
* **종속성 지옥은 프로그램의 종속성이 서로 공통된 라이브러리에 의존하지만 호환되지는 않는 서로 다른 버전을 필요로하는 경우를 의미**한다.
* **Node.js는 종속성 지옥을 우아하게 해결하기 위해 로드되는 위치에 따라 서로 다른 버전의 모듈을 로드할 수 있도록 한다**.
  * 이러한 장점은 Node.js 패키지 관리자가 애플리케이션 종속성을 구성하는 방식과 require 함수의 resolving(해결) 알고리즘에도 적용된다.
* resolve 함수는 모듈의 이름을 입력으로 하여 모듈 전체의 경로를 반환한다.
  * 이 때, **반환된 경로는 코드를 로드하고 모듈을 고유하게 식별하는 데에 사용**된다.
* 해결 알고리즘은 크게 다음과 같은 분류로 나누어볼 수 있다.
  1. 파일 모듈: 모듈명이 / 또는 ./로 시작하는 경우이다.
     * / : 절대 경로로 간주되며 해당 경로명을 그대로 반환한다.
     * ./ : 상대 경로로 간주되며 **요청한 모듈로부터 시작하여 계산**한다.
  2. 코어 모듈: 모듈명이 / 또는 ./로 시작하지 않는 경우, 코어 Node.js 모듈 내에서 검색을 시도한다.
  3. 패키지 모듈: 모듈명과 일치하는 코어 모듈도 없을 경우, 요청 모듈의 경로에서 시작하여 디렉토리 구조를 따라 올라가면서 탐색한다.
     * 이 때, 매 디렉토리 구조마다 node_modules 디렉토리를 찾아간다.
     * 탐색하는 디렉토리 구조에서 node_modules 디렉토리를 찾는데 성공한 경우, 그 안에서 일치하는 모듈을 찾아간다.
     * **알고리즘은 파일 시스템의 루트에 도달할 때까지 디렉토리 트리를 따라 올라가며 node_modules 디렉토리를 탐색하고 일치하는 모듈을 찾아나간다**.
* 파일 모듈과 패키지 모듈은 개별 파일과 디렉토리가 모두 모듈명과 일치할 수 있으며, 알고리즘은 다음과 같은 형식의 파일을 순서대로 찾는다.
  1. 모듈명.js
  2. 모듈명/package.json에 명시된 main 속성에 지정된 디렉토리, 또는 파일
  3. 모듈명/index.js
* **node_modules 디렉토리는 패키지 매니저가 실제로 각 패키지의 종속성을 설치하는 위치**이다.
  * **상술한 알고리즘을 기반으로 각 패키지는 자체적인 개별 종속성을 가질 수 있다**.
  * 때문에 **각 모듈에서 요구하는 종속성이 갖더라도 모듈에 따라 다른 파일이 로드될 수 있다**.
* 해결 알고리즘은 require 함수를 호출하는 것으로 적용되지만, 필요한 경우 모듈에서 require.resolve 메소드를 직접 호출하여 사용할 수도 있다.

### 모듈 캐싱
* require 함수의 후속 호출은 단순히 캐시된 버전을 반환하므로, 각각의 모듈은 첫 로딩시에만 실제로 로드되고 평가된다.
* 모듈 캐싱은 성능을 위해 매우 중요한 기능이지만, 다음과 같은 기능적인 영향도 존재한다.
  1. 모듈 종속성 내에서 순환 종속성을 가질 가능성이 발생한다.
  2. **일정 패키지 내에서 동일 모듈이 필요한 경우, 얼마간 동일한 인스턴스가 항상 반환되는 것을 보장**한다.
* 모듈 캐싱은 require.cache 변수를 통해 외부로 노출되므 필요시 모듈 캐시에 직접 접근할 수도 있다.
```
const { hello } = require('../dependency');
// 모듈 캐시에 직접 접근하기
console.log(require.cache);
```
* 일반적인 사용 사례는 require.cache 변수에서 관련된 키를 삭제하여 캐싱된 모듈을 무효화하는 것이다.
  * 그러나 캐싱된 모듈을 무효화하는 것은 테스트에서만 유용하며, 운영 코드에서는 매우 위험한 접근 방식이다.

### 순환 종속성
* 아래와 같이 main.js가 a.js와 b.js에 의존하고, a.js와 b.js는 서로에 대한 의존을 갖는 경우 순환 종속성을 갖게 된다.
```
// main.js
const a = require('./a');
const b = require('./b');

console.log(`a -> ${JSON.stringify(a, null, 2)}`);
console.log(`b -> ${JSON.stringify(b, null, 2)}`);

// a.js
exports.loaded = false;

const b = require('./b');

module.exports = {
  b,
  loaded: true,
};

// b.js
exports.loaded = false;

const a = require('./a');

module.exports = {
  a,
  loaded: true,
};
```
* **CommonJS에서 순환 종속성이 발생한 경우, 종속성 로드 순서에 따라 a와 b 각각으로부터 익스포트된 것이 애플리케이션의 각 지점에서 다를 수도 있다**. 
* 위 코드는 다음과 같이 진행된다.
  1. main.js에서 require 구문을 통해 모듈 a를 로드한다.
  2. 모듈 a는 loaded를 false로 설정한 후, require 구문에 의해 모듈 b를 로드한다.
  3. 모듈 b는 loaded를 false로 설정한 후, require 구뮨에 의해 모듈 a를 로드한다.
  4. **모듈 a는 이미 처리되었으므로 익스포트된 값은 즉시 모듈 b의 범위에 복사**된다.
  5. 모듈 b는 모듈 a로부터 복사된 값과 true로 설정된 loaded 변수로 구성된 새로운 객체를 익스포트한다.
     * 모듈 b는 이 시점에서 완전히 실행되며, 제어권은 모듈 a로 반환된다.
     * 모듈 b는 이 시점에서 캐싱된다.
  6. 모듈 a는 모듈 b로부터 복사된 값과 true로 설정된 loaded 변수로 구성된 새로운 객체를 익스포트한다.
     * 모듈 a는 이 시점에서 완전히 실행되며, 제어권은 main으로 반환된다.
  7. main은 모듈 a로부터 복사된 값을 내부 범위에 포함하게 된다.
  8. **main은 require 구문에 의해 모듈 b를 로드하지만, 반환되는 모듈 b는 5.의 과정에서 캐싱된 값**이다.
     * 즉, 모듈 a의 변경이 모듈 b에 반영되지 않는다.
  9. main은 모듈 b로부터 복사된 값을 내부 범위에 포함하게 된다.
* **상술한 절차에 따라 모듈 b는 완전히 로드되지 않은 모듈 a의 상태를 포함하게 되며, 이 문제를 main에 전파**시킨다.
* 순환 종속성이 발생하는 상황에서 어떤 모듈부터 로딩되는지를 놓칠 경우 디버깅은 어려워지며, 이는 프로젝트의 규모가 커질 경우 쉽게 발생할 수 있는 문제이다.

### 모듈 정의 패턴
```
> 모듈 시스템은 종속성을 로드하는 메커니즘을 제공할 뿐만 아니라, API를 정의하기 위한 도구이기도 하다.
```
* API 디자인과 관련된 문제들에서 주로 고려해야만 하는 요소는 private 함수와 public 함수 간의 균형이다.
* **API 디자인의 목표는 확장성과 코드 재사용성과 같은 소프트웨어 품질 균형은 유지하되, 정보 은닉 및 API 유연성은 극대화하는 것**이다.

### Named exports
* **public API를 공개하는 가장 기본적인 방법은 exports의 속성에 할당하는 것**이다.
  * 해당 방식에서는 exports 변수가 참조하는 객체의 속성에 공개할 모든 값을 할당하게 된다.
  * 이를 통해 **외부에 공개된 exports 객체는 일련의 기능에 대한 컨테이너, 또는 네임스페이스 역할을 수행**할 수 있다.
* **Node.js의 코어 모듈 대부분은 해당 패턴을 사용하며, CommonJS의 명세에는 public 멤버의 공개에 exports 변수만을 사용하도록 제시**한다.
  * 즉, **public 멤버를 exports로 지정하는 것만이 CommonJS의 명세와 완벽히 호환되는 유일한 방식**이다. 
  * 반면, module.exports는 Node.js가 제공하는 모듈 정의 패턴의 광범위한 범위를 지원하기 위한 기능이다.

### Substack pattern
* 가장 일반적인 모듈 정의 패턴 중 하나는 module.exports 변수 전체를 함수로 재할당하는 것이다.
  * 이 방식은 **모듈에 대한 명확한 진입점 역할을 수행하는 단일 기능을 통해 모듈에 대한 이해와 사용을 단순화**한다.
  * 이는 최소한의 노출 원리에도 잘 맞아떨어지는 방식이며, 커뮤니티에서는 서브스택 패턴으로 알려진다.
* **서브스택 패턴은 익스포트된 함수를 또 다른 public 멤버의 네임스페이스로 활용할 수 있다**.
  * 아래의 코드에서, 익스포트된 함수 logger는 또 다른 함수 verbose 네임스페이스로 사용된다.
  * 따라서, logger() 형식 뿐만 아니라 logger.verbose() 형식의 호출 역시 가능해진다.
```
// logger.js
module.exports = (message) => {
  console.log(`info: ${message}`);
};

// 해당 모듈에서 반환된 함수를 네임스페이스로 사용한다.
module.exports.verbose = (message) => {
  console.log(`verbose: ${message}`);
};

// main.js
const logger = require('./logger');

logger('정보 메시지');
// logger를 네임스페이스로 사용하는 verbose 함수를 호출할 수 있다.
logger.verbose('상세 메시지');
```
* **서브스택 패턴을 상술한 방식으로 응용할 경우, 익스포트된 함수를 명확한 단일 진입점으로 제공하므로 아주 강력한 방식**이 될 수 있다.
  * 이를 통해 익스포트된 기능의 고급 유즈케이스를 만들 수 있는 부가적인 기능을 노출할 수 있다.
  * 상술한 예시에서, 익스포트된 logger는 클라이언트가 고급 유즈케이스를 구현하는 과정에서 활용할 수 있도록 verbose라는 부가 기능을 제공한다.
* **객체가 아닌 함수 하나만을 익스포트하는 것이 제약처럼 보일 수 있으나, 실제로는 단일 기능에 중점을 두어 단일 책임 원칙을 준수하는 완벽한 방법**이다.
  * 이를 통해 내부의 상세한 구현 사항에 대한 가시성을 줄이되, 보조적으로 필요한 사항들만 함수의 속성으로 노출하는 단일 진입점의 제공이 가능하다.
  * **Node.js의 모듈성은 단일 책임 원칙의 준수를 강력히 권장**한다.
  * 결국 모든 모듈은 단일 기능에 대한 책임만을 져야하며, 그 책임은 모듈에 의해 완전히 캡슐화되어야 한다.

### 클래스 내보내기
* 클래스를 익스포트하는 모듈은 함수를 익스포트하는 모듈이 특화된 것이다.
* 해당 방식은 프로토타입을 확장하고 새로운 클래스를 작성할 수 있는 기능을 제공할 수 있다는 장점을 갖는다.
* 또한 **해당 방식은 여전히 모듈에 대한 단일 진입점을 제공하지만, 서브스택 패턴과 비교할 경우 훨씬 더 많은 내부를 노출**한다.
  * 반면, 또 다른 한편으로는 기능 확장에 있어 훨씬 강력할 수 있다.

### 인스턴스 내보내기
* **require 함수의 캐싱 기능을 통해 생성자나 팩토리로부터 서로 다른 모듈 간에 공유할 수 있는 상태 저장 인스턴스를 정의**할 수 있다.
* 모듈이 캐싱되므로, 해당 모듈을 로드하는 모든 다른 모듈은 실제로 항상 동일한 인스턴스를 받아 상태를 공유할 수 있다.
  * 즉, 해당 패턴은 싱글톤 패턴과 매우 유사하다.
* 그러나 **전통적인 싱글톤 패턴처럼 전체 애플리케이션에 걸쳐 인스턴스의 고유성을 보장하지는 않는다**.
  * 해결 알고리즘에 의해 모듈은 동일한 애플리케이션의 종속성 트리 안에서 여러 번 설치될 수 있다.
    * **동일한 모듈이 임포트되는 위치가 다른 경우, 해결 알고리즘에서 반환하는 절대 경로인 id가 모두 달라지므로 인스턴스는 여러 개 생성**될 수 있다.
  * 이로 인해 동일한 논리적 모듈의 여러 인스턴스가 모두 동일한 Node.js 애플리케이션의 컨텍스트에서 실행될 수 있다.
* 해당 방식은 클래스를 명시적으로 익스포트하지 않지만, 익스포트된 인스턴스의 constructor 속성을 기반으로 새로운 인스턴스를 우회적으로 생성할 수 있다.
  * 그러나 이러한 방법은 **모듈 제작자가 클래스를 명시적으로 익스포트하지 않은 의도를 고려하여 사용을 지양하는 것이 바람직**하다.

### Monkey patching
```
> 몽키 패치란 모듈이 전역 범위의 다른 모듈이나 객체를 수정하는 것다. 
> 더 일반적인 의미로는 런타임 시 기존 객체를 수정하거나 동작을 변경하는 임시 수정 적용 관행을 말한다.
```
* **모듈은 아무 것도 내보내지 않을 수도 있으며, 대신 캐시에 있는 다른 모듈 또는 전역 범위에 위치한 모든 개체를 수정**할 수 있다.
* 몽키 패치는 일반적으로 권장되지 않지만, 테스트 등 일부 상황에서는 유연하고 안전하며 심지어 실전에서도 종종 사용되는 방식이다.
```
// patcher.js
// 단순히 logger에 새로운 기능을 덧붙이는 역할만을 수행한다.
require('./logger').debug = (message) => {
  console.log(`debug: ${message}`);
}

// main.js
// 아래 라인을 주석 처리하는 경우 에러가 발생한다.
require('./patcher');
const logger = require('./logger');

logger('정보 메시지');
logger.verbose('상세 메시지');
logger.debug('디버그 메시지');
```
* **몽키 패치는 실제로 적용하기에는 위험한 기술이며, 이는 전역 네임스페이스나 다른 모듈을 수정하는 모듈을 갖는 것 자체에 부작용이 있기 때문**이다.
* **몽키 패치는 범위를 벗어난 요소의 상태에 영향을 미치므로, 여러 모듈이 동일한 속성에 대한 작업을 수행하는 경우에 예측할 수 없는 결과를 초래**할 수 있다.
  * 중요한 것은 몽키 패치가 전체 애플리케이션에 좋지 않은 영향을 미칠 가능성이 높다는 사실이다.
* **몽키 패치를 프로젝트에서 사용하고자 하는 경우, 발생할 수 있는 모든 부작용을 이해한 상태에서 신중하게 적용할 수 있도록 해야 한다**.
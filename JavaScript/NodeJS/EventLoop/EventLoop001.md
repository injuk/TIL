# EventLoop
## 2022-06-01 Wed

## 이벤트 루프란?
* Node.js가 여러 비동기 작업을 관리하기 위해 사용하는 구현체이다.
* 이벤트 루프는 되도록 커널에 I/O작업을 넘겨 Node.js가 논블로킹 작업을 수행할 수 있도록 한다. 
  * 대부분의 현대적인 커널은 멀티 스레드이므로 백그라운드에서 여러 작업을 수행할 수 있다. 
  * 이러한 작업 중 하나가 완료되면 Node.js에게 알리고, 적절한 콜백이 Poll 큐에 추가된다.

### 이벤트 루프의 허와 실
* 이벤트 루프는 V8과 같은 JS 엔진이 아닌 Node.js 또는 브라우저 자체에 포함된다.
* 이벤트 루프에는 스택이 존재하지 않는다.
* 이벤트 루프는 하나가 아닌 여러 개의 큐를 활용하여 동작한다.
* 이벤트 루프는 루프의 진행과 JS 코드의 실행 모두를 단일 스레드로 처리한다. 
  * 이 때, 코드의 실행은 V8 등의 JS 엔진을 활용한다.

### 이벤트 루프의 구조
```
> nextTickQueue와 microTaskQueue는 이벤트 루프 외부에 위치한다.
```
* 이벤트 루프는 여러 단계로 구성되며, 각 단계마다 실행되어야 할 콜백을 포함하는 FIFO 큐를 갖는다.
* 이벤트 루프는 각 단계에 진입하면 해당 단계의 큐를 확인하고, 콜백을 실행한다. 
  * 이 때, 콜백은 큐를 완전히 비우거나 / 콜백 실행 제한 수에 이를 때까지 실행된다. 
* 이벤트 루프에 포함되는 각 단계는 페이즈(Phase), 페이즈 전환은 틱(Tick)이라고 부른다.
![](https://github.com/injuk/TIL/blob/master/JavaScript/images/event-loop-architecture.png)

### 이벤트 루프의 흐름
* node 명령에 의해 JS 코드가 실행된 경우, Node.js는 다음과 같은 순서로 동작한다.
  1. 이벤트 루프를 생성한다.
  2. 이벤트 루프 외부에서 JS 코드를 실행한다.
  3. Node.js는 이벤트 루프가 수행해야할 작업이 있는 활성 상태인지 확인한다.
    * 활성 상태가 아닌 경우, Node.js는 process.on('exit', ()=>{});를 실행하고 이벤트 루프를 종료한다.
  4. 이벤트 루프가 활성 상태인 경우, 이벤트 루프의 첫 번째 페이즈인 Timers 페이즈를 실행한다.
* 이 때, 각각의 페이즈는 작업 결과로 또 다른 작업을 스케쥴링할 수도 있다.
  * 그러나 각 페이즈는 콜백 실행 한도 제한이 있으므로, 영영 하나의 페이즈에 머무를 일은 없다.

## 페이즈 개요
* 이벤트 루프는 다음과 같은 여섯 개의 페이즈로 구성된다.
  1. timers: setTimeout과 setInterval로 스케쥴링된 콜백을 실행한다. 
  2. pending callbacks: 다음 루프 반복으로 연기되었던 I/O 콜백들을 실행한다. 
  3. idle, prepare: 이벤트 루프의 내부 관리 목적으로 사용되는 페이즈이다. 
  4. poll: 새로운 I/O 이벤트를 가져오며, 연관된 모든 콜백을 실행한다. 
    * Node.js는 적시에 poll 페이즈에서 블록된다. 
  5. check: setImmediate 콜백을 위한 페이즈이다. 
  6. close callbacks: close 콜백들을 위한 페이즈이다.
* JS 코드의 실행은 idle, prepare 페이즈를 제외한 모든 단계에서 가능하다.
* nextTickQueue와 microTaskQueue는 이벤트 루프의 일부가 아니며, 이들 작업은 우선 순위가 더 높다. 
  * 해당 큐에 포함된 작업들 역시 모든 페이즈에서 실행될 수 있다.

### Timers 페이즈
* setTimeout, setInterval에 설정된 타이머는 정확한 시간이 아닌 기준 시간이다. 
  * 예를 들어, 1000으로 설정된 경우 타이머는 1000ms 이후에 콜백을 가능한 한 빨리 실행한다.
* Timer 페이즈는 이벤트 루프에서 가장 먼저 시작되는 페이즈이다.
* setTimeout이나 setInterval과 같은 타이머들은 min-heap으로 유지된다. 
  * 이로 인해 타이머들은 실행되어야하는 순서에 맞게 저장된다. 
  * 실행할 때가 된 타이머들은 Timers 페이즈가 관리하는 큐에 삽입되어 실행된다. 
* 해당 페이즈의 큐에는 setTimeout / setInterval과 같은 타이머에 의해 스케쥴링된 콜백이 저장된다. 
* 기술적으로 Timers 페이즈는 Poll 페이즈에 의해 제어된다.

### Pending Callbacks 페이즈
* 이벤트 루프의 pending_queue에 삽입된 콜백들이 실행되는 페이즈이다. 
  * 해당 큐에 삽입된 콜백들은 이전 루프에서 실행한 작업 중 완료된 작업의 콜백이다. 
  * 즉, 이전 이벤트 루프에서 미처 수행되지 못한 I/O 콜백들이다.
* 대부분의 페이즈는 시스템 실행 한도의 영향을 받는다. 
  * 실행 한도에 의해 큐에 쌓인 모든 작업을 실행하지 못한 페이즈는 pending_queue에 작업을 삽입한다.
* 에러 핸들러 콜백 역시 pending_queue에서 실행하게 된다. 
  * 예로, *nix는 TCP 단에서 수신한 ECONNREFUSED를 처리하기 위한 에러 핸들러를 pending_queue에 추가한다.

### Idle, Prepare 페이즈
```
> 해당 두 페이즈는 이벤트 루프와 직접적인 연관이 있는 것은 아니며, 오히려 Node.js의 내부적인 관리를 위해 존재하는 페이즈이다.
```

### Poll 페이즈
* Poll 페이즈는 두 가지 주요한 기능을 갖는다. 
  1. I/O를 얼마나 오래 블록하고 폴링할지 계산한다. 
  2. Poll 페이즈 큐에 있는 이벤트를 처리한다.
* 해당 페이즈에서는 새로운 소켓 설정돠 파일 읽기 등의 데이터를 허용한다. 
* 해당 페이즈가 관리하는 watcher_queue는 I/O와 관련된 거의 모든 콜백들이 삽입된다. 
  * 사실상 setTimeout, setInterval, setImmediate, close 콜백 등을 제외한 모든 콜백이 삽입된다. 
* Poll 페이즈가 갖는 watcher_queue가 비어있지 않은 경우, 큐가 비거나 시스템 실행 한도에 다다를 때까지 콜백을 동기적으로 실행한다.
* watcher_queue가 비어 있는 경우, NODE.JS는 약간의 대기 시간을 가지게 된다. 
  * 이 때, NODE.JS의 대기 시간은 여러 요인에 따라 계산된다.
* 이벤트 루프가 Poll 페이즈에 진입하고 스케쥴링된 타이머가 없는 경우, Poll 큐를 확인한 후 분기한다.
  1. 비어있지 않은 경우: 이벤트 루프는 콜백 큐를 순회하며 콜백을 실행한다. 
     * 콜백은 큐가 완전히 비워지거나 실행 제한에 도달할 때까지 실행된다. 
  2. 비어있는 경우: setImmediate가 스케쥴링한 콜백이 있는지 확인한다. 
     1. 있는 경우: 이벤트 루프는 Poll 페이즈를 종료하고 Check 페이즈로 전이한다. 
     2. 없는 경우: 이벤트 루프는 새로운 콜백이 Poll 큐에 추가되는 것을 대기하고, 즉시 실행한다.
* Poll 큐가 완전히 비워지는 경우, 이벤트 루프는 실행해야 할 타이머 콜백 역시 확인한다. 
  * 하나 이상의 타이머가 준비된 경우, 이벤트 루프는 콜백 실행을 위해 Timers 페이즈로 전이한다.

### Check 페이즈
* Check 페이즈는 Poll 페이즈가 완료된 직후 실행될 콜백을 개발자가 추가할 수 있도록 한다. 
* Poll 페이즈가 유휴 상태이며, setImmediate로 Check 큐에 콜백이 다시 추가된 경우 Check 페이즈를 계속한다.

### nextTickQueue, microTaskQueue
```
> 해당 큐들은 기술적으로 이벤트 루프의 일부가 아니므로, libuv가 아닌 Node.js에 포함되는 기술이다.
> 해당 큐에 포함되는 작업들은 현재 실행 중인 작업이 끝난 직후에 호출된다.
```
* nextTickQueue는 process.nextTick()에 의해 스케쥴링된 콜백들을 갖게 된다. 
* microTaskQueue는 resolve된 프로미스의 콜백을 갖게 된다.

## 페이즈 상세
### Timers 페이즈
* 이벤트 루프는 우선 실행해야될 타이머 콜백 큐를 확인한다. 
* 이 때, 콜백 큐의 타이머들을 하나씩 확인하며 타이머 콜백을 실행해야하는지 검사한다. 
  * 조건에 해당하는 타이머의 콜백은 실행하고, 다음 콜백을 검사한다. 
  * 조건에 해당하지 않는 타이머의 콜백인 경우, 탐색을 종료하고 다음 페이즈로 전이한다. 
* 페이즈는 시스템의 실행 한도에도 영향을 받는다.
  * 즉, 실행해야 할 타이머가 남아 있더라도 한도에 다다르면 다음 페이즈로 전이한다.

### Pending Callbacks 페이즈
* Timers 페이즈가 종료된 후 이벤트 루프는 Pending I/O 페이즈로 전이한다. 
* 우선 이전 작업들의 콜백이 pending_queue에 삽입되었는지 확인한다. 
  * 대기 중인 콜백이 존재하는 경우, 큐가 완전히 비거나 한도에 다다를 때까지 콜백을 실행한다.

### Poll 페이즈
* 이벤트 루프가 해당 페이즈에 진입한 경우, watcher_queue에 수행해야할 작업이 있는지 확인한다. 
  * 있는 경우, 큐를 완전히 비우거나 한도에 다다를 때까지 콜백을 실행한다. 
* Poll 페이즈가 관리하는 I/O 이벤트는 타이머와 달리 항상 순서대로 실행된다는 보장이 없다. 
  * 때문에 watcher_queue에는 열린 소켓에 대한 메타데이터를 갖는 watcher가 삽입된다. 
  * 각 watcher는 FD 정보 역시 포함하므로, OS가 FD의 준비를 알리면 이벤트 루프는 적절한 watcher를 찾아 대응되는 콜백을 실행하게 된다.
* Poll 페이즈에 진입한 후 watcher_queue가 비워졌다면, 이벤트 루프는 해당 페이즈에서 대기한다. 
* 이 때, 대기 시간은 다음과 같은 요인으로 결정된다. 
  * 이벤트 루프가 종료된 경우, 즉시 다음 페이즈로 전이한다. 
  * check_queue / pending_queue / closing_callbacks_queue에 실행해야 할 콜백이 있는지 검사한다. 
    * 실행해야할 콜백이 있는 경우, 즉시 다음 페이즈로 전이한다.
* 남아 있는 타이머가 없는 경우, 무한정 대기한다. 
* 남아 있는 타이머가 있는 경우, 다음과 같이 동작한다. 
  * 해당 타이머를 즉시 실행할 수 있는 경우, 즉시 다음 페이즈로 전이한다. 
  * 해당 타이머를 즉시 실행할 수 없는 경우, 실행이 가능할 때까지 대기해야할 시간을 계산하고 대기한다.

### Check 페이즈
* 해당 페이즈 역시 setImmediate로 스케쥴링된 콜백이 큐에 있는지 확인한다. 
  * 있는 경우, 큐를 완전히 비우거나 한도에 다다를 때까지 콜백을 실행한다.

### Close Callbacks 페이즈
* close나 destroy 타입의 콜백을 관리하기 위한 페이즈이다. 
* 이벤트 루프가 해당 페이즈를 종료하는 경우, 다음 루프를 돌아야하는지 확인한다. 
  * 더 이상 처리할 콜백이 없는 경우, 이벤트 루프는 종료된다. 
    * 이벤트 루프가 종료되면 process.on('exit', () => {}) 가 실행되고 애플리케이션이 종료된다.
  * 있는 경우, 이벤트 루프는 다음 순회를 시작하기 위해 Timers 페이즈로 진입한다.

### nextTickQueue, microTaskQueue
* 해당 큐의 콜백은 페이즈 간의 전이가 발생하기 이전에 자신이 갖는 콜백들을 최대한 빠르게 실행한다. 
  * Node.js 11 이전에는 페이즈 전이 사이에 해당 큐들을 확인하였다. 
  * 그러나 11 버전 이후에는 각 페이즈 별 큐를 확인하기 전에 두 큐를 확인하도록 수정되었다.
* 해당 큐는 다른 큐들과 달리 시스템의 실행 한도에 영향을 받지 않는다. 
  * 따라서 Node.js는 각 큐가 완전히 비워질 때까지 콜백을 실행한다.
* nextTickQueue는 microTaskQueue보다 높은 우선 순위를 갖는다.
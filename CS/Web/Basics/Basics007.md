# Basics
## 2022-06-08 Wed

### HTTP 헤더란?
* HTTP 헤더는 HTTP 전송에 필요한 모든 부가 정보를 입력하기 위해 사용할 수 있다.
* HTTP 헤더는 수많은 표준 헤더가 존재하며, 필요시 임의의 사용자 정의 헤더를 추가할 수도 있다.

### 최신 스펙에서의 HTTP 본문
* 메시지 본문을 통해 표현 데이터를 전달하며, 이는 payload라는 용어로 지칭한다.
* 표현이란 요청 또는 응답에서 전달할 실제 데이터이며, 이 중 표현 헤더는 표현 데이터를 해석할 수 있는 정보를 제공한다.
  * 예를 들어 표현 헤더에는 데이터 유형 / 데이터 길이 / 압축 정보 등이 포함될 수 있다.
  * 이 때, **표현은 표현 데이터와 표현 헤더를 아우르는 용어**이다.

### 표현 헤더
* Content-Type은 표현 데이터의 형식을 나타내는 헤더이다.
* Content-Encoding은 표현 데이터의 압축 방식을 나타내는 헤더이다.
* Content-Language는 표현 데이터의 언어를 나타내는 헤더이다.
  * 예를 들어, 해당 헤더는 한국어 또는 영어 등을 포함할 수 있다.
* Content-Length는 표현 데이터의 길이를 나타내는 헤더이다.
  * 엄격하게 분류하는 경우 Content-Length는 표현과 관련이 없으므로, 페이로드 헤더로 볼 수 있다.
* **표현 헤더는 HTTP 요청과 응답 모두에서 사용**될 수 있다.

### Content-Type 헤더
* 해당 헤더는 표현 데이터의 형식을 설명하며, 미디어 타입 또는 문자 인코딩을 표현하기 위해 다음과 같은 값을 작성할 수 있다.
  1. text/html; charset=utf-8
  2. application/json
  3. image/png
* 이 때, application/json은 기본 인코딩이 utf-8로 적용된다.

### Content-Encoding 헤더
* 해당 헤더는 표현 데이터를 압축하기 위해 사용되며, 데이터를 전달하는 곳에서 압축한 후 해당 헤더를 추가한다.
  * 데이터를 읽는 측에서는 해당 헤더의 정보를 토대로 압축을 해제한다.
* 해당 헤더는 예를 들어, gzip / deflate / identity 등의 값을 포함할 수 있다.
  * 이 때, identity는 압축을 하지 않는 것을 의미한다.

### Content-Language 헤더
* 해당 헤더는 표현 데이터의 자연 언어를 명시하기 위해 사용되며, 예를 들어 다음과 같은 값을 포함할 수 있다.
  1. ko: 이 경우, **메시지 수신자는 메시지 본문에 한글이 들어가 있을 것을 예상**할 수 있다.
  2. en
  3. en-US
* 해당 헤더는 사용자의 언어와 Content-Language 헤더의 언어가 상이한 경우 번역된 페이지를 볼 것인지 선택하는 토스트를 띄우는 데에 활용할 수 있다.

### Content-Length 헤더
* 해당 헤더는 바이트 단위로 표현된 표현 데이터의 길이를 나타낸다.
* 이 때, Transfer-Encoding을 사용하는 경우 Content-Length 헤더를 사용하지 않아야 한다.
  * 이는 Transfer-Encoding을 사용하는 경우, 해당 헤더 안에 필요한 모든 정보가 포함되기 때문이다.

### 컨텐츠 협상
* **해당 분류는 HTTP 요청에서만 사용되며, 클라이언트가 선호하는 표현과 관련된 정보를 서버에게 알리기 위해 명시**한다.
  1. Accept: 클라이언트가 선호하는 미디어 타입을 명시한다.
  2. Accept-Charset: 클라이언트가 선호하는 문자 인코딩 방식을 명시한다.
  3. Accept-Encoding: 클라이언트가 선호하는 압축 인코딩 방식을 명시한다.
  4. Accept-Language: 클라이언트가 선호하는 자연어 종류를 명시한다.
* 서버는 해당 헤더의 정보를 확인하여 클라이언트가 원하는 방식으로 HTTP 응답을 작성할 수 있다.
  * 그러나 각 헤더에 분류된 타입을 서버가 제공할 수 없을 수도 있다.
  * 즉, 서버는 클라이언트의 요청에 최대한 맞춰주는 `Best Effort` 방식으로 동작한다.

### 컨텐츠 협상과 우선 순위 설정
* 컨텐츠 협상과 관련된 헤더에는 우선 순위인 `Quality Values`를 나타내는 변수 q를 사용할 수 있다.
  * q의 범위는 0 ~ 1이며, 큰 값일수록 높은 우선 순위를 갖는다.
  * 변수 q를 생략한 경우, 값은 1로 적용된다.
* 예를 들어 다음과 같은 헤더를 HTTP 요청에 작성할 수 있다.
```
GET /events HTTP/1.1
Accept-Language: ko-KR,ko;q=0.9,en-US;q=0.8,en;q=0.7

```
* 상술한 헤더의 경우, ko-KR / ko / en-US / en 순으로 우선 순위가 낮아진다.
  * 즉, ko-KR의 우선 순위가 가장 높다.
* 이러한 컨텐츠 협상 우선 순위의 경우, 다음과 같은 시나리오에서 유용하게 사용할 수 있다.
  1. 서버는 독일어와 영어를 지원하되, 기본 언어가 독일어이다.
  2. Accept-Language 헤더를 한국어 설정으로만 보낼 경우, 서버는 기본 언어인 독일어를 기반으로 데이터를 반환한다.
  3. 이 때, 최소한 영어로 작성된 데이터를 받기 위해 en 또는 en-US의 q 변수의 값을 할당할 수 있다.
     * 이 때, 굳이 독일어 설정을 헤더에 작성할 필요는 없다.
     * 서버는 우선 순위가 높은 언어부터 파악하며, 자신이 지원하는 언어를 확인한 시점에서 해당 언어로 반환한다.

### 구체적인 컨텐츠를 우선하기
* Accept 헤더의 경우, 와일드카드 기호인 `*`을 사용할 수 있다.
* 우선 순위 변수 q가 생략된 경우, **추상화된 데이터인 와일드카드를 작성한 값보다 구체적으로 작성된 값의 우선 순위가 더 높이 적용**된다.
* 예를 들어, 다음과 같은 HTTP 요청 메시지의 경우 우선 순위는 아래와 같다.
  1. text/plain;format=flowed
  2. text/plain
  3. text/*
  4. */*
```
GET /events HTTP/1.1
Accept: text/*,text/plain,text/plain;format=flowed,*/*

```

### 전송 방식
* 전송 방식은 크게 다음과 같이 분류할 수 있다.
  1. 단순 전송
  2. 압축 전송
  3. 분할 전송
  4. 범위 전송
* 단순 전송의 경우, 메시지 본문에 대한 Content-Length를 작성하여 HTTP 응답으로 반환한다.
  * 즉, 메시지 본문의 길이를 알 수 있는 경우에 해당한다.
* **압축 전송의 경우, 메시지 본문을 압축하며 Content-Encoding 헤더를 추가하여 HTTP 응답을 반환**해야 한다.
* 분할 전송의 경우, `Transfer-Encoding: chunked` 헤더를 HTTP 응답에 포함시켜 반환해야 한다.
  * **분할 전송은 Content-Length를 초기에 예상할 수 없으므로, 해당 헤더를 포함하지 않아야 한다**.
  * 또한 분할된 각 chunk에 byte 정보가 이미 포함되므로, 굳이 Content-Length 헤더를 명시할 필요도 없다. 
* 범위 전송의 경우, Range와 Content-Range 헤더를 활용할 수 있다.
  * 클라이언트는 `Range: bytes=1001-2000`과 같은 형식으로 요청하는 범위를 명시한다.
  * 서버는 `Content-Range: bytes 1001-2000 / 2000`과 같은 형식으로 반환되는 범위에 대한 정보를 포함시킨다.

### 일반적인 정보를 표현하는 헤더
* 일반적인 정보를 표현하는 헤더는 `From`, `Referer`, `User-Agent`, `Server`, `Date` 등이 존재한다.

### From 헤더
* `From` 헤더는 유저 에이전트의 이메일 정보를 명시하는 헤더이며, HTTP 요청에서 사용된다.
  * 일반적으로는 잘 사용되지 않으며, 주로 검색 엔진에서 사용하는 헤더이다.

### Referer 헤더
* **`Referer` 헤더는 현재 요청된 페이지의 이전 웹 페이지 주소를 명시하는 헤더이며, HTTP 요청에서 사용**된다.
  * **페이지 A에서 페이지 B로 이동한 경우, B의 페이지를 요청할 때 `Referer: A` 헤더를 포함하여 요청**하게 된다.
  * 해당 헤더를 통해 사용자가 유입된 경로를 분석할 수 있다.
  * 해당 헤더는 실무에서도 매우 많이 사용되는 헤더이다.

### User-Agent 헤더
* **`User-Agent` 헤더는 사용자의 에이전트 애플리케이션 정보를 나타내는 헤더이며, 주로 브라우저 정보를 명시**한다.
  * 해당 헤더 역시 HTTP 요청에서 사용되며, 주로 어떠한 종류의 브라우저에서 오류가 발생하는지 파악하는 데에 사용할 수 있다.
  * 클라이언트가 사용한 애플리케이션을 유저 에이전트라는 용어로도 지칭한다.

### Server 헤더
* `Server` 헤더는 요청을 처리하는 Origin 서버의 소프트웨어 정보를 명시하는 헤더이며, HTTP 응답에서 사용된다.
  * **Origin 서버란, 클라이언트의 HTTP 요청을 실제로 처리하여 표현 데이터를 생성해주는 서버**를 말한다.
  * 예를 들어, HTTP 요청이 전달되는 과정에서 수많은 프록시 또는 캐시 서버를 거칠 수 있다.
  * **Server 헤더는 이러한 중간 서버들을 모두 제외하고, 실제로 요청을 처리하는 서버에 대한 정보를 알려주기 위해 사용**된다.

### Date 헤더
* `Date` 헤더는 메시지가 발생한 날짜와 시간을 명시하며, HTTP 응답에서 사용된다.
  * **과거에는 HTTP 요청에서도 사용이 가능했으나, 최신 스펙에서는 HTTP 응답에서만 사용하도록 수정**되었다.

### 특수한 정보를 표현하는 헤더
* 특수한 정보를 표현하기 위해 사용되는 헤더는 `Host`, `Location`, `Allow`, `Retry-After` 등이 있다.

### Host 헤더
* **`Host` 헤더는 필수로 사용되는 헤더이며, HTTP 요청에서 사용**된다.
  * 필수 헤더는 거의 존재하지 않으나, 해당 헤더는 필수 헤더에 해당한다.
* **해당 헤더는 하나의 서버 또는 하나의 IP 주소에서 여러 도메인을 처리하는 경우하는 경우에 사용**된다. 
  * 이는 가상 호스트 개념을 통해 단일 서버에서 여러 도메인에 대한 요청을 처리하는 경우를 예시로 들 수 있다.
  * 이 경우, **`Host` 헤더를 사용하지 않는다면 서버는 사용자의 요청을 어떤 도메인에 대한 요청으로 받아들여야할지 판단할 수 없다**.

### Location 헤더
* `Location` 헤더는 페이지 리다이렉션에 사용되는 헤더이다.
* 예를 들어 **웹 브라우저는 3xx 번대 상태 코드를 갖는 HTTP 응답에 `Location` 헤더가 포함된 경우, 해당 위치로 자동으로 이동**한다.
* 해당 헤더는 HTTP 응답에 사용된 상태 코드에 따라 다음과 같은 의미를 갖는다.
  1. 201 Created: HTTP 요청에 의해 생성된 리소스의 URI를 의미한다.
  2. 3xx Redirection: **HTTP 요청을 자동으로 리다이렉트하기 위한 대상 리소스를 의미**한다.

### Allow 헤더
* `Allow` 헤더는 허용 가능한 HTTP 메소드를 명시하기 위해 사용되며, 405 Method Not Allowed를 반환하는 HTTP 응답에 포함해야 한다. 
* 예를 들어, `Allow: GET,HEAD,PUT`과 같은 형태로 작성될 수 있다.
  * 그러나 이는 실무에서 서버에 구현하는 경우가 드문 기능이며, `Allow` 헤더 역시 잘 사용되지 않는다.

### Retry-After 헤더
* `Retry-After` 헤더는 유저 에이전트가 다음 요청을 시도하기까지 대기해야하는 시간을 명시하기 위해 사용하는 헤더이다.
  * 예를 들어, HTTP 응답 코드가 503 Service Unavailable인 경우 서비스가 언제까지 불능할지 명시하기 위해 해당 헤더를 활용할 수 있다. 
* 해당 헤더는 다음과 같은 두 가지 방식으로 작성할 수 있다.
  1. 날짜 표기법: `Retry-After: Fri,31 Dec 1999 23:59:59 GMT`
  2. 초단위 표기법: `Retry-After: 120`
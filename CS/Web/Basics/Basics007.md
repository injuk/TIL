# Basics
## 2022-06-08 Wed

### HTTP 헤더란?
* HTTP 헤더는 HTTP 전송에 필요한 모든 부가 정보를 입력하기 위해 사용할 수 있다.
* HTTP 헤더는 수많은 표준 헤더가 존재하며, 필요시 임의의 사용자 정의 헤더를 추가할 수도 있다.

### 최신 스펙에서의 HTTP 본문
* 메시지 본문을 통해 표현 데이터를 전달하며, 이는 payload라는 용어로 지칭한다.
* 표현이란 요청 또는 응답에서 전달할 실제 데이터이며, 이 중 표현 헤더는 표현 데이터를 해석할 수 있는 정보를 제공한다.
  * 예를 들어 표현 헤더에는 데이터 유형 / 데이터 길이 / 압축 정보 등이 포함될 수 있다.
  * 이 때, **표현은 표현 데이터와 표현 헤더를 아우르는 용어**이다.

### 표현 헤더
* Content-Type은 표현 데이터의 형식을 나타내는 헤더이다.
* Content-Encoding은 표현 데이터의 압축 방식을 나타내는 헤더이다.
* Content-Language는 표현 데이터의 언어를 나타내는 헤더이다.
  * 예를 들어, 해당 헤더는 한국어 또는 영어 등을 포함할 수 있다.
* Content-Length는 표현 데이터의 길이를 나타내는 헤더이다.
  * 엄격하게 분류하는 경우 Content-Length는 표현과 관련이 없으므로, 페이로드 헤더로 볼 수 있다.
* **표현 헤더는 HTTP 요청과 응답 모두에서 사용**될 수 있다.

### Content-Type 헤더
* 해당 헤더는 표현 데이터의 형식을 설명하며, 미디어 타입 또는 문자 인코딩을 표현하기 위해 다음과 같은 값을 작성할 수 있다.
  1. text/html; charset=utf-8
  2. application/json
  3. image/png
* 이 때, application/json은 기본 인코딩이 utf-8로 적용된다.

### Content-Encoding 헤더
* 해당 헤더는 표현 데이터를 압축하기 위해 사용되며, 데이터를 전달하는 곳에서 압축한 후 해당 헤더를 추가한다.
  * 데이터를 읽는 측에서는 해당 헤더의 정보를 토대로 압축을 해제한다.
* 해당 헤더는 예를 들어, gzip / deflate / identity 등의 값을 포함할 수 있다.
  * 이 때, identity는 압축을 하지 않는 것을 의미한다.

### Content-Language 헤더
* 해당 헤더는 표현 데이터의 자연 언어를 명시하기 위해 사용되며, 예를 들어 다음과 같은 값을 포함할 수 있다.
  1. ko: 이 경우, **메시지 수신자는 메시지 본문에 한글이 들어가 있을 것을 예상**할 수 있다.
  2. en
  3. en-US
* 해당 헤더는 사용자의 언어와 Content-Language 헤더의 언어가 상이한 경우 번역된 페이지를 볼 것인지 선택하는 토스트를 띄우는 데에 활용할 수 있다.

### Content-Length 헤더
* 해당 헤더는 바이트 단위로 표현된 표현 데이터의 길이를 나타낸다.
* 이 때, Transfer-Encoding을 사용하는 경우 Content-Length 헤더를 사용하지 않아야 한다.
  * 이는 Transfer-Encoding을 사용하는 경우, 해당 헤더 안에 필요한 모든 정보가 포함되기 때문이다.

### 컨텐츠 협상
* **해당 분류는 HTTP 요청에서만 사용되며, 클라이언트가 선호하는 표현과 관련된 정보를 서버에게 알리기 위해 명시**한다.
  1. Accept: 클라이언트가 선호하는 미디어 타입을 명시한다.
  2. Accept-Charset: 클라이언트가 선호하는 문자 인코딩 방식을 명시한다.
  3. Accept-Encoding: 클라이언트가 선호하는 압축 인코딩 방식을 명시한다.
  4. Accept-Language: 클라이언트가 선호하는 자연어 종류를 명시한다.
* 서버는 해당 헤더의 정보를 확인하여 클라이언트가 원하는 방식으로 HTTP 응답을 작성할 수 있다.
  * 그러나 각 헤더에 분류된 타입을 서버가 제공할 수 없을 수도 있다.
  * 즉, 서버는 클라이언트의 요청에 최대한 맞춰주는 `Best Effort` 방식으로 동작한다.

### 컨텐츠 협상과 우선 순위 설정
* 컨텐츠 협상과 관련된 헤더에는 우선 순위인 `Quality Values`를 나타내는 변수 q를 사용할 수 있다.
  * q의 범위는 0 ~ 1이며, 큰 값일수록 높은 우선 순위를 갖는다.
  * 변수 q를 생략한 경우, 값은 1로 적용된다.
* 예를 들어 다음과 같은 헤더를 HTTP 요청에 작성할 수 있다.
```
GET /events HTTP/1.1
Accept-Language: ko-KR,ko;q=0.9,en-US;q=0.8,en;q=0.7

```
* 상술한 헤더의 경우, ko-KR / ko / en-US / en 순으로 우선 순위가 낮아진다.
  * 즉, ko-KR의 우선 순위가 가장 높다.
* 이러한 컨텐츠 협상 우선 순위의 경우, 다음과 같은 시나리오에서 유용하게 사용할 수 있다.
  1. 서버는 독일어와 영어를 지원하되, 기본 언어가 독일어이다.
  2. Accept-Language 헤더를 한국어 설정으로만 보낼 경우, 서버는 기본 언어인 독일어를 기반으로 데이터를 반환한다.
  3. 이 때, 최소한 영어로 작성된 데이터를 받기 위해 en 또는 en-US의 q 변수의 값을 할당할 수 있다.
     * 이 때, 굳이 독일어 설정을 헤더에 작성할 필요는 없다.
     * 서버는 우선 순위가 높은 언어부터 파악하며, 자신이 지원하는 언어를 확인한 시점에서 해당 언어로 반환한다.

### 구체적인 컨텐츠를 우선하기
* Accept 헤더의 경우, 와일드카드 기호인 `*`을 사용할 수 있다.
* 우선 순위 변수 q가 생략된 경우, **추상화된 데이터인 와일드카드를 작성한 값보다 구체적으로 작성된 값의 우선 순위가 더 높이 적용**된다.
* 예를 들어, 다음과 같은 HTTP 요청 메시지의 경우 우선 순위는 아래와 같다.
  1. text/plain;format=flowed
  2. text/plain
  3. text/*
  4. */*
```
GET /events HTTP/1.1
Accept: text/*,text/plain,text/plain;format=flowed,*/*

```

### 전송 방식
* 전송 방식은 크게 다음과 같이 분류할 수 있다.
  1. 단순 전송
  2. 압축 전송
  3. 분할 전송
  4. 범위 전송
* 단순 전송의 경우, 메시지 본문에 대한 Content-Length를 작성하여 HTTP 응답으로 반환한다.
  * 즉, 메시지 본문의 길이를 알 수 있는 경우에 해당한다.
* **압축 전송의 경우, 메시지 본문을 압축하며 Content-Encoding 헤더를 추가하여 HTTP 응답을 반환**해야 한다.
* 분할 전송의 경우, `Transfer-Encoding: chunked` 헤더를 HTTP 응답에 포함시켜 반환해야 한다.
  * **분할 전송은 Content-Length를 초기에 예상할 수 없으므로, 해당 헤더를 포함하지 않아야 한다**.
  * 또한 분할된 각 chunk에 byte 정보가 이미 포함되므로, 굳이 Content-Length 헤더를 명시할 필요도 없다. 
* 범위 전송의 경우, Range와 Content-Range 헤더를 활용할 수 있다.
  * 클라이언트는 `Range: bytes=1001-2000`과 같은 형식으로 요청하는 범위를 명시한다.
  * 서버는 `Content-Range: bytes 1001-2000 / 2000`과 같은 형식으로 반환되는 범위에 대한 정보를 포함시킨다.

### 일반적인 정보를 표현하는 헤더
* 일반적인 정보를 표현하는 헤더는 `From`, `Referer`, `User-Agent`, `Server`, `Date` 등이 존재한다.

### From 헤더
* `From` 헤더는 유저 에이전트의 이메일 정보를 명시하는 헤더이며, HTTP 요청에서 사용된다.
  * 일반적으로는 잘 사용되지 않으며, 주로 검색 엔진에서 사용하는 헤더이다.

### Referer 헤더
* **`Referer` 헤더는 현재 요청된 페이지의 이전 웹 페이지 주소를 명시하는 헤더이며, HTTP 요청에서 사용**된다.
  * **페이지 A에서 페이지 B로 이동한 경우, B의 페이지를 요청할 때 `Referer: A` 헤더를 포함하여 요청**하게 된다.
  * 해당 헤더를 통해 사용자가 유입된 경로를 분석할 수 있다.
  * 해당 헤더는 실무에서도 매우 많이 사용되는 헤더이다.

### User-Agent 헤더
* **`User-Agent` 헤더는 사용자의 에이전트 애플리케이션 정보를 나타내는 헤더이며, 주로 브라우저 정보를 명시**한다.
  * 해당 헤더 역시 HTTP 요청에서 사용되며, 주로 어떠한 종류의 브라우저에서 오류가 발생하는지 파악하는 데에 사용할 수 있다.
  * 클라이언트가 사용한 애플리케이션을 유저 에이전트라는 용어로도 지칭한다.

### Server 헤더
* `Server` 헤더는 요청을 처리하는 Origin 서버의 소프트웨어 정보를 명시하는 헤더이며, HTTP 응답에서 사용된다.
  * **Origin 서버란, 클라이언트의 HTTP 요청을 실제로 처리하여 표현 데이터를 생성해주는 서버**를 말한다.
  * 예를 들어, HTTP 요청이 전달되는 과정에서 수많은 프록시 또는 캐시 서버를 거칠 수 있다.
  * **Server 헤더는 이러한 중간 서버들을 모두 제외하고, 실제로 요청을 처리하는 서버에 대한 정보를 알려주기 위해 사용**된다.

### Date 헤더
* `Date` 헤더는 메시지가 발생한 날짜와 시간을 명시하며, HTTP 응답에서 사용된다.
  * **과거에는 HTTP 요청에서도 사용이 가능했으나, 최신 스펙에서는 HTTP 응답에서만 사용하도록 수정**되었다.

### 특수한 정보를 표현하는 헤더
* 특수한 정보를 표현하기 위해 사용되는 헤더는 `Host`, `Location`, `Allow`, `Retry-After` 등이 있다.

### Host 헤더
* **`Host` 헤더는 필수로 사용되는 헤더이며, HTTP 요청에서 사용**된다.
  * 필수 헤더는 거의 존재하지 않으나, 해당 헤더는 필수 헤더에 해당한다.
* **해당 헤더는 하나의 서버 또는 하나의 IP 주소에서 여러 도메인을 처리하는 경우하는 경우에 사용**된다. 
  * 이는 가상 호스트 개념을 통해 단일 서버에서 여러 도메인에 대한 요청을 처리하는 경우를 예시로 들 수 있다.
  * 이 경우, **`Host` 헤더를 사용하지 않는다면 서버는 사용자의 요청을 어떤 도메인에 대한 요청으로 받아들여야할지 판단할 수 없다**.

### Location 헤더
* `Location` 헤더는 페이지 리다이렉션에 사용되는 헤더이다.
* 예를 들어 **웹 브라우저는 3xx 번대 상태 코드를 갖는 HTTP 응답에 `Location` 헤더가 포함된 경우, 해당 위치로 자동으로 이동**한다.
* 해당 헤더는 HTTP 응답에 사용된 상태 코드에 따라 다음과 같은 의미를 갖는다.
  1. 201 Created: HTTP 요청에 의해 생성된 리소스의 URI를 의미한다.
  2. 3xx Redirection: **HTTP 요청을 자동으로 리다이렉트하기 위한 대상 리소스를 의미**한다.

### Allow 헤더
* `Allow` 헤더는 허용 가능한 HTTP 메소드를 명시하기 위해 사용되며, 405 Method Not Allowed를 반환하는 HTTP 응답에 포함해야 한다. 
* 예를 들어, `Allow: GET,HEAD,PUT`과 같은 형태로 작성될 수 있다.
  * 그러나 이는 실무에서 서버에 구현하는 경우가 드문 기능이며, `Allow` 헤더 역시 잘 사용되지 않는다.

### Retry-After 헤더
* `Retry-After` 헤더는 유저 에이전트가 다음 요청을 시도하기까지 대기해야하는 시간을 명시하기 위해 사용하는 헤더이다.
  * 예를 들어, HTTP 응답 코드가 503 Service Unavailable인 경우 서비스가 언제까지 불능할지 명시하기 위해 해당 헤더를 활용할 수 있다. 
* 해당 헤더는 다음과 같은 두 가지 방식으로 작성할 수 있다.
  1. 날짜 표기법: `Retry-After: Fri,31 Dec 1999 23:59:59 GMT`
  2. 초단위 표기법: `Retry-After: 120`
* 그러나 실제로는 서비스가 언제까지 불능할지 예측하기 어려우므로, 실무에서는 잘 사용되지 않는 헤더이다.

## 2022-06-09 Thu
### 인증과 관련된 정보를 표현하는 헤더
* 인증과 관련된 정보를 표현하는 헤더는 `Authorization`과 `WWW-Authenticate` 헤더가 존재한다.

### Authorization 헤더
* `Authorization` 헤더는 클라이언트의 인증 정보를 서버에게 전달하기 위해 사용하는 헤더이다.
  * 예를 들어, `Authorization: Basic xxxxx...` 의 형태로 작성할 수 있다.
  * **인증과 관련된 여러 메커니즘이 존재하며, 각각의 메커니즘 중 어떠한 것을 선택하느냐에 따라 `Authorization` 헤더에 포함되는 값이 달라진다**.
* 즉, **`Authorization` 헤더는 인증 메커니즘에 관계 없이 인증과 관련된 '값'의 명시만을 위해 존재하는 헤더**이다.

### WWW-Authenticate 헤더
* `WWW-Authenticate` 헤더는 리소스에 접근하는 경우에 필요한 인증 방법을 명시하기 위해 사용하는 헤더이다.
  * 때문에 **해당 헤더는 401 Unauthorized 상태 코드가 포함된 HTTP 응답과 함께 사용**된다.

### 쿠키와 관련된 헤더
* 쿠키와 관련된 헤더는 크게 다음의 두 종류로 나누어볼 수 있다.
1. `Set-Cookie`: HTTP 응답에서 사용되며, 서버에서 클라이언트로 쿠키를 전달한다.
2. `Cookie`: HTTP 요청에서 사용되며, 클라이언트가 서버로부터 받은 쿠키를 저장하고 요청 시마다 서버에 전달한다.

### 쿠키의 시작
* HTTP는 Stateless한 특징이 있는 무상태 프로토콜이다.
  * 때문에 **원칙적으로는 로그인을 성공적으로 수행하여 인증했더라도, 그 다음 번 요청에서 서버는 클라이언트가 인증된 사용자임을 구분할 방법이 없다**.
  * 이는 HTTP의 특징 상 클라이언트와 서버가 서로 상태를 유지하지 않는 특징에서 기인한다.
* 이러한 문제를 극복하기 위해 모든 요청에 사용자 정보를 포함시킬 수도 있으나, 모든 HTTP 요청과 URI에 사용자 정보를 포함하는 것은 무리가 있다.
* 쿠키는 현실적으로 이를 극복하기 위해 도입된 개념이며, 서버는 사용자의 인증 성공 시 `Set-Cookie` 헤더에 사용자의 쿠키를 담아 반환한다.
  * **웹 브라우저는 내부에 쿠키 저장소가 포함되어 있으며, 서버가 `Set-Cookie` 헤더를 통해 반환한 쿠키를 쿠키 저장소에 저장**해둔다.
  * **웹 브라우저는 이후의 동작에서 해당 서버에 접근할 때마다 쿠키 저장소를 확인하고, 관련된 쿠키를 `Cookie` 헤더에 명시하여 HTTP 요청을 송신**한다.
  * 서버는 `Cookie` 헤더를 확인하여 해당 사용자가 인증되었다는 사실을 인식할 수 있게 된다.
* 이렇듯 **쿠키는 웹 브라우저에 의해 해당 서버와 연관된 모든 요청에 자동으로 포함**된다.

### 쿠키란?
* 쿠키는 서버에 의해 다음과 같은 형태로 반환된다.
```
set-cookie: sessionId=helloworld; expires=Sat,26-Dec-2020 00:00:00 GMT; path=/; domain=.google.com; Secure
```
* 쿠키의 주 용도는 사용자의 로그인 세션을 관리하기 위해 사용된다.
  * **서버는 로그인에 성공한 경우 세션 키를 신규 생성하여 서버의 저장소에 저장하고, 이를 찾아낼 수 있는 세션 Id를 쿠키에 포함시켜 반환**한다.
  * 클라이언트는 이후의 요청에 세션 Id를 `Cookie` 헤더에 포함하고, 서버는 이를 확인하여 인증된 사용자인지 여부를 확인한다.
* 또는 광고 정보를 트래킹하는 데에도 자주 사용된다.
  * 예를 들어, 쿠키를 통해 해당 웹 브라우저를 사용하는 사용자가 주로 어떤 유형의 광고를 보는지 트래킹할 수 있다.
* 이러한 **쿠키 정보는 항상 서버에 전송되므로 네트워크 트래픽을 매번 추가로 유발시키는 한계 역시 존재**한다.
  * 때문에 세션 Id 또는 인증 토큰 정도의 최소한의 정보만을 포함하는 것이 바람직하다.
* 개발 과정에서는 임의의 정보를 쿠키처럼 웹 브라우저에 저장하되, 클라이언트가 유지하여 서버에 전송하고 싶지는 않은 데이터가 생길 수 있다. 
  * 이렇듯 **서버에 전송하지 않고 웹 브라우저 내부에 저장해두고 싶은 정보는 local storage 또는 session storage와 같은 웹 스토리지를 활용**한다.
  * 쿠키는 세팅하는 경우 무조건 서버에 보내는 HTTP 요청에 포함되므로, 웹 스토리지를 적절히 활용하는 것이 바람직하다.
* **사용자의 주민등록번호 또는 신용카드 번호와 같이, 보안에 민감한 데이터는 쿠키나 웹 스토리지에 절대 저장하지 않아야 한다**.

### 쿠키와 생명 주기
* 쿠키의 생명 주기에 활용할 수 있는 key로는 `expires`와 `max-age`가 있다.
* `expires`의 경우, 명시된 만료일에 쿠키를 삭제한다.
```
Set-Cookie: expires=Sat, 26-Dec-2020 00:00:00 GMT
```
* `max-age`의 경우, 초 단위로 명시된 값만큼 쿠키를 유지한다.
  * 예를 들어, 아래의 예시는 3600 초를 명시하였으므로 1 시간 동안만 쿠키가 유지된다.
  * **0 또는 음수를 지정하는 경우, 쿠키를 즉시 삭제**한다.
```
Set-Cookie: max-age=3600
```
* 쿠키는 만료 날짜의 생략 여부에 따라 다음과 같이 분류할 수 있다.
  1. **세션 쿠키: 만료 날짜가 생략된 쿠키이며, 브라우저 종료 시점까지만 유지**된다.
  2. **영속 쿠키: 만료 날짜가 명시된 쿠키이며, 브라우저 종료와 관계 없이 명시된 만료일까지 유지**된다.

### 쿠키와 도메인
* 쿠키에는 도메인 정보가 포함될 수 있으며, 도메인의 명시 여부에 따라 다음과 같이 동작한다.
* **도메인을 쿠키에 명시한 경우, 명시한 도메인과 서브 도메인 모두에 대해 쿠키를 사용**한다.
  * 예를 들어 `domain=example.org`를 지정한 경우, example.org와 ~~~.example.org 모든 도메인에 접근할 때 해당 쿠키를 함께 전송한다.
  * 이렇듯 쿠키를 전송하는 행위를 '쿠키에 접근한다'는 용어로도 표현할 수 있다.
* **도메인을 쿠키에서 생략한 경우, 현재 접속 중인 문서를 기준으로 한 도메인에서만 적용**된다.
  * example.org 도메인에서 쿠키를 생성한 경우, example.org 이외의 도메인에서는 쿠키에 접근할 수 없다.

### 쿠키와 경로
* **쿠키에는 `path=/path` 형태의 경로 정보를 포함할 수 있으며, 해당 경로를 포함하는 하위 경로에서만 쿠키에 접근**할 수 있다.
  * 때문에 일반적으로는 `path=/` 형태로 지정하여 하위의 모든 경로에서 쿠키에 접근할 수 있도록 한다.
  * 일반적으로 루트 경로를 지정하는 이유는, 대부분의 경우 하나의 도메인 내부 전체에서 쿠키를 전송하기를 원하기 때문이다.

### 쿠키와 보안
* 쿠키에는 `Secure`, `HttpOnly`, `SameSite` 가 포함될 수 있다.
* `Secure`가 쿠키에 명시된 경우, 쿠키는 https 접속인 경우에만 전송된다.
  * **일반적으로 쿠키는 http와 https를 구분하지 않고 전송**된다.
* `HttpOnly`는 XSS 공격을 방지하기 위해 사용되는 쿠키이다.
  * 해당 쿠키는 document.cookie와 같은 명령어를 활용한 JS의 접근이 불가능하며, 오직 http 전송에서만 사용된다.
* `SameSite`는 XSRF 공격을 방지하기 위해 사용되는 쿠키이며, 요청 도메인과 쿠키에 설정된 도메인이 같은 경우에만 쿠키를 전송한다.
  * 해당 속성은 기능이 적용된 것이 오래되지 않았으므로, 사용시 브라우저의 지원 정도를 파악하고 적용해야 한다.

### 캐시의 기본 동작
* 클라이언트가 서버에 큰 이미지 파일을 요청하면 HTTP 응답에는 HTTP 헤더 정보와 바이트 코드로 변환된 이미지가 포함된다.
  * 즉, HTTP 응답에는 커다란 이미지가 포함된 상태이다.
* 캐시가 없는 경우, HTTP 응답에는 항상 상술한 HTTP 헤더 정보와 큰 이미지가 포함된다.
  * 때문에 데이터가 변경되지 않더라도 계속해서 네트워크를 통해 데이터를 다운로드 받아야 한다.
  * 인터넷 네트워크는 IO 이벤트이므로 비용이 비싼 작업이며, 사용자 경험은 느려진다.
* 캐시를 적용하는 경우, 서버가 `Cache-Control: max-age=60`과 같은 형태로 캐시와 관련된 헤더를 설정하여 HTTP 응답을 설정한다.
  * **최초의 요청에는 여전히 큰 이미지가 HTTP 응답에 포함되지만, 이 이미지는 웹 브라우저에 내장된 캐시 저장소에 저장**된다.
  * 이렇게 캐시에 저장된 이미지는 `max-age=60`에 의해 60초간 유지된다.
* 이제 **`GET /image.png HTTP/1.1`과 같이 동일한 요청이 발생한 경우, 웹 브라우저는 우선 캐시에서 이미지를 해당 검색**한다.
  * 캐시에 유효한 이미지가 존재하는 경우, 네트워크를 타지 않고 캐시의 이미지를 재사용한다.
  * 이를 토대로 캐시 가능 시간 동안 비싼 작업인 네트워크 IO를 수행할 필요가 없으며, 브라우저의 로딩 속도가 빨라져 사용자 경험은 향상된다.
* 캐시를 적용하였으나 캐시된 이미지의 캐시 유효 시간이 만료된 경우, 최초의 이미지 요청과 동일한 흐름으로 동작한다.
  * 이렇게 다시 받아온 이미지를 캐시 저장소의 기존 이미지를 덮어 씌우는 식으로 동작하게 된다.
  * 이렇듯 캐시 유효 시간이 초과된 경우, 서버를 통해 데이터를 다시 조회하고 캐시를 갱신하는 과정에서 네트워크 다운로드 작업이 발생한다.

### 캐시 검증 헤더
* 캐시의 유효 시간이 만료된 경우, 서버의 원본 이미지는 다음과 같은 두 상태 중 하나를 갖는다.
  1. 서버의 기존 데이터가 변경된 경우
  2. 서버의 기존 데이터가 변경되지 않은 경우
* 서버의 기존 데이터가 변경된 경우에는 당연히 다시 다운로드 받아야하지만, 기존 데이터가 변경되지 않은 경우 큰 이미지를 다시 다운로드 받는 것은 낭비가 된다.
* **캐시 검증 헤더는 이러한 상황에 활용할 수 있으며, 서버의 원본 데이터가 아직 변경되지 않아 클라이언트가 사전에 다운로드한 이미지가 최신임을 보장**한다.
  * 캐시 검증 헤더는 `Last-Modified: Fri, 27 Sep 2019 01:00:00 GMT`의 형태를 띈다.
* 클라이언트가 서버에 최초로 이미지를 요청한 시점에서, 서버는 HTTP 응답의 헤더에 `Cache-Control`과 `Last-Modified` 헤더를 포함시켜 반환한다.
* **웹 브라우저는 이미지 다운로드가 완료된 후 응답 결과를 캐시에 저장하고, 데이터의 유효 기간과 최종 수정일 역시 함께 저장**한다.
  * 유효 기간과 최종 수정일은 각각 `Cache-Control`과 `Last-Modified` 헤더의 값을 기반으로 설정된다.
* **캐시의 만료 시간이 지난 경우, 서버에 동일한 이미지를 요청할 때 웹 브라우저는 `if-modified-since` 헤더에 최종 수정일 정보를 함께 전달**한다.
  * 이는 캐시에 있는 이미지에 최종 수정일이 설정된 경우, 웹 브라우저에 의해 자동으로 적용된다.
  * 이 때, `if-modified-since` 헤더의 값은 최초 요청시 `Last-Modified`에 정의된 값과 같다.
* 사용자의 HTTP 요청에 `if-modified-since` 헤더가 포함된 경우, 서버는 이 값을 토대로 자신이 갖고 있는 이미지와 비교 검증할 수 있게 된다.
* 클라이언트가 요청한 이미지가 아직 수정되지 않은 것이 검증된 경우, 서버는 다음과 같은 형태의 HTTP 응답을 반환한다.
  * 응답 상태 코드는 304 Not Modified를 적용한다.
  * `Cache-Control`과 `Last-Modified`는 그대로 설정한다.
  * **HTTP 메시지 본문은 비워둔다**.
```
HTTP/1.1 304 Not Modified
Content-Type: image/png
Cache-Control: max-age=60
Last-Modified: Fri, 27 Sep 2019 01:00:00 GMT
Content-Length: 12345

// HTTP 메시지 본문은 생략된다!
```
* **클라이언트는 이러한 메시지를 통해 캐시된 이미지가 최신임을 인식하게 되며, 캐시 저장소의 캐시 만료 기간을 갱신**한다.
  * 이후 갱신된 캐시의 이미지를 재사용한다.

### 캐시 검증 헤더와 조건부 요청의 혼용
* **`Last-Modified`는 검증 헤더이며, `if-modified-since`는 조건부 요청 헤더에 해당**한다.
  * **두 헤더를 조합하여 캐싱된 이미지가 최신인지 확인할 수 있으며, 불필요한 네트워크 트래픽을 줄이고 브라우저의 캐시를 재사용**할 수 있다.
* 이를 통해 캐시의 유효 기간이 만료되었더라도 서버의 데이터가 갱신되었는지의 여부에 따라 효율적인 동작을 취할 수 있게 되며, 다음과 같은 이점을 얻을 수 있다.
  1. 서버는 304 Not Modified와 헤더 메타 정보만을 응답하며, 메시지 본문을 포함하지 않으므로 불필요한 네트워크 트래픽을 사용하지 않는다.
  2. **클라이언트는 서버가 반환한 HTTP 응답의 헤더 정보를 토대로 캐시의 메타데이터를 갱신**한다.
  3. 이를 통해 클라이언트는 캐시에 저장된 데이터를 재활용할 수 있게 된다.
* **이러한 방식은 네트워크 요청이 발생하긴 하지만, 이상적인 경우 용량이 적은 HTTP 헤더 정보만을 다운로드하게 되므로 매우 실용적인 방식**이다.
  * 때문에 대부분의 웹 브라우저는 해당 방법을 적극적으로 도입하여 구현해두었다.
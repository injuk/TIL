# Basics
## 2022-06-08 Wed

### HTTP 헤더란?
* HTTP 헤더는 HTTP 전송에 필요한 모든 부가 정보를 입력하기 위해 사용할 수 있다.
* HTTP 헤더는 수많은 표준 헤더가 존재하며, 필요시 임의의 사용자 정의 헤더를 추가할 수도 있다.

### 최신 스펙에서의 HTTP 본문
* 메시지 본문을 통해 표현 데이터를 전달하며, 이는 payload라는 용어로 지칭한다.
* 표현이란 요청 또는 응답에서 전달할 실제 데이터이며, 이 중 표현 헤더는 표현 데이터를 해석할 수 있는 정보를 제공한다.
  * 예를 들어 표현 헤더에는 데이터 유형 / 데이터 길이 / 압축 정보 등이 포함될 수 있다.
  * 이 때, **표현은 표현 데이터와 표현 헤더를 아우르는 용어**이다.

### 표현 헤더
* Content-Type은 표현 데이터의 형식을 나타내는 헤더이다.
* Content-Encoding은 표현 데이터의 압축 방식을 나타내는 헤더이다.
* Content-Language는 표현 데이터의 언어를 나타내는 헤더이다.
  * 예를 들어, 해당 헤더는 한국어 또는 영어 등을 포함할 수 있다.
* Content-Length는 표현 데이터의 길이를 나타내는 헤더이다.
  * 엄격하게 분류하는 경우 Content-Length는 표현과 관련이 없으므로, 페이로드 헤더로 볼 수 있다.
* **표현 헤더는 HTTP 요청과 응답 모두에서 사용**될 수 있다.

### Content-Type 헤더
* 해당 헤더는 표현 데이터의 형식을 설명하며, 미디어 타입 또는 문자 인코딩을 표현하기 위해 다음과 같은 값을 작성할 수 있다.
  1. text/html; charset=utf-8
  2. application/json
  3. image/png
* 이 때, application/json은 기본 인코딩이 utf-8로 적용된다.

### Content-Encoding 헤더
* 해당 헤더는 표현 데이터를 압축하기 위해 사용되며, 데이터를 전달하는 곳에서 압축한 후 해당 헤더를 추가한다.
  * 데이터를 읽는 측에서는 해당 헤더의 정보를 토대로 압축을 해제한다.
* 해당 헤더는 예를 들어, gzip / deflate / identity 등의 값을 포함할 수 있다.
  * 이 때, identity는 압축을 하지 않는 것을 의미한다.

### Content-Language 헤더
* 해당 헤더는 표현 데이터의 자연 언어를 명시하기 위해 사용되며, 예를 들어 다음과 같은 값을 포함할 수 있다.
  1. ko: 이 경우, **메시지 수신자는 메시지 본문에 한글이 들어가 있을 것을 예상**할 수 있다.
  2. en
  3. en-US
* 해당 헤더는 사용자의 언어와 Content-Language 헤더의 언어가 상이한 경우 번역된 페이지를 볼 것인지 선택하는 토스트를 띄우는 데에 활용할 수 있다.

### Content-Length 헤더
* 해당 헤더는 바이트 단위로 표현된 표현 데이터의 길이를 나타낸다.
* 이 때, Transfer-Encoding을 사용하는 경우 Content-Length 헤더를 사용하지 않아야 한다.
  * 이는 Transfer-Encoding을 사용하는 경우, 해당 헤더 안에 필요한 모든 정보가 포함되기 때문이다.

### 컨텐츠 협상
* **해당 분류는 HTTP 요청에서만 사용되며, 클라이언트가 선호하는 표현과 관련된 정보를 서버에게 알리기 위해 명시**한다.
  1. Accept: 클라이언트가 선호하는 미디어 타입을 명시한다.
  2. Accept-Charset: 클라이언트가 선호하는 문자 인코딩 방식을 명시한다.
  3. Accept-Encoding: 클라이언트가 선호하는 압축 인코딩 방식을 명시한다.
  4. Accept-Language: 클라이언트가 선호하는 자연어 종류를 명시한다.
* 서버는 해당 헤더의 정보를 확인하여 클라이언트가 원하는 방식으로 HTTP 응답을 작성할 수 있다.
  * 그러나 각 헤더에 분류된 타입을 서버가 제공할 수 없을 수도 있다.
  * 즉, 서버는 클라이언트의 요청에 최대한 맞춰주는 `Best Effort` 방식으로 동작한다.

### 컨텐츠 협상과 우선 순위 설정
* 컨텐츠 협상과 관련된 헤더에는 우선 순위인 `Quality Values`를 나타내는 변수 q를 사용할 수 있다.
  * q의 범위는 0 ~ 1이며, 큰 값일수록 높은 우선 순위를 갖는다.
  * 변수 q를 생략한 경우, 값은 1로 적용된다.
* 예를 들어 다음과 같은 헤더를 HTTP 요청에 작성할 수 있다.
```
GET /events HTTP/1.1
Accept-Language: ko-KR,ko;q=0.9,en-US;q=0.8,en;q=0.7

```
* 상술한 헤더의 경우, ko-KR / ko / en-US / en 순으로 우선 순위가 낮아진다.
  * 즉, ko-KR의 우선 순위가 가장 높다.
* 이러한 컨텐츠 협상 우선 순위의 경우, 다음과 같은 시나리오에서 유용하게 사용할 수 있다.
  1. 서버는 독일어와 영어를 지원하되, 기본 언어가 독일어이다.
  2. Accept-Language 헤더를 한국어 설정으로만 보낼 경우, 서버는 기본 언어인 독일어를 기반으로 데이터를 반환한다.
  3. 이 때, 최소한 영어로 작성된 데이터를 받기 위해 en 또는 en-US의 q 변수의 값을 할당할 수 있다.
     * 이 때, 굳이 독일어 설정을 헤더에 작성할 필요는 없다.
     * 서버는 우선 순위가 높은 언어부터 파악하며, 자신이 지원하는 언어를 확인한 시점에서 해당 언어로 반환한다.

### 구체적인 컨텐츠를 우선하기
* Accept 헤더의 경우, 와일드카드 기호인 `*`을 사용할 수 있다.
* 우선 순위 변수 q가 생략된 경우, **추상화된 데이터인 와일드카드를 작성한 값보다 구체적으로 작성된 값의 우선 순위가 더 높이 적용**된다.
* 예를 들어, 다음과 같은 HTTP 요청 메시지의 경우 우선 순위는 아래와 같다.
  1. text/plain;format=flowed
  2. text/plain
  3. text/*
  4. */*
```
GET /events HTTP/1.1
Accept: text/*,text/plain,text/plain;format=flowed,*/*

```

### 전송 방식
* 전송 방식은 크게 다음과 같이 분류할 수 있다.
  1. 단순 전송
  2. 압축 전송
  3. 분할 전송
  4. 범위 전송
* 단순 전송의 경우, 메시지 본문에 대한 Content-Length를 작성하여 HTTP 응답으로 반환한다.
  * 즉, 메시지 본문의 길이를 알 수 있는 경우에 해당한다.
* **압축 전송의 경우, 메시지 본문을 압축하며 Content-Encoding 헤더를 추가하여 HTTP 응답을 반환**해야 한다.
* 분할 전송의 경우, `Transfer-Encoding: chunked` 헤더를 HTTP 응답에 포함시켜 반환해야 한다.
  * **분할 전송은 Content-Length를 초기에 예상할 수 없으므로, 해당 헤더를 포함하지 않아야 한다**.
  * 또한 분할된 각 chunk에 byte 정보가 이미 포함되므로, 굳이 Content-Length 헤더를 명시할 필요도 없다. 
* 범위 전송의 경우, Range와 Content-Range 헤더를 활용할 수 있다.
  * 클라이언트는 `Range: bytes=1001-2000`과 같은 형식으로 요청하는 범위를 명시한다.
  * 서버는 `Content-Range: bytes 1001-2000 / 2000`과 같은 형식으로 반환되는 범위에 대한 정보를 포함시킨다.

### 일반적인 정보를 표현하는 헤더
* 일반적인 정보를 표현하는 헤더는 `From`, `Referer`, `User-Agent`, `Server`, `Date` 등이 존재한다.

### From 헤더
* `From` 헤더는 유저 에이전트의 이메일 정보를 명시하는 헤더이며, HTTP 요청에서 사용된다.
  * 일반적으로는 잘 사용되지 않으며, 주로 검색 엔진에서 사용하는 헤더이다.

### Referer 헤더
* **`Referer` 헤더는 현재 요청된 페이지의 이전 웹 페이지 주소를 명시하는 헤더이며, HTTP 요청에서 사용**된다.
  * **페이지 A에서 페이지 B로 이동한 경우, B의 페이지를 요청할 때 `Referer: A` 헤더를 포함하여 요청**하게 된다.
  * 해당 헤더를 통해 사용자가 유입된 경로를 분석할 수 있다.
  * 해당 헤더는 실무에서도 매우 많이 사용되는 헤더이다.

### User-Agent 헤더
* **`User-Agent` 헤더는 사용자의 에이전트 애플리케이션 정보를 나타내는 헤더이며, 주로 브라우저 정보를 명시**한다.
  * 해당 헤더 역시 HTTP 요청에서 사용되며, 주로 어떠한 종류의 브라우저에서 오류가 발생하는지 파악하는 데에 사용할 수 있다.
  * 클라이언트가 사용한 애플리케이션을 유저 에이전트라는 용어로도 지칭한다.

### Server 헤더
* `Server` 헤더는 요청을 처리하는 Origin 서버의 소프트웨어 정보를 명시하는 헤더이며, HTTP 응답에서 사용된다.
  * **Origin 서버란, 클라이언트의 HTTP 요청을 실제로 처리하여 표현 데이터를 생성해주는 서버**를 말한다.
  * 예를 들어, HTTP 요청이 전달되는 과정에서 수많은 프록시 또는 캐시 서버를 거칠 수 있다.
  * **Server 헤더는 이러한 중간 서버들을 모두 제외하고, 실제로 요청을 처리하는 서버에 대한 정보를 알려주기 위해 사용**된다.

### Date 헤더
* `Date` 헤더는 메시지가 발생한 날짜와 시간을 명시하며, HTTP 응답에서 사용된다.
  * **과거에는 HTTP 요청에서도 사용이 가능했으나, 최신 스펙에서는 HTTP 응답에서만 사용하도록 수정**되었다.

### 특수한 정보를 표현하는 헤더
* 특수한 정보를 표현하기 위해 사용되는 헤더는 `Host`, `Location`, `Allow`, `Retry-After` 등이 있다.

### Host 헤더
* **`Host` 헤더는 필수로 사용되는 헤더이며, HTTP 요청에서 사용**된다.
  * 필수 헤더는 거의 존재하지 않으나, 해당 헤더는 필수 헤더에 해당한다.
* **해당 헤더는 하나의 서버 또는 하나의 IP 주소에서 여러 도메인을 처리하는 경우하는 경우에 사용**된다. 
  * 이는 가상 호스트 개념을 통해 단일 서버에서 여러 도메인에 대한 요청을 처리하는 경우를 예시로 들 수 있다.
  * 이 경우, **`Host` 헤더를 사용하지 않는다면 서버는 사용자의 요청을 어떤 도메인에 대한 요청으로 받아들여야할지 판단할 수 없다**.

### Location 헤더
* `Location` 헤더는 페이지 리다이렉션에 사용되는 헤더이다.
* 예를 들어 **웹 브라우저는 3xx 번대 상태 코드를 갖는 HTTP 응답에 `Location` 헤더가 포함된 경우, 해당 위치로 자동으로 이동**한다.
* 해당 헤더는 HTTP 응답에 사용된 상태 코드에 따라 다음과 같은 의미를 갖는다.
  1. 201 Created: HTTP 요청에 의해 생성된 리소스의 URI를 의미한다.
  2. 3xx Redirection: **HTTP 요청을 자동으로 리다이렉트하기 위한 대상 리소스를 의미**한다.

### Allow 헤더
* `Allow` 헤더는 허용 가능한 HTTP 메소드를 명시하기 위해 사용되며, 405 Method Not Allowed를 반환하는 HTTP 응답에 포함해야 한다. 
* 예를 들어, `Allow: GET,HEAD,PUT`과 같은 형태로 작성될 수 있다.
  * 그러나 이는 실무에서 서버에 구현하는 경우가 드문 기능이며, `Allow` 헤더 역시 잘 사용되지 않는다.

### Retry-After 헤더
* `Retry-After` 헤더는 유저 에이전트가 다음 요청을 시도하기까지 대기해야하는 시간을 명시하기 위해 사용하는 헤더이다.
  * 예를 들어, HTTP 응답 코드가 503 Service Unavailable인 경우 서비스가 언제까지 불능할지 명시하기 위해 해당 헤더를 활용할 수 있다. 
* 해당 헤더는 다음과 같은 두 가지 방식으로 작성할 수 있다.
  1. 날짜 표기법: `Retry-After: Fri,31 Dec 1999 23:59:59 GMT`
  2. 초단위 표기법: `Retry-After: 120`
* 그러나 실제로는 서비스가 언제까지 불능할지 예측하기 어려우므로, 실무에서는 잘 사용되지 않는 헤더이다.

## 2022-06-09 Thu
### 인증과 관련된 정보를 표현하는 헤더
* 인증과 관련된 정보를 표현하는 헤더는 `Authorization`과 `WWW-Authenticate` 헤더가 존재한다.

### Authorization 헤더
* `Authorization` 헤더는 클라이언트의 인증 정보를 서버에게 전달하기 위해 사용하는 헤더이다.
  * 예를 들어, `Authorization: Basic xxxxx...` 의 형태로 작성할 수 있다.
  * **인증과 관련된 여러 메커니즘이 존재하며, 각각의 메커니즘 중 어떠한 것을 선택하느냐에 따라 `Authorization` 헤더에 포함되는 값이 달라진다**.
* 즉, **`Authorization` 헤더는 인증 메커니즘에 관계 없이 인증과 관련된 '값'의 명시만을 위해 존재하는 헤더**이다.

### WWW-Authenticate 헤더
* `WWW-Authenticate` 헤더는 리소스에 접근하는 경우에 필요한 인증 방법을 명시하기 위해 사용하는 헤더이다.
  * 때문에 **해당 헤더는 401 Unauthorized 상태 코드가 포함된 HTTP 응답과 함께 사용**된다.

### 쿠키와 관련된 헤더
* 쿠키와 관련된 헤더는 크게 다음의 두 종류로 나누어볼 수 있다.
1. `Set-Cookie`: HTTP 응답에서 사용되며, 서버에서 클라이언트로 쿠키를 전달한다.
2. `Cookie`: HTTP 요청에서 사용되며, 클라이언트가 서버로부터 받은 쿠키를 저장하고 요청 시마다 서버에 전달한다.

### 쿠키의 시작
* HTTP는 Stateless한 특징이 있는 무상태 프로토콜이다.
  * 때문에 **원칙적으로는 로그인을 성공적으로 수행하여 인증했더라도, 그 다음 번 요청에서 서버는 클라이언트가 인증된 사용자임을 구분할 방법이 없다**.
  * 이는 HTTP의 특징 상 클라이언트와 서버가 서로 상태를 유지하지 않는 특징에서 기인한다.
* 이러한 문제를 극복하기 위해 모든 요청에 사용자 정보를 포함시킬 수도 있으나, 모든 HTTP 요청과 URI에 사용자 정보를 포함하는 것은 무리가 있다.
* 쿠키는 현실적으로 이를 극복하기 위해 도입된 개념이며, 서버는 사용자의 인증 성공 시 `Set-Cookie` 헤더에 사용자의 쿠키를 담아 반환한다.
  * **웹 브라우저는 내부에 쿠키 저장소가 포함되어 있으며, 서버가 `Set-Cookie` 헤더를 통해 반환한 쿠키를 쿠키 저장소에 저장**해둔다.
  * **웹 브라우저는 이후의 동작에서 해당 서버에 접근할 때마다 쿠키 저장소를 확인하고, 관련된 쿠키를 `Cookie` 헤더에 명시하여 HTTP 요청을 송신**한다.
  * 서버는 `Cookie` 헤더를 확인하여 해당 사용자가 인증되었다는 사실을 인식할 수 있게 된다.
* 이렇듯 **쿠키는 웹 브라우저에 의해 해당 서버와 연관된 모든 요청에 자동으로 포함**된다.

### 쿠키란?
* 쿠키는 서버에 의해 다음과 같은 형태로 반환된다.
```
set-cookie: sessionId=helloworld; expires=Sat,26-Dec-2020 00:00:00 GMT; path=/; domain=.google.com; Secure
```
* 쿠키의 주 용도는 사용자의 로그인 세션을 관리하기 위해 사용된다.
  * **서버는 로그인에 성공한 경우 세션 키를 신규 생성하여 서버의 저장소에 저장하고, 이를 찾아낼 수 있는 세션 Id를 쿠키에 포함시켜 반환**한다.
  * 클라이언트는 이후의 요청에 세션 Id를 `Cookie` 헤더에 포함하고, 서버는 이를 확인하여 인증된 사용자인지 여부를 확인한다.
* 또는 광고 정보를 트래킹하는 데에도 자주 사용된다.
  * 예를 들어, 쿠키를 통해 해당 웹 브라우저를 사용하는 사용자가 주로 어떤 유형의 광고를 보는지 트래킹할 수 있다.
* 이러한 **쿠키 정보는 항상 서버에 전송되므로 네트워크 트래픽을 매번 추가로 유발시키는 한계 역시 존재**한다.
  * 때문에 세션 Id 또는 인증 토큰 정도의 최소한의 정보만을 포함하는 것이 바람직하다.
* 개발 과정에서는 임의의 정보를 쿠키처럼 웹 브라우저에 저장하되, 클라이언트가 유지하여 서버에 전송하고 싶지는 않은 데이터가 생길 수 있다. 
  * 이렇듯 **서버에 전송하지 않고 웹 브라우저 내부에 저장해두고 싶은 정보는 local storage 또는 session storage와 같은 웹 스토리지를 활용**한다.
  * 쿠키는 세팅하는 경우 무조건 서버에 보내는 HTTP 요청에 포함되므로, 웹 스토리지를 적절히 활용하는 것이 바람직하다.
* **사용자의 주민등록번호 또는 신용카드 번호와 같이, 보안에 민감한 데이터는 쿠키나 웹 스토리지에 절대 저장하지 않아야 한다**.

### 쿠키와 생명 주기
* 쿠키의 생명 주기에 활용할 수 있는 key로는 `expires`와 `max-age`가 있다.
* `expires`의 경우, 명시된 만료일에 쿠키를 삭제한다.
```
Set-Cookie: expires=Sat, 26-Dec-2020 00:00:00 GMT
```
* `max-age`의 경우, 초 단위로 명시된 값만큼 쿠키를 유지한다.
  * 예를 들어, 아래의 예시는 3600 초를 명시하였으므로 1 시간 동안만 쿠키가 유지된다.
  * **0 또는 음수를 지정하는 경우, 쿠키를 즉시 삭제**한다.
```
Set-Cookie: max-age=3600
```
* 쿠키는 만료 날짜의 생략 여부에 따라 다음과 같이 분류할 수 있다.
  1. **세션 쿠키: 만료 날짜가 생략된 쿠키이며, 브라우저 종료 시점까지만 유지**된다.
  2. **영속 쿠키: 만료 날짜가 명시된 쿠키이며, 브라우저 종료와 관계 없이 명시된 만료일까지 유지**된다.

### 쿠키와 도메인
* 쿠키에는 도메인 정보가 포함될 수 있으며, 도메인의 명시 여부에 따라 다음과 같이 동작한다.
* **도메인을 쿠키에 명시한 경우, 명시한 도메인과 서브 도메인 모두에 대해 쿠키를 사용**한다.
  * 예를 들어 `domain=example.org`를 지정한 경우, example.org와 ~~~.example.org 모든 도메인에 접근할 때 해당 쿠키를 함께 전송한다.
  * 이렇듯 쿠키를 전송하는 행위를 '쿠키에 접근한다'는 용어로도 표현할 수 있다.
* **도메인을 쿠키에서 생략한 경우, 현재 접속 중인 문서를 기준으로 한 도메인에서만 적용**된다.
  * example.org 도메인에서 쿠키를 생성한 경우, example.org 이외의 도메인에서는 쿠키에 접근할 수 없다.

### 쿠키와 경로
* **쿠키에는 `path=/path` 형태의 경로 정보를 포함할 수 있으며, 해당 경로를 포함하는 하위 경로에서만 쿠키에 접근**할 수 있다.
  * 때문에 일반적으로는 `path=/` 형태로 지정하여 하위의 모든 경로에서 쿠키에 접근할 수 있도록 한다.
  * 일반적으로 루트 경로를 지정하는 이유는, 대부분의 경우 하나의 도메인 내부 전체에서 쿠키를 전송하기를 원하기 때문이다.

### 쿠키와 보안
* 쿠키에는 `Secure`, `HttpOnly`, `SameSite` 가 포함될 수 있다.
* `Secure`가 쿠키에 명시된 경우, 쿠키는 https 접속인 경우에만 전송된다.
  * **일반적으로 쿠키는 http와 https를 구분하지 않고 전송**된다.
* `HttpOnly`는 XSS 공격을 방지하기 위해 사용되는 쿠키이다.
  * 해당 쿠키는 document.cookie와 같은 명령어를 활용한 JS의 접근이 불가능하며, 오직 http 전송에서만 사용된다.
* `SameSite`는 XSRF 공격을 방지하기 위해 사용되는 쿠키이며, 요청 도메인과 쿠키에 설정된 도메인이 같은 경우에만 쿠키를 전송한다.
  * 해당 속성은 기능이 적용된 것이 오래되지 않았으므로, 사용시 브라우저의 지원 정도를 파악하고 적용해야 한다.
# Basics
## 2022-06-09 Thu

### 캐시의 기본 동작
* 클라이언트가 서버에 큰 이미지 파일을 요청하면 HTTP 응답에는 HTTP 헤더 정보와 바이트 코드로 변환된 이미지가 포함된다.
    * 즉, HTTP 응답에는 커다란 이미지가 포함된 상태이다.
* 캐시가 없는 경우, HTTP 응답에는 항상 상술한 HTTP 헤더 정보와 큰 이미지가 포함된다.
    * 때문에 데이터가 변경되지 않더라도 계속해서 네트워크를 통해 데이터를 다운로드 받아야 한다.
    * 인터넷 네트워크는 IO 이벤트이므로 비용이 비싼 작업이며, 사용자 경험은 느려진다.
* 캐시를 적용하는 경우, 서버가 `Cache-Control: max-age=60`과 같은 형태로 캐시와 관련된 헤더를 설정하여 HTTP 응답을 설정한다.
    * **최초의 요청에는 여전히 큰 이미지가 HTTP 응답에 포함되지만, 이 이미지는 웹 브라우저에 내장된 캐시 저장소에 저장**된다.
    * 이렇게 캐시에 저장된 이미지는 `max-age=60`에 의해 60초간 유지된다.
* 이제 **`GET /image.png HTTP/1.1`과 같이 동일한 요청이 발생한 경우, 웹 브라우저는 우선 캐시에서 이미지를 해당 검색**한다.
    * 캐시에 유효한 이미지가 존재하는 경우, 네트워크를 타지 않고 캐시의 이미지를 재사용한다.
    * 이를 토대로 캐시 가능 시간 동안 비싼 작업인 네트워크 IO를 수행할 필요가 없으며, 브라우저의 로딩 속도가 빨라져 사용자 경험은 향상된다.
* 캐시를 적용하였으나 캐시된 이미지의 캐시 유효 시간이 만료된 경우, 최초의 이미지 요청과 동일한 흐름으로 동작한다.
    * 이렇게 다시 받아온 이미지를 캐시 저장소의 기존 이미지를 덮어 씌우는 식으로 동작하게 된다.
    * 이렇듯 캐시 유효 시간이 초과된 경우, 서버를 통해 데이터를 다시 조회하고 캐시를 갱신하는 과정에서 네트워크 다운로드 작업이 발생한다.

### 캐시 검증 헤더
* 캐시의 유효 시간이 만료된 경우, 서버의 원본 이미지는 다음과 같은 두 상태 중 하나를 갖는다.
    1. 서버의 기존 데이터가 변경된 경우
    2. 서버의 기존 데이터가 변경되지 않은 경우
* 서버의 기존 데이터가 변경된 경우에는 당연히 다시 다운로드 받아야하지만, 기존 데이터가 변경되지 않은 경우 큰 이미지를 다시 다운로드 받는 것은 낭비가 된다.
* **캐시 검증 헤더는 이러한 상황에 활용할 수 있으며, 서버의 원본 데이터가 아직 변경되지 않아 클라이언트가 사전에 다운로드한 이미지가 최신임을 보장**한다.
    * 캐시 검증 헤더는 `Last-Modified: Fri, 27 Sep 2019 01:00:00 GMT`의 형태를 띈다.
* 클라이언트가 서버에 최초로 이미지를 요청한 시점에서, 서버는 HTTP 응답의 헤더에 `Cache-Control`과 `Last-Modified` 헤더를 포함시켜 반환한다.
* **웹 브라우저는 이미지 다운로드가 완료된 후 응답 결과를 캐시에 저장하고, 데이터의 유효 기간과 최종 수정일 역시 함께 저장**한다.
    * 유효 기간과 최종 수정일은 각각 `Cache-Control`과 `Last-Modified` 헤더의 값을 기반으로 설정된다.
* **캐시의 만료 시간이 지난 경우, 서버에 동일한 이미지를 요청할 때 웹 브라우저는 `if-modified-since` 헤더에 최종 수정일 정보를 함께 전달**한다.
    * 이는 캐시에 있는 이미지에 최종 수정일이 설정된 경우, 웹 브라우저에 의해 자동으로 적용된다.
    * 이 때, `if-modified-since` 헤더의 값은 최초 요청시 `Last-Modified`에 정의된 값과 같다.
* 사용자의 HTTP 요청에 `if-modified-since` 헤더가 포함된 경우, 서버는 이 값을 토대로 자신이 갖고 있는 이미지와 비교 검증할 수 있게 된다.
* 클라이언트가 요청한 이미지가 아직 수정되지 않은 것이 검증된 경우, 서버는 다음과 같은 형태의 HTTP 응답을 반환한다.
    * 응답 상태 코드는 304 Not Modified를 적용한다.
    * `Cache-Control`과 `Last-Modified`는 그대로 설정한다.
    * **HTTP 메시지 본문은 비워둔다**.
```
HTTP/1.1 304 Not Modified
Content-Type: image/png
Cache-Control: max-age=60
Last-Modified: Fri, 27 Sep 2019 01:00:00 GMT
Content-Length: 12345

// HTTP 메시지 본문은 생략된다!
```
* **클라이언트는 이러한 메시지를 통해 캐시된 이미지가 최신임을 인식하게 되며, 캐시 저장소의 캐시 만료 기간을 갱신**한다.
    * 이후 갱신된 캐시의 이미지를 재사용한다.

### 캐시 검증 헤더와 조건부 요청의 혼용
* **`Last-Modified`는 검증 헤더이며, `if-modified-since`는 조건부 요청 헤더에 해당**한다.
    * **두 헤더를 조합하여 캐싱된 이미지가 최신인지 확인할 수 있으며, 불필요한 네트워크 트래픽을 줄이고 브라우저의 캐시를 재사용**할 수 있다.
* 이를 통해 캐시의 유효 기간이 만료되었더라도 서버의 데이터가 갱신되었는지의 여부에 따라 효율적인 동작을 취할 수 있게 되며, 다음과 같은 이점을 얻을 수 있다.
    1. 서버는 304 Not Modified와 헤더 메타 정보만을 응답하며, 메시지 본문을 포함하지 않으므로 불필요한 네트워크 트래픽을 사용하지 않는다.
    2. **클라이언트는 서버가 반환한 HTTP 응답의 헤더 정보를 토대로 캐시의 메타데이터를 갱신**한다.
    3. 이를 통해 클라이언트는 캐시에 저장된 데이터를 재활용할 수 있게 된다.
* **이러한 방식은 네트워크 요청이 발생하긴 하지만, 이상적인 경우 용량이 적은 HTTP 헤더 정보만을 다운로드하게 되므로 매우 실용적인 방식**이다.
    * 때문에 대부분의 웹 브라우저는 해당 방법을 적극적으로 도입하여 구현해두었다.

### 검증 헤더의 종류
* 검증 헤더는 캐시 데이터와 서버 데이터의 동일성을 검증하기 위해 사용되는 헤더이며, `Last-Modified` 헤더와 `ETag` 헤더를 사용할 수 있다.
  * 각 검증 헤더에 대응하는 조건부 요청 헤더는 `If-Modified-Since` 헤더와 `If-None-Match` 헤더이다.
  * 각 조건부 요청 헤더의 조건을 만족하여 만료된 리소스의 경우, 200 OK 상태 코드로 응답된다.
  * 반면, 조건을 만족하지 못하여 캐싱된 리소스를 사용해도 무방한 경우 304 Not Modified 상태 코드로 응답한다.

### Last-Modified 헤더의 한계
* 1초 미만의 단위로 캐시 조정이 불가능하며, 오로지 날짜 기반의 로직만을 사용할 수 있다.
* 데이터를 수정하여 수정 날짜는 변경되었지만, 실제 데이터는 수정되지 않은 경우 역시 캐시된 이미지를 재활용하는 것이 아닌, 새로운 리소스를 다운로드 한다.
* 상술한 이유에서 `Last-Modified` 헤더는 서버에서 날짜 기반의 로직이 아닌, 컨텐츠 기반 또는 임의의 캐시 로직을 관리하고 싶은 경우에는 적절하지 못하다.
  * **서버에서 완전히 캐시 메커니즘을 컨트롤하고 싶은 경우, `ETag` 헤더를 활용**할 수 있다. 

### ETag 헤더
* **Entity Tag 헤더는 캐시용 리소스에 Hash 등 임의의 고유한 버전 처리를 적용**한다.
  * 데이터가 수정된 경우, Hash를 재생성하여 ETag를 변경한다.
* **캐시 메커니즘은 매우 단순하며, 단지 ETag의 값을 비교하여 동일한 경우에는 캐싱된 리소스를 재사용**한다.
* **웹 브라우저는 리소스를 캐시할 때 ETag의 값을 함께 저장하며, 해당 리소스를 다시 요청하는 경우 `If-None-Match` 헤더에 ETag의 값을 명시**한다.
  * 서버는 검증 실패시 304 Not Modified 상태 코드를 반환하여 캐시된 리소스를 재활용하도록 한다.
* ETag 방식은 캐시 제어 메커니즘을 서버에서 완전히 관리하며, 클라이언트는 단순히 ETag의 값을 서버에 제공하는 역할만을 수행한다.
  * 즉, 클라이언트는 캐시 메커니즘을 알 수 없다.

### 캐시 제어와 관련된 헤더들
* 캐시 제어와 관련된 헤더들은 `Cache-Control`, `Pragma`, `Expires` 등이 존재한다.

### Cache-Control 헤더
* `Cache-Control: max-age`는 초 단위로 캐시 유효 시간을 명시한다.
* `Cache-Control: no-cache`는 데이터의 캐싱을 허용하지만, 반드시 Origin 서버에 검증 후에 사용하도록 한다.
  * **해당 헤더가 명시된 경우, 네트워크 경로 상에 있는 캐시 서버에게 질의하는 것이 아닌 항상 원 서버에 질의 후 사용**하게 된다.
* `Cache-Control: no-store`는 데이터에 민감한 정보가 포함되는 경우, 이를 저장하지 말고 메모리에서 사용 후 최대한 빠르게 삭제하도록 한다.
  * no-cache와 no-store를 혼동하지 않아야 한다.

### Pragma 헤더와 Expires 헤더
* 해당 두 헤더는 모두 HTTP/1.0의 하위 호환을 위해 남겨진 헤더이며, 시용법은 다음과 같다.
  * `Pragma: no-cache`
  * `Expires: Fri, 27 Sep 2019 01:00:00 GMT`
* `Pragma` 헤더의 경우, `Cache-Control: no-cache`와 유사하게 동작한다.
  * 이제는 잘 사용되지 않는 헤더이며, 단지 HTTP/1.0의 하위호환성 유지가 필요한 경우에 사용된다.
* `Expires` 헤더의 경우, 캐시 만료일을 정확한 날짜로만 지정한다.
  * 때문에 현재에는 더 유연한 `Cache-Control: max-age` 헤더의 사용이 권장된다.
  * 만약 **`Cache-Control: max-age`과 함께 사용하는 경우, `Expires` 헤더는 무시**된다.

### If-Match 헤더와 If-Modified-Since 헤더
* `ETag`와 `Last-Modified`에 대응하는 조건부 요청 헤더는 `If-None-Match`와 `If-Modified-Since`외에도 다음과 같은 헤더가 존재한다.
  * `If-Match` 헤더: `ETag` 헤더와 함께 사용된다.
  * `If-Unmodified-Since` 헤더: `Last-Modified` 헤더와 함께 사용된다.

### 프록시 캐시 서버
* CDN 등의 서비스는 먼 원격지에 있는 파일을 캐시하는 프록시 캐시 서버의 역할을 수행한다.
  * 이 때, CDN에 캐시된 리소스를 public 캐시라고 한다.
  * 반면, 웹 브라우저 또는 로컬에 저장된 리로스는 private 캐시에 해당한다.

### 프록시 캐시와 관련된 헤더
* `Cache-Control: public` 헤더는 HTTP 응답이 public 캐시에 저장되는 것을 허용한다.
* `Cache-Control: private` 헤더는 HTTP 응답이 해당 사용자만을 위한 것이며, private 캐시에만 저장하도록 허용한다.
  * `Cache-Control`은 private이 기본으로 적용된다.
* `Cache-Control: s-maxage` 헤더는 프록시 캐시에만 적용되는 `max-age`에 해당한다.
* `Age: 60`과 같은 형태의 헤더는 Origin 서버에서 응답한 후 프록시 캐시 내에 머문 시간을 초 단위로 명시한다.

### 캐시 무효화하기
* **캐시를 하지 않는 헤더를 명시한다고 하더라도, 웹 브라우저가 임의로 브라우저 내에 리소스를 캐시해버리는 경우가 발생**할 수 있다.
* 때문에 **캐시를 완전히 무효화하여 임의의 리소스를 절대 캐싱하지 않으려는 경우, 반드시 다음과 같은 헤더를 명시**해야 한다.
  * `Cache-Control: no-cache, no-store, must-revalidate`
  * 또는 HTTP/1.0의 하위 호환성을 위해 `Pragma: no-cache`도 명시한다.
* **일반적으로 상술한 `Cache-Control`과 `Pragma` 헤더를 조합하는 것으로 웹 브라우저의 캐싱을 방지**할 수 있다.

### 캐시 무효화와 관련된 헤더
* `Cache-Control: no-cache`는 데이터의 캐싱을 허용하지만, 반드시 Origin 서버에 검증 후에 사용하도록 한다.
* `Cache-Control: no-store`는 데이터에 민감한 정보가 포함되는 경우, 이를 저장하지 말고 메모리에서 사용 후 최대한 빠르게 삭제하도록 한다.
* `Cache-Control: must-revalidate`는 캐시 만료 후 최초 조회시 반드시 Origin 서버에 검증하도록 한다.
  * Origin 서버 접근 실패시에는 반드시 504 Gateway Timeout 오류가 발생해야 한다.
  * must-revalidate의 경우, 캐시 유효 시간 내라면 캐시를 사용하도록 동작한다.
* `Pragma: no-cache`: HTTP/1.0과의 하위 호환성을 위해 사용하는 캐시이며, `Cache-Control: no-cache`와 같은 동작을 수행한다.

### no-cache와 must-revalidate의 차이
* 두 속성 모두 Origin 서버에 질의를 유도하는 기능은 동일하다.
* 클라이언트 - 프록시 캐시 - Origin 서버의 흐름으로 통신할 때, Origin 서버가 일시적으로 통신이 불가한 경우 두 값은 각각 다음과 같이 동작한다.
  * no-cache: 프록시 캐시 서버의 정책에 따라 오래된 리소스라도 우선 반환하여, 사용자가 오류 상황을 알 필요가 없게 동작할 수도 있다.
  * must-revalidate: Origin 서버가 서비스 불능인 경우, 반드시 504 Gateway Timeout과 같은 오류를 반환하도록 동작해야 한다.
    * 이는 HTTP 스펙에 정의된 내용이다.
* 예를 들어 통장 잔고와 같이 매우 민감한 정보의 경우, 프록시 캐시 서버의 정책에 따라 오래된 리소스를 보여주는 것은 적절한 접근 방식이 아니다.
* 때문에 **확실히 캐시를 무효화하려면, 서버가 HTTP 응답을 생성할 때 no-cache, no-store, must-revalidate, `Pragma: no-cache`를 명시**한다.
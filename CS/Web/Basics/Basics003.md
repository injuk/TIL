# Basics
## 2022-06-06 Mon

### HTTP everywhere
* HTTP 메시지에는 다음과 같이 사실상 모든 것들을 전송할 수 있다.
  1. HTML과 텍스트
  2. 이미지, 영상, 파일, 음성
  3. JSON, XML
* **거의 모든 형태의 데이터를 전송할 수 있으며, 비단 클라이언트 뿐만 아닌 서버 간의 데이터 송수신에도 HTTP가 활용**된다.

### HTTP의 역사
* HTTP의 역사는 크게 다음과 같이 분류해볼 수 있다.
  1. HTTP/0.9: GET 메소드만을 지원하였으며, HTTP 헤더가 존재하지 않았다.
  2. HTTP/1.0: GET 이외의 여러 메소드와 헤더가 추가되었다.
  3. **HTTP/1.1: 가장 많이 사용되는 버전**이다.
  4. HTTP/2: 성능이 개선된 버전이다.
  5. HTTP/3: TCP 대신에 UDP를 사용하며, 성능이 개선되는 버전이다.
* **HTTP/1.1 스펙에 거의 대부분의 기능이 포함되며, HTTP/2와 HTTP/3은 성능 개선에 초점을 맞추므로 HTTP/1.1을 이해하는 것이 가장 중요**하다.
* HTTP/1.1은 다시 다음과 같은 RFC 문서로 개정되어왔다.
  1. RFC2068: 1997년
  2. RFC2616: 1999년 개정
  3. RFC7230 ~ 7235: 2014년 개정
* 그러나 HTTP/1.1을 해설하는 대부분의 책과 인터넷 상의 글들은 RFC2616을 기반으로 설명하는 경우가 많다.
  * 때문에 HTTP를 학습할 때 초점은 RFC7230 이후의 버전에 맞추어야 한다.
* **HTTP/3은 HTTP/1.1과 HTTP/2가 TCP를 기반으로 하는 것과 달리 UDP를 사용**한다.
* 현재로서는 HTTP/1.1이 주로 사용되지만, HTTP/2와 HTTP/3의 수요도 점점 늘어나는 추세이다.
  * 그러나 **HTTP의 스펙은 HTTP/1.1에서 완성되었으며, HTTP/2와 HTTP/3은 성능 개선에 초점을 맞추므로 HTTP/1.1을 정확히 이해하는 것이 중요**하다.

### HTTP의 특징
* 클라이언트 - 서버 구조를 갖는다.
* **상태가 없는 무상태 프로토콜을 지향하며, 비연결성을 특징**으로 갖는다.
* HTTP 메시지를 통신에 사용한다.
* 프로토콜 자체가 단순하며, 확장성이 용이하다.

### 클라이언트 - 서버 구조
```
> HTTP는 클라이언트 - 서버 구조를 따르며, 클라이언트는 서버에게 요청을 전달한다.
> 서버는 클라이언트의 요청을 처리하기 위한 응답을 만들어 반환하며, 클라이언트는 이를 대기한다.
> 클라이언트가 성공적으로 응답을 수신한 경우, 서버가 반환한 응답 메시지를 토대로 적절히 동작한다.
```
* 클라이언트 - 서버 구조에서의 HTTP 통신은 다음과 같은 흐름으로 진행된다.
  1. **HTTP 클라이언트는 HTTP 요청 메시지를 만들어 서버에게 요청을 송신하고, 서버의 응답을 대기**한다.
  2. **서버는 HTTP 요청에 대한 내부적인 처리를 진행하고, HTTP 응답 메시지를 만들어 클라이언트에게 반환**한다.
  3. 클라이언트는 서버로부터 수신한 HTTP 응답 메시지를 토대로 적절한 동작을 수행하게 된다.
* **동작 방식은 아주 단순하지만, 중요한 것은 클라이언트와 서버의 역할이 개념적으로 나뉘었다는 사실 그 자체**이다.
  * 이전에는 클라이언트와 서버의 역할이 따로 나누어지지 않았다.
* **클라이언트 - 서버 구조에서는 비즈니스 로직과 데이터 등을 모두 서버에게 모아두고, 클라이언트는 오로지 UI와 사용성에만 집중**할 수 있게 된다.
  * **이를 통해 클라이언트와 서버는 각각 독립적으로 진화**할 수 있게 된다.
  * 즉, 클라이언트는 복잡한 비즈니스 로직이나 데이터를 다룰 필요가 없으며, 단순히 UI에만 신경쓰면 된다.
  * 서버 역시 트래픽이 증대하더라도 백엔드 로직의 고도화만 고려하면 되며, 클라이언트 단을 신경쓸 필요가 없어진다.

### Stateless
* **HTTP는 상태를 갖지 않는 무상태 프로토콜(Stateless)을 지향하며, 이는 서버가 클라이언트의 상태를 보존하지 않는다**는 사실을 시사한다.
  * 반면, Stateful의 경우 서버가 클라이언트의 상태 정보를 보존한다.
* 상태를 갖는 Stateful과 상태를 갖지 않는 Stateless의 차이를 예시로 들어 설명하면 다음과 같다.
  1. Stateful: 상점에서 점원에게 무언가를 구매하는 경우, 매 질의마다 같은 점원과 대화한다.
     * 때문에 점원은 구매자의 모든 요구사항(컨텍스트)을 알고 있다.
  2. Stateless: **매 질의마다 다른 점원과 대화하므로, 각 점원은 구매자의 이전 요구사항(컨텍스트)에 대해 알지 못한다**.
* **무상태 프로토콜에서는 클라이언트에게 필요한 정보를 그 때 그 때 전부 넘겨주므로, 각 요청과 응답에서 질의하는 서버가 달라져도 상관이 없어진다**.
  * 이러한 특징은 클라이언트 서버 구조에서의 엄청난 확장성으로 이어진다.

### Stateful과 Stateless의 차이
```
> Stateful: 클라이언트는 계속해서 같은 서버와 통신해야 한다.
> Stateless: 클라이언트의 매 질의마다 응답 서버가 바뀌어도 상관이 없다.
```
* **상태를 유지하는 경우, 서버는 모든 클라이언트의 컨텍스트를 계속해서 유지하고 있어야 한다**.
  * 이러한 방식에서 서버를 증설하려면 새로운 서버에게 기존 클라이언트의 컨텍스트를 복사해주어야 한다. 
  * 또는 클라이언트와 통신 중이던 서버가 복잡한 질의 과정 중간에서 서비스 불가능해진 경우, 클라이언트는 모든 과정을 처음부터 다시 시작해야만 한다.
* **상태를 유지하지 않는 경우, 서버가 클라이언트의 컨텍스트를 유지할 필요가 없으므로 응답 서버가 바뀌어도 상관이 없다**.
  * 때문에 서버에 질의하는 클라이언트가 폭증하는 경우 서버를 늘리기만 하면 된다.
  * 즉, **무상태를 유지하는 구조의 경우 응답 서버를 사실상 무한정 증설**할 수 있다.

### Stateless의 한계
* **모든 것을 무상태로 설계할 수 있는 것은 아니다**.
  * 예를 들어, 사용자가 로그인했다는 사실 자체는 서버에 유지되어야 한다.
  * 이러한 로그인의 유지는 일반적으로 브라우저 쿠키와 서버의 세션 등을 활용한다.
* **중요한 것은 상태를 최소한으로 유지하되, 꼭 필요한 경우에만 사용해야 한다는 점**이다.
  * 웹 애플리케이션을 설계하는 과정에서는 최대한 무상태로 설계하고, 어쩔 수 없는 경우에만 상태를 유지하도록 하는 것이 바람직하다.
* 또한, **Stateless는 너무 많은 데이터를 주고 받는다는 단점 역시 존재**한다.

### 비연결성
* 연결성을 유지하는 모델의 경우, 모든 클라이언트들의 연결을 서버가 유지하고 있어야 한다.
  * 즉, 클라이언트 A, B, C의 TCP / IP 연결을 서버는 계속해서 유지해야 한다.
  * 이는 설령 클라이언트 B, C가 아무런 요청을 보내지 않더라도 적용되는 문제점이다.
* 반면, **비연결성 모델인 HTTP의 경우 클라이언트의 HTTP 요청에 대한 서버의 HTTP 응답이 있은 후에는 TCP / IP 연결을 종료**한다.
  * 때문에 서버는 연결성 모델에 비해 유지해야하는 TCP / IP 연결에 대한 부담이 줄어든다.
  * 이렇듯 **서버는 요청을 주고 받을 때에만 연결을 유지한 후에 끊어버리므로, 필요 최소한의 자원만을 사용**할 수 있다.

### HTTP와 비연결성
* **HTTP는 기본적으로 연결을 유지하지 않는 비연결 지향 모델**이며, 일반적으로 초 단위 이하의 빠른 속도로 응답이 가능하다. 
* 때문에 **1시간에 수천 명이 서비스를 사용하는 모델에서도 서버에서 실제로 동시에 처리하는 요청은 수십개 이하를 유지**할 수 있다.
  * 이는 모든 사용자가 동시에 연결을 시도하지 않기 때문이다.
  * 즉, 서버 자원을 효율적으로 사용할 수 있다.

### 비연결성 모델의 한계와 HTTP 지속 연결
* 비연결성 모델의 경우, 매 요청마다 `3 way handshake`를 거쳐야만 한다.
  * 결국 **연결을 수립하는 시간이 소모되므로, 반응 속도는 상대적으로 늦어진다**.
* 또한, 웹 브라우저에 대한 요청시마다 HTML을 비롯한 JS, CSS, 정적 리소스 등 수많은 자원이 함께 다운로드된다.
  * 예를 들어 정적 리소스를 포함하는 웹 페이지를 요청한 경우, 클라이언트는 HTML, JS, CSS, 정적 리소스 각각에 대해 연결을 수립해야 한다.
  * **이러한 과정에서 각 리소스를 다운로드받을 때마다 TCP / IP 연결을 수립하거나 종료하기 위한 시간이 소모**된다.
* 이러한 **한계점을 극복하기 위해 현재의 HTTP는 지속 연결(Persistent Connections)를 도입**하였다.
  * **HTTP 지속 연결을 사용하는 경우, 상술한 정적 리소스 로드 시나리오에서 TCP / IP 연결 수립과 종료는 단 한 번만 수행**된다.
  * 현재의 HTTP는 지속 연결을 기본적으로 사용하고 있으며, HTTP/2와 HTTP/3에서는 더욱 더 최적화되었다.

### 서버 개발자들에게 어려운 점
* 웹 개발을 진행하는 경우, **정말 동일한 시간에 대용량 트래픽이 발생하는 이벤트에 대응해야하는 경우**가 있다.
  * 예를 들어, 수강신청은 정해진 시간에 수많은 재학생들의 접속 요청이 발생한다.
  * 이 경우, Stateless 특징은 사실상 의미가 없어진다.
* **그럼에도 최대한 Stateless하게 설계하는 것이 중요하며, 이를 통해 대용량 트래픽에 대해 서버를 증설하여 대응할 수 있는 선택지가 늘어나게 된다**.
  * 예를 들어, 이벤트 페이지에 진입하기 전에 잠시 사용자를 잡아둘 수 있는 정적 HTML 페이지를 버퍼 용도로 끼워 넣을 수 있다. 
* **중요한 것은 Stateless를 위해 최대한 모든 것을 무상태로 만들되, 정말 어쩔 수 없는 경우에 한해서만 상태를 유지할 수 있도록 분리하여 설계하는 것**이다.

### HTTP 메시지
* 모든 것이 HTTP이므로, HTTP 메시지에 모든 것을 전송할 수 있다.
  * 예를 들어, HTML 뿐만 아니라 이미지, 영상, 파일, JSON, 등 거의 모든 형태의 데이터를 전송할 수 있다.
* **HTTP는 요청 메시지와 응답 메시지의 형태가 다르다**.
* HTTP 메시지는 크게 다음과 같은 구조를 갖는다.
  1. start-line: 시작 라인이며, HTTP 요청과 응답 메시지에서 구조가 다르다.
  2. header: 헤더 정보이며, 여러 줄이 포함될 수 있다.
  3. empty line: **공백 라인(CRLF)이며, 필수적으로 포함되어야 하는 항목**이다.
     * **메시지 본문이 없는 경우, message body 항목은 누락되지만 empty line은 포함**된다.
  4. message body: 메시지 본문이며, 본문이 없는 경우 항목 자체가 누락될 수 있다.
* 이를 토대로, HTTP 요청 메시지는 다음과 같이 분류할 수 있다.
```
시작 라인 > GET /search?q=hello&hl=ko HTTP/1.1
헤더 정보 > Host: www.google.com
공백 라인 >
메시지 본문 > // HTTP 요청 메시지 역시 body를 가질 수 있다.
```
* 또한, HTTP 응답 메시지는 다음과 같이 분류할 수 있다.
  * **시작 라인이 HTTP 요청 메시지와 다르며, 나머지 부분은 동일**하다.
```
시작 라인 > HTTP/1.1 200 OK
헤더 정보 > Content-Type: text/html;charset=UTF-8
헤더 정보 > Content-Length: 3423
공백 라인 >
메시지 본문 > <html>...</html>
```

### 시작 라인
* start-line은 크게 request-line과 status-line으로 분류된다.
  * request-line은 HTTP 요청 메시지에서 사용된다.
* request-line의 경우, 다음과 같은 구조를 갖는다.
```
[METHOD] [공백] [REQUEST_TARGET] [공백] [HTTP_VERSION] [개행]
GET /search?q=hello&hl=ko HTTP/1.1
```
* [METHOD]는 HTTP 메소드를 가리키며, 서버가 수행해야할 동작을 지정하기 위해 사용된다.
  * 예를 들어, GET / POST / PUT / DELETE 등이 존재한다.
* [REQUEST_TARGET]은 요청 대상을 가리키며, 일반적으로 절대 경로를 사용한다.
  * 예를 들어, `absolute-path[?query]` 형태를 갖는다.
  * **절대 경로는 반드시 적용되는 절대적인 규칙이 아니며, `http://...?x=y`와 같은 다른 유형의 경로 지정 방식도 존재**한다.
* [HTTP_VERSION]은 HTTP 버전을 가리킨다.
* status-line의 경우 HTTP 응답 메시지에서 사용되며, 다음과 같은 구조를 갖는다.
```
[HTTP_VERSION] [공백] [STATUS_CODE] [공백] [REASON_PHRASE] [개행]
HTTP/1.1 200 OK
```
* [STATUS_CODE]는 요청에 대한 상태 코드를 가리키며, 요청의 성공 또는 실패를 가리킨다.
  * 예를 들어, 200은 요청이 성공했음을 의미한다.
* [REASON_PHRASE]는 상태 코드를 보조하며, 사람이 이해할 수 있는 상태 코드에 대한 짧은 설명이다.

### HTTP 헤더
```
> HTTP 헤더에는 메시지 본문을 제외하고 필요한 모든 메타데이터가 기입된다.
```
* header-filed는 헤더 정보를 입력하기 위해 사용하며, 다음과 같은 구조를 갖는다.
```
[FIELD_NAME]: [띄어쓰기 가능] [FIELD_VALUE] [띄어쓰기 가능]
Content-Type: text/html;charset=UTF-8
```
* [FIELD_NAME]은 **헤더의 키이며, 대소문자를 구분하지 않는다**.
  * [FIELD_NAME]과 : 기호 사이에는 **반드시 띄어쓰기가 없어야 한다**.
  * **헤더의 값은 대소문자를 구분**한다.
* **HTTP 헤더는 HTTP 전송에 필요한 모든 부가정보를 기입하기 위해 사용**한다.
  * 예를 들어, 메시지 본문의 내용이나 본문 크기, 인증, 요청 클라이언트 정보 등을 기입할 수 있다.
  * 수많은 표준 헤더가 존재하며, 필요한 경우 임의의 헤더를 추가할 수도 있다.
  * 임의의 헤더를 추가한 경우, 표준 헤더가 아니므로 해당 헤더를 이해할 수 있는 클라이언트와 서버만이 활용할 수 있다.

### HTTP 메시지 본문
* **HTTP 메시지 본문은 HTML 문서, 이미지, 영상 등 실제로 전송하고자하는 데이터가 포함**된다.
  * **byte로 표현할 수 있는 사실상 모든 데이터를 전송 가능**하다.

### HTTP의 단순함
* HTTP는 매우 단순하며, 이를 토대로 한 HTTP 메시지도 단순한 형태를 갖는다.
* 이렇듯 크게 성공하는 표준적인 기술은 단순하지만, 확장성이 뛰어난 경우가 많다.
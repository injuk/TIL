# Basics
## 2022-06-07 Tue

### HTTP 상태 코드란?
* **HTTP 상태 코드는 클라이언트가 보낸 요청의 처리 상태를 HTTP 응답 메시지에서 알려주는 기능**을 수행한다.
  1. 1xx: Informational, 요청이 수신되어 처리 중인 경우.
  2. 2xx: Successful, 요청이 정상 처리된 경우.
  3. 3xx: Redirection, 요청을 완료하기 위해 추가적인 행동이 필요한 경우.
  4. 4xx: Client Error, 클라이언트의 오류 또는 잘못된 문법 등으로 인해 서버가 요청을 처리할 수 없는 경우.
  5. 5xx: Server Error, 서버의 오류 등으로 인해 서버가 요청을 정상적으로 처리할 수 없는 경우.
* 이 때, 100번대 상태 코드는 거의 사용되지 않는다.

### 추가될 상태 코드에 대비하기
* 현재에는 존재하지 않는 상태 코드가 추후 서버에 추가되고, 이를 클라이언트에서 처리해야할 필요가 생길 수 있다.
* 클라이언트의 입장에서 이해할 수 없는 코드를 서버가 반환하는 경우, 백의 자리에서 묶어 처리해도 무방하다.
  * 예를 들어 **서버로부터 상태 코드 599가 반환되었으나 클라이언트가 이를 인식할 수 없는 경우, 5xx Server Error로 처리**한다.
* 이러한 방식을 적용한 경우, **미래에 새로운 상태 코드가 추가되더라도 상위 레벨 상태 코드로 처리하므로 추가 작업이 필요 없어진다**.

### 2xx - Successful
* 2xx 상태 코드는 클라이언트의 요청이 성공적으로 처리되었음을 의미하며, 크게 다음과 같이 분류된다.
  1. 200 OK
  2. 201 Created
  3. 202 Accepted
  4. 204 No Content

### 200 OK
* 해당 상태 코드는 요청이 성공했음을 의미한다.

### 201 Created
* 클라이언트의 요청이 성공하여 새로운 리소스가 생성되었음을 의미한다.
  * 이 때, **생성된 리소스는 HTTP 응답의 `Location` 헤더로 식별**한다.
* **클라이언트는 상태 코드가 201로 반환되는 경우, `Location` 헤더가 있을 수도 있다는 사실을 짐작**할 수 있다.

### 202 Accepted
* 클라이언트의 요청이 접수되었으나, 아직 처리가 완료되지 않은 경우에 사용되는 상태 코드이다.
  * 예를 들어 1시간 이후에 시작되는 Batch 프로세스가 요청을 처리하는 경우에 반환할 수 있다.

### 204 No Content
* 해당 상태 코드는 **서버가 요청을 정상적으로 처리하였으나, HTTP 응답 메시지 본문에 첨부할 데이터가 없는 경우에 사용**할 수 있다.
  * 이는 웹 문서 편집기에서 저장 버튼을 클릭한 경우를 예로 들 수 있다.
  * 상술한 시나리오의 경우, 저장 버튼을 클릭한 후 아무런 내용을 반환받을 필요가 없으므로 204 상태 코드를 반환하는 것이 바람직하다.

### 2xx 결론
* 일반적으로 200 OK만 사용하는 경우가 많고, 200과 201을 혼용하는 경우도 있다.
* 이는 **개발 팀에서 개발을 시작하기 전에 합의하고, 합의된 내용에 따라 개발을 진행하는 것이 바람직**하다.

### 3xx - Redirection
* 3xx 상태 코드는 요청을 완료하기 위해 유저 에이전트의 추가적인 조치가 필요한 상황을 의미하며, 크게 다음과 같이 분류된다.
  1. 300 Multiple Choices
  2. 302 Moved Permanently
  3. 302 Found
  4. 303 See Other
  5. 304 Not Modified
  6. 307 Temporary Redirect
  7. 308 Permanent Redirect
* 이 때, **유저 에이전트란 일반적으로 클라이언트 역할을 수행하는 웹 브라우저를 지칭**한다.

### 리다이렉션이란?
* **웹 브라우저는 3xx 상태 코드로 반환된 HTTP 응답의 결과에 `Location` 헤더가 존재하는 경우, `Location` 위치로 자동적으로 이동**한다.
  * 이렇듯 웹 브라우저에 의한 자동 이동을 리다이렉트라고 표현한다.
* 예를 들어 `/event` URI에서 기존 이벤트 페이지를 운영하고 `/new-event` URI에서 신규 이벤트 페이지를 운영한다고 하자.
* 상술한 시나리오에서 기존 이벤트 페이지에 접속한 클라이언트를 신규 이벤트 페이지로 리다이렉트시키는 흐름은 다음과 같다.
  1. 클라이언트는 `GET /event HTTP/1.1`로 요청한다.
  2. 서버는 `HTTP/1.1 301 Moved Permanently`와 `Location: /new-event`로 응답한다.
  3. 클라이언트 측 브라우저는 이를 받아 자동으로 `GET /new-event HTTP/1.1`을 요청한다.
     * **이 과정이 리다이렉션에 해당하며, 웹 브라우저에 의해 자동으로 수행**된다.
  4. 서버는 `HTTP/1.1 200 OK`로 응답하며, 메시지 본문에 신규 이벤트 페이지의 HTML 문서를 첨부하여 반환한다.

### 리다이렉션의 종류
* 리다이렉션은 다시 크게 다음과 같이 분류해볼 수 있다.
  1. 영구 리다이렉션: 특정한 리소스의 URI가 영구적으로 이동한 경우에 해당한다.
  2. 일시 리다이렉션: 일시적인 변경에 해당한다.
  3. 특수 리다이렉션: 예를 들어, 결과 대신 캐시를 사용하는 경우에 해당한다.

### 301 Move Permanently / 308 Permanent Redirect
* 두 상태 코드 모두 리소스의 URI가 영구적으로 이동한 경우에 사용할 수 있다.
  * 즉, **두 코드 모두 기존 URI가 새로운 URI로 영구적으로 변경된 사실을 알리는 역할을 수행**한다.
  * 이 경우 기존 URI를 사용하지 않으며, 이러한 변경 사항은 웹 브라우저에서도 인식할 수 있다.
* **301 상태 코드의 경우, 리다이렉트시 HTTP 요청이 GET 메소드로 변경되며 메시지 본문이 제거될 수도 있다**.
* **308 상태 코드의 경우, 301과 기능은 같으나 리다이렉트시 요청 메소드와 메시지 본문이 유지**된다.
* **301과 308을 비교하는 경우, 영구적으로 페이지가 이동된 경우에는 내부적으로 사용하는 데이터의 형식도 변경될 것이므로 301을 사용하는 것이 바람직**하다.
* **실무에서는 301 상태 코드가 가장 자주 사용**된다.

### 301 Move Permanently의 배경
* 해당 상태 코드의 초기 목적은 전달 받은 메소드를 그대로 유지하여 리다이렉트하는 것이었다.
* 그러나 실제로 브라우저들은 메소드를 유지하지 않고 GET 으로 변환하는 방식으로 구현되었고, 결국 스펙 역시 이에 따라 바뀌게 된 케이스에 속한다.
* 때문에 **상단에서는 요청 메소드가 GET으로 변경되거나 메시지 본문이 버려질 '수도' 있다고 작성되었으나, 실제로 대부분의 브라우저는 이렇게 동작**한다.

## 2022-06-08 Wed
### 일시적 리다이렉션
* **일시적 리다이렉션은 리소스의 URI가 일시적으로 변경된 상태이므로, 브라우저 등 검색 엔진이 URI를 변경하지 않아야 한다**.
* 일시적 리다이렉션은 실무에서도 많이 사용되는 상태이며, 크게 다음과 같이 분류된다.
  1. 302 Found: 리다이렉트시 요청 메소드가 GET으로 변경되며, 메시지 본문이 제거될 수 있다.
  2. 307 Temporary Redirect: **302와 기능은 동일하나, 리다이렉트시 요청 메소드가 변경되거나 메시지 본문이 제거되지 않는다**.
  3. 303 See Other: 302와 기능은 같으나, 리다이렉트시 요청 메소드는 GET으로 변경된다.
* 302 상태 코드 역시 상술한 301과 마찬가지로 메소드를 유지하는 스펙으로 정의되었으나, 브라우저의 구현 문제로 인해 스펙이 구현을 따라간 예시이다.
  * **이로 인해 307과 303 코드가 추가**되게 되었다.
* 303 상태 코드의 경우, 리다이렉트시 반드시 요청 메소드를 GET으로 변경한다.
  * 즉, **302는 바뀔 '수도' 있다면 307은 반드시 변경하고, 303은 반드시 변경하지 않는 차이점이 존재**한다.
  * 그러나 302 상태 코드는 대부분의 경우에 요청 메소드를 GET 메소드로 변경한다.
* **실무에서는 302 상태 코드가 가장 자주 사용**된다.
  * 대부분의 프레임워크, 또는 라이브러리에서는 디폴트가 302 상태 코드인 경우가 많다.
  * 때문에 GET 메소드로 변경되도 무방한 경우, 302를 사용해도 큰 문제는 발생하지 않는다.

### PRG - POST / Redirect / GET
* 예를 들어 POST 메소드로 구현된 상품 주문 페이지에서 새로고침하는 경우, POST 요청이 한 번 더 송신되므로 중복 주문이 발생하게 된다.
  * 원칙적으로는 이러한 상황은 서버 단에서 방지해야 하지만, 클라이언트 단에서도 처리가 가능해야 한다.
* 일시적 리다이렉션의 PRG 패턴은 다음과 같이 구현하는 것으로 이러한 상황을 미연에 방지한다.
  1. **POST 메소드를 통해 주문 완료한 후, 주문 결과 화면을 GET 메소드로 리다이렉트**한다.
  2. **이를 통해 새로고침 버튼을 클릭하더라도 결과 화면은 마지막 요청인 GET 메소드로 조회**된다.
* 이러한 PRG 패턴은 실무에서도 자주 사용되는 방식이다.
* HTTP 요청과 응답을 예로 들어, 상품 하나를 주문하는 경우 HTTP 요청 메시지는 다음과 같은 형식을 따를 수 있다.
```
POST /order HTTP/1.1
Host: localhost:8080

itemId=mouse&count=1
```
* 서버는 요청에 대한 HTTP 응답을 다음과 같이 302 Found로 반환한다.
```
HTTP/1.1 302 Found
Location: /order-result/19

```
* 웹 브라우저는 이를 인식하고, 자동으로 `/order-result/19` 리소스에 GET 요청을 전송한다.
```
GET /order-result/19 HTTP/1.1
Host: localhost:8080

```
* 서버는 클라이언트의 두 번째 요청에 대한 응답을 200 OK로 반환한다.
```
HTTP/1.1 200 OK

<html>...</html>
```
* 이 경우, PRG 이후에 리다이렉트를 하더라도 URI는 이미 POST에서 GET으로 리다이렉트 되었으므로, 새로고침하더라도 주문 완료 결과 화면만 조회하게 된다.
* 주문 완료 페이지에서 실수로 새로고침하는 실수는 실무에서도 많이 발생하는 상황이다.
  * PRG를 적용하면 클라이언트 입장에서도 실수할 가능성이 줄어들며, UX 측면에서도 불필요한 alert를 띄우지 않으므로 편리하다.
  * 또한, 서버 입장에서도 불필요한 오류가 크게 줄어드는 효과를 얻을 수 있다.

### 302 VS 307 VS 303
```
> 302 Found는 요청 메소드가 대부분의 경우에 GET 메소드로 변경된다.
> 307 Temporary Redirect는 요청 메소드가 변경되지 않아야 한다.
> 303 See Other는 요청 메소드가 GET 메소드로 반드시 변경되어야 한다.
```
* 초기의 302 상태 코드의 의도는 HTTP 메소드를 유지하는 것이었으나, 스펙의 모호함으로 인해 많은 브라우저들이 요청 메소드를 GET으로 변경하도록 구현하였다.
  * 반면, **상태 코드를 유지하는 구현체들도 더러 있었으므로 302 상태 코드의 모호함을 대체하기 위한 307과 303 상태 코드가 등장**하게 되었다.
  * 이는 영구적인 리다이렉션에서 모호함을 갖는 301 상태 코드를 대체하기 위해 308 상태 코드가 고안된 것과 일맥상통한다.
* **일반적으로 307 또는 303을 용도에 맞추어 사용하는 것이 권장되지만, 현실적으로는 이미 많은 라이브러리들이 302를 디폴트로 사용**하고 있다.
* 자동 리다이렉트의 경우, GET 메소드로 요청 메소드가 변경되어도 괜찮은 경우에는 302 상태 코드를 사용해도 무방하다.

### 3xx - 기타 리다이렉션
* 300 Multiple Choices: 사용되지 않는다.
* 304 Not Modified: 캐시를 목적으로 사용되는 상태 코드이며, 클라이언트에게 리소스가 수정되지 않았음을 알린다.
  * 때문에 **클라이언트는 로컬 PC에 저장된 캐시를 재사용하도록 캐시로 리다이렉트**한다.
  * 304 상태 코드로 응답하는 경우, 로컬 캐시를 사용해야하므로 메시지 본문을 포함하지 않아야 한다.
  * 304 상태 코드는 조건부로 GET 또는 HEAD 요청시에 사용되며, 실무에서도 매우 빈번하게 사용된다.

### 4xx - Client Error
* 해당 상태 코드들은 클라이언트의 요청이 잘못되어 서버가 요청을 수행할 수 없는 경우를 나타낸다.
  * 즉, **오류의 원인은 클라이언트**에게 있다.
* 클라이언트가 이미 잘못된 요청을 송신하므로, 재시도하더라도 요청은 항상 실패한다.
  * 반면, **5xx 오류는 서버의 상황에 따라 같은 요청을 재시도하는 경우 성공할 가능성이 존재**한다.

### 400 Bad Request
* 클라이언트가 잘못된 요청을 전달하였기에 서버가 요청을 처리할 수 없는 상태를 나타낸다.
  * 예를 들어, 요청 데이터의 형식이 잘못되었거나 API의 스펙이 일치하지 않는 경우가 있다.
* 클라이언트는 해당 상태 코드를 반환 받은 경우, 반드시 요청 내용을 검토하고 수정해야 한다.
* 이러한 **클라이언트 오류는 서버의 가장 바깥 단에서 반드시 핸들링해주어야 하며, 무조건 5xx 상태 코드로 반환하지 않아야 한다**.
  * **서버 개발자들은 철저한 밸리데이션 로직을 통해 앱 개발자 또는 프론트엔드 개발자와의 책임 소지를 명확히 나누어야 한다**.

### 401 Unauthorized
* 해당 상태 코드는 클라이언트가 해당 리소스에 접근하기 위해 인증이 필요한 상태를 의미한다.
  * 원인 메시지는 Unauthorized로 표현되지만, 실제로는 Authentication과 관련된 오류이다.
  * **Unauthorized란 권한에 의한 인가와 관련이 있으며, Authentication이 실제 사용자의 인증과 관련이 있는 항목**이다.
* 401 상태 코드로 대표되는 오류가 발생한 경우, HTTP 응답에 `www-authenticate` 헤더와 함께 인증 방법을 설명할 수 있다.

### 403 Forbidden
* 서버가 요청을 정상적으로 이해했으나, 거부한 상태를 가리키는 상태 코드이다.
  * **이는 주로 사용자가 인증되었으나, 접근 권한이 충분하지 않은 경우를 가리킨다**.

### 404 Not Found
* 해당 상태 코드는 요청 리소스를 서버가 찾을 수 없는 상태를 가리킨다.
* 또한, **클라이언트가 권한이 부족한 리소스에 접근하고자 하는 경우에 리소스를 숨기기 위해 사용할 수도** 있다.

### 5xx - Server Error
* 주로 서버 측의 문제로 발생한 오류를 나타내기 위해 사용하는 상태 코드들이며, 서버 측의 문제이므로 같은 HTTP 요청을 재시도하면 성공하는 경우도 있다.

### 500 Internal Server Error
* 서버의 내부 문제로 인해 발생한 오류를 나타내는 상태 코드이다.
* **애매한 경우에는 500 상태 코드를 사용해도 무방**하다.

### 503 Service Unavailable
* **서버가 제공하는 서비스가 일시적으로 이용 불가 상태인 상황을 나타내는 상태 코드**이다.
  * 예를 들어, 서버가 일시적인 과부하 또는 예정되었던 작업을 처리하기 위해 잠시 요청을 처리할 수 없는 경우가 있다.
  * 이러한 경우 `retry-after` 헤더를 통해 얼마 후에 복구되는지를 명시할 수도 있다.
* 그러나 **서버 측 장애는 복구 시간이 예측 불가능한 경우가 많으므로, 실무에서는 503 상태 코드보다는 500 상태 코드를 더 자주 사용**한다.

### 5xx 에러는 가능한 한 사용을 지양하기
* **5xx 에러는 정말 서버가 서비스 불가능한 상태임을 나타내기 위해 사용하는 것이 바람직**하다.
* 예를 들어, **비즈니스 로직 상 발생할 수 있는 잔고 부족 등의 예외 상황을 5xx 에러로 처리하지 않아야 한다**.
# Basics
## 2022-06-06 Mon

### URI, URL, URN
* URI, URL, URN 등 유사한 형식의 용어가 많지만 이를 구분하지 못하는 경우가 많다.
* URI는 URL과 URN 모두를 포괄하는 더 큰 개념이며, URL과 URN은 완전히 별도의 개념을 지칭한다.
  * URI: 인터넷 상에 위치한 개별 리소스를 식별한다.
  * URL: 인터넷 상에 위치한 개별 리소스의 **위치를 지칭**한다.
  * URN: 인터넷 상에 위치한 개별 리소스의 **이름을 지칭**한다.
* 이렇듯 **URL은 어디에서 리소스를 찾을 수 있는지를 의미하며, URN은 리소스의 이름 자체를 지칭한다는 점에서 차이**가 있다.
  * 이 때, 위치는 변할 수 있지만 이름은 변하지 않는 개념이다.
  * 그러나 **URN만으로 실제 리소스를 찾을 수 있는 보편화된 방법이 존재하지 않는다**.
* 그러나 사용 상의 불편함으로 인해 URN은 잘 쓰이지 않으며, URL이 더 많이 사용되곤 한다.
* 반면, URI의 각 글자는 다음과 같은 의미를 갖는다.
  * Uniform: 리소스를 식별하기 위한 단일 방식
  * Resource: URI로 식별할 수 있는 모든 자원이며, 자원이 되기 위한 제한은 존재하지 않는다.
    * 즉, 자원은 HTML과 같은 파일만을 가리키는 용어가 아니다.
    * 때문에 개발자가 자원으로 지정하고자 하는 모든 개념을 가리킬 수 있다.
  * Identifier: 다른 항목과 구분하기 위한 식별자

### URL 구조 분석하기
* 다음과 같은 URL이 있다고 하자.
```
https://www.google.com/search?q=hello&hl=ko
```
* 상술한 URL은 다음과 같은 URL만의 문법을 따라 작성된 예시이다.
```
scheme://[userinfo@]host[:port][/path][?query][#fragment]
```
* **scheme이란 주로 프로토콜을 표현하기 위한 정보**이다.
  * 이 때, 프로토콜이란 임의의 자원에 어떠한 방식으로 접근할지를 합의하는 규약이다.
  * 각각 80과 443을 사용하는 http, https 포트와 같이 잘 알려진 포트는 생략이 가능하다.
* userinfo는 URL에 사용자 정보를 포함하여 인증하는 경우에 사용되지만, 거의 사용되지 않는 개념이다.
* host란 임의의 서버를 가리키며, 도메인명 또는 IP 주소를 직접 입력할 수 있다.
* port는 접속 포트를 가리키며, 일반적으로 생략이 가능하다.
* **path는 리소스의 경로를 가리키며, 계층적인 구조**를 갖는다.
* **query는 `key=value` 형태로 작성하며, ?로 시작하여 &로 이어간다**.
  * query는 웹 서버에 제공하는 파라미터 정보이므로 query parameter 라고도 부를 수 있다. 
  * 또는 query의 모든 값은 숫자로 입력하더라도 문자열로 전달되므로, query string이라는 용어를 사용할 수도 있다.
* fragment의 경우 HTML 문서 내부적인 북마크 등에 사용한다.
  * **해당 값은 실제로 서버에 전송되는 정보는 아니다**.

### 웹 브라우저에서의 요청 흐름
* 클라이언트 상에 위치한 웹 브라우저에서, 구글 서버의 리소스를 가리키는 URL을 호출했다고 가정하자.
```
https://www.google.com:443/search?q=hello&hl=ko
```
* 이 때, 웹 브라우저는 다음과 같은 과정을 통해 HTTP 요청 메시지를 생성한다.
  1. 우선 웹 브라우저는 DNS 서버를 통해 `www.google.com`에 대응되는 IP 주소를 알아낸다.
  2. 또한 scheme와 동일한 포트인 443은 제거한다.
  3. HTTP 요청 메시지를 생성한다.
* 여기까지의 과정에서, 생성된 HTTP 메시지의 형태는 다음과 같다.
```
GET /search?q=hello&hl=ko HTTP/1.1
HOST: www.google.com
```
* 이후의 클라이언트와 서버 간의 통신은 생성된 HTTP 메시지를 기반으로 동작하며, 다음과 같이 진행한다.
  1. 웹 브라우저는 HTTP 요청 메시지를 생성한다.
  2. 웹 브라우저는 Socket 라이브러리를 통해 서버와 3 way handshake를 진행하여 연결을 수립한다.
  3. 연결이 수립되면 웹 브라우저는 실제 데이터인 HTTP 요청 메시지를 송신하기 위해 운영체제 계층에 전달한다.
  4. 운영체제 계층은 해당 정보를 토대로 TCP / IP 패킷을 생성한다.
  5. 생성된 패킷은 네트워크 인터페이스 계층을 경유하여 LAN 카드를 통해 인터넷 망으로 전달된다.
* 결론적으로 이렇게 **생성되어 전달되는 패킷은 전송 데이터를 포함하며, 이 전송 데이터는 웹 브라우저가 생성한 HTTP 요청 메시지**가 된다.
* 서버에 패킷이 성공적으로 전달된 경우, 서버는 다음과 같은 과정을 통해 메시지를 수신한다.
  1. 서버는 우선 TCP / IP 패킷에 캡슐화된 정보를 제거한다.
  2. 적절한 **서버의 애플리케이션이 HTTP 요청 메시지에 포함된 path, query 등의 정보를 해석**한다.
  3. **서버는 클라이언트의 요청에 응답하기 위한 데이터를 만들어내는 내부적인 처리를 진행**한다.
* 이 때, 생성된 HTTP 응답 메시지의 형태는 다음과 같다.
```
HTTP/1.1 200 OK
Content-Type: text/html;charset=UTF-8
Content-Length: 3423

<html>
  <body>...</body>
</html>
```
* 상술한 과정에서 서버에 의해 생성된 HTTP 응답 메시지는 클라이언트에서와의 동일한 과정을 통해 반환된다.
  * 즉, 생성된 데이터와 TCP / IP 패킷 정보들이 포함된다.
* 클라이언트에게 반환된 응답 패킷에는 웹 서버가 생성한 HTTP 응답 메시지와 HTML 문서가 포함된다.
  * **이렇게 반환된 HTML 문서는 웹 브라우저에 의해 렌더링되어 사용자에게 보여진다**.
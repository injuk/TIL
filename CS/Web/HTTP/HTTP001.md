# HTTP
## 2025-11-24 Mon
### 간단하게 알아보는 HTTP
```
> 전 세계의 웹 브라우저, 서버 및 웹 애플리케이션은 모두 HTTP를 통해 소통한다.
```
* HTTP는 현대 인터넷의 공용어이며, 수많은 이미지나 HTML 문서 등을 웹 서버로부터 웹 브라우저로 안전하게 옮겨주는 프로토콜로 이해할 수 있다.
* 이러한 HTTP는 신뢰성 있는 데이터 전송 프로토콜을 사용하므로, 데이터가 손상되거나 순서가 꼬이지 않음을 보장한다.
  * 이로 인해 인터넷 앱 개발자는 HTTP 통신으로 인한 데이터의 손상 복구를 염려하지 않고 기능을 구현하는 데에만 온전히 집중하는 것이 가능하다.

## 2025-11-25 Tue
### HTTP 서버와 클라이언트, 그리고 리소스
* HTTP로 옮겨지는 데이터인 웹 콘텐츠는 웹 서버에 존재하며, 웹 서버는 통신을 위한 수단으로 HTTP 프로토콜을 사용한다.
  * 이로 인해 웹 서버는 HTTP 서버라는 용어로도 지칭할 수 있으며, **HTTP 서버와 HTTP 클라이언트는 WWW를 구성하는 핵심적인 기본 요소**에 해당한다.
  * 이러한 **HTTP 서버는 인터넷의 데이터를 저장하며, HTTP 클라이언트가 요청한 데이터를 제공하는 역할을 수행**한다.
  * 즉, 클라이언트는 임의의 데이터를 HTTP를 통해 서버에 요청하고 서버는 HTTP 응답으로 이를 반환한다.
* 웹 컨텐츠는 웹 리소스로 구성되며, **텍스트나 HTML과 같이 웹 서버의 파일 시스템에 저장된 정적인 파일은 가장 단순한 형태의 웹 리소스에 해당한**다.
  * 반면, **리소스는 반드시 정적 파일일 필요 없이 요청 사용자 정보나 시간 등 외부 요인에 따라 동적인 컨텐츠를 생성하는 프로그램이 될 수도** 있다.
  * 다시 말해, 웹 리소스에 사실상 제약은 없으며 단지 웹에서 접근 가능한 어떠한 형태의 컨텐츠도 리소스로 취급될 수 있다.

## 2025-11-26 Wed
### MIME 타입이란?
* 앞서 다룬 바와 같이, 인터넷은 수많은 데이터 타입을 다룰 수 있기에 HTTP는 이들 객체 각각의 타입을 신중히 구분할 방법이 필요하다.
* **MIME 타입은 각 객체의 유형을 명시적으로 구분하기 위한 데이터 포맷 라벨로, 주로 HTTP 상의 멀티미디어 컨텐츠 라벨링을 위해 사용**된다.
  * 반면, MIME은 근본적으로 이메일 시스템 사이의 메시지 전송을 위해 설계되었으나 그 견고함으로 인해 HTTP 세계에도 채택된 케이스에 해당한다.
* **HTTP 서버는 모든 HTTP 객체에 대해 MIME 타입을 명시하며, HTTP 클라이언트는 객체를 반환받을 때 MIME 타입을 통해 자신이 다룰 수 있는지 확인**한다.
* MIME 타입은 슬래시 문자(`/`)를 기준으로 다음과 같은 두 구성 요소로 구분된다.
    1. 주 타입: `text`, `image` 등이 해당한다.
    2. 부 타입: `html`, `jpeg` 등이 해당한다.
* 이러한 MIME 타입은 수백 가지 이상이 존재하며, 실험용 또는 특정한 용도를 위한 MIME 타입 역시 존재한다.

## 2025-11-27 Thu
### URI와 URL, 그리고 URN
```
> HTTP 서버가 관리하는 리소스는 각각 자신의 이름을 갖기에, 클라이언트는 자신이 원하는 리소스를 명확히 지목하는 것이 가능하다.
> URI를 구성하는 두 분류 중 URN은 리소스의 이름만으로도 식별이 가능한 반면, URL은 리소스의 위치를 설명하는 것으로 식별한다.
```
* URI는 서버 리소스의 대표적인 이름으로, 각 HTTP 객체를 고유하게 식별하고 지정할 수 있도록 돕는다.
* 또한, URI는 다음과 같이 URL과 URN으로 구분하는 것이 가능하다.
    1. URL: **가장 흔한 형태의 URI이며, 특정 서버의 임의의 리소스에 대한 구체적인 위치를 서술**한다.
    2. URN: 임의의 리소스를 고유하게 가리키는 유일무이한 이름으로, 임의의 리소스에 대한 URN이 유지될 경우 리소스의 위치가 변경되더라도 참조 가능하다.
* **URL의 경우 스킴과 주소 및 리소스 이름과 같은 세 부분으로 구분할 수 있으며, 이는 표준 포맷에 해당**한다.
  * 최근의 경우, **대부분의 URI는 URL과 같기에 사실상 동일한 의미로 사용**된다.
* URN은 `urn:ietf:rfc:2141`와 같은 예를 들 수 있으며, 이는 인터넷 표준 문서인 RFC 2141에 대한 참조로서 기능한다.
  * 때문에 해당 문서가 어떤 서버로 이동되거나 접근 프로토콜이 변경되더라도 항상 해당 문서로 접근할 수 있음이 보장된다.
  * 반면, **URN은 기반 인프라 지원이 필요하지만 관련된 인프라가 부재한 관계로 널리 채택된 개념이 아닌 점에 주의**해야 한다. 

## 2025-11-28 Fri
### HTTP 트랜잭션이란?
* **HTTP 트랜잭션은 클라이언트와 서버가 리소스를 주고 받기 위한 과정에서 성립되며, HTTP 메시지를 활용하는 요청과 응답으로 구성**된다.
  * 이 때, HTTP 메시지는 요청 또는 응답에 따라 정형화된 형태의 데이터 덩어리를 지칭한다.
* 요청의 경우, HTTP 메소드라는 여러 종류의 명령이 지원되며 각 메소드는 서버에게 어떠한 동작이 취해져야하는지 전달한다.
* 응답의 경우, 서버가 클라이언트에게 요청 성공 여부를 알려주기 위한 세자리 숫자와 간단한 이유를 포함하는 개념인 HTTP 상태 코드를 포함한다.
  * 반면, **클라이언트의 경우 사유 구절보다는 상태 코드를 활용하여 응답을 처리**한다.
* **일반적인 웹 페이지는 여러 리소스의 모음이므로, 애플리케이션은 하나의 작업을 위해 복수 개의 HTTP 트랜잭션을 수행**할 수 있다. 

## 2025-11-29 Sat
### HTTP 메시지란?
```
> HTTP 메시지는 단순히 줄 단위로 구분되는 문자열이며, 이진 형식이 아닌 일반 텍스트 형태를 띄기에 사람에게 친숙하다.
```
* HTTP 메시지는 서버로 전달되는 요청과 클라이언트로 전달되는 응답 두 종류만 존재하며, 크게 다음과 같은 세 부분으로 구성된다.
  1. 시작줄: 메시지의 첫 줄로, 요청의 경우 무엇을 해야하는지 명시하는 반면 응답의 경우 무슨 일이 일어났는지 명시한다.
  2. 헤더: 0개 이상의 헤더 필드를 명시하며, 콜론(`:`) 문자로 구분되는 키-값 쌍으로 구성되어 **빈 줄로 끝난다**.
  3. 본문: **헤더의 끝인 빈 줄 다음에는 전달하기 위한 데이터가 명시될 수 있으며, 엄격한 구조를 갖는 해더와 달리 임의의 이진 데이터까지도 포함 가능**하다.

## 2025-11-30 Sun
### TCP 커넥션을 활용하는 HTTP
```
> 상술한 HTTP 트랜잭션, 그리고 트랜잭션을 통해 전달되는 HTTP 메시지는 모두 TCP 커넥션을 활용한다.
```
* HTTP는 세부적인 통신 방식에 집중하는 대신 대중적이고 신뢰성 있는 TCP/IP에 위임하며, 이로 인해 웹 자체가 TCP/IP에 기초한다고 이해할 수 있다.
  * 이는 TCP의 특징인 오류 없는 데이터 전송과 순서에 맞는 전달, 크기에 무방하게 전달 가능한 데이터 스트림의 장점을 취하기 위함이다.
* **TCP/IP는 TCP와 IP가 조합되어 네트워크와 하드웨어의 특성을 숨기며, 어떤 종류의 컴퓨터나 네트워크에서든 신뢰성 있는 소통이 가능하도록 지원**한다.
  * 이러한 특징으로 인해, **일단 TCP 커넥션이 맺어진 후에는 두 컴퓨터 간에 교환되는 메시지가 손상되거나 순서가 뒤바뀌는 일은 절대 발생하지 않는다**.
* 바꿔 말해, **클라이언트와 서버가 HTTP 메시지를 주고받기 위해서는 반드시 IP 주소와 포트 번호를 활용하여 TCP/IP 커넥션을 맺는 것이 선행**되어야 한다.

## 2025-12-01 Mon
### HTTP 프로토콜 버전
* HTTP 프로토콜은 프로토타입 버전인 HTTP/0.9부터 시작하여 현재에 이르기까지, 다양한 버전을 다음과 같이 제공한다.
    1. HTTP/0.9: 프로토타입 버전으로, 심각한 결함을 포함하며 GET 메소드만을 지원하는 반면 MIME 타입이나 헤더 등을 지원하지 않는다.
    2. HTTP/1.0: 처음으로 널리 쓰이기 시작한 버전으로, `1.0`이라는 버전 번호와 헤더 및 추가적인 메소드를 지원한다.
    3. HTTP/1.0+: 웹이 급격히 성장하며 `keep-alive` 커넥션을 포함한 여러 기능이 사실상 표준으로 추가된 버전을 지칭한다.
    4. HTTP/1.1: HTTP 설계의 구조적 결함을 개선한 버전으로, 현재 가장 많이 사용되는 버전으로 이해할 수 있다.
* 이 밖에도 HTTP/2.0 및 HTTP/3.0 등의 버전이 존재하며, 각 버전은 HTTP/1.1이 갖는 성능 문제를 개선하기 위해 제안되었다.

## 2025-12-02 Tue
### 웹을 구성하는 여러 요소
* 웹 애플리케이션인 웹 브라우저와 웹 서버는 기본적인 트랜잭션을 구현하기 위해 메시지를 주고 받는 반면, 그 밖에도 웹 애플리케이션은 여러 종류가 존재한다.
  1. 프록시: 클라이언트와 서버 사이에 위치하여 요청을 중개하며, 주로 보안을 위해 배치되는 것으로 신뢰할만한 중개자 역할을 담당한다.
  2. 캐시: 자주 사용되는 HTTP 객체를 저장하며, 클라이언트 입장에서 서버보다 가까이에 위치하는 것으로 속도적인 이점을 취할 수 있도록 지원한다.
  3. 게이트웨이: 주로 HTTP 요청을 다른 프로토콜로 변환하기 위해 사용되며, 마치 리소스를 다루는 진짜 서버인 것처럼 동작한다.
  4. 터널: 두 커넥션 사이에서 데이터를 직접 열지 않고 포워딩하기만 하는 특별한 종류의 프록시를 지칭한다.
  5. 에이전트: 사용자를 위해 HTTP 요청을 생성하는 클라이언트 측 프로그램으로, **웹 브라우저와 같이 HTTP 요청을 시작하는 모든 애플리케이션이 해당**된다.

## 2025-12-03 Wed
### URL이란?
```
> URL은 인터넷 상의 임의의 리소스를 지칭하기 위한 표준 이름으로, 해당 리소스가 어디에 있고 애플리케이션이 이에 어떻게 접근할 수 있는지 알린다.
```
* URL은 브라우저가 정보를 찾기 위해 필요한 리소스의 위치를 가리키며, 이를 통해 사용자는 수많은 리소스 중 필요한 것을 찾거나 공유할 수 있다.
  * 이렇게 공유된 리소스에는 HTTP 또는 다른 프로토콜을 통해 접근하는 것이 가능하다.
* **URL은 임의의 리소스에 접근하기 위한 방법으로 이해할 수 있으며, 해당 리소스가 어디에 배치되어 있고 이에 어떻게 접근해야할지 제시**한다.
  * 이 때, `어떻게`에 해당하는 정보는 스킴에 포함되며 `ftp` 형태의 스킴으로 미루어보아 HTTP 이외의 방법으로도 리소스에 접근할 수 있음을 알 수 있다.
  * 이렇듯 **URL은 인터넷 상에 공개된 리소스라면 무엇이든, 누구나 해당 리소스를 조회할 수 있도록 단일 방식의 작명 규칙을 갖는다**.
* URL은 브라우저가 임의의 리소스에 대해 더 영리하게 접근하고, 이를 다룰 수 있게 하는 것으로 인터넷 세상을 단순화시키는 중대한 역할을 수행한다.
  * 이로 인해 **사용자는 뉴스 리더나 FTP 클라이언트 애플리케이션 등을 설치하고 배울 필요가 없으며, 대신 URL이 브라우저에게 필요한 모든 것을 제공**한다.

## 2025-12-04 Thu
### URL 문법 살펴보기
* URL은 HTTP나 FTP, SMTP 등 다양한 스킴을 지원하지만 대부분의 URL은 다음과 같이 일반적인 URL 문법을 따르므로 비슷한 사용성을 갖게 된다.
```
<스킴>://<사용자명>:<비밀번호>@<호스트>:<포트>/<경로>;<파라미터>?<질의>#<프래그먼트>
```
* 이러한 **많은 컴포넌트를 모두 사용해야만 하는 일은 드문 반면, 대부분의 경우 가장 중요한 것은 스킴과 호스트 및 경로에 해당**한다.

## 2025-12-05 Fri
### 스킴 컴포넌트
* 스킴은 주어진 리소스에 대한 접근 방법을 제시하는 중요한 정보이며, 대부분의 스킴은 적절한 기본 포트를 갖는다.
  * 예를 들어, HTTP 스킴은 기본 포트 80을 갖는다.
* 스킴 컴포넌트는 반드시 영문자로 시작하며, URL의 왼쪽에서 세었을 때 첫 번째 콜론(`:`) 문자로 나머지 컴포넌트들과 구분된다.
  * 또한, **스킴은 대소문자를 가리지 않기에 `http://`와 `HTTP://`는 동일하게 처리**된다.

## 2025-12-06 Sat
### 호스트와 포트 컴포넌트
* 임의의 리소스를 찾기 위해서는 우선 해당 리소스를 호스팅하는 장비를 찾을 필요가 있으며, 리소스가 해당 장비의 어느 서버에서 제공되는지 알 수 있어야 한다.
* URL의 **호스트와 포트 컴포넌트는 각각 대상 장비와, 해당 장비 상에서 동작하는 서버가 열어둔 포트 정보를 명시**한다.
  * 이 때, 호스트는 IP 주소 형태 또는 DNS에 의해 지원되는 호스트 명을 가질 수 있으며 둘 중 어떤 방식으로 호스트를 명시하더라도 URL은 유효하다.
  * 반면, 상술한 바와 같이 HTTP 스킴은 기본 포트로 80을 적용한다.

## 2025-12-07 Sun
### 사용자명과 비밀번호 컴포넌트
* FTP 및 그 외 다양한 서버들은 자신의 데이터에 접근하고자 하는 사용자를 확인하기 위해 사용자 이름과 비밀번호를 요구할 수 있다.
* 물론 이러한 컴포넌트들은 누락될 수도 있으며, 누락된 경우 기본 사용자 이름과 비밀번호가 적용된다.
  * 대부분의 경우 기본 사용자 이름은 `anonymous`이며, 비밀번호를 브라우저 구현체마다 서로 다른 기본 값을 적용한다.

## 2025-12-08 Mon
### 경로와 파라미터 컴포넌트, 그리고 질의 문자열 컴포넌트
* URL 상의 경로 컴포넌트는 임의의 리소스가 해당 서버의 어느 위치에서 호스팅 중인지 제시하며, `/` 문자로 구분되는 계층적 구조를 갖는다.
  * 이 떄, 이러한 경로 컴포넌트의 정보는 서버가 사용자가 요청한 리소스의 위치를 찾기 위해 사용되는 정보이다.
* 파라미터 컴포넌트는 클라이언트가 서버에게 정확한 요청을 전송하기 위해 필요한 입력 파라미터를 명시하며, `/path;key=value` 형태를 갖는다.
  * 이렇듯 다른 컴포넌트들과는 세미콜론(`;`) 문자로 구분되며, 이를 통해 클라이언트는 리소스에 접근하기 위해 필요한 추가 정보를 전달할 수 있다.
* URL 상에서 경로 컴포넌트는 다시 경로 조각으로 나뉠 수 있으며, 각 경로 조각은 자신만의 자체 파라미터를 가질 수 있다.
* 요청받은 리소스 형식의 범위를 좁히고자 하는 경우에는 질의 문자열을 활용할 수 있으며, 물음표(`?`) 우측에 키-값 쌍 형태로 명시한다.
* 질의 문자열의 경우 특정한 문자들을 제외하고 이렇다할 제약 사항은 없으며, 여러 키-값 쌍을 사용하는 경우 `&` 기호로 구분한다. 

## 2025-12-09 Tue
### 프래그먼트 컴포넌트
* HTML과 같은 특수한 형태의 리소스 형식은 전체를 구성하는 작은 부분으로 나뉠 수 있으며, 프래그먼트 컴포넌트는 이러한 작은 부분을 가리킨다.
  * 예를 들어, 임의의 HTML 문서는 이상적으로 보았을 때 문서 전체가 하나의 리소스인 반면 임의의 단락을 가리킬 수 있다면 유용할 수 있다.
* 임의의 리소스에 대해 특정한 부분만을 가리킬 수 있도록 URL은 리소스의 조각 일부를 의미하는 프래그먼트 컴포넌트를 제공하며, 이는 `#` 문자로 구분한다.
* 그러나 **일반적인 경우, HTTP 서버는 객체 일부가 아닌 객체 전부만을 제공하므로 클라이언트가 서버에 프래그먼트 정보를 전달하는 상황은 발생하지 않는다**.
  * 대신 브라우저와 같은 클라이언트가 서버로부터 전체 리소스를 반환받은 후, 프래그먼트 정보를 활용하여 리소스의 일부를 보여주는 방식으로 동작하게 된다.

## 2025-12-10 Wed
### 단축 URL과 상대 URL
```
> 클라이언트 애플리케이션은 단축 URL 기능을 제공하며, 예를 들어 상대 URL은 임의의 리소스를 간결하게 기술하는 반면 URL 자동 확장은 검색 편의성을 높인다.
```
* 상대 URL은 클라이언트가 인식 가능한 단축 URL의 일종으로, 리소스에 접근하기 위한 모든 정보를 포함하지는 않는 URL을 지칭한다.
  * 때문에 상대 URL로 임의의 리소스에 접근하기 위해서는 기저라고 불리우는 별도의 URL이 필요하다.
* 상대 URL 문법을 따를 경우, URL에 스킴이나 호스트 등의 컴포넌트를 모두 입력할 필요는 없으며 이는 기저 URL을 통해 상속 받게 된다.
* 클라이언트는 상대 URL을 사용하기 위해서는 이를 절대 URL로 변환할 수 있어야 하며, 대부분의 경우 다음과 같은 과정을 따른다.
    1. 리소스에서 명시적으로 제공되거나, 상대 URL을 명시하는 리소스의 URL로부터 기저 URL을 조회한다.
    2. 상대 URL과 기저 URL을 컴포넌트 조각으로 분해한 후, 변환 알고리즘에 따라 절대 URL로 파싱한다.

## 2025-12-11 Thu
### URL을 구성하는 문자
* URL은 인터넷 상의 모든 리소스가 여러 프로토콜을 통해 잘 전달되고, 각자 유일한 이름을 가질 수 있도록 설계되었다.
  * 바꿔 말해, 서로 다른 장치가 임의의 프로토콜에 따라 데이터를 안전하게 전송할 수 있도록 하기 위해서는 URL의 설계는 중요한 주제였다.
* 안전한 전송을 위해서는 정보가 유실될 가능성을 가능한 한 줄여야 하지만, SMTP와 같은 프로토콜은 특정한 문자를 제거하는 식으로 동작한다.
  * 때문에 **URL에 모든 문자를 허용할 경우 앞서 말한 '여러 프로토콜을 통해 잘 전달되는' 요구사항을 위배**하게 된다.
  * 또한, URL 설계자들은 URL 자체가 안전함과 동시에 가독성을 갖기를 원했기에 공백과 같이 보이지 않는 문자를 URL에 사용하지 않도록 제한했다.
* 상술한 조건 속에서도 **URL 설계자들은 안전하지 않은 문자를 URL에 포함하고자 하는 요구사항이 적지 않다는 것을 확인**하게 된다.
  * 이로 인해 **안전하지 않은 문자를 안전한 문자로 인코딩할만한 방법이 필요했으며, 이에 이스케이프라는 기능이 추가**되었다.

## 2025-12-12 Fri
### URL 문자 집합
* 다른 컴퓨터 시스템들이 그렇듯, URL 역시 적은 수의 영문자만을 포함하는 ASCII를 사용한다.
  * 그러나 **ASCII는 다른 언어권 문자들을 지원하지 않으며, 나아가 URL 자체에 ASCII에 포함되지 않은 이진 데이터를 포함해야하는 경우도 발생**하곤 했다.
* **URL 설계자들은 ASCII에 포함되지 않는 문자를 지원하기 위해 이스케이프 문자열을 도입하였으며, 이를 통해 금지된 문자를 인코딩하여 완성도**를 높였다.
  * 예를 들어, **안전하지 않은 문자열은 퍼센티지 기호(`%`)로 시작하는 두자리 16진수 숫자로 구성된 이스케이프 문자로 인코딩**될 수 있다.
  * 상술한 `%`에 더해 `/`나 `#` 및 `?` 외에도 여러 문자는 각자 다양한 용도로 사용되기 위해 선점되었으므로 반드시 이스케이프할 필요가 있다.

## 2025-12-13 Sat
### 클라이언트가 URL을 다루는 방법
* 어떤 전송 프로토콜에서는 안전하지 않은 문자를 인코딩하지 않아도 무방할 수 있지만, 이는 애플리케이션 개발자의 실수이며 반드시 수정되어야 할 내용이다.
* 애플리케이션은 정해진 방식에 따라 구현하는 것이 바람직하며, **어떤 URL을 사용하든지 클라이언트는 안전하지 않은 문자를 변환할 것이 권장**된다.
  * 이러한 원칙을 준수할 경우 상호작용하는 두 애플리케이션은 혼동의 여지를 두지 않고 공유된 URL의 원형을 안전하게 유지할 수 있다.
  * 또한, 일반적으로 입력받은 URL의 어떤 문자를 인코딩할지 결정하기에 적합한 장소는 웹 브라우저와 같이 URL을 최초로 입력받는 애플리케이션이 적절하다.
* 극단적으로는 모든 문자를 인코딩할 수도 있으나, 이러한 방식은 안전하지 않은 문자를 인코딩하지 않는 허술한 애플리케이션과 상호작용하는 데에 어려움이 있다.
* 반면, URL을 해석하는 애플리케이션은 URL을 처리하기 전에 디코딩하는 것이 권장된다.

## 2025-12-14 Sun
### URL의 한계
* URL은 웹 세상에 존재하는 모든 객체에 이름을 붙일 수 있으며 새로운 포맷 역시 쉽게 추가할 수 있는 강력한 도구이다.
* 그러나 URL은 일종의 참조이지 실체가 아니므로, 객체가 옮겨지면 해당 URL을 더 이상 사용할 수 없다는 명확한 한계를 갖는다.
* 이를 해결하기 위해서는 각 리소스의 실체에 대해 이름을 할당하는 것으로, 이 경우 리소스의 물리적인 위치가 변경되더라도 상술한 문제는 발생하지 않는다.
    * 이는 URN에 대한 설명인 반면, **URN이라는 새로운 표준을 제정하기 위해서 드는 수고와 비용에 의해 아직까지는 URL을 대체할 수 없다**. 

## 2025-12-15 Mon
### HTTP 메시지가 흐르는 방향
```
> HTTP 메시지는 HTTP 서버와 클라이언트 사이에서 주고 받는 데이터 블록들을 지칭한다.
```
* HTTP 메시지는 메시지의 내용과 의미를 설명하기 위한 문자 형태의 메타데이터로 시작되며, 그 이후에는 선택적으로 데이터 본문이 포함될 수 있다.
* 임의의 HTTP 메시지 한 건은 한 방향으로 흐르며, 방향에 따라 다음과 같은 용어를 사용할 수 있다.
    1. 인바운드: HTTP 메시지가 클라이언트로부터 서버로 향하는 요청의 경우
    2. 아웃바운드: HTTP 메시지의 처리가 완료된 후, 서버로부터 클라이언트로 향하는 응답의 경우
    3. 업스트림: HTTP 요청 / 응답과 무관하게 HTTP 메시지 발송자 자체를 지칭
    4. 다운스트림: HTTP 요청 / 응답과 무관하게 HTTP 메시지 수신자 자체를 지칭
* 덧붙여 업스트림과 다운스트림의 경우, HTTP 메시지는 항상 다운스트림 방향으로 흐르며 절대 업스트림으로 흐를 수 없다.

## 2025-12-16 Tue
### HTTP 메시지의 구성 요소
* **HTTP 메시지는 단순히 구조화된 데이터 블록**에 지나지 않으며, 각 메시지는 클라이언트로부터 발생한 요청이나 서버의 응답 중 하나를 포함한다.
* 이 때, **HTTP 요청 / 응답과 무관하게 HTTP 메시지는 시작줄과 헤더 블록 및 본문의 세 가지 구성 요소**를 갖는다.
    1. 시작줄: 해당 메시지가 요청이나 응답 중 어떤 유형을 갖는지 서술한다.
    2. 헤더 블록: 해당 메시지의 속성을 열거한다.
    3. 본문: 본격적인 HTTP 데이터를 포함하나, 본문은 아예 없을 수도 있다.
* 시작줄과 헤더 블록은 단지 줄 단위로 분리된 아스키 문자열에 불과하며, **각 줄은 두 글자의 줄바꿈 문자열인 `CRLF`로 끝난다**.
    * HTTP 명세에서는 줄바꿈을 위해 `CRLF`만을 허용하지만, 견고한 HTTP 앱은 일반적인 개행 문자를 처리할 수 있어야 한다.
    * 바꿔 말해, 견고하지 않은 HTTP 앱에서는 캐리지 리턴과 개행 문자를 모두 전송하지 않는 경우가 있을 수 있다.
* 본문의 경우 단순히 선택적으로 포함시킬 수 있는 데이터 덩어리에 불과한 반면, 시작줄이나 헤더와는 달리 텍스트나 이진 데이터를 포함할 수 있다.

## 2025-12-17 Wed
### HTTP 메시지의 문법
```
> 모든 HTTP 메시지는 요청 또는 응답으로 구분된다.
> HTTP 요청 메시지는 서버에 임의의 동작을 요구하는 반면, 응답 메시지는 요청에 대한 처리 결과를 클라이언트에 반환한다.
```
* HTTP 요청과 응답은 모두 기본적으로 동일한 구성 요소를 갖지만, 세부적인 형식에 따라 다음과 같은 차이가 있다.
  1. 요청: 시작줄이 `<메소드> <URL> <버전>` 정보를 포함한다.
  2. 응답: 시작줄이 `<버전> <상태 코드> <사유 구절>` 정보를 포함한다.
* 이 때, 요청시 URL은 절대 경로 또는 URL의 경로 구성 요소를 명시할 수 있다.
  * 절대 경로가 아닌 경우, 서버는 생략된 호스트나 포트 정보를 자신으로 치환하는 방식으로 동작한다.
* 헤더 블록의 경우, `이름`과 `:`에 선택적인 공백을 한 칸 명시할 수 있으며, 이후 `값`과 `CRLF`로 작성되는 형태를 지키는 헤더를 0개 이상 명시한다.
  * 반면, **헤더 블록 자체가 본문의 시작과 구분하기 위한 `CRLF`를 하나 갖기에 헤더가 없더라도 시작줄과 본문은 항상 구분**될 수 있다.
* 상술했듯 본문은 선택적이며, 본문이 없는 HTTP 메시지는 `CRLF`로 끝나게 된다.
* 극단적으로, **헤더 블록과 본문이 모두 없는 HTTP 메시지의 경우에도 항상 `CRLF`를 통해 끝맺어야** 한다.
  * 그러나 본문이 없는 경우에 `CRLF`를 누락시키는 경우가 있으므로, 호환을 위해 모든 HTTP 앱은 `CRLF`로 끝나지 않는 메시지를 처리할 수 있어야 한다.

## 2025-12-18 Thu
### HTTP 메시지와 시작줄
* 상술한 바와 같이모든 HTTP 메시지는 시작줄로 시작하며, 이러한 시작줄은 요청과 응답이라는 유형에 따라 다른 구성을 갖는다.
    * 이 때, 각 구성 요소는 `<요소1> <요소2>`와 같이 공백으로 구분된다.
* 요청에 명시된 시작줄의 경우, 서버에 요청하는 리소스인 URL과 동사인 HTTP 메소드를 포함한다.
    * 또한, 클라이언트가 어떤 버전의 HTTP를 사용하고 있는지 알려주기 위한 버전 역시 포함된다.
* 응답에 명시된 시작줄의 경우, 응답 메시지의 HTTP 버전에 더해 요청에 대한 처리 결과를 의미하는 상태값인 상태 코드와 직관적인 메시지인 사유 구절이 포함된다.
* 덧붙여 HTTP/1.0의 경우, 요청에 명시된 시작줄의 마지막 구성 요소인 버전 정보와 응답의 시작줄 자체가 포함될 필요가 없었다.

## 2025-12-19 Fri
### HTTP 메소드 - 요약
* 요청에 명시된 시작줄의 첫 구성 요소인 HTTP 메소드는 서버가 무엇을 해야할지 알려주기 위한 정보이며, **HTTP 명세는 공통 요청 메소드 집합을 정의**한다.
    * 공통 요청 메소드 집합이란, 예를 들어 `GET`이나 `POST` 등 자주 사용되는 메소드 외에 `OPTIONS`와 `TRACE` 등을 포함하는 일곱 종류를 말한다.
* 이 때, **HTTP 메소드는 그 종류에 따라 요청 메시지에 본문을 포함하거나 하지 않을 수 있다는 점에 주의**를 기울여야 한다.
    * 예를 들어, `POST`와 `PUT`을 제외한 모든 HTTP 메소드는 본문을 포함하지 않는다.
    * 이는 스펙 상 엄격히 제한된 것은 아니나, HTTP 애플리케이션을 개발하는 개발자들 사이의 일관된 합의이므로 준수할 것이 강력히 권장된다.
* HTTP는 쉽게 확장할 수 있도록 설계되었으므로, 각 서버는 모든 메소드를 구현할 필요 없으며 자신만의 특별한 `확장 메소드`를 구현할 수도 있다.

## 2025-12-20 Sat
### HTTP 상태 코드 - 요약
* HTTP 메소드가 서버에게 무엇을 해야할지 요청하듯, HTTP 상태 코드는 응답에 포함된 시작줄에 명시되어 클라이언트에게 작업 결과를 알려준다.
  * 예를 들어, 서버는 클라이언트의 요청을 처리하는 데에 성공했거나 해당 리소스를 찾지 못했을 수 있으며 이러한 결과를 HTTP 상태 코드로 표현한다.
* HTTP 상태 코드는 숫자로 작성된 코드와 문자열로 작성된 메시지인 사유 구절 형태로 구분되며, **세 자리 숫자로 백의 자리의 값에 따라 묶여 취급**된다.
  * 예를 들어, `1xx`는 정보를 의미하며 `2xx`는 성공을 의미한다.
* HTTP는 명세 상 각 범위의 일부만을 정의하며, 이는 추후 프로토콜이 진화함에 따라 더 많은 상태 코드 정의가 HTTP 명세에 포함될 가능성을 열어두었다.
* 때문에 클라이언트가 인식하지 못하는 상태 코드를 수신했을 경우, 이는 해당 서버가 현재 HTTP 명세를 의도적으로 확장하여 사용하고 있음을 의미할 수 있다.
  * 이 경우, **클라이언트는 해당하는 사용자 정의 상태 코드를 마치 임의의 범위 구간에 포함되는 것처럼 간주하도록 동작**해야 한다.

## 2025-12-21 Sun
### 사유 구절이란?
* 응답에 포함된 시작줄의 마지막 구성 요소인 사유 구절은 해당 응답에 명시된 HTTP 상태 코드에 대한 문자열 형태의 설명을 지칭한다.
    * 예를 들어, 임의의 응답에 포함된 시작줄이 `HTTP/1.1 200 OK`라면 사유 구절은 `OK`가 된다.
* 모든 사유 구절은 임의의 HTTP 상태 코드와 일대 일 대응되며, 마치 HTTP 상태 코드의 읽기 쉬운 버전처럼 취급할 수 있다.
* 이 때, **HTTP 명세는 사유 구절을 엄격히 정의하지 않으므로 개발자는 자신만의 사유 코드를 정의하여 사용하더라도 HTTP 명세를 위반하지 않는다**.

## 2025-12-22 Mon
### 버전 번호란?
```
> 버전 번호는 HTTP 애플리케이션이 지원하는 가장 높은 HTTP 버전을 명시하며, 해당 애플리케이션이 어느 HTTP의 어느 버전까지 이해할 수 있는지를 의미한다.
```
* 버전 번호는 `HTTP/x.y` 형태로 요청과 응답 각각에 포함되는 시작줄에 모두 명시된다. 
  * 이는 각 **HTTP 애플리케이션이 자신이 사용하는 프로토콜 버전을 상대에게 알리기 위해 사용**될 수 있다.
* 버전 번호는 HTTP 애플리케이션들이 상대의 능력과, 사용하는 형식에 대한 단서를 제공하기 위해 사용된다.
  * 예를 들어, `1.1` 버전을 사용하는 애플리케이션은 `1.0`을 사용하는 애플리케이션과 통신하는 과정에서 `1.1`의 신규 기능을 사용할 수 없음을 알 수 있다.
* HTTP 버전 번호는 `/`로 구분되지만 분수로 읽히지 않으며, `x`와 `y`를 각각 별도로 비교한다.
  * 예를 들어, `2.22`는 `2.3`의 경우 22와 3을 비교했을 때 더 큰 수를 갖는 `2.22`가 더 높은 버전임을 알 수 있다.

## 2025-12-23 Tue
### HTTP 헤더 분류하기
* HTTP 명세는 여러 헤더 필드를 정의하며, 애플리케이션 개발자 역시 자신만의 헤더를 자유롭게 정의할 수 있다.
* 이 때, 헤더는 분류에 따라 다음과 같이 나누어 이해할 수 있다.
  1. 일반 헤더: 요청과 응답 모두가 사용할 수 있다.
  2. 요청 헤더: 요청에 대한 부가 정보를 제공한다.
  3. 응답 헤더: 응답에 대한 부가 정보를 제공한다.
  4. 엔티티 헤더: 본문의 크기나 컨텐츠 또는 리소스 그 자체를 서술한다.
  5. 확장 헤더: HTTP 명세에 정의되지 않는 새로운 헤더를 지칭한다.
* 모든 HTTP 헤더는 `<키>: <값> <CRLF>` 순서로 작성되며, 값과 콜론 사이의 공백은 있거나 없어도 무방하다.
  * 반면, **값의 길이가 너무 길다면 가독성을 위해 여러 줄로 쪼갤 수 있으나 이 경우 각 줄의 앞에는 최소 하나의 공백 또는 탭 문자가 작성**되어야 한다.

## 2025-12-24 Wed
### 안전한 HTTP 메소드
* HTTP는 안전한 메소드라고 불리우는 집합을 정의하며, `GET`과 `HEAD`는 이에 포함된다.
    * 이는 즉, 상술한 두 메소드의 처리 결과로는 서버에 어떠한 부작용도 발생하지 않음을 의미한다.
    * 예를 들어, 임의의 리소스를 서버로부터 조회하더라도 해당 리소스의 상태는 변경되지 않는다.
* 반면, 안전한 메소드가 어떠한 부작용도 일으키지 않는다는 사실은 HTTP 명세의 엄격한 규칙은 아니며 어디까지나 서버 개발자의 구현에 따라 결정된다.
* **안전한 메소드의 목적은 '안전하지 않은 메소드'를 호출할 때 무언가 부작용이 발생할 수 있다는 사실을 클라이언트에게 알려주는 데**에 있다.

## 2025-12-25 Thu
### HTTP 메소드 - GET과 HEAD
```
> 임의의 서버가 HTTP/1.1과 호환되고자 하는 경우, 자신의 리소스에 대해 `GET`과 `HEAD`를 구현해야 한다.
```
* `GET`은 가장 자주 사용되는 메소드로, 서버에 임의의 리소스를 요청하는 데에 사용된다.
* **`HEAD`는 `GET`처럼 행동하지만, 서버는 응답으로 본문 대신 헤더만을 반환**한다.
    * 덕분에 클라이언트는 리소스 자체를 확인하지 않더라도 리소스의 타입이나 존재 여부, 변경 여부 등의 메타데이터만을 조회할 수 있다.
* **서버 개발자는 `HEAD` 메소드를 구현하는 경우 해당 메소드의 반환 헤더가 `GET`의 호출 결과에 포함된 헤더와 정확히 같음을 보장**해야 한다.
* 또한, `GET`과 `HEAD`는 모두 요청에 별도의 본문을 포함하지 않는다.

## 2025-12-26 Fri
### HTTP 메소드 - PUT
* `PUT` 메소드는 서버에 리소스를 쓰는 방식으로 동작하며, 요청 URL의 이름대로 새로운 문서를 생성하거나 기생성된 문서를 교체한다.
    * 즉, 리소스가 없을 때 `PUT` 메소드를 호출하면 처리 결과에 의해 새로운 리소스가 생성된다.
    * 반면, 리소스가 있는 경우 `PUT` 메소드를 호출하면 처리 결과에 의해 해당 리소스가 변경된다.
* 일반적으로 `PUT`은 리소스를 변경하는, '안전하지 않은 메소드'에 해당하므로 인증과 인가가 요구된다.

## 2025-12-27 Sat
### HTTP 메소드 - POST
* `POST` 메소드는 서버에 입력 데이터를 전송하기 위해 설계되었다는 점에서 `PUT`과는 차이가 있다.
    * 다시 말해, **`PUT`은 서버가 관리하는 임의의 리소스에 데이터를 입력하기 위해 사용**된다.
    * 반면, **`POST`는 서버에 데이터를 보내는 것 자체에 그 의의**를 둔다.
* 서버는 `POST` 메소드를 통해 전달된 데이터를 필요한 다른 곳에 포워딩하거나, 자신이 직접 처리할 수 있다.

## 2025-12-28 Sun
### HTTP 메소드 - TRACE
* 클라이언트의 요청은 방화벽이나 프록시 및 게이트웨이 등 다양한 매체를 경유하여 서버에 전달될 수도 있으며, 이 경우 요청은 중간에 변조될 가능성이 있다.
* **`TRACE` 메소드는 이러한 경우에 고려될 수 있으며, 클라이언트에게 자신의 요청이 서버에 도달했을 때 어떤 모습을 갖는지 알려준다**.
  * 요청의 마지막 단계에 있는 서버는 자신이 받은 요청 메시지를 본문에 그대로 반환하며, 클라이언트는 이를 통해 요청이 어떻게 변경되는지 확인할 수 있다.
* `TRACE` 메소드는 주로 진단을 위해 사용되지만, 중개자들이 여러 HTTP 메소드에 대해 일관된 동작을 보장한다고 가정한다는 한계를 갖는다.
  * 실제로는 프록시와 같은 중개자들은 `POST`와 `GET`에 대해 서로 다른 동작을 수행하는 경우가 많다.
  * 다시 말해, **`TRACE` 메소드는 HTTP 메소드를 구별할 수 있을만한 별도의 기능을 제공하지 않는다**.
* `TRACE` 역시 다수의 HTTP 메소드와 같이 요청에 별도의 본문을 포함하지 않는다.

## 2025-12-29 Mon
### HTTP 메소드 - OPTIONS
* **`OPTIONS` 메소드는 서버에게, 임의의 리소스에 대한 지원 범위에 대해 질의하기 위해 사용되는 HTTP 메소드**이다.
    * 다시 말해, 서버에게 임의의 리소스에 대한 어떤 HTTP 메소드 요청을 허용하는지 질의한다.
* `OPTIONS` 메소드를 사용하며 클라이언트는 리소스에 대해 실제로 접근하여 결과를 확인하는 식으로 동작할 필요 없이도 어떻게 접근해야할지 확인할 수 있다.
* `OPTIONS` 역시 다수의 HTTP 메소드와 같이 요청에 별도의 본문을 포함하지 않는다.

## 2025-12-30 Tue
### HTTP 메소드 - DELETE
* 명시적인 이름에서도 알 수 있듯, `DELETE` 메소드는 서버에게 해당 리소스를 삭제할 것을 요청한다.
* 반면, **클라이언트는 `DELETE` 호출을 통해 해당 리소스가 반드시 삭제될 것을 보장받을 수는 없다**.
    * 이는 **HTTP 명세 자체적으로 서버가 클라이언트에게 알리지 않고 삭제 요청을 무시하는 것을 허용하기 때문**이다!
* `DELETE` 역시 다수의 HTTP 메소드와 같이 요청에 별도의 본문을 포함하지 않는다.

## 2025-12-31 Wed
### HTTP 메소드 - 확장 메소드
```
> 확장 메소드는 `HTTP/1.1`에 정의되지 않은 메소드를 지칭한다.
```
* HTTP는 명세상 필요에 따라 확장할 수 있음을 보장하므로, 새로운 기능을 추가하더라도 기존 애플리케이션들의 오동작을 유발하지 않는다.
* 확장 메소드는 개발자들에게 자신이 구현한 서버가 관리하는 리소스에 대한 능력을 확장하는 수단으로써 기능한다.
* 잘 알려진 확장으로 `LOCK`이나 `COPY`, `MOVE` 등이 존재하지만 이들은 HTTP 명세에 정의된 것이 아님에 주의해야 한다.
    * 때문에 대부분의 애플리케이션은 이러한 확장 메소드를 이해하지 못하며, 내 애플리케이션조차 이해할 수 없는 메소드 요청을 수신할 수 있다.
* 반면, **확장 메소드에 대해서는 관용적으로 동작할 수 있도록 서버를 구현하는 것이 권장**된다.
    * 예를 들어, 알려지지 않은 메소드에 대한 요청에 대해서는 501 코드를 반환하는 식으로 구현해볼 수 있다.
    * 이렇듯 **확장 메소드와 같은 확장을 다루는 경우에는 '엄격하게 보내고 관대하게 받아들이기'라는 규칙을 따르는 것이 바람직**하다.

## 2026-01-01 Thu
### HTTP 상태 코드 - 100 Continue
```
> 상태 코드 100-199 구간은 정보성 상태 코드를 의미하며, 대표적으로 100과 101이 존재한다.
> 해당 구간의 코드는 서버와의 통신 과정에서 주로 최종 응답이 아닌 임시 응답의 뉘앙스로 사용된다.
```
- 클라이언트가 요청시 본문을 포함하지 않고 `Expect: 100-Continue`를 전송했을 때, 이는 다음과 같은 의미를 갖는다.
    - 클라이언트는 서버에게 본문을 전송하고자 한다.
    - 클라이언트는 서버가 다룰 수 없거나 너무 큰 본문을 보내지 않도록 확인하고자 한다.
- 초기에는 100 상태 코드를 잘못된 용도로 사용한 경우가 많았기에, 서버가 100으로 응답하지 않았더라도 클라이언트가 본문을 보내는 것이 권장된다.
- **서버는 `Expect: 100-Continue` 헤더가 포함된 요청에 대해 `100 Continue` 또는 에러 코드로 답해야 한다**.
    - 바꿔 말해, **서버는 이 외의 경우에는 절대로 `100 Continue`로 응답하지 않아야 한다**.
- 반면, 서버가 `100 Continue`를 보내기 전에 이미 본문을 수신했다면 서버는 해당 상태 코드로 응답할 필요가 없다.
    - 대신 모든 본문을 읽을 후에 최종 상태 코드로 응답할 필요가 있다.
- 서버는 `100 Continue`를 기대한 요청에 대해 에러로 응답하고자 하는 경우, 클라이언트가 응답을 받도록 구현해야 한다.

## 2026-01-02 Fri
### HTTP 상태 코드 - 101 Switching Protocols
- `101`은 서버가 클라이언트의 프로토콜 변경 요청을 수락했을 때 사용된다.
- 대표적인 예시로는 `WebSocket` 연결이 있으며, 다음과 같은 시나리오에 따라 프로토콜을 변경하게 된다.
    1. 클라이언트가 `Upgrade: websocket` 헤더를 포함하여 요청하는 것으로 HTTP 대신 `WebSocket` 사용을 제안한다.
    2. 서버는 이를 수락할 경우 `101 Switching Protocols` 응답을 반환한다.
    3. 이후 통신은 `WebSocket`을 기반으로 진행된다.

## 2026-01-03 Sat
### HTTP 상태 코드 - 2xx
- 클라이언트가 전송한 요청은 대부분의 경우에 성공하며, 서버는 성공을 의미하기 위해 `2xx` 응답을 사용할 수 있다.
- `200 OK`의 경우,  요청이 정상적으로 처리되었으며 엔티티 본문에 요청된 리소스가 포함된다.
- `201 Created`의 경우, 요청 성공에 신규 리소스가 생성되었다는 의미를 명확히하기 위해 사용된다.
    - 이 때, 새로운 리소스의 위치를 응답 헤더의 `Location: /resources/1`과 같이 명시하는 것이 권장된다.
- `202 Accepted`의 경우, 요청은 정상적으로 접수되었으나 서버가 동작을 수행하지 않았음을 의미한다.
    - 때문에 **해당 응답 코드의 경우, 서버가 요청의 처리를 정상적으로 완료할 것인지 보장할 수 없다**.
    - `202 Accepted` 응답은 주로 오랜 시간이 걸리는 비동기 처리 작업 요청에 대한 응답으로 사용된다.
- `204 No Content`의 경우, 요청은 성공했으나 응답할만한 본문이 딱히 없는 경우에 사용될 수 있다.
    - 예를 들어, `DELETE`에 대한 응답은 돌려줄만한 데이터가 없기에 해당 상태 코드를 적용하기에 바람직하다.
    - 또한, 브라우저가 해당 응답을 받은 경우 페이지를 새로고침하지 않고 유지하며 화면만을 갱신하므로 효율적이다.

## 2026-01-04 Sun
### HTTP 상태 코드 - 300 Multiple Choices
- **`3xx` 코드는 리다이렉션 상태 코드이며, 클라이언트가 원하는 리소스에 대해 다른 위치를 사용하도록 유도하거나 다른 대안 응답을 제공하기 위해 사용**된다.
    - 예를 들어, 리소스의 위치가 변경된 경우 리다이렉션 상태 코드와 옮겨진 리소스의 위치를 `Location` 헤더에 명시할 수 있다.
    - 또한, 브라우저는 이에 대해 사용자를 귀찮게 하는 대신 직접 새로운 위치를 이동하는 식으로 편의성을 높인다.
- `300 Multiple Choices`는 클라이언트가 요청한 리소스에 대해 서버가 반환할 수 있는 데이터가 여럿인 경우에 고려할 수 있다.
    - 예를 들어, 요청 받은 임의의 영상 리소스의 확장자가 하나 이상인 경우 해당 상태 코드와 함께 목록을 반환하여 브라우저의 선택을 유도할 수 있다.
- 그러나 현재로서는 컨텐츠 협상 기술의 발달로 인해 거의 사용되지 않으며, 대신 `Accept: video/mp4`와 같은 헤더를 활용하는 것이 권장된다.

## 2026-01-05 Mon
### HTTP 상태 코드 - 301 Moved Permanently
- `301 Moved Permanently`의 경우, 요청된 URL의 리소스가 영구적으로 옮겨졌을 때 사용될 수 있다.
    - 때문에 응답 헤더에는 `Location` 정보가 명시될 필요가 있으며, 이를 통해 브라우저는 새로운 리소스 주소를 캐싱한 후 즉시 요청할 수 있도록 한다.
- 반면, **해당 상태 코드는 HTTP 상태 코드를 유지하지 않고 `GET`으로 변경하므로 데이터 유실 가능성이 있음에 주의**해야 한다.
    - 이에 이를 보완한 `308 Permanent Redirect`가 제안되었으며, 이 경우 HTTP 메소드를 유지하는 특징이 있다.

## 2026-01-06 Tue
### HTTP 상태 코드 - 302 Found
- `302 Found`의 경우 리소스가 일시적으로 다른 곳에 있음을 의미하며, 임시 이동에 해당하므로 `301`과 달리 새로운 주소를 캐싱하지 않는다.
  - 또한, 이 역시 `301`과 동일하게 데이터 유실 가능성을 수반하므로 `307 Temporary Redirect` 코드가 고안되었다.
- `302 Found` 역시 리다이렉션 상태 코드에 해당하므로, 응답 헤더의 `Location`을 명확히 명시해줄 필요가 있다.

## 2026-01-07 Wed
### HTTP 상태 코드 - 303 See Other
- `303 See Other`는 클라이언트에게 리소스를 다른 URL로부터 조회할 것을 권장하기 위해 사용하며, 역시 `Location` 헤더를 활용한다.
- 해당 상태 코드는 **주로 `POST` 요청에 대한 응답으로 리소스의 위치를 반환하기 위해 사용**된다.
  - 관련된 패턴으로는 `Post-Redirect-Get` 패턴이 있으며, 작업 결과를 다른 곳에서 확인하도록 유도하는 뉘앙스를 갖는다.
- 이 때, 해당 상태 코드는 요청 메소드와 관계 없이 반드시 `GET`으로 리다이렉트하도록 강제하는 특징을 갖는다.
  - 이는 **`302 Found`와 유사하지만, `302`가 잘못된 관례가 고착된 경우라면 `303`은 명세상 `GET`으로 바꿀 것을 명시하는 표준**에 해당한다.
  - 실무 관점의 경우, RESTful API를 엄격히 설계하는 개발자들은 리소스 생성 요청에 대해 해당 상태 코드를 적극적으로 사용한다.

## 2026-01-08 Thu
### 참고 - 리소스 생성시 응답 상태 코드
- 상술한 내용에 따라, 리소스 생성에 대한 서버의 응답으로는 `201`과 `303`을 고려할 수 있다.
- 이 중, **일반적으로 가장 권장되는 응답은 `201 Created`임에 주의**할 필요가 있다.
    - `201`의 경우, `Location` 헤더에 새로 생성된 리소스의 경로를 명시함과 동시에 본문을 통해 생성된 리소스에 대한 JSON 문서를 반환할 수 있다.
    - 때문에 **클라이언트는 단 한 번의 요청만으로도 생성 요청과 요청 처리 결과, 생성된 리소스의 모든 정보를 반환받을 수 있기에 효율적**이다.
- 반면, `303 See Other`의 경우 생성된 리소스에 대한 추가적인 `GET` 요청을 유발하므로 트래픽이 많은 API에서는 성능적인 아쉬움을 갖는다.
- 그러나 `303`의 진가는 브라우저 환경에 있으며, 생성 요청 후 브라우저에 의한 강제 리다이렉션이 유발되는 PRG 패턴을 적용할 수 있다.
    - 이 경우, **리소스 생성 요청 후 사용자 실수에 의한 새로고침 상황에서 리소스 중복 생성을 방지**할 수 있다.

## 2026-01-09 Fri
### HTTP 상태 코드 - 304 Not Modified
- `304 Not Modified`의 경우 리다이렉션보다는 재사용에 가까운 뉘앙스를 주며, 웹 성능 최적화의 핵심에 위치하는 상태 코드로 이해할 수 있다.
- 예를 들어 `image.png`를 다운로드 받은 경우, 서버에게 `If-Modified-Since` 헤더를 포함하는 `GET` 요청으로 리소스의 수정 여부를 질의할 수 있다.
  - 서버는 이를 확인한 후 수정되지 않았다면 본문이 포함되지 않은 `304` 응답을 반환하는 것으로 브라우저가 캐시의 파일을 그대로 사용할 수 있도록 유도한다.

## 2026-01-10 Sat
### 참고 - 302 Found와 307 Temporary Redirect
- `HTTP/1.0`을 사용하는 클라이언트가 POST에 대해 `302`를 수신한 경우, `Location`에 포함된 위치에 `GET` 요청을 전송하는 식으로 리다이렉션한다.
  - 이는 바꿔 말해, **HTTP/1.0 서버 역시 이러한 동작을 기대하고 `302`를 반환할 것임을 의미**한다.
- 그러나 HTTP/1.1 명세는 상술한 형태의 리다이렉션에 `303`을 권장하므로, 두 버전의 혼용에 의한 혼란이 유발되었다.
- 이러한 혼란을 방지하기 위해 HTTP/1.1 명세는 일시적인 리다이렉트에 `307`을 사용할 것을 권장한다.
  - 이는 서버가 HTTP/1.0 클라이언트를 위해 `302` 응답을 남겨두는 것으로 하위호환성을 유지할 수 있도록 하기 위한 조치이다.
  - 바꿔 말해, **서버는 리다이렉트 응답에 사용할 적절한 코드를 선택하기 위해 클라이언트의 HTTP 버전을 검사할 필요**가 있다.

## 2026-01-11 Sun
### HTTP 상태 코드 - 4xx
```
> 서버는 잘못한 게 없으니, 클라이언트가 확인하라
```
- 서버가 다룰 수 없는 데이터를 클라이언트가 요청한 경우, 서버는 `4xx` 응답을 반환한다.
- 이 때, 대표적인 `4xx` 응답 코드는 다음과 같이 정리할 수 있다.
  1. `400 Bad Request`: 클라이언트의 요청 문법이 잘못되었거나, 필요한 파라미터가 누락되거나 데이터 타입이 일치하지 않는다.
  2. `401 Unauthorized`: 인증이 필요하지만 사용자가 인증되지 않았음을 의미하며, 주로 `Authorization` 헤더의 누락으로 인해 발생한다.
  3. `403 Forbidden`: 인증된 사용자의 권한 부족으로 인한 인가 실패 상황을 의미한다.
  4. `404 Not Found`: 클라이언트의 요청 리소스가 존재하지 않음을 의미하며, 때로는 데이터가 물리적으로 존재하더라도 이를 숨기기 위해 사용될 수도 있다.

## 2026-01-12 Mon
### HTTP 상태 코드 - 409 Conflict
- `409 Conflict`는 요청 자체는 문법적인 이상이 없어 `400`이 아니지만, 데이터의 무결성이나 비즈니스 로직 상 다양한 상황에서 도입될 수 있다.
- 예를 들어, `409` 응답이 적용될 수 있을만한 대표적인 상황은 다음과 같다.
  1. UNIQUE 제약 조건: Id 충돌 등으로 인한 유일성 제약 조건이 위배될 수 있는 경우
  2. 상태 충돌: 주문을 예로 들어, 이미 배송된 주문을 취소하고자 하는 경우
  3. 동시성 제어: 여러 클라이언트가 동일한 리소스를 동시에 수정하고자 하는 경우
  4. 관계에 의한 처리 불가: 예를 들어 임의의 폴더에 파일이 생성되어 있어 정책상 삭제할 수 없는 경우
- 일반적으로 `400 Bad Request`와 혼동되곤 하지만, 두 상태 코드는 다음과 같이 차이점을 정의할 수 있다.
  1. `400 Bad Request`: **애초에 말이 되지 않는 요청이 전송**된 경우
  2. `409 Conflict`: **요청 자체는 말이 되지만, 논리적으로 허용 불가능한 요청**이 전송된 경우

## 2026-01-13 Tue
### HTTP 상태 코드 - 410 Gone
- `410 Gone` 상태 코드는 **과거엔 있었던 리소스이나, 의도적으로 영원히 제거되어 다시 복구할 수 없다는 뉘앙스를 주기 위해 사용**된다.
  - `404 Not Found`의 경우 해당 **리소스가 원래 없었는지, 잠깐 제거되었는지 등의 정보를 줄 수 없다는 점과 비교되는 `410`의 특징에 해당**한다.
- `410` 응답 코드는 검색 엔진과 봇에 대해 다시는 해당 리소스가 돌아오지 않는다는 의미를 전달하므로, 이후 발생할 수 있는 불필요한 요청을 방지한다.
  - 반면, `404` 응답의 경우 해당 리소스가 언젠가 생성될 수도 있기에 검색 엔진과 봇의 불필요한 요청을 유발한다.
- 실무적 관점에서, 대부분의 경우 `404`를 사용하지만 `더 이상 관리되지 않고, 앞으로도 관리되지 않을` 뉘앙스를 명확히 전달하기 위해 고려될 수 있다.

## 2026-01-14 Wed
### HTTP 상태 코드 - 5xx
- 클라이언트가 올바른 요청을 전송했으나, 클라이언트 외적인 오류로 인해 응답할 수 없는 경우 `5xx` 응답 코드를 확인할 수 있다.
- 이 때, 대표적인 `5xx` 응답 코드는 다음과 같이 정리할 수 있다.
  1. `500 Internal Server Error`: 버그 등에 의해 서버 측 에러가 발생했으나, 그 원인을 명확히 알려주고 싶지는 않은 경우에 적용할 수 있다.
  2. `501 Not Implemented`: 서버가 지원하지 않는 기능을 요청한 경우에 대한 응답으로 고려될 수 있다.
  3. `502 Bad Gateway`: 프록시용 서버가 요청 응답 연쇄 상 다음 링크에 위치한 서버에 접근할 수 없는 경우를 의미한다.
  4. `503 Service Unavailable`: 서버가 동작하고 있으나, 점검 또는 과부하 등의 원인으로 인해 현재로서는 응답할 수 없음을 의미한다.
  5. `504 Gateway Timeout`: 프록시용 서버가 시간 내에 다음 링크에 위치한 서버로부터 응답을 받지 못한 경우를 의미한다.
- 반면, **`503`의 경우 응답에 포함된 `Retry-After` 헤더에 초 단위로 표현된 정수를 명시하여 클라이언트에게 복구 시점을 알려주는 것이 권장**된다.

## 2026-01-15 Thu
### HTTP 헤더 분류하기
- 헤더와 메소드는 클라이언트와 서버가 각각 무엇을 할지 결정하기 위한 정보이며, 특히 헤더의 경우 다음과 같은 분류가 가능하다.
  1. 일반 헤더: 클라이언트와 서버가 모두 사용할 수 있는 일반적인 목적의 헤더이다.
  2. 요청 헤더: 요청 메시지에 사용되는 헤더이며, 클라이언트가 서버에게 부가 정보를 전달하기 위해 사용할 수 있다.
  3. 응답 헤더: 클라이언트에게 추가적인 정보를 전달하기 위해 서버가 사용하는 헤더이다.
  4. 엔티티 헤더: 본문에 삽입된 데이터에 대한 정보를 전달하기 위한 헤더이다.
  5. 확장 헤더: 애플리케이션 개발자들에 의해 추가된 사용자 정의 헤더이며, HTTP 명세에 정의되지 않은 비표준 헤더를 지칭한다.
- 특히, HTTP 애플리케이션은 공식적으로 정의되지 않은 비표준 헤더인 확장 헤더 역시 서로에게 올바르게 주고 받아야할 책임을 갖는다.

## 2026-01-16 Fri
### HTTP와 TCP/IP의 관계
```
> HTTP 커넥션은 대부분의 경우 TCP 커넥션에 불과하다.
```
- 일반적인 HTTP 역시 TCP/IP를 기반으로 하며, 임의의 HTTP 요청은 다음과 같이 처리된다.
  1. 브라우저는 URL로부터 호스트 정보를 추출하여 적절한 IP 주소를 찾는다.
  2. 브라우저는 URL로부터 포트 정보를 추출하여 서버측 애플리케이션으로 향하는 TCP 커넥션을 생성한다.
  3. 브라우저는 2.의 커넥션을 통해 HTTP GET 요청 메시지를 전송한다.
  4. 서버는 요청에 대한 처리 결과를 반환한다.
  5. 브라우저는 서버의 응답을 읽어들인 후, 커넥션을 끊는다.

## 2026-01-17 Sat
### TCP란?
- TCP/IP를 사용하는 클라이언트는원하는 때에 서버로 TCP/IP 커넥션을 맺을 수 있으며, 이 경우 메시지는 손상되거나 순서가 바뀌지 않고 전달된다.
  - 때문에 HTTP로 메시지를 전송하는 경우, 현재 연결된 TCP 커넥션을 통해 메시지에 포함된 데이터가 순차적으로 전달된다.
- TCP는 세그먼트라는 단위로 데이터 스트림을 나누고, 이렇게 나뉘어진 세그먼트를 다시 IP 패킷에 담아 전달한다.
  - 이러한 과정은 모두 TCP/IP 계층을 담당하는 애플리케이션에 의해 처리되므로, HTTP 개발자는 이를 신경쓸 필요가 없다.
  - IP 패킷은 IP 패킷 헤더와 TCP 세그먼트 헤더 및 TCP 데이터 조각으로 구성된다.
  - 반면, TCP 세그먼트 헤더는 TCP 포트 번호와 제어 플래그 및 데이터 무결성을 검증하기 위한 숫자 값을 포함한다.

## 2026-01-18 Sun
### TCP 커넥션 구성 요소
- 컴퓨터는 기본적으로 여러 개의 TCP 커넥션을 처리하며, TCP는 포트 번호를 통해 여러 개의 커넥션을 유지한다.
- 이 때, **각각의 TCP 커넥션은 다음과 같은 네 가지 구성 요소의 조합으로 유일하게 식별**된다.
  1. 발신지 IP 주소
  2. 발신지 포트 번호
  3. 수신지 IP 주소
  4. 수신지 포트 번호
- 때문에 임의의 서버는 동일한 포트 번호에서 여러 개의 TCP 커넥션을 구분하여 관리할 수 있다.
  - 반면, **현대적인 서버는 대부분의 경우 하나의 리스닝 포켓을 열어두고 새로운 연결 요청에 대해 전용 소켓을 생성하여 연결을 수립**하는 경우가 많다.

## 2026-01-19 Mon
### TCP 소켓 프로그래밍이란?
- 운영체제는 TCP 커넥션 생성과 관련된 여러 기능을 제공하며, 이를 위한 TCP 프로그래밍 인터페이스를 구현하는 소켓 API는 TCP와 IP의 세부 구현을 숨긴다.
  - **소켓 API는 유닉스 운영체제용으로 개발되었으나, 현대에 이르러서는 다양한 구현체들로 인해 대부분의 운영체제와 프로그래밍 언어에서 사용**할 수 있다.
- 소켓 API를 사용하면 TCP 엔드포인트가 되는 데이터 구조를 생성하고, 원격 서버의 TCP 엔드포인트에 이를 연결할 수 있다.
  - 이 때, 연결된 후에는 이를 통해 데이터 스트림을 읽고 쓸 수 있다.
  - 반면, **이러한 API는 기본적인 핸드셰이크와 TCP 데이터 스트림의 분할 및 재조립과 관련된 세부 사항을 개발자가 신경쓰지 않도록 숨기는 역할**을 맡는다.

## 2026-01-20 Tue
### HTTP와 TCP 네트워크 지연
- HTTP는 TCP 위에서 동작하는 계층이므로, 트랜잭션의 성능 역시 TCP 성능에 직접적인 영향을 받는다.
- HTTP 통신 시간은 DNS 동작 이후에 커넥션 연결과 요청, 요청에 대한 처리와 결과를 응답하고 종료하는 과정 전체를 포함한다.
  - 이 때, 트랜잭션 처리 시간을 제외한 다른 모든 과정을 위해 소요되는 시간에 비해 트랜잭션 처리 시간은 적은 시간을 요구한다.
- 이렇듯 **HTTP 트랜잭션을 지연시키는 직접적인 원인은 TCP 네트워크의 지연**으로, 크게 다음과 같이 정리할 수 있다.
  1. 임의의 호스트에 대한 첫 요청시 발생하는 DNS 처리 시간
  2. 서버로의 TCP 커넥션 수립 요청과 이에 대한 서버의 응답 대기 시간
  3. 커넥션이 수립된 후 이를 통해 HTTP 요청을 전송하고, 서버에 의해 처리되는 시간
  4. 서버에 의해 처리된 결과가 응답되기까지의 시간
- 또한, TCP 네트워크 지연은 하드웨어의 성능과 네트워크 속도 및 요청과 응답의 크기에도 영향을 받을 수 있다.
  - 심지어는 클라이언트와 서버 간의 물리적인 거리나, TCP 자체의 기술적 복잡성 역시 주요한 원인이 될 수 있다.

## 2026-01-21 Wed
### 일반적인 TCP 관련 지연들
- 상술한 요인 외에도, HTTP 기반 개발자에게 영향을 줄 수 있을만한 성능 상의 문제는 다음과 같은 지연들로부터 발생할 수 있다.
  1. TCP 커넥션 핸드셰이크 설정
  2. 혼잡 제어를 위한 TCP의 느린 시작
  3. 네이글 알고리즘
  4. TCP piggyback ACK를 위한 ACK 지연
  5. TIME_WAIT 지연과 포트의 고갈
- 일반적인 기준보다좋은 성능을 목표로 하는 HTTP 애플리케이션을 개발하기 위해서는 이러한 요소를 모두 신경쓸 필요가 있다.

## 2026-01-22 Thu
### TCP 커넥션 핸드셰이크 지연
- 일반적인 3-Way TCP 커넥션 핸드셰이크는 다음과 같이 진행된다.
  1. 클라이언트는 새로운 TCP 커넥션을 생성하기 위해 `SYN` 플래그를 포함하는 작은 패킷을 전송한다.
  2. 서버는 해당 TCP 패킷을 분석하고, 커넥션 요청을 받아들이기 위해 `SYN`과 `ACK`가 포함된 패킷을 전송한다.
  3. 클라이언트는 커넥션 수립 완료를 알리기 위해 `ACK`를 보내며, 이 때 데이터를 함께 전송할 수 있다.
- 그러나 **어떤 때라도 새로운 TCP 커넥션을 여는 과정에서는 위와 같은 연속적인 IP 패킷 교환이 전제**된다.
  - 바꿔말해, 아무리 작은 데이터를 전송할 때라도 TCP 커넥션을 사용하는 이상 패킷 교환은 필수적이다.
  - 즉, **데이터의 크기가 충분히 작다면 데이터 전송보다 패킷 교환에 더 많은 비용을 소모**해야할 수 있다.
- 반면, HTTP 계층의 관점에서 TCP 계층은 추상화되므로 상술한 연속적 패킷 교환 과정은 HTTP 계층에서 알 수 없다.
  - 단지 **HTTP 계층에서 체감할 수 있는 것은 암시적으로 진행되는 TCP 패킷 교환으로 인한 지연** 뿐이다.
- 상술한 **TCP 구성 과정에서 기인하는 지연을 제거하기 위해서는 이미 존재하는 커넥션을 재활용하는 것을 고려**해볼 수 있다.

## 2026-01-23 Fri
### ACK 응답 지연
- **인터넷이라는 환경 자체가 무결한 패킷 전송을 보장하지 않는다는 점에서 TCP는 무결성 보장을 위해 자체적인 확인 체계**를 갖는다.
  - 단적인 예로, 라우터는 과부하 상황에서 패킷을 마음껏 파기할 수 있다.
- 다시 말해, 각각의 TCP 세그먼트는 순번과 무결성 체크섬을 가지며 수신자는 이를 확인하여 수신을 확인하기 위한 ACK를 전송한다.
  - 송신자 입장에서, 임의의 데이터에 대해 일정 시간 안에 ACK를 수신하지 못한 경우 해당 데이터를 재전송한다.
- 이러한 **ACK는 크기가 작기 때문에 TCP는 필요한 데이터에 ACK를 함께 전송할 수 있으며, 이를 piggyback이라는 용어로 지칭**한다.
  - 이는 즉 데이터 패킷과 ACK를 하나로 묶어 네트워크를 효율적으로 사용하기 위함이다.
- 반면, **많은 TCP 구현체는 piggyback의 빈도를 높이기 위해 ACK 응답 지연 알고리즘을 구현**한다.
  - 예를 들어, 전송해야 할 ACK를 별도의 버퍼에 일정 시간 저장해둔 후 그 시간 내에 송출 데이터가 발생하면 piggyback으로 반환한다.
  - 반면, 일정 시간 내에 송출 데이터가 발생하지 않는다면 ACK는 별도의 패킷으로 전송된다.
- 그러나 **HTTP 트랜잭션은 요청과 응답으로 구성되므로, piggyback이 발생할 가능성이 낮아 ACK 응답 지연으로 인한 지연이 발생**하기 쉽다.
- 물론 ACK 지연 관련 기능을 수정하거나 비활성화하는 것은 가능하지만, 이러한 설정으로 인해 부작용이 발생하지 않는다는 명확한 근거 하에 진행해야 한다.

## 2026-01-24 Sat
### TCP의 느린 시작
- TCP의 데이터 전송 속도는 TCP 커넥션이 생성되고 얼마나 지났는지에 따라 달라질 수 있으며, 이렇듯 **TCP 커넥션은 시간에 따라 자체적으로 최적화**된다.
  - 예를 들어, 최초에는 최대 속도를 제한하되 점진적으로 속도 제한을 높여나간다.
  - 이러한 TCP의 동작 방식을 **느린 시작이라는 용어로 지칭하며, 이는 인터넷 상에서 발생할 수 있는 혼잡을 방지하는 데에 의의**를 갖는다.
- TCP의 느린 시작은 TCP가 한 번에 전송할 수 있는 패킷 수를 제헌하며, ACK를 받아갈수록 전송 가능한 패킷의 양이 늘어난다.
  - 이는 `congestion window`와 관련이 있으며, 이로 인해 새로운 커넥션은 보다 오래 사용된 커넥션보다 느리게 동작한다.
- 즉, **HTTP 통신의 경우 일반적으로 이미 생성된 TCP 커넥션을 재사용하는 것이 성능 상 유리**할 수 있다.

## 2026-01-25 Sun
### 네이글 알고리즘과 TCP_NODELAY
- 각 TCP 세그먼트는 여러 플래그와 헤더가 포함되므로, 크기가 작은 데이터를 포함한 세그먼트를 많이 전송할 경우 네트워크 성능은 크게 저하된다.
- 이 때, **네이글 알고리즘은 네트워크 효율성을 위해 패킷을 전송하기 전에 많은 TCP 데이터를 하나로 합치는 방식으로 동작**한다.
  - 즉, 세그먼트가 사실상 최대 크기가 되지 않는다면 전송을 하지 않는다.
  - 반면, 다른 모든 패킷이 ACK를 수신한 경우라면 최대 크기보다 작은 패킷까지도 전송 가능하다.
- 다시 말해, 다른 패킷들이 아직 전송 중인 상황에서는 새로운 패킷은 버퍼에 저장된다.
  - 전송 중이던 패킷에 대한 ACK를 수신 받았거나, 버퍼의 데이터가 충분히 쌓인 경우에만 전송된다.
  - 때문에 네이글 알고리즘은 크기가 작은 HTTP 메시지는 패킷의 크기가 충분하지 않아 오랜 시간 지연될 가능성을 갖는다.
- ACK에 의존적인 네이글 알고리즘은 ACK 지연과 함께 동작할 때 큰 성능 저하를 보이게 되며, 이를 제어하기 위해 `TCP_NODELAY` 파라미터를 설정할 수 있다.
  - 해당 플래그는 네이글 알고리즘을 비활성화하며, 이 경우 너무 작은 데이터가 많이 생기지 않도록 데이터를 적절히 모아줄 필요가 있다.

## 2026-01-26 Mon
### TIME_WAIT 누적과 포트의 고갈
- TCP 커넥션 엔드포인트에서 커넥션을 종료한 경우, 엔드포인트는 커넥션의 IP 주소와 포트 번호를 메모리의 `control block`에 임시 저장한다.
  - 이는 **동일한 주소와 포트 번호를 사용하는 새로운 TCP 커넥션이 일정 시간 생성되지 않도록 하기 위함**이다.
- 이를 통해 **이전 커넥션과 관련된 패킷이 새로운 커넥션에 삽입되는 것을 방지**할 수 있다.
- 일반적인 경우 커넥션 종료 지연이 영향을 주지는 않으나, 성능 테스트와 같은 특수한 상황에서는 문제가 될 수 있다.
  - 이는 성능 측정 대상 서버에 대해 접근 가능한 IP 주소의 개수가 제한되는 경우가 많기 때문이다.
- 클라이언트가 서버에 접속할 때마다 유일한 커넥션을 생성하는 경우, 소켓을 구분하기 위한 구성 요소 중 발신지 포트만을 변경할 수 있다.
  - 그러나 사용 가능한 발신지 포트는 제한적이며, `TIME_WAIT` 상태의 커넥션은 재사용될 수 없으므로 결과적으로 커넥션이 제한된다.

## 2026-01-27 Tue
### Connection 헤더란?
```
> Connection 헤더는 HTTP 커넥션 관리에 있어 매우 중요하지만 잘못 이해되는 헤더이기도 하다.
```
- HTTP는 클라이언트와 대상 서버 사이에 프록시 등 여러 중개자가 놓일 수 있으므로, 인접한 HTTP 애플리케이션 사이의 커넥션에만 옵션을 적용해야할 수 있다.
- `Connection` 헤더는 커넥션 토큰을 쉼표로 구분하며, 이는 다른 커넥션에 전달되지 않는다.
- 이 때, `Connection` 헤더는 다음과 같은 토큰을 명시할 수 있다.
  1. HTTP 헤더 이름: 해당 커넥션에만 해당되는 헤더를 명시한다.
  2. 임시 토큰 값: 해당 커넥션에 대한 비표준 옵션을 명시한다.
  3. `close`: 작업 완료 후 커넥션이 종료되어야 함을 의미한다.
- 특히 **HTTP 헤더 이름의 경우, `Connection`에 명시된 헤더는 메시지가 다른 홉으로 전달되는 시점에 삭제**되어야 한다.
- 예를 들어, `Connection: meter, close, bill-my-credit-cards` 헤더는 다음과 같은 의미를 갖는 것으로 해석할 수 있다.
  1. `Meter` 헤더를 다른 커넥션으로 전달하지 않는다.
  2. `bill-my-credit-card`는 비표준 옵션으로 적용해야 한다.
  3. `close`에 의해 현재 트랜잭션이 종료되는대로 커넥션도 종료되어야 한다.

## 2026-01-28 Wed
### 순차 트랜잭션 처리에 의한 지연 극복하기
- 커넥션을 적절히 관리하지 않는 경우, TCP의 성능은 크게 저하될 수 있다.
- 예를 들어, 여러 컨텐츠를 포함하는 HTML 페이지를 요청할 경우 컨텐츠 별 트랜잭션 개수 + HTML 요청 트랜잭션 개수만큼 지연이 발생한다.
  - 또한, 이러한 지연은 상술한 느린 시작에 의해 예상한 것보다도 더더욱 느려질 수 있다.
  - 이렇듯 **순차 처리로 인해 발생한 지연은 물리적인 지연 뿐만 아니라, 로딩 과정에서 텅 빈 웹페이지를 보는 데에서 오는 심리적인 지연도 발생**하기 쉽다.
- 이러한 문제를 해결하기 위해 HTTP 커넥션을 향상시킬 수 있는, 다음과 같은 여러 기술이 제공된다.
  1. 병렬 커넥션: 여러 TCP 커넥션을 활용한 HTTP 동시 요청
  2. 지속 커넥션: 커넥션을 맺고 끊는 데에서 오는 지연을 제거하기 위한 TCP 커넥션의 재활용
  3. 파이프라인 커넥션: 공유 TCP 커넥션을 활용하는 병렬 HTTP 요청
  4. 다중 커넥션: 요청과 응답들 각각에 대한 중재를 적용

## 2026-01-29 Thu
### 병렬 커넥션이란?
- HTTP는 클라이언트가 여러 개의 커넥션을 맺는 것으로 다수의 HTTP 트랜잭션을 병렬로 처리할 수 있도록 지원한다.
  - 이 때, 웹페이지 내부의 컴포넌트들은 각자 출처가 다를 수 있으므로 병렬 커넥션은 다수의 서버와 맺어질 수 있어야 한다.
- 일반적으로 **병렬 커넥션은 각 커넥션의 지연 시간을 겹치게 하는 것으로 전체 지연을 줄일 수 있기에 더 빠르다**.
  - 그러나 항상 빠른 것은 아니며, 예를 들어 제한된 네트워크 대역폭 내에서는 오히려 느릴 수 있다.
  - 또한, 너무 많은 커넥션은 많은 메모리를 소모하므로 서버 측에서 단일 사용자에 대해 무제한에 가까운 커넥션을 허용하지는 않는다.
  - 예를 들어, 브라우저의 경우 병렬 커넥션을 사용하지만 적은 수의 병렬 커넥션만을 허용한다.
- 반면, 병렬 커넥션이 항상 빠르지는 않지만 여러 객체를 동시에 내려받으므로 사용자로 하여금 더 빠르게 느껴질 수 있도록 할 수 있다.
  - 이는 실제로 전체 페이지의 다운로드 시간이 늘어나더라도, 동시다발적으로 여러 작업이 수행되는 것을 확인하는 데에서 오는 심리적인 착각에 가깝다.

## 2026-01-30 Fri
### 지속 커넥션이란?
- 일반적인 HTTP 클라이언트는 동일한 서버에 대해 여러 개의 커넥션을 맺으며, 이를 사이트 지역성이라고 지칭한다.
  - 단적으로, 동일한 웹 페이지에 배치된 리소스들은 대부분 동일한 출처에 위치한다.
  - 때문에 웹 페이지의 모든 리소스를 조회하기 위해서는 동일한 서버에 대한 요청이 여러번 발생한다.
- 이러한 특성에서 **HTTP/1.1은 임의의 요청에 대한 처리가 완료된 후에도 TCP 커넥션을 유지하는 것으로 재사용성을 높이는 특징**을 갖는다.
  - 이렇듯 처리 완료 후에도 연결된 상태로 유지되는 TCP 커넥션은 지속 커넥션이라는 용어로 지칭한다.
- 비지속 커넥션은 처리 완료 후 커넥션을 끊지만, 지속 커넥션은 명시적인 종료 전에는 유지된다.
- **지속 커넥션은 커넥션을 맺기 위한 준비 작업에 필요한 시간과, 느린 시작으로 인한 지연을 회피할 수 있어 유용**하다.
- 반면, 지속 커넥션은 HTTP 버전에 따라 다음과 같은 종류로 구분될 수 있다.
  1. HTTP/1.0: `keep-alive` 커넥션
  2. HTTP/1.1: 지속 커넥션

## 2026-01-31 Sat
### 병렬 커넥션과 지속 커넥션의 비교
- 병렬 커넥션은 매번 새로운 커넥션을 생성하고, 느린 시작의 문제를 피할 수 없다는 단점을 갖는다.
  - 반면, 지속 커넥션은 TCP 커넥션 자체의 지연을 회피하고 최적화된 커넥션을 유지할 수 있다는 장점을 갖는다.
- 지속 커넥션은 잘못 관리될 경우 계속 연결된 상태로 남는 수많은 커넥션에 의해 클라이언트와 서버의 불필요한 리소스 사용을 유발할 수 있다.
- 이러한 특징에서, **두 방식은 혼합하여 사용할 때 가장 효과적이며 수많은 애플리케이션은 적은 수의 병렬 커넥션을 맺은 후 이를 유지하는 방식을 취**한다.
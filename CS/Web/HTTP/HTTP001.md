# HTTP
## 2025-11-24 Mon
### 간단하게 알아보는 HTTP
```
> 전 세계의 웹 브라우저, 서버 및 웹 애플리케이션은 모두 HTTP를 통해 소통한다.
```
* HTTP는 현대 인터넷의 공용어이며, 수많은 이미지나 HTML 문서 등을 웹 서버로부터 웹 브라우저로 안전하게 옮겨주는 프로토콜로 이해할 수 있다.
* 이러한 HTTP는 신뢰성 있는 데이터 전송 프로토콜을 사용하므로, 데이터가 손상되거나 순서가 꼬이지 않음을 보장한다.
  * 이로 인해 인터넷 앱 개발자는 HTTP 통신으로 인한 데이터의 손상 복구를 염려하지 않고 기능을 구현하는 데에만 온전히 집중하는 것이 가능하다.

## 2025-11-25 Tue
### HTTP 서버와 클라이언트, 그리고 리소스
* HTTP로 옮겨지는 데이터인 웹 콘텐츠는 웹 서버에 존재하며, 웹 서버는 통신을 위한 수단으로 HTTP 프로토콜을 사용한다.
  * 이로 인해 웹 서버는 HTTP 서버라는 용어로도 지칭할 수 있으며, **HTTP 서버와 HTTP 클라이언트는 WWW를 구성하는 핵심적인 기본 요소**에 해당한다.
  * 이러한 **HTTP 서버는 인터넷의 데이터를 저장하며, HTTP 클라이언트가 요청한 데이터를 제공하는 역할을 수행**한다.
  * 즉, 클라이언트는 임의의 데이터를 HTTP를 통해 서버에 요청하고 서버는 HTTP 응답으로 이를 반환한다.
* 웹 컨텐츠는 웹 리소스로 구성되며, **텍스트나 HTML과 같이 웹 서버의 파일 시스템에 저장된 정적인 파일은 가장 단순한 형태의 웹 리소스에 해당한**다.
  * 반면, **리소스는 반드시 정적 파일일 필요 없이 요청 사용자 정보나 시간 등 외부 요인에 따라 동적인 컨텐츠를 생성하는 프로그램이 될 수도** 있다.
  * 다시 말해, 웹 리소스에 사실상 제약은 없으며 단지 웹에서 접근 가능한 어떠한 형태의 컨텐츠도 리소스로 취급될 수 있다.

## 2025-11-26 Wed
### MIME 타입이란?
* 앞서 다룬 바와 같이, 인터넷은 수많은 데이터 타입을 다룰 수 있기에 HTTP는 이들 객체 각각의 타입을 신중히 구분할 방법이 필요하다.
* **MIME 타입은 각 객체의 유형을 명시적으로 구분하기 위한 데이터 포맷 라벨로, 주로 HTTP 상의 멀티미디어 컨텐츠 라벨링을 위해 사용**된다.
  * 반면, MIME은 근본적으로 이메일 시스템 사이의 메시지 전송을 위해 설계되었으나 그 견고함으로 인해 HTTP 세계에도 채택된 케이스에 해당한다.
* **HTTP 서버는 모든 HTTP 객체에 대해 MIME 타입을 명시하며, HTTP 클라이언트는 객체를 반환받을 때 MIME 타입을 통해 자신이 다룰 수 있는지 확인**한다.
* MIME 타입은 슬래시 문자(`/`)를 기준으로 다음과 같은 두 구성 요소로 구분된다.
    1. 주 타입: `text`, `image` 등이 해당한다.
    2. 부 타입: `html`, `jpeg` 등이 해당한다.
* 이러한 MIME 타입은 수백 가지 이상이 존재하며, 실험용 또는 특정한 용도를 위한 MIME 타입 역시 존재한다.

## 2025-11-27 Thu
### URI와 URL, 그리고 URN
```
> HTTP 서버가 관리하는 리소스는 각각 자신의 이름을 갖기에, 클라이언트는 자신이 원하는 리소스를 명확히 지목하는 것이 가능하다.
> URI를 구성하는 두 분류 중 URN은 리소스의 이름만으로도 식별이 가능한 반면, URL은 리소스의 위치를 설명하는 것으로 식별한다.
```
* URI는 서버 리소스의 대표적인 이름으로, 각 HTTP 객체를 고유하게 식별하고 지정할 수 있도록 돕는다.
* 또한, URI는 다음과 같이 URL과 URN으로 구분하는 것이 가능하다.
    1. URL: **가장 흔한 형태의 URI이며, 특정 서버의 임의의 리소스에 대한 구체적인 위치를 서술**한다.
    2. URN: 임의의 리소스를 고유하게 가리키는 유일무이한 이름으로, 임의의 리소스에 대한 URN이 유지될 경우 리소스의 위치가 변경되더라도 참조 가능하다.
* **URL의 경우 스킴과 주소 및 리소스 이름과 같은 세 부분으로 구분할 수 있으며, 이는 표준 포맷에 해당**한다.
  * 최근의 경우, **대부분의 URI는 URL과 같기에 사실상 동일한 의미로 사용**된다.
* URN은 `urn:ietf:rfc:2141`와 같은 예를 들 수 있으며, 이는 인터넷 표준 문서인 RFC 2141에 대한 참조로서 기능한다.
  * 때문에 해당 문서가 어떤 서버로 이동되거나 접근 프로토콜이 변경되더라도 항상 해당 문서로 접근할 수 있음이 보장된다.
  * 반면, **URN은 기반 인프라 지원이 필요하지만 관련된 인프라가 부재한 관계로 널리 채택된 개념이 아닌 점에 주의**해야 한다. 

## 2025-11-28 Fri
### HTTP 트랜잭션이란?
* **HTTP 트랜잭션은 클라이언트와 서버가 리소스를 주고 받기 위한 과정에서 성립되며, HTTP 메시지를 활용하는 요청과 응답으로 구성**된다.
  * 이 때, HTTP 메시지는 요청 또는 응답에 따라 정형화된 형태의 데이터 덩어리를 지칭한다.
* 요청의 경우, HTTP 메소드라는 여러 종류의 명령이 지원되며 각 메소드는 서버에게 어떠한 동작이 취해져야하는지 전달한다.
* 응답의 경우, 서버가 클라이언트에게 요청 성공 여부를 알려주기 위한 세자리 숫자와 간단한 이유를 포함하는 개념인 HTTP 상태 코드를 포함한다.
  * 반면, **클라이언트의 경우 사유 구절보다는 상태 코드를 활용하여 응답을 처리**한다.
* **일반적인 웹 페이지는 여러 리소스의 모음이므로, 애플리케이션은 하나의 작업을 위해 복수 개의 HTTP 트랜잭션을 수행**할 수 있다. 

## 2025-11-29 Sat
### HTTP 메시지란?
```
> HTTP 메시지는 단순히 줄 단위로 구분되는 문자열이며, 이진 형식이 아닌 일반 텍스트 형태를 띄기에 사람에게 친숙하다.
```
* HTTP 메시지는 서버로 전달되는 요청과 클라이언트로 전달되는 응답 두 종류만 존재하며, 크게 다음과 같은 세 부분으로 구성된다.
  1. 시작줄: 메시지의 첫 줄로, 요청의 경우 무엇을 해야하는지 명시하는 반면 응답의 경우 무슨 일이 일어났는지 명시한다.
  2. 헤더: 0개 이상의 헤더 필드를 명시하며, 콜론(`:`) 문자로 구분되는 키-값 쌍으로 구성되어 **빈 줄로 끝난다**.
  3. 본문: **헤더의 끝인 빈 줄 다음에는 전달하기 위한 데이터가 명시될 수 있으며, 엄격한 구조를 갖는 해더와 달리 임의의 이진 데이터까지도 포함 가능**하다.

## 2025-11-30 Sun
### TCP 커넥션을 활용하는 HTTP
```
> 상술한 HTTP 트랜잭션, 그리고 트랜잭션을 통해 전달되는 HTTP 메시지는 모두 TCP 커넥션을 활용한다.
```
* HTTP는 세부적인 통신 방식에 집중하는 대신 대중적이고 신뢰성 있는 TCP/IP에 위임하며, 이로 인해 웹 자체가 TCP/IP에 기초한다고 이해할 수 있다.
  * 이는 TCP의 특징인 오류 없는 데이터 전송과 순서에 맞는 전달, 크기에 무방하게 전달 가능한 데이터 스트림의 장점을 취하기 위함이다.
* **TCP/IP는 TCP와 IP가 조합되어 네트워크와 하드웨어의 특성을 숨기며, 어떤 종류의 컴퓨터나 네트워크에서든 신뢰성 있는 소통이 가능하도록 지원**한다.
  * 이러한 특징으로 인해, **일단 TCP 커넥션이 맺어진 후에는 두 컴퓨터 간에 교환되는 메시지가 손상되거나 순서가 뒤바뀌는 일은 절대 발생하지 않는다**.
* 바꿔 말해, **클라이언트와 서버가 HTTP 메시지를 주고받기 위해서는 반드시 IP 주소와 포트 번호를 활용하여 TCP/IP 커넥션을 맺는 것이 선행**되어야 한다.

## 2025-12-01 Mon
### HTTP 프로토콜 버전
* HTTP 프로토콜은 프로토타입 버전인 HTTP/0.9부터 시작하여 현재에 이르기까지, 다양한 버전을 다음과 같이 제공한다.
    1. HTTP/0.9: 프로토타입 버전으로, 심각한 결함을 포함하며 GET 메소드만을 지원하는 반면 MIME 타입이나 헤더 등을 지원하지 않는다.
    2. HTTP/1.0: 처음으로 널리 쓰이기 시작한 버전으로, `1.0`이라는 버전 번호와 헤더 및 추가적인 메소드를 지원한다.
    3. HTTP/1.0+: 웹이 급격히 성장하며 `keep-alive` 커넥션을 포함한 여러 기능이 사실상 표준으로 추가된 버전을 지칭한다.
    4. HTTP/1.1: HTTP 설계의 구조적 결함을 개선한 버전으로, 현재 가장 많이 사용되는 버전으로 이해할 수 있다.
* 이 밖에도 HTTP/2.0 및 HTTP/3.0 등의 버전이 존재하며, 각 버전은 HTTP/1.1이 갖는 성능 문제를 개선하기 위해 제안되었다.

## 2025-12-02 Tue
### 웹을 구성하는 여러 요소
* 웹 애플리케이션인 웹 브라우저와 웹 서버는 기본적인 트랜잭션을 구현하기 위해 메시지를 주고 받는 반면, 그 밖에도 웹 애플리케이션은 여러 종류가 존재한다.
  1. 프록시: 클라이언트와 서버 사이에 위치하여 요청을 중개하며, 주로 보안을 위해 배치되는 것으로 신뢰할만한 중개자 역할을 담당한다.
  2. 캐시: 자주 사용되는 HTTP 객체를 저장하며, 클라이언트 입장에서 서버보다 가까이에 위치하는 것으로 속도적인 이점을 취할 수 있도록 지원한다.
  3. 게이트웨이: 주로 HTTP 요청을 다른 프로토콜로 변환하기 위해 사용되며, 마치 리소스를 다루는 진짜 서버인 것처럼 동작한다.
  4. 터널: 두 커넥션 사이에서 데이터를 직접 열지 않고 포워딩하기만 하는 특별한 종류의 프록시를 지칭한다.
  5. 에이전트: 사용자를 위해 HTTP 요청을 생성하는 클라이언트 측 프로그램으로, **웹 브라우저와 같이 HTTP 요청을 시작하는 모든 애플리케이션이 해당**된다.

## 2025-12-03 Wed
### URL이란?
```
> URL은 인터넷 상의 임의의 리소스를 지칭하기 위한 표준 이름으로, 해당 리소스가 어디에 있고 애플리케이션이 이에 어떻게 접근할 수 있는지 알린다.
```
* URL은 브라우저가 정보를 찾기 위해 필요한 리소스의 위치를 가리키며, 이를 통해 사용자는 수많은 리소스 중 필요한 것을 찾거나 공유할 수 있다.
  * 이렇게 공유된 리소스에는 HTTP 또는 다른 프로토콜을 통해 접근하는 것이 가능하다.
* **URL은 임의의 리소스에 접근하기 위한 방법으로 이해할 수 있으며, 해당 리소스가 어디에 배치되어 있고 이에 어떻게 접근해야할지 제시**한다.
  * 이 때, `어떻게`에 해당하는 정보는 스킴에 포함되며 `ftp` 형태의 스킴으로 미루어보아 HTTP 이외의 방법으로도 리소스에 접근할 수 있음을 알 수 있다.
  * 이렇듯 **URL은 인터넷 상에 공개된 리소스라면 무엇이든, 누구나 해당 리소스를 조회할 수 있도록 단일 방식의 작명 규칙을 갖는다**.
* URL은 브라우저가 임의의 리소스에 대해 더 영리하게 접근하고, 이를 다룰 수 있게 하는 것으로 인터넷 세상을 단순화시키는 중대한 역할을 수행한다.
  * 이로 인해 **사용자는 뉴스 리더나 FTP 클라이언트 애플리케이션 등을 설치하고 배울 필요가 없으며, 대신 URL이 브라우저에게 필요한 모든 것을 제공**한다.

## 2025-12-04 Thu
### URL 문법 살펴보기
* URL은 HTTP나 FTP, SMTP 등 다양한 스킴을 지원하지만 대부분의 URL은 다음과 같이 일반적인 URL 문법을 따르므로 비슷한 사용성을 갖게 된다.
```
<스킴>://<사용자명>:<비밀번호>@<호스트>:<포트>/<경로>;<파라미터>?<질의>#<프래그먼트>
```
* 이러한 **많은 컴포넌트를 모두 사용해야만 하는 일은 드문 반면, 대부분의 경우 가장 중요한 것은 스킴과 호스트 및 경로에 해당**한다.

## 2025-12-05 Fri
### 스킴 컴포넌트
* 스킴은 주어진 리소스에 대한 접근 방법을 제시하는 중요한 정보이며, 대부분의 스킴은 적절한 기본 포트를 갖는다.
  * 예를 들어, HTTP 스킴은 기본 포트 80을 갖는다.
* 스킴 컴포넌트는 반드시 영문자로 시작하며, URL의 왼쪽에서 세었을 때 첫 번째 콜론(`:`) 문자로 나머지 컴포넌트들과 구분된다.
  * 또한, **스킴은 대소문자를 가리지 않기에 `http://`와 `HTTP://`는 동일하게 처리**된다.

## 2025-12-06 Sat
### 호스트와 포트 컴포넌트
* 임의의 리소스를 찾기 위해서는 우선 해당 리소스를 호스팅하는 장비를 찾을 필요가 있으며, 리소스가 해당 장비의 어느 서버에서 제공되는지 알 수 있어야 한다.
* URL의 **호스트와 포트 컴포넌트는 각각 대상 장비와, 해당 장비 상에서 동작하는 서버가 열어둔 포트 정보를 명시**한다.
  * 이 때, 호스트는 IP 주소 형태 또는 DNS에 의해 지원되는 호스트 명을 가질 수 있으며 둘 중 어떤 방식으로 호스트를 명시하더라도 URL은 유효하다.
  * 반면, 상술한 바와 같이 HTTP 스킴은 기본 포트로 80을 적용한다.

## 2025-12-07 Sun
### 사용자명과 비밀번호 컴포넌트
* FTP 및 그 외 다양한 서버들은 자신의 데이터에 접근하고자 하는 사용자를 확인하기 위해 사용자 이름과 비밀번호를 요구할 수 있다.
* 물론 이러한 컴포넌트들은 누락될 수도 있으며, 누락된 경우 기본 사용자 이름과 비밀번호가 적용된다.
  * 대부분의 경우 기본 사용자 이름은 `anonymous`이며, 비밀번호를 브라우저 구현체마다 서로 다른 기본 값을 적용한다.

## 2025-12-08 Mon
### 경로와 파라미터 컴포넌트, 그리고 질의 문자열 컴포넌트
* URL 상의 경로 컴포넌트는 임의의 리소스가 해당 서버의 어느 위치에서 호스팅 중인지 제시하며, `/` 문자로 구분되는 계층적 구조를 갖는다.
  * 이 떄, 이러한 경로 컴포넌트의 정보는 서버가 사용자가 요청한 리소스의 위치를 찾기 위해 사용되는 정보이다.
* 파라미터 컴포넌트는 클라이언트가 서버에게 정확한 요청을 전송하기 위해 필요한 입력 파라미터를 명시하며, `/path;key=value` 형태를 갖는다.
  * 이렇듯 다른 컴포넌트들과는 세미콜론(`;`) 문자로 구분되며, 이를 통해 클라이언트는 리소스에 접근하기 위해 필요한 추가 정보를 전달할 수 있다.
* URL 상에서 경로 컴포넌트는 다시 경로 조각으로 나뉠 수 있으며, 각 경로 조각은 자신만의 자체 파라미터를 가질 수 있다.
* 요청받은 리소스 형식의 범위를 좁히고자 하는 경우에는 질의 문자열을 활용할 수 있으며, 물음표(`?`) 우측에 키-값 쌍 형태로 명시한다.
* 질의 문자열의 경우 특정한 문자들을 제외하고 이렇다할 제약 사항은 없으며, 여러 키-값 쌍을 사용하는 경우 `&` 기호로 구분한다. 

## 2025-12-09 Tue
### 프래그먼트 컴포넌트
* HTML과 같은 특수한 형태의 리소스 형식은 전체를 구성하는 작은 부분으로 나뉠 수 있으며, 프래그먼트 컴포넌트는 이러한 작은 부분을 가리킨다.
  * 예를 들어, 임의의 HTML 문서는 이상적으로 보았을 때 문서 전체가 하나의 리소스인 반면 임의의 단락을 가리킬 수 있다면 유용할 수 있다.
* 임의의 리소스에 대해 특정한 부분만을 가리킬 수 있도록 URL은 리소스의 조각 일부를 의미하는 프래그먼트 컴포넌트를 제공하며, 이는 `#` 문자로 구분한다.
* 그러나 **일반적인 경우, HTTP 서버는 객체 일부가 아닌 객체 전부만을 제공하므로 클라이언트가 서버에 프래그먼트 정보를 전달하는 상황은 발생하지 않는다**.
  * 대신 브라우저와 같은 클라이언트가 서버로부터 전체 리소스를 반환받은 후, 프래그먼트 정보를 활용하여 리소스의 일부를 보여주는 방식으로 동작하게 된다.

## 2025-12-10 Wed
### 단축 URL과 상대 URL
```
> 클라이언트 애플리케이션은 단축 URL 기능을 제공하며, 예를 들어 상대 URL은 임의의 리소스를 간결하게 기술하는 반면 URL 자동 확장은 검색 편의성을 높인다.
```
* 상대 URL은 클라이언트가 인식 가능한 단축 URL의 일종으로, 리소스에 접근하기 위한 모든 정보를 포함하지는 않는 URL을 지칭한다.
  * 때문에 상대 URL로 임의의 리소스에 접근하기 위해서는 기저라고 불리우는 별도의 URL이 필요하다.
* 상대 URL 문법을 따를 경우, URL에 스킴이나 호스트 등의 컴포넌트를 모두 입력할 필요는 없으며 이는 기저 URL을 통해 상속 받게 된다.
* 클라이언트는 상대 URL을 사용하기 위해서는 이를 절대 URL로 변환할 수 있어야 하며, 대부분의 경우 다음과 같은 과정을 따른다.
    1. 리소스에서 명시적으로 제공되거나, 상대 URL을 명시하는 리소스의 URL로부터 기저 URL을 조회한다.
    2. 상대 URL과 기저 URL을 컴포넌트 조각으로 분해한 후, 변환 알고리즘에 따라 절대 URL로 파싱한다.

## 2025-12-11 Thu
### URL을 구성하는 문자
* URL은 인터넷 상의 모든 리소스가 여러 프로토콜을 통해 잘 전달되고, 각자 유일한 이름을 가질 수 있도록 설계되었다.
  * 바꿔 말해, 서로 다른 장치가 임의의 프로토콜에 따라 데이터를 안전하게 전송할 수 있도록 하기 위해서는 URL의 설계는 중요한 주제였다.
* 안전한 전송을 위해서는 정보가 유실될 가능성을 가능한 한 줄여야 하지만, SMTP와 같은 프로토콜은 특정한 문자를 제거하는 식으로 동작한다.
  * 때문에 **URL에 모든 문자를 허용할 경우 앞서 말한 '여러 프로토콜을 통해 잘 전달되는' 요구사항을 위배**하게 된다.
  * 또한, URL 설계자들은 URL 자체가 안전함과 동시에 가독성을 갖기를 원했기에 공백과 같이 보이지 않는 문자를 URL에 사용하지 않도록 제한했다.
* 상술한 조건 속에서도 **URL 설계자들은 안전하지 않은 문자를 URL에 포함하고자 하는 요구사항이 적지 않다는 것을 확인**하게 된다.
  * 이로 인해 **안전하지 않은 문자를 안전한 문자로 인코딩할만한 방법이 필요했으며, 이에 이스케이프라는 기능이 추가**되었다.

## 2025-12-12 Fri
### URL 문자 집합
* 다른 컴퓨터 시스템들이 그렇듯, URL 역시 적은 수의 영문자만을 포함하는 ASCII를 사용한다.
  * 그러나 **ASCII는 다른 언어권 문자들을 지원하지 않으며, 나아가 URL 자체에 ASCII에 포함되지 않은 이진 데이터를 포함해야하는 경우도 발생**하곤 했다.
* **URL 설계자들은 ASCII에 포함되지 않는 문자를 지원하기 위해 이스케이프 문자열을 도입하였으며, 이를 통해 금지된 문자를 인코딩하여 완성도**를 높였다.
  * 예를 들어, **안전하지 않은 문자열은 퍼센티지 기호(`%`)로 시작하는 두자리 16진수 숫자로 구성된 이스케이프 문자로 인코딩**될 수 있다.
  * 상술한 `%`에 더해 `/`나 `#` 및 `?` 외에도 여러 문자는 각자 다양한 용도로 사용되기 위해 선점되었으므로 반드시 이스케이프할 필요가 있다.

## 2025-12-13 Sat
### 클라이언트가 URL을 다루는 방법
* 어떤 전송 프로토콜에서는 안전하지 않은 문자를 인코딩하지 않아도 무방할 수 있지만, 이는 애플리케이션 개발자의 실수이며 반드시 수정되어야 할 내용이다.
* 애플리케이션은 정해진 방식에 따라 구현하는 것이 바람직하며, **어떤 URL을 사용하든지 클라이언트는 안전하지 않은 문자를 변환할 것이 권장**된다.
  * 이러한 원칙을 준수할 경우 상호작용하는 두 애플리케이션은 혼동의 여지를 두지 않고 공유된 URL의 원형을 안전하게 유지할 수 있다.
  * 또한, 일반적으로 입력받은 URL의 어떤 문자를 인코딩할지 결정하기에 적합한 장소는 웹 브라우저와 같이 URL을 최초로 입력받는 애플리케이션이 적절하다.
* 극단적으로는 모든 문자를 인코딩할 수도 있으나, 이러한 방식은 안전하지 않은 문자를 인코딩하지 않는 허술한 애플리케이션과 상호작용하는 데에 어려움이 있다.
* 반면, URL을 해석하는 애플리케이션은 URL을 처리하기 전에 디코딩하는 것이 권장된다.

## 2025-12-14 Sun
### URL의 한계
* URL은 웹 세상에 존재하는 모든 객체에 이름을 붙일 수 있으며 새로운 포맷 역시 쉽게 추가할 수 있는 강력한 도구이다.
* 그러나 URL은 일종의 참조이지 실체가 아니므로, 객체가 옮겨지면 해당 URL을 더 이상 사용할 수 없다는 명확한 한계를 갖는다.
* 이를 해결하기 위해서는 각 리소스의 실체에 대해 이름을 할당하는 것으로, 이 경우 리소스의 물리적인 위치가 변경되더라도 상술한 문제는 발생하지 않는다.
    * 이는 URN에 대한 설명인 반면, **URN이라는 새로운 표준을 제정하기 위해서 드는 수고와 비용에 의해 아직까지는 URL을 대체할 수 없다**. 

## 2025-12-15 Mon
### HTTP 메시지가 흐르는 방향
```
> HTTP 메시지는 HTTP 서버와 클라이언트 사이에서 주고 받는 데이터 블록들을 지칭한다.
```
* HTTP 메시지는 메시지의 내용과 의미를 설명하기 위한 문자 형태의 메타데이터로 시작되며, 그 이후에는 선택적으로 데이터 본문이 포함될 수 있다.
* 임의의 HTTP 메시지 한 건은 한 방향으로 흐르며, 방향에 따라 다음과 같은 용어를 사용할 수 있다.
    1. 인바운드: HTTP 메시지가 클라이언트로부터 서버로 향하는 요청의 경우
    2. 아웃바운드: HTTP 메시지의 처리가 완료된 후, 서버로부터 클라이언트로 향하는 응답의 경우
    3. 업스트림: HTTP 요청 / 응답과 무관하게 HTTP 메시지 발송자 자체를 지칭
    4. 다운스트림: HTTP 요청 / 응답과 무관하게 HTTP 메시지 수신자 자체를 지칭
* 덧붙여 업스트림과 다운스트림의 경우, HTTP 메시지는 항상 다운스트림 방향으로 흐르며 절대 업스트림으로 흐를 수 없다.

## 2025-12-16 Tue
### HTTP 메시지의 구성 요소
* **HTTP 메시지는 단순히 구조화된 데이터 블록**에 지나지 않으며, 각 메시지는 클라이언트로부터 발생한 요청이나 서버의 응답 중 하나를 포함한다.
* 이 때, **HTTP 요청 / 응답과 무관하게 HTTP 메시지는 시작줄과 헤더 블록 및 본문의 세 가지 구성 요소**를 갖는다.
    1. 시작줄: 해당 메시지가 요청이나 응답 중 어떤 유형을 갖는지 서술한다.
    2. 헤더 블록: 해당 메시지의 속성을 열거한다.
    3. 본문: 본격적인 HTTP 데이터를 포함하나, 본문은 아예 없을 수도 있다.
* 시작줄과 헤더 블록은 단지 줄 단위로 분리된 아스키 문자열에 불과하며, **각 줄은 두 글자의 줄바꿈 문자열인 `CRLF`로 끝난다**.
    * HTTP 명세에서는 줄바꿈을 위해 `CRLF`만을 허용하지만, 견고한 HTTP 앱은 일반적인 개행 문자를 처리할 수 있어야 한다.
    * 바꿔 말해, 견고하지 않은 HTTP 앱에서는 캐리지 리턴과 개행 문자를 모두 전송하지 않는 경우가 있을 수 있다.
* 본문의 경우 단순히 선택적으로 포함시킬 수 있는 데이터 덩어리에 불과한 반면, 시작줄이나 헤더와는 달리 텍스트나 이진 데이터를 포함할 수 있다.

## 2025-12-17 Wed
### HTTP 메시지의 문법
```
> 모든 HTTP 메시지는 요청 또는 응답으로 구분된다.
> HTTP 요청 메시지는 서버에 임의의 동작을 요구하는 반면, 응답 메시지는 요청에 대한 처리 결과를 클라이언트에 반환한다.
```
* HTTP 요청과 응답은 모두 기본적으로 동일한 구성 요소를 갖지만, 세부적인 형식에 따라 다음과 같은 차이가 있다.
  1. 요청: 시작줄이 `<메소드> <URL> <버전>` 정보를 포함한다.
  2. 응답: 시작줄이 `<버전> <상태 코드> <사유 구절>` 정보를 포함한다.
* 이 때, 요청시 URL은 절대 경로 또는 URL의 경로 구성 요소를 명시할 수 있다.
  * 절대 경로가 아닌 경우, 서버는 생략된 호스트나 포트 정보를 자신으로 치환하는 방식으로 동작한다.
* 헤더 블록의 경우, `이름`과 `:`에 선택적인 공백을 한 칸 명시할 수 있으며, 이후 `값`과 `CRLF`로 작성되는 형태를 지키는 헤더를 0개 이상 명시한다.
  * 반면, **헤더 블록 자체가 본문의 시작과 구분하기 위한 `CRLF`를 하나 갖기에 헤더가 없더라도 시작줄과 본문은 항상 구분**될 수 있다.
* 상술했듯 본문은 선택적이며, 본문이 없는 HTTP 메시지는 `CRLF`로 끝나게 된다.
* 극단적으로, **헤더 블록과 본문이 모두 없는 HTTP 메시지의 경우에도 항상 `CRLF`를 통해 끝맺어야** 한다.
  * 그러나 본문이 없는 경우에 `CRLF`를 누락시키는 경우가 있으므로, 호환을 위해 모든 HTTP 앱은 `CRLF`로 끝나지 않는 메시지를 처리할 수 있어야 한다.

## 2025-12-18 Thu
### HTTP 메시지와 시작줄
* 상술한 바와 같이모든 HTTP 메시지는 시작줄로 시작하며, 이러한 시작줄은 요청과 응답이라는 유형에 따라 다른 구성을 갖는다.
    * 이 때, 각 구성 요소는 `<요소1> <요소2>`와 같이 공백으로 구분된다.
* 요청에 명시된 시작줄의 경우, 서버에 요청하는 리소스인 URL과 동사인 HTTP 메소드를 포함한다.
    * 또한, 클라이언트가 어떤 버전의 HTTP를 사용하고 있는지 알려주기 위한 버전 역시 포함된다.
* 응답에 명시된 시작줄의 경우, 응답 메시지의 HTTP 버전에 더해 요청에 대한 처리 결과를 의미하는 상태값인 상태 코드와 직관적인 메시지인 사유 구절이 포함된다.
* 덧붙여 HTTP/1.0의 경우, 요청에 명시된 시작줄의 마지막 구성 요소인 버전 정보와 응답의 시작줄 자체가 포함될 필요가 없었다.
# HTTP
## 2026-01-16 Fri
### HTTP와 TCP/IP의 관계
```
> HTTP 커넥션은 대부분의 경우 TCP 커넥션에 불과하다.
```
- 일반적인 HTTP 역시 TCP/IP를 기반으로 하며, 임의의 HTTP 요청은 다음과 같이 처리된다.
  1. 브라우저는 URL로부터 호스트 정보를 추출하여 적절한 IP 주소를 찾는다.
  2. 브라우저는 URL로부터 포트 정보를 추출하여 서버측 애플리케이션으로 향하는 TCP 커넥션을 생성한다.
  3. 브라우저는 2.의 커넥션을 통해 HTTP GET 요청 메시지를 전송한다.
  4. 서버는 요청에 대한 처리 결과를 반환한다.
  5. 브라우저는 서버의 응답을 읽어들인 후, 커넥션을 끊는다.

## 2026-01-17 Sat
### TCP란?
- TCP/IP를 사용하는 클라이언트는원하는 때에 서버로 TCP/IP 커넥션을 맺을 수 있으며, 이 경우 메시지는 손상되거나 순서가 바뀌지 않고 전달된다.
  - 때문에 HTTP로 메시지를 전송하는 경우, 현재 연결된 TCP 커넥션을 통해 메시지에 포함된 데이터가 순차적으로 전달된다.
- TCP는 세그먼트라는 단위로 데이터 스트림을 나누고, 이렇게 나뉘어진 세그먼트를 다시 IP 패킷에 담아 전달한다.
  - 이러한 과정은 모두 TCP/IP 계층을 담당하는 애플리케이션에 의해 처리되므로, HTTP 개발자는 이를 신경쓸 필요가 없다.
  - IP 패킷은 IP 패킷 헤더와 TCP 세그먼트 헤더 및 TCP 데이터 조각으로 구성된다.
  - 반면, TCP 세그먼트 헤더는 TCP 포트 번호와 제어 플래그 및 데이터 무결성을 검증하기 위한 숫자 값을 포함한다.

## 2026-01-18 Sun
### TCP 커넥션 구성 요소
- 컴퓨터는 기본적으로 여러 개의 TCP 커넥션을 처리하며, TCP는 포트 번호를 통해 여러 개의 커넥션을 유지한다.
- 이 때, **각각의 TCP 커넥션은 다음과 같은 네 가지 구성 요소의 조합으로 유일하게 식별**된다.
  1. 발신지 IP 주소
  2. 발신지 포트 번호
  3. 수신지 IP 주소
  4. 수신지 포트 번호
- 때문에 임의의 서버는 동일한 포트 번호에서 여러 개의 TCP 커넥션을 구분하여 관리할 수 있다.
  - 반면, **현대적인 서버는 대부분의 경우 하나의 리스닝 포켓을 열어두고 새로운 연결 요청에 대해 전용 소켓을 생성하여 연결을 수립**하는 경우가 많다.

## 2026-01-19 Mon
### TCP 소켓 프로그래밍이란?
- 운영체제는 TCP 커넥션 생성과 관련된 여러 기능을 제공하며, 이를 위한 TCP 프로그래밍 인터페이스를 구현하는 소켓 API는 TCP와 IP의 세부 구현을 숨긴다.
  - **소켓 API는 유닉스 운영체제용으로 개발되었으나, 현대에 이르러서는 다양한 구현체들로 인해 대부분의 운영체제와 프로그래밍 언어에서 사용**할 수 있다.
- 소켓 API를 사용하면 TCP 엔드포인트가 되는 데이터 구조를 생성하고, 원격 서버의 TCP 엔드포인트에 이를 연결할 수 있다.
  - 이 때, 연결된 후에는 이를 통해 데이터 스트림을 읽고 쓸 수 있다.
  - 반면, **이러한 API는 기본적인 핸드셰이크와 TCP 데이터 스트림의 분할 및 재조립과 관련된 세부 사항을 개발자가 신경쓰지 않도록 숨기는 역할**을 맡는다.

## 2026-01-20 Tue
### HTTP와 TCP 네트워크 지연
- HTTP는 TCP 위에서 동작하는 계층이므로, 트랜잭션의 성능 역시 TCP 성능에 직접적인 영향을 받는다.
- HTTP 통신 시간은 DNS 동작 이후에 커넥션 연결과 요청, 요청에 대한 처리와 결과를 응답하고 종료하는 과정 전체를 포함한다.
  - 이 때, 트랜잭션 처리 시간을 제외한 다른 모든 과정을 위해 소요되는 시간에 비해 트랜잭션 처리 시간은 적은 시간을 요구한다.
- 이렇듯 **HTTP 트랜잭션을 지연시키는 직접적인 원인은 TCP 네트워크의 지연**으로, 크게 다음과 같이 정리할 수 있다.
  1. 임의의 호스트에 대한 첫 요청시 발생하는 DNS 처리 시간
  2. 서버로의 TCP 커넥션 수립 요청과 이에 대한 서버의 응답 대기 시간
  3. 커넥션이 수립된 후 이를 통해 HTTP 요청을 전송하고, 서버에 의해 처리되는 시간
  4. 서버에 의해 처리된 결과가 응답되기까지의 시간
- 또한, TCP 네트워크 지연은 하드웨어의 성능과 네트워크 속도 및 요청과 응답의 크기에도 영향을 받을 수 있다.
  - 심지어는 클라이언트와 서버 간의 물리적인 거리나, TCP 자체의 기술적 복잡성 역시 주요한 원인이 될 수 있다.

## 2026-01-21 Wed
### 일반적인 TCP 관련 지연들
- 상술한 요인 외에도, HTTP 기반 개발자에게 영향을 줄 수 있을만한 성능 상의 문제는 다음과 같은 지연들로부터 발생할 수 있다.
  1. TCP 커넥션 핸드셰이크 설정
  2. 혼잡 제어를 위한 TCP의 느린 시작
  3. 네이글 알고리즘
  4. TCP piggyback ACK를 위한 ACK 지연
  5. TIME_WAIT 지연과 포트의 고갈
- 일반적인 기준보다좋은 성능을 목표로 하는 HTTP 애플리케이션을 개발하기 위해서는 이러한 요소를 모두 신경쓸 필요가 있다.

## 2026-01-22 Thu
### TCP 커넥션 핸드셰이크 지연
- 일반적인 3-Way TCP 커넥션 핸드셰이크는 다음과 같이 진행된다.
  1. 클라이언트는 새로운 TCP 커넥션을 생성하기 위해 `SYN` 플래그를 포함하는 작은 패킷을 전송한다.
  2. 서버는 해당 TCP 패킷을 분석하고, 커넥션 요청을 받아들이기 위해 `SYN`과 `ACK`가 포함된 패킷을 전송한다.
  3. 클라이언트는 커넥션 수립 완료를 알리기 위해 `ACK`를 보내며, 이 때 데이터를 함께 전송할 수 있다.
- 그러나 **어떤 때라도 새로운 TCP 커넥션을 여는 과정에서는 위와 같은 연속적인 IP 패킷 교환이 전제**된다.
  - 바꿔말해, 아무리 작은 데이터를 전송할 때라도 TCP 커넥션을 사용하는 이상 패킷 교환은 필수적이다.
  - 즉, **데이터의 크기가 충분히 작다면 데이터 전송보다 패킷 교환에 더 많은 비용을 소모**해야할 수 있다.
- 반면, HTTP 계층의 관점에서 TCP 계층은 추상화되므로 상술한 연속적 패킷 교환 과정은 HTTP 계층에서 알 수 없다.
  - 단지 **HTTP 계층에서 체감할 수 있는 것은 암시적으로 진행되는 TCP 패킷 교환으로 인한 지연** 뿐이다.
- 상술한 **TCP 구성 과정에서 기인하는 지연을 제거하기 위해서는 이미 존재하는 커넥션을 재활용하는 것을 고려**해볼 수 있다.

## 2026-01-23 Fri
### ACK 응답 지연
- **인터넷이라는 환경 자체가 무결한 패킷 전송을 보장하지 않는다는 점에서 TCP는 무결성 보장을 위해 자체적인 확인 체계**를 갖는다.
  - 단적인 예로, 라우터는 과부하 상황에서 패킷을 마음껏 파기할 수 있다.
- 다시 말해, 각각의 TCP 세그먼트는 순번과 무결성 체크섬을 가지며 수신자는 이를 확인하여 수신을 확인하기 위한 ACK를 전송한다.
  - 송신자 입장에서, 임의의 데이터에 대해 일정 시간 안에 ACK를 수신하지 못한 경우 해당 데이터를 재전송한다.
- 이러한 **ACK는 크기가 작기 때문에 TCP는 필요한 데이터에 ACK를 함께 전송할 수 있으며, 이를 piggyback이라는 용어로 지칭**한다.
  - 이는 즉 데이터 패킷과 ACK를 하나로 묶어 네트워크를 효율적으로 사용하기 위함이다.
- 반면, **많은 TCP 구현체는 piggyback의 빈도를 높이기 위해 ACK 응답 지연 알고리즘을 구현**한다.
  - 예를 들어, 전송해야 할 ACK를 별도의 버퍼에 일정 시간 저장해둔 후 그 시간 내에 송출 데이터가 발생하면 piggyback으로 반환한다.
  - 반면, 일정 시간 내에 송출 데이터가 발생하지 않는다면 ACK는 별도의 패킷으로 전송된다.
- 그러나 **HTTP 트랜잭션은 요청과 응답으로 구성되므로, piggyback이 발생할 가능성이 낮아 ACK 응답 지연으로 인한 지연이 발생**하기 쉽다.
- 물론 ACK 지연 관련 기능을 수정하거나 비활성화하는 것은 가능하지만, 이러한 설정으로 인해 부작용이 발생하지 않는다는 명확한 근거 하에 진행해야 한다.

## 2026-01-24 Sat
### TCP의 느린 시작
- TCP의 데이터 전송 속도는 TCP 커넥션이 생성되고 얼마나 지났는지에 따라 달라질 수 있으며, 이렇듯 **TCP 커넥션은 시간에 따라 자체적으로 최적화**된다.
  - 예를 들어, 최초에는 최대 속도를 제한하되 점진적으로 속도 제한을 높여나간다.
  - 이러한 TCP의 동작 방식을 **느린 시작이라는 용어로 지칭하며, 이는 인터넷 상에서 발생할 수 있는 혼잡을 방지하는 데에 의의**를 갖는다.
- TCP의 느린 시작은 TCP가 한 번에 전송할 수 있는 패킷 수를 제헌하며, ACK를 받아갈수록 전송 가능한 패킷의 양이 늘어난다.
  - 이는 `congestion window`와 관련이 있으며, 이로 인해 새로운 커넥션은 보다 오래 사용된 커넥션보다 느리게 동작한다.
- 즉, **HTTP 통신의 경우 일반적으로 이미 생성된 TCP 커넥션을 재사용하는 것이 성능 상 유리**할 수 있다.

## 2026-01-25 Sun
### 네이글 알고리즘과 TCP_NODELAY
- 각 TCP 세그먼트는 여러 플래그와 헤더가 포함되므로, 크기가 작은 데이터를 포함한 세그먼트를 많이 전송할 경우 네트워크 성능은 크게 저하된다.
- 이 때, **네이글 알고리즘은 네트워크 효율성을 위해 패킷을 전송하기 전에 많은 TCP 데이터를 하나로 합치는 방식으로 동작**한다.
  - 즉, 세그먼트가 사실상 최대 크기가 되지 않는다면 전송을 하지 않는다.
  - 반면, 다른 모든 패킷이 ACK를 수신한 경우라면 최대 크기보다 작은 패킷까지도 전송 가능하다.
- 다시 말해, 다른 패킷들이 아직 전송 중인 상황에서는 새로운 패킷은 버퍼에 저장된다.
  - 전송 중이던 패킷에 대한 ACK를 수신 받았거나, 버퍼의 데이터가 충분히 쌓인 경우에만 전송된다.
  - 때문에 네이글 알고리즘은 크기가 작은 HTTP 메시지는 패킷의 크기가 충분하지 않아 오랜 시간 지연될 가능성을 갖는다.
- ACK에 의존적인 네이글 알고리즘은 ACK 지연과 함께 동작할 때 큰 성능 저하를 보이게 되며, 이를 제어하기 위해 `TCP_NODELAY` 파라미터를 설정할 수 있다.
  - 해당 플래그는 네이글 알고리즘을 비활성화하며, 이 경우 너무 작은 데이터가 많이 생기지 않도록 데이터를 적절히 모아줄 필요가 있다.

## 2026-01-26 Mon
### TIME_WAIT 누적과 포트의 고갈
- TCP 커넥션 엔드포인트에서 커넥션을 종료한 경우, 엔드포인트는 커넥션의 IP 주소와 포트 번호를 메모리의 `control block`에 임시 저장한다.
  - 이는 **동일한 주소와 포트 번호를 사용하는 새로운 TCP 커넥션이 일정 시간 생성되지 않도록 하기 위함**이다.
- 이를 통해 **이전 커넥션과 관련된 패킷이 새로운 커넥션에 삽입되는 것을 방지**할 수 있다.
- 일반적인 경우 커넥션 종료 지연이 영향을 주지는 않으나, 성능 테스트와 같은 특수한 상황에서는 문제가 될 수 있다.
  - 이는 성능 측정 대상 서버에 대해 접근 가능한 IP 주소의 개수가 제한되는 경우가 많기 때문이다.
- 클라이언트가 서버에 접속할 때마다 유일한 커넥션을 생성하는 경우, 소켓을 구분하기 위한 구성 요소 중 발신지 포트만을 변경할 수 있다.
  - 그러나 사용 가능한 발신지 포트는 제한적이며, `TIME_WAIT` 상태의 커넥션은 재사용될 수 없으므로 결과적으로 커넥션이 제한된다.

## 2026-01-27 Tue
### Connection 헤더란?
```
> Connection 헤더는 HTTP 커넥션 관리에 있어 매우 중요하지만 잘못 이해되는 헤더이기도 하다.
```
- HTTP는 클라이언트와 대상 서버 사이에 프록시 등 여러 중개자가 놓일 수 있으므로, 인접한 HTTP 애플리케이션 사이의 커넥션에만 옵션을 적용해야할 수 있다.
- `Connection` 헤더는 커넥션 토큰을 쉼표로 구분하며, 이는 다른 커넥션에 전달되지 않는다.
- 이 때, `Connection` 헤더는 다음과 같은 토큰을 명시할 수 있다.
  1. HTTP 헤더 이름: 해당 커넥션에만 해당되는 헤더를 명시한다.
  2. 임시 토큰 값: 해당 커넥션에 대한 비표준 옵션을 명시한다.
  3. `close`: 작업 완료 후 커넥션이 종료되어야 함을 의미한다.
- 특히 **HTTP 헤더 이름의 경우, `Connection`에 명시된 헤더는 메시지가 다른 홉으로 전달되는 시점에 삭제**되어야 한다.
- 예를 들어, `Connection: meter, close, bill-my-credit-cards` 헤더는 다음과 같은 의미를 갖는 것으로 해석할 수 있다.
  1. `Meter` 헤더를 다른 커넥션으로 전달하지 않는다.
  2. `bill-my-credit-card`는 비표준 옵션으로 적용해야 한다.
  3. `close`에 의해 현재 트랜잭션이 종료되는대로 커넥션도 종료되어야 한다.

## 2026-01-28 Wed
### 순차 트랜잭션 처리에 의한 지연 극복하기
- 커넥션을 적절히 관리하지 않는 경우, TCP의 성능은 크게 저하될 수 있다.
- 예를 들어, 여러 컨텐츠를 포함하는 HTML 페이지를 요청할 경우 컨텐츠 별 트랜잭션 개수 + HTML 요청 트랜잭션 개수만큼 지연이 발생한다.
  - 또한, 이러한 지연은 상술한 느린 시작에 의해 예상한 것보다도 더더욱 느려질 수 있다.
  - 이렇듯 **순차 처리로 인해 발생한 지연은 물리적인 지연 뿐만 아니라, 로딩 과정에서 텅 빈 웹페이지를 보는 데에서 오는 심리적인 지연도 발생**하기 쉽다.
- 이러한 문제를 해결하기 위해 HTTP 커넥션을 향상시킬 수 있는, 다음과 같은 여러 기술이 제공된다.
  1. 병렬 커넥션: 여러 TCP 커넥션을 활용한 HTTP 동시 요청
  2. 지속 커넥션: 커넥션을 맺고 끊는 데에서 오는 지연을 제거하기 위한 TCP 커넥션의 재활용
  3. 파이프라인 커넥션: 공유 TCP 커넥션을 활용하는 병렬 HTTP 요청
  4. 다중 커넥션: 요청과 응답들 각각에 대한 중재를 적용

## 2026-01-29 Thu
### 병렬 커넥션이란?
- HTTP는 클라이언트가 여러 개의 커넥션을 맺는 것으로 다수의 HTTP 트랜잭션을 병렬로 처리할 수 있도록 지원한다.
  - 이 때, 웹페이지 내부의 컴포넌트들은 각자 출처가 다를 수 있으므로 병렬 커넥션은 다수의 서버와 맺어질 수 있어야 한다.
- 일반적으로 **병렬 커넥션은 각 커넥션의 지연 시간을 겹치게 하는 것으로 전체 지연을 줄일 수 있기에 더 빠르다**.
  - 그러나 항상 빠른 것은 아니며, 예를 들어 제한된 네트워크 대역폭 내에서는 오히려 느릴 수 있다.
  - 또한, 너무 많은 커넥션은 많은 메모리를 소모하므로 서버 측에서 단일 사용자에 대해 무제한에 가까운 커넥션을 허용하지는 않는다.
  - 예를 들어, 브라우저의 경우 병렬 커넥션을 사용하지만 적은 수의 병렬 커넥션만을 허용한다.
- 반면, 병렬 커넥션이 항상 빠르지는 않지만 여러 객체를 동시에 내려받으므로 사용자로 하여금 더 빠르게 느껴질 수 있도록 할 수 있다.
  - 이는 실제로 전체 페이지의 다운로드 시간이 늘어나더라도, 동시다발적으로 여러 작업이 수행되는 것을 확인하는 데에서 오는 심리적인 착각에 가깝다.

## 2026-01-30 Fri
### 지속 커넥션이란?
- 일반적인 HTTP 클라이언트는 동일한 서버에 대해 여러 개의 커넥션을 맺으며, 이를 사이트 지역성이라고 지칭한다.
  - 단적으로, 동일한 웹 페이지에 배치된 리소스들은 대부분 동일한 출처에 위치한다.
  - 때문에 웹 페이지의 모든 리소스를 조회하기 위해서는 동일한 서버에 대한 요청이 여러번 발생한다.
- 이러한 특성에서 **HTTP/1.1은 임의의 요청에 대한 처리가 완료된 후에도 TCP 커넥션을 유지하는 것으로 재사용성을 높이는 특징**을 갖는다.
  - 이렇듯 처리 완료 후에도 연결된 상태로 유지되는 TCP 커넥션은 지속 커넥션이라는 용어로 지칭한다.
- 비지속 커넥션은 처리 완료 후 커넥션을 끊지만, 지속 커넥션은 명시적인 종료 전에는 유지된다.
- **지속 커넥션은 커넥션을 맺기 위한 준비 작업에 필요한 시간과, 느린 시작으로 인한 지연을 회피할 수 있어 유용**하다.
- 반면, 지속 커넥션은 HTTP 버전에 따라 다음과 같은 종류로 구분될 수 있다.
  1. HTTP/1.0: `keep-alive` 커넥션
  2. HTTP/1.1: 지속 커넥션

## 2026-01-31 Sat
### 병렬 커넥션과 지속 커넥션의 비교
- 병렬 커넥션은 매번 새로운 커넥션을 생성하고, 느린 시작의 문제를 피할 수 없다는 단점을 갖는다.
  - 반면, 지속 커넥션은 TCP 커넥션 자체의 지연을 회피하고 최적화된 커넥션을 유지할 수 있다는 장점을 갖는다.
- 지속 커넥션은 잘못 관리될 경우 계속 연결된 상태로 남는 수많은 커넥션에 의해 클라이언트와 서버의 불필요한 리소스 사용을 유발할 수 있다.
- 이러한 특징에서, **두 방식은 혼합하여 사용할 때 가장 효과적이며 수많은 애플리케이션은 적은 수의 병렬 커넥션을 맺은 후 이를 유지하는 방식을 취**한다.

## 2026-02-01 Sun
### HTTP/1.0+와 keep-alive 커넥션
- `keep-alive` 커넥션은 커넥션을 맺고 끊는 데에 필요한 작업이 없어 시간이 단축되며, 느린 시작을 회피할 수 있다는 점에서 지속 커넥션의 장점을 갖는다.
- `keep-alive` 커넥션을 위해서는 클라이언트와 서버 모두가 헤더에 `Connection: Keep-Alive`를 명시할 필요가 있다.
  - 요청을 받은 서버는 클라이언트가 동일한 커넥션을 유지하기를 기대한다는 사실을 알 수 있다.
  - 클라이언트는 서버로부터의 응답에 해당 헤더가 포함된 경우 커넥션이 유지된 다는 것을 알 수 있다.
  - 반면, 누락된 경우 서버가 지속 커넥션을 지원하지 않아 커넥션이 끊길 것으로 추정하게 된다.
  - 이렇듯 헤더에 명시된 내용은 어디까지나 요청일 뿐이므로, 서버가 이를 반드시 따를 의무는 존재하지 않는다는 점에 주의해야 한다.
- `keep-alive` 커넥션과 관련된 옵션은 `Keep-Alive: max=5, timeout=120`과 같이 쉼표로 구분 된 키-값 쌍의 모음으로 명시할 수 있다.
  - 그러나 해당 헤더는 `Connection: Keep-Alive` 헤더가 명시된 경우에만 사용이 가능하다.

## 2026-02-02 Mon
### keep-alive 커넥션의 규칙
- `keep-alive` 커넥션은 HTTP/1.0에서 기본으로 사용되지 않으며, 반드시 `Connection` 헤더를 명시해야 한다.
- 클라이언트와 서버는 `Connection: Keep-Alive` 헤더가 명시된 것을 통해 커넥션 유지 여부를 결정하거나 추정할 수 있다.
  - 즉, 서버는 반드시 이를 따를 필요 없으며 클라이언트 역시 서버가 요청에 응하지 않을 수 있다는 점을 이해해야 한다.
- `keep-alive` 커넥션은 `Content-Length` 헤더가 정확히 명시되어야 하며, 이를 통해 트랜잭션의 시작과 끝을 명확히 인식하는 것이 가능하다.
- 클라이언트는 모든 응답을 수신하기 전에 커넥션이 끊어진 경우, 별다른 이유가 없다는 가정 하에 요청을 다시 보낼 수 있어야 한다.

## 2026-02-03 Tue
### keep-alive와 멍청한 프록시
- 일반적인 프록시는 `keep-alive` 커넥션과 `Connection` 헤더를 이해하지 못하며, 이로 인해 해당 헤더를 삭제하지 않고 그대로 전달한다.
- 때문에 `keep-alive` 커넥션을 지원하는 클라이언트와 서버는 각각 서로와 지속 커넥션이 생성되었다고 오판할 수 있다.
  - 실제로는 중재자인 프록시가 클라이언트 및 서버 각각에 대해 지속 커넥션을 유지한다.
- 클라이언트는 프록시와의 커넥션에 요청을 지속적으로 전달하지만, 프록시는 동일한 커넥션에서 오는 요청을 예상할 수 없기에 이를 무시한다.
- 반면 프록시는 `keep-alive` 커넥션을 이해하지 못해 서버의 연결 종료를 기대하지만, 서버는 `keep-alive` 커넥션 유지를 위해 연결을 종료하지 않는다.
  - 결과적으로 브라우저와 같은 클라이언트는 타임아웃으로 인해 커넥션이 끊길 때까지 대기하게 된다.
- 이러한 문제를 피하기 위해서는 **프록시는 `Connection`이나 `Keep-Alive`와 같은 홉 별 헤더를 절대 전달하지 않아야** 한다.
  - 프록시는 이러한 홉 별 헤더를 이해하지 못하는 경우, 단순히 확장 헤더로 취급하여 헤더를 전달한다.

## 2026-02-04 Wed
### Proxy-Connection과 영리한 프록시
- 멍청한 프록시 문제를 해결하기 위해, `Proxy-Connection`과 같은 비표준 헤더가 제안되었으며 이를 이해하는 프록시는 영리한 프록시로 지칭할 수 있다.
- 멍청한 프록시가 해당 헤더를 전달 받은 경우 이를 확장 헤더로 이해하여 서버에 전달하지만, 서버는 이를 무시하므로 문제가 되지 않는다.
  - 반면, 영리한 프록시는 이를 `Connection` 헤더로 변환하여 전달하기에 멍청한 프록시 문제를 해결할 수 있다.
- 그러나 이러한 방식은 영리한 프록시 하나만 존재하는 경우에 유효하며, 멍청한 프록시가 경로에 포함되는 경우를 해결할 수 없다.
- 또한, 대부분의 경우 **리버스 프록시는 숨겨지므로 브라우저가 이들을 인식하여 `Proxy-Connection` 헤더를 요청에 포함하는 것 역시 불가능**하다.
  - 이렇듯 **보이지 않는 웹 애플리케이션들이 지속 커넥션 기능을 명확히 구현하는 것은 매우 중요**하다.

## 2026-02-05 Thu
### HTTP/1.1과 지속 커넥션
```
> HTTP/1.1은 `keep-alive` 커넥션을 지원하지 않는 대신, 더 개선된 버전의 지속 커넥션을 지원한다.
```
- **HTTP/1.1이 제공하는 지속 커넥션은 기본적으로 활성화되어 있으므로, 별도의 설정이 없는 경우 모든 커넥션은 지속 커넥션으로 취급**된다.
- 때문에 HTTP/1.1 애플리케이션이 트랜잭션 종료 후 커넥션을 끊기 위해서는 `Connection: close` 헤더를 명시해야 한다.
  - 바꿔 말해, **HTTP/1.1 클라이언트는 응답에 `Connection: close`가 포함되지 않는 경우 커넥션을 계속해서 유지한다는 것으로 추정**한다.
- 물론 현실에서는 클라이언트와 서버는 언제든지 커넥션을 종료할 수 있으므로, 해당 헤더가 포함되지 않은 것이 영영 커넥션을 유지한다는 것을 의미하지는 않는다.

## 2026-02-06 Fri
### 지속 커넥션의 규칙
- 클라이언트가 요청에 `Connection: close`를 명시한 경우, 클라이언트는 해당 커넥션으로 추가적인 요청을 전송할 수 없다.
  - 바꿔 말해, 더 이상 요청하지 않을 것이라면 해당 헤더를 명시해야 한다.
- **커넥션을 지속하기 위해서는 커넥션 상 주고 받는 메시지 모두에 `Content-Length` 헤더를 정확히 명시**해야 한다.
- HTTP/1.1 프록시는 지속 커넥션을 위해 서버와 클라이언트 각각에 대해 별도의 커넥션을 맺고 유지할 필요가 있다.
- **HTTP/1.1 애플리케이션은 `Connection` 헤더에 명시된 값과는 관계 없이 언제든 커넥션을 종료할 수 있음을 기억**할 필요가 있다.
  - 반면, HTTP/1.1 애플리케이션은 끊어진 커넥션을 복구할 수도 있어야 한다.
- 임의의 클라이언트는 서버의 과부하를 방지하기 위해 필요 최소한의 커넥션만을 유지해야 한다.

## 2026-02-07 Sat
### 파이프라인 커넥션이란?
- HTTP/1.1은 지속 커넥션을 활용하여 요청을 파이프라이닝할 수 있으며, 이를 통해 대기 시간이 긴 네트워크 상 왕복으로 인한 시간을 줄여 성능을 높일 수 있다.
- 또한, HTTP/1.1 애플리케이션은 파이프라인 커넥션을 사용하기 위해 다음과 같은 규칙을 준수해야 한다.
  1. HTTP 클라이언트는 지속 커넥션이라는 확신이 있기 전에는 요청을 파이프라이닝하지 않아야 한다.
  2. HTTP 메시지는 순서 개념이 없으므로, 응답은 요청 순서에 맞게 전송되어야 한다.
  3. HTTP 클라이언트는 커넥션이 언제 끊기더라도 남은 요청을 다시 보낼 준비가 되어 있어야 한다.
  4. HTTP 클라이언트는 POST와 같이 멱등하지 않은 메소드를 파이프라인에 요청하지 않아야 한다.

## 2026-02-15 Sun
### HTTP 메시지의 문법
```
> 모든 HTTP 메시지는 요청 또는 응답으로 구분된다.
> HTTP 요청 메시지는 서버에 임의의 동작을 요구하는 반면, 응답 메시지는 요청에 대한 처리 결과를 클라이언트에 반환한다.
```
* HTTP 요청과 응답은 모두 기본적으로 동일한 구성 요소를 갖지만, 세부적인 형식에 따라 다음과 같은 차이가 있다.
  1. 요청: 시작줄이 `<메소드> <URL> <버전>` 정보를 포함한다.
  2. 응답: 시작줄이 `<버전> <상태 코드> <사유 구절>` 정보를 포함한다.
* 이 때, 요청시 URL은 절대 경로 또는 URL의 경로 구성 요소를 명시할 수 있다.
  * 절대 경로가 아닌 경우, 서버는 생략된 호스트나 포트 정보를 자신으로 치환하는 방식으로 동작한다.
* 헤더 블록의 경우, `이름`과 `:`에 선택적인 공백을 한 칸 명시할 수 있으며, 이후 `값`과 `CRLF`로 작성되는 형태를 지키는 헤더를 0개 이상 명시한다.
  * 반면, **헤더 블록 자체가 본문의 시작과 구분하기 위한 `CRLF`를 하나 갖기에 헤더가 없더라도 시작줄과 본문은 항상 구분**될 수 있다.
* 상술했듯 본문은 선택적이며, 본문이 없는 HTTP 메시지는 `CRLF`로 끝나게 된다.
* 극단적으로, **헤더 블록과 본문이 모두 없는 HTTP 메시지의 경우에도 항상 `CRLF`를 통해 끝맺어야** 한다.
  * 그러나 본문이 없는 경우에 `CRLF`를 누락시키는 경우가 있으므로, 호환을 위해 모든 HTTP 앱은 `CRLF`로 끝나지 않는 메시지를 처리할 수 있어야 한다.

## 2026-02-16 Mon
### HTTP 메시지와 시작줄
* 상술한 바와 같이모든 HTTP 메시지는 시작줄로 시작하며, 이러한 시작줄은 요청과 응답이라는 유형에 따라 다른 구성을 갖는다.
  * 이 때, 각 구성 요소는 `<요소1> <요소2>`와 같이 공백으로 구분된다.
* 요청에 명시된 시작줄의 경우, 서버에 요청하는 리소스인 URL과 동사인 HTTP 메소드를 포함한다.
  * 또한, 클라이언트가 어떤 버전의 HTTP를 사용하고 있는지 알려주기 위한 버전 역시 포함된다.
* 응답에 명시된 시작줄의 경우, 응답 메시지의 HTTP 버전에 더해 요청에 대한 처리 결과를 의미하는 상태값인 상태 코드와 직관적인 메시지인 사유 구절이 포함된다.
* 덧붙여 HTTP/1.0의 경우, 요청에 명시된 시작줄의 마지막 구성 요소인 버전 정보와 응답의 시작줄 자체가 포함될 필요가 없었다.

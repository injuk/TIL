# HTTP
## 2025-12-15 Mon
### HTTP 메시지가 흐르는 방향
```
> HTTP 메시지는 HTTP 서버와 클라이언트 사이에서 주고 받는 데이터 블록들을 지칭한다.
```
* HTTP 메시지는 메시지의 내용과 의미를 설명하기 위한 문자 형태의 메타데이터로 시작되며, 그 이후에는 선택적으로 데이터 본문이 포함될 수 있다.
* 임의의 HTTP 메시지 한 건은 한 방향으로 흐르며, 방향에 따라 다음과 같은 용어를 사용할 수 있다.
  1. 인바운드: HTTP 메시지가 클라이언트로부터 서버로 향하는 요청의 경우
  2. 아웃바운드: HTTP 메시지의 처리가 완료된 후, 서버로부터 클라이언트로 향하는 응답의 경우
  3. 업스트림: HTTP 요청 / 응답과 무관하게 HTTP 메시지 발송자 자체를 지칭
  4. 다운스트림: HTTP 요청 / 응답과 무관하게 HTTP 메시지 수신자 자체를 지칭
* 덧붙여 업스트림과 다운스트림의 경우, HTTP 메시지는 항상 다운스트림 방향으로 흐르며 절대 업스트림으로 흐를 수 없다.

## 2025-12-16 Tue
### HTTP 메시지의 구성 요소
* **HTTP 메시지는 단순히 구조화된 데이터 블록**에 지나지 않으며, 각 메시지는 클라이언트로부터 발생한 요청이나 서버의 응답 중 하나를 포함한다.
* 이 때, **HTTP 요청 / 응답과 무관하게 HTTP 메시지는 시작줄과 헤더 블록 및 본문의 세 가지 구성 요소**를 갖는다.
  1. 시작줄: 해당 메시지가 요청이나 응답 중 어떤 유형을 갖는지 서술한다.
  2. 헤더 블록: 해당 메시지의 속성을 열거한다.
  3. 본문: 본격적인 HTTP 데이터를 포함하나, 본문은 아예 없을 수도 있다.
* 시작줄과 헤더 블록은 단지 줄 단위로 분리된 아스키 문자열에 불과하며, **각 줄은 두 글자의 줄바꿈 문자열인 `CRLF`로 끝난다**.
  * HTTP 명세에서는 줄바꿈을 위해 `CRLF`만을 허용하지만, 견고한 HTTP 앱은 일반적인 개행 문자를 처리할 수 있어야 한다.
  * 바꿔 말해, 견고하지 않은 HTTP 앱에서는 캐리지 리턴과 개행 문자를 모두 전송하지 않는 경우가 있을 수 있다.
* 본문의 경우 단순히 선택적으로 포함시킬 수 있는 데이터 덩어리에 불과한 반면, 시작줄이나 헤더와는 달리 텍스트나 이진 데이터를 포함할 수 있다.

## 2025-12-17 Wed
### HTTP 메시지의 문법
```
> 모든 HTTP 메시지는 요청 또는 응답으로 구분된다.
> HTTP 요청 메시지는 서버에 임의의 동작을 요구하는 반면, 응답 메시지는 요청에 대한 처리 결과를 클라이언트에 반환한다.
```
* HTTP 요청과 응답은 모두 기본적으로 동일한 구성 요소를 갖지만, 세부적인 형식에 따라 다음과 같은 차이가 있다.
  1. 요청: 시작줄이 `<메소드> <URL> <버전>` 정보를 포함한다.
  2. 응답: 시작줄이 `<버전> <상태 코드> <사유 구절>` 정보를 포함한다.
* 이 때, 요청시 URL은 절대 경로 또는 URL의 경로 구성 요소를 명시할 수 있다.
  * 절대 경로가 아닌 경우, 서버는 생략된 호스트나 포트 정보를 자신으로 치환하는 방식으로 동작한다.
* 헤더 블록의 경우, `이름`과 `:`에 선택적인 공백을 한 칸 명시할 수 있으며, 이후 `값`과 `CRLF`로 작성되는 형태를 지키는 헤더를 0개 이상 명시한다.
  * 반면, **헤더 블록 자체가 본문의 시작과 구분하기 위한 `CRLF`를 하나 갖기에 헤더가 없더라도 시작줄과 본문은 항상 구분**될 수 있다.
* 상술했듯 본문은 선택적이며, 본문이 없는 HTTP 메시지는 `CRLF`로 끝나게 된다.
* 극단적으로, **헤더 블록과 본문이 모두 없는 HTTP 메시지의 경우에도 항상 `CRLF`를 통해 끝맺어야** 한다.
  * 그러나 본문이 없는 경우에 `CRLF`를 누락시키는 경우가 있으므로, 호환을 위해 모든 HTTP 앱은 `CRLF`로 끝나지 않는 메시지를 처리할 수 있어야 한다.

## 2025-12-18 Thu
### HTTP 메시지와 시작줄
* 상술한 바와 같이모든 HTTP 메시지는 시작줄로 시작하며, 이러한 시작줄은 요청과 응답이라는 유형에 따라 다른 구성을 갖는다.
  * 이 때, 각 구성 요소는 `<요소1> <요소2>`와 같이 공백으로 구분된다.
* 요청에 명시된 시작줄의 경우, 서버에 요청하는 리소스인 URL과 동사인 HTTP 메소드를 포함한다.
  * 또한, 클라이언트가 어떤 버전의 HTTP를 사용하고 있는지 알려주기 위한 버전 역시 포함된다.
* 응답에 명시된 시작줄의 경우, 응답 메시지의 HTTP 버전에 더해 요청에 대한 처리 결과를 의미하는 상태값인 상태 코드와 직관적인 메시지인 사유 구절이 포함된다.
* 덧붙여 HTTP/1.0의 경우, 요청에 명시된 시작줄의 마지막 구성 요소인 버전 정보와 응답의 시작줄 자체가 포함될 필요가 없었다.

## 2025-12-19 Fri
### HTTP 메소드 - 요약
* 요청에 명시된 시작줄의 첫 구성 요소인 HTTP 메소드는 서버가 무엇을 해야할지 알려주기 위한 정보이며, **HTTP 명세는 공통 요청 메소드 집합을 정의**한다.
  * 공통 요청 메소드 집합이란, 예를 들어 `GET`이나 `POST` 등 자주 사용되는 메소드 외에 `OPTIONS`와 `TRACE` 등을 포함하는 일곱 종류를 말한다.
* 이 때, **HTTP 메소드는 그 종류에 따라 요청 메시지에 본문을 포함하거나 하지 않을 수 있다는 점에 주의**를 기울여야 한다.
  * 예를 들어, `POST`와 `PUT`을 제외한 모든 HTTP 메소드는 본문을 포함하지 않는다.
  * 이는 스펙 상 엄격히 제한된 것은 아니나, HTTP 애플리케이션을 개발하는 개발자들 사이의 일관된 합의이므로 준수할 것이 강력히 권장된다.
* HTTP는 쉽게 확장할 수 있도록 설계되었으므로, 각 서버는 모든 메소드를 구현할 필요 없으며 자신만의 특별한 `확장 메소드`를 구현할 수도 있다.

## 2025-12-20 Sat
### HTTP 상태 코드 - 요약
* HTTP 메소드가 서버에게 무엇을 해야할지 요청하듯, HTTP 상태 코드는 응답에 포함된 시작줄에 명시되어 클라이언트에게 작업 결과를 알려준다.
  * 예를 들어, 서버는 클라이언트의 요청을 처리하는 데에 성공했거나 해당 리소스를 찾지 못했을 수 있으며 이러한 결과를 HTTP 상태 코드로 표현한다.
* HTTP 상태 코드는 숫자로 작성된 코드와 문자열로 작성된 메시지인 사유 구절 형태로 구분되며, **세 자리 숫자로 백의 자리의 값에 따라 묶여 취급**된다.
  * 예를 들어, `1xx`는 정보를 의미하며 `2xx`는 성공을 의미한다.
* HTTP는 명세 상 각 범위의 일부만을 정의하며, 이는 추후 프로토콜이 진화함에 따라 더 많은 상태 코드 정의가 HTTP 명세에 포함될 가능성을 열어두었다.
* 때문에 클라이언트가 인식하지 못하는 상태 코드를 수신했을 경우, 이는 해당 서버가 현재 HTTP 명세를 의도적으로 확장하여 사용하고 있음을 의미할 수 있다.
  * 이 경우, **클라이언트는 해당하는 사용자 정의 상태 코드를 마치 임의의 범위 구간에 포함되는 것처럼 간주하도록 동작**해야 한다.

## 2025-12-21 Sun
### 사유 구절이란?
* 응답에 포함된 시작줄의 마지막 구성 요소인 사유 구절은 해당 응답에 명시된 HTTP 상태 코드에 대한 문자열 형태의 설명을 지칭한다.
  * 예를 들어, 임의의 응답에 포함된 시작줄이 `HTTP/1.1 200 OK`라면 사유 구절은 `OK`가 된다.
* 모든 사유 구절은 임의의 HTTP 상태 코드와 일대 일 대응되며, 마치 HTTP 상태 코드의 읽기 쉬운 버전처럼 취급할 수 있다.
* 이 때, **HTTP 명세는 사유 구절을 엄격히 정의하지 않으므로 개발자는 자신만의 사유 코드를 정의하여 사용하더라도 HTTP 명세를 위반하지 않는다**.

## 2025-12-22 Mon
### 버전 번호란?
```
> 버전 번호는 HTTP 애플리케이션이 지원하는 가장 높은 HTTP 버전을 명시하며, 해당 애플리케이션이 어느 HTTP의 어느 버전까지 이해할 수 있는지를 의미한다.
```
* 버전 번호는 `HTTP/x.y` 형태로 요청과 응답 각각에 포함되는 시작줄에 모두 명시된다.
  * 이는 각 **HTTP 애플리케이션이 자신이 사용하는 프로토콜 버전을 상대에게 알리기 위해 사용**될 수 있다.
* 버전 번호는 HTTP 애플리케이션들이 상대의 능력과, 사용하는 형식에 대한 단서를 제공하기 위해 사용된다.
  * 예를 들어, `1.1` 버전을 사용하는 애플리케이션은 `1.0`을 사용하는 애플리케이션과 통신하는 과정에서 `1.1`의 신규 기능을 사용할 수 없음을 알 수 있다.
* HTTP 버전 번호는 `/`로 구분되지만 분수로 읽히지 않으며, `x`와 `y`를 각각 별도로 비교한다.
  * 예를 들어, `2.22`는 `2.3`의 경우 22와 3을 비교했을 때 더 큰 수를 갖는 `2.22`가 더 높은 버전임을 알 수 있다.

## 2025-12-23 Tue
### HTTP 헤더 분류하기
* HTTP 명세는 여러 헤더 필드를 정의하며, 애플리케이션 개발자 역시 자신만의 헤더를 자유롭게 정의할 수 있다.
* 이 때, 헤더는 분류에 따라 다음과 같이 나누어 이해할 수 있다.
  1. 일반 헤더: 요청과 응답 모두가 사용할 수 있다.
  2. 요청 헤더: 요청에 대한 부가 정보를 제공한다.
  3. 응답 헤더: 응답에 대한 부가 정보를 제공한다.
  4. 엔티티 헤더: 본문의 크기나 컨텐츠 또는 리소스 그 자체를 서술한다.
  5. 확장 헤더: HTTP 명세에 정의되지 않는 새로운 헤더를 지칭한다.
* 모든 HTTP 헤더는 `<키>: <값> <CRLF>` 순서로 작성되며, 값과 콜론 사이의 공백은 있거나 없어도 무방하다.
  * 반면, **값의 길이가 너무 길다면 가독성을 위해 여러 줄로 쪼갤 수 있으나 이 경우 각 줄의 앞에는 최소 하나의 공백 또는 탭 문자가 작성**되어야 한다.

## 2025-12-24 Wed
### 안전한 HTTP 메소드
* HTTP는 안전한 메소드라고 불리우는 집합을 정의하며, `GET`과 `HEAD`는 이에 포함된다.
  * 이는 즉, 상술한 두 메소드의 처리 결과로는 서버에 어떠한 부작용도 발생하지 않음을 의미한다.
  * 예를 들어, 임의의 리소스를 서버로부터 조회하더라도 해당 리소스의 상태는 변경되지 않는다.
* 반면, 안전한 메소드가 어떠한 부작용도 일으키지 않는다는 사실은 HTTP 명세의 엄격한 규칙은 아니며 어디까지나 서버 개발자의 구현에 따라 결정된다.
* **안전한 메소드의 목적은 '안전하지 않은 메소드'를 호출할 때 무언가 부작용이 발생할 수 있다는 사실을 클라이언트에게 알려주는 데**에 있다.

## 2025-12-25 Thu
### HTTP 메소드 - GET과 HEAD
```
> 임의의 서버가 HTTP/1.1과 호환되고자 하는 경우, 자신의 리소스에 대해 `GET`과 `HEAD`를 구현해야 한다.
```
* `GET`은 가장 자주 사용되는 메소드로, 서버에 임의의 리소스를 요청하는 데에 사용된다.
* **`HEAD`는 `GET`처럼 행동하지만, 서버는 응답으로 본문 대신 헤더만을 반환**한다.
  * 덕분에 클라이언트는 리소스 자체를 확인하지 않더라도 리소스의 타입이나 존재 여부, 변경 여부 등의 메타데이터만을 조회할 수 있다.
* **서버 개발자는 `HEAD` 메소드를 구현하는 경우 해당 메소드의 반환 헤더가 `GET`의 호출 결과에 포함된 헤더와 정확히 같음을 보장**해야 한다.
* 또한, `GET`과 `HEAD`는 모두 요청에 별도의 본문을 포함하지 않는다.

## 2025-12-26 Fri
### HTTP 메소드 - PUT
* `PUT` 메소드는 서버에 리소스를 쓰는 방식으로 동작하며, 요청 URL의 이름대로 새로운 문서를 생성하거나 기생성된 문서를 교체한다.
  * 즉, 리소스가 없을 때 `PUT` 메소드를 호출하면 처리 결과에 의해 새로운 리소스가 생성된다.
  * 반면, 리소스가 있는 경우 `PUT` 메소드를 호출하면 처리 결과에 의해 해당 리소스가 변경된다.
* 일반적으로 `PUT`은 리소스를 변경하는, '안전하지 않은 메소드'에 해당하므로 인증과 인가가 요구된다.

## 2025-12-27 Sat
### HTTP 메소드 - POST
* `POST` 메소드는 서버에 입력 데이터를 전송하기 위해 설계되었다는 점에서 `PUT`과는 차이가 있다.
  * 다시 말해, **`PUT`은 서버가 관리하는 임의의 리소스에 데이터를 입력하기 위해 사용**된다.
  * 반면, **`POST`는 서버에 데이터를 보내는 것 자체에 그 의의**를 둔다.
* 서버는 `POST` 메소드를 통해 전달된 데이터를 필요한 다른 곳에 포워딩하거나, 자신이 직접 처리할 수 있다.

## 2025-12-28 Sun
### HTTP 메소드 - TRACE
* 클라이언트의 요청은 방화벽이나 프록시 및 게이트웨이 등 다양한 매체를 경유하여 서버에 전달될 수도 있으며, 이 경우 요청은 중간에 변조될 가능성이 있다.
* **`TRACE` 메소드는 이러한 경우에 고려될 수 있으며, 클라이언트에게 자신의 요청이 서버에 도달했을 때 어떤 모습을 갖는지 알려준다**.
  * 요청의 마지막 단계에 있는 서버는 자신이 받은 요청 메시지를 본문에 그대로 반환하며, 클라이언트는 이를 통해 요청이 어떻게 변경되는지 확인할 수 있다.
* `TRACE` 메소드는 주로 진단을 위해 사용되지만, 중개자들이 여러 HTTP 메소드에 대해 일관된 동작을 보장한다고 가정한다는 한계를 갖는다.
  * 실제로는 프록시와 같은 중개자들은 `POST`와 `GET`에 대해 서로 다른 동작을 수행하는 경우가 많다.
  * 다시 말해, **`TRACE` 메소드는 HTTP 메소드를 구별할 수 있을만한 별도의 기능을 제공하지 않는다**.
* `TRACE` 역시 다수의 HTTP 메소드와 같이 요청에 별도의 본문을 포함하지 않는다.

## 2025-12-29 Mon
### HTTP 메소드 - OPTIONS
* **`OPTIONS` 메소드는 서버에게, 임의의 리소스에 대한 지원 범위에 대해 질의하기 위해 사용되는 HTTP 메소드**이다.
  * 다시 말해, 서버에게 임의의 리소스에 대한 어떤 HTTP 메소드 요청을 허용하는지 질의한다.
* `OPTIONS` 메소드를 사용하며 클라이언트는 리소스에 대해 실제로 접근하여 결과를 확인하는 식으로 동작할 필요 없이도 어떻게 접근해야할지 확인할 수 있다.
* `OPTIONS` 역시 다수의 HTTP 메소드와 같이 요청에 별도의 본문을 포함하지 않는다.

## 2025-12-30 Tue
### HTTP 메소드 - DELETE
* 명시적인 이름에서도 알 수 있듯, `DELETE` 메소드는 서버에게 해당 리소스를 삭제할 것을 요청한다.
* 반면, **클라이언트는 `DELETE` 호출을 통해 해당 리소스가 반드시 삭제될 것을 보장받을 수는 없다**.
  * 이는 **HTTP 명세 자체적으로 서버가 클라이언트에게 알리지 않고 삭제 요청을 무시하는 것을 허용하기 때문**이다!
* `DELETE` 역시 다수의 HTTP 메소드와 같이 요청에 별도의 본문을 포함하지 않는다.

## 2025-12-31 Wed
### HTTP 메소드 - 확장 메소드
```
> 확장 메소드는 `HTTP/1.1`에 정의되지 않은 메소드를 지칭한다.
```
* HTTP는 명세상 필요에 따라 확장할 수 있음을 보장하므로, 새로운 기능을 추가하더라도 기존 애플리케이션들의 오동작을 유발하지 않는다.
* 확장 메소드는 개발자들에게 자신이 구현한 서버가 관리하는 리소스에 대한 능력을 확장하는 수단으로써 기능한다.
* 잘 알려진 확장으로 `LOCK`이나 `COPY`, `MOVE` 등이 존재하지만 이들은 HTTP 명세에 정의된 것이 아님에 주의해야 한다.
  * 때문에 대부분의 애플리케이션은 이러한 확장 메소드를 이해하지 못하며, 내 애플리케이션조차 이해할 수 없는 메소드 요청을 수신할 수 있다.
* 반면, **확장 메소드에 대해서는 관용적으로 동작할 수 있도록 서버를 구현하는 것이 권장**된다.
  * 예를 들어, 알려지지 않은 메소드에 대한 요청에 대해서는 501 코드를 반환하는 식으로 구현해볼 수 있다.
  * 이렇듯 **확장 메소드와 같은 확장을 다루는 경우에는 '엄격하게 보내고 관대하게 받아들이기'라는 규칙을 따르는 것이 바람직**하다.

## 2026-01-01 Thu
### HTTP 상태 코드 - 100 Continue
```
> 상태 코드 100-199 구간은 정보성 상태 코드를 의미하며, 대표적으로 100과 101이 존재한다.
> 해당 구간의 코드는 서버와의 통신 과정에서 주로 최종 응답이 아닌 임시 응답의 뉘앙스로 사용된다.
```
- 클라이언트가 요청시 본문을 포함하지 않고 `Expect: 100-Continue`를 전송했을 때, 이는 다음과 같은 의미를 갖는다.
  - 클라이언트는 서버에게 본문을 전송하고자 한다.
  - 클라이언트는 서버가 다룰 수 없거나 너무 큰 본문을 보내지 않도록 확인하고자 한다.
- 초기에는 100 상태 코드를 잘못된 용도로 사용한 경우가 많았기에, 서버가 100으로 응답하지 않았더라도 클라이언트가 본문을 보내는 것이 권장된다.
- **서버는 `Expect: 100-Continue` 헤더가 포함된 요청에 대해 `100 Continue` 또는 에러 코드로 답해야 한다**.
  - 바꿔 말해, **서버는 이 외의 경우에는 절대로 `100 Continue`로 응답하지 않아야 한다**.
- 반면, 서버가 `100 Continue`를 보내기 전에 이미 본문을 수신했다면 서버는 해당 상태 코드로 응답할 필요가 없다.
  - 대신 모든 본문을 읽을 후에 최종 상태 코드로 응답할 필요가 있다.
- 서버는 `100 Continue`를 기대한 요청에 대해 에러로 응답하고자 하는 경우, 클라이언트가 응답을 받도록 구현해야 한다.

## 2026-01-02 Fri
### HTTP 상태 코드 - 101 Switching Protocols
- `101`은 서버가 클라이언트의 프로토콜 변경 요청을 수락했을 때 사용된다.
- 대표적인 예시로는 `WebSocket` 연결이 있으며, 다음과 같은 시나리오에 따라 프로토콜을 변경하게 된다.
  1. 클라이언트가 `Upgrade: websocket` 헤더를 포함하여 요청하는 것으로 HTTP 대신 `WebSocket` 사용을 제안한다.
  2. 서버는 이를 수락할 경우 `101 Switching Protocols` 응답을 반환한다.
  3. 이후 통신은 `WebSocket`을 기반으로 진행된다.

## 2026-01-03 Sat
### HTTP 상태 코드 - 2xx
- 클라이언트가 전송한 요청은 대부분의 경우에 성공하며, 서버는 성공을 의미하기 위해 `2xx` 응답을 사용할 수 있다.
- `200 OK`의 경우,  요청이 정상적으로 처리되었으며 엔티티 본문에 요청된 리소스가 포함된다.
- `201 Created`의 경우, 요청 성공에 신규 리소스가 생성되었다는 의미를 명확히하기 위해 사용된다.
  - 이 때, 새로운 리소스의 위치를 응답 헤더의 `Location: /resources/1`과 같이 명시하는 것이 권장된다.
- `202 Accepted`의 경우, 요청은 정상적으로 접수되었으나 서버가 동작을 수행하지 않았음을 의미한다.
  - 때문에 **해당 응답 코드의 경우, 서버가 요청의 처리를 정상적으로 완료할 것인지 보장할 수 없다**.
  - `202 Accepted` 응답은 주로 오랜 시간이 걸리는 비동기 처리 작업 요청에 대한 응답으로 사용된다.
- `204 No Content`의 경우, 요청은 성공했으나 응답할만한 본문이 딱히 없는 경우에 사용될 수 있다.
  - 예를 들어, `DELETE`에 대한 응답은 돌려줄만한 데이터가 없기에 해당 상태 코드를 적용하기에 바람직하다.
  - 또한, 브라우저가 해당 응답을 받은 경우 페이지를 새로고침하지 않고 유지하며 화면만을 갱신하므로 효율적이다.

## 2026-01-04 Sun
### HTTP 상태 코드 - 300 Multiple Choices
- **`3xx` 코드는 리다이렉션 상태 코드이며, 클라이언트가 원하는 리소스에 대해 다른 위치를 사용하도록 유도하거나 다른 대안 응답을 제공하기 위해 사용**된다.
  - 예를 들어, 리소스의 위치가 변경된 경우 리다이렉션 상태 코드와 옮겨진 리소스의 위치를 `Location` 헤더에 명시할 수 있다.
  - 또한, 브라우저는 이에 대해 사용자를 귀찮게 하는 대신 직접 새로운 위치를 이동하는 식으로 편의성을 높인다.
- `300 Multiple Choices`는 클라이언트가 요청한 리소스에 대해 서버가 반환할 수 있는 데이터가 여럿인 경우에 고려할 수 있다.
  - 예를 들어, 요청 받은 임의의 영상 리소스의 확장자가 하나 이상인 경우 해당 상태 코드와 함께 목록을 반환하여 브라우저의 선택을 유도할 수 있다.
- 그러나 현재로서는 컨텐츠 협상 기술의 발달로 인해 거의 사용되지 않으며, 대신 `Accept: video/mp4`와 같은 헤더를 활용하는 것이 권장된다.

## 2026-01-05 Mon
### HTTP 상태 코드 - 301 Moved Permanently
- `301 Moved Permanently`의 경우, 요청된 URL의 리소스가 영구적으로 옮겨졌을 때 사용될 수 있다.
  - 때문에 응답 헤더에는 `Location` 정보가 명시될 필요가 있으며, 이를 통해 브라우저는 새로운 리소스 주소를 캐싱한 후 즉시 요청할 수 있도록 한다.
- 반면, **해당 상태 코드는 HTTP 상태 코드를 유지하지 않고 `GET`으로 변경하므로 데이터 유실 가능성이 있음에 주의**해야 한다.
  - 이에 이를 보완한 `308 Permanent Redirect`가 제안되었으며, 이 경우 HTTP 메소드를 유지하는 특징이 있다.

## 2026-01-06 Tue
### HTTP 상태 코드 - 302 Found
- `302 Found`의 경우 리소스가 일시적으로 다른 곳에 있음을 의미하며, 임시 이동에 해당하므로 `301`과 달리 새로운 주소를 캐싱하지 않는다.
  - 또한, 이 역시 `301`과 동일하게 데이터 유실 가능성을 수반하므로 `307 Temporary Redirect` 코드가 고안되었다.
- `302 Found` 역시 리다이렉션 상태 코드에 해당하므로, 응답 헤더의 `Location`을 명확히 명시해줄 필요가 있다.

## 2026-01-07 Wed
### HTTP 상태 코드 - 303 See Other
- `303 See Other`는 클라이언트에게 리소스를 다른 URL로부터 조회할 것을 권장하기 위해 사용하며, 역시 `Location` 헤더를 활용한다.
- 해당 상태 코드는 **주로 `POST` 요청에 대한 응답으로 리소스의 위치를 반환하기 위해 사용**된다.
  - 관련된 패턴으로는 `Post-Redirect-Get` 패턴이 있으며, 작업 결과를 다른 곳에서 확인하도록 유도하는 뉘앙스를 갖는다.
- 이 때, 해당 상태 코드는 요청 메소드와 관계 없이 반드시 `GET`으로 리다이렉트하도록 강제하는 특징을 갖는다.
  - 이는 **`302 Found`와 유사하지만, `302`가 잘못된 관례가 고착된 경우라면 `303`은 명세상 `GET`으로 바꿀 것을 명시하는 표준**에 해당한다.
  - 실무 관점의 경우, RESTful API를 엄격히 설계하는 개발자들은 리소스 생성 요청에 대해 해당 상태 코드를 적극적으로 사용한다.

## 2026-01-08 Thu
### 참고 - 리소스 생성시 응답 상태 코드
- 상술한 내용에 따라, 리소스 생성에 대한 서버의 응답으로는 `201`과 `303`을 고려할 수 있다.
- 이 중, **일반적으로 가장 권장되는 응답은 `201 Created`임에 주의**할 필요가 있다.
  - `201`의 경우, `Location` 헤더에 새로 생성된 리소스의 경로를 명시함과 동시에 본문을 통해 생성된 리소스에 대한 JSON 문서를 반환할 수 있다.
  - 때문에 **클라이언트는 단 한 번의 요청만으로도 생성 요청과 요청 처리 결과, 생성된 리소스의 모든 정보를 반환받을 수 있기에 효율적**이다.
- 반면, `303 See Other`의 경우 생성된 리소스에 대한 추가적인 `GET` 요청을 유발하므로 트래픽이 많은 API에서는 성능적인 아쉬움을 갖는다.
- 그러나 `303`의 진가는 브라우저 환경에 있으며, 생성 요청 후 브라우저에 의한 강제 리다이렉션이 유발되는 PRG 패턴을 적용할 수 있다.
  - 이 경우, **리소스 생성 요청 후 사용자 실수에 의한 새로고침 상황에서 리소스 중복 생성을 방지**할 수 있다.

## 2026-01-09 Fri
### HTTP 상태 코드 - 304 Not Modified
- `304 Not Modified`의 경우 리다이렉션보다는 재사용에 가까운 뉘앙스를 주며, 웹 성능 최적화의 핵심에 위치하는 상태 코드로 이해할 수 있다.
- 예를 들어 `image.png`를 다운로드 받은 경우, 서버에게 `If-Modified-Since` 헤더를 포함하는 `GET` 요청으로 리소스의 수정 여부를 질의할 수 있다.
  - 서버는 이를 확인한 후 수정되지 않았다면 본문이 포함되지 않은 `304` 응답을 반환하는 것으로 브라우저가 캐시의 파일을 그대로 사용할 수 있도록 유도한다.

## 2026-01-10 Sat
### 참고 - 302 Found와 307 Temporary Redirect
- `HTTP/1.0`을 사용하는 클라이언트가 POST에 대해 `302`를 수신한 경우, `Location`에 포함된 위치에 `GET` 요청을 전송하는 식으로 리다이렉션한다.
  - 이는 바꿔 말해, **HTTP/1.0 서버 역시 이러한 동작을 기대하고 `302`를 반환할 것임을 의미**한다.
- 그러나 HTTP/1.1 명세는 상술한 형태의 리다이렉션에 `303`을 권장하므로, 두 버전의 혼용에 의한 혼란이 유발되었다.
- 이러한 혼란을 방지하기 위해 HTTP/1.1 명세는 일시적인 리다이렉트에 `307`을 사용할 것을 권장한다.
  - 이는 서버가 HTTP/1.0 클라이언트를 위해 `302` 응답을 남겨두는 것으로 하위호환성을 유지할 수 있도록 하기 위한 조치이다.
  - 바꿔 말해, **서버는 리다이렉트 응답에 사용할 적절한 코드를 선택하기 위해 클라이언트의 HTTP 버전을 검사할 필요**가 있다.

## 2026-01-11 Sun
### HTTP 상태 코드 - 4xx
```
> 서버는 잘못한 게 없으니, 클라이언트가 확인하라
```
- 서버가 다룰 수 없는 데이터를 클라이언트가 요청한 경우, 서버는 `4xx` 응답을 반환한다.
- 이 때, 대표적인 `4xx` 응답 코드는 다음과 같이 정리할 수 있다.
  1. `400 Bad Request`: 클라이언트의 요청 문법이 잘못되었거나, 필요한 파라미터가 누락되거나 데이터 타입이 일치하지 않는다.
  2. `401 Unauthorized`: 인증이 필요하지만 사용자가 인증되지 않았음을 의미하며, 주로 `Authorization` 헤더의 누락으로 인해 발생한다.
  3. `403 Forbidden`: 인증된 사용자의 권한 부족으로 인한 인가 실패 상황을 의미한다.
  4. `404 Not Found`: 클라이언트의 요청 리소스가 존재하지 않음을 의미하며, 때로는 데이터가 물리적으로 존재하더라도 이를 숨기기 위해 사용될 수도 있다.

## 2026-01-12 Mon
### HTTP 상태 코드 - 409 Conflict
- `409 Conflict`는 요청 자체는 문법적인 이상이 없어 `400`이 아니지만, 데이터의 무결성이나 비즈니스 로직 상 다양한 상황에서 도입될 수 있다.
- 예를 들어, `409` 응답이 적용될 수 있을만한 대표적인 상황은 다음과 같다.
  1. UNIQUE 제약 조건: Id 충돌 등으로 인한 유일성 제약 조건이 위배될 수 있는 경우
  2. 상태 충돌: 주문을 예로 들어, 이미 배송된 주문을 취소하고자 하는 경우
  3. 동시성 제어: 여러 클라이언트가 동일한 리소스를 동시에 수정하고자 하는 경우
  4. 관계에 의한 처리 불가: 예를 들어 임의의 폴더에 파일이 생성되어 있어 정책상 삭제할 수 없는 경우
- 일반적으로 `400 Bad Request`와 혼동되곤 하지만, 두 상태 코드는 다음과 같이 차이점을 정의할 수 있다.
  1. `400 Bad Request`: **애초에 말이 되지 않는 요청이 전송**된 경우
  2. `409 Conflict`: **요청 자체는 말이 되지만, 논리적으로 허용 불가능한 요청**이 전송된 경우

## 2026-01-13 Tue
### HTTP 상태 코드 - 410 Gone
- `410 Gone` 상태 코드는 **과거엔 있었던 리소스이나, 의도적으로 영원히 제거되어 다시 복구할 수 없다는 뉘앙스를 주기 위해 사용**된다.
  - `404 Not Found`의 경우 해당 **리소스가 원래 없었는지, 잠깐 제거되었는지 등의 정보를 줄 수 없다는 점과 비교되는 `410`의 특징에 해당**한다.
- `410` 응답 코드는 검색 엔진과 봇에 대해 다시는 해당 리소스가 돌아오지 않는다는 의미를 전달하므로, 이후 발생할 수 있는 불필요한 요청을 방지한다.
  - 반면, `404` 응답의 경우 해당 리소스가 언젠가 생성될 수도 있기에 검색 엔진과 봇의 불필요한 요청을 유발한다.
- 실무적 관점에서, 대부분의 경우 `404`를 사용하지만 `더 이상 관리되지 않고, 앞으로도 관리되지 않을` 뉘앙스를 명확히 전달하기 위해 고려될 수 있다.

## 2026-01-14 Wed
### HTTP 상태 코드 - 5xx
- 클라이언트가 올바른 요청을 전송했으나, 클라이언트 외적인 오류로 인해 응답할 수 없는 경우 `5xx` 응답 코드를 확인할 수 있다.
- 이 때, 대표적인 `5xx` 응답 코드는 다음과 같이 정리할 수 있다.
  1. `500 Internal Server Error`: 버그 등에 의해 서버 측 에러가 발생했으나, 그 원인을 명확히 알려주고 싶지는 않은 경우에 적용할 수 있다.
  2. `501 Not Implemented`: 서버가 지원하지 않는 기능을 요청한 경우에 대한 응답으로 고려될 수 있다.
  3. `502 Bad Gateway`: 프록시용 서버가 요청 응답 연쇄 상 다음 링크에 위치한 서버에 접근할 수 없는 경우를 의미한다.
  4. `503 Service Unavailable`: 서버가 동작하고 있으나, 점검 또는 과부하 등의 원인으로 인해 현재로서는 응답할 수 없음을 의미한다.
  5. `504 Gateway Timeout`: 프록시용 서버가 시간 내에 다음 링크에 위치한 서버로부터 응답을 받지 못한 경우를 의미한다.
- 반면, **`503`의 경우 응답에 포함된 `Retry-After` 헤더에 초 단위로 표현된 정수를 명시하여 클라이언트에게 복구 시점을 알려주는 것이 권장**된다.

## 2026-01-15 Thu
### HTTP 헤더 분류하기
- 헤더와 메소드는 클라이언트와 서버가 각각 무엇을 할지 결정하기 위한 정보이며, 특히 헤더의 경우 다음과 같은 분류가 가능하다.
  1. 일반 헤더: 클라이언트와 서버가 모두 사용할 수 있는 일반적인 목적의 헤더이다.
  2. 요청 헤더: 요청 메시지에 사용되는 헤더이며, 클라이언트가 서버에게 부가 정보를 전달하기 위해 사용할 수 있다.
  3. 응답 헤더: 클라이언트에게 추가적인 정보를 전달하기 위해 서버가 사용하는 헤더이다.
  4. 엔티티 헤더: 본문에 삽입된 데이터에 대한 정보를 전달하기 위한 헤더이다.
  5. 확장 헤더: 애플리케이션 개발자들에 의해 추가된 사용자 정의 헤더이며, HTTP 명세에 정의되지 않은 비표준 헤더를 지칭한다.
- 특히, HTTP 애플리케이션은 공식적으로 정의되지 않은 비표준 헤더인 확장 헤더 역시 서로에게 올바르게 주고 받아야할 책임을 갖는다.
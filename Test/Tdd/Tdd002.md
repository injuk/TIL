# Tdd
## 2022-08-02 Tue
## Rhythm of tdd
### TDD의 리듬
* 테스트 주도 개발의 리듬은 다음과 같이 요약할 수 있다.
  1. 빠르게 테스트를 하나 추가한다.
  2. 모든 테스트를 실행한 후, 새로 추가한 것이 실패하는지 확인한다.
  3. 코드를 조금 수정한다.
  4. 모든 테스트를 실행한 후, 전부 성공하는지 확인한다.
  5. 성공했다면, 리팩토링을 통해 중복을 제거한다.
* 테스트 주도 개발을 처음 시작하는 개발자는 다음과 같은 사실에 대해 놀랄 수 있지만, 이는 자연스러운 현상이다.
  1. 각각의 테스트가 기능 별 증가분을 커버한다.
  2. 새로운 테스트를 동작시키기 위해 작고 못생긴 변화를 실행한다.
  3. **너무나도 자주 테스트**한다.
  4. 수 없이 작은 단계를 통해 리팩토링해나간다.

### TODO 리스트 작성하기
* 임의의 기능을 프로젝트에 추가하는 경우, 우선 TODO 리스트를 작성하여 앞으로 어떤 일을 수행해야할지 정리한다.
  1. 리스트의 항목에 대해 작업을 시작한 경우, 굵은 글씨체로 표시한다.
  2. 작업을 완료한 경우, 취소선을 그어 표시한다.
  3. 작업 도중 새로운 할 일이 떠오른 경우, 리스트에 새로운 항목을 추가한다.
* **TODO 리스트를 작성했다면, 이제 객체를 만들기 전에 어떤 테스트를 작성할지 먼저 생각**해본다.
  * 만약 임의의 할 일이 너무 복잡해보인다면, 더 잘게 나누어 작은 것부터 시작하거나 아예 시작하지 않는다.

### 테스트 작성하기
* **테스트를 작성하기 시작할 때, 우선 객체가 수행할 수 있는 연산인 오퍼레이션의 완벽한 인터페이스에 대해 상상**한다.
  * 이렇게 상상된 API를 테스트 코드로 표현한 후에 시작한다.
* **최초의 테스트 코드는 완전할 필요가 없으며, 우선 실패하는 테스트를 만들고 최대한 빠르게 성공하는 것을 목표로 작은 단계로 시작**한다.
* 이렇게 작성하는 테스트 코드는 클래스의 메소드와 필드는 물론, 클래스 자체도 존재하지 않는 상태에서 작성하므로 컴파일조차 되지 않는다.
  * 이를 기본 생성자, 스텁 구현 메소드, 원시 타입 필드 등을 통해 최대한 빠르게 컴파일 가능하게 만든다.
  * 이 때, **스텁 구현이란 컴파일만될 수 있도록 만들어낸 메소드의 껍데기를 의미**한다.
* 테스트는 컴파일 가능해지더라도 실패하며, 실패한 테스트는 개발자를 주눅들게 할 수도 있다.
  * 그러나 **이는 실패의 구체적인 척도를 갖게된 것이며, 왜 실패하고 이를 통과시키기 위해 무엇을 해야할지 알 수 있게 되므로 큰 진척**으로 받아들여야 한다.
  * 또한, **이후에는 테스트 코드를 통과시키기 위해 완벽한 해법을 제시하기보다는 최대한 빠르게 통과하는 것을 목표로 하는 것이 바람직**하다.

### 첫 번째 테스트 성공
* **테스트가 성공하도록 코드를 구현하거나 수정한 것은 긍정적이나, 이에 안주하기보다는 다음과 같은 주기를 완성시키는데 집중하는 것이 바람직**하다.
  1. 작은 테스트를 추가한다.
  2. 모든 테스트를 실행하고, 테스트가 실패하는 것을 확인한다.
  3. 코드를 약간 수정한다.
  4. 모든 테스트를 실행하고, 테스트가 성공하는 것을 확인한다.
  5. 중복을 제거하기 위해 리팩토링한다.
* 또한, 이러한 주기 안에서 이루어지는 각 단계가 너무 작다고 해서 아쉬워하지 말아야 한다.
  * **TDD의 핵심은 작은 단계를 반드시 밟아야한다는 사실 자체가 아닌, 작은 단계를 밟을 줄 아는 능력을 가져야한다는 것**이다.
  * 정말 작은 단계로 구현하는 방법을 항상 연습해야 하며, 이를 토대로 저절로 적잘한 크기로 작업할 수 있는 소양을 기를 수 있게 된다.

### 첫 번째 테스트 성공 - 결론
* 이렇듯 간단한 테스트 주도 개발은 항상 다음과 같은 작업으로 시작된다.
  1. 현재까지 알고 있는 지식을 토대로 작업해야 할 테스트 목록을 만든다.
  2. **오퍼레이션이 외부에서 어떻게 보이기를 원하는지를 코드로 표현**한다.
  3. 끔찍한 코드를 작성하여 테스트를 통과시킨다.
  4. **돌아가기만 하는 코드를 점진적으로 일반화**한다.
  5. 새로운 할 일들을 즉시 처리하는 대신, TODO 리스트에 추가하고 넘어간다.

## 2022-08-03 Wed
## 느낌을 테스트로 표현하기
### TDD 주기 자세히보기
```
> 다시, TDD의 궁극적인 목적은 동작하는 깔끔한 코드를 얻는 것이다.
```
* **일반적인 TDD 주기는 테스트를 작성하고, 실행 가능하게 만들고, 수습하는 짧은 단계로 구성**된다.
* **테스트를 작성하는 과정에서는 오퍼레이션이 코드에 어떤식으로 드러나길 원하는지 우선 생각**해야 한다.
  * 원하는 인터페이스가 어떻게 구성되길 원하는지, 이러한 올바른 답을 위해 필요한 요소는 무엇인지 고려하고 모두 포함시킨다.
  * 즉, **테스트 코드는 단순히 기능을 확인하는 것이 아닌 이상적인 오퍼레이션은 어떤 형태여야하는지 표현하는 역할을 수행**한다.
* **실행 가능하게 만드는 과정에서 가장 중요한 것은 최대한 빠르게 성공하여 초록 막대를 확인하는 것**이다.
  * 이 과정에서 깔끔하고 단순한 해법이 보인다면 이를 빠르게 입력한다.
  * 그러나 **깔끔하고 좋은 해법을 알지만, 구현하는 데 수 분 이상 걸릴 것 같은 문제는 일단 따로 작성해둔 후에 초록 막대를 확인하는 본업으로 돌아온다**.
* 이제 코드가 동작한다면 내가 저질러둔 코드를 수습해야 한다.
  * 이 과정에서 **올바른 소프트웨어를 만들고, 중복을 제거하면서 초록 막대를 지속적으로 확인**한다.

### 동작하는 깔끔한 코드란?
```
> 동작하는 깔끔한 코드를 성취하는 것은 최고의 프로그래머들에게도 어려운 목표이며, 대부분의 평범한 프로그래머들에게는 거의 불가능한 일이다.
```
* 이렇듯 **불가능한 일을 해내기 위해서는 우선 문제를 나누어 정복할 필요**가 있다.
  * 즉, 동작하는 깔끔한 코드를 얻어야한다는 전체 명제를 나누어 `동작하는` 을 우선 해결한다.
  * 그 후에 `깔끔한 코드` 문제를 해결하는 것에 TDD의 본질이 숨어 있다.
* **동작하는 깔끔한 코드를 만드는 과정에서 초기 테스트 코드로 표현했던 인터페이스가 수정되는 경우, 망설이지 말고 테스트 코드 역시 수정**해야 한다.
  * **올바른 구현이 무엇인가에 대한 개발자의 추측이 완벽하지 못한 것처럼, 올바른 인터페이스에 대해 추측한 테스트 코드 역시 절대 완벽할 수 없다**.

### 최대한 빠르게 초록 막대를 맞이하기
* 테스트 코드를 작성하는 과정에서, 최대한 빠르게 초록 막대를 보기 위한 전략 중 자주 사용되는 분류는 다음과 같다.
  1. 가짜 구현: **우선 상수를 반환하도록 하고, 진짜 코드를 얻을 때까지 점진적으로 변수를 도입**한다.
  2. 명백한 구현: 실제 구현을 입력한다.
* 실무에서는 자신이 뭘 해야할지 아는 경우에 명백한 구현을 주로 사용한다.
  * 이 때, **중간 중간 테스트 코드를 실행했을 때 빨간색을 마주한다면 가짜 구현 기법을 도입하여 올바른 코드로 리팩토링**한다.
  * 이 과정에서 **자신감을 되찾으면 다시 명백한 구현 기법을 사용하며, 이렇듯 TDD에서는 두 방법을 번갈아가며 사용**하게 된다.

### 느낌을 테스트 코드로 담아내기
* TDD를 진행하는 과정에서, 설계상 결함이 있다는 느낌을 받는 경우 다음과 같이 진행할 수 있다.
  1. 우선 **설계상의 결함을 파악하고, 그 결함으로 인해 실패하는 테스트 케이스를 작성**한다.
  2. 스텁 구현을 통해 컴파일을 최대한 빠르게 통과하도록 한다.
  3. 이제 올바르다고 생각하는 코드로 리팩토링한 후, 다시 테스트를 통과한다.
* 이렇듯 **부작용에 대한 혐오감과 같은 느낌을 테스트로 바꿔나가는 것은 TDD의 일반적인 주제**이다. 
  * 또한, **이러한 작업을 많이 경험할수록 미적 판단을 테스트로 변환하는 것에 점점 익숙**해진다. 
* 이를 토대로 설계에 대한 논의는 우선 올바른 행위에 대한 결정을 내린 후, 이에 다다를 수 있는 최상의 방법에 대해 이야기할 수 있게 된다.

## Value object
### 값 객체와 테스트
* **어떤 수에 1을 더한 경우, 개발자는 기존 값 자체가 변경되는 것이 아닌 새로운 값이 반환될 것을 기대**한다.
* 반면, 객체는 기본적으로 이러한 특성이 없으나 구현에 따라서는 객체 역시 값처럼 사용할 수 있다.
  * **이러한 구현 방식은 값 객체 패턴이라고 지칭**할 수 있다.
* 값 객체 패턴을 적용한 경우, 값 객체는 다음과 같은 의미를 갖게 된다.
  1. **값 객체에 대한 모든 연산은 기존 값 객체에 영향을 주지 않으며, 새로운 값 객체를 반환**한다.
  2. 값 객체는 equals() 메소드를 재정의하여 같은 값을 갖는 객체끼리의 동일성을 보장해야 한다.
  3. 당연히 hashCode() 메소드도 재정의해야하며, 이는 해시 컨테이너에서 값 객체를 사용하기 위함이다.
* 당연히 **값 객체에 대한 테스트를 작성하는 경우, 값 객체임을 증명할 수 있도록 상술한 특징을 중점적으로 테스트**할 수 있어야 한다.
  * 이렇듯 **적용한 디자인 패턴이 또 다른 오퍼레이션을 암시하는 경우가 있으며, 테스트 코드를 통해 이를 표현하고 검증**할 수 있어야 한다.

### 삼각 측량 전략
* 삼각 측량이란, 두 수신국이 하나의 라디오 신호를 감지할 때 필요한 조건을 충족한다면 발신지를 알 수 있다는 점을 이용한 측량법이다.
* 반면 **테스트 코드에서, 삼각 측량 전략이란 두 개의 예제를 통해 코드를 일반화하는 전략**을 말한다.
  * 이 때, **두 번째 작성된 테스트 코드가 더 일반적인 결과를 필요로 할 때에만 일반화를 적용**해야 한다.
* 값 객체의 equals를 테스트하는 예제에서, equals를 테스트하기 위한 전략은 크게 다음과 같을 수 있다.
  1. 같은 값을 갖는 두 값 객체를 equals로 비교하였을 경우, 가짜 구현 전략을 통해 동일성을 보장하기 위해 상수 true를 반환하도록 정의하였다.
  2. 신중한 테스트 기법인 삼각 측량 기법을 적용하기 위해, 다른 값을 갖는 두 값 객체를 비교하는 단언을 추가한다.
  3. 테스트는 실패하며, **두 번째 작성된 테스트인 단언이 더 일반적인 결과를 요구하므로 일반화를 적용**한다.

### 삼각 측량 전략의 특징
* 테스트 코드를 작성하는 과정에서, 일반적인 해법을 구할 방법이 보인가면 그대로 구현한다.
  * 즉, 한 번에 끝낼 수 있는 일이라면 굳이 또 다른 테스트 코드를 작성할 필요가 없다.
* 반면, **설계를 어떻게 해야할지 떠오르지 않거나 어떻게 리팩토링해야할지 감조차 오지 않는 경우라면 삼각 측량 전략은 유용**하다.
* 이렇듯 **삼각 측량 전략은 애플리케이션이 어떠한 변화 가능성을 지원해야하는지 등, 문제를 다른 방향에서 바라볼 기회를 제공**할 수 있다.

## 표현력
### 테스트로 의도를 표현하기
* **객체가 갖는 오퍼레이션이 어떤 역할을 하는지 테스트는 가능한 한 정확히 이를 표현**할 수 있어야 한다.
  * 예를 들어, **오퍼레이션이 할 수 있는 동작만을 서술하는 것이 아닌 일련의 명제와 단언을 통해 오퍼레이션의 의도를 드러내야** 한다.

### TDD와 위험 요소
```
> 테스트 주도 개발은 완벽한 코드를 위해 절치부심하는 방법론이 아니다.
```
* **TDD를 진행하는 개발자는 완벽함을 위해 노력하지 않으며, 단지 모든 사실을 코드와 테스트로 두 번씩 말하는 것으로 결함의 정도를 낮추고자 한다**.
  * 이렇듯 TDD는 두 번 말하는 것으로 자신감을 가진 상태에서 전진할 수 있도록 지원하는 역할을 맡는다.
* 때문에 **임의의 기능을 적절히 검증하는데 실패한다면, 이와 연관된 다른 테스트 코드 역시 검증에 실패할 수 있다는 사실을 이해**해야 한다.
  * 예를 들어, 값 객체의 equals 메소드에 대한 검증 자체가 잘못되었다면 값 객체를 활용하여 연산하는 테스트 역시 올바른 것으로 볼 수 없다.
  * 또한, **이는 TDD 진행 과정에서 적극적으로 관리해야할 위험 요소**이기도 하다.
* **TDD 속에서는 언제나 결함이 우리의 예상을 빠져나갈 수 있음을 인정하며, 이를 보완하기 위해 어떻게 테스트를 작성해야 했는지 교훈을 얻을 수 있어야** 한다.
  * 즉, 둘 이상의 테스트는 동시에 실패할 수도 있다는 사실을 인식할 필요가 있다.
  * 그러한 **위험 요소가 있음에도 테스트로부터 교훈을 얻고, 테스트를 보완하여 계속해서 진행할 수 있어야 한다**.
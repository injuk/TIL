# Tdd
## 2022-08-07 Sun
## 필요 없는 것은 지우기
### 테스트 코드의 제거
* 리팩토링을 통해 중복을 제거하는 과정에서, 때로는 클래스 자체를 삭제할 필요가 있다.
  * **이 경우, 해당 클래스를 검증하기 위해 존재했던 테스트 코드 역시 함께 삭제하는 것이 바람직**하다. 
  * 이렇듯 기존에는 필요했지만 리팩토링 등의 이유로 인해 더 이상 필요 없게 된 테스트는 적시에 제거해도 무방하다.
* **테스트 코드 역시 개발자가 유지 보수해야할 자산이며, 마찬가지 이유에서 중복 제거의 대상**이 된다.

## 메타포
### 커다란 기능을 작은 메타포로 나누기
* 테스트 대상 기능이 너무 커 어떻게 구현해야할 지 감이 잡히지 않는 경우, 우선 이를 작은 테스트로 줄이는 방식으로 접근한다.
* 이렇게 **나누어진 작은 테스트는 여러 연산으로 이루어지며, 이러한 연산 각각에 대해 적절할 메타포를 신중히 고민할 수 있게 된다**.
  * 이 때, **선정된 메타포는 각각 대응되는 객체가 될 수 있다**.
  * 최초로 선정했던 메타포의 이름이 다소 어색하게 느껴질 수는 있으나, 이는 어디까지나 객체의 이름에 불과하므로 추후에 더 좋은 메타포로 대체할 수 있다.
* 이렇게 추려진 메타포를 기반으로 기존의 테스트를 수정하며, 이후로트는 테스트를 컴파일하고 실행하는 기존 TDD의 주기를 따를 수 있다.

### 통찰을 지원하는 TDD
* 설계 상 어려운 제약을 마주쳤을 때, TDD는 명쾌한 통찰을 보장해주지는 못한다.
  * **대신 확신을 주는 테스트와 잘 정리된 코드를 통해, 통찰에 대한 준비와 통찰을 적용할 준비를 할 수 있다**.

## 테스트 코드 품질 높이기
### 모든 중복을 제거하기
```
> 현재 작업 중인 코드 상의 모든 중복이 제거되기 전까지 테스트에 완료 처리를 할 수는 없다.
```
* 테스트 코드 역시 우리가 관리해야 할 자산이므로, 높은 품질을 유지할 방법을 고려해야 한다.
* 예를 들어, **테스트 역시 테스트 대상의 내부 구현에 깊게 관여하지 않아야 한다**.
  * 이러한 특징은 테스트의 유연성을 떨어트리며, 대신 테스트 대상이 제공하는 연산의 외부 행위에 집중해야 한다.
* **테스트 대상 메소드가 클래스를 명시적으로 검사하여 달리 동작하는 식으로 구현되었다면, 다형성을 적용하도록 수정**할 수 있다.
  * 이를 통해 지저분한 캐스팅과 클래스 검사 코드를 모두 제거할 수 있다.
  * 반면, 단순히 테스트를 통과하기 위해 빠르게 구현하는 것이 목적이라면 우선 캐스팅을 활용하여 테스트를 성공시킨 후에 리팩토링해도 무방하다.
* **객체의 동작과 관련된 상수가 코드와 테스트 사이에 중복해서 사용되는 경우, 객체의 속성 또는 메소드를 이용하여 이러한 중복을 제거할 수 있도록 수정**한다.

## 2022-08-08 Mon
## 테스트 코드의 지속적인 보완
### 실패를 테스트로 표현하기
* **기능의 추가 또는 수정이 완료되어 이를 테스트 코드로 확인하는 경우, 종종 예상치 못한 예외 케이스에 의해 테스트가 실패하는 경우**가 있다.
  * 또는, 좋은 상황은 아니지만 운영 코드가 예상치 못한 상황으로 인해 실패하는 경우도 마주칠 수 있다.
* **이러한 경우에는 이슈를 수정하는 것에 그치지 않고, 수정 과정에서 우리가 알아낸 것을 반드시 테스트 코드로 작성해두는 것이 바람직**하다. 
  * 이를 통해 우리가 발견한 내용을 머릿 속에만 담아두는 것이 아니라, 다른 개발자들에게도 공유할 수 있게 된다.

### 테스트 코드를 보완하지 않아도 되는 경우
* 테스트 코드를 작성하고 코드를 리팩토링하는 과정에서 필요에 의해 신규 객체를 추가하는 경우, 상황에 따라 해당 객체의 테스트 코드를 작성하지 않을 수 있다.
  * 예를 들어, **신규 추가되는 객체가 이미 기존 테스트 코드에 의해 기능이 충분히 검증 되는 경우가 이에 해당**한다.
  * 이 경우, 리팩토링을 마치고 모든 테스트가 통과한다면 이미 신규 추가된 객체가 실제로 사용되었으며 정상 동작한다고 생각해도 무방하다. 

## 앞으로 나아가는 방법
### 앞으로 나아가기 위한 갈림길
* 코드를 수정하기 위해 앞으로 나아갈 수 있는 방법은 크게 다음과 같다.
  1. 좁은 범위의 한정적인 테스트를 빠르게 작성해나간 후에 일반화하기
  2. 또는 개발자의 모든 실수를 컴파일러가 잡아줄 것이라 믿고 진행하기

## TDD의 경제성
### 기록으로 남기기
* **테스트를 작성하는 것은 단지 개발자의 프로그래밍 경험을 향상시키기 위한 것 뿐만이 아닌, 추후에 코드를 읽을 다른 사람에게 도움이 되기 위함이기도** 하다.
  * 때문에 **코드를 작성할 때에는 운영 코드 뿐만 아니라 테스트 코드의 경우에도 미래의 독자를 고려**해야 한다.

### 그 이전 방식과 비교하기
* TDD료 개발해나가는 경우, 테스트 코드의 라인 수와 모델 코드의 라인 수는 거의 비슷해지는 경향이 있다.
* 때문에 **TDD가 경제적이기 위해서는, 매일 만들어내는 코드가 그 이전의 두 배이거나 각 모델 코드의 길이가 절반이어야** 한다.
  * **TDD가 기존 방식과 어떻게 다른지 직접 측정해야 하며, 이 때 디버깅과 통합 및 다른 개발자에게 설명하는 시간 등 외적 요인이 반드시 포함**되어야 한다.

## 2022-08-09 Tue
## 회고하기
### 다음에 해야할 일들
* TDD의 세상에서 완벽한 완료는 존재하기 어렵다.
  * 즉, **TDD를 완벽을 위한 노력의 일환으로 활용할 수도 있으나 이는 TDD의 가장 효과적인 용법은 아니다**.
* 시스템이 커질수록 개발자가 자주 수정하는 부분들은 절대에 가까운 견고성을 가져야 하며, 이로 인해 안심한 상태에서 수정을 가할 수 있다.
* 반면 시스템에서 자주 바뀌지 않는 부분을 손보는 경우에도 비록 테스트의 밀도는 낮겠지만, 여전히 안심한 상태에서 수정할 수 있다.
* **TDD가 어느 정도 궤도에 오르고 난 후에도 다음에 해야할 일은 어떤 테스트를 추가로 작성할지 고민하는 것**이다.
  * 예를 들어, 자신이 작성한 테스트 코드에서 실패해야하는 테스트가 성공하는 경우 이러한 원인을 찾아 표현해야 한다.
  * 또는 실패해야 할 테스트가 실패한 경우, 필요에 따라 실패한 테스트를 기록 용도로 사용할 수도 있다.
* **TDD를 진행하는 과정에서 업데이트해 나갔던 TODO 리스트가 비었다면, 그 때까지 설계한 내용을 검토하기엔 적절한 시기**로 볼 수 있다. 

### 메타포
* 같은 프로그램을 작성하더라도, 매 번 떠오르는 메타포는 다를 수 있다.
* **메타포란 단지 클래스나 변수의 이름을 얻어내기 위해 사용하는 것이 아니며, 오히려 설계에도 직접적인 영향을 주는 요소**이다.
  * **메타포에 따라 성능이 우려되는 상황이 발생할 수 있으나, 섣부르게 최적화하기 전에 어느 정도의 통계를 기다리는 것이 바람직**하다.

### 테스트 코드와 실제 코드의 비교
* **일반적으로 테스트 코드와 실제 코드의 함수 및 라인 개수는 비슷하게 유지**된다.
  * 테스트 코드의 라인 수는 공통된 픽스쳐를 추출하는 것으로 줄일 수 있으나, 그럼에도 실제 코드와의 대략적인 라인 수의 비율은 유지된다.
* **테스트 코드에는 분기 또는 반복문 등의 명시적인 흐름 제어 구문이 없어야 한다**.
  * 또한, 실제 코드에서도 가능한 한 다형성으로 문제를 처리하는 것이 바람직하다.

### TDD 프로세스
* TDD의 주기는 다음과 같이 진행된다.
  1. 작은 테스트를 추가하기
  2. 모든 테스트를 실행하여 실패를 확인하기
  3. 코드를 수정하기
  4. 모든 테스트를 실행하여 성공을 확인하기
  5. 중복을 제거하기 위해 리팩토링하기
* 이러한 **하나의 테스트를 작성하는 것을 단일 단계라고 가정할 때, 이를 컴파일하여 실행 후 리팩토링하는 데에 드는 수정 횟수는 충분히 적게 유지**된다.
  * 나아가, 프로젝트의 규모가 커지더라도 수정 횟수는 충분히 적게 유지된다.

### 테스트의 품질
* TDD의 과정에서 정의되는 테스트들은 시스템의 생명 주기와 함께할 수 있을 정도로 유용하지만, 다음의 테스트를 반드시 대체할 수 있는 것은 아니다.
  1. 성능 테스트
  2. 부하 테스트
  3. 사용성 테스트
* **그러나 TDD 코드의 결함 밀도가 충분히 낮은 경우, 테스팅은 의사소통을 증폭시키는 역할을 수행**할 수 있다.
  * 예를 들어, 시스템이 무엇을 해야할 지 알고 있는 사람들과 이를 실제로 구현하는 사람들 사이의 의사소통을 증폭시킬 수 있다.

### 테스트의 지표
* **명령문 커버리지는 항상 테스트의 질적인 평가 기준이 될 수는 없으나, 테스트의 시작점이기도 하다**.
  * TDD는 100%의 명령문 커버리지를 이상적인 상황으로 본다.
* **결함 삽입은 테스트의 질을 평가하는 또 다른 방법이며, 코드의 의미를 바꾼 후에 테스트가 실패하는 것을 확인**한다.
  * 해당 작업은 수동으로 할 수도 있으나, Jester와 같은 별도의 도구를 사용할 수도 있다.
* 테스트 커버리지를 향상시키는 방법은 크게 다음과 같다.
  1. 더 많은 테스트를 작성하기
  2. 또는 **테스트의 수는 그대로 둔 채, 프로그램의 로직을 단순화**하기
* 특히 두 번째 방식은 적절한 리팩토링을 통해 얻어질 수 있으며, 개발자는 모든 입력의 경우를 토대로 테스트 커버리지를 높이는 대신 코드를 줄이도록 해야 한다.
  * 예를 들어, **테스트는 그대로 둔 채 코드를 단순화하여 동일한 테스트가 다양한 경우를 다룰 수 있도록 해야 한다**.

### 결론
* 테스트를 확실하게 돌아가도록 하는 세 가지 접근 법은 다음과 같다.
  1. 가짜 구현
  2. 삼각 측량법
  3. 명백한 구현
* **설계를 주도하기 위한 방법으로 테스트 코드와 실제 코드 사이의 중복을 제거**할 수 있다.
* **TDD 과정에서, 테스트 사이의 간격은 개발자가 유동적으로 조절할 수 있어야 한다**.
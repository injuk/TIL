# Tdd
## 2022-08-11 Thu
### 어떻게 테스트할 것인가?
* 어떻게 테스트할 지 알 수 있으려면, 우선 다음과 같은 항목에 대해 답할 수 있어야 한다.
  1. 테스트한다는 것은 무엇일까?
  2. 테스트는 언제 해야할까?
  3. 테스트 대상 로직은 어떻게 선정할 것인가?
  4. 테스트 대상 데이터는 어떻게 선정할 것인가?

### 테스트
```
> 작성한 소프트웨어를 테스트하기 위해서는 반드시 자동화된 테스트를 만들어야 한다.
```
* 모든 개발자는 아무리 작은 변화라도 테스트하지 않고 릴리즈하지는 않으며, 반드시 테스트를 진행한다.
  * 그러나 **변화를 테스트하는 것과 자동화된 테스트를 갖고 있는 것은 전혀 같지 않다**.

### 자동화된 테스트
* 스트레스와 테스트의 실행은 다음과 같은 밀접한 연관 관계를 갖는다.
  1. 스트레스를 많이 받으면 테스트를 더 적게 수행하게 된다.
  2. 테스트 코드를 더 적게 작성하게 되면, 개발자가 만들어내는 에러는 점점 많아진다.
  3. 에러가 많아지만, 개발자는 더 많은 스트레스를 받게 된다.
  4. 반복된다.
* 이러한 **양성 피드백 고리에서 빠져나오기 위해서는 단순한 테스트의 수행을 자동화된 테스트로 치환할 필요**가 있다.
* 테스트는 개발자의 두려움을 지루함으로 바꾸어주며, 스트레스를 받기 시작할 때 실행할 수 있는 상태를 유지한다.
  * 즉, **스트레스를 더 많이 받을수록 테스트를 더 자주 실행하게 되며 이로 인해 에러의 발생 가능성을 줄일 수 있다**.

### 바빠서 테스트할 시간이 없다
* 상술한 이유로 인해 스트레스를 더 많이 받을수록 결국 실패하게 된다.
  * 즉, 테스트를 능동적으로 수행하지 않는 프로젝트는 성공을 보장할 수 없다.
* 반면, **자동화된 테스트가 있는 경우에는 두려움의 정도를 개발자가 스스로 선택할 수 있게 된다**.

### 격리된 테스트
```
> 테스트의 실행은 서로에 대해 아무런 영향을 주지 않아야 한다.
```
* 이상적인 테스트는 다음과 같은 특징을 가져야 한다.
  1. **충분히 빨라 개발자가 직접, 자주 실행할 수 있어야 한다**.
  2. **하나의 테스트가 실패한 것으로 다른 테스트가 영향을 받지 않아야 한다**.
* 이로 인해 **테스트는 전체 애플리케이션을 대상으로 동작하기 보다는 더 작은 단위를 테스트하는 것이 바람직**하다.
  * 또한, **각각의 테스트는 다른 테스트들과 완전히 독립적이어야** 한다.
* 이렇듯 격리된 테스트를 작성하는 데에 성공하게 된다면, 테스트는 실행 순서에도 독립적이게 된다.
  * 즉, **테스트의 선행 순서를 걱정하지 않고도 일부만을 실행할 수 있어야 한다**.
* **테스트를 격리하는 작업은 결과적으로 시스템의 응집도는 높으면서도, 결합도는 낮은 객체의 모음으로 구성되도록 한다**. 
* **일반적으로 이러한 방식으로 시스템을 설계하는 것은 어렵지만, 격리된 테스트를 수행하는 습관을 들이면 자연스레 시스템을 이상적인 방향으로 설계**하게 된다.

### 테스트 목록
```
> 작업을 시작하기 전에 우선 작성해야 할 테스트의 목록을 모두 적어둔다.
```
* 스트레스를 줄이는 접근법의 처음은 작업의 방향이 확실해지기 전까지는 전진하지 않는 것이다.
* 개발 과정에서 발생하는 새로운 일은 지금 할 일일지, 나중에 해도 되는 일에 속하거나 아예 필요하지 않은 일인지 결정한다
  * 구현해야할 모든 것을 목록화하고, 우선 구현할 필요가 있다면 오퍼레이션의 사용 예시를 작성한다.
  * 그 다음으로 아직 존재하지 않는 오퍼레이션의 널 버전을 목록에 작성한다.
  * **마지막으로는 깔끔한 코드를 얻기 위해, 해당 작업을 끝내기 전에 반드시 해야할 리팩토링 목록을 작성**한다.
* **테스트를 통과하는 과정에서 개발자가 작성하는 코드에는 새로운 테스트가 필요함을 암시적으로 알리는 부분이 존재**한다.
  * 이러한 새 테스트 역시 리팩토링과 마찬기지로 할 일 목록에 작성해야 한다.

### 신중한 등반
* 신중한 등반가들은 두 다리와 두 팔중 셋은 항상 고정하는 규칙을 따른다.
* 이는 **순수한 TDD에서, 초록 막대 상태에서는 한 번에 하나만 수정하는 규칙과 유사**한 점이 있다.

### 세션이 완료된 후
```
> 제대로 작동하지 않는 테스트를 생각해냈다면, 이를 제대로 통과하도록 만드는 것이 코드 릴리즈보다 더 중요하다.
```
* 세션이 완료되었을 때까지도 목록에 남아 있는 항목들은 따로 신경써서 관리하는 것이 바람직하다.
  * 예를 들어 어떠한 기능을 하나 진행하는 중인 경우, 다음 번 세션에서도 같은 목록을 사용할 수 있다.
* 현재 작업 범위를 넘어서는 큰 리팩토링 목표는 다음 할 일 목록으로 옮길 수 있다.

## 2022-08-12 Fri
### 테스트 우선하기
```
> 테스트 코드는 테스트 대상 코드를 작성하기 '직전에' 작성하는 것이 바람직하다.
```
* 상술한 양성 피드백에 의해, 스트레스가 커질수록 테스트는 충분치 않아질 가능성이 높아진다.
  * 반면 테스트가 충분치 않을수록 스트레스 역시 커질 가능성이 높으므로, 이러한 악순환으로부터 빠져나갈 방법이 필요하다.
* **코드를 작성하기 전에 우선 테스트를 작성한다는 규칙을 도입할 경우, 양성 피드백의 악순환으로부터 성공적으로 빠져나와 선순환에 이를 수 있다**.
  * 테스트를 먼저 진행하므로 스트레스는 줄고, 이로 인해 더 많은 테스트를 진행하게 된다.
  * 그러나 **스트레스는 여러 요인으로부터 발생하기 쉬우므로, 테스트는 또 다른 효과적인 주기의 영향을 받을 필요**가 있다. 
* 또한 **테스트는 애플리케이션의 설계를 다시 고려하거나 작업 범위 조절에 유용한 즉각적인 이점**을 줄 수 있다. 
  * 이로 인해 어느 정도는 스트레스가 존재하는 상황에서조차 테스트를 작성하는 것은 항상 좋다.

### 단언 우선하기
```
> 테스트 코드를 작성하기 시작한 경우, 우선 단언을 가장 먼저 작성하는 것이 바람직하다.
```
* 단언을 우선해야한다는 규칙은 다음과 같은 흐름을 통해 명백하게 드러난다.
  1. 시스템을 개발하는 경우, 완성된 시스템이 어떨 것이라는 이야기부터 작성한다.
  2. 특정 기능을 개발하는 경우, 기능이 완료되었을 때 통과할 테스트부터 작성한다.
  3. **테스트를 개발하는 경우, 완료될 때 통과해야 할 단언부터 작성**한다.
* **단언을 먼저 작성하면 작업을 단순하게 만드는 강력한 효과를 얻어낼 수 있다**.
* **단언을 우선 작성하는 경우, 단언을 만족시키기 위한 일련의 과정을 역순으로 쉽게 추적하며 테스트를 작성**할 수 있다.
  * 즉, 작은 단계를 통해 빠르게 피드백을 받으며 테스트의 개요를 작성해나갈 수 있다.

### 테스트 데이터 패턴
```
> 테스트 코드를 보는 개발자가 쉽게 읽을 수 있고, 따라가기 좋을 만한 데이터를 사용한다.
> 데이터 간에 차이가 존재하는 경우, 그 속에는 반드시 어떠한 의미가 존재해야 한다.
```
* **테스트 데이터는 여러 의미를 담는 동일한 상수의 사용을 지양**한다.
  * 예를 들어, 더하기 메소드를 테스트한다면 두 개의 1보다는 1과 2 등을 테스트 데이터로 사용한다.
* 다음과 같은 몇몇 경우에 실세계에서 사용되는 데이터를 테스트 데이터로 활용하는 것은 유용할 수 있다.
  1. 예전 시스템의 출력과 현재 시스템의 출력을 비교하는 경우
  2. 또는 정밀한 부동소수점을 다루는 시스템을 리팩토링한 후 기존과 정확히 동일한 결과가 반환되는지 확인하는 경우

### 명백한 데이터 사용하기
```
> 테스트 자체에 예상되는 값과 실제 값을 포함하여 둘 사이의 관계를 명시적으로 드러낼 수 있도록 노력하는 것이 바람직하다.
```
* **테스트를 작성할 때에는 언제나 또 다른 누군가가 테스트 코드를 읽는 것을 가정하며, 가능한 한 많은 단서를 남겨야 한다**.
  * 무엇보다, 일반적으로 또 다른 누군가는 미래의 내가 될 확률이 가장 높다.
* 보다 명백한 데이터를 사용하며, 값 자체보다는 입력과 출력의 관계를 묘사하는 데에 집중한다.
* **명백한 데이터를 사용하는 경우, 단언에 우선 식을 작성하는 것으로 다음에 무엇을 작성해야할지 쉽게 알 수 있게 된다**.
* 명백한 데이터는 자칫 매직 넘버를 사용하지 말라는 것처럼 비추어보일 수 있다.
  * 물론, 단일 메소드 내부에서라면 매직 넘버 간의 관계는 충분하게 드러낼 수 있다.
  * **그럼에도 이미 정의된 기호 상수가 존재하는 경우, 매직 넘버보다는 기호 상수를 활용하는 것이 바람직**하다.
# Tdd
## 2022-08-09 Tue
## xUnit 살펴보기 
### 테스트 프레임워크의 기능
* 일반적인 테스트 프레임워크의 필수적인 기능은 크게 다음과 같다.
  1. 우선 setUp을 호출한다.
  2. 이후에 tearDown을 호출한다.
  3. 테스트 메소드가 실패하더라도 tearDown을 호출한다.
  4. 여러 개의 테스트를 실행할 수 있다.
  5. 수집된 결과를 출력할 수 있다.

### 일반화 리팩토링
* **일반적인 리팩토링의 패턴은 하나의 특화된 사례에만 동작하는 코드를 다른 사례에서도 적용할 수 있도록 일반화하는 것**이다.
  * 이 과정에서 상수를 변수로 변환하게 된다.
  * 또한, 상수는 반드시 데이터 값이 아닌 하드 코딩된 코드일 수도 있다.
* **이러한 리팩토링 방식은 단순히 머리 속 추론이 아닌, 잘 돌아가는 구체적인 사례로부터 시작할 수 있도록 지원한다는 점에서 TDD와 잘 맞는다**.

### TDD의 작업 단위
* TDD를 한 번 마스터하고 나면 예상보다 큰 기능 단위로 작업을 진행할 수 있다.
* 그러나, **TDD를 마스터하기 위해서는 반드시 필요할 때 아주 작은 단계로도 작업하는 방법을 배워야 한다**.
  * TDD에서 발생 가능한 최악의 경우는 큰 단계로 시작하여 실패하고, 다시 작은 단계로 돌아오는 것이다.

### 테스트 패턴
* 테스트 케이스를 작성해 나가다보면 이윽고 다음과 같은 공통된 패턴을 발견하게 된다.
  1. arrange: 객체를 생성하고 테스트를 준비한다.
  2. act: 객체에 어떤 자극을 주어 행동하게 한다.
  3. assert: 객체가 남긴 행동의 결과를 검사한다.
* **상술한 세 단계를 가리켜 3A라고도 부르며, 일반적으로 2.와 3.은 항상 다르지만 1.은 여러 테스트에 걸쳐 유사한 경우가 많다**.
* 이러한 패턴이 더 큰 규모에서 반복되는 경우, 테스트를 위해 객체를 준비하는 과정에서 다음과 같은 문제에 직면하게 된다.
  1. 성능: 테스트는 가능한 한 빨리 실행되어야 한다.
  2. 격리: 한 테스트의 결과가 다른 테스트에 영향을 주지는 않아야 한다.

### 테스트 디커플링
* 테스트 사이의 커플링은 다음과 같은 사례가 발생할 수 있으므로 지저분한 결과를 낳는다.
  1. 하나의 테스트가 깨져 다른 올바른 테스트들이 모두 깨질 가능성이 있다.
  2. 테스트가 실행되는 순서에 따라 결과가 달라질 가능성이 있다.
  3. 이에 따라, 하나의 테스트가 분명 잘못되었지만 실행 순서에 따라 테스트에 통과할 가능성이 있다.
* 이러한 이유에서 **테스트 케이스 간의 커플링은 지양해야하며, 서로 격리된 테스트 코드를 작성하는 것이 바람직**하다.

## 2022-08-10 Wed
### tearDown 메소드
* setUp 메소드에서 외부 자원을 할당 받는 경우, 테스트의 독립성 유지를 위해 자원을 다시 반환할 필요가 있다.
  * 이 때, 각 테스트 케이스 이후에 호출되는 **tearDown 메소드는 자원을 반환하기에 적절한 역할을 수행**한다.

### 리팩토링을 망설이지 않기
* 앞서 중복된 코드를 제거하는 과정에서 리팩토링한 것을 다시 되돌리는 것은 흔한 일이며, 이에 따른 개발자들의 대처는 크게 다음과 같다.
  1. 했던 일을 되돌리기 귀찮아서 중복이 서넛 발생할 때까지 기다린다.
  2. 또는 **작업 시간의 대부분을 설계에 할당하기 위해 반사적으로 리팩토링**한다.

### 테스트 구현 순서
* 일반적으로 테스트 구현 순서는 중요하며, 기본적으로 자신에게 가르침을 줄 수 있고 확실히 개발할 수 있는 기능을 우선적으로 선택할 수 있다.
* 또한, **테스트를 구현하는 과정에서 문제가 발생한 경우 한 두 걸음 물러서서 다시 시작할 것을 고려**할 수 있다.
  * 모든 테스트가 성공한 매 시점을 체크 포인트 삼아 되돌릴 수 있는 환경이 지원된다면 더욱 좋다.
* 자주 다루었듯, 각 테스트를 구현한 후 기능을 작업하는 TDD 주기는 다음과 같이 진행된다.
  1. 작업 선정
  2. 테스트 작성 및 실행 후 실패 확인
  3. 가짜구현, 삼각 측량, 등을 사용하여 구현
  4. 테스트 실행 후 성공을 확인
  5. **일반화 기법을 통해 코드를 올바르게 수정, 리팩토링**
  6. 코드에서 중복을 제거
  7. 반복
* 이 때, **코드를 수정하기 위해서조차 또 다른 테스트 코드의 작성이 필요하다는 점을 반드시 기억**해야 한다. 
  * 이렇듯 **언제나 신규 코드의 작성 또는 기존 코드의 수정 이전에 새로운 테스트를 먼저 작성해야한다는 점을 의식적으로 떠올리는 것이 바람직**하다.
  * **이 과정에서 중요한 문제를 발견했다면, 이를 즉시 처리하기보다는 TODO 리스트에 적어 관리**하도록 한다.
* 테스트를 통과시키지 못하고 일부분만 구현하고 넘어가는 것은 중대한 TDD 규칙 위반에 해당한다.

### 테스트 수트
* **테스트 수트는 컴포지트 패턴의 순수한 예제이며, 이를 통해 테스트 하나와 테스트의 집단을 동일하게 다룰 수 있다**.
  * 컴포지트 패턴의 주요한 제약 중 하나는 컬렉션조차 마치 하나의 개별 항목인 것처럼 반응되어야 한다는 점이다.

## 2022-08-11 Thu
### xUnit 결론
* xUnit은 많은 프로그래밍 언어 용도로 포팅되어 있으나, 다음과 같은 이유료 인해 개발자 자신이 직접 xUnit을 구현해볼 가치는 충분하다.
  1. 숙달되기: **xUnit의 정신은 간결함에 있으며, 수 많은 사람이 짧은 코드로부터 큰 은혜를 입게 한다**.
     * 직접 만들어 사용하는 xUnit은 마치 숙달된 도구를 사용하는 느낌을 줄 수 있다.
  2. 탐험하기: 새로운 프로그래밍 언어를 접하는 경우, 해당 언어로 xUnit을 만드는 도전을 해 볼 수 있다.
     * **테스트를 열 개 가량 통과할 즈음에는 해당 언어로 프로그래밍하며 접하게 될 많은 기능을 경험**해볼 수 있다.
* Junit의 경우, 간단한 Test 인터페이스를 구현하는 것으로 자신의 테스트를 실행하도록 만들 수 있다.
* 반면, 동적 타이핑 언어에서는 인터페이스를 구현할 필요조차 없이 그저 해당 오퍼레이션을 구현하기만 하면 된다.
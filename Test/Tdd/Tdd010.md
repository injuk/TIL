# Tdd
## 2022-08-18 Thu
### 리팩토링
* 일반적인 리팩토링은 어떠한 상황에서도 애플리케이션의 겉보기 동작에 해당하는 의미론을 변경하지 않아야 한다.
* 반면, **TDD에서는 리팩토링을 특이한 방법으로 사용하며 리팩토링이 테스트 집합에 변화를 주지 않아야한다는 점에 주목**한다.
  * 즉, **일반적인 경우에 리팩토링은 겉보기 동작에 초점을 맞추나 TDD는 이미 통과한 테스트들에 집중**한다.
  * 또한, TDD에서 의미론이 유지되는 상황이란 단지 테스트 케이스 하나가 통과하는 것을 말할 수도 있다. 
* 이러한 관측상의 동치성이 성립되기 위해서는 충분한 테스트를 유지하는 것이 필수적이다.
  * 이 때, **충분한 테스트란 현재의 테스트들에 기반한 리팩토링이 추측 가능한 모든 테스트에 기반한 리팩토링과 동일한 것으로 여겨질 수 있는 상태**를 말한다.
  * 때문에 문제가 있다는 것은 인지했으나 테스트에 통과했으니 상관 없다는 생각은 금물이며, 이 경우에는 충분한 테스트를 충족시키도록 테스트를 더 작성해야 한다.
  
## TDD 마스터하기
### 각 단계의 크기
* TDD의 과정에서 겪는 각각의 단계의 크기의 결정에는 다음과 같은 질문이 숨어 있다.
  1. 각각의 테스트가 다뤄야만 하는 범위는 얼마나 넓을까?
  2. 리팩토링 과정에서 얼마나 많은 중간 단계를 겪어야 할까?
* 결론적으로, **테스트 주도 개발자는 둘 모두를 수행할 수 있어야 한다**.
* **시간이 지남에 따라 테스트 주도 개발자의 경향은 더 작은 단계를 수행하는 것으로 귀결**된다.
* 리팩토링의 초기에는 아주 작은 단계로 기꺼이 작업할 준비가 되어 있어야 하며, 이에 익숙해질수록 몇 단계를 건너 뛰어가며 자신의 주기를 찾을 수 있다.
  * 이 때, 자동화된 리팩토링 툴은 리팩토링의 양과 질을 엄청나게 상승시킨다.

### 무엇을 테스트하지 말아야 할까?
```
> 두려움이 지루함으로 변할 때까지 테스트를 작성하는 것이 바람직하다.
```
* 기본적으로, 다음의 분류는 테스트를 작성해야 한다.
  1. 조건문
  2. 반복문
  3. 연산자
  4. 다형성
* **중요한 것은 자신이 작성한 것에 대해서만 테스트하는 것이며, 불신할 이유가 없다면 다른 개발자가 작성한 코드를 테스트할 필요는 없다**.
  * 반면, 서드 파티 코드에서 버그가 발생한 경우 해당 문제가 수정되었을 때 실패할 테스트를 작성하여 문서화하는 방법을 선택할 수 있다.

### 설계에 문제가 있는 테스트의 특징
* 하나의 단순한 단언을 수행하기 위해 수백 줄의 객체 생성 코드가 필요한 경우, 이는 분명히 설계 상의 문제가 존재함을 의미한다.
  * 예를 들어, 이러한 경우에는 객체가 너무 크다는 것을 의미하므로 분리할 필요가 있다.
* **공통의 설정 코드를 작성할만한 장소를 찾기 어려운 경우, 이는 간접적으로 객체 간의 결합도가 너무 높음을 의미**한다.
* 실행 시간이 오래 걸리는 테스트의 경우, 애플리케이션의 작은 부분만을 따로 테스트하기 어렵다는 것을 의미한다.
  * **작은 부분만 테스트할 수 없다는 특징언 명백히 설계 상의 문제를 암시**한다.
* **깨지기 쉬운 테스트는 애플리케이션에 위치한 임의의 코드가 다른 부분에 바람직하지 않은 방향으로 영향을 준다는 것을 의미**한다.
  * 이 경우, 객체 간의 결합도를 낮추어 연결을 끊거나 둘을 합치는 방식으로 설계를 변경할 것을 고려해야 한다.

### 미래를 고려하지 않기
* TDD에서는 아이러니하게도 코드의 미래에 대해 고려하지 않고 현재에 집중하는 것으로 인해 코드가 더욱 뛰어난 적응성을 가질 수 있도록 한다.
  * **TDD는 `오늘을 위해 코딩하고, 내일을 위해 설계하라`는 고전적인 조언을 정확히 뒤집어 `내일을 위해 코딩하고 오늘을 위해 설계`한다**.
* 이러한 TDD의 특징 아래에서 다음과 같은 상황을 겪을 수 있게 된다.
  1. 첫 기능을 구현한다: 해당 기능은 단순하고 직관적으로 구현되며, 짧은 시간 내에 결함도 적은 상태로 만들어진다.
  2. 첫 기능의 변주인 두 번째 기능을 구현한다: 두 기능 사이의 중복은 한 곳으로 모이고, 서로 다른 부분은 다른 곳으로 옮겨진다.
  3. 앞선 두 기능의 변주인 세 번째 기능을 구현한다: 공통 로직은 약간의 수정만을 통해서 재활용 가능할 상태로 만들어진다.
     * 또한, **공통적이지 않은 로직들은 서로 다른 메소드 또는 클래스 등 명확히 로직이 위치해야 할 장소에 배치되는 경향**이 생긴다.
* **TDD 아래에서 OCP는 서서히 준수되어지며, 이는 발생하지 않은 변주는 잘 표현하지 못하지만 발생한 변주의 종류는 잘 표현하는 TDD의 특징에서 기인**한다.
  * 이를 통해 발생한 변주의 종류들을 잘 표현하는 애플리케이션을 작성할 수 있게 된다.
* 오랜 시간이 흐른 후에 일반적이지 않은 변화가 발생하더라도 문제는 없으며, 정확히 필요한 지점에서만 설계가 변경될 수 있다.
  * **이 과정에서 잠시 OCP를 위배할 수 있지만, 아무 것도 잘못하지 않았다는 확신을 줄 수 있는 수 많은 테스트가 존재하므로 이는 큰 문제가 되지 않는다**.

### 테스트를 얼마나 작성해야 할까?
* 개발자는 자신의 경험과 숙고 과정을 토대로 테스트를 얼마나 많이 작성할지 결정해야 한다.
  * 예를 들어, **어떠한 구현에 대한 지식이 충분히 신뢰할 만 하다면 굳이 테스트를 작성하지 않아도 무방**하다.
* **정말 발생할 일이 없을 것만 같은 테스트를 작성하는 것은, 해당 조건이 아예 발생하지 않을 것이라고 증명할 수 있는 경우를 제외하고는 가치가 있다**.
  * **TDD에서 테스트에 대한 관점은 실용적이며, 테스트는 단지 크게 신뢰할 수 있는 코드라는 하나의 목적을 위한 수단 중 하나**이다.
* 객체의 구현을 의도적으로 무시하는 블랙박스 테스트는 그 자체로 가치가 있으나, 이는 TDD와는 다른 방식에 해당한다.
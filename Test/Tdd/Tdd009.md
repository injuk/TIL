# Tdd
## 2022-08-15 Mon
### 단언은 구체적으로 명시하기
* 테스트가 잘 동작했는지 확인하기 위해, 불린 값을 반환하는 표현식을 활용하여 애플리케이션이 자동으로 동작성을 판단하도록 작성하는 것이 바람직하다.
  * 테스트를 완전히 자동화하려면 결과를 평가하기 위해 필요한 사람의 개입을 모두 드러내야 한다.
  * 즉, **테스트 버튼을 클릭하면 코드가 올바르게 동작하는지 확인하는 모든 판단 역시 컴퓨터가 실행하는 코드여야 한다**.
* **단언의 결과는 불린이어야 하며, 결과로 반환되는 불린 값은 컴퓨터에 의해 검증되어야 한다**.
* 또한, **단언은 구체적이어야 하며 무엇을 검증하는지 명시적으로 드러나야 한다**.
  * 예를 들어, 모든 것을 assertTrue로 검증하기보다는 필요에 따라 assertEquals를 활용해야 한다.
  * xUnit 역시 자신이 테스트하는 대상이 동등성임을 아는 경우, 그에 맞는 친절한 에러 메시지를 작성할 수 있다.
* **객체는 가능한 한 블랙 박스로 취급되어야 하며, 테스트 케이스는 객체의 내부 구현에 의존하지 않아야 한다**.
  * **화이트박스 테스트만을 필요로 하는 것은 테스트의 문제 이전에 발생한 설계 문제**이다.
* jUnit의 경우, 첫 번째 매개 변수에 선택적으로 테스트를 설명하는 메시지를 작성할 수 있다.
  * 일반적으로 선택적 매개 변수는 메소드 시그니쳐에서 매개 변수 목록의 마지막에 위치하지면, jUnit은 테스트의 가독성을 높이기 위해 이러한 방식을 채택하였다.
  * **첫 번째 매개 변수에 단언에 대한 설명을 명시할 경우, 오류 발생시 디버그와 코드 수정에 큰 도움을 받을 수 있다**.

### 픽스쳐 활용하기
```
> 여러 테스트에서 테스트를 시작하기 위해 공통적으로 테스트 대상 객체를 초기화하는 경우, 이를 테스트 픽스쳐라고 한다.
```
* 어려 테스트로부터 공통적으로 사용되는 객체들을 생성하는 경우, setUp 메소드를 재정의할 수 있다.
  * 예를 들어, **각 테스트 코드에 존재하는 지역 변수를 인스턴스 변수로 바꾸고 setUp으로부터 인스턴스 변수들을 초기화**한다.
  * 습관적으로 테스트 대상이 되는 모델 코드(= 운영 코드)에서 중복을 제거하듯, 테스트 코드로부터 발생하는 중복 역시 제거되어야 한다.
* 객체를 초기화하는 코드가 중복되는 경우, 모델 코드와 마찬가지로 다음과 같은 중복성 이슈가 발생하기 쉽다.
  1. 테스트를 작성하는데 상대적으로 더 많은 시간을 소모하게 된다.
  2. **인터페이스를 변경하고자 하는 경우, 연관된 모든 테스트를 수정**해야 한다.
* 그러나 **중복을 허용하는 경우 테스트 코드를 그저 위에서부터 아래로 읽어내려갈 수 있다는 가독성 측면의 장점 역시 존재**한다.
  * 반면, setUp을 재정의하는 경우 매 테스트 케이스마다 픽스쳐가 초기화되는 방식을 직접 기억해야한다는 단점이 존재한다.
  * xUnit은 두 가지 방식을 모두 지원하며, 픽스쳐 객체의 설정을 각 테스트 케이스에서 수행하거나 setUp으로 추출할 수 있다.

### 외부 픽스쳐 관리하기
* **픽스쳐 중 외부 리소스가 포함되는 경우, tearDown 메소드를 재정의하여 이를 해제**할 수 있다.
  * 예를 들어, 테스트를 위해 파일을 열었다면 반드시 테스트가 종료되기 전에 파일을 닫아야 한다.
* 또한 외부 리소스에 대해 여러 테스트로부터 접근하는 경우, 이를 공통 픽스쳐의 일부로 만들 수 있다.
  * 즉, 상술한 바와 마찬가지로 setUp 메소드를 재정의하여 리소스를 할당받는다.
  * 이 때, **xUnit은 테스트 종료 후에 tearDown 메소드가 호출되는 것을 보장하므로 외부 리소스를 해제하기에 적합한 위치**이다.

## 2022-08-16 Tue
### 테스트 메소드 관리하기
* 각각의 개별 테스트 케이스는 관례에 의해 test라는 접두사를 갖는 메소드로 정의한다.
  * 객체지향 프로그래밍 언어의 경우, 모듈과 클래스 및 메소드라는 구조 계층을 제공한다.
  * **테스트는 메소드로 관리하는 것이 적절하며, 동일한 픽스쳐를 공유하는 모든 테스트를 동일한 클래스의 메소드로 작성**한다.
* **테스트 케이스의 메소드 명은 처음 보는 사람이 코드를 읽더라고 해당 테스트가 왜 작성되었는지 알 수 있도록 명시적으로 작성**한다.
  * 테스트 메소드는 언제나 의미가 그대로 드러나도록 가독성을 높여야 한다.
* 테스트 케이스를 작성하기 전에, 주석을 활용하여 원하는 테스트를 설명하는 아웃라인을 작성해둘 수 있다.
  * 이렇게 작성된 아웃라인은 본질적으로 테스트하는 클래스의 계약 문서 역할을 수행하며, 가장 낮은 레벨의 아웃라인 바로 밑에 테스트 케이스 코드가 작성된다.

### 예외를 테스트하기
* **예외가 발생하는 것이 정상인 상황을 테스트하는 경우, 예상되는 예외를 잡아서 무시하고 그렇지 않은 경우에만 테스트가 실패하도록 작성**한다.
  * 이를 위해 고전적인 try - catch를 사용할 수 있으며, 비어 있는 catch 블록에서 예상되는 예외를 잡도록 구현한다.
* 이 때, **예상되는 종류의 예외만을 catch 블록에서 무시하도록 정확히 명시하는 것이 바람직**하다.
  * 그렇지 못한 경우, 개발자가 원하는 예외가 아닌 다른 예외가 발생했을 때 테스트가 성공할 수도 있게 된다.

### 전체 테스트하기
* IDE에 의해 전체 테스트 실행 기능을 지원받지 못하는 경우, 모든 테스트를 한 번에 실행할 수 있도록 테스트 슈트에 대한 모음을 작성한다.
  * 이 때, 각 패키지에 대해 하나씩 작성하는 데에 더해 애플리케이션에 포함된 패키지 테스트를 모두 모아주는 테스트 슈트를 작성한다.
  * 예를 들어 각 패키지는 AllTests라는 이름의 클래스를 가질 수 있으나, 최근의 IDE는 이러한 기능을 개발 환경 차원에서 제공한다.
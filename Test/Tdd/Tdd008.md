# Tdd
## 2022-08-14 Sun
### 자식 테스트로 리듬 유지하기
* 지나치게 큰 테스트를 통과시키기 어려운 경우, 테스트 케이스의 깨지는 부분에 해당하는 작은 테스트를 작성하고 이를 실행시킨다.
  * 그 후에 다시 원래의 테스트 케이스를 추가할 수 있다.
* **빨강 / 초록 / 리팩토링의 리듬은 성공을 지속시키는데 매우 중요하며, 그 리듬이 깨질 것 같은 순간에 부가적인 노력으로 리듬을 유지하는 것은 가치가 있다**.
* **너무 큰 테스트를 작성했다면 왜 테스트가 커졌으며 어떤 방식을 통해 작게 유지할 수 있었을지 교휸을 얻어내는 것이 바람직**하다.
  * 또한, 이를 수정하는 과정에서 기존 테스트를 삭제하거나 일단 실행되지 않도록 설정한 후에 작은 테스트를 작성하는 방법을 택할 수 있다.

### 모킹하기
* **비용이 많이 들거나 복잡한 리소스에 의존하는 객체를 테스트하는 경우, 상수를 반환하도록 만든 속임수 버전의 리소스를 새로 만들어 사용**한다.
  * 가장 대표적인 예시는 데이터베이스이며, 이는 시작이 오래 걸리고 깨끗한 상태로 유지하기도 어려우며 네트워크 상의 물리적인 위치에도 영향을 크게 받는다.
  * **이렇듯 데이터베이스는 개발 과정에서 발생하는 많은 오류의 원인이 되므로, 떠올릴 수 있는 해법은 실제 데이터베이스를 사용하지 않는 것**이다. 
  * **대부분의 테스트는 마치 데이터베이스인 것처럼 흉내내지만 실제로는 메모리에만 존재하는 객체를 통해 작성될 수 있다**.
  * 예를 들어, 모킹 데이터베이스 객체는 예상된 쿼리를 얻지 못하면 예외를 던지며 쿼리가 올바른 경우에만 result set처럼 보이는 결과를 반환한다.
* **모킹을 사용하도록 결정하는 가치는 성능과 견고함 이외에도 가독성**에 있다.
* **모의 객체 역시 큰 자원을 사용하므로, 이를 전역 변수에 저장해둔 채 방치하는 일이 발생하지 않도록 주의**해야 한다.
  * 부득이하게 전역 변수에 저장해야만하는 경우, 이를 모의 객체로 설정하고 테스트를 실행한 후에 다시 전역 변수를 복구시켜야 한다.
* **모의 객체는 모든 객체의 가시성에 대해 고민하도록 격려하므로, 설계에 불필요한 커플링을 방지**하도록 한다.
* 반면, 모의 객체를 도입하는 것은 프로젝트에 위험 요소를 하나 늘리는 것이기도 하다.
  * **모의 객체가 실제와 동일하게 동작하지 않을 수 있기 때문이며, 이는 모의 객체용 테스트 집합을 실제에도 그대로 적용해보는 것으로 위험을 줄일 수 있다**.

### 셀프 션트
* 객체가 또 다른 객체와 협력하기 위해 올바르게 메시지를 주고 받는지 테스트하는 경우, 테스트 대상이 되는 객체가 테스트 케이스와 대화하도록 만들 수 있다.
  * **이 경우, 테스트 케이스가 일종의 모의 객체 역할을 수행**한다.
* 이를 셀프 션트 패턴이라고 하며, 셀프 션트가 적용된 테스트가 그렇지 않은 경우에 비해 가독성이 높다.
* 반면, 셀프 션트 패턴은 테스트 케이스가 구현할 인터페이스를 얻기 위해 인터페이스 추출이 선행되어야 한다.
  * 때문에 인터페이스를 추출하는 것이 쉬운지, 이미 존재하는 클래스를 블랙 박스로 테스트하는 것이 더 쉬운지는 개발자가 결정해야 한다.
  * Java의 경우, 셀프 션트의 결과로 인터페이스 안에 온갖 메소드를 구현하는 테스트들을 보게될 수 있다.
  * **각 인터페이스에 대한 구현은 적절한 값을 되돌리거나, 적절하지 않은 시도에 대해 예외를 던지도록 정의**해야 한다.

### 로그 문자열 활용하기
* **메시지의 호출 순서가 정확한지 검사하는 경우, 로그 문자열을 가지고 있다가 메시지가 호출될 때마다 해당 문자열에 추가하여 결과를 비교**할 수 있다.
  * 이러한 로그 문자열은 특히 옵저버를 구현하고, 이벤트 통보가 원하는 순서대로 발생했는지 확인하는 경우에 유용하다.
  * 반면, 이벤트 통보가 발생하는 것을 확인하지만 순서는 상관 없을 경우에는 문자열 집합을 활용한다.
  * **로그 문자열 방식은 셀프 션트 패턴과도 잘 통합되며, 테스트 케이스는 각 메소드가 로그를 추가하고 적절히 동작하는 식으로 구현**되어야 한다.

### 크래시 테스트 더미 활용하기
* **발생하기 어려울 것 같은 예외 상황에 대해 테스트하는 경우, 그저 해당 예외를 던지기만 하는 더미 객체를 정의하여 활용**한다.
  * **언제나 테스트되지 않은 코드는 동작하는 것이 아니라고 가정하고 개발을 진행하는 것이 안전**하다.
* 객체 전체를 모킹하지 않는다는 점을 제외하면 크래시 테스트 더미는 모의 객체와 유사하다.
  * Java의 경우, **익명 내부 클래스는 테스트 대상 메소드만이 예외를 던지도록 정의하기 위해 유용하게 사용**될 수 있다.
  * 이는 **테스트 케이스 안에서 원하는 메소드 하나만을 재정의하며, 가독성을 크게 높이는 효과**를 얻을 수 있다.

### 테스트가 깨진 상태로 끝마치기
* **혼자서 개발을 진행하는 경우, 프로그래밍 세션은 항상 마지막 테스트가 깨진 상태로 마치는 것이 바람직**하다.
  * 이렇듯 글을 중간까지만 작성하고 멈추는 방식은 다음에 다시 집필하기 위해 앉았을 때 이전 상황을 떠올리게 만든다.
  * **개발 과정에서도 이는 마찬가지이며, 다시 개발을 진행하기 위해 돌아왔을 때 어느 작업부터 시작할지 확실히 떠올릴 수 있다**.
* **깨진 테스트가 하나 정도 존재한다고 해서 애플리케이션의 완성도가 급락하는 것은 아니며, 이는 단지 애플리케이션의 상태를 명확히 드러내기 위한 장치**이다.
  * 이렇듯 오랜 시간이 흐른 후에도 개발하던 것을 이어나갈 수 있는 능력을 갖기 위해서는 빨간 막대를 두고 가는 정도의 가책은 감수할 수 있어야 한다.

### 테스트가 깨지지 않은 상태로 체크인하기
* **상술한 바와 달리, 팀과 협업하는 경우에서는 반드시 모든 테스트가 성공한 상태로 프로그래밍 세션을 마치는 것이 바람직**하다. 
* 팀 프로젝트에서 프로그래밍 세션을 시작하는 경우, 자신이 마지막에 개발한 시점으로부터 지금까지 무슨 일이 있었는지 완벽히 알 수는 없다.
  * 때문에 안심이 되고 확신이 있는 상태에서 프로그래밍 세션을 시작할 수 있어야 한다.
  * 이를 위해 **개발을 마무리하고 코드를 체크인하기 전에 항상 모든 테스트가 통과하는 상태로 만들어두어야 한다**.
* 체크인 하기 전에 실행하는 전체 테스트 스위트는 작업 중에 분 단위로 실행하는 테스트보다 규모가 크고, 느릴 수 밖에 없다.
  * 반면, **테스트의 규모가 충분히 작거나 속도가 빠르다면 언제나 전체 테스트를 실행하는 것을 포기하지 않아야 한다**.
* **간혹 통합 테스트 스위트에서 테스트가 실패하는 경우가 발생할 수 있으며, 이는 개발자가 아직 애플리케이션을 완벽히 이해하지 못했다는 강력한 증거**가 된다.
* 이 경우, 다음과 같은 방식으로 대처해볼 수 있다.
  1. 그간 작업한 코드를 전부 제거한 후에 다시 시작한다.
  2. 문제를 수정하고나서 테스트를 다시 실행해본다.
* 특히 **첫 번째 방식의 경우, 팀원 모두가 해당 규칙을 따를 경우 체크인을 더 자주 시도하는 경향**을 만들어낸다.
  * 우선 체크인할수록 그만큼 코드를 지워야할 위험이 낮아지기 때문이며, 이는 바람직한 방향에 해당한다.
* **어느 때라도 테스트 스위트만을 통과시키기 위해 실패한 테스트를 주석 처리해두는 것은 엄격히 금지**되어야 한다.

## 2022-08-15 Mon
### 진짜로 만들기 전까지는 가짜로 구현하기
* 실패하는 테스트를 작성하는 데에 성공했다면, 첫 번째 구현은 상수를 반환하는 가짜 구현을 적용할 수 있다.
  * **일단 테스트를 통과시켜 초록 막대를 확인하고 난 후에 단계적으로 상수를 변수로 일반화**한다.
  * 이러한 가짜 구현은 아직 완료에 도달하지 못한 상태이며, 테스트는 통과하지만 코드 구조가 잘못된 상태를 만든다.
  * 그러나 **가짜 구현에서 시작하여 일반화에 성공한 경우, 여전히 테스트는 통과하고 코드는 견고함과 안전성을 유지**한다.
* 언뜻 가짜 구현은 어차피 제거될 것이므로 불필요한 단계처럼 보일 수도 있으나, 무엇인가가 성공적으로 돌아가는 것을 가진 상황이 그렇지 못한 것보다 훨씬 좋다.
  * 또한, **애초에 잘 못 작성된 테스트 케이스는 가짜 구현만으로도 이를 알아차릴 수 있으므로 실제 구현에 시간을 허비할 가능성을 크게 줄여준다**.
* 또한 가짜 구현은 다음과 같은 커다란 강점이 존재한다.
  1. 심리학적으로, 초록 막대 상태인 것은 빨간 막대 상태와는 큰 차이가 있다.
     * **초록 막대를 유지하는 상황에서 개발자는 자신이 어디까지 와 있는지 알 수 있고, 확신을 가진 상태로 리팩토링을 시작**할 수 있다.
  2. **구체적인 예에서부터 시작하여 일반화하므로, 쓸데 없는 고민으로 혼동하지 않도록 개발 범위를 조절**할 수 있다.
* 가짜 구현은 리팩토링 단계에서 테스트 케이스와 실제 코드 사이의 데이터 중복을 제거하는 과정에서 제거되므로, 불필요한 코드를 작성하는 것으로 볼 수는 없다.
  * 그러나 **이를 믿지 못하는 개발자는 우선 삼각 측량 기법을 사용하고, 필요한 경우에 한해 가짜 구현 또는 명백한 구현을 적용해도 무방**하다.

### 삼각 측량 기법 활용하기
* **추상화를 적용하는 과정을 테스트로 주도하는 경우, 이를 최대한 보수적으로 하는 방법은 오로지 예시가 둘 이상인 경우에만 추상화를 적용하는 것**이다.
  * 예를 들어, 덧셈을 구현하는 경우 정확한 예시를 확인하는 단언 하나만으로는 가짜 구현을 적용해야한다.
  * 그러나 **예시가 둘 이상일 경우, 단언 두 개를 통해 오퍼레이션의 구현을 추상화**할 수 있다.
* 이렇듯 **삼각 측량 기법은 추상화를 이끌어내기 위한 규칙이 매우 명확한 장점이 존재**한다.
  * 반면, 가짜 구현은 테스트 케이스와 실제 코드 사이의 중복을 제거하기 위한 개발자의 감각에 의존하므로 약간 모호할 수 있다.
* 그러나 삼각 측량 기법은 다음과 같은 흐름으로 무한 루프를 만들어낼 수도 있다.
  1. 두 단언을 통해 오퍼레이션을 추상했다.
  2. 그러나 두 단언은 내용이 중복되므로 하나를 제거할 수 있다.
  3. 이로 인해 추상화된 오퍼레이션을 다시 가짜 구현으로 수정해야 한다.
  4. 반복된다.
* 때문에 **삼각 측량 기법은 어떠한 연산을 올바르게 추상화하는 방법이 도무지 떠오르지 않은 경우에만 적용하는 것이 바람직**하다.
  * **그 이외의 경우, 가짜 구현 또는 명백한 구현에 의존해도 무방**하다.

### 명백한 구현 활용하기
* **단순한 연산의 경우, 내가 무엇을 구현해야할지 확실히 알고 있다면 그냥 구현해도 무방**하다.
  * 가짜 구현과 삼각 측량은 정말 작은 발걸음으로 테스트하는 것이므로, 간단한 연산에서조차 두 방식을 활용할 필요는 없다.
  * 무엇보다, 두 방식에 특별한 미덕이 있는 것은 아니다.
* 테스트를 진행하며 리듬에 익숙해지고 자신감이 붙은 경우에 확신까지 있다면 명백한 구현을 사용하기에 적절하다.
  * 그러나 오로지 명백한 구현만 활용하는 것은 개발자 자신에게 완벽함을 요구하게 되며, 실망과 자괴감을 부르는 악순환의 시작이 될 가능성이 있다.
  * **개발 과정에서 빨간 막대가 자주 보이기 시작하고, 동작하지 않는 코드가 많아진다면 가짜 구현과 삼각 측량을 적용하여 속도를 늦추도록 한다**.
  * 이렇듯 **TDD란 리듬을 조절해나가는 과정이며, 명백한 구현은 두 번째 기어에 해당**한다.
* 제대로 동작하는 동시에 깨끗한 코드를 작성하는 것은 한 번에 이루어내기에는 너무 과할 수 있다.
  * 때문에 **우선 동작시키는데에 집중하고, 그 후에 깨끗한 코드로 수정하는 작업을 느긋하게 해결**하도록 한다.

### 하나에서 여럿으로 늘려가기
* **객체 컬렉션을 다루는 오퍼레이션의 경우, 우선 컬렉션 없이 구현하고 그 후에 컬렉션을 도입하는 것이 바람직**하다.
* 이 때, 변화 격리하기 기법을 적용하여 안전하게 코드를 수정할 수 있다.
  * 예를 들어, 우선 단일 인자를 다루는 오퍼레이션을 테스트했다면 두 번째 인자를 컬렉션으로 추가하여 코드를 수정한다.
  * 코드의 수정이 완료되어 테스트에 통과했다면, 이제 단일 인자를 삭제한다.
  * **해당 방식을 통해 테스트 케이스를 수정하더라도 코드를 수정할 필요는 없어지므로, 이제 개발자는 원하는대로 테스트 케이스를 개선**할 수 있다.
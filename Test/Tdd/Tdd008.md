# Tdd
## 2022-08-14 Sun
### 자식 테스트로 리듬 유지하기
* 지나치게 큰 테스트를 통과시키기 어려운 경우, 테스트 케이스의 깨지는 부분에 해당하는 작은 테스트를 작성하고 이를 실행시킨다.
  * 그 후에 다시 원래의 테스트 케이스를 추가할 수 있다.
* **빨강 / 초록 / 리팩토링의 리듬은 성공을 지속시키는데 매우 중요하며, 그 리듬이 깨질 것 같은 순간에 부가적인 노력으로 리듬을 유지하는 것은 가치가 있다**.
* **너무 큰 테스트를 작성했다면 왜 테스트가 커졌으며 어떤 방식을 통해 작게 유지할 수 있었을지 교휸을 얻어내는 것이 바람직**하다.
  * 또한, 이를 수정하는 과정에서 기존 테스트를 삭제하거나 일단 실행되지 않도록 설정한 후에 작은 테스트를 작성하는 방법을 택할 수 있다.

### 모킹하기
* **비용이 많이 들거나 복잡한 리소스에 의존하는 객체를 테스트하는 경우, 상수를 반환하도록 만든 속임수 버전의 리소스를 새로 만들어 사용**한다.
  * 가장 대표적인 예시는 데이터베이스이며, 이는 시작이 오래 걸리고 깨끗한 상태로 유지하기도 어려우며 네트워크 상의 물리적인 위치에도 영향을 크게 받는다.
  * **이렇듯 데이터베이스는 개발 과정에서 발생하는 많은 오류의 원인이 되므로, 떠올릴 수 있는 해법은 실제 데이터베이스를 사용하지 않는 것**이다. 
  * **대부분의 테스트는 마치 데이터베이스인 것처럼 흉내내지만 실제로는 메모리에만 존재하는 객체를 통해 작성될 수 있다**.
  * 예를 들어, 모킹 데이터베이스 객체는 예상된 쿼리를 얻지 못하면 예외를 던지며 쿼리가 올바른 경우에만 result set처럼 보이는 결과를 반환한다.
* **모킹을 사용하도록 결정하는 가치는 성능과 견고함 이외에도 가독성**에 있다.
* **모의 객체 역시 큰 자원을 사용하므로, 이를 전역 변수에 저장해둔 채 방치하는 일이 발생하지 않도록 주의**해야 한다.
  * 부득이하게 전역 변수에 저장해야만하는 경우, 이를 모의 객체로 설정하고 테스트를 실행한 후에 다시 전역 변수를 복구시켜야 한다.
* **모의 객체는 모든 객체의 가시성에 대해 고민하도록 격려하므로, 설계에 불필요한 커플링을 방지**하도록 한다.
* 반면, 모의 객체를 도입하는 것은 프로젝트에 위험 요소를 하나 늘리는 것이기도 하다.
  * **모의 객체가 실제와 동일하게 동작하지 않을 수 있기 때문이며, 이는 모의 객체용 테스트 집합을 실제에도 그대로 적용해보는 것으로 위험을 줄일 수 있다**.

### 셀프 션트
* 객체가 또 다른 객체와 협력하기 위해 올바르게 메시지를 주고 받는지 테스트하는 경우, 테스트 대상이 되는 객체가 테스트 케이스와 대화하도록 만들 수 있다.
  * **이 경우, 테스트 케이스가 일종의 모의 객체 역할을 수행**한다.
* 이를 셀프 션트 패턴이라고 하며, 셀프 션트가 적용된 테스트가 그렇지 않은 경우에 비해 가독성이 높다.
* 반면, 셀프 션트 패턴은 테스트 케이스가 구현할 인터페이스를 얻기 위해 인터페이스 추출이 선행되어야 한다.
  * 때문에 인터페이스를 추출하는 것이 쉬운지, 이미 존재하는 클래스를 블랙 박스로 테스트하는 것이 더 쉬운지는 개발자가 결정해야 한다.
  * Java의 경우, 셀프 션트의 결과로 인터페이스 안에 온갖 메소드를 구현하는 테스트들을 보게될 수 있다.
  * **각 인터페이스에 대한 구현은 적절한 값을 되돌리거나, 적절하지 않은 시도에 대해 예외를 던지도록 정의**해야 한다.

### 로그 문자열 활용하기
* **메시지의 호출 순서가 정확한지 검사하는 경우, 로그 문자열을 가지고 있다가 메시지가 호출될 때마다 해당 문자열에 추가하여 결과를 비교**할 수 있다.
  * 이러한 로그 문자열은 특히 옵저버를 구현하고, 이벤트 통보가 원하는 순서대로 발생했는지 확인하는 경우에 유용하다.
  * 반면, 이벤트 통보가 발생하는 것을 확인하지만 순서는 상관 없을 경우에는 문자열 집합을 활용한다.
  * **로그 문자열 방식은 셀프 션트 패턴과도 잘 통합되며, 테스트 케이스는 각 메소드가 로그를 추가하고 적절히 동작하는 식으로 구현**되어야 한다.

### 크래시 테스트 더미 활용하기
* **발생하기 어려울 것 같은 예외 상황에 대해 테스트하는 경우, 그저 해당 예외를 던지기만 하는 더미 객체를 정의하여 활용**한다.
  * **언제나 테스트되지 않은 코드는 동작하는 것이 아니라고 가정하고 개발을 진행하는 것이 안전**하다.
* 객체 전체를 모킹하지 않는다는 점을 제외하면 크래시 테스트 더미는 모의 객체와 유사하다.
  * Java의 경우, **익명 내부 클래스는 테스트 대상 메소드만이 예외를 던지도록 정의하기 위해 유용하게 사용**될 수 있다.
  * 이는 **테스트 케이스 안에서 원하는 메소드 하나만을 재정의하며, 가독성을 크게 높이는 효과**를 얻을 수 있다.

### 테스트가 깨진 상태로 끝마치기
* **혼자서 개발을 진행하는 경우, 프로그래밍 세션은 항상 마지막 테스트가 깨진 상태로 마치는 것이 바람직**하다.
  * 이렇듯 글을 중간까지만 작성하고 멈추는 방식은 다음에 다시 집필하기 위해 앉았을 때 이전 상황을 떠올리게 만든다.
  * **개발 과정에서도 이는 마찬가지이며, 다시 개발을 진행하기 위해 돌아왔을 때 어느 작업부터 시작할지 확실히 떠올릴 수 있다**.
* **깨진 테스트가 하나 정도 존재한다고 해서 애플리케이션의 완성도가 급락하는 것은 아니며, 이는 단지 애플리케이션의 상태를 명확히 드러내기 위한 장치**이다.
  * 이렇듯 오랜 시간이 흐른 후에도 개발하던 것을 이어나갈 수 있는 능력을 갖기 위해서는 빨간 막대를 두고 가는 정도의 가책은 감수할 수 있어야 한다.

### 테스트가 깨지지 않은 상태로 체크인하기
* **상술한 바와 달리, 팀과 협업하는 경우에서는 반드시 모든 테스트가 성공한 상태로 프로그래밍 세션을 마치는 것이 바람직**하다. 
* 팀 프로젝트에서 프로그래밍 세션을 시작하는 경우, 자신이 마지막에 개발한 시점으로부터 지금까지 무슨 일이 있었는지 완벽히 알 수는 없다.
  * 때문에 안심이 되고 확신이 있는 상태에서 프로그래밍 세션을 시작할 수 있어야 한다.
  * 이를 위해 **개발을 마무리하고 코드를 체크인하기 전에 항상 모든 테스트가 통과하는 상태로 만들어두어야 한다**.
* 체크인 하기 전에 실행하는 전체 테스트 스위트는 작업 중에 분 단위로 실행하는 테스트보다 규모가 크고, 느릴 수 밖에 없다.
  * 반면, **테스트의 규모가 충분히 작거나 속도가 빠르다면 언제나 전체 테스트를 실행하는 것을 포기하지 않아야 한다**.
* **간혹 통합 테스트 스위트에서 테스트가 실패하는 경우가 발생할 수 있으며, 이는 개발자가 아직 애플리케이션을 완벽히 이해하지 못했다는 강력한 증거**가 된다.
* 이 경우, 다음과 같은 방식으로 대처해볼 수 있다.
  1. 그간 작업한 코드를 전부 제거한 후에 다시 시작한다.
  2. 문제를 수정하고나서 테스트를 다시 실행해본다.
* 특히 **첫 번째 방식의 경우, 팀원 모두가 해당 규칙을 따를 경우 체크인을 더 자주 시도하는 경향**을 만들어낸다.
  * 우선 체크인할수록 그만큼 코드를 지워야할 위험이 낮아지기 때문이며, 이는 바람직한 방향에 해당한다.
* **어느 때라도 테스트 스위트만을 통과시키기 위해 실패한 테스트를 주석 처리해두는 것은 엄격히 금지**되어야 한다.
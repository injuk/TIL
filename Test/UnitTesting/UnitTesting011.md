# UnitTesting
## 2022-05-11 Wed

## 테스트 리팩토링
* 테스트 코드를 작성한다는 것은 또 다른 투자를 의미하기도 한다.
  * 테스트는 결함을 최소화하고, 리팩토링을 쉽게 하여 시스템을 깔끔히 유지시켜준다.
  * 그러나 또 다른 측면에서는 **테스트 코드 역시 유지보수가 필요하므로, 지속적인 비용을 요구하는 자산**이다.
* 시스템의 변경에 따라 테스트 코드 역시 변경될 수 있으며, 때로는 변경 사항으로 인해 깨진 테스트를 반드시 고쳐야 한다.
* **마치 운영 시스템을 리팩토링하는 것처럼 테스트를 리팩토링하는 것으로 코드에 대한 이해도를 높이고, 유지 보수 비용을 최소화**할 수 있다.

### 이해 검색하기
* 처음 작업하는 클래스가 어떠한 일을 수행하는지 전혀 알지 못하는 상황에는 우선 단위 테스트부터 확인하는 것이 바람직하다.
  * **적절히 작성된 단위 테스트를 통해 작업 대상 클래스에 대한 이해도를 높일 수 있다**.
* 그러나 때로는 단위 테스트가 너무 지저분하고 장황하여 무엇을 하고자 하는 테스트인지 전혀 알 수 없는 경우가 발생한다.
* 이렇듯 도움이 되지 않는 테스트 코드는 크게 다음과 같은 특징을 갖는다.
  1. 테스트의 이름이 너무 일반적이며, 어떠한 정보도 제공하지 않는다.
  2. 별 도움이 되지 않는 주석이 작성되어 있다.
* 이러한 테스트가 무엇을 하기 위함인지 완벽히 이해하려면 테스트를 한 줄 한 줄 꼼꼼히 읽고, 퍼즐을 풀어가는 수 밖에 없다.
* **테스트 역시 리팩토링의 대상이 될 수 있으며, 이를 통해 더 깔끔하고 표현력이 좋은 테스트로 개선되어야 한다**.
  * 테스트 코드의 리팩토링을 위해서는 우선 다양한 악취를 풍기는 코드 냄새를 찾아낼 수 있어야 한다.

### 코드 냄새 - 불필요한 테스트 코드
```
> try - catch 블록과 not null 단언은 테스트 코드를 읽는 개발자에게 유용한 정보를 주지 못하는 불필요한 테스트 코드이다.
```
1. **테스트 메소드는 예외를 기대하지 않으므로, 예외가 발생했다면 그냥 예외를 던지도록 작성**하면 된다.
   * 테스트 도중 예외가 발생한 경우, junit이 이를 잡아 오류로 처리해준다.
   * 따라서 try - catch 블록을 별도로 명시할 필요가 없다.
2. not null 단언은 어떠한 참조가 null이 아님을 검증하기 위해 사용된다.
   * 운영 코드의 경우, 변수를 역으로 참조하기 전에 null이 아님을 검증하는 것은 안전하고 좋은 일이다.
   * 반면, 테스트 코드의 경우 null 참조시 예외가 발생하고 이를 junit이 잡아 처리하므로 불필요한 코드에 해당한다.
   * 때문에 **try - catch 블록과 마찬가지로 not null 단언 역시 테스트 코드를 읽는 개발자에게 유용한 정보를 줄 수 없다**.

### 코드 냄새 - 누락된 추상화
* 잘 구성된 테스트는 시스템과 상호작용 하는 과정을 준비, 호출, 단언의 세 가지 관점으로 잘 드러낸다.
* 이 때, **각 단계를 위한 코드는 불필요한 세부사항이 드러나지 않도록 추상화하여 가독성을 높이는 것이 바람직**하다.
  * 추상화를 활용하면 필수적인 개념은 최대화하고, 불필요한 세부사항은 숨길 수 있다.
  * 즉, **좋은 단위 테스트는 클라이언트가 시스템과 상호작용하는 방법을 적절히 추상화**한다.
* 테스트 코드에 추상화를 적용하기 위해서는 다음과 같은 작업을 수행할 수 있다.
  1. 하나의 개념을 구체화하는 여러 단언문이 사용되는 경우, 별도의 사용자 정의 단언문을 구현하여 활용한다.
     * 이 경우, 사용자 정의 단언문을 만들기 위해 더욱 많은 코드를 작성해야 한다.
     * 그러나 **테스트를 이해하려는 노력이 단순화되며, 별도의 추가 테스트에서도 재활용이 가능하므로 투자 대비 얻는 이점이 더욱 크다**.
     * 이렇듯 **단일 개념을 구현하는 여러 줄의 코드를 발견한 경우, 깔끔한 한 문장으로 추출할 수 있는지 고려**해야 한다.
  2. **결과 값이 비어있는지 확인하는 단언문은 equalTo 대신 가독성이 좋은 isEmpty 단언으로 교체**한다.
     * **단언의 종류를 바꾸어주는 것만으로 크기 비교를 이해하기 위해 드는 불필요한 스트레스를 줄일 수 있다**.
* **테스트의 경우 작은 냄새들이 쌓여 개발자에게 큰 스트레스를 줄 수 있으며, 이는 유지보수 비용으로 고스란히 이어지기 쉽다**.

### 코드 냄새 - 적절하지 않은 정보
```
> 테스트 코드에 사용되는 데이터 역시 테스트 코드가 알려주는 중요한 내용에 도움을 줄 수 있어야 한다.
```
* **잘 추상화된 테스트는 코드를 이해하기 위해 중요한 것만을 부각시키며, 그렇지 않은 것은 숨긴다**.
* 때때로 테스트에는 적절하지 않지만, 눈 앞의 컴파일을 위해 데이터를 하드코딩하는 경우가 발생할 수 있다.
  * 예를 들어 **테스트에는 어떠한 영향도 주지 않는 부가적인 인수를 작성하기 위해 매직 리터럴을 사용하는 경우**이다.
* 매직 리터럴은 불필요한 질문을 유발하며, 용도를 찾기 위해 다른 세부적인 코드를 읽게 만드는 경향이 있다.
* 이로 인해 **시간이 낭비되므로, 매직 리터럴을 지양하고 의미 있는 상수를 도입하여 즉시 파악이 가능하도록 개선하는 것이 바람직**하다.
  * 또는 빈 문자열로 의미를 두지 않는 데이터를 표현할 수도 있다.

### 코드 냄새 - 부푼 생성
* **복잡한 객체 생성 과정이 테스트의 여러 지점에서 중복되는 경우, 이를 도우미 메소드로 추출**할 수 있다.
* 도우미 메소드는 복잡한 구현 세부사항을 숨기며, 테스트의 가독성과 유지보수성을 높여줄 수 있다.

### 코드 냄새 - 너무 많은 단언
```
> 테스트마다 단언을 하나로 유지하는 것은 좋은 습관이다.
```
* 때로는 단일 테스트에 여러 사후 조건에 대한 단언이 필요한 경우가 있다.
* 그러나 **일반적으로 단일 테스트에 대해 여러 단언이 존재한다는 것은, 해당 테스트가 테스트 케이스를 여럿 포함하고 있다는 명백한 증거**이다.
* 여러 **테스트 케이스를 포함하는 테스트를 여러 개로 분할하는 것으로 테스트 각각의 맥락에 맞는 기대 행동을 더 간결하게 명시**할 수 있게 된다.
  * 또한, 이 과정에서 불필요한 주석을 제거할 수 있다.
  * **단일 목적의 테스트는 주석 없이도 더 좋은 테스트 이름을 명명하는 것으로 가독성을 높일 수 있다**.

### 코드 냄새 - 테스트와 무관한 세부사항들
```
> 좋은 테스트는 테스트 코드를 읽는 개발자로 하여금 다른 함수를 파헤치치 않도록 한다.
```
* 종종 테스트를 실행하는 과정에서 로그를 끄거나, 테스트를 완료한 후 리소스를 닫는 처리를 해주는 테스트를 작성하는 경우가 있다.
  * 그러나 이러한 코드들을 테스트에 포함시키면 군더더기 코드가 되며, 개발자가 테스트의 핵심을 이해하는 것을 방해하게 된다.
* 이를 해결하기 위해 @Before와 @After 메소드를 활용할 수 있다.
* **세부 내용을 @Before와 @After, 또는 도우미 메소드로 옮기는 경우에는 테스트를 이해하는 데에 유용한 정보를 제거하지는 않는지 신중히 확인**해야 한다.

### 코드 냄새 - 잘못된 조직
* **바람직한 테스트는 AAA 원칙을 준수하며, 이를 통해 어떤 부분이 준비, 실행, 단언인지 빠르게 인식**할 수 있게 한다.
  * 즉, 테스트를 읽는 개발자는 테스트의 전체적인 그림을 빠르게 인식할 수 있다.
* **개행 없이 붙여서 작성된 테스트 코드는 AAA 원칙을 준수했더라도 가독성을 떨어트리므로, 각 단계의 사이에 개행을 두어 가독성을 높이는 것이 바람직**하다.

### 코드 냄새 - 암시적인 의미
* **각 테스트는 왜 그러한 결과를 기대하는지 분명하게 대답할 수 있어야 한다**.
  * **테스트를 읽는 독자는 테스트의 준비 부분과 단언 부분을 어렵지 않게 상호 연관지을 수 있어야 한다**.
  * 단언이 기대하는 이유가 분명하지 않은 경우, 코드를 읽는 개발자는 다른 코드를 확인하며 시간을 낭비하게 된다.
* 예를 들어, **테스트 데이터의 의미가 불분명한 경우 테스트의 의도를 더 명시적으로 드러내는 테스트 데이터를 활용**할 수 있다.
  * 문자열에서 특정 문자를 검색하는 메소드를 검색하는 경우, 멋들어진 문장보다는 1234 등의 읽기 쉬운 문자로 구분되는 테스트 데이터를 활용할 수 있다.
* 테스트 전체적으로 상호 관련성을 향상시키고 가독성을 높이는 방법은 크게 다음과 같으며, 그 외에도 무한한 방법이 존재한다.
  1. 의미 있는 상수의 도입
  2. 더 좋은 변수 이름 명명
  3. 더 좋은 데이터 사용
  4. 개별 테스트에서 계산은 되도록 적게 수행

### 새로운 테스트 추가하기
* 상술한 코드 냄새를 제거하며 테스트 코드를 리팩토링해갈수록 가독성이 떨어지는 큰 테스트는 잘 읽히는 여러개의 단위 테스트로 분할된다.
  * 또한, 리팩토링으로 인해 가독성이 향상될 뿐만 아니라 새로운 테스트를 추가하기도 쉬워진다.

## 결론
```
> 테스트 코드를 통해 시스템을 쉽게 이해하고자 하는 경우, 테스트를 가능한 한 쉽고 깔끔하게 유지하는 것이 바람직하다.
```
* 테스트 코드 역시 리팩토링을 거쳐 단순해질 수 있으며, 이를 통해 다음과 같은 이점을 얻게 된다.
  1. **테스트 코드를 읽는 개발자는 테스트의 이름만으로 어떤 테스트 케이스인지 이해**할 수 있다.
  2. **테스트의 실행 부분을 바로 확인하여 테스트가 무엇을 호출하는지 빠르게 이해**할 수 있다.
  3. **테스트의 준비 부분을 바로 확인하여 테스트가 어떠한 맥락에서 실행되는지 빠르게 이해**할 수 있다.
  4. **테스트의 단언 부분을 바로 확인하여 테스트가 기대하는 결과가 무엇인지 빠르게 파악**할 수 있다.
* 이렇게 리팩토링된 테스트 케이스들은 이전보다 빠르게 실행되며, 테스트를 이해하는데에 필요한 시간도 수 분에서 수 초로 줄어들게 된다.
* 바람직한 시스템은 다음과 같은 과정을 통해 얻어질 수 있다.
  1. 운영 코드를 깔끔하고 간결하게 리팩토링한다.
  2. 운영 코드를 설계하는 과정에서 더 많은 유연성을 제공할 수 있도록 리팩토링한다.
  3. 시스템의 의존성을 흉내내는 목을 제공한다.
  4. 상술한 과정을 통해 시스템의 유지보수 비용을 최소화한다.
  5. **시스템에 대한 이해도를 최대화할 수 있도록 테스트를 리팩토링**한다.
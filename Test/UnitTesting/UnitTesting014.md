# UnitTesting
## 2022-05-12 Thu

## 프로젝트에서 테스트
### 빠르게 도입하기
* **단위 테스트와 같이 개발자 개개인에게 의존하는 실천법을 도입하는 것은 끊임없는 경계를 요구**한다.
* 일반적으로 다른 팀원들은 테스트 코드보다 기능을 우선시할 것이며, 마감 시간을 준수하기 위해 모든 보호 장치를 제거하려고 할 것이다.
* 그러나 마감 시한을 위해 단위 테스트를 거두는 것은 다음과 같은 상황에 직면하기 쉽다.
  1. 짧은 시간에 코드를 많이 만들지만, 엉망인 코드들만 양산하게 된다.
  2. 엉망인 코드는 디버깅에 훨씬 많은 시간을 들여야 한다.
  3. 무엇보다, 코드를 많이 양산할 수 있다는 장점도 며칠가지 못한다.
* 단위 테스트를 도입하는 과정에서 가능한 것은 팀원들과의 원만한 협상 뿐이다.
  * 그러나 첫 날부터 단위 테스트를 통해 품질을 통제하며 개발하는 것을 주장하는 경우, 팀원들과 부딪히는 횟수를 줄일 수 있다.
* **단위 테스트는 품질 통제의 일부로서 기능할 수 있으므로, 팀 문화의 습관적인 일부가 되는 것이 바람직**하다.

### 팀과 같은 편에 서기
* 개발자들이 단위 테스트에 접근하는 방식은 크게 다음과 같이 분류할 수 있으며, 개개인마다 매우 다른 경우가 많다.
  1. 어떤 개발자들은 TDD를 주장한다.
  2. 어떤 개발자들은 필요하다고 느낀 경우에만 단위 테스트를 작성한다.
  3. 어떤 개발자들은 다수의 테스트를 단일 테스트 메소드로 몰아넣는 것을 선호한다.
  4. 어떤 개발자들은 느린 통합 테스트를 선호한다.
* 이러한 환경 속에서 팀이 같은 편이 되는 것은 매우 중요하다.
  * 해결책 없는 오랜 언쟁은 팀 구성원 개개인의 시간을 빼앗기만 할 뿐이다.
  * 따라서 **팀 구성원 모두가 동의할 수는 없을지라도, 적어도 어떠한 것에는 동의하고 합의점을 늘려가는 방식으로 시작하는 것이 바람직**하다.

### 단위 테스트의 표준을 정의하기
* 단위 테스트의 표준을 정의하기 위해 다음과 같은 두 항목에 대해 우선 고민해야 한다.
  1. 어떤 것이 모든 개발자의 시간을 많이 낭비하는가?
  2. 모두가 빠르게 동의할만한 단순한 표준은 무엇인가?
* 상술한 두 항목으로 팀 내 소통을 시작하여 모두의 기대 사항을 정의한다.
* 여기에 멈추지 않고, **팀은 표준을 지속하기 위해 필요할 때마다 정의된 표준을 재검토하고 수정할 수 있어야 한다**.
  * 대부분의 팀은 적어도 분기에 한 번은 표준을 검토해야 한다.
* 단위 테스트를 팀에 도입하는 초창기에 표준화해야하는 목록은 일반적으로 다음과 같다.
  1. 코드를 체크인하기 전에 어떤 테스트를 실행할 것인가?
  2. 테스트 클래스와 메소드의 명명법은 어떻게 할 것인가?
  3. 햄크레스트, 또는 전통적인 단언을 사용할 것인가?
  4. AAA를 준수할 것인가?
  5. 목 도구는 무엇을 사용할 것인가?
  6. 체크인 테스트를 실행할 때 콘솔에 출력을 허용할 것인가?
  7. 단위 테스트 스위트에서 느린 테스트를 어떻게 식별하고 방지할 것인가?

### 리뷰를 활용하여 표준 준수를 높이기
```
> 표준을 준수하는 것은 쉽지 않으므로, 팀은 구성원 모두에게 약간의 압박을 가할 필요가 있다.
```
* **개발 팀은 모두의 동의를 통해 어떻게 코드 리뷰를 진행할지도 표준화할 수 있어야** 한다.
  * 단위 테스트와 운영 코드는 모두 소중한 팀의 자산이므로, 아무나 코드를 마음대로 작성할 수 없어야 한다.
* **단위 테스트 작성자는 리뷰를 통해 다른 팀원들에게 피드백을 요청할 수 있으며, 이러한 사후 리뷰를 통해 뻔한 표준 위반을 미연에 방지**할 수 있다.
* **또는 풀 리퀘스트를 활용하는 방식도 유용**할 수 있다.
  * 어떤 개발자는 메인 브랜치에 통합하려는 작업 내용에 대해 풀 리퀘스트를 제출할 수 있다.
  * 다른 팀원들은 요청에 대해 주석을 달고, 결과적으로 변경 사항을 메인 브랜치에 pull 하거나 병합할 것을 결정할 수 있다.

### 페어 프로그래밍으로 리뷰하기
* 페어 프로그래밍은 두 개발자가 나란히 앉아 소프트웨어를 개발하는 방식이다.
  * **이상적인 경우 페어 프로그래밍의 결과물은 한 명이 진행한 것보다 설계가 좋으므로 코드의 품질 역시 높아진다**.
  * 페어 프로그래밍은 적극적인 형태의 리뷰라고도 이해할 수 있다.
* 사후 리뷰의 경우, 다음과 같은 이유에서 완전하지 못하다.
  1. 최상의 리뷰는 코드를 깊이 이해하는데서 시작하지만, 리뷰어들은 리뷰를 진행하는 코드의 세부 사항에 익숙하지 못하다.
  2. 회사에는 현실적인 문제로 시간적인 여유가 없다.
  3. 때문에 기대하는 것보다 적은 결함만을 찾아내게 되고, 교정된 결함의 종류도 표면적인 수준에 그치게 된다.
  4. 또한 심각한 문제를 고칠 수 있는 시기를 놓치기 쉽다.
  5. 상술한 이유에서 사후 리뷰는 가치는 있으나, 들이는 노력만큼의 가치는 없다.
* 반면, **페어 프로그래밍은 두 사람의 눈으로 시작부터 품질이 좋은 코드를 만들 수 있다는 희망을 갖고 개발해나갈 수 있다**.
  * 이를 위한 하나의 방향은 더 많고 좋은 단위 테스트를 지속하는 것이며, 단위 테스트는 페어 프로그래밍 습관을 들이기 위한 좋은 방법이다.
* 페어 프로그래밍을 진행하는 경우, 단위 테스트의 가치는 더 높아질 수 있다.

### 지속적으로 통합하기
```
> CI 서버는 현대적인 개발 팀을 구성하는 최소 요건이다.
```
* 단위 테스트를 팀 차원의 표준으로 바라보게 되면 반드시 공유 저장소가 필요하게 된다.
  * 개발자들은 임의의 기능을 추가하기 위해 저장소로부터 코드를 체크아웃하고, 변경점을 만들어 로컬 테스트를 마친 후 코드를 공유 저장소에 통합한다.
* 오래된 기존 방식은 공유된 코드에 대해 야간 빌드를 수행하여 통합 코드가 잘 동작하는지 확인하곤 했다.
  * 이러한 야간 빌드 방식에도 자동화된 테스트를 추가하면 가치를 극적으로 향상시킬 수 있다.
  * 예를 들어, 개발자가 추가한 변경점이 다른 머신에서도 테스트를 통과한다는 것을 알면 배포에 대한 자신감이 생길 수 밖에 없다.
* 그러나 야간 빌드는 다음과 같은 이유에서 적절하지 못한 방식이다.
  1. 개발 팀은 하루에도 수많은 변경점을 만들어낸다.
  2. 더 많은 코드가 추가될수록 코드를 통합했을 때 정상 동작하지 못할 확률이 높아진다.
  3. 야간 빌드로 통합된 소프트웨어를 테스트한다면, 변경점을 추가한 시점과 충돌을 발견하는 시점이 너무 멀어진다.
  4. 문제를 발견했다고 해도, 이를 다시 해결하는 데까지의 시간도 너무 오래 걸린다.
* **CI는 이를 해결해줄 수 있는 유용한 개념이며, 코드를 더 자주 통합하고 결과를 매번 검증하는 과정에서 더 빠른 피드백을 받을 수 있게하는 기법**이다.
  * 코드를 변경점과 합쳤을 때 동작하지 않는다는 것을 더 빠르게 알수록 팀의 성과는 좋아진다.
* CI의 실천은 지속적 통합 서버라고 하는 별개의 도구 지원을 받아야 한다.
  * CI 서버는 소스 저장소를 모니터링하며, 새로운 코드가 체크인 되는 것을 감지하면 코드를 가져와 빌드를 진행한다.
  * 빌드에 문제가 있는 경우, CI 서버는 개발 팀에 이를 통지한다.
* **CI 서버가 어떠한 가치를 제공할 수 있으려면 빌드가 단위 테스트를 함께 수행할 수 있어야** 한다.
  * 또한, CI 서버의 빌드 절차 자체가 소스 저장소의 코드 기록을 바탕으로 하므로 시스템의 전반적인 상태도 함께 모니터링할 수 있다.
* **CI 서버는 나쁜 코드를 통합하지 않을 수 있도록 건강한 팀 내 압박을 지원**한다.
  * 개발자들은 CI 빌드의 실패로 다른 개발자들의 시간을 낭비하지 않기 위해 체크 인 하기 전에 단위 테스트를 돌려보는 습관을 들이게 된다.
* 전형적인 CI 서버를 설치하고 설정하는 데에는 하루 이상의 시간이 필요하지만, 이는 그 이상의 가치를 얻기 위해 충분히 감내할 수 있을만한 작업이다.

### 코드 커버리지
* **코드 커버리지는 얼마나 많은 코드가 단위 테스트에서 실행되었는지를 가리키는 개념**이다.
  * 더 구체적으로, 코드 커버리지는 단위 테스트가 실행한 코드가 전체 코드에서 차지하는 비율을 퍼센트로 측정할 수도 있다.
  * **코드 커버리지는 측정 도구마다 결과가 달리 나올 수 있으므로, 반환되는 숫자는 경향으로만 참고하여 집착하지 않아야 한다**. 

### 커버리지는 어느 정도로 유지되어야 하는가?
```
> 낮은 커버리지 영역에서는 나쁜 코드의 양도 증가한다.
```
* 표면적으로는 더 높은 코드 커버리지가 무조건 좋은 것처럼 보인다.
  * 그러나 코드 커버리지의 개념은 속임수를 통해서만 100%를 달성할 수 있다는 제한이 있다.
  * 반면, 개발자는 아쉽게도 관리자를 만족시키기 위해 무엇이 충분한 수치인지 결정해야 한다.
* 일반적으로 **대부분의 경우 70% 이하의 코드 커버리지는 불충분하며, 습관적으로 단위 테스트를 작성하는 팀들은 70%의 수치를 비교적 쉽게 달성**할 수 있다.
  * 커버리지 밖의 1/3의 코드는 나쁜 의존성으로 테스트가 어렵거나, 코드 자체가 어려운 경우에 해당한다.
  * 그러나 코드 결함의 1/3, 또는 그 이상의 결함 역시 이러한 테스트되지 않은 코드들에 숨어들기 쉽다.
  * 이렇듯 어려운 코드는 많은 결함을 숨기는 경향이 있다.

### 100% 커버리지는 정말 좋을까?
* **설계가 좋을수록 테스트의 작성도 쉬워지며, 좋은 설계는 팀을 더 적은 결함으로 이끄는 100% 커버리지에 도달할 수 있도록 한다**.
  * 실제로 100%는 도달하기 어렵지만, 그래도 괜찮다.
* TDD를 적극적으로 수행하는 개발자들은 일반적으로 90% 이상의 커버리지를 쉽게 달성한다.
  * 이들은 **작성하려는 코드를 설명하는 단위 테스트를 먼저 작성하므로, TDD의 사이클에서 작성된 테스트는 일종의 자기 충족적인 예언이 된다**.
* 그러나 한편으로는 **커버리지의 수치 자체가 오도될 수 있음을 분명히 인지해야 한다**.
  * 예를 들어, 커버리지를 올리기 위한 테스트 몇 개에 단언은 거의 없는 형태가 될 수 있다.
  * 또는 이해하고 유지보수가 어려우며 가치 있는 단언을 포함하지도 않는 나쁜 테스트를 양산해낼 수도 있다.
  * **많은 개발 팀은 높은 커버리지를 달성하기만을 위해 가치 없는 단위 테스트를 작성하는 데에 시간을 낭비**하게 될 수도 있다.

### 코드 커버리지의 가치
```
> 코드 커버리지 도구는 코드의 어느 지점에서 커버리지가 부족하고, 팀이 어느 지점에서 아래 방향을 향하고 있는지 확인하기 위해서만 사용해야 한다.
```
* 단위 테스트를 작성하면서 테스트가 어느 코드를 커버하고, 그렇지 못한지 알고 싶은 것은 자연스러운 현상이다.
* 코드 커버리지 도구의 장점은 커버리지에서 누락되는 부분을 가시적으로 보여줄 수 있다는 점이다.
* **테스트 작성을 완료했다고 생각될 때 자연스럽게 커버리지 도구를 실행하는 것은 바람직한 습관**이다.
  * 커버되지 않은 코드 영역이 염려된다면, 더 많은 단위 테스트를 작성해야 한다는 신호이다.
  * 이렇듯 커버리지 도구를 주기적으로 실행하는 것으로 개발자는 지속적으로 단위 테스트에 솔직해질 수 있다.
* **코드 커버리지의 숫자 자체는 실제로 큰 의미가 없음을 반드시 기억**해야 한다.
  * 반면, **코드 커버리지의 결과 추세 자체는 매우 중요**하다.
  * 시간이 지나면서 **프로젝트가 성숙함에 따라 팀의 커버리지는 비율이 높아져가야 하고, 아래 방향을 향하지 않아야 한다**.

## 결론
* **단위 테스트를 적극적으로 도입하는 것으로 소프트웨어의 품질을 크게 높일 수 있다**.
* 또한, 단위 테스트와 관련된 지식을 토대로 다음과 같은 실천 역시 필요하다.
  1. 자신이 만든 코드에 우선 테스트를 작성한다.
  2. 소프트웨어가 점점 좋아질 수 있도록, 주의 깊게 테스트를 계속 작성해나간다.
  3. **지속적으로 단위 테스트에 대한 지식을 늘려가며, 새로운 것을 받아들이고 실천해보는 습관**을 들인다.
* 단위 테스트의 역사는 20년 정도로 짧지만, 그 속에는 단위 테스트에 접근하는 혁신적인 변화들이 포함되어 있다.
  * 때문에 단위 테스트와 TDD를 계속 주시하고 조사해나가야 한다.
  * 그 과정에서 노력을 보상받을 수 있는 훨씬 더 좋은 방법들을 찾아낼 수 있게 된다.
# UnitTesting
## 2022-05-12 Thu

## 까다로운 유형의 테스트
* 일반적으로 스레드 또는 영속성과 관련된 코드는 테스트가 어렵다.
* **한 가지 가능한 접근 방법은 더 좋은 테스트를 지원할 수 있도록 설계를 개선하고, 스텁과 목을 활용하여 의존성을 끊는 것**이다.

### 멀티스레드 코드의 어려움
* 기대한대로 동작하는 코드를 작성하는 것도 어렵지만, 동시성 코드를 올바르게 작성하는 것은 더욱 어렵다.
* 동시성 처리가 필요한 애플리케이션 코드를 테스트하는 것은 기술적으로 단위 테스트보다는 통합 테스트로 분류되어야 하는 영역이다.
* **스레드를 사용하는 코드에 대한 테스트는 느려지는 경향**이 있다.
  * 이는 동시성 문제가 없다는 것을 보장하면서 실행 시간의 범위를 확장해야하기 때문이다.
  * 스레드와 관련된 결함은 오랫동안 조용하다가, 없을 것 같다고 확신한 경우에 등장하기도 한다.

### 단순하고 똑똑하게 유지하기
* 멀티스레드 코드를 테스트하는 경우, 다음의 항목을 따르는 것이 바람직하다.
  1. 스레드 통제와 애플리케이션 코드 사이의 중첩은 최소화한다.
     * 즉, 스레드 없이 다량의 애플리케이션 코드를 단위 테스트할 수 있도록 설계를 변경해야 한다.
     * 이러한 **재설계 과정을 통해 스레드와 애플리케이션 로직은 명확히 구분**된다.
     * 이후, 스레드에 남겨둔 코드에 대해 집중적으로 테스트하는 코드를 작성하도록 한다.
  2. 다른 사람의 작업을 믿는다.
     * 예를 들어, Java 5 이후로 추가된 concurrent 패키지는 훌륭한 동시성 유틸리티이다.
     * **문제를 해결하기 위한 방법을 직접 설계하기보다, 오래 사용되고 검증받은 라이브러리를 활용하는 것이 더 좋은 결과를 낼 수 있다**.
* 동시성 코드의 경우, 특히 **애플리케이션 로직과 스레드 로직의 관심사를 분리하는 것이 중요**하다.
  * 이렇게 분리하는 데에 성공했더라도, 첫 번째 테스트는 어떻게 작성해야할지 신중히 고민하게 된다.
  * 그러나 이 과정에서 얻어진 스레드 중심의 테스트를 처리하기 위한 유틸리티 메소드들로 인해 두 번째 테스트부터는 상대적으로 작성이 쉬워진다. 

### 데이터베이스 테스트하기
* **데이터베이스와 상호작용 메소드를 테스트하기 어려운 이유는 JPA를 활용하여 데이터베이스와 통신하는 객체 때문**이다.
  * 이러한 객체의 대부분의 로직은 JPA 인터페이스를 구현하는 코드에 대해 단순히 위임하기만 한다.
  * 이는 **JPA에 대한 의존성을 성공적으로 고립시키므로 좋은 설계이나, 테스트 관점에서는 여전히 아쉬움**이 남는다.
* JPA와 관련된 모든 인터페이스를 스텁으로 만들어 단위 테스트를 진행할 수도 있으나, 이는 노력이 많이 들고 실제로 테스트하기도 어렵다.
* 대신 **실제로 데이터베이스와 상호 작용 하는 객체에 대한 테스트를 작성하는 것이 바람직**하다.
  * 이러한 테스트는 느리지만, 모든 것이 올바르게 연결되어 있음을 증명할 수 있다.
  * 이 과정에서 많은 결함이 발생하지만, JPA를 다루는 경우 Java 코드와 persistence.xml, 데이터베이스 세 개념이 상호작용하므로 결함은 흔한 문제이다.

### 데이터의 문제
* junit의 대다수 테스트는 속도가 빠르길 바라는 경향이 있지만, 데이터베이스와 상호 작용하는 테스트는 본질적으로 느릴 수 밖에 없다.
  * 그러나 **영속적인 모든 상호작용을 시스템의 한 곳으로 고립시킬 수 있다면, 통합 테스트의 대상을 소규모로 줄일 수 있다**.
  * H2와 같은 테스트 전용 인메모리 데이터베이스를 활용하고 싶은 충동이 들 수 있지만, 운영 데이터베이스와의 미묘한 차이 때문에 많은 문제점을 겪을 수 있다.
* **실제 데이터베이스와 상호작용하는 통합 테스트를 작성하는 경우, 데이터베이스의 데이터를 어떻게 준비할지는 매우 중요한 고려사항**이다.
  * 이는 데이터베이스에 질의했을 때 올바른 결과가 나오는 것을 증명하기 위해서는 우선 데이터가 데이터베이스에 준비되어 있어야 하기 때문이다.
* 반면, **데이터가 이미 데이터베이스에 존재한다고 가정하는 것은 고통스러운 접근법에 해당**한다.
  * 시간이 지나면서 데이터는 변질되고, 테스트도 덩달아 망가지기 쉽다.
  * 무엇보다 **테스트 코드와 데이터를 분리시키면 특정한 테스트가 왜 통과되거나 실패하는지 이유를 이해하기가 어려워진다**.
  * 즉, 테스트 관점에서 데이터의 의미는 이를 모두 데이터베이스에 밀어넣는 순간 사라지게 된다.
* **이상적인 것은 테스트 코드 안에서 데이터를 직접 생성하고 관리하는 것**이며, 이를 위해 다음과 같은 방식을 고려할 수 있다.
  1. 테스트마다 깨끗한 데이터베이스, 또는 적절한 데이터를 포함된 데이터베이스 인스턴스로 시작한다.
  2. **매 테스트는 테스트 과정에서 사용될 데이터를 추가하거나, 추가한 데이터를 통해 작업**한다.
* 이러한 방식을 통해 **다른 테스트의 결과로 남은 데이터로 인해 테스트가 망가지는 테스트 간 의존성 문제는 최소화**될 수 있다.
* 만일 **자신이 직접 관리하는 데이터베이스가 아닌, 모두가 테스트 용도로 공유하는 데이터베이스에만 접근할 수 있는 경우에는 트랜잭션을 활용**할 수 있다.
  * 예를 들어, **데이터베이스가 트랜잭션을 지원하는 경우 테스트마다 트랜잭션을 초기화하고 테스트가 종료된 후에 롤백**한다.
  * 일반적으로 트랜잭션의 처리는 @Before와 @After 메소드에 위임된다.

### 데이터베이스 통합 테스트의 어려움
* 통합 테스트는 작성과 유지보수 모두 어려운 편에 속한다.
  * 테스트는 깨지기 쉬우며, 깨졌을 때 문제를 디버깅하여 해결하는 것도 오래 걸린다.
  * 그러나 **통합 테스트는 테스트 전략의 필수적인 부분이므로, 반드시 작성할 수 있도록 하는 것이 바람직**하다.
* 필수적인 통합 테스트는 설계와 유지보수가 어렵다는 단점이 존재하므로, 단위 테스트를 최대화할 수 있어야 한다.
  * **단위 테스트를 최대화하는 경우 검증하는 로직의 범위가 함께 넓어지므로, 통합 테스트의 개수와 복잡도는 최소화**될 수 있다.

### 클린 룸 데이터베이스 테스트
* 데이터베이스와 상호작용하는 객체를 위한 테스트는 매 테스트 케이스의 실행 전후에 데이터베이스를 비우는 방식으로 작성할 수 있다.
* 예를 들어, @Before와 @After 메소드 모두에서 deleteAll()을 호출하도록 한다.
  * 디버깅이 필요한 경우, @After 메소드의 deleteAll()을 주석처리하여 실제 데이터를 확인하는 방식으로 접근한다.
* 이렇게 작성된 테스트는 단순하고 직접적이며, 종단 간 애플리케이션의 기능을 테스트하지는 않는다.
  * 대신 **테스트 코드의 관심사는 대부분 질의 기능을 테스트하는 데에 집중**되며, 객체가 데이터베이스와 적절히 상호작용하는지 검증한다.

### 객체를 목 처리하기
* 상술한 내용은 데이터베이스와의 직접적인 상호작용을 모두 임의의 객체에 고립시키고 테스트를 진행하였다.
* 이제 **데이터베이스와 상호작용하는 객체는 신뢰할 수 있으므로, find와 같은 메소드를 스텁으로 만들 수 있다**.
* 목을 작성하는 경우, 다음과 같은 항목을 반드시 이해하고 있어야 한다.
  1. 목으로 처리하는 것은 무엇인가?
  2. 목은 질의에 어떻게 반응하는가?
  3. 목은 어떤 부작용을 발생시키는가?
* **이러한 지식이 충분치 않은 경우, 테스트에 잘못된 가정이 포함된 것**과 같다.
* Mockito를 활용하는 경우 테스트에서 목의 활용을 단순하고 선언적으로 유지하므로, 테스트가 무엇을 하는지 파악하기는 쉬워진다.
  * 심지어 Mockito를 잘 알지 못하는 개발자도 테스트를 읽고 그 의도를 빠르게 이해할 수 있다.

## 결론
* 멀티스레드와 데이터베이스와 상호 작용 하는 코드는 그 자체로 험난한 주제 중 하나이며, 애플리케이션의 많은 결함은 이러한 영역에서 출몰한다.
* 일반적으로 멀티스레드나 데이터베이스, 또는 다른 더 어려운 시나리오들에 대해서는 다음과 같은 전략을 따르는 것이 바람직하다.
  1. **관심사를 분리**한다.
     * **애플리케이션 로직은 스레드나 데이터베이스, 또는 문제가 될 수 있는 다른 의존성과 반드시 분리**되어야 한다.
     * 의존적인 코드는 적절히 고립시켜 전체적인 코드베이스에 흩어지지 않도록 하는 것이 바람직하다.
  2. 느리거나 휘발적인 코드는 목으로 대체한다.
     * 이로 인해 단위 테스트의 의존성을 끊을 수 있다.
  3. 필요한 경우에는 통합 테스트도 작성한다.
     * 이 경우, 통합 테스트는 단순하고 집중적인 형태로 작성되어야 한다.
# UnitTesting
## 2022-05-09 Mon

## 경계 조건 기억하기
* 단위 테스트는 종종 경계 조건과 관련된 결함을 미리 발견하는 데에 도움이 되곤 한다.
  * **경계 조건은 행복 경로의 끝에 있는 것이며, 자주 문제가 발생할 수 있는 지점을 말한다**.
* CORRECT라는 두문자 약어는 잠재적인 경계 조건을 기억하는 데에 도움을 줄 수 있다.
  1. C onformance: 값이 기대한 양식을 '준수'하고 있는가?
  2. O rdering: 값의 집합이 적절히 정렬되었거나, 그렇지 않은가?
  3. R ange: 이성적인 최소값과 최대값의 범위 내부에 있는 값인가?
  4. R eference: 코드 자체에서 통제할 수 없는 외부 참조를 포함하는가?
  5. E xistence: 값이 실제로 존재하는가?
      * 예를 들어 null이거나, 0이거나, 집합에 존재하지 않는 것은 아닌가?
  6. C ardinality: 정확히 충분한 값들만 존재하는가?
  7. T ime: 모든 것이 정확한 시간에, 정시에 순서대로 발생하는가?
* **각 조건에 대해 넘겨지는 인수와 필드, 지역 변수까지 가능한 모든 원인이 데이터에 미치는 영향을 고려**해야 한다.
* 잘못될 수 있는 무엇이라도 떠오른 경우, 그 순간 테스트의 이름을 적어둔다.
  * 이후, 여유가 될 때 테스트에 살을 붙이도록 한다.
  * 이렇듯 **테스트에 대해서는 상상력을 가능한 오래 유지하는 것이 바람직**하다.

### C - 준수
* 이메일 주소, 전화번호, 파일 이름 등 많은 데이터 요소는 정해진 특정 양식을 따라야 한다.
* 이메일 주소를 예로 들어, 입력이 정해진 양식을 준수하는지 확인하기 위해 @기호가 없는 경우나 이름이 없는 경우에 대처할 수 있어야 한다.
  * 코드를 설계하는 것은 전적으로 개발자의 역할이므로, 이 경우 null이나 빈 문자열 또는 예외를 던지는 식으로 구현할 수 있다.
* **중요한 것은 각 경계 조건이 발생했을 때 어떠한 일이 발생하는지 어떤 일이 일어나는지 보여줄 수 있는 테스트 코드를 작성해야 한다는 것**이다.  
* 이메일 주소나 전화번호 등 양식 있는 문자열 데이터를 검증할 때에는 많은 규칙을 지켜야하지만, 이는 일반적으로 단순하다.
* 그러나 **데이터 구조가 복잡해지는 경우, 모든 경계 조건을 확인하면 테스트의 수가 폭발적으로 늘어날 수도 있다**.
  * 기대하는 구조에 입력 데이터가 맞는지 확인하는 방법은 더 많은 브레인스토밍을 실행하는 과정에서 발견할 수 있다.
  * **일반적으로 결함들은 시스템의 경계에 옹기종기 모여 있는 경향이 있으므로, 브레인스토밍 과정에서 더 많은 결함을 발견할 수 있다**.
* **가능하다면 시스템에 검증이 필요한 필드가 처음 입력될 때 값을 검사하는 것으로 필드를 다른 메소드에 넘길 때마다 검사하지 않아도 된다**. 
  * 이렇듯 시스템의 데이터 흐름을 이해하면 불필요한 검사를 최소화할 수 있다.

### O - 순서
* **데이터 순서 또는 커다란 컬렉션에 위치한 데이터 한 조각은 코드가 쉽게 잘못될 수 있는 경계 조건**이다.

### R - 범위
* Java 기본형으로 변수를 만드는 경우, 대부분은 필요한 것보다 훨씬 많은 용량을 갖는다.
  * 그러나 불필요한 값으로 인해 잘못될 가능성은 언제나 존재한다.
  * 예를 들어, 나이를 기본형 int로 정의했다면 음수 나이를 처리할 수 있어야 한다.
* **기본형의 과도한 사용은 기본형 중독 유형의 코드 악취에 해당하며, 이는 Java의 장점을 활용하여 해결**할 수 있다.
  * Java와 같은 객체 지향 언어의 장점은 사용자 정의 추상화 개념을 클래스로 작성할 수 있다는 것이다.
  * 나이를 예로 들어, 나이 클래스를 작성하고 생성자를 통해 범위를 검증하면 시스템에서 나이와 관련된 범위 문제를 미연에 방지할 수 있다.
* 어떠한 불변식은 임의의 코드가 실행되더라도 참으로 유지되어야 하는 속성을 의미한다.
  * 테스트 클래스에서 불변식을 단언 형태로 확인할 수 있으며, 이 경우 @After 메소드를 통해 테스트가 완료되었을 때마다 확인하도록 할 수 있다.
  * @After 메소드에 정의된 불변식 단언 코드는 각 테스트 케이스에 의해 테스트 대상 클래스가 조작된 후에 확인된다.
  * 테스트 대상 클래스를 조작하는 모든 테스트에 대해 junit이 스스로 불변식을 검사해주므로, 개발자는 마음을 놓을 수 있다.

### 불변성을 검사하는 사용자 정의 matcher 작성하기
* matcher는 왼쪽에서부터 읽었을 때 잘 읽히는 단언을 표현해야 한다.
* 사용자 정의 matcher를 구현하려는 경우, org.hamcrest.TypeSafeMatcher 클래스를 상속하여 매칭하고자 하는 타입을 지정한다.
  * 이 경우, 클래스는 제약 사항을 포함하는 matchesSafely() 메소드를 오버라이드해야 한다.
* **사용자 정의 matcher 클래스는 matcher 인스턴스를 반환하는 정적 팩토리 메소드를 제공해야 하며, 단언을 작성할 때 이 팩토리 메소드를 호출**하게 된다.

### 범위 경계 조건과 인덱스
* **인덱싱은 수많은 잠재적인 오류를 포함하므로, 인덱스를 다루는 경우 다음과 같은 시나리오를 반드시 고려**해야 한다.
  1. 시작과 마지막 인덱스는 같지 않아야 한다.
  2. 시작이 마지막보다 클 수 없다.
  3. 인덱스는 음수일 수 없다.
  4. 인덱스가 허용된 것보다 클 수 없다.
  5. 개수는 실제 항목의 개수와 맞아야 한다.

### R - 참조
* 어떠한 메소드를 테스트하는 경우, 반드시 다음의 항목을 고려해야 한다.
  1. 범위를 넘어서는 것을 참조하고 있는가?
  2. 외부 의존성은 무엇인가?
  3. 특정한 상태에 있는 객체를 의존하고 있는가?
  4. 반드시 존재해야 하는 그 외의 다른 조건들이 있는가?
* 예를 들어, 스택의 pop 메소드를 호출하려면 스택이 비어 있지 않아야 한다.
  * 또는 차량 변속기를 주행에서 주차로 변경하려고 하는 경우, 우선 차를 멈춰두어야 한다.
* **어떠한 상태에 대해 가정하는 경우, 그 가정이 맞지 않아도 코드가 합리적으로 동작하는지를 반드시 검사**해야 한다.
  * 이를 통해 어떠한 조건이 맞지 않는 경우 메소드가 우아하게 동작하는 것을 보장할 수 있어야 한다.

### E - 존재
```
> 메소드는 홀로 설 수 있어야 한다.
```
* **어떠한 인자를 허용하거나 필드를 유지하는 메소드에 null, 0, 빈 값을 넘기는 경우에 어떠한 일이 발생하는지를 반드시 생각**해보아야 한다.
  * 이렇듯 스스로에게 주어진 값이 존재하는지 자문하는 것으로 많은 잠재적인 결함을 확인할 수 있다.
* Java 라이브러리는 어떠한 데이터가 존재하지 않거나 초기화되지 않은 상태에서 접근되었을 때 길고 복잡한 예외를 던지는 경향이 있다.
  * 이 경우, 특정한 메시지를 에외에서 알려주면 문제를 추적하는 과정을 매우 단순하게 만들 수 있다.
* **개발자는 일반적으로 행복 경로를 만드는 데에 집중하며, 예상하는 데이터가 없는 경우에 해당하는 불행 경로는 그 다음에 생각하는 경향이 있다**.
* 상술한 문제에 대비하여 **다음의 항목을 반드시 확인하는 테스트를 작성**할 수 있도록 한다.
  1. 메소드가 잠재적인 null을 반환하는 경우
  2. 기대하는 파일이 없는 경우
  3. 네트워크가 가용하지 못한 경우

### C - 기수
* **많은 개발자는 숫자 세기에 능하지 않으며, 문제에 대해 충분히 생각하지 않아서 발생하는 오류를 많이 경험**한다.
* 이러한 유형의 오류는 한 끗 차이로 발생하는 수 많은 경우 중 하나이나, 종종 치명적인 상태가 될 수 있다.
* E 항목의 '존재' 역시 기술적으로는 기수의 특수한 경우이다.
* 일반적으로 **집합을 이루는 값의 개수는 다음과 같은 세 경우를 집중적으로 확인**해야 한다.
  1. 0
  2. 1
  3. n
* 이는 0-1-n 법칙에 해당하며, 무언가의 컬렉션에서 중요히 다루어야 할 세 가지 경우를 가리킨다.
  1. E - 존재 절에서도 확인했듯, 아무 것도 없는 것은 중요한 경계 조건이다.
  2. 컬렉션이지만 단 하나의 항목만을 다루고 있는 상황도 중요한 경계 조건이다.
  3. 컬렉션을 다루는 경우, 일반적으로 10개나 100개, 1000개는 다루는 원리가 같다.
* 이러한 **개수의 개념은 하나도 없는 경우, 하나만 있는 경우, 많이 있는 경우로 나뉘는 테스트 작업 목록을 정의하는 데에 도움**을 줄 수 있다.
* 때문에 **테스트 코드는 0과 1, 그리고 n이라는 경계 조건에만 집중**해야 한다.
  * 이 때, **n은 비즈니스 요구사항에 따라 바뀔 수 있는 변수**이다. 

### T - 시간
```
> 데이터 순서가 중요한 것처럼 메소드의 호출 순서도 중요하다.
```
* 시간과 관련된 다음의 항목을 반드시 고려할 수 있어야 한다.
  1. 상대적인 시간: 시간 순서
  2. 절대적인 시간: 측정된 시간
  3. 동시성 문제들
* 어떠한 인터페이스들은 close()보다 read()가 우선 호출되어야 하는 것과 같이 태생적인 상태를 갖는다.
* 메소드들의 호출 순서가 맞지 않는 경우에 어떤 일이 발생하는지 반드시 고려해야 한다.
  * 예를 들어, 순서의 중간을 생략하거나 여러 대안 순서를 적용해봐야 한다.
* 상대적인 시간은 타임 아웃 문제도 포함할 수 있으며, 수명이 짧은 자원에 대해 코드가 얼마나 대기할지 결정해야 한다.
  * 메소드에 소요되는 시간이 인내심이 부족한 호출자에게 너무 길지는 않은지도 결정할 수 있어야 한다.
* UTC와 DST 등 복잡한 시간 세계의 결과는 연산이 항상 기대한대로 동작하지 않을 수 있다.
  * 따라서 **시간에 민감한 테스트는 이러한 경계 조건에 해당하는 날을 확실하게 확인할 수 있어야 한다**.
  * 어떠한 하위 라이브러리가 개발자 대신 이러한 문제들을 정확하게 처리할 것이라고 가정하는 것은 금물이며, 언젠가는 여기저기 깨진 코드가 발생하게 된다.
* **실패에 대한 또 다른 해결책은 시스템 시계에 의존하는 테스트를 작성하는 것**이다.
  * 이 경우, 테스트 코드 내부에서 통제할 수 있는 곳으로부터 얻어오는 시간을 사용하도록 애플리케이션을 수정한다.
* 동시성과 동기화된 접근 맥락에 관련된 문제는 시간과 관련된 대표적인 문제점 중 하나이다.
* 멀티스레드이면서 동시적인 프로그램을 설계하고 구현하는 것은 매우 복잡한 내용이며, 다음과 같은 항목을 반드시 자문해야 한다.
  1. 동시에 같은 객체를 다수의 스레드가 접근하는 경우가 발생하는가?
  2. 어떠한 전역 또는 인스턴스 수준의 데이터나 메소드에 동기화할 것인가?
  3. 파일 또는 하드웨어로의 외적인 접근은 어떻게 처리할 것인가?
* **클라이언트에 동시성 요구 사항이 있는 경우, 다수의 클라이언트 스레드를 보여 주는 테스트 역시 작성할 필요**가 있다.

## 결론
* 모든 경계는 반드시 알 필요가 있으며, 테스트라면 더욱 그렇다.
* **경계 조건은 여러 종류의 결함을 특히 자주 만들어내는 지점**이다.
* **CORRECT 두문자 약어를 통해 단위 테스트를 작성하는 과정에서 고려해야 할 경계들을 쉽게 기억**할 수 있다.
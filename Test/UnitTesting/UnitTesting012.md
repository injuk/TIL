# UnitTesting
## 2022-05-12 Thu

## 테스트 주도 개발
```
> 작성하려는 코드가 있다면, 코드를 작성하기에 앞서우선 어떻게 코드를 테스트할지 고민해야 한다.
```
* 어떤 코드에서는 단위 테스트가 작성하기 어렵고, 어려운 레거시 코드는 점차 늘어만 간다.
  * 이러한 문제의 주된 이유 중 하나는 단위 테스트에 대한 관심이 부족하기 때문이다.
  * 즉, **단위 테스트를 어떻게 할지 고민할수록 코드는 테스트하기 쉬워진다**.
* **코드를 작성한 후에 어떻게 테스트할지 고민하는 것보다는 작성할 코드를 묘사하는 테스트를 설계하는 것이 더 효율적**이다.
  * 이러한 **역방향 접근법은 일견 불가능해보일 수 있으나, 이것이 테스트 주도 개발에 기반을 두는 단위 테스트 전략의 핵심**이다.
* TDD에서의 단위 테스트는 시스템의 모양을 잡고 통제하기 위한 도구로 활용되어야 한다.
  * 이 때, 단위 테스트는 소프트웨어를 어떻게 만들어갈지에 대한 사이클의 핵심적인 부분이다.
  * 따라서 TDD를 채택하는 것으로 소프트웨어 설계는 더 좋은 쪽으로 개선되기 쉽다.

### TDD의 이점
* 단위 테스트를 코드의 구현이 끝난 이후에 작성하는 방식은 코드가 예상한대로 동작한다는 자신감을 불어넣어 준다.
  * 이러한 이점은 TDD에서도 동일하게 얻을 수 있으며, 심지어 그 이상을 성취할 수 있다.
* 코드를 깨끗하게 유지하려고 노력하지 않으면 시스템은 점점 퇴화하지만, 개발자는 여러 이유에에서 나쁜 코드를 정리하지 않고는 한다.
* **TDD를 도입하는 경우, 코드가 변경된다는 사실에서 기인하는 두려움을 지울 수 있다**.
  * 리팩토링은 실제로도 위험 부담이 있는 일이며, 개발자는 사소한 변경에서도 실수할 수 있다.
  * **TDD를 잘 따르는 경우, 구현하는 실질적인 모든 사례에 대한 단위 테스트를 작성**하게 된다.
  * 이렇게 작성된 단위 테스트는 개발자가 코드를 지속적으로 발전시킬 수 있게 하는 자유를 준다.

### TDD를 쉽게 시작하기
* TDD는 일반적으로 다음과 같은 사이클로 구성된다.
  1. 실패하는 테스트 코드 작성하기
  2. 테스트 통과시키기
  3. 이전 두 단계에서 추가되거나 변경된 코드를 개선하기
* 시작 단계인 첫 번째 단계는 시스템에 추가하고자 하는 동작을 정의하는 테스트 코드를 작성한다.
  * 테스트 코드는 점진적으로 작성하며, 우선 작은 테스트를 작성한 후에 코드를 작성한다.
* **TDD에서 첫 테스트는 항상 실패해야 하며, 테스트가 기술하는 기대 동작이 아직 시스템에 존재하지 않는 것을 보장**할 수 있다.
  * 이렇듯 **TDD를 진행하는 과정에서는 여러 불필요한 가정을 피하기 위해 항상 테스트를 먼저 실패시켜야 한다**.
* **테스트가 원하는 동작이 아직 정의되지 않았기에 실패함을 확인했다면, 테스트를 가장 빠르게 통과하는 단순한 방법으로 기대 동작을 구현**한다.
  * 이 단계에서는 하드코딩된 값을 반환하여 테스트를 통과해도 무방하다.
* **테스트에 통과하는 데에 성공한 경우, 작성한 코드를 다시 확인하며 리팩토링을 적용할지 결정**한다.
* 이렇듯 **하드코딩된 값으로 테스트를 통과시키는 것이 억지스러워 보일 수 있으나, TDD의 점진적인 사고 방식을 따르는 것은 매우 중요**하다.

### TDD의 첫 사이클
* 상술한 과정에서 진행한 **실패 - 통과 - 개선의 한 사이클을 통해 새로운 클래스의 기능을 작성하고, 이것이 동작함을 보장**하게 되었다.
* 깃과 같은 소스 코드 저장소를 사용하는 경우, 이 시점에서 코드를 커밋할 수 있다.
  * **TDD를 진행하면서 한 사이클마다 커밋하는 것은 필요 시 코드를 백업하거나 작업 사항을 되돌리기 수월**하게 한다. 

### 코드를 점진적으로 작성하기
* **실패하는 각 테스트에 대해, 테스트를 통과할 수 있을 정도의 코드만 추가하는 것은 가능한 가장 작은 증분을 추가하는 것**과 같다.
* 이렇듯 코드의 증분을 추가하는 과정에서 따라야 하는 사고 방식은 크게 다음과 같다.
  1. 우선 테스트가 나타내는 명세를 정확히 코딩한다.
  2. 테스트가 모두 통과하는 경우, 잠재적으로 코드를 배포할 수 있게 된다.
  3. 이 시점에서 테스트는 시스템이 무엇을 할 수 있는지를 문서화하게 된다.
  4. 이로 인해 개발자는 추측에 근거하는 개발과 같은 잠재적인 낭비를 피할 수 있게 된다.
* **TDD를 따르는 실용적인 관점에서, 가능한 한 작은 양의 코드를 작성하는 것은 실패하는 또 다른 테스트를 작성할 수 있다는 의미**를 갖는다.
  * 반면, 필요 이상으로 많은 코드를 작성하는 것은 즉시 통과할 수 있는 테스트를 추가할 수 있다는 의미를 갖는다.
  * 이는 적절한 피드백을 받기 전에 많은 양의 코드를 양산하고 넘어가는 기존의 방식으로 회귀하는 것과 같다.
  * **가능하다면 결함 있는 코드를 작성한 경우에는 그 즉시 피드백을 받는 것이 이상적**이다. 

### 새로운 '작은' 기능 추가하기
* 새로운 기능을 추가하기 위해, 우선 실패하는 테스트를 작성하는 가장 작은 증분을 추가하는 작업은 다음과 같다.
  1. 새로운 테스트 메소드를 작성하며, 추가될 기능에 대한 명세를 작성한다.
  2. 테스트를 실행하여 실패하는 것을 확인하고, 테스트 대상 클래스에서 해당 기능을 제공하지 않는 것을 확인한다.
  3. 테스트에 통과할 수 있도록 대상 클래스에 새로운 메소드를 추가한다.
  4. 추가된 테스트 메소드와 대상 클래스의 메소드를 확인하며 리팩토링을 적용할지 결정한다.

### 테스트 정리하기
* TDD의 점진적인 각 사이클마다 코드를 리팩토링하여 정리할지 고민해야 한다.
* 테스트는 짧고 깔끔하게 유지되어야 하므로, 각 테스트마다 공통되는 초기화 로직 등을 @Before 메소드로 추출해야 한다.
* **각 리팩토링 기법을 적용할 때마다 테스트를 실행하여 코드가 깨지지 않았다는 것을 반드시 확인**한다.
  * TDD의 아름다움은 모든 기능에 대해 먼저 테스트를 작성하며, 언제나 방금 작성된 코드를 리팩토링하고 정리할 수 있다는 자신감을 주는 데에서 온다.
  * 이렇듯 **TDD는 거의 모든 코드에 대해 리팩토링을 안전하게 진행할 수 있도록 지원**한다.
* 리팩토링 과정에서 언제나 더 명확한 이름을 명명할 수 있는지 고민하도록 한다.
  * 대부분의 리팩토링은 쉽게 적용할 수 있으나, 그 효과는 매우 크다.
  * 예를 들어 변수의 이름을 변경하거나 로직을 메소드로 추출하는 것은 코드를 읽는 개발자에게 많은 정보를 주며 테스트를 향상시킨다.

### 또 다른 '작은' 기능 추가하기
* 상술한 방식을 통해 대상 클래스에 새로운 기능을 추가하고, 이를 테스트할 수 있다.
* **TDD로 생각하는 과정에서 중요한 것 중 하나는 다음에 작성할 테스트를 결정하는 것**이다.
* **개발자는 코드가 다루어야 하는 가능한 모든 조합과 시나리오를 이해할 수 있어야 한다**.
* **TDD로 성공하기 위해서는 각각의 시나리오를 우선 테스트로 작성하고, 각 테스트를 통과하게 하는 코드의 증분은 최소화되도록 코드를 작성**해야 한다.

### 설계 우회하기
```
> TDD를 할 때에는 리팩토링에 필요한 변경을 임의의 클래스로만 제한할 필요가 없으며, 필요한 다른 클래스의 설계를 변경해도 좋다.
```
* TDD의 리팩토링 과정에서, 리팩토링 대상 클래스에 어색함이 있다면 설계를 변경하여 다른 클래스에 책임을 위임해도 무방하다.
* 이를 위해 다른 클래스에 넘겨질 행위를 기술하는 테스트를 우선적으로 작성하고, 실패 - 통과 - 개선의 TDD 사이클을 동일하게 적용하도록 한다.

### 인터페이스 확장하기
* 단일 객체만을 지원하는 인터페이스가 컬렉션을 제공할 수 있도록 확장하는 경우에도 다음과 같이 TDD의 사이클을 따르도록 한다.
  1. 작성할 테스트를 결정한다.
  2. 실패하는 테스트를 작성한다.
  3. 테스트를 통과하도록 수정한다.
     * 이 과정에서, 최초에는 단순히 테스트만을 통과하기 위해 하드코딩된 값을 반환해도 무방하다.
     * 테스트 대상 메소드는 컬렉션을 반복하는 과정에서 기존에 작성해둔 단일 객체 처리용 메소드를 호출하는 식으로 작성될 수 있다.
  4. 리팩토링 여부를 결정한다.
* **테스트를 리팩토링하면 TDD 사이클을 1 - 2분 정도로 짧게 유지하는 데에 도움**을 준다.
* TDD는 언제나 최상의 설계를 마법처럼 만들어내지는 않으므로 리팩토링을 계속해나가야 한다.
  * 그러나 **TDD의 과정에서 이미 작성된 테스트들은 원하는 시점에 더 좋은 설계로 개선하는 리팩토링을 쉽게 적용할 수 있도록 지원**해준다.
* **리팩토링 과정에서 AAA 원칙을 조금 위배하는 것이 가독성에 도움을 준다면, 기꺼이 위배하는 것이 바람직**하다.
  * AAA는 불변의 법칙이 아니며, 특히 반복적인 성질을 갖는 테스트에서는 불필요한 실행 부분과 단언 부분을 하나로 합치더라도 가독성이 향상되는 경우가 많다.

### 클래스 분리하기
* 클래스에 기능을 추가하는 과정에서 명령 질의 분리 원칙을 어기는 경우가 발생할 수 있다.
  * 예를 들어, 테스트를 추가한 후 실패를 확인한 다음 테스트를 통과시키는 과정에서 부작용이 발생하는 경우가 있다.
  * 이 경우, **대상 클래스를 억지로 테스트에 꾸겨 맞추기 보다는 명령 질의 분리 원칙을 위배하지 않도록 클래스를 분할하는 것을 고려**할 수 있다.
* 이렇게 분리된 클래스 역시 자신의 단위 테스트를 갖도록 TDD의 사이클에 맞추어 작성되어야 한다.
  * 이렇게 분리된 클래스는 단일 책임 원칙 역시 준수할 가능성이 높다.

### 문서로서의 테스트
```
> 테스트 클래스는 세심하게 작성될수록 테스트 대상 클래스에 의도적으로 설계된 동작들을 더욱 자세히 문서화할 수 있게 된다.
> TDD를 따르는 과정에서도 작성된 테스트의 이름이 적절한지 정기적으로 확인하는 것이 바람직하다.
```
* **TDD의 사이클에 따라 테스트를 작성하는 과정에서, 가끔은 테스트 클래스에 작성된 메소드의 이름을 돌아볼 필요**가 있다.
* **이상적인 것은 각 테스트 클래스의 테스트 메소드 이름만으로 테스트 대상 클래스의 동작이 무엇인지 파악할 수 있는 상황**이다.
  * 예를 들어, Profile 클래스를 테스트하는 ProfileTest 클래스의 테스트 메소드 이름만 보고도 Profile 클래스의 기능을 알 수 있어야 한다.
* **테스트 클래스는 각 테스트의 이름이 다른 것들과 같이 깔끔하고 일관성이 있을수록 더욱 신뢰할 수 있는 클래스 문서로서 기능**할 수 있다.
* 한 편, 길고 서술적인 테스트의 이름은 나쁘지 않지만 더 좋아질 수 있다.
  * 예를 들어, ProfileTest 클래스는 어차피 Profile 클래스를 테스트하므로 각 테스트 메소드 이름에서 Profile이라는 단어를 제거할 수 있다.
  * 테스트 대상 클래스의 메소드가 오버로드된 경우, 인자의 형태를 테스트 메소드에 명시하여 이를 구분할 수 있다. 
* **테스트의 이름을 개선했음에도 불구하고 너무 길고 서술적인 경우, 테스트 클래스 자체를 분할**할 수 있다.
  * **연관된 동작 그룹을 기준으로 클래스를 분할하고, 각 클래스가 관련된 테스트만을 포함하도록 작성하는 것으로 테스트 메소드의 이름을 짧게 유지**할 수 있다.
  * 즉, 테스트 대상 동작을 테스트 클래스의 이름에 포함하는 것으로 연관된 동작에 집중하고 이름으로부터 중복된 단어를 제거할 수 있다.

### TDD의 리듬
```
> TDD의 사이클은 짧으며, 테스트 - 코드 - 리팩토링의 각 사이클은 몇 분 안에 종료되어야 한다.
```
* TDD의 사이클에서, 각 단계에서 추가되거나 변경되는 코드의 증분은 비교적 작게 유지된다.
* **개발자는 TDD의 리듬에 익숙해지기 위해 임의의 기능을 구현하는 과정에서 스스로에게 테스트를 통과하기 까지 10분의 시간 제한**을 걸 수도 있다.
  * 이 경우, 10분 이내에 테스트에 통과하지 못했다면 작업 중인 코드를 모두 폐기하고 더 작은 단계로 시도하도록 한다.
* 이렇듯 **TDD의 각 사이클은 테스트를 가설로 하는 시간 제한이 있는 실험으로 취급**할 수 있다.
  * 실험이 엉망이 되었다면, 모두 폐기하고 다시 시작하되 가설의 범위를 축소해야 한다.
  * **이러한 과정을 통해 무엇이 잘못되었는지 빠르게 찾을 수 있으며, 이는 앞으로 낭비될 시간에 비해 더 이른 시기에 좋은 해답을 가져다줄 수 있다**.

## 결론
* **TDD는 테스트를 작성하고, 실패를 확인하고, 테스트를 통과시킨 후에 리팩토링하는 작은 사이클을 계속해서 반복하는 것**이다.
  * 이를 위해 단위 테스트에서 배운 모든 내용을 단순하고 반복적인 사이클에 도입할 수 있다.
* **TDD를 도입하는 것으로 안정적인 테스트 코드를 작성할 수 있음은 물론, 설게에 대한 접근 방식 역시 바뀔 수 있다**.
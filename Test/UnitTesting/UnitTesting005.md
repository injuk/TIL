# UnitTesting
## 2022-05-08 Sun

## 좋은 테스트의 속성
* 단위 테스트는 잘 사용했을 때 많은 이점을 얻을 수 있다.
* 그러나 **테스트 코드 역시 개발자가 작성하고 유지보수해가야 하는 또 다른 코드에 해당**한다.
* 테스트에 다음과 같은 문제점이 있는 경우, 좋은 테스트로 볼 수 없다.
  1. 테스트를 사용하는 사람에게 어떠한 정보도 주지 못하는 경우
  2. 산발적으로 실패하는 경우
  3. 어떠한 가치도 증명해내지 못하는 경우
  4. 실행 자체가 오래 걸리는 경우
  5. 코드를 충분히 커버하지 못하는 경우
  6. 세부 사항, 즉 구현과 너무 강하게 결합되어 작은 변화에도 쉽게 깨지는 경우
  7. 수많은 설정 고리로 점프하는 난해한 테스트의 경우

### 좋은 테스트 조건으로서의 FIRST
* **FIRST 원리는 다음과 같이 분류되며, 이를 준수하는 경우 단위 테스트 작성자가 쉬이 빠질 수 있는 위험을 회피**할 수 있다.
  1. F ast: 빠른
  2. I solated: 고립된
  3. R epeatable: 반복 가능한
  4. S elf validating: 스스로 검증 가능한
  5. T imely: 적시의
* FIRST는 드 간어 자체로 단위 테스트 맥락에서 큰 의미를 갖는다.
* 개발자는 일반적으로 코드를 작성한 후 테스트 코드를 작성하곤 한다.
  * 그러나 순서를 바꾸어 테스트를 우선 작성하고, 코드를 작성하면 이전과는 다른 더 좋은 결과를 얻을 수도 있다.
  * 이는 일반적으로 테스트 주도 개발로 지칭되는 개념을 말하며, TDD에서는 일반 단위 테스트와 달리 테스트 코드를 우선 작성한다.
* **테스트를 먼저 작성하든 그렇지 않든, FIRST 원리를 준수하는 것은 어떠한 경우에도 적용이 가능하며 테스트의 품질을 높여준다**.

### Fast
* 빠름과 느림을 나누는 테스트의 속도 구분은 다소 자의적이나, 일반적으로 **빠른 테스트 코드란 코드만 실행하며 수 밀리초 수준에 종료되는 것**을 말한다.
  * **빠른 테스트는 코드만 실행하므로, 데이터베이스와 같은 외부 시스템에 접근하지 않고 로컬에 위치한 로직 코드만을 실행**한다.
* 시스템이 커지면 단위 테스트도 실행하는 데에 점점 오래 걸리게 된다.
  * 이는 누구나 겪을 수 있는 일반적인 상황이지만, 자랑스레 말할 만한 일도 아니다.
  * **단위 테스트를 하루에 서너 번 실행하기도 어렵다면 무엇인가 잘못되고 있다는 신호**이다.
* **단위 테스트 스위트의 가치는 대상 시스셑ㅁ에 대한 지속적이고 종합적인 피드백을 주지 못할수록 저하**된다.
* **테스트는 언제나 빠르게 유지되어야 하며, 설계를 깨끗하게 하는 것으로 테스트를 빠르게 유지하는 데에 도움**을 줄 수 있다.
  * **빠른 테스트를 위해, 최우선적으로 느린 테스트에 대한 의존성을 줄여야** 한다.
* 더 많은 로직을 커버하는 소수의 빠른 테스트는 데이터베이스에 의존하는 단일 테스트보다 수월하게 실행될 수 있다.
* **느린 것에 의존하는 코드를 최소화하는 경우, 테스트는 빠르게 동작하며 작성하기도 쉬워진다**.
  * 이렇듯 의존성을 최소화하는 것 역시 좋은 설계의 목표에 해당한다.
  * 코드를 클린 객체 지향 설계 개념과 맞출수록 테스트 코드의 작성도 쉬워진다.

### Isolate
* 좋은 단위 테스트는 검증하려는 적은 양의 코드에만 집중해야 한다.
* 직접적으로나 간접적으로나 테스트 코드와 상호 작용하는 코드가 많아질수록 문제가 발생할 소지는 늘어난다.
  * 예를 들어, 테스트 코드가 외부 저장소와 상호 작용하게 되면 테스트가 가용성 또는 접근성 이슈로 실패할 가능성이 높아진다.
* 좋은 단위 테스트는 다른 단위 테스트에 의존하지 않는다.
  * 예를 들어, 비용이 높은 데이터를 재활용하기 위해 여러 테스트 케이스의 순서를 조작하고 싶을 수 있다.
  * 이를 통해 **일시적으로는 테스트의 실행 속도를 높일 수 있겠지만, 장기적으로는 의존성의 악순환만 동시에 발생**한다.
* 따라서, **테스트 코드는 어떠한 순서나 시간에 관계 없이 실행이 가능해야 한다**.
  * 각각의 테스트가 적은 양의 동작에만 집중하면 테스트 코드를 집중적이고 독립적인 상태로 유지하기 쉬워진다.
* **단일 책임 원칙은 테스트 메소드에서도 좋은 가이드가 되어줄 수 있다**.
  * 단일 책임 원칙에 따르면, 클래스는 작고 단일한 목적을 가져야 하며 클래스를 변경해야 할 이유가 단 하나 뿐이어야 한다.
  * 때문에 **테스트 메소드가 하나 이상의 이유로 깨진다면 단일 책임 원칙을 위배하지 않는지 확인하며, 테스트를 분할하는 것을 고려**해야 한다.

### Repeatable
```
> 각 테스트는 언제나 동일한 결과를 만들어내야 한다.
```
* 개발자가 테스트를 설계하므로, 테스트 코드는 전적으로 개발자의 통제 아래에 있다.
* **테스트 설게에서 개발자의 역할 중 하나는 테스트 결과가 매 번 어떻게 나와야 하는지 설명하는 단언을 제공하는 것**이다.
* 반복 가능한 테스트는 실행할 때마다 매 번 결과가 같아야 한다.
  * 따라서, **반복 가능한 테스트를 만들려면 직접 통제할 수 없는 외부 환경의 항목들과 격리**해야 한다.
* 그러나 시스템은 불가피하게 통제할 수 없는 요소와 상호 작용해야만 할 수도 있다.
  * 예를 들어 현재 시간을 다루어야 하는 경우, 테스트 대상 코드를 나머지와 격리하고 시간 변화에 독립성을 유지하는 방법으로 목 객체를 활용할 수 있다.

### Self validating
```
> 테스트는 기대하는 것이 무엇인지 단언하지 못하면 테스트가 아니다.
```
* 단위 테스트는 개발자의 시간을 소모하기보다는 절약해야 한다.
  * 테스트 결과를 수동으로 검증하고, 눈으로 확인하는 것은 시간 소모적인 절차이다.
  * 이러한 방식은 리스크도 크며, 집중력이 떨어져 정작 중요한 신호는 놓칠 수도 있다.
* **테스트는 스스로 검증 가능해야 하며, 필요한 것을 준비할 수도 있어야 한다**.
  * **테스트를 시작하기 전에 수동으로 준비 단계를 만드는 것은 어리석은 짓**이다.
  * **테스트는 실행을 위해 필요한 어떠한 설정 단계든지 자동화되어야 하며, 테스트를 실행하는데에 외부 설정이 필요하다면 Isolated 원리가 위배된 것**이다.
* 한 발 더 나아가, 테스트는 언제 어떻게 실행할지도 자동화될 수 있다.
  * 작은 규모라면 IDE 환경에서의 Infinitest와 같은 도구를 사용할 수 있다.
  * 조금 더 큰 규모에서는 Jenkins 등의 CI 도구를 활용하여, 소스 저장소의 변화를 감지하면 빌드와 테스트 절차를 시작하도록 할 수 있다.
* 오늘 날 많은 프로젝트에서는 이미 CI CD를 도입하였으며, 도입 단계에서 제품 배포까지의 불필요한 오버헤드를 획기적으로 줄여가고 있다.

### Timely
* 사실상 언제라도 마음만 먹는다면 단위 테스트의 작성을 시작할 수 있다.
  * 예를 들어, 지금 당장이라도 시스템의 오래된 부분에 코드를 추가하고 단위 테스트를 시작할 수도 있다.
  * 그러나 가능하면 적절한 순간에만 단위 테스트에 집중하는 것이 더 좋다.
* **단위 테스트는 마치 양치질처럼 좋은 습관이지만, 완전히 체화되지 않은 경우 매 번 건너뛰고 싶은 충동을 느끼기 쉽다**.
  * 이러한 행동은 한 순간에는 편리하지만, 추후에는 치석을 제거하는 시간처럼 고통스럽게 변질되곤 한다.
* **단위 테스트 역시 코드를 검증하는 것을 미룰수록 불쾌한 치석이 끼고, 충치와 같은 결함이 늘어나기 쉽다**.
  * 이 경우, 코드를 소스 저장소에 커밋하면 이를 되돌려 테스트를 작성하기는 더욱 어려워진다.
* 테스트를 사랑하는 많은 프로젝트의 단위 테스트 지침은 엄격한 경우가 많으며, 이러한 좋은 실천 습관을 준수하기 위해 지속적인 경계가 필요하다.
* **단위 테스트를 더 많이 할수록 테스트 대상 코드는 줄어들게 된다**.
  * 이로 인해 단위 테스트의 작성은 점차 쉬워지게 되며, 나아가 새로운 코드를 추가했을 때 테스트의 효과는 즉시 나타난다.
* 작은 규모로 코드를 작성한 후에 테스트를 작성하는 주기가 정착되었다면, 테스트를 우선 작성하는 테스트 주도 개발의 도입을 고려하는 것이 바람직하다.
* **레거시에 대한 테스트는 시간 낭비가 되기 쉽다**.
  * 코드에 큰 결함이 없고, 지금 당장 변경할 예정이 없다면 단위 테스트를 작성하는 노력은 거의 보상받지 못한다.
  * **레거시 코드에 이러한 노력을 쏟는 대신, 더 말썽이 많고 역동적인 부분에 집중하는 것이 바람직**하다.

## 결론
* 단위 테스트를 작성하는 것은 상당한 시간이 필요한 작업이다.
* 단위 테스트의 작성은 그에 상응하는 가치가 있는 작업이지만, 이 역시 개발자가 유지보수해야하는 또 다른 코드에 불과하다.
* **테스트 코드를 언제나 고품질로 유지하여 단위 테스트에 투자한 비용을 보호**할 수 있어야 한다.
* **좋은 테스트를 만들기 위해 FIRST 원리를 활용하고, 이를 통해 좋은 테스트가 갖는 속성을 기억**할 수 있다.
# UnitTesting
## 2022-05-10 Tue

## 더 큰 설계 문제
* 작은 코드들을 지속적으로 리팩토링하는 것은 코드의 유지 보수 비용을 지속적으로 낮추어줄 수 있다.
* 단위 테스트를 작성하는 것은 설계라는 더 크고 지속적으로 변경되는 퍼즐의 일부와도 같다.
* 시스템의 설계는 테스트를 작성에 영향을 주며, 테스트 역시 설계에 영향을 줄 수 있다.

### 단일 책임 원칙을 준수하는 클래스
* 단일 책임 원칙은 클래스를 변경하는 경우, 단 하나의 이유만 있어야함을 의미하는 원칙이다.
* 따라서 **어떠한 클래스에 대해 단일 책임을 강조할수록 변경에 의한 리스크는 줄어든다**.
  * 반대로, 클래스에 더 많은 책임이 존재할수록 클래스에 있는 코드를 변경할 때 기존의 다른 동작들을 깨트리기는 쉬워진다.
* **더 작고 집중화된 클래스는 재사용 측면에서도 가치를 제공할 수 있으며, 여러 맥락에서 활용이 가능**해진다.
  * 반면, 다수의 책임을 갖는 큰 클래스는 다른 맥락에서 재사용하기 어려울 수 밖에 없다.

### 클래스 분리하기
* **클래스가 실세계 개념과 잘 들어맞는다는 이유만으로 단일 클래스로 한정할 필요는 없다**.
  * 클래스는 점점 커지고 복잡해지므로, 단일 클래스로 우겨넣은 개념으로 인한 피해는 언젠가 반드시 생기기 마련이다.
  * 또한, 커다란 클래스는 재사용과 동작을 이해하기 위한 가독성도 떨어진다.
  * 이로 인해 클래스를 수정할 때마다 관계 없는 항목들이 깨지기 쉬워진다.
* 클래스를 설계하는 과정에서 개념에 매핑하되, 구체적인 항목에는 매핑하지 않아야 한다.
* **설계는 코드를 변경하는 모든 곳에 존재하므로, 단지 클래스 수준의 상호작용이 아닌 유지보수의 모든 측면에 집중할 수 있어야 한다**.
* 코드를 새로운 클래스로 추출할수록 작성한 테스트는 더 직관적이고, 작성하기 쉬워진다.
* 기존 클래스의 private 메소드를 새로운 클래스의 public 메소드로 추출한 경우, 테스트 커버리지가 충분하지 않음을 인식하게 된다.
  * 이는 private 메소드 자체가 테스트하기 어렵기 때문이며, 자연스러운 현상이다.
  * 따라서 **새로이 작성된 클래스에 대한 테스트를 작성하고, 새롭게 노출된 public 메소드에 대한 동작을 문서화할 수 있어야 한다**.

### 명령 질의 분리 원칙 준수하기
* **어떠한 값을 반환하는 동시에 부작용을 발생시키는 메소드는 명령 질의 분리 원칙을 위반**한다.
  * 이 때, 부작용이란 시스템 상에 존재하는 어떠한 클래스 또는 엔티티의 상태를 변경하는 것을 가리킨다.
* **명령 질의 분리 원칙에 따르면 메소드는 다음의 두 작업 중 반드시 하나만을 수행**해야 한다.
  1. 부작용을 생성하는 작업에 해당하는 명령 실행
  2. 질의에 응답하기 위한 값 반환
* **명령 질의 분리 원칙을 위배하는 경우, 여러 번 질의를 수행하는 작업에서 암시적으로 상태가 변경되므로 원하지 않는 결과가 발생하기 쉽다**.

### 단위 테스트와 유지보수 비용
* 리팩토링 또는 수정 사항을 반영하는 과정에서 단위 테스트에 실패하는 경우, 우선 이슈를 해결해야 한다.
  * 이는 단위 테스트를 소유하기 위한 비용에 해당한다.
* 일반적으로, **단위 테스트를 소유함으로써 얻는 이점이 훨씬 크기 때문에 테스트 코드를 고치는 비용은 기꺼이 받아들여질 수 있다**.
* 그러나 **테스트가 동시에 너무 많이 깨지는 현상이 자주 발생한다면, 이는 더 큰 설계의 문제가 있음을 시사**한다.

### 단위 테스트의 유지보수 비용 줄이기
```
> 시스템의 설계 및 코드의 품질이 낮아질수록 단위 테스트의 유지보수 비용은 덩달아 증가한다.
```
* 코드의 중복은 가장 큰 설계의 문제에 해당하며, 이는 테스트 관점에서도 다음과 같은 문제를 갖는다.
  1. 코드의 중복으로 인해 가독성이 떨어지므로 테스트를 따르기 어려워진다.
     * 여러 줄로 테스트를 준비하는 것보다, 이를 단일 메소드로 추출하여 적절히 명명하는 것이 코드를 읽는 개발자의 입장에서 훨씬 직관적이다.
  2. 중복된 작은 코드들을 단일 메소드로 추출하면 변경으로 인한 영향을 최소화할 수 있다.
     * 여러 장소에 흩어진 작은 코드 조각을 하나의 메소드로 모으는 것이 수정에 있어 훨씬 편리하다.
* **단위 테스트를 준비하기 위해 코드가 수십 줄 필요한 경우, 이는 시스템의 설계에 문제가 있다는 신호**이다. 
  * 단일 책임 원칙을 위반하면 클래스는 점점 커지고, 다른 클래스에 대한 의존성이 커지므로 테스트 설정에 더욱 많은 노력이 요구된다.
  * 따라서, 이러한 클래스는 반드시 분할되어야 한다.
* **private 메소드와 같은 구현 세부 사항을 테스트하려는 충동이 드는 것 역시 클래스가 필요 이상으로 커졌다는 또 다른 신호**이다.
  * **private 메소드가 자꾸 늘어만 가는 클래스 역시 분할하여 새로운 클래스의 public 메소드로 옮기는 것이 바람직**하다.
* **단위 테스트가 너무 어렵게 보이는 현상 역시 설계를 개선해야 함을 의미하는 좋은 신호이며, 설계를 개선하여 단위 테스트를 더 쉽게 만들어야 한다**.
* **상술한 과정을 통해 단위 테스트를 유지하는 비용은 완전히 제거할 수는 않지만, 충분히 받아들일 수 있을 정도로 줄일 수 있다**.

### 결론
```
> 언제나 시스템 설게에 대한 비판적인 관점을 유지하고, 최상의 설계는 없다는 사실을 명심해야 한다.
> 즉, 시스템을 깨끗하게 하는 책임에는 결코 끝이 있을 수가 없다.
```
* **설계를 지속적으로 개선해 나갈 수 있는 자신감을 위해 단위 테스트의 커버리지를 높여야 한다**.
* 설계에 관한 원칙들은 가능한 한 많이 알아두어야 한다.
  * 설계와 관련된 지식들로 무장한 경우, 단위 테스트를 통해 불가피하게 다가올 변경 사항에 능동적으로 대응할 수 있도록 코드를 다듬어갈 수 있게 된다.
* **새로운 작은 클래스와 메소드들을 만드는 데에 반발감이 없어야 하며, 이는 유연한 설계로 이어지는 지름길**이다.
  * 유연한 설계는 더 작고 잘 조직된 구성 요소들로부터 시작된다.
# Spring Advanced
## 2024-09-04 Wed
### ThreadLocal이란?
```
> 쓰레드로컬이란, 임의의 쓰레드에서만 접근할 수 있는 특별한 저장소를 의미한다.
```
* 일반적인 경우, 여러 쓰레드가 동일한 인스턴스의 필드에 동시에 접근하여 변경하는 시나리오에서는 동시성 문제가 발생하기 쉽다.
  * 즉, 임의의 쓰레드가 보관한 데이터가 변경되거나 유실되기 쉽다.
* 반면, **쓰레드로컬을 사용할 경우 각각의 쓰레드마다 내부적으로 별도의 저장소를 제공받게 되므로 필요한 데이터를 전용 저장소에 저장**할 수 있다.
  * Java는 언어 차원에서 쓰레드로컬을 지원하기 위해 `java.lang.ThreadLocal` 클래스를 제공한다.

## 2024-09-05 Thu
### ThreadLocal 활용하기
```
> 스프링 웹 MVC는 요청당 하나의 스레드를 사용하고, 다음 요청에 대해 동일한 스레드가 사용될 수 있으므로 요청 처리 후 반드시 remove()를 호출해주어야 한다.
```
* 쓰레드로컬은 크게 다음과 같은 메소드를 제공한다.
  * `set(xxx)`: 쓰레드로컬에 데이터를 저장한다.
  * `get()`: 쓰레드로컬에 저장된 데이터를 조회한다.
  * `remove()`: 쓰레드로컬에 저장된 데이터를 제거한다.
* 이 때, **해당 쓰레드가 쓰레드로컬에 데이터를 저장하고 조회하는 로직이 모두 완료되었다면 반드시 `remove()` 메소드를 호출해줄 필요**가 있다.
  * 이를 통해 쓰레드로컬에 저장된 값을 제거하여 메모리 누수를 방지하고, 나아가 다음 동작에 영향을 주지 않을 수 있다.

## 2024-09-06 Fri
### 템플릿 메소드 패턴이란?
* 일반적인 애플리케이션의 경우, 임의의 기능은 핵심 기능과 부가 기능으로 구분될 수 있다.
  * 핵심 기능이란, 임의의 객체가 제공하는 고유의 기능을 지칭한다.
  * 반면, 부가 기능이란 로그 추적이나 트랜잭션 처리 등 단독으로 사용되지 않고 단지 핵심 기능을 보조하는 부연적인 기능을 의미한다.
* **애플리케이션 개발에 있어 더 중요한 것은 분명 핵심 기능이나, 이를 보조하기 위한 부가 기능을 완전히 배제하는 것은 사실상 불가능**하다.
* 결국 부가 기능은 개발 단계에서 더 효율적으로 사용할 수 있도록 설계되어야 하며, 대부분의 부가 기능은 일종의 보일러 플레이트 형태를 띄는 경우가 많다.
  * 이는 곧 **중복 코드를 효율적으로 제거할 수 있는 방법을 적용해야함을 의미하며, 디자인 패턴은 이러한 경우에 큰 도윰**이 될 수 있다.
* 반면, 좋은 애플리케이션 설계는 변할 수 있는 부분과 변하지 않는 부분을 잘 분리한 것이며 이 경우 부가 기능은 변하지 않는 부분에 해당한다.
* **템플릿 메소드 패턴은 이러한 경우에 적용할 수 있으며, 변하는 부분과 변하지 않는 부분을 각각 분리하여 성공적으로 모듈화할 수 있도록 지원**한다.

## 2024-09-07 Sat
### 좋은 설계란?
```
> 좋은 설계에는 다양한 정의가 있을 수 있으나, '정말로' 좋은 설계는 기능을 변경하는 과정에서 자연스럽게 드러난다.
```
* 부가 기능과 관련된 로직의 변경으로 인해 핵심 기능에도 영향을 주게 되는 코드는 좋은 설계가 적용되었다고 볼 수 없다.
* 반면, 템플릿 메소드 패턴 등의 디자인 패턴을 적용하여 변경 지점을 하나로 모아 변경에 쉽게 대처할 수 있는 구조를 설계하는 것은 좋은 설계로 이해할 수 있다.
  * 이렇듯 **변경 지점을 하나의 클래스로 모아 변경에 쉽게 대응할 수 있는 구조를 적용하는 것은 SRP와 관련**이 있다.

## 2024-09-08 Sun
### 템플릿 메소드 패턴의 장단점
* GOF의 경우, 템플릿 메소드 패턴은 `작업의 형태를 정의하고 일부 단계를 하위 클래스가 결정할 수 있도록 연기하는 것`으로 정의된다.
  * 즉, **템플릿을 상속하는 하위 클래스는 전체적인 알고리즘의 구조를 변경하지 않으면서도 알고리즘의 하위 단계를 재정의**할 수 있게 된다.
* 그러나 **템플릿 메소드 패턴은 상속 자체가 가질 수 있는 잠정적인 문제들을 고스란히 갖는 단점 역시 수반**된다.
  * 예를 들어, 상속은 부모 클래스와 하위 클래스 간의 컴파일 시점의 강하게 결합되는 문제를 갖는다.
  * 다시 말해 **템플릿의 특정 단계를 구현하는 하위 클래스는 부모 클래스의 기능을 전혀 사용하지 않음에도 상속을 기반으로 부모와 강하게 결합**된다.
* 결국 템플릿 메소드 패턴을 적용할 경우 변경 지점을 모아 변경에 쉽게 대처할 수 있으나, 반대로 하위 클래스는 모두 이러한 변경의 영향을 강하게 받게 된다.

## 2024-09-09 Mon
### 템플릿이 갖는 의미
* 템플릿 메소드 패턴의 핵심은 변하는 부분과 변하지 않는 부분을 분리하는 데에 있으며, 이 때 변하지 않는 부분을 템플릿이라는 용어로 표현할 수 있다.
* 목적 달성을 위해서는 템플릿을 정의하고, 템플릿에 변하는 부분을 표현하는 `작은 코드 조각`을 전달하여 실행하는 것이 이상적이다.

### 전략 패턴이란?
```
> 템플릿 메소드 패턴은 변하지 않는 로직을 포함하는 하나의 부모를 두고 변하는 부분을 자식 클래스에 두는 상속을 활용한다.
> 반면, 전략 패턴은 변하는 부분을 하나의 인터페이스로 표현하는 것으로 상속이 아닌 위임을 활용하도록 유도한다.   
```
* 전략 패턴은 변하지 않는 로직을 표현하는 일종의 템플릿인 `Context`와 변하는 부분을 표현하는 `Strategy` 인터페이스로 구성된다.
  * 즉, **알고리즘 군을 각각 정의하여 캡슐화하고 각 알고리즘을 상호교환 가능하도록 구현하여 클라이언트와 독립적으로 알고리즘을 변경**할 수 있도록 한다.
* `Context`는 템플릿 역할을 하는 구현체이며 변하는 부분을 캡슐화한 `Strategy`를 참조하므로, 템플릿 메소드 패턴과 비교하여 다음과 같은 이점을 갖는다.
  1. 변동 가능한 부분인 `Strategy`는 더 이상 변하지 않는 부분인 `Context`에 의존하지 않는다.
  2. 변하지 않는 부분인 `Context`가 수정되더라도 변동 가능한 부분인 `Strategy`는 영향 받지 않는다.
* 이러한 **전략 패턴은 스프링 프레임워크 차원에서도 적극적으로 채택하는 디자인 패턴으로, 예를 들어 의존 관계 주입은 대표적인 전략 패턴에 해당**한다.
* 반면, 런타임 차원에서 전략을 수정할 수 있도록 하는 등 좀 더 유연한 구현을 원한다면 전략 참조가 아닌 메소드 파라미터로 전달 받는 방법을 고려해볼 수 있다.
  * 전자의 경우 구현이 쉬우나 유연하지 못하다면, 후자의 경우 반대로 구현은 번거로우나 유연하다는 특징을 갖게 된다.

## 2024-09-10 Tue
### 디자인 패턴 주의사항
* 프로그래밍 초심자는 디자인 패턴을 공부할 경우, 디자인 패턴을 표현한 다이어그램에 매몰되어 다이어그램이 곧 디자인 패턴이라는 식의 표현에 매몰되기 쉽다.
  * 그러나 디자인 패턴 간에는 유사점이 많아 다이어그램 위주의 학습은 역효과를 내기 쉽다.
* 오히려 **가장 중요한 것은 각 패턴이 갖는 의도이며, 각각의 디자인 패턴이 어떠한 의도 하에 고안되었는지 이해하는 것이 가장 중요**하다.
* 다시 말해 **디자인 패턴은 다이어그램을 정확히 모방하는 단 하나의 구현 방식만을 갖는 것이 아니며, 핵심은 각 패턴의 의도를 따르는 것**에 있다.

## 2024-09-11 Wed
### 템플릿 콜백 패턴이란?
```
> 콜백 또는 콜애프터 함수란 다른 코드의 인자로 전달할 수 있는 실행 가능한 코드를 의미하며, 의도에 따라 즉시 실행되거나 지연 실행될 수 있다.
```
* 상술한 전략 패턴은 변하지 않는 코드를 템플릿하고 변동 가능성이 있는 코드를 별도의 전략 클래스로 분리하여 참조하거나 인자로 전달할 수 있도록 한다.
  * 이 때, **인자로 전달할 수 있는 실행 가능한 코드는 콜백이라고 지칭**할 수도 있다.
* Java 8 이전의 경우 이러한 콜백은 별도의 객체를 활용하여 인자로 전달하게 되며, Java 8 버전부터는 람다식을 지원한다.
  * 때문에 Java 8을 기준으로 이전의 애플리케이션은 단일 메소드를 갖는 인터페이스를 구현하는 익명 내부 클래스를 사용하고, 최근에는 람다식을 활용한다.
* 상술한 **전략 패턴 중 메소드 인자로 전략을 전달하는 방식을 템플릿 콜백 패턴으로도 지칭**할 수 있으며, 엄밀히 말해 해당 패턴은 GOF에 속하지 않는다.
* 스프링에서는 `xxxTemplate` 형태의 다양한 템플릿 콜백 패턴이 사용되며, 예를 들어 `TransactionTemplate`이 있다.

## 2024-09-12 Thu
### 애플리케이션의 수정과 프록시 패턴의 시작
* 애플리케이션을 처음부터 설계하는 입장이라면 상술한 디자인 패턴들을 활용하여 변경 가능성을 격리하는 것이 추후 다가올 수정에 있어 큰 도움이 될 수 있다.
* 그러나 이미 만들어진 애플리케이션에 대해 새로운 기능을 추가하기 위해 상술한 디자인 패턴을 적용하는 경우라면 다른 전략 패턴을 고려하는 것이 좋을 수 있다.
  * 기존 코드의 수정을 줄이는 위해 패턴을 적용한다는 이유를 대기엔 단지 양의 차이만 있을 뿐이며, 기존 코드를 모두 수정한다는 점에서는 차이가 없을 수 있다.
* 이러한 경우, 원본 코드를 손대지 않고 부가 기능을 적용하기 위해서는 프록시 패턴 등 다른 디자인 패턴들을 고려하는 것이 바람직하다.
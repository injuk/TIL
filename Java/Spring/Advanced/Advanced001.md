# Spring Advanced
## 2024-09-04 Wed
### ThreadLocal이란?
```
> 쓰레드로컬이란, 임의의 쓰레드에서만 접근할 수 있는 특별한 저장소를 의미한다.
```
* 일반적인 경우, 여러 쓰레드가 동일한 인스턴스의 필드에 동시에 접근하여 변경하는 시나리오에서는 동시성 문제가 발생하기 쉽다.
  * 즉, 임의의 쓰레드가 보관한 데이터가 변경되거나 유실되기 쉽다.
* 반면, **쓰레드로컬을 사용할 경우 각각의 쓰레드마다 내부적으로 별도의 저장소를 제공받게 되므로 필요한 데이터를 전용 저장소에 저장**할 수 있다.
  * Java는 언어 차원에서 쓰레드로컬을 지원하기 위해 `java.lang.ThreadLocal` 클래스를 제공한다.

## 2024-09-05 Thu
### ThreadLocal 활용하기
```
> 스프링 웹 MVC는 요청당 하나의 스레드를 사용하고, 다음 요청에 대해 동일한 스레드가 사용될 수 있으므로 요청 처리 후 반드시 remove()를 호출해주어야 한다.
```
* 쓰레드로컬은 크게 다음과 같은 메소드를 제공한다.
  * `set(xxx)`: 쓰레드로컬에 데이터를 저장한다.
  * `get()`: 쓰레드로컬에 저장된 데이터를 조회한다.
  * `remove()`: 쓰레드로컬에 저장된 데이터를 제거한다.
* 이 때, **해당 쓰레드가 쓰레드로컬에 데이터를 저장하고 조회하는 로직이 모두 완료되었다면 반드시 `remove()` 메소드를 호출해줄 필요**가 있다.
  * 이를 통해 쓰레드로컬에 저장된 값을 제거하여 메모리 누수를 방지하고, 나아가 다음 동작에 영향을 주지 않을 수 있다.

## 2024-09-06 Fri
### 템플릿 메소드 패턴이란?
* 일반적인 애플리케이션의 경우, 임의의 기능은 핵심 기능과 부가 기능으로 구분될 수 있다.
  * 핵심 기능이란, 임의의 객체가 제공하는 고유의 기능을 지칭한다.
  * 반면, 부가 기능이란 로그 추적이나 트랜잭션 처리 등 단독으로 사용되지 않고 단지 핵심 기능을 보조하는 부연적인 기능을 의미한다.
* **애플리케이션 개발에 있어 더 중요한 것은 분명 핵심 기능이나, 이를 보조하기 위한 부가 기능을 완전히 배제하는 것은 사실상 불가능**하다.
* 결국 부가 기능은 개발 단계에서 더 효율적으로 사용할 수 있도록 설계되어야 하며, 대부분의 부가 기능은 일종의 보일러 플레이트 형태를 띄는 경우가 많다.
  * 이는 곧 **중복 코드를 효율적으로 제거할 수 있는 방법을 적용해야함을 의미하며, 디자인 패턴은 이러한 경우에 큰 도윰**이 될 수 있다.
* 반면, 좋은 애플리케이션 설계는 변할 수 있는 부분과 변하지 않는 부분을 잘 분리한 것이며 이 경우 부가 기능은 변하지 않는 부분에 해당한다.
* **템플릿 메소드 패턴은 이러한 경우에 적용할 수 있으며, 변하는 부분과 변하지 않는 부분을 각각 분리하여 성공적으로 모듈화할 수 있도록 지원**한다.

## 2024-09-07 Sat
### 좋은 설계란?
```
> 좋은 설계에는 다양한 정의가 있을 수 있으나, '정말로' 좋은 설계는 기능을 변경하는 과정에서 자연스럽게 드러난다.
```
* 부가 기능과 관련된 로직의 변경으로 인해 핵심 기능에도 영향을 주게 되는 코드는 좋은 설계가 적용되었다고 볼 수 없다.
* 반면, 템플릿 메소드 패턴 등의 디자인 패턴을 적용하여 변경 지점을 하나로 모아 변경에 쉽게 대처할 수 있는 구조를 설계하는 것은 좋은 설계로 이해할 수 있다.
  * 이렇듯 **변경 지점을 하나의 클래스로 모아 변경에 쉽게 대응할 수 있는 구조를 적용하는 것은 SRP와 관련**이 있다.

## 2024-09-08 Sun
### 템플릿 메소드 패턴의 장단점
* GOF의 경우, 템플릿 메소드 패턴은 `작업의 형태를 정의하고 일부 단계를 하위 클래스가 결정할 수 있도록 연기하는 것`으로 정의된다.
  * 즉, **템플릿을 상속하는 하위 클래스는 전체적인 알고리즘의 구조를 변경하지 않으면서도 알고리즘의 하위 단계를 재정의**할 수 있게 된다.
* 그러나 **템플릿 메소드 패턴은 상속 자체가 가질 수 있는 잠정적인 문제들을 고스란히 갖는 단점 역시 수반**된다.
  * 예를 들어, 상속은 부모 클래스와 하위 클래스 간의 컴파일 시점의 강하게 결합되는 문제를 갖는다.
  * 다시 말해 **템플릿의 특정 단계를 구현하는 하위 클래스는 부모 클래스의 기능을 전혀 사용하지 않음에도 상속을 기반으로 부모와 강하게 결합**된다.
* 결국 템플릿 메소드 패턴을 적용할 경우 변경 지점을 모아 변경에 쉽게 대처할 수 있으나, 반대로 하위 클래스는 모두 이러한 변경의 영향을 강하게 받게 된다.

## 2024-09-09 Mon
### 템플릿이 갖는 의미
* 템플릿 메소드 패턴의 핵심은 변하는 부분과 변하지 않는 부분을 분리하는 데에 있으며, 이 때 변하지 않는 부분을 템플릿이라는 용어로 표현할 수 있다.
* 목적 달성을 위해서는 템플릿을 정의하고, 템플릿에 변하는 부분을 표현하는 `작은 코드 조각`을 전달하여 실행하는 것이 이상적이다.

### 전략 패턴이란?
```
> 템플릿 메소드 패턴은 변하지 않는 로직을 포함하는 하나의 부모를 두고 변하는 부분을 자식 클래스에 두는 상속을 활용한다.
> 반면, 전략 패턴은 변하는 부분을 하나의 인터페이스로 표현하는 것으로 상속이 아닌 위임을 활용하도록 유도한다.   
```
* 전략 패턴은 변하지 않는 로직을 표현하는 일종의 템플릿인 `Context`와 변하는 부분을 표현하는 `Strategy` 인터페이스로 구성된다.
  * 즉, **알고리즘 군을 각각 정의하여 캡슐화하고 각 알고리즘을 상호교환 가능하도록 구현하여 클라이언트와 독립적으로 알고리즘을 변경**할 수 있도록 한다.
* `Context`는 템플릿 역할을 하는 구현체이며 변하는 부분을 캡슐화한 `Strategy`를 참조하므로, 템플릿 메소드 패턴과 비교하여 다음과 같은 이점을 갖는다.
  1. 변동 가능한 부분인 `Strategy`는 더 이상 변하지 않는 부분인 `Context`에 의존하지 않는다.
  2. 변하지 않는 부분인 `Context`가 수정되더라도 변동 가능한 부분인 `Strategy`는 영향 받지 않는다.
* 이러한 **전략 패턴은 스프링 프레임워크 차원에서도 적극적으로 채택하는 디자인 패턴으로, 예를 들어 의존 관계 주입은 대표적인 전략 패턴에 해당**한다.
* 반면, 런타임 차원에서 전략을 수정할 수 있도록 하는 등 좀 더 유연한 구현을 원한다면 전략 참조가 아닌 메소드 파라미터로 전달 받는 방법을 고려해볼 수 있다.
  * 전자의 경우 구현이 쉬우나 유연하지 못하다면, 후자의 경우 반대로 구현은 번거로우나 유연하다는 특징을 갖게 된다.

## 2024-09-10 Tue
### 디자인 패턴 주의사항
* 프로그래밍 초심자는 디자인 패턴을 공부할 경우, 디자인 패턴을 표현한 다이어그램에 매몰되어 다이어그램이 곧 디자인 패턴이라는 식의 표현에 매몰되기 쉽다.
  * 그러나 디자인 패턴 간에는 유사점이 많아 다이어그램 위주의 학습은 역효과를 내기 쉽다.
* 오히려 **가장 중요한 것은 각 패턴이 갖는 의도이며, 각각의 디자인 패턴이 어떠한 의도 하에 고안되었는지 이해하는 것이 가장 중요**하다.
* 다시 말해 **디자인 패턴은 다이어그램을 정확히 모방하는 단 하나의 구현 방식만을 갖는 것이 아니며, 핵심은 각 패턴의 의도를 따르는 것**에 있다.

## 2024-09-11 Wed
### 템플릿 콜백 패턴이란?
```
> 콜백 또는 콜애프터 함수란 다른 코드의 인자로 전달할 수 있는 실행 가능한 코드를 의미하며, 의도에 따라 즉시 실행되거나 지연 실행될 수 있다.
```
* 상술한 전략 패턴은 변하지 않는 코드를 템플릿하고 변동 가능성이 있는 코드를 별도의 전략 클래스로 분리하여 참조하거나 인자로 전달할 수 있도록 한다.
  * 이 때, **인자로 전달할 수 있는 실행 가능한 코드는 콜백이라고 지칭**할 수도 있다.
* Java 8 이전의 경우 이러한 콜백은 별도의 객체를 활용하여 인자로 전달하게 되며, Java 8 버전부터는 람다식을 지원한다.
  * 때문에 Java 8을 기준으로 이전의 애플리케이션은 단일 메소드를 갖는 인터페이스를 구현하는 익명 내부 클래스를 사용하고, 최근에는 람다식을 활용한다.
* 상술한 **전략 패턴 중 메소드 인자로 전략을 전달하는 방식을 템플릿 콜백 패턴으로도 지칭**할 수 있으며, 엄밀히 말해 해당 패턴은 GOF에 속하지 않는다.
* 스프링에서는 `xxxTemplate` 형태의 다양한 템플릿 콜백 패턴이 사용되며, 예를 들어 `TransactionTemplate`이 있다.

## 2024-09-12 Thu
### 애플리케이션의 수정과 프록시 패턴의 시작
* 애플리케이션을 처음부터 설계하는 입장이라면 상술한 디자인 패턴들을 활용하여 변경 가능성을 격리하는 것이 추후 다가올 수정에 있어 큰 도움이 될 수 있다.
* 그러나 이미 만들어진 애플리케이션에 대해 새로운 기능을 추가하기 위해 상술한 디자인 패턴을 적용하는 경우라면 다른 전략 패턴을 고려하는 것이 좋을 수 있다.
  * 기존 코드의 수정을 줄이는 위해 패턴을 적용한다는 이유를 대기엔 단지 양의 차이만 있을 뿐이며, 기존 코드를 모두 수정한다는 점에서는 차이가 없을 수 있다.
* 이러한 경우, 원본 코드를 손대지 않고 부가 기능을 적용하기 위해서는 프록시 패턴 등 다른 디자인 패턴들을 고려하는 것이 바람직하다.

## 2024-09-13 Fri
### 참고 - 스프링 컨트롤러
* 스프링 부트 3.0 이전 버전의 경우, 웹 MVC는 다음과 같은 어노테이션이 있는 경우에 스프링 컨트롤러를 인식할 수 있다.
  1. `@Controller`
  2. `@RequestMapping`
* 상술한 **두 어노테이션 중 하나를 적용한 컨트롤러는 스프링 차원에서 인식되며, 인식된 후에는 HTTP URL이 매핑되어 동작**하게 된다.
  * 이 때, 이러한 **어노테이션은 인터페이스에 적용할 수도 있다**.
  * 반면, 스프링 부트 3.0 이후 버전의 경우 오직 `@Controller`만을 컨트롤러로 인식한다는 점에 주의를 기울여야 한다.
* 또한 **`@ResponseBody` 어노테이션은 HTTP 메시지 컨버터를 활용하여 응답하는 방식으로 동작하며, 이 역시 인터페이스에 적용 가능**하다.

## 2024-09-14 Sat
### @Import와 @SpringBootApplication의 scanBasePackages 설정
* `@Import([클래스명])`과 같이 할당할 경우, `클래스명`에 명시된 클래스는 빈에 등록된다.
  * 이러한 방식은 일반적으로 `@Configuration`과 같은 설정 파일을 등록할 때 사용하지만, 필요에 따라서는 별도의 스프링 빈을 등록할 수도 있다.
* **`@ComponentScan` 어노테이션이 할당된 경우, 해당 어노테이션이 할당된 패키지와 그 하위 패키지에 있는 모든 빈을 자동으로 등록**한다.
  * 이는 `@SpringBootApplication`에 포함되어 있으므로, 별도의 설정이 없었다면 메인 애플리케이션이 위치한 패키지를 기준으로 스캔을 진행한다.
  * 반면, **`@SpringBootApplication(scanBasePackages="[패키지]")`와 같이 명시할 경우 해당 패키지와 그 하위 패키지만을 스캔 대상**으로 한다.
* **상술한 두 방식을 활용할 경우, 빈 등록 범위를 개발자가 필요에 따라 직접 조절하는 것이 가능**하다.

## 2024-09-15 Sun
### 프록시란?
```
> 프록시라는 개념은 클라이언트와 서버 사이의 관계에서 자연스레 발생하며, 규모에 따라 객체이거나 웹 서버인 등 천차만별이지만 그 본질은 같다.
```
* 웹 개발 분야의 경우, 클라이언트와 서버는 일반적으로 요청자와 웹 서버를 가리킨다.
  * 그러나 실제로는 광범위하게 사용될 수 있는 용어이며, 단지 서버에게 필요한 것을 요청하는 클라이언트와 요청 받은 내용을 처리하여 반환하는 서버로 분류된다.
  * 대표적인 예시로 웹 브라우저와 웹 서버의 관계를 들 수 있으며, 코드 단으로 의미를 확장할 경우 API를 호출하는 클라이언트와 결과를 반환하는 서버가 있다.
* 일반적으로 클라이언트와 서버의 관게에서는 두 객체가 호출과 응답을 기반으로 직접적으로 상호작용하나, 특정한 경우에는 중간에 대리자를 두어 소통할 수 있다.
  * 즉, 클라이언트는 서버에게 요청하여 결과를 반환받았다고 생각하지만 실제로는 대리자가 요청을 가로채어 동작했을 수 있다.
  * 이 때, 이렇듯 **클라이언트와 서버 사이에 위치하여 요청을 대신 처리하는 대리자를 프록시로 지칭**한다.

## 2024-09-16 Mon
### 프록시의 이점
* 프록시 객체는 단순히 요청을 가로채어 응답하는 불필요한 단계가 아니며, 구현에 따라 다음과 같은 이점을 제공할 수 있다.
  1. 접근 제어: 프록시는 클라이언트로부터 서버로 향하는 호출을 중간 위치에서 제어할 수 있다.
  2. 캐싱: **NIO 등의 이유에서 서버와의 통신이 부담되는 경우, 프록시는 최초 요청 이후의 호출에 대해 캐싱을 결정**할 수 있다.
  3. 지연 로딩: 서버 객체가 자주 호출되지 않으면서도 생성이 부담되는 경우, 프록시를 기반으로 지연 로딩을 적용할 수 있다.
  4. 부가 기능 제공: 클라이언트의 호출에 대해 서버가 응답한 결과에 여러 부가 기능을 제공할 수 있다.
* 또한, 프록시는 또 다른 대리자를 호출하는 식으로 동작하는 프록시 체인을 형성할 수도 있다.

## 2024-09-17 Tue
### 클라이언트와 프록시의 관계
* 이 때, **클라이언트는 프록시의 존재를 인식할 수 없으며 자신의 호출에 대해 서버가 응답했는지 또는 프록시가 응답했는지 여부를 알 수 없어야** 한다.
  * 이는 **서버와 프록시가 같은 인터페이스를 구현함을 의미하며, DI에 의해 런타임에서 두 객체가 교체되더라도 클라이언트에는 변경이 없어야 함을 의미**한다.
  * 엄밀히 말해, 클라이언트 입장에서는 자신의 호출에 응답하는 객체가 교체되었는지 사실조차 알 수 없어야 한다.

## 2024-09-18 Wed
### 프록시 패턴과 데코레이터 패턴
```
> 프록시가 대리자 역할을 하는 모든 객체를 지칭한다면, 프록시 패턴은 프록시 형태로 접근 제어를 제공하는 패턴을 의미하므로 두 개념은 동일한 것이 아니다.
> 프록시를 도입한 경우, 접근 제어에 의도를 둔다면 프록시 패턴이지만 부가 기능에 초점을 맞추었다면 데코레이터 패턴에 해당한다. 
```
* 프록시 패턴과 데코레이터 패턴은 모두 프록시 형태를 띄지만, GOF에서는 각 패턴의 의도에 따라 두 패턴을 다음과 같이 분류한다.
  1. 프록시 패턴: **캐싱이나 권한 제어 등의 이유를 위해 클라이언트에서 서버로 향하는 접근을 제어하는 데에 목적**을 둔다.
  2. 데코레이터 패턴: **클라이언트로부터 서버로 향하는 접근에 대해 데이터 조작 또는 로깅 등의 부가 기능을 동적으로 제공하는 데에 목적**을 둔다.
* 이렇듯 **두 패턴은 유사한 구현을 갖지만 의도에서 큰 차이를 보이며, 이는 프록시 패턴이 유일하게 프록시를 사용하는 것은 아니라는 것을 의미**한다.
  * 즉, **두 패턴은 모양이 유사하거나 때로는 같아지기까지 하지만 모양보다는 프록시를 적용한 의도에 따라 명확히 구분될 수 있다는 점을 기억**해야 한다.

## 2024-09-19 Thu
### 데코레이터 패턴에 추상 클래스 도입하기
* 데코레이터 패턴은 동일한 `Component`를 구현하더라도 독자적으로 존재할 수 있는 클래스와 단지 부가 기능만을 제공하는 클래스로 구분될 수 있다.
  * 후자의 경우, 독자적으로 존재할 수 없으므로 항상 생성자에 독자적으로 존재할 수 있는 클래스를 전달 받아 참조에 저장하는 코드가 중복된다.
* 때문에 **단지 부가 기능만을 제공하는 것은 `Component`를 확장하는 추상 클래스를 정의하고 이를 구현하는 방식으로 개발을 진행**해볼 수 있다.
  * 이 경우, **클래스 다이어그램 상에서도 독자적인 기능을 제공하는 클래스와 부가 기능을 제공하는 데코레이터 클래스가 명확히 구분되는 장점**이 있다.

## 2024-09-20 Fri
### 구체 클래스 기반의 프록시 적용
* GOF의 프록시 패턴의 경우 프록시와 서버가 같은 인터페이스를 사용하도록 구현되므로, 일견 구체 클래스에는 프록시 패턴을 적용할 수 없을 것처럼 보일 수 있다.
  * 또는 구체 클래스에 프록시를 적용하기 위해 별도의 인터페이스를 반드시 정의해내어야할 것처럼 보일 수 있다.
* 그러나 실제로는 **Java와 같은 객체지향 언어의 경우 인터페이스를 활용한 확장 관계와 상속을 활용한 관계 모두 다형성을 적용**할 수 있다.
  * 다시 말해 Java의 경우 다형성은 인터페이스와 구체 클래스를 구분하지 않고 활용하는 것이 가능하다.
  * 즉, 구체 클래스의 경우 기존 서버 클래스를 상속하는 프록시 클래스를 정의하는 것으로 프록시 패턴을 도입할 수 있다.
* 그러나 구체 클래스 기반의 프록시의 경우, 부모 생성자를 반드시 호출해주어야 하는 Java의 특성 상 언뜻 의미 없어보이는 코드가 추가될 수 있다는 단점이 있다.
* 결국 중요한 것은 실무에서 프록시 패턴을 적용하는 과정에서 인터페이스와 구현체에 대한 적용 두 가지 상황 모두에 대해 고려하는 것이 바람직하다는 점이다.

## 2024-09-21 Sat
### 인터페이스 기반의 프록시와 구체 클래스 기반의 프록시 비교하기
* 인터페이스 기반의 프록시는 역할과 구현을 명확히 분리한다는 점에서 큰 장점이 있지만 인터페이스 그 자체가 필요하다는 단점이 있다.
* 반면, 구체 클래스 기반의 프록시는 인터페이스가 없더라도 어떠한 클래스에 대해서든 프록시를 적용할 수 있다는 이점이 있다.
  * 그러나 구체 클래스 기반의 프록시는 해당 클래스에 종속되는 반면, 인터페이스 기반의 프록시는 동일한 인터페이스를 적용하는 모든 클래스에 대해 정의할 수 있다.
* 또한, 구체 클래스 기반의 프록시는 상속을 사용함에 따라 다음과 같은 단점을 갖는다.
  1. 부모 클래스의 생성자 호출이 반드시 필요하다.
  2. 클래스 자체에 `final` 키워드가 명시된 경우에는 프록시 패턴을 적용할 수 없다.
  3. 메소드 자체에 `final` 키워드가 명시된 경우에는 해당 메소드를 재정의할 수 없다.
* 일반적으로 상속이라는 제약으로부터 자유로운 인터페이스 기반의 프록시 패턴이 더 좋다고 볼 수 있다.
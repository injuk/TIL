# Spring Advanced
## 2024-09-04 Wed
### ThreadLocal이란?
```
> 쓰레드로컬이란, 임의의 쓰레드에서만 접근할 수 있는 특별한 저장소를 의미한다.
```
* 일반적인 경우, 여러 쓰레드가 동일한 인스턴스의 필드에 동시에 접근하여 변경하는 시나리오에서는 동시성 문제가 발생하기 쉽다.
  * 즉, 임의의 쓰레드가 보관한 데이터가 변경되거나 유실되기 쉽다.
* 반면, **쓰레드로컬을 사용할 경우 각각의 쓰레드마다 내부적으로 별도의 저장소를 제공받게 되므로 필요한 데이터를 전용 저장소에 저장**할 수 있다.
  * Java는 언어 차원에서 쓰레드로컬을 지원하기 위해 `java.lang.ThreadLocal` 클래스를 제공한다.

## 2024-09-05 Thu
### ThreadLocal 활용하기
```
> 스프링 웹 MVC는 요청당 하나의 스레드를 사용하고, 다음 요청에 대해 동일한 스레드가 사용될 수 있으므로 요청 처리 후 반드시 remove()를 호출해주어야 한다.
```
* 쓰레드로컬은 크게 다음과 같은 메소드를 제공한다.
  * `set(xxx)`: 쓰레드로컬에 데이터를 저장한다.
  * `get()`: 쓰레드로컬에 저장된 데이터를 조회한다.
  * `remove()`: 쓰레드로컬에 저장된 데이터를 제거한다.
* 이 때, **해당 쓰레드가 쓰레드로컬에 데이터를 저장하고 조회하는 로직이 모두 완료되었다면 반드시 `remove()` 메소드를 호출해줄 필요**가 있다.
  * 이를 통해 쓰레드로컬에 저장된 값을 제거하여 메모리 누수를 방지하고, 나아가 다음 동작에 영향을 주지 않을 수 있다.

## 2024-09-06 Fri
### 템플릿 메소드 패턴이란?
* 일반적인 애플리케이션의 경우, 임의의 기능은 핵심 기능과 부가 기능으로 구분될 수 있다.
  * 핵심 기능이란, 임의의 객체가 제공하는 고유의 기능을 지칭한다.
  * 반면, 부가 기능이란 로그 추적이나 트랜잭션 처리 등 단독으로 사용되지 않고 단지 핵심 기능을 보조하는 부연적인 기능을 의미한다.
* **애플리케이션 개발에 있어 더 중요한 것은 분명 핵심 기능이나, 이를 보조하기 위한 부가 기능을 완전히 배제하는 것은 사실상 불가능**하다.
* 결국 부가 기능은 개발 단계에서 더 효율적으로 사용할 수 있도록 설계되어야 하며, 대부분의 부가 기능은 일종의 보일러 플레이트 형태를 띄는 경우가 많다.
  * 이는 곧 **중복 코드를 효율적으로 제거할 수 있는 방법을 적용해야함을 의미하며, 디자인 패턴은 이러한 경우에 큰 도윰**이 될 수 있다.
* 반면, 좋은 애플리케이션 설계는 변할 수 있는 부분과 변하지 않는 부분을 잘 분리한 것이며 이 경우 부가 기능은 변하지 않는 부분에 해당한다.
* **템플릿 메소드 패턴은 이러한 경우에 적용할 수 있으며, 변하는 부분과 변하지 않는 부분을 각각 분리하여 성공적으로 모듈화할 수 있도록 지원**한다.

## 2024-09-07 Sat
### 좋은 설계란?
```
> 좋은 설계에는 다양한 정의가 있을 수 있으나, '정말로' 좋은 설계는 기능을 변경하는 과정에서 자연스럽게 드러난다.
```
* 부가 기능과 관련된 로직의 변경으로 인해 핵심 기능에도 영향을 주게 되는 코드는 좋은 설계가 적용되었다고 볼 수 없다.
* 반면, 템플릿 메소드 패턴 등의 디자인 패턴을 적용하여 변경 지점을 하나로 모아 변경에 쉽게 대처할 수 있는 구조를 설계하는 것은 좋은 설계로 이해할 수 있다.
  * 이렇듯 **변경 지점을 하나의 클래스로 모아 변경에 쉽게 대응할 수 있는 구조를 적용하는 것은 SRP와 관련**이 있다.

## 2024-09-08 Sun
### 템플릿 메소드 패턴의 장단점
* GOF의 경우, 템플릿 메소드 패턴은 `작업의 형태를 정의하고 일부 단계를 하위 클래스가 결정할 수 있도록 연기하는 것`으로 정의된다.
  * 즉, **템플릿을 상속하는 하위 클래스는 전체적인 알고리즘의 구조를 변경하지 않으면서도 알고리즘의 하위 단계를 재정의**할 수 있게 된다.
* 그러나 **템플릿 메소드 패턴은 상속 자체가 가질 수 있는 잠정적인 문제들을 고스란히 갖는 단점 역시 수반**된다.
  * 예를 들어, 상속은 부모 클래스와 하위 클래스 간의 컴파일 시점의 강하게 결합되는 문제를 갖는다.
  * 다시 말해 **템플릿의 특정 단계를 구현하는 하위 클래스는 부모 클래스의 기능을 전혀 사용하지 않음에도 상속을 기반으로 부모와 강하게 결합**된다.
* 결국 템플릿 메소드 패턴을 적용할 경우 변경 지점을 모아 변경에 쉽게 대처할 수 있으나, 반대로 하위 클래스는 모두 이러한 변경의 영향을 강하게 받게 된다.
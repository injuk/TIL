# Spring Advanced

## 2024-10-31 Thu
### 스프링의 AOP 활용하기
* 스프링의 AOP를 활용하기 위해서는 반드시 `spring-boot-starter-aop` 의존성을 추가해야 한다.
  * 이를 활용하는 것으로 **`aspectjweaver` 와 같은 `aspectJ` 관련 라이브러리에 더해 스프링 부트가 필요한 AOP 관련 클래스를 자동으로 등록**한다.
  * 더 정확히는 `AopAutoConfiguration` 이라는 설정 파일을 통해 어떤 빈들이 등록되는지 쉽게 확인할 수 있다.
* 상술한 **의존성을 추가할 경우 스프링 부트 자동 설정에 의해 `AnnotationAwareAspectAutoProxyCreator`라는 빈 후처리기가 등록**된다.
* 이는 **말 그대로 프록시를 자동 생성해주는 빈 후처리기이며, 해당 후처리기는 스프링 빈으로 등록된 모든 `Advisor`를 필요한 곳에 자동으로 적용**한다.
  * 특히, `Advisor`는 내부적으로 `Pointcut`과 `Advice`를 모두 포함하므로 빈 후처리기는 자동으로 적절한 위치에 필요한 포인트컷을 적용한다.
  * 추가적으로, 해당 빈 후처리기는 `@AspectJ`와 관련된 AOP 기능들도 자동으로 인식하여 프록시를 생성하는 방식으로 AOP를 적용한다.

## 2024-11-01 Fri
### @PostConstruct 어노테이션의 비밀
* `@PostConstruct` 어노테이션은 스프링의 빈 생성 이후 빈을 초기화하는 역할을 담당하며, 이는 쉽게 말해 이미 생성된 빈을 한 번 조작하는 것을 의미한다.
* 이를 위해 단순히 빈을 조작하기 위한 빈 후처리기를 고려할 수 있으며, 스프링은 이러한 역할을 담당하는 빈 후처리기를 내부적으로 등록하는 방식으로 동작한다.
  * 스프링의 `CommonAnnotationBeanPostProcessor` 라는 이름의 빈 후처리기는 `@PostConstruct` 어노테이션이 할당된 메소드를 호출한다.
  * 이렇듯 스프링조차도 스프링이 제공하는 내부적인 기능들을 확장하기 위해 빈 후처리기를 활용한다.

## 2024-11-02 Sat
### 자동 프록시 생성기 동작 과정
* 상술한 의존성을 활용하여 자동 프록시 생성기를 적용할 경우, 프록시 객체는 다음과 같은 과정에 의해 등록된다.
  1. 생성: 스프링은 빈 객체를 생성하며, 이는 `@Bean`과 컴포넌트 스캔 대상 모두를 포함한다.
  2. 전달: 생성된 빈 객체를 빈 저장소에 저장하기 전에 빈 후처리기에 전달한다.
  3. `Advisor` 조회: 빈 후처리기는 스프링 컨테이너로부터 모든 `Advisor`를 조회한다.
  4. 프록시 적용 대상 체크: `Advisor`의 포인트컷 정보를 활용하여 각 객체에 대한 프록시 적용 여부를 판단한다.
  5. 프록시 생성: 프록시 적용 대상인 경우 프록시를 생성하고, 그렇지 않은 경우 원본 객체를 반환한다.
  6. 빈 등록: 반환된 객체를 스프링 빈에 등록한다.
* 특히, **`Advisor`를 활용하여 프록시 대상을 검증하는 과정은 대응되는 모든 포인트컷을 매칭하여 하나라도 만족하는 경우 프록시 적용 대상으로 판정**한다.
  * 예를 들어 10개의 메소드 중 하나만 포인트컷 조건을 만족하더라도 해당 빈 객체는 프록시 적용 대상으로 판정된다.
  * 이러한 과정에서 생성된 프록시는 내부적으로 `Advisor`를 포함하며, 실제 호출될 대상 객체 역시 참조하게 된다.
* 기본적으로 **모든 객체에 프록시를 생성하는 것은 낭비이며, 때문에 반드시 필요한 곳에만 프록시를 적용**해줄 필요가 있다.
  * 때문에 자동 프록시 생성기 역시 모든 스프링 빈에 대해 프록시를 적용하는 대신, 포인트컷을 기반으로 한 번 필터링된 빈 객체에 대해서만 프록시를 생성한다.

## 2024-11-03 Sun
### 포인트컷의 두 가지 용도
* 이 때, **중요한 것은 프록시 생성 단계에서 사용되는 포인트컷과 실제 부가 기능 적용을 위해 사용되는 포인트컷을 구분해야한다는 점**에 있다.
* 예를 들어, 프록시 생성 단계에서 각 빈 객체에게 프록시를 생성할지 결정하기 위해 포인트컷이 사용될 수 있다.
  * 자동 프록시 생성기는 포인트컷 정보를 기반으로 각 빈에 대해 프록시를 생성할지 여부를 검증한다.
  * 이 과정에서 클래스 조건은 물론 메소드 조건까지 검증되며, 모든 메소드를 체크하여 포인트컷이 제시하는 조건 하나 하나에 매칭한다.
  * **조건을 모두 충족시키지 않는 대상에 대해서는 프록시를 생성하지 않으며, 바꿔 말해 조건을 하나라도 충족시킨다면 프록시를 생성**한다.
* 또한, **프록시 객체가 호출되었을 때 프록시가 제공하는 부가 기능인 `Advice`를 적용할지 여부를 검증하기 위해서도 포인트컷을 활용**한다.

## 2024-11-04 Mon
### 보다 정밀한 포인트컷 활용하기
* 단순히 메소드 이름 등을 기준으로 `Advice`를 적용하도록 개발한 경우, 범용적인 용어를 명시했을수록 포인트컷은 많은 대상을 허용하게 된다.
  * 다시 말해, 스프링 내부적으로 사용되는 빈까지도 프록시가 생성되거나 부가 기능의 대상이 될 수 있다.
* 때문에 메소드 뿐만 아니라 패키지 등의 조건을 조합할 수 있는 정밀한 포인트컷이 필요하며, 이를 위한 `AspectExpressionPointcut`을 고려해볼 수 있다.
  * **`AspectExpressionPointcut`은 `AspectJ`라는 AOP에 특화된 포인트컷 표현식을 기반으로 복잡한 포인트컷 적용을 지원**한다.

## 2024-11-05 Tue
### 하나의 프록시로 여러 Advisor 적용하기
* 예를 들어 **임의의 빈 객체가 둘 이상의 `Advisor`가 제공하는 포인트컷의 조건을 모두 만족할 경우, 프록시 자동 생성기는 프록시를 단 하나만 생성**한다.
  * 예를 들어 어드바이저 1의 포인트컷만 만족할 경우, 어드바이저 1만을 포함하는 프록시 하나가 생성된다.
  * 반면, **어드바이저 1과 2의 포인트컷을 모두 만족할 경우 두 어드바이저를 모두 포함하는 프록시 하나가 생성**된다.
  * 덧붙여, 모든 포인트컷을 만족하지 않는 빈 객체의 경우 프록시가 생성되지 않는다.
  * 이는 프록시 팩토리에 의해 생성되는 프록시가 내부적으로 여러 `Advisor`를 포함할 수 있기 때문으로, 이로 인해 생성 비용 낭비를 지양할 수 있다.
* **이러한 방식은 후술할 스프링 AOP와 동일하며, 스프링 AOP 역시 여러 개 적용되더라도 여러 프록시가 생성되지 않는 다는 점에 주목**해야 한다.

## 2024-11-06 Wed
### @Aspect 프록시
* **자동 프록시 생성기인 `AnnotationAwareAspectJAutoProxyCreator`로 인해 단지 `Advisor`만을 빈에 등록하는 것으로 프록시 적용이 가능**하다.
  * 이 경우, 자동 프록시 생성기는 스프링 빈에 등록된 모든 어드바이저를 찾아 각각의 빈 객체들에 대해 자동으로 프록시를 적용한다.
* 반면, **스프링은 `@Aspect` 어노테이션을 활용하여 포인트컷과 어드바이스를 포함하는 어드바이저를 매우 편리하게 생성할 수 있도록 지원**한다.
* 이러한 `@Aspect` 어노테이션은 AOP를 가능케하는 `AspectJ` 프로젝트의 어노테이션으로, 스프링은 이를 기반으로 프록시를 활용한 AOP를 지원한다.

## 2024-11-07 Thu
### @Aspect 프록시와 관련된 개념들
* `@Aspect` 어노테이션은 어노테이션 기반의 프록시를 적용하는 경우에 사용되는, 기본적인 어노테이션에 해당한다.
* `@Around` 어노테이션은 인자에 `AspectJ` 포인트컷 표현식을 전달하며, 해당 어노테이션이 할당된 메소드는 `Advice`로서 기능한다.
* `ProceedingJoinPoint`는 어드바이스에서 활용되는 `MethodInvocation`과 유사한 개념에 해당한다.
  * 때문에 해당 객체는 내부적으로 실제 호출 대상과 전달될 인자, 호출된 메소드 정보 등을 포함한다.
  * 예를 들어 `joinPoint.proceed()` 메소드는 실제 호출 대상을 호출하는 `methodInvocation.processd()`와 유사하게 동작한다.

## 2024-11-08 Fri
### @Aspect 프록시 II
```
> 자동 프록시 생성기는 @Aspect 어노테이션을 감지하여 Advisor로 저장하고, 이러한 Advisor를 기반으로 프록시를 생성하는 두 가지 역할을 담당한다.
```
* 앞서 다룬 바와 같이, `AnnotationAwareAspectJAutoProxyCreator`는 `Advisor`를 모두 찾아 필요한 곳에 프록시를 생성하여 적용한다.
* 추가적으로, 이러한 **자동 프록시 생성기는 `@Aspect` 어노테이션을 감지하여 이를 `Advisor`로 등록**한다.
  * 즉, 앞서 다룬 기능들에 더해 `@Aspect`가 할당된 클래스를 `Advisor`로 변환하여 저장하는 기능을 함께 담당한다.

## 2024-11-09 Sat
### @Aspect 대상을 어드바이저로 변환하는 과정
* 스프링이 실행된느 경우, 스프링 내부적으로 자동 프록시 생성기를 다음과 같이 호출하여 처리한다.
  1. 스프링 애플리케이션이 로딩되는 시점에 자동 프록시 생성기가 호출된다.
  2. **자동 프록시 생성기는 스프링 컨테이너로부터 `@Aspect` 어노테이션이 할당된 모든 스프링 빈을 조회**한다.
  3. `@Aspect` 어드바이저 빌더를 활용하여 해당 어노테이션 정보를 기반으로 `Advisor`를 생성한다.
  4. 생성된 `@Aspect` 기반 어드바이저를 빌더의 내부에 저장한다.
* 이 때, **3.의 과정에서 생성된 `Advisor`는 내부적으로 `@Around` 어노테이션 정보를 기반으로 하는 포인트컷과 어드바이스를 포함**한다.
  * 예를 들어, `@Around` 어노테이션의 인자로 포인트컷을 생성하며 해당 어노테이션이 할당된 메소드를 어드바이스로 취급한다.

## 2024-11-10 Sun
### @Aspect 어드바이저 빌더란?
* 구현체인 `BeanFactoryAspectAdvisorBuilder` 클래스로, `Advisor`를 생성하고 보관하는 역할을 수행한다.
  * 상술한 바와 같이 이 과정에서는 `@Aspect` 어노테이션의 정보를 기반으로 결정된 포인트컷과 어드바이스가 `Advisor`에 적용된다.
* 이렇게 **생성된 어드바이저는 `@Aspect` 어드바이저 빌더 내부적으로 포함된 저장소에 캐싱**된다.
  * 캐시에 이미 동일한 `Advisor`가 생성되어 있다면 기생성된 `Advisor`가 반환되므로, 추가적인 비용 낭비를 걱정하지 않아도 무방하다.
* 실무적 관점에서 해당 구현체의 동작을 세세하게 알 필요는 없으며, 그저 생성된 `Advisor`가 캐싱된다는 사실 정도만 기억하는 것이 바람직하다.

## 2024-11-11 Mon
### Advisor를 기반으로 프록시를 생성하는 과정
* 상술한 내용을 토대로, 자동 프록시 생성기가 동작하는 전체 과정은 다음과 같음을 예상할 수 있다.
  1. 스프링은 `@Bean`과 컴포넌트 스캔을 기반으로 빈 객체들을 생성한다.
  2. 생성된 빈 객체들을 빈 저장소에 저장하기에 앞서 우선 빈 후처리기에 전달한다.
  3. `Advisor`를 모두 조회한다.
    1. 우선, 스프링 컨테이너로부터 모든 `Advisor` 빈을 조회한다.
    2. 다음으로, `@Aspect` 어드바이저 빌더 내부에 저장된 모든 `Advisor`를 조회한다.
  4. `Advisor` 내부에 포함된 포인트컷을 모두 각 객체의 클래스 및 메소드 정보와 비교하여 프록시 대상인지 아닌지를 검증한다.
  5. 프록시 적용 대상인 경우 프록시를 생성하여 프록시를, 그렇지 않은 경우 원본 객체를 반환한 후 스프링 빈에 등록한다.
  6. 5.의 과정에서 반환된 객체들을 각각 스프링 빈에 등록한다.
* **중요한 것은 `3-1.`의 과정과 `3-2.`의 과정에서 생성된 결과는 모두 `Advisor`로서 활용된다는 점**에 있다.

## 2024-11-12 Tue
### @Aspect 어노테이션의 편리함
* `@Aspect` 어노테이션을 활용하여 프록시를 적용하는 것은 매우 편리하며, 실무에서도 대부분의 경우 이러한 방식이 활용된다.
* 일반적으로 **부가 기능은 특별한 도메인 기능에 의존하는 것이 아닌, 애플리케이션의 이곳저곳에 걸쳐서 적용될 수 있는 관심사**가 된다.
  * **이러한 개념을 횡단 관심사라고 지칭하며, `@Aspect`를 활용하는 프록시의 적용은 여러 곳에 걸쳐진 횡단 관심사 문제를 해결하는 대표적인 방법**이다.

## 2024-11-13 Wed
### 부가 기능과 횡단 관심사
* 앞서 다룬 바와 같이, 애플리케이션의 로직은 크게 핵심 기능과 부가 기능으로 분류할 수 있다.
  * 핵심 기능이란, 임의의 객체가 제공하는 고유의 기능을 의미한다.
  * 반면, 부가 기능이란 핵심 기능을 보조하기 위해 제공하는 기능으로 로그 추적 또는 트랜잭션 등을 예로 들 수 있다.
* **부가 기능은 단독으로 사용되기보다는 핵심 기능과 함께 사용되는 경향이 있으며, 대부분의 경우 말 그대로 핵심 기능을 보조하기 위해 존재**한다.
  * 이로 인해 부가 기능은 핵심 기능을 제공하는 객체 안에 섞이기 쉬우며, 핵심 기능에 부가  합친 하나의 로직 형태로 제공될 수 있다.
* 반면, 여러 **부가 기능들은 일반적으로 단일 핵심 기능만을 위하지 않고 여러 클래스에 걸쳐 사용되는 경향**을 보인다.
  * 이러한 기능을 **횡단 관심사라는 용어로 지칭하며, 동일한 부가 기능은 애플리케이션의 이곳 저곳에서 사용**될 수 있다.

## 2024-11-14 Thu
### 부가 기능과 관련된 문제
* 이렇듯 **부가 기능은 여러 곳에 적용될 가능성이 높으므로, 매번 이러한 코드를 적용하는 것 자체가 큰 일이 되기 쉽다**.
  * 부가 기능을 별도의 유틸리티성 클래스로 작성한다고 해도, 결국에는 해당 클래스를 호출하는 로직이 들어가야한다는 점에서 코드 중복은 제거되지 않는다.
  * 나아가 부가 기능 자체가 예외 처리 흐름을 갖는 등의 구조를 필요로 한다면 로직은 더욱 복잡해진다.
* 애플리케이션 이곳 저곳에 손수 코드를 붙여넣었다고 해도, 요구사항의 변경으로 인해 부가 기능을 수정해야 하는 경우에는 이러한 모든 중복 코드를 수정하게 된다.
* 이렇듯 부가 기능은 그 자체로 많은 중복을 수반하며, 변경시 많은 수정을 필요로하는 등 유지보수성이 떨어지기 쉽다.
* **소프트웨어 개발에 있어 변경 지점은 모듈 형태로 모아 관리되어야 하지만, 부가 기능은 그 자체로서 OOP 방식으로 해결하기 어려운 특징**을 갖는다.

## 2024-11-15 Fri
### AOP와 애스팩트
```
> 애스펙트란, 부가 기능 그 자체와 각각의 부가 기능을 어느 지점에 적용할지 정의한 것과 같다.
```
* 이러한 **부가 기능의 관리를 위해, 최종적으로는 부가 기능을 핵심 기능으로부터 분리하고 한 곳에서 관리하는 방식이 고안**되었다.
  * 나아가 이러한 **부가 기능을 어디에 적용할지 결정하는 기능도 추가되었으며, 이를 하나의 모듈로 만든 것이 `Aspect`에 해당**한다.
* **애스펙트는 앞서 다루었던 `@Aspect`에 해당하며, 스프링이 제공하는 어드바이저 역시 개념상 애스펙트에 해당**한다.
  * 이러한 애스펙트는 이름 그대로 애플리케이션을 바라보는 각각의 관점을 여러 기능으로부터 횡단 관심사 관점으로 달리 보는 것과 같다.
* 상술한 **애스펙트를 기반으로 사용하는 프로그래밍 방식은 관점 지향 프로그래밍이라고 지칭하며, 이는 OOP를 대체하기보다는 OOP를 보조하기 위해 고안**되었다.

## 2024-11-16 Sat
### AspectJ 프레임워크란?
* AspectJ 프레임워크는 AOP의 대표적인 구현으로, 스프링이 제공하는 AOP와는 별개의 프로젝트를 지칭한다.
* 스프링 AOP 역시도 대부분 AspectJ의 문법을 차용하며, 심지어 AspectJ의 기능 일부까지 제공한다.
  * 앞서 다루었던 스프링의 `Advice`, `Advisor` 등의 개념은 스프링 AOP를 지원하며, 특히 프록시를 활용하는 AOP에 해당한다.
* AspectJ는 스스로를 Java의 완벽한 관점 지향 확장이자, 오류 처리 또는 캐싱 등의 여러 횡단 관심사의 깔끔한 모듈화가 가능함을 전면에 내세운다.

## 2024-11-17 Sun
### AOP의 적용 방식
* **AOP는 핵심 기능과 부가 기능을 코드로부터 완벽히 분리하므로, 결국에는 부가 기능이 어느 시점에선가 실제 로직에 추가되어야할 필요**가 있다.
* 이렇듯 AOP를 사용하는 과정에서 부가 기능을 실제 로직에 추가하는 방법은 크게 다음과 같이 분류해볼 수 있다.
  1. 컴파일 시점
  2. 클래스 로딩 시점
  3. 런타임 시점(=프록시)

## 2024-11-18 Mon
### 컴파일 시점의 적용
* **`.java` 확장자를 갖는 소스 코드를 컴파일러를 활용하여 `.class` 확장자인 바이트코드로 컴파일 시점에 부가기능을 추가**할 수 있다.
  * 이 경우, AspectJ 진영에서 제공하는 특별할 컴파일러를 사용해야 하며 결과적으로 바이트코드에 애스펙트와 관련된 코드가 포함된다.
* AspectJ의 **컴파일러는 `Aspect`를 확인하여 해당 클래스가 적용 대상이 맞는지 검증하고, 그 결과에 따라 부가 기능을 적용하는 방식으로 동작**한다.
  * 이렇듯 **원본 코드에 부가 기능 로직이 실제로 추가되는 것을 컴파일 타임 위빙이라는 용어로 지칭**한다.
* 반면, **컴파일 시점에 부가 기능 로직이 위빙되는 것은 별도의 컴파일러를 필요로 하는 등 복잡성이 수반되기에 잘 사용되지 않는다**.

## 2024-11-19 Tue
### 클래스 로딩 시점의 적용
* Java가 실행될 경우 `.class` 형태의 바이트코드는 JVM 내부의 클래스 로더에 보관되므로, 이 때 중간에서 바이트코드를 조작할 수 있다.
  * 정확히는 `.class` 형태의 바이트코드를 조작한 후에 JVM에 적재하는 방식이 되며, 이는 Java 언어 차원에서 제공하는 기능을 활용할 수 있다.
* 이러한 방식은 대부분의 모니터링 도구로부터 사용되며, 이렇듯 **클래스 로딩 시점에 애스펙트를 적용하는 것을 로드 타임 위빙이라는 용어로 지칭**한다.
* 반면, 클래스 로드 시점의 위빙은 Java를 실행할 때 `java -javaagent`와 같은 옵션을 기반으로 클래스 로더 조작기를 명시하게 된다.
  * 때문에 **이러한 방법 역시 번거롭고 운영하기에 어려움이 수반되므로 잘 사용되지 않는다**.

## 2024-11-20 Wed
### 런타임 시점의 적용
* 런타임 시점에는 컴파일도 완료되고, 클래스 로더에 클래스도 모두 적재되므로 이미 Java 기반 애플리케이션이 실행된 것과 같다.
  * 다시 말해, Java가 제공하는 main 메소드가 이미 실행된 이후의 시점을 의미한다.
* 이로 인해 Java 차원에서 제공되는 범위 안에서 부가 기능을 적용할 필요가 있으며, 이 과정에서는 스프링과 컨테이너의 도움은 물론 많은 것이 총동원되어야 한다.
  * 예를 들어, 프록시와 DI 및 빈 후처리기 등의 개념이 총동원되어야 한다.
* 이를 통해 최종적으로 프록시를 기반으로 스프링 빈에 부가 기능을 적용할 수 있으며, 이는 앞서 다루었던 프록시 방식의 AOP를 의미히한다.
* **런타임 시점의 적용은 프록시를 사용하므로 AOP에 일부 제약이 있으나, Java를 실행하기 위해 별도의 컴파일러나 옵션이 필요하지 않다는 장점도 존재**한다.
  * 예를 들어, **프록시 대상 클래스는 항상 상속이 가능해야 하거나 생성자에 프록시를 적용할 수 없고 반드시 프록시 객체를 통해야하는 등의 제약**이 있다.
  * 반면, 스프링만으로도 얼마든지 AOP의 적용이 가능하다는 장점 역시 존재한다!

## 2024-11-21 Thu
### 각 적용 방식을 비교하기
* 앞서 다룬 세 가지 방식으로부터 부가 기능이 적용되는 차이는 다음과 같음을 알 수 있다.
  1. 컴파일 시점: 대상의 실제 코드에 애스펙트 기반의 부가 기능 호출 로직이 포함되며, AspectJ를 직접 사용해야만 한다.
  2. 클래스 로딩 시점: 대상의 실제 코드에 애스펙트 기반의 부가 기능 호출 로직이 포함되며, 역시 AspectJ를 직접 사용해야 한다.
  3. 런타임 시점: **실제 원본 코드를 그대로 유지하는 대신 항상 프록시를 기반으로만 부가 기능을 적용하며, 스프링 AOP는 이러한 방식을 채택**한다.

## 2024-11-22 Fri
### AOP의 적용 위치
* AOP의 경우, 앞서 다루었던 메소드 실행 위치 뿐만 아니라 다음과 같은 다양한 위치에 적용이 가능하다.
  1. 생성자
  2. 필드 값에 대한 접근
  3. `static` 메소드에 대한 접근
  4. 메소드의 실행
* 이 때, 이렇듯 **다양한 AOP 적용 가능 지점을 조인 포인트라는 용어로 지칭**한다.
* AspectJ를 사용하여 컴파일 또는 클래스 로딩 시점에 AOP를 적용할 경우, 실제 바이트코드를 조작하므로 각 부가 기능을 어떠한 지점에든 적용할 수 있다.

## 2024-11-23 Sat
### 스프링 AOP 주의사항
* **스프링 AOP의 경우, 수많은 기능을 갖는 AspectJ 프레임워크를 직접적으로 사용하기보다는 기능 일부에 대한 문법을 차용하는 것**에 그친다.
  * 즉, **스프링은 AspectJ를 직접 사용하는 대신 문법만을 차용하고 여러 AOP 적용 가능 시점 중 프록시 방식의 AOP만을 사용한다는 특징**을 갖는다.
* 이렇듯 **프록시 방식을 활용하는 스프링 AOP는 메소드의 실행 시점에만 AOP를 적용**할 수 있다.
  * 프록시는 메소드 오버라이딩 방식으로 동작하므로, 생성자나 `static` 메소드 및 필드 값 접근에 적용될 수 없다.
  * 다시 말해, **프록시를 사용하는 스프링 AOP의 조인 포인트는 오로지 메소드 실행 지점으로만 제한**된다!
* 또한, **프록시 방식을 사용하는 스프링 AOP는 컨테이너가 관리할 수 있는 각각의 스프링 빈에만 적용이 가능**하다.

## 2024-11-24 Sun
### AspectJ와 스프링 AOP의 비교
* 스프링은 AOP의 기능 일부만을 사용하고, 바꿔 말해 AspectJ는 더욱 복잡하고 다양한 기능을 제공하므로 일견 AspectJ가 더 좋은 기술처럼 보일 수 있다.
* 그러나 AspectJ는 그 내용 자체가 워낙 방대하고, 컴파일러나 전용 문법 등 Java와 관련된 설정도 복잡하다.
  * 반면, 스프링 AOP는 별도의 Java 설정 없이 편리하게 AOP를 적용할 수 있다는 큰 장점을 갖는다.
* **실무의 경우, 대부분의 부가 기능 문제는 스프링 AOP만으로도 해결이 가능하기에 방대한 AspectJ보다는 비교적 편리한 스프링 AOP의 학습이 권장**된다.

## 2024-11-25 Mon
### AOP와 관련된 용어 - I
* **조인 포인트란, 어드바이스가 적용될 수 있는 위치로 메소드 실행 시점이나 생성자 호출 및 필드 값 접근 등의 지점을 의미**한다.
  * 이렇듯 조인 포인트는 어떠한 클래스라기보다는 추상적 개념으로, AOP 적용이 가능한 모든 지점을 지칭한다.
  * 반면, **스프링 AOP는 프록시 방식의 AspectJ만을 사용하므로 조인 포인트는 언제나 메소드 실행 시점에만 제한**된다.
* **포인트컷이란, 조인 포인트 중 어드바이스가 적용될 위치를 선별하는 기능을 지칭**한다.
  * 이러한 포인트컷은 주로 AspectJ 표현식을 사용하여 지정하며, 물론 프록시를 사용하는 스프링 AOP는 메소드 실행 지점만을 포인트컷으로 선별할 수 있다.
* **타겟이란 어드바이스를 받는 객체로서, 포인트컷으로 결정**된다.
* **어드바이스란, 부가 기능 그 자체로서 특정한 조인 포인트로부터 `Aspect`에 의해 적용되는 조치 자체를 의미**한다.
  * `Around`와 `Before` 및 `After` 등의 다양한 어드바이스가 존재한다.

## 2024-11-26 Tue
### AOP와 관련된 용어 - II
* **애스팩트란, 어드바이스와 포인트컷을 한 데 모아 모듈화한 것을 지칭**한다.
  * 말 그대로 `@Aspect`에 해당하며, **하나의 애스팩트에는 여러 어드바이스와 포인트컷은 함께 존재할 수 있다**.
* **어드바이저란 하나의 어드바이스와 하나의 포인트컷으로 구성되며, 스프링 AOP에서만 사용되는 용어에 해당**한다.
* **위빙은 포인트컷으로 결정된 타겟의 조인 포인트에 어드바이스를 적용하는 행위이며, 위빙을 통해 핵심 로직에 영향을 주지 않고 부가 기능을 적용**할 수 있다.
  * 바꿔 말해, **위빙은 AOP를 적용하기 위해 애스팩트를 임의의 객체와 연결한 상태를 지칭**하기도 한다.
  * 상술한 바와 같이, 위빙 시점은 컴파일 시점과 클래스 로딩 시점 및 스프링 AOP가 사용하는 프록시 방식을 의미하는 런타임 시점으로 분류할 수 있다.
* AOP 프록시란, AOP 기능을 구현하기 위해 만들어진 프록시 객체로서 스프링 AOP의 경우 JDK 동적 프록시 또는 CGLIB 프록시를 가리킨다.

## 2024-11-27 Wed
### 스프링 부트 프로젝트에 AOP 기본 설정하기
* 스프링 부트의 경우, AOP를 활용하기 위해서는 아래와 같은 의존성을을 `build.gradle`에 작성해주어야 한다.
  * `spring-data-jpa` 등의 일반적인 의존성을 사용할 경우 아래 의존성 역시 함께 포함되지만, 그렇지 않은 경우에는 직접 명시해야 한다.
```kotlin
dependencies {
	implementation("org.springframework.boot:spring-boot-starter-aop")
}
```
* 또한, `@Aspect`와 같은 어노테이션을 사용하기 위해서는 `@EnableAspectJAutoProxy`와 같은 스프링 설정이 전제되어야 한다.
  * 그러나, 스프링 부트를 사용할 경우 이러한 설정은 자동으로 추가된다.

## 2024-11-28 Thu
### 간단한 AOP 구현하기
* 스프링 AOP를 구현하는 가장 일반적인 방법은 `@Aspect`를 사용하는 것이며, 예를 들어 다음과 같은 코드를 작성해볼 수 있다.
```kotlin
@Aspect
class AspectV1 {
    @Around("execution(* ga.injuk.aop.order..*(..))")
    fun doLog(joinPoint: ProceedingJoinPoint): Any {
        println("${joinPoint.signature}") // join point 시그니쳐 확인
        
        return joinPoint.proceed()
    }
}
```
* `@Around` 어노테이션의 경우, 인자로 전달된 값에 대한 포인트컷 역할을 수행한다.
  * 이 때, `execution...`으로 시작하는 인자는 `ga.injuk.aop.order` 패키지 및 그 하위 모든 패키지를 지칭하는 `AspectJ` 포인트컷 표현식이다.
  * 또한, **해당 어노테이션이 명시된 메소드인 `doLog`는 일종의 어드바이스로서 기능**하게 된다.
* 이를 통해 `ga.injuk.aop.order` 및 그 하위 패키지에 위치한 모든 클래스가 AOP 적용 대상이 될 수 있다. 
  * 또한, **프록시 방식의 AOP를 사용하는 스프링 특성상 프록시를 통하는 메소드만 AOP의 적용 대상**이 된다.

## 2024-11-29 Fri
### 스프링 부트와 AspectJ의 관계
* `@Aspect`와 같이 `org.aspectj` 패키지에 포함되는 기능들은 모두 `aspectjweaver.jar` 라이브러리로부터 제공된다.
* 반면, **스프링의 경우 `AspectJ`의 어노테이션이나 그와 관련된 인터페이스만 사용하는 것으로, 실제 `AspectJ`가 제공하는 위버를 사용하지는 않는다**.
  * 상술했듯, 스프링은 프록시 방식의 AOP를 사용한다.
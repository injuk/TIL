# Spring Advanced

## 2024-10-31 Thu
### 스프링의 AOP 활용하기
* 스프링의 AOP를 활용하기 위해서는 반드시 `spring-boot-starter-aop` 의존성을 추가해야 한다.
  * 이를 활용하는 것으로 **`aspectjweaver` 와 같은 `aspectJ` 관련 라이브러리에 더해 스프링 부트가 필요한 AOP 관련 클래스를 자동으로 등록**한다.
  * 더 정확히는 `AopAutoConfiguration` 이라는 설정 파일을 통해 어떤 빈들이 등록되는지 쉽게 확인할 수 있다.
* 상술한 **의존성을 추가할 경우 스프링 부트 자동 설정에 의해 `AnnotationAwareAspectAutoProxyCreator`라는 빈 후처리기가 등록**된다.
* 이는 **말 그대로 프록시를 자동 생성해주는 빈 후처리기이며, 해당 후처리기는 스프링 빈으로 등록된 모든 `Advisor`를 필요한 곳에 자동으로 적용**한다.
  * 특히, `Advisor`는 내부적으로 `Pointcut`과 `Advice`를 모두 포함하므로 빈 후처리기는 자동으로 적절한 위치에 필요한 포인트컷을 적용한다.
  * 추가적으로, 해당 빈 후처리기는 `@AspectJ`와 관련된 AOP 기능들도 자동으로 인식하여 프록시를 생성하는 방식으로 AOP를 적용한다.

## 2024-11-01 Fri
### @PostConstruct 어노테이션의 비밀
* `@PostConstruct` 어노테이션은 스프링의 빈 생성 이후 빈을 초기화하는 역할을 담당하며, 이는 쉽게 말해 이미 생성된 빈을 한 번 조작하는 것을 의미한다.
* 이를 위해 단순히 빈을 조작하기 위한 빈 후처리기를 고려할 수 있으며, 스프링은 이러한 역할을 담당하는 빈 후처리기를 내부적으로 등록하는 방식으로 동작한다.
  * 스프링의 `CommonAnnotationBeanPostProcessor` 라는 이름의 빈 후처리기는 `@PostConstruct` 어노테이션이 할당된 메소드를 호출한다.
  * 이렇듯 스프링조차도 스프링이 제공하는 내부적인 기능들을 확장하기 위해 빈 후처리기를 활용한다.

## 2024-11-02 Sat
### 자동 프록시 생성기 동작 과정
* 상술한 의존성을 활용하여 자동 프록시 생성기를 적용할 경우, 프록시 객체는 다음과 같은 과정에 의해 등록된다.
  1. 생성: 스프링은 빈 객체를 생성하며, 이는 `@Bean`과 컴포넌트 스캔 대상 모두를 포함한다.
  2. 전달: 생성된 빈 객체를 빈 저장소에 저장하기 전에 빈 후처리기에 전달한다.
  3. `Advisor` 조회: 빈 후처리기는 스프링 컨테이너로부터 모든 `Advisor`를 조회한다.
  4. 프록시 적용 대상 체크: `Advisor`의 포인트컷 정보를 활용하여 각 객체에 대한 프록시 적용 여부를 판단한다.
  5. 프록시 생성: 프록시 적용 대상인 경우 프록시를 생성하고, 그렇지 않은 경우 원본 객체를 반환한다.
  6. 빈 등록: 반환된 객체를 스프링 빈에 등록한다.
* 특히, **`Advisor`를 활용하여 프록시 대상을 검증하는 과정은 대응되는 모든 포인트컷을 매칭하여 하나라도 만족하는 경우 프록시 적용 대상으로 판정**한다.
  * 예를 들어 10개의 메소드 중 하나만 포인트컷 조건을 만족하더라도 해당 빈 객체는 프록시 적용 대상으로 판정된다.
  * 이러한 과정에서 생성된 프록시는 내부적으로 `Advisor`를 포함하며, 실제 호출될 대상 객체 역시 참조하게 된다.
* 기본적으로 **모든 객체에 프록시를 생성하는 것은 낭비이며, 때문에 반드시 필요한 곳에만 프록시를 적용**해줄 필요가 있다.
  * 때문에 자동 프록시 생성기 역시 모든 스프링 빈에 대해 프록시를 적용하는 대신, 포인트컷을 기반으로 한 번 필터링된 빈 객체에 대해서만 프록시를 생성한다.

## 2024-11-03 Sun
### 포인트컷의 두 가지 용도
* 이 때, **중요한 것은 프록시 생성 단계에서 사용되는 포인트컷과 실제 부가 기능 적용을 위해 사용되는 포인트컷을 구분해야한다는 점**에 있다.
* 예를 들어, 프록시 생성 단계에서 각 빈 객체에게 프록시를 생성할지 결정하기 위해 포인트컷이 사용될 수 있다.
  * 자동 프록시 생성기는 포인트컷 정보를 기반으로 각 빈에 대해 프록시를 생성할지 여부를 검증한다.
  * 이 과정에서 클래스 조건은 물론 메소드 조건까지 검증되며, 모든 메소드를 체크하여 포인트컷이 제시하는 조건 하나 하나에 매칭한다.
  * **조건을 모두 충족시키지 않는 대상에 대해서는 프록시를 생성하지 않으며, 바꿔 말해 조건을 하나라도 충족시킨다면 프록시를 생성**한다.
* 또한, **프록시 객체가 호출되었을 때 프록시가 제공하는 부가 기능인 `Advice`를 적용할지 여부를 검증하기 위해서도 포인트컷을 활용**한다.

## 2024-11-04 Mon
### 보다 정밀한 포인트컷 활용하기
* 단순히 메소드 이름 등을 기준으로 `Advice`를 적용하도록 개발한 경우, 범용적인 용어를 명시했을수록 포인트컷은 많은 대상을 허용하게 된다.
  * 다시 말해, 스프링 내부적으로 사용되는 빈까지도 프록시가 생성되거나 부가 기능의 대상이 될 수 있다.
* 때문에 메소드 뿐만 아니라 패키지 등의 조건을 조합할 수 있는 정밀한 포인트컷이 필요하며, 이를 위한 `AspectExpressionPointcut`을 고려해볼 수 있다.
  * **`AspectExpressionPointcut`은 `AspectJ`라는 AOP에 특화된 포인트컷 표현식을 기반으로 복잡한 포인트컷 적용을 지원**한다.

## 2024-11-05 Tue
### 하나의 프록시로 여러 Advisor 적용하기
* 예를 들어 **임의의 빈 객체가 둘 이상의 `Advisor`가 제공하는 포인트컷의 조건을 모두 만족할 경우, 프록시 자동 생성기는 프록시를 단 하나만 생성**한다.
  * 예를 들어 어드바이저 1의 포인트컷만 만족할 경우, 어드바이저 1만을 포함하는 프록시 하나가 생성된다.
  * 반면, **어드바이저 1과 2의 포인트컷을 모두 만족할 경우 두 어드바이저를 모두 포함하는 프록시 하나가 생성**된다.
  * 덧붙여, 모든 포인트컷을 만족하지 않는 빈 객체의 경우 프록시가 생성되지 않는다.
  * 이는 프록시 팩토리에 의해 생성되는 프록시가 내부적으로 여러 `Advisor`를 포함할 수 있기 때문으로, 이로 인해 생성 비용 낭비를 지양할 수 있다.
* **이러한 방식은 후술할 스프링 AOP와 동일하며, 스프링 AOP 역시 여러 개 적용되더라도 여러 프록시가 생성되지 않는 다는 점에 주목**해야 한다.

## 2024-11-06 Wed
### @Aspect 프록시
* **자동 프록시 생성기인 `AnnotationAwareAspectJAutoProxyCreator`로 인해 단지 `Advisor`만을 빈에 등록하는 것으로 프록시 적용이 가능**하다.
  * 이 경우, 자동 프록시 생성기는 스프링 빈에 등록된 모든 어드바이저를 찾아 각각의 빈 객체들에 대해 자동으로 프록시를 적용한다.
* 반면, **스프링은 `@Aspect` 어노테이션을 활용하여 포인트컷과 어드바이스를 포함하는 어드바이저를 매우 편리하게 생성할 수 있도록 지원**한다.
* 이러한 `@Aspect` 어노테이션은 AOP를 가능케하는 `AspectJ` 프로젝트의 어노테이션으로, 스프링은 이를 기반으로 프록시를 활용한 AOP를 지원한다.

## 2024-11-07 Thu
### @Aspect 프록시와 관련된 개념들
* `@Aspect` 어노테이션은 어노테이션 기반의 프록시를 적용하는 경우에 사용되는, 기본적인 어노테이션에 해당한다.
* `@Around` 어노테이션은 인자에 `AspectJ` 포인트컷 표현식을 전달하며, 해당 어노테이션이 할당된 메소드는 `Advice`로서 기능한다.
* `ProceedingJoinPoint`는 어드바이스에서 활용되는 `MethodInvocation`과 유사한 개념에 해당한다.
  * 때문에 해당 객체는 내부적으로 실제 호출 대상과 전달될 인자, 호출된 메소드 정보 등을 포함한다.
  * 예를 들어 `joinPoint.proceed()` 메소드는 실제 호출 대상을 호출하는 `methodInvocation.processd()`와 유사하게 동작한다.
# Spring MVC II
## 2024-06-30 Sun
### 오류 코드 관리 전략
* **핵심은 상세한 것에서 범용적인 것으로 흐르는 방향을 가져야되는 것이며, 이를 통해 메시지를 관리하기 위한 공통 전략을 수립**할 수 있다.
  * 이를 통해 모든 오류 코드에 대해 메시지를 작성하는 등 피로감을 느끼지 않으며, 범용적인 것을 우선시하되 적시에 상세한 메시지만을 추가할 수 있다.

### 스프링이 직접 생성하는 오류 메시지를 처리하기
* 검증 오류 코드는 크게 개발자가 직접 설정한 후 `rejectValue()` 메소드를 호출하는 것과, 스프링이 직접 검증 오류에 추가한 경우로 분류된다.
  * 이 때, 후자의 경우 숫자 필드에 문자열을 전달한 등 타입 정보가 맞지 않는 경우에 주로 발생한다.
* 스프링은 타입 오류에 대해 `typeMismatch` 오류 코드를 사용하며, 이는 MessageCodesResolver를 통해 4개의 필드 오류 코드가 된다.
* 이렇듯 스프링이 직접 삽입한 오류의 경우 사용자 입장에서 굉장히 길고 난해하므로, 이를 유저 친화적인 메시지로 적절히 변환해줄 필요가 있다.
  * 이러한 **변환 작업은 별도의 코딩이 필요하지 않으며, 단지 `typeMismatch`와 관련된 코드를 메시지 프로퍼티 파일에 재정의하는 것으로 완료**된다.

## 2024-07-01 Mon
### 밸리데이터 분리하기
* 입력 데이터에 대한 기본적인 검증은 컨트롤러의 책임이지만, 데이터가 복잡할수록 컨트롤러에 이러한 로직이 산재되기 쉽다.
  * 이러한 문제의 해결 방법은 간단하게 `Validator` 클래스를 정의하고, 검증 로직을 모두 밸리데이터에서 처리하도록 수정하는 것이 있다.
  * 반면, **검증 로직 자체가 간단하여 가독성과 유지보수성을 헤치지 않는다면 굳이 밸리데이터를 분리하지 않아도 무방**하다.
* 이렇듯 데이터의 유효성 검증 책임을 가질 수 있는 `Validator`는 이미 스프링 차원에서 인터페이스 형태로 제공하며, 다음과 같은 두 메소드를 갖는다.
  1. `supports`: 클래스 인자를 받아 해당 클래스를 검증할 수 있는지 여부를 반환한다.
  2. `validate`: 검증 대상을 Object 형으로 받고, 검증 결과를 Errors에 담는 방식으로 실제 검증 로직을 처리한다.
* 이 때, `supports` 메소드의 경우 일반적으로 `return [검증_대상_클래스명].class.isAssignableFrom(class);`를 반환한다.
  * 이러한 방식을 사용할 경우, 검증 대상 클래스 뿐만 아니라 자식 클래스까지 검증이 가능하다는 장점이 있다.
* **`validate` 메소드의 경우 인자로 `Errors errors`를 받으며, 이는 BindingResult의 부모 클래스이므로 다형적으로 동작**할 수 있다.
* 이렇게 정의된 밸리데이터는 빈으로 등록하여 활용할 수 있으며, 컨트롤러에서 이를 주입받아 `validator.validate(item, br);` 형태로 검증할 수 있다.

## 2024-07-02 Tue
### 밸리데이터 활용하기
* 상술한 방식의 경우, 일견 컴포넌트 등록과 주입 및 `validate` 메소드 호출 과정이 중복되는 것처럼 보일 수 있다.
  * **스프링은 `Validator` 클래스에 대한 지원 기능을 이미 제공하며, 이를 활용할 경우 데이터에 대한 검증 로직 호출 없이도 자동으로 처리**할 수 있다.
* 이를 위해서는 `WebDataBinder` 클래스를 사용해야하며, 검증이 필요한 각 컨트롤러 클래스에 다음과 같이 작성해줄 필요가 있다.
```kotlin
@Controller
class MyController(
    private val myValidator: MyValidator,
) {
    @InitBinder
    fun init(binder: WebDataBinder) {
      binder.addValidators(myValidator)
    }
  
    @PostMapping("/add")
    fun add(@Validated @ModelAttribute item: MyItem, bindingResult: BindingResult): String {
        // 이 경우, myValidator.validate(item, bindingResult)를 별도로 작성할 필요가 없다!
    }
} 
```
* 이렇게 작성할 경우 **컨트롤러가 제공하는 각 메소드가 호출될 때마다 `init` 메소드가 호출되어 바인더가 생성된 후 할당**된다.
  * **바인더는 내부적으로 검증 로직 처리를 위한 밸리데이터 객체를 포함하며, 검증이 필요한 컨트롤러 메소드에 `@Validated`를 명시하는 것으로 동작**한다.
  * 이 때, `@Validated`는 검증을 처리해야한다는 사실을 알리는 어노테이션으로서 `WebDataBinder`에 등록된 밸리데이터 중 적절한 것을 찾아 동작한다.
  * 또한 `WebDataBinder`에는 여러 밸리데이터가 등록될 수 있으므로, 내부적으로는 각 밸리데이터에 대해 `supports` 메소드를 호출하는 식으로 동작한다.

## 2024-07-03 Wed
### 글로벌 밸리데이터 적용하기
* 임의의 밸리데이터 로직이 굉장히 범용적이기에 모든 컨트롤러에 적용할 필요가 있는 경우 `WebMvcConfigurer`를 상속하는 빈으로 이를 등록할 수 있다.
  * 해당 인터페이스의 `getValidator()` 메소드를 재정의하는 것으로, 이 경우 `@InitBinder` 없이도 해당 밸리데이터는 모든 컨트롤러에 대해 동작한다.
  * 물론, 글로벌하게 등록된 밸리데이터 역시 `@Validated`와 `supports` 메소드를 기반으로 동작하는 것은 동일하다.
* 반면 **글로벌하게 설정된 밸리데이터가 존재하는 경우, 후술할 `BeanValidator`는 자동으로 등록되지 않으므로 이에 주의**해야 한다.
  * 덧붙여, **이러한 동작 원리로 인해 글로벌 밸리데이터는 잘 사용되지 않는다**.
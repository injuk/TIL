# Spring MVC II
## 2024-06-30 Sun
### 오류 코드 관리 전략
* **핵심은 상세한 것에서 범용적인 것으로 흐르는 방향을 가져야되는 것이며, 이를 통해 메시지를 관리하기 위한 공통 전략을 수립**할 수 있다.
  * 이를 통해 모든 오류 코드에 대해 메시지를 작성하는 등 피로감을 느끼지 않으며, 범용적인 것을 우선시하되 적시에 상세한 메시지만을 추가할 수 있다.

### 스프링이 직접 생성하는 오류 메시지를 처리하기
* 검증 오류 코드는 크게 개발자가 직접 설정한 후 `rejectValue()` 메소드를 호출하는 것과, 스프링이 직접 검증 오류에 추가한 경우로 분류된다.
  * 이 때, 후자의 경우 숫자 필드에 문자열을 전달한 등 타입 정보가 맞지 않는 경우에 주로 발생한다.
* 스프링은 타입 오류에 대해 `typeMismatch` 오류 코드를 사용하며, 이는 MessageCodesResolver를 통해 4개의 필드 오류 코드가 된다.
* 이렇듯 스프링이 직접 삽입한 오류의 경우 사용자 입장에서 굉장히 길고 난해하므로, 이를 유저 친화적인 메시지로 적절히 변환해줄 필요가 있다.
  * 이러한 **변환 작업은 별도의 코딩이 필요하지 않으며, 단지 `typeMismatch`와 관련된 코드를 메시지 프로퍼티 파일에 재정의하는 것으로 완료**된다.

## 2024-07-01 Mon
### 밸리데이터 분리하기
* 입력 데이터에 대한 기본적인 검증은 컨트롤러의 책임이지만, 데이터가 복잡할수록 컨트롤러에 이러한 로직이 산재되기 쉽다.
  * 이러한 문제의 해결 방법은 간단하게 `Validator` 클래스를 정의하고, 검증 로직을 모두 밸리데이터에서 처리하도록 수정하는 것이 있다.
  * 반면, **검증 로직 자체가 간단하여 가독성과 유지보수성을 헤치지 않는다면 굳이 밸리데이터를 분리하지 않아도 무방**하다.
* 이렇듯 데이터의 유효성 검증 책임을 가질 수 있는 `Validator`는 이미 스프링 차원에서 인터페이스 형태로 제공하며, 다음과 같은 두 메소드를 갖는다.
  1. `supports`: 클래스 인자를 받아 해당 클래스를 검증할 수 있는지 여부를 반환한다.
  2. `validate`: 검증 대상을 Object 형으로 받고, 검증 결과를 Errors에 담는 방식으로 실제 검증 로직을 처리한다.
* 이 때, `supports` 메소드의 경우 일반적으로 `return [검증_대상_클래스명].class.isAssignableFrom(class);`를 반환한다.
  * 이러한 방식을 사용할 경우, 검증 대상 클래스 뿐만 아니라 자식 클래스까지 검증이 가능하다는 장점이 있다.
* **`validate` 메소드의 경우 인자로 `Errors errors`를 받으며, 이는 BindingResult의 부모 클래스이므로 다형적으로 동작**할 수 있다.
* 이렇게 정의된 밸리데이터는 빈으로 등록하여 활용할 수 있으며, 컨트롤러에서 이를 주입받아 `validator.validate(item, br);` 형태로 검증할 수 있다.

## 2024-07-02 Tue
### 밸리데이터 활용하기
* 상술한 방식의 경우, 일견 컴포넌트 등록과 주입 및 `validate` 메소드 호출 과정이 중복되는 것처럼 보일 수 있다.
  * **스프링은 `Validator` 클래스에 대한 지원 기능을 이미 제공하며, 이를 활용할 경우 데이터에 대한 검증 로직 호출 없이도 자동으로 처리**할 수 있다.
* 이를 위해서는 `WebDataBinder` 클래스를 사용해야하며, 검증이 필요한 각 컨트롤러 클래스에 다음과 같이 작성해줄 필요가 있다.
```kotlin
@Controller
class MyController(
    private val myValidator: MyValidator,
) {
    @InitBinder
    fun init(binder: WebDataBinder) {
      binder.addValidators(myValidator)
    }
  
    @PostMapping("/add")
    fun add(@Validated @ModelAttribute item: MyItem, bindingResult: BindingResult): String {
        // 이 경우, myValidator.validate(item, bindingResult)를 별도로 작성할 필요가 없다!
    }
} 
```
* 이렇게 작성할 경우 **컨트롤러가 제공하는 각 메소드가 호출될 때마다 `init` 메소드가 호출되어 바인더가 생성된 후 할당**된다.
  * **바인더는 내부적으로 검증 로직 처리를 위한 밸리데이터 객체를 포함하며, 검증이 필요한 컨트롤러 메소드에 `@Validated`를 명시하는 것으로 동작**한다.
  * 이 때, `@Validated`는 검증을 처리해야한다는 사실을 알리는 어노테이션으로서 `WebDataBinder`에 등록된 밸리데이터 중 적절한 것을 찾아 동작한다.
  * 또한 `WebDataBinder`에는 여러 밸리데이터가 등록될 수 있으므로, 내부적으로는 각 밸리데이터에 대해 `supports` 메소드를 호출하는 식으로 동작한다.

## 2024-07-03 Wed
### 글로벌 밸리데이터 적용하기
* 임의의 밸리데이터 로직이 굉장히 범용적이기에 모든 컨트롤러에 적용할 필요가 있는 경우 `WebMvcConfigurer`를 상속하는 빈으로 이를 등록할 수 있다.
  * 해당 인터페이스의 `getValidator()` 메소드를 재정의하는 것으로, 이 경우 `@InitBinder` 없이도 해당 밸리데이터는 모든 컨트롤러에 대해 동작한다.
  * 물론, 글로벌하게 등록된 밸리데이터 역시 `@Validated`와 `supports` 메소드를 기반으로 동작하는 것은 동일하다.
* 반면 **글로벌하게 설정된 밸리데이터가 존재하는 경우, 후술할 `BeanValidator`는 자동으로 등록되지 않으므로 이에 주의**해야 한다.
  * 덧붙여, **이러한 동작 원리로 인해 글로벌 밸리데이터는 잘 사용되지 않는다**.

## 2024-07-04 Thu
### @Validated와 @Valid의 차이
```
> 두 어노테이션 모두 스프링이 검증시 활용할 수 있으며, 단지 스프링 전용 검증 어노테이션인지 / Java 표준 검증 어노테이션인지에 대한 차이점만이 존재한다.
```
* **`@Validated`의 경우 스프링 진영의 검증용 어노테이션인 반면, `@Valid`는 Java 진영의 표준 어노테이션인 `javax.validation`에서 제공**된다.
  * 그러나 **`@Valid`를 사용하고자 하는 경우, `spring-boot-starter-validation` 의존성 추가가 필요**하다.
* `@Validated`의 경우 `groups`라는 별도의 기능을 갖기에, 이를 반드시 사용해야하는 상황을 제외하고는 두 어노테이션 중 무엇을 사용해도 무방하다.

## 2024-07-05 Fri
### 빈 밸리데이션이란?
* 일반적으로, 대부분의 검증 로직은 다음과 같은 종류로 일반화 수 있다.
  1. 빈 값인가, 그렇지 않은가?
  2. 값이 어떤 범위 내에 존재하는가?
* 이렇듯 **일반화된 로직을 매 번 코드로 작성하는 것은 개발자의 피로도와 휴먼 에러의 발생 가능성을 높이기 쉽다**.
* **빈 밸리데이션은 이러한 번거로운 로직에 어노테이션을 적용하자는 아이디어에서 출발하였으며, 이를 범용적으로 사용할 수 있을 만큼 표준화한 것에 해당**한다.
* 이 때, **빈 밸리데이션은 엄밀히 말해 구현체가 아닌 `JSR-380(Bean Validation 2.0)`이라는 기술 표준을 지칭**한다.
  * 즉, **빈 밸리데이션은 검증 오너테이션과 여러 인터페이스의 모음에 불과하며 이는 표준으로서의 JPA와 구현체로서의 하이버네이트와의 관계와 유사**하다.
  * **빈 밸리데이션 역시 대중적인 구현체로는 하이버네이트가 있으나, 이는 ORM 기술과는 전혀 무관**하다.
* **어노테이션을 적용했을 경우 `@NotNull`과 같이 `javax.validation`에서 임포트되는 것은 표준에 해당하므로 어떠한 구현체에서도 동작**한다.
  * 반면, `@Range`와 같이 `org.hibernate.validator` 등으로부터 임포트되는 것은 표준에 해당하지 않으므로 해당 구현체에서만 동작한다.
  * 그러나 **실무에서는 대부분의 경우 하이버네이트 밸리데이터를 사용하므로, 표준 지원 여부에 크게 연연하지 않아도 무방**하다.
* **빈 밸리데이션이 적용된 클래스에 대한 검증은 별도의 팩토리와 밸리데이터를 사용하는 등 번거롭지만, 스프링은 이미 이러한 과정을 완전히 통합**해두었다.
# Spring MVC II
## 2024-06-30 Sun
### 오류 코드 관리 전략
* **핵심은 상세한 것에서 범용적인 것으로 흐르는 방향을 가져야되는 것이며, 이를 통해 메시지를 관리하기 위한 공통 전략을 수립**할 수 있다.
  * 이를 통해 모든 오류 코드에 대해 메시지를 작성하는 등 피로감을 느끼지 않으며, 범용적인 것을 우선시하되 적시에 상세한 메시지만을 추가할 수 있다.

### 스프링이 직접 생성하는 오류 메시지를 처리하기
* 검증 오류 코드는 크게 개발자가 직접 설정한 후 `rejectValue()` 메소드를 호출하는 것과, 스프링이 직접 검증 오류에 추가한 경우로 분류된다.
  * 이 때, 후자의 경우 숫자 필드에 문자열을 전달한 등 타입 정보가 맞지 않는 경우에 주로 발생한다.
* 스프링은 타입 오류에 대해 `typeMismatch` 오류 코드를 사용하며, 이는 MessageCodesResolver를 통해 4개의 필드 오류 코드가 된다.
* 이렇듯 스프링이 직접 삽입한 오류의 경우 사용자 입장에서 굉장히 길고 난해하므로, 이를 유저 친화적인 메시지로 적절히 변환해줄 필요가 있다.
  * 이러한 **변환 작업은 별도의 코딩이 필요하지 않으며, 단지 `typeMismatch`와 관련된 코드를 메시지 프로퍼티 파일에 재정의하는 것으로 완료**된다.

## 2024-07-01 Mon
### 밸리데이터 분리하기
* 입력 데이터에 대한 기본적인 검증은 컨트롤러의 책임이지만, 데이터가 복잡할수록 컨트롤러에 이러한 로직이 산재되기 쉽다.
  * 이러한 문제의 해결 방법은 간단하게 `Validator` 클래스를 정의하고, 검증 로직을 모두 밸리데이터에서 처리하도록 수정하는 것이 있다.
  * 반면, **검증 로직 자체가 간단하여 가독성과 유지보수성을 헤치지 않는다면 굳이 밸리데이터를 분리하지 않아도 무방**하다.
* 이렇듯 데이터의 유효성 검증 책임을 가질 수 있는 `Validator`는 이미 스프링 차원에서 인터페이스 형태로 제공하며, 다음과 같은 두 메소드를 갖는다.
  1. `supports`: 클래스 인자를 받아 해당 클래스를 검증할 수 있는지 여부를 반환한다.
  2. `validate`: 검증 대상을 Object 형으로 받고, 검증 결과를 Errors에 담는 방식으로 실제 검증 로직을 처리한다.
* 이 때, `supports` 메소드의 경우 일반적으로 `return [검증_대상_클래스명].class.isAssignableFrom(class);`를 반환한다.
  * 이러한 방식을 사용할 경우, 검증 대상 클래스 뿐만 아니라 자식 클래스까지 검증이 가능하다는 장점이 있다.
* **`validate` 메소드의 경우 인자로 `Errors errors`를 받으며, 이는 BindingResult의 부모 클래스이므로 다형적으로 동작**할 수 있다.
* 이렇게 정의된 밸리데이터는 빈으로 등록하여 활용할 수 있으며, 컨트롤러에서 이를 주입받아 `validator.validate(item, br);` 형태로 검증할 수 있다.

## 2024-07-02 Tue
### 밸리데이터 활용하기
* 상술한 방식의 경우, 일견 컴포넌트 등록과 주입 및 `validate` 메소드 호출 과정이 중복되는 것처럼 보일 수 있다.
  * **스프링은 `Validator` 클래스에 대한 지원 기능을 이미 제공하며, 이를 활용할 경우 데이터에 대한 검증 로직 호출 없이도 자동으로 처리**할 수 있다.
* 이를 위해서는 `WebDataBinder` 클래스를 사용해야하며, 검증이 필요한 각 컨트롤러 클래스에 다음과 같이 작성해줄 필요가 있다.
```kotlin
@Controller
class MyController(
    private val myValidator: MyValidator,
) {
    @InitBinder
    fun init(binder: WebDataBinder) {
      binder.addValidators(myValidator)
    }
  
    @PostMapping("/add")
    fun add(@Validated @ModelAttribute item: MyItem, bindingResult: BindingResult): String {
        // 이 경우, myValidator.validate(item, bindingResult)를 별도로 작성할 필요가 없다!
    }
} 
```
* 이렇게 작성할 경우 **컨트롤러가 제공하는 각 메소드가 호출될 때마다 `init` 메소드가 호출되어 바인더가 생성된 후 할당**된다.
  * **바인더는 내부적으로 검증 로직 처리를 위한 밸리데이터 객체를 포함하며, 검증이 필요한 컨트롤러 메소드에 `@Validated`를 명시하는 것으로 동작**한다.
  * 이 때, `@Validated`는 검증을 처리해야한다는 사실을 알리는 어노테이션으로서 `WebDataBinder`에 등록된 밸리데이터 중 적절한 것을 찾아 동작한다.
  * 또한 `WebDataBinder`에는 여러 밸리데이터가 등록될 수 있으므로, 내부적으로는 각 밸리데이터에 대해 `supports` 메소드를 호출하는 식으로 동작한다.

## 2024-07-03 Wed
### 글로벌 밸리데이터 적용하기
* 임의의 밸리데이터 로직이 굉장히 범용적이기에 모든 컨트롤러에 적용할 필요가 있는 경우 `WebMvcConfigurer`를 상속하는 빈으로 이를 등록할 수 있다.
  * 해당 인터페이스의 `getValidator()` 메소드를 재정의하는 것으로, 이 경우 `@InitBinder` 없이도 해당 밸리데이터는 모든 컨트롤러에 대해 동작한다.
  * 물론, 글로벌하게 등록된 밸리데이터 역시 `@Validated`와 `supports` 메소드를 기반으로 동작하는 것은 동일하다.
* 반면 **글로벌하게 설정된 밸리데이터가 존재하는 경우, 후술할 `BeanValidator`는 자동으로 등록되지 않으므로 이에 주의**해야 한다.
  * 덧붙여, **이러한 동작 원리로 인해 글로벌 밸리데이터는 잘 사용되지 않는다**.

## 2024-07-04 Thu
### @Validated와 @Valid의 차이
```
> 두 어노테이션 모두 스프링이 검증시 활용할 수 있으며, 단지 스프링 전용 검증 어노테이션인지 / Java 표준 검증 어노테이션인지에 대한 차이점만이 존재한다.
```
* **`@Validated`의 경우 스프링 진영의 검증용 어노테이션인 반면, `@Valid`는 Java 진영의 표준 어노테이션인 `javax.validation`에서 제공**된다.
  * 그러나 **`@Valid`를 사용하고자 하는 경우, `spring-boot-starter-validation` 의존성 추가가 필요**하다.
* `@Validated`의 경우 `groups`라는 별도의 기능을 갖기에, 이를 반드시 사용해야하는 상황을 제외하고는 두 어노테이션 중 무엇을 사용해도 무방하다.

## 2024-07-05 Fri
### 빈 밸리데이션이란?
* 일반적으로, 대부분의 검증 로직은 다음과 같은 종류로 일반화 수 있다.
  1. 빈 값인가, 그렇지 않은가?
  2. 값이 어떤 범위 내에 존재하는가?
* 이렇듯 **일반화된 로직을 매 번 코드로 작성하는 것은 개발자의 피로도와 휴먼 에러의 발생 가능성을 높이기 쉽다**.
* **빈 밸리데이션은 이러한 번거로운 로직에 어노테이션을 적용하자는 아이디어에서 출발하였으며, 이를 범용적으로 사용할 수 있을 만큼 표준화한 것에 해당**한다.
* 이 때, **빈 밸리데이션은 엄밀히 말해 구현체가 아닌 `JSR-380(Bean Validation 2.0)`이라는 기술 표준을 지칭**한다.
  * 즉, **빈 밸리데이션은 검증 오너테이션과 여러 인터페이스의 모음에 불과하며 이는 표준으로서의 JPA와 구현체로서의 하이버네이트와의 관계와 유사**하다.
  * **빈 밸리데이션 역시 대중적인 구현체로는 하이버네이트가 있으나, 이는 ORM 기술과는 전혀 무관**하다.
* **어노테이션을 적용했을 경우 `@NotNull`과 같이 `javax.validation`에서 임포트되는 것은 표준에 해당하므로 어떠한 구현체에서도 동작**한다.
  * 반면, `@Range`와 같이 `org.hibernate.validator` 등으로부터 임포트되는 것은 표준에 해당하지 않으므로 해당 구현체에서만 동작한다.
  * 그러나 **실무에서는 대부분의 경우 하이버네이트 밸리데이터를 사용하므로, 표준 지원 여부에 크게 연연하지 않아도 무방**하다.
* **빈 밸리데이션이 적용된 클래스에 대한 검증은 별도의 팩토리와 밸리데이터를 사용하는 등 번거롭지만, 스프링은 이미 이러한 과정을 완전히 통합**해두었다.

## 2024-07-06 Sat
### 스프링 MVC와 빈 밸리데이터의 통합
* 프로젝트 **의존성에 `spring-boot-starter-validation`가 포함된 경우, 스프링 MVC는 자동으로 빈 밸리데이터를 인식하고 스프링에 통합**한다.
* 이 경우, **스프링은 검증 기능을 갖는 `LocalValidatorFactoryBean`이라는 밸리데이터를 글로벌 밸리데이터로 자동 적용하는 식으로 동작**한다.
  * 이로 인해 개발자는 단지 `@Valid` 또는 `@Validated` 어노테이션만 명시하면 되며, 예외 발생시 `BindingResult` 객체에 오류가 등록된다.
  * 또한, 이러한 동작 원리로 인해 개발자가 별도로 등록한 글로벌 밸리데이터가 존재하는 경우 빈 밸리데이터는 스프링에 통합되지 않는 점에 주의해야 한다.

## 2024-07-07 Sun
### 빈 밸리데이션 검증 순서
* 스프링 MVC에 빈 밸리데이션이 자동 통합된 경우, 임의의 데이터에 대해 스프링은 다음과 같이 동작한다.
  1. `@ModelAttribute` 어노테이션이 명시된 객체의 각 필드에 대해 바인딩을 시도한다.
  2. 바인딩에 실패한 경우, `typeMismatch`와 관련된 FieldError를 추가한다.
  3. 바인딩 완료 후 밸리데이터를 활용하여 검증한다.
* 이 때, 우선 바인딩에 성공해야 검증 로직이 의미가 있으므로 **스프링은 바인딩에 성공한 필드에 대해서만 빈 밸리데이션을 적용**한다.

## 2024-07-08 Mon
### 빈 밸리데이션과 메시지 코드
* **`@NotBlank`라는 어노테이션을 예로 들어, `MessageCodesResolver`는 해당 어노테이션 이름을 접두사로 갖는 메시지 코드들을 생성**한다.
  * 이는 마치 `typeMismatch`와 유사한 메시지 코드들을 생성하며, 예를 들어 `NotBlank.item.itemName` 따위의 코드가 생성된다.
  * 그러나 이 과정에서는 어디까지나 오류 코드가 생성되는 것이므로, 실제로는 `messages.properties` 파일에 대응되는 메시지가 없어도 무방하다.
* 또한, 내부적으로 `MessageCodesResolver`가 활용되므로 원하는 경우에는 언제나 더 자세한 오류 메시지를 메시지 관리용 프로퍼티 파일에 작성할 수 있다.
* 결국, 빈 밸리데이션에 의해 오류 메시지가 결정되는 우선 순위는 다음과 같이 정리해볼 수 있다.
  1. `MessageCodesResolver`에 의해 생성된 메시지 코드 순서대로 `messageSource`로부터 조회한다.
  2. 빈 밸리데이션을 위해 명시한 어노테이션에 정의된 `message` 속성을 활용한다.
  3. 라이브러리가 제공하는 기본 값을 사용한다.

## 2024-07-09 Tue
### 빈 밸리데이션을 활용하여 ObjectError를 처리하기
* 예를 들어 데이터 클래스에 포함된 둘 이상의 필드를 활용하는 검증 로직이 필요한 경우, 다음과 같이 `@ScriptAssert` 어노테이션을 활용할 수 있다.
```kotlin
// 아래의 코드에서, _this는 MyData 클래스로부터 생성된 인스턴스 자신을 의미한다.
@ScriptAssert(lang = "javascript", script = "_this.price * _this.quantity >= 10000", message = "다시 입력해주세요!")
data class MyData(
    val price: Int,
    val quantity: Int,
)
```
* 이러한 `@ScriptAssert` 역시 `MessageCodesResolver`에 의해 적절한 메시지 코드가 생성되어 이를 제어할 수 있다.
* 그러나 **`@ScriptAssert`를 활용하는 방식은 제약이 많고 복잡하며, 무엇보다 해당 객체의 범위를 넘어서는 검증 요구사항에 대응하기 어렵다**.
  * 때문에 이러한 **ObjectError의 경우 `@ScriptAssert` 어노테이션 대신 직접 코드를 활용하여 필요한 검증 과정을 처리하는 것이 권장**된다.

## 2024-07-10 Wed
### 빈 밸리데이션의 한계와 groups 기능
* 예를 들어 임의의 리소스에 대한 생성과 수정에 동일한 모델을 사용하지만, 각 요구사항에 대해 검증 방식이 달라질 수 있다.
  * 상품 도메인을 예로 들어, 상품은 생성 시에는 식별자가 필요없지만 수정 시에는 필수적일 수 있다.
* 이렇듯 동일한 모델이 여러 요구사항에서 다른 검증 방식을 가져 동일한 빈 밸리데이션을 적용할 수 없는 경우, 다음과 같은 두 방식을 고려해볼 수 있다.
  1. 빈 밸리데이션의 `groups` 기능을 활용하기
  2. 또는 도메인을 위해 사용되는 모델 대신 요구사항 별로 별도의 DTO를 적용하기
* `groups` 기능을 활용하기 위해서는 각 검증 요구사항 별로 그룹을 나눌 필요가 있으며, 이 과정에서 어떠한 메소드도 갖지 않는 인터페이스를 사용하게 된다.
```kotlin
// 아무런 메소드도 갖지 않으며, 단지 마킹을 위해 존재한다.
interface CreateChecker {}

interface UpdateChecker {}
```
* `groups` 기능은 이렇게 정의된 마커 인터페이스를 활용하여 다음과 같이 간단하게 적용할 수 있다.
```kotlin
data class MyData(
    @NotNull(groups = UpdateChecker.class)
    val id: Long,

    @NotBlank(groups = [CreateChecker.class, UpdateChecker.class])
    val name: String,
    val price: Int,
    val quantity: Int,
)
```
* 또한, 이러한 `groups` 기능을 활용하기 위해서는 컨트롤러 메소드에 `@Validated(value = CreateChecker.class)`와 같이 명시해줄 필요가 있다.
  * 이렇듯 명시된 그룹의 종류를 기반으로, 해당 컨트롤러 메소드에서 적용할 검증 로직을 결정할 수 있게 된다.
  * 덧붙여, `@Valid`는 상술한 `groups` 기능을 제공하지 않으므로 해당 기능을 위해서는 반드시 `@Validated` 어노테이션을 사용해야 한다.
* 상술한 바와 같이, `@Validated` 어노테이션과 `groups` 기능을 혼용할 경우 요구사항 별로 다른 검증 로직을 처리하되 동일한 모델을 활용할 수 있다.
  * 그러나 **`groups` 기능은 복잡도가 높아실무에서는 잘 활용되지 않으며, 오히려 요구사항 별로 별도의 클래스를 정의하여 활용하는 방식을 선호**한다.

## 2024-07-11 Thu
### RestController와 요청 처리 방식
* `@RestController` 등 JSON을 주고 받기 위한 API의 경우, 컨트롤러 로직이 호출되기에 앞서 우선 요청 정보가 `@RequestBody`로 파싱될 필요가 있다.
  * 그러나 **`@RequestBody`에 명시된 객체와 다른 데이터를 전달할 경우, 객체 파싱 자체가 불가하여 컨트롤러 로직이 호출되지 않는다**.
  * 즉, 사용자의 요청에 대해 HTTP 메시지 컨버터가 우선 객체화할 필요가 있으나 이 단계에서 실패할 경우 컨트롤러로 진입이 불가하다.
* 이렇듯 API가 호출된 경우, 컨트롤러 입장에서는 세 가지 분기가 가능하다.
  1. 유효한 요청: 사용자가 정상적인 요청을 전달한 경우
  2. 유효하지 않은 요청: 사용자가 비정상적인 요청을 전달하여 JSON 문서를 객체화하지 못한 경우
  3. 검증 오류 요청: JSON을 객체화하였으나, 검증 과정에서 실패하는 경우

## 2024-07-12 Fri
### @ModelAttribute와 @RequestBody의 검증 방식
```
> @ModelAttribute는 HTTP 요청 파라미터를 처리하므로 필드 단위의 세밀한 바인딩이 가능하다.
> @RequestBody의 경우 우선 HTTP 메시지 컨버터를 통해 HTTP 요청 본문을 객체화하므로, 객체화에 성공해야만 바인딩이 가능하다. 
```
* `@ModelAttribute`는 HTTP 요청 파라미터를 처리하므로, 각 필드 단위로 세밀하게 검증을 처리할 수 있다.
  * 이러한 이유에서, **임의의 필드 타입이 일치하지 않는 경우에도 나머지 필드를 처리하거나 컨트롤러 로직을 호출하는 것이 가능**하다.
* 반면, **`@RequestBody`의 경우 `HttpMessageConverter`가 JSON 문서 전체를 객체화하기 위한 로직이 적용**된다.
  * 즉, `@ModelAttribute`의 경우와는 달리 각 필드 별로 검증 로직이 적용되는 대신 전체 객체 단위로 적용된다.
  * 이로 인해 **우선 객체화가 전제되며, 그 이후에야 `@Valid` 또는 `@Validate` 어노테이션이 동작**할 수 있다.
  * 반면, **객체화에 실패한 경우에는 HTTP 메시지 컨버터에 의해 예외가 발생하므로 밸리데이터는 물론 컨트롤러 로직조차 호출되지 않는다**.

## 2024-07-13 Sat
### 참고 - 도메인이란?
```
> 도메인이 가장 중요하다!
```
* **도메인이란, 화면이나 UI 등 표현이나 인프라 영역을 제외하고 시스템이 반드시 구현해야 할 핵심적인 비즈니스 업무 영역 전반을 의미**한다.
  * 즉, 화면을 표현하는 방식이나 기반 인프라가 변경되더라도 도메인에 작성된 코드는 그대로 사용할 수 있어야 한다.
  * 이를 위해서는 도메인 이외의 영역은 도메인에 의존하지만, 도메인은 다른 영역에 의존하지 않도록 설계되어야 한다.
* 이 때, 도메인에 포함되는 것을 예로 들면 핵심적인 비즈니스 로직 및 이와 관련된 클래스들이 있다.
* **좋은 설계란, 도메인이 다른 영역을 참조하는 등 의존하지 않는 것을 의미**한다.

## 2024-07-14 Sun
### 글로벌 오류와 필드 오류의 차이
* 글로벌 오류의 경우, 검증 대상 객체 자체만으로 유효성을 판단할 수 없는 경우가 많다.
  * 예를 들어 로그인 로직의 경우, Form으로부터 넘어온 폼 객체에서 그치지 않고 로그인 처리 및 사용자 검증을 위해 DB까지 관여되는 경우가 많다.
* 반면, 필드 오류의 경우 해당 객체만으로도 유효성 검증이 가능하다.
* 때문에 **글로벌 오류와 필드 오류를 결정하기 어려운 경우, 우선 해당 객체만으로 유효성 검증이 가능한지 고민해보는 것이 바람직**하다.

## 2024-07-15 Mon
### 쿠키를 활용한 로그인 처리
* 로그인의 경우 로그인 상태를 유지할 필요가 있으나, 이러한 로그인 정보를 매번 쿼리 파라미터 등을 통해 전달하는 것은 매우 번거로운 일이 된다.
  * **이러한 경우에 쿠키를 고려할 수 있으며, 이는 서버에서 로그인에 성공할 경우 HTTP 응답에 쿠키를 담아 브라우저에 반환하는 방식으로 동작**한다.
  * 또한, 브라우저는 서버로부터의 응답에 쿠키가 포함된 경우 이후의 요청에는 해당 쿠키를 포함시키게 된다.
* 이 때, 활용 가능한 쿠키의 선택지는 크게 다음과 같이 구분할 수 있다.
  1. 영속 쿠키: 만료 날짜가 입력된 경우, 쿠키를 해당 만료 날짜까지 유지한다.
  2. 세션 쿠키: 만료 날짜가 생략된 경우, 브라우저가 종료될 때까지 쿠키를 유지하며 이 경우 세션은 일반적인 HTTP 세션 등과는 전혀 무관한 의미로 사용된다.
* 스프링의 경우 HTTP 응답에 쿠키를 포함시키기 위해서는 `HttpServletResponse`를 다음과 같이 활용한다.
```java
@PostMapping("/login")
public String login(@Valid @ModelAttribute LoginForm form, BindingResult bindingResult, HttpServletResponse response) {
    if(bindingResult.hasErrors()) {
        return "login/loginForm";
    }

    Member loginMember = loginService.login(form.getLoginId(), form.getPassword());
    if(loginMember == null) {
        bindingResult.reject("loginFail", "아이디 또는 비밀번호가 잘못되었습니다.");
        return "login/loginForm";
    }

    // 만료일을 설정하지 않으므로 세션 쿠키로서 동작하고, 브라우저 종료시 모두 제거된다.
    Cookie cookie = new Cookie("memberId", String.valueOf(loginMember.getId()));
    response.addCookie(cookie);

    return "redirect:/";
}
```
* 이렇듯 쿠키 기능을 구현할 경우, 로그인 완료시 응답 헤더에 `Set-Cookie`가 포함되어 반환되며 이후의 요청에는 항상 `Cookie` 헤더가 포함된다.
* 이후의 요청에 대해서는 다음과 같이 `@CookieValue` 어노테이션을 활용하여 로그인에 활용된 쿠키의 값을 추출할 수 있다.
```java
@GetMapping("/")
public String loginHome(@CookieValue(name = "memberId", required = false) Long memberId, Model model) {
    // 해당 쿠키가 없는 경우, 일반 사용자를 위한 페이지를 반환한다.
    if(memberId == null) {
        return "home";
    }

    // 해당 쿠키가 있더라도 로그인이 불가능한 사용자 역시 일반 사용자를 위한 페이지로 반환한다.
    Member loginMember = memberRepository.findById(memberId);
    if(loginMember == null) {
        return "home";
    }

    // 이 시점에서 member는 성공적으로 로그인된 사용자를 의미한다.
    model.addAttribute("member", loginMember);

    return "loginHome";
}
```

## 2024-07-16 Tue
### 쿠키를 활용한 로그아웃 처리
* 쿠키의 경우, 만료일을 다음과 같이 제거해주면 제거되므로 이를 활용하여 로그아웃 로직을 손쉽게 구현할 수 있다.
  * 이는 웹 브라우저가 쿠키를 확인했을 때, 만료일이 0이므로 즉시 제거하는 원리를 이용한 것에 해당한다.
```java
@PostMapping("/logout")
public String logout(HttpServletResponse response) {
    expireCookie(response, "memberId");

    return "redirect:/";
}

private void expireCookie(HttpServletResponse response, String cookieName) {
    Cookie cookie = new Cookie(cookieName, null);
    cookie.setMaxAge(0);

    response.addCookie(cookie);
}
```

## 2024-07-17 Wed
### 쿠키를 활용한 로그인 처리 - 결론
* 쿠키를 활용하여 로그인할 경우, 서버와 브라우저는 다음과 같은 절차를 거쳐 통신하게 된다.
  1. 사용자가 서버에 로그인을 요청한 경우, 서버는 로그인 로직을 처리한 후에 올바른 사용자에 한해 응답 헤더에 `Set-Cookie`를 담아 반환한다.
  2. 브라우저는 `Set-Cookie`가 포함된 응답에 대해, 해당하는 쿠키를 브라우저 내의 쿠키 저장소에 저장한다.
  3. 브라우저는 이후 해당 서버로 향하는 모든 요청의 `Cookie` 헤더에 앞서 반환된 쿠키를 포함시켜 요청한다.
* 이 때, 브라우저는 쿠키의 종류가 세션 쿠키인지 영속 쿠키인지에 따라 쿠키를 직접 제거하는 방식으로 동작한다.
* 그러나 상술한 바와 같이 **단순히 쿠키만을 활용하여 로그인을 처리할 경우, 심각한 보안 문제에 직면하기 쉬움에 주의**해야 한다.

## 2024-07-18 Thu
### 쿠키와 관련된 보안 문제
* 쿠키의 경우, 클라이언트 차원에서 저장되므로 언제든지 위/변조가 가능하다.
  * 같은 이유에서 쿠키의 정보는 언제든지 탈취될 수 있으므로, 민감한 정보는 절대로 저장하지 않아야 한다.
* 때문에 **쿠키에는 가능한 한 민감한 정보를 저장하지 않고, 예측이 어려운 랜덤한 값을 반환한 후 이를 서버 차원에서 사용자 정보와 매핑하는 것이 바람직**하다.
  * 즉, **서버에서는 예측 불가능한 값인 토큰을 반환하되 이러한 토큰 정보와 사용자 정보를 매핑하여 관리**한다.
  * 또한, 토큰의 만료 기간을 짧게 두는 것으로 토큰 탈취에 의한 피해를 최소화할 수도 있다.
* 이를 통해 토큰이 탈취되더라도 예측 불가능한 값을 사용하므로 다른 사용자의 정보에 접근하기 어려우며, 필요한 경우 토큰을 무효화하는 것도 가능하다.
# Spring MVC II
## 2024-07-26 Fri
### 공통 관심사와 서블릿 필터, 스프링 인터셉터
```
> 대표적인 두 기능인 필터와 인터셉터는 각각 서블릿과 스프링이 제공하는 기능이라는 점에서 차이가 있다.
```
* 예를 들어, 로그인된 사용자에 제한해야 하는 기능들이 많은 경우 각 기능을 대표하는 메소드마다 로그인 여부를 확인하는 로직이 포함되게 된다.
  * 나아가 이러한 로그인 여부를 확인하는 로직은 이후에 추가될 모든 기능에 대해서도 동일하게, 반복적으로 작성되어야 하는 경향이 있다.
* 이렇듯 **애플리케이션의 여러 로직에서 공통적으로 관심을 유지해야 할 기능을 `공통 관심사`라는 용어로 지칭하며, 인증은 대표적인 공통 관심사에 해당**한다.
* 이러한 **공통 관심사는 스프링이 제공하는 AOP로도 해결할 수 있으나, 그 중에서도 웹과 관련된 공통 관심사는 필터나 인터셉터를 활용하는 것이 바람직**하다.
  * 이는 **필터와 인터셉터가 모두 `HttpServletRequest`를 제공하므로, 헤더나 URL 등 사용자의 요청 정보에 더 쉽게 접근할 수 있기 때문**이다.
  * 덧붙여 별도의 기능을 제공하지 않는 AOP와 달리, 필터나 인터셉터는 웹과 관련된 수많은 부가 기능을 제공한다.

## 2024-07-27 Sat
### 서블릿 필터란?
```
> 필터는 마치 스프링 빈처럼 서블릿 컨테이너에 의해 싱글톤 객체로 관리된다는 점에 유의해야 한다.
```
* 필터는 서블릿이 제공하는 수문장으로, 다음과 같은 요청 및 응답 흐름 속에서 일반적인 로직으로서 동작한다.
```
> 사용자 -> HTTP 요청 -> WAS -> 서블릿 필터 -> 서블릿 -> 컨트롤러 -> ... 
```
* 이렇듯 **필터를 적용할 경우 서블릿이 호출되기에 앞서 필터가 호출된 후에 서블릿이 호출**되며, 패턴을 명시하여 특정 엔드포인트에만 필터를 적용할 수도 있다.
  * 때문에 모든 HTTP 요청에 대해 로그를 남기는 등의 요구 사항에 대해서는 우선적으로 필터를 고려해볼 수 있다.
* 예를 들어 로그인 사용자에 대해서만 API 호출이 가능하도록 제한하고자 하는 경우에도 필터를 사용할 수 있으며, 이 경우 제한된 요청은 필터 차원에서 차단된다.
* **하나 이상의 필터를 활용하는 것으로 필터 체인을 구성할 수 있으며, 각 필터는 순차적으로 처리되므로 언제든지 중간 필터를 추가하거나 제거할 수 있다**.
* **필터는 다음과 같은 메소드를 제공하는 인터페이스로, 필터의 구현체를 등록하는 것으로 서블릿 컨테이너가 필터에 해당하는 싱글톤 객체를 생성한 후 관리**한다.
  1. `init()`: 필터를 초기화하는 메소드이며, 서블릿 컨테이너가 생성되는 시점에 호출된다.
  2. `doFilter()`: **임의의 HTTP 요청에 대해 호출되는 메소드로, 필터의 핵심적인 로직을 작성**한다.
  3. `destroy()`: 필터 종료 메소드로서, 서블릿 컨테이너가 종료될 때 호출된다.

## 2024-07-28 Sun
### 간단한 로그 필터 구현하기
* 상술한 내용을 기반으로, 사용자의 모든 HTTP 요청에 대해 로그를 남기는 간단한 필터는 다음과 같이 구현해볼 수 있다.
```java
@Slf4j
// 필터를 구현하는 경우, javax.servlet.Filter 인터페이스를 구현해주어야 한다.
public class LogFilter implements Filter {
    @Override
    public void init(FilterConfig filterConfig) throws ServletException {
        log.info("log filter init!");
    }

    @Override
    public void destroy() {
        log.info("log filter destroy...");
    }

    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
        log.info("log filter - doFilter");

        // ServletRequest는 HttpServletRequest의 부모이며 HTTP 이외의 모든 요청에 대비하였으며, 별 기능이 없으므로 다운캐스팅한다.
        HttpServletRequest httpRequest = (HttpServletRequest) request;

        String requestURI = httpRequest.getRequestURI();
        String uuid = UUID.randomUUID().toString();

        try {
            log.info("USER REQ: [{}] [{}]", requestURI, uuid);

            // 해당 메소드 호출은 필수적이며, 다음 필터가 있다면 다음 필터를 호출하고 / 없다면 서블릿을 호출한다.
            chain.doFilter(request, response);
        } catch (Exception e) {
            throw e;
        } finally {
            // 해당 로그가 출력되는 시점은 필터 체인 완료 > 서블릿 > 컨트롤러 로직까지 모두 처리된 후가 된다.
            log.info("USER RESP: [{}] [{}]", requestURI, uuid);
        }
    }
}
```
* 이 때, **`chain.doFilter();` 메소드에 의해 필터 체인에 등록된 다음 필터들이 호출된 후 서블릿과 컨트롤러 로직이 순차적으로 처리**된다.
  * **필터 체인에 어떠한 필터도 등록되지 않았다면 서블릿이 호출되며, 해당 메소드를 호출하지 않으면 요청에 대한 처리 흐름이 정상적으로 동작하지 않는다**.
  * 이 때, **`Filter` 구현체가 `ServletRequest`와 `ServletResponse`를 전달 받는 점을 이용하여 다른 구현체로 변환하는 식의 응용도 가능**하다.
* 반면, 이러한 로그는 자동으로 등록되지 않으므로 다음과 같은 `@Configuration`을 토대로 필터를 직접 등록해줄 필요가 있다.
  * 실제로는 필터를 등록하는 방법이 다양하지만, 스프링 부트를 사용하는 경우에는 아래와 같이 `FilterRegistrationBean`을 사용하게 된다.
  * 덧붙여 `@WebFilter` 등의 어노테이션으로도 필터 등록이 가능하지만, 이러한 방식의 경우 필터의 순서를 결정할 수 없으므로 사용하지 않는 것이 바람직하다.
```java
@Configuration
public class WebConfig {

    @Bean
    public FilterRegistrationBean logFilter() {
        // Spring Boot는 WAS를 함께 실행하며, 해당 빈이 존재하는 경우 필터를 함께 등록해준다.
        FilterRegistrationBean<Filter> filterRegistrationBean = new FilterRegistrationBean<>();

        // LogFilter를 필터로 등록한다.
        filterRegistrationBean.setFilter(new LogFilter());

        // 필터가 적용될 순서를 명시한다.
        filterRegistrationBean.setOrder(1);

        // 모든 URL에 대해 필터를 적용한다.
        filterRegistrationBean.addUrlPatterns("/*");

        return filterRegistrationBean;
    }
    
    // 또한, 여러 개의 필터를 등록하고자 하는 경우 상술한 메소드 형태에서 메소드의 이름만 바꾸어 새로운 FilterRegistrationBean을 빈으로 등록한다.
    // @Bean
    // public FilterRegistrationBean loginCheckFilter() { ... }
}
```
* 실무에서, 예시와 같이 동일한 요청에 대해 동일한 식별자로 로그를 남기되 이를 애플리케이션 전체에 적용하고자 하는 경우에는 로깅 라이브러리를 고려할 수 있다.
  * 예를 들어 `logback`의 MDC가 있으며, 이 경우 로그 필터 뿐만 아니라 컨트롤러나 서비스 계층까지도 이러한 기능을 적용시킬 수 있다.
# Spring DB I
## 2024-02-17 Sat
### 트랜잭션이란?
```
> 데이터를 영구히 저장하기 위해서는 파일 시스템을 활용할 수도 있겠지만, 데이터베이스는 트랜잭션을 지원한다는 점에서 메꿀 수 없는 차이가 발생한다.
```
* **트랜잭션은 직역했을 때 거래로 해석되며, DB에서도 이와 다를 바 없이 하나의 단위 거래를 안전하게 처리할 수 있도록 지원**한다.
  * 트랜잭션 안에서 처리되는 일련의 연산은 하나의 거래로 취급되어 하나라도 실패할 경우 상태를 취소하고, 모두 성공했을 때만 상태를 적용할 수 있어야 한다.
  * 이 때, **모든 작업이 성공하여 정상 상태를 DB에 반영하는 것을 `Commit`이라고 표현하는 반면 거래 이전으로 복구하는 것을 `Rollback`**이라고 한다.

## 2024-02-18 Sun
### 트랜잭션과 ACID
* 트랜잭션은 소위 ACID라는 표현으로 지칭하는 다음과 같은 특징을 갖는다.
  1. Atomicity: 트랜잭션 내의 모든 작업은 마치 하나의 작업인 것처럼 모두 실패하거나, 성공해야 한다.
  2. Consistency: 모든 트랜잭션은 DB의 무결성 제약 조건을 항상 준수하는 것으로 일관성 있는 DB 상태를 유지해야 한다.
  3. Isolation: 동시에 실행되는 다수의 트랜잭션은 서로에게 영향을 주지 않아야 하며, 동시성과 격리성 간의 trade-off는 격리 수준 옵션으로 결정한다.
  4. Durability: 트랜잭션이 성공할 경우 결과는 항상 기록되어야 하며, 설령 시스템 상 문제가 발생하더라도 로그 등을 활용하여 복구될 수 있어야 한다.
* **트랜잭션은 상술한 원자성과 일관성, 지속성을 보장하지만 격리성은 동시성과 관련된 trade-off가 발생하므로 ANSI 표준에 의해 네 단계로 다시 분류**된다.
  1. READ UNCOMMITTED
  2. READ COMMITTED
  3. REPEATABLE READ
  4. SERIALIZABLE

## 2024-02-19 Mon
### DB 연결 구조와 DB 세션
* 클라이언트가 WAS나 DB 접근 도구를 활용하여 DB에 연결을 요청할 경우 결과적으로는 커넥션을 맺게 된다.
  * 반면, **DB 내에서는 커넥션에 대응되는 세션이라는 것을 생성하는 것으로 커넥션 별 요청에 대한 처리 과정을 위임**한다.
  * 단적으로 말해, WAS 상에서 요청된 쿼리는 결과적으로 커넥션에 연결된 DB 세션이 처리하게 된다.
* **세션은 트랜잭션을 시작한 후 커밋 또는 롤백으로 완료하며, 완료 이후에는 또 다른 트랜잭션을 시작**할 수도 있다.
  * **세션은 클라이언트가 커넥션을 닫거나, DBA에 의해 명시적으로 종료되는 경우에만 종료**된다.
* 바꿔 말해, **커넥션 풀에 의해 커넥션이 N개 생성된 경우 DB 내의 세션 역시 N개가 생성되어 유지**된다.

## 2024-02-20 Tue
### 트랜잭션의 사용 방식 예제
* 삽입이나 수정 등 데이터 변경 쿼리를 실행한 경우, 그 결과를 최종적으로 반영하기 위해서는 `COMMIT` 또는 `ROLLBACK` 명령어를 입력해야 한다.
  * 만일 `COMMIT` 없이 데이터 변경 사항이 반영된 경우, 이는 `auto commit mode`가 활성화되어 자동 커밋된 것으로 이해할 수 있다.
  * 또한, **트랜잭션 안에서 명시적으로 커밋 또는 롤백하지 않은 경우에는 DB 별로 설정된 트랜잭션 타임아웃이 넘어가는 시점에 자동으로 롤백이 적용**된다.
* 이 때, **완료되지 않은 트랜잭션의 모든 데이터 변경 사항은 실제 테이블에 반영되는 것이 아닌 임시로 저장되는 것에 유념**해야 한다.
  * 이로 인해 해당 세션에서 트랜잭션을 시작한 사용자에게는 변경 내용이 보여지나, 다른 세션의 트랜잭션에서 작업하는 사용자는 이를 볼 수 없다.

## 2024-02-21 Wed
### 자동 커밋과 수동 커밋
```
> 일반적으로, 커밋과 롤백을 직접 결정하기 위해 자동 커밋 모드에서 수동 커밋 모드로 전환하는 것을 '트랜잭션을 시작한다'고 표현한다. 
```
* 일반적인 DB의 경우 자동 커밋 모드가 활성화되어 있으며, 명시적으로는 `set autocommit true;`와 같이 활성화할 수 있다.
  * 이렇듯 자동 커밋 모드가 활성화되어 있는 경우, 각 쿼리가 실행된 직후에 결과가 DB에 반영된다.
  * 즉, **DB 차원에서는 해당 모드에서 실행하는 모든 쿼리 역시 해당 세션에서 트랜잭션을 시작하고 커밋하는 과정이 암시적으로 포함되는 것**으로 볼 수 있다.
* 이러한 자동 커밋은 `COMMIT`과 `ROLLBACK`을 일일히 호출하지 않아도 되는 편리함을 제공하지만, 트랜잭션 기능을 활용할 수는 없다는 단점 역시 존재한다.
* 상술한 이유에서, 트랜잭션을 시작하기 위해서는 `set autocommit true;`와 같은 명령어를 활용하여 수동 커밋 모드를 활성화해줄 필요가 있다.
  * 일반적으로, 자동 커밋이 기본 모드로 동작하는 경우가 많기에 수동 커밋 모드를 활성화하는 것 자체를 트랜잭션의 시작으로 볼 수도 있다.
* **자동 커밋과 수동 커밋 모드는 해당 DB 세션 내에서 유효하며, 중간에 변경하는 것 역시 가능**하다.
  * **애플리케이션이 커넥션을 기반으로 DB와 상호 작용하는 과정에서, 트랜잭션을 시작한다는 것 역시 수동 커밋 모드를 활성화하는 것으로 이해**할 수 있다.

## 2024-02-22 Thu
### DB 락이란?
* 두 개의 세션에서 각각 트랜잭션을 시작했으나, 동일한 데이터를 수정하는 경우에는 트랜잭션의 원자성이 깨지기 쉽다.
  * 때문에 **이러한 문제를 방지하기 위해 트랜잭션을 시작하고 완료하기 전까지 다른 세션에서는 데이터를 수정할 수 없도록 막아줄 필요**가 있다.
* **DB는 이러한 동시성 문제를 해결하기 위해 락 개념을 제공하며, 임의의 Row에 대해 우선적으로 접근한 세션이 락을 획득**하도록 한다.
  * 이렇듯 락을 획득한 세션만이 데이터를 수정할 수 있으며, 락을 획득하지 못한 세션은 락을 획득할 때까지 대기한다.
  * 반면, 락을 획득하지 못한 세션이 무한정 대기하는 일이 없도록 락 타임 아웃을 설정할 수도 있다.
* 락을 획득한 세션이 `COMMIT`등을 통해 트랜잭션을 완료한 경우, 락은 반환되어 대기 중인 다른 세션이 획득할 수 있는 상태가 된다.
  * 이 때, 상술한 락은 별도로 필요한 작업 없이 두 트랜잭션에서 동일한 Row를 수정하고자 할 때 자동으로 적용된다.

## 2024-02-23 Fri
### FOR UPDATE를 활용한 락
* 일반적인 조회의 경우, 락을 사용할 필요가 없으므로 다른 세션에서 변경 중인 Row를 조회하는 데에는 문제가 없다.
* 그러나 **특수한 요구사항을 위해 데이터를 조회할 때에도 락을 획득하고 싶을 수 있으며, `select for update` 쿼리는 이러한 경우에 활용이 가능**하다.
  * 이 경우, 해당 쿼리를 사용하여 데이터를 조회한 세션이 락을 획득하므로 다른 세션은 트랜잭션이 완료될 때까지 데이터를 변경할 수 없게 된다.

## 2024-02-24 Sat
### 트랜잭션을 코드에 적용하기
```
> 트랜잭션은 일반적으로 비즈니스 로직이 포함되는 서비스 게층에서 시작한다.
```
* **트랜잭션을 시작하기 위해서는 커넥션이 필요하므로, 일반적인 경우 서비스 게층에서 커넥션을 생성하고 트랜잭션을 완료한 후에 커넥션을 반납**해야 한다.
  * 다시 말해, 서비스 로직 상에서 DB 트랜잭션을 활용하기 위해서는 트랜잭션 도중에 같은 커넥션이 유지되어야 한다.
  * 이렇듯 서비스 로직 상에서 같은 커넥션을 유지하기 위해서는, 가장 단순하게 커넥션 객체 자체를 파라미터로 전달하는 방법을 사용할 수 있다.
* 상술한 방법을 활용하여 코드 상에서 커넥션을 얻어 활용하는 경우, `connection.setAutoCommit(false);`와 같은 형태로 트랜잭션을 시작한다.
  * 그러나 **활용되는 커넥션은 `HikariCP`에 다시 반납되므로, 반드시 최종적으로는 다시 자동 커밋 모드를 활성화한 후에 반납**해야 한다.
* 추가적으로, 비즈니스 로직을 다루는 메소드는 비즈니스 로직만에 집중하는 것이 이상적이다.
  * 그러나 **상술한 방식을 사용할 경우, 해당 메소드에서 비즈니스 로직은 물론 트랜잭션까지 관리하게 되므로 관심사가 흩어지기 쉽다**.
  * 이렇듯 트랜잭션을 직접 관리하는 경우, 서비스 로직보다 트랜잭션을 관리하는 코드가 더 많아지며 유지보수성이 떨어지는 현상이 발생할 수 있다.

## 2024-02-25 Sun
### 트랜잭션을 직접 관리하는 경우의 문제점
```
> 서비스 계층은 가능한 한 순수한 Java로만 작성되어야 하며, 그 어떠한 기반 기술이나 계층에도 의존하지 않는 것이 바람직하다.
```
* 일반적으로, 비즈니스 로직의 순수성을 보장하고 수정을 최소화하기 위해 서비스 계층을 분리하여 코드를 작성하게 된다.
  * 이렇듯 **프리젠테이션 계층 및 리포지토리 계층으로부터 서비스 로직을 분리하는 것으로 비즈니스 로직이 특정한 기술에 의존하지 않도록 보장**할 수 있다.
  * 반면, 서비스 계층의 순수성을 지속적으로 보장하기 위해서는 비즈니스 로직 외에 특정 기술에 구현하는 코드를 작성하지는 않아야 한다.
* 그러나 **코드 상에서 트랜잭션을 직접 제어하게 될 경우, 서비스 계층에서 트랜잭션 방식에 의존하는 문제점**이 발생하게 된다.
  * 즉, DB 등의 기반 기술이 변경되었을 때 가장 순수해야 할 서비스 계층의 수정이 불가피해진다.
  * 나아가 이러한 애플리케이션의 경우, 트랜잭션 자체의 문제는 물론이고 특정 기술에 의존적인 예외가 누수되거나 반복적인 코드가 발생하기도 쉽다.
* 반면, 스프링은 서비스 계층을 순수하게 유지하면서도 트랜잭션을 관리할 수 있는 다양한 방법론과 기반 기술을 제공한다.

## 2024-02-26 Mon
### 트랜잭션 추상화하기
* JDBC를 예로 들어 `connection.setAutoCommit(false);`와 같은 식으로 트랜잭션을 적용한 경우, DB 기반 기술이 변경되면 각 코드에 수정이 가해진다.
* 이러한 **문제를 해결하기 위해서는, 객체지향의 강력한 무기 중 하나인 추상화를 활용**하면 된다!
  * 즉, 이렇게 추출해낸 인터페이스를 기반으로 각 DB 기반 기술에 맞는 구현체를 정의해서 사용해볼 수 있다.
  * 또한, 구체적인 DB 기반 기술에 의존하던 서비스 계층을 순수한 인터페이스에 의존하게 한 후 적절한 구현체를 DI하는 것으로 문제를 해결할 수 있다.
  * 이렇듯 스프링은 OOP가 제공하는 장점을 극대화하여 OCP와 DI를 준수하는, 변경에 유연하게 대응할 수 있는 기능들을 제공한다.

## 2024-02-27 Tue
### 스프링과 트랜잭션 추상화
```
> 각 기반 기술에 맞는 트랜잭션 관리 인터페이스와 구현체를 정의할 것 없이, 스프링은 이미 고도화된 트랜잭션 추상화 기술을 제공한다.
> 때문에 스프링을 사용하는 개발자는 각 DB 기반 기술에 맞는 트랜잭션 구현체를 그저 가져다 쓰기만 하는 것으로도 개발을 진행할 수 있다.
```
* **스프링이 제공하는 `PlatformTransactionManager`는 인터페이스로, 스프링 트랜잭션의 핵심에 해당**한다.
  * 이제 트랜잭션을 활용하는 서비스 로직은 단지 `PlatformTransactionManager` 인터페이스에 의존하는 것으로 다가올 변경에 대비할 수 있게 된다.
* 또한, `PlatformTransactionManager`는 크게 다음과 다음과 같은 메소드를 제공한다.
  1. `getTransaction`: 트랜잭션을 시작하기 위한 메소드에 해당한다.
  2. `commit`: 트랜잭션을 커밋으로 완료하기 위한 메소드에 해당한다.
  3. `rollback`: 트랜잭션을 롤백으로 완료하기 위한 메소드에 해당한다.
* 이 때, **트랜잭션을 시작하는 메소드의 이름이 `getTransaction`인 이유는 이미 진행 중인 트랜잭션에 참여할 수 있는 가능성을 내포하기 위함**이다.

## 2024-02-28 Wed
### PlatformTransactionManager의 여러 구현체
* 심지어 이러한 인터페이스는 개발자가 구현할 필요도 없으며, 개발 중인 애플리케이션의 DB 기반 기술에 따라 다음과 같은 구현체를 선택할 수 있다.
  1. JDBC: `DataSourceTransactionManager`
  2. JPA: `JpaTransactionManager`
  3. Hibernate: `HibernateTransactionManager`
* 물론 이 밖에도 여러 구현체가 미리 준비되어 있으므로, 개발자는 DB 기반 기술을 선택한 후에 적절한 구현체를 결정할 수 있다.

## 2024-02-29 Thu
### 트랜잭션 동기화 매니저란?
* 하나의 트랜잭션 안에서 DB와 상호작용하는 메소드를 여럿 호출해야 하는 경우, 커넥션을 유지하기 위해 모든 메소드에 커넥션을 전달할 필요가 있다.
  * 그러나 이러한 방법은 코드의 중복을 낳기 쉬우며, 유지보수성도 크게 떨어질 수 밖에 없다.
* 이에 **스프링은 트랜잭션을 추상화하는 트랜잭션 매니저 외에도 리소스를 동기화하는 역할을 담당하는 트랜잭션 동기화 매니저를 제공**한다.
* **트랜잭션 동기화 매니저는 `ThreadLocal`을 기반으로 커넥션을 동기화하며, 트랜잭션 매니저는 내부적으로 트랜잭션 동기화 매니저를 사용**한다.
  * **`ThreadLocal`을 활용하므로, 트랜잭션 동기화 매니저는 멀티스레드 환경에서도 안전하게 커넥션을 관리**할 수 있다.
  * 나아가 트랜잭션 동기화 매니저를 활용하는 것으로 커넥션은 내부적으로 획득 절차를 거치게 되므로, 더 이상 커넥션을 매개 변수로 전달할 필요가 없다.
* 나아가 코드 상에서 직접 트랜잭션 동기화 매니저를 활용하고자 하는 경우, `DataSourceUtils.getConnection(dataSource);`를 활용할 수 있다.
  * 이러한 방식은 트랜잭션 동기화 매니저가 관리하는 커넥션이 있는 경우에는 이를 반환하지만, 없는 경우에는 새로운 커넥션을 생성하여 반환한다.

## 2024-03-01 Fri
### 트랜잭션 동기화 매니저를 활용한 트랜잭션의 시작과 종료 과정
* 트랜잭션 동기화 매니저를 활용하는 트랜잭션 처리 절차는 크게 다음과 같은 흐름으로 이해할 수 있다.
  1. 트랜잭션을 시작하기 위해서는 반드시 커넥션이 필요하므로, **`트랜잭션 매니저`는 `dataSource`를 활용하여 커넥션을 획득**한다.
  2. **`트랜잭션 매니저`는 획득한 커넥션을 기반으로 트랜잭션을 시작(=`setAutoCommit(false);`)하고, 이를 `트랜잭션 동기화 매니저`에 보관**한다.
  3. 실제로 **DB와 상호작용하는 `리포지토리`는 `트랜잭션 동기화 매니저`로부터 보관된 커넥션을 가져와 사용**한다.
  4. 트랜잭션이 종료될 경우, `트랜잭션 매니저`는 `트랜잭션 동기화 매니저`에 보관된 커넥션을 기반으로 트랜잭션을 종료한다.
  5. 트랜잭션이 종료된 후, `트랜잭션 매니저`는 `트랜잭션 동기화 매니저`에 보관된 커넥션을 닫아 제거한다.

## 2024-03-02 Sat
### ThreadLocal 핥아보기
* `ThreadLocal`을 활용할 경우, 각각의 개별 스레드마다 일종의 저장소가 부여된다.
  * 이를 통해 각 스레드는 자신만의 저장소에 접근할 수 있게 되며, 저장된 데이터를 스레드 안전하게 활용할 수 있다.
  * 상술한 트랜잭션 동기화 매니저 역시 내부적으로는 `ThreadLocal`을 활용하므로, 동시에 여러 스레드가 동일한 커넥션에 접근하는 문제는 발생하지 않게 된다.

## 2024-03-03 Sun
### 트랜잭션 템플릿이란?
* 일반적인 트랜잭션 처리의 경우, 다음과 같은 과정이 매 트랜잭션마다 반복되는 경향을 보인다.
  1. try - catch 문을 시작한다.
  2. 트랜잭션을 시작한다.
  3. 비즈니스 로직을 처리한다.
  4. 3.이 성공적으로 진행된 경우, 커밋한다.
  5. 3.이 성공적으로 진행되지 않은 경우, 롤백한다.
* 결국 세 번째 과정인 **비즈니스 로직을 제외하면, 트랜잭션이 필요한 모든 서비스에서 상술한 과정이 반복적으로 발생하게 되는 문제점이 수반**된다.
  * **트랜잭션 템플릿은 상술한 문제점을 템플릿 콜백 패턴을 도입하는 것으로 해결**한다.
* **스프링은 각 반복적인 트랜잭션 코드를 제거하기 위한 템플릿 콜백 패턴을 `TransactionTemplate`이라는 클래스로 제공**한다.
  * 이 외에도 스프링이 제공하는 여러 `Template` 클래스들은 기본적으로 템플릿 콜백 패턴으로 정의된다.
* 트랜잭션 템플릿은 내부적으로 트랜잭션 매니저를 활용하며, 다음과 같은 두 개의 메소드를 제공한다.
  1. `execute`: 트랜잭션 내에서 로직을 처리한 후, 결과를 반환하는 경우에 사용한다.
  2. `executeWithoutResult`: 트랜잭션 내에서 로직을 처리한 후, 결과를 반환할 필요가 없는 경우에 사용한다.
* 또한, 트랜잭션 템플릿은 내부적으로는 트랜잭션 매니저를 활용하는 특성으로 인해 생성자 등을 통해 `PlatformTransactionManager`를 주입받아야 한다.
  * 물론 **트랜잭션 템플릿을 빈으로 등록하여 주입받아도 무방하나, 구체 클래스인 트랜잭션 템플릿의 특성상 이는 상대적으로 유연성이 떨어지는 방법**에 속한다.
* 이 때, **트랜잭션 템플릿은 `Unchecked Exception`에 대해서는 롤백하지만 `Checked Exception`에 대해서는 커밋하는 점에 주의**해야 한다.
  * 이는 트랜잭션 템플릿의 설계 결함이 아닌, 스프링이 트랜잭션에 대해 가져가는 일종의 규칙에 해당한다.

## 2024-03-04 Mon
### 트랜잭션 템플릿의 장단점
```
> 서비스 계층에 비즈니스 로직 외에 다른 코드가 포함되는 순간, 그 만큼 유지보수성은 낮아지게 된다.
```
* 트랜잭션 템플릿을 도입할 경우, 코드 상에서 트랜잭션을 처리하기 위해 반복되는 로직들을 효율적으로 제거할 수 있다.
* 그러나 **트랜잭션 템플릿을 활용하더라도, 여전히 서비스 게층이 비즈니스 로직 외에도 트랜잭션을 처리하는 로직을 포함한다는 단점은 유지**된다.
  * 즉, 서비스 관점에서는 핵심적인 비즈니스 로직 외에는 모두 부가적인 기능과도 같다.
  * **부가적인 기능은 곧 또다른 관심사를 의미하게 되므로, 이러한 방식은 하나의 서비스 클래스에서 둘 이상의 관심사를 처리하는 결과를 수반**하게 된다.
  * 다시 말해, **서비스 계층에서 비즈니스 로직 외에도 트랜잭션 처리 로직을 포함하게 될 경우 그만큼 유지보수성은 낮아지게 된다**.

## 2024-03-05 Tue
### 트랜잭션 프록시란?
* 트랜잭션 템플릿을 도입할 경우 반복적인 트랜잭션 처리 코드를 제거할 수 있으나, 여전히 비즈니스 로직은 트랜잭션 처리 코드에 오염된 상태를 유지한다.
  * 스프링은 이러한 경우를 위해 AOP를 제공하며, 스프링의 트랜잭션 AOP를 토대로 프록시를 도입하는 것으로 모든 문제를 깔끔하게 해결할 수 있게 된다.
* 프록시를 도입하지 않는 경우, 상술한 바와 같이 서비스 계층에서 비즈니스 로직을 시작하기 전과 완료 후에 각각 트랜잭션을 처리하는 로직을 작성하게 된다.
* 반면 **프록시를 도입할 경우, 서비스 계층의 비즈니스 로직에 대한 호출은 프록시 객체가 대신하게 되며 프록시가 트랜잭션을 처리**하게 된다.
  * 즉, 프록시 없이는 서비스 계층에 비즈니스와 트랜잭션 로직이 섞이지만 프록시를 도입할 경우 트랜잭션 로직에 대한 책임을 위임할 수 있다.
  * 이를 기반으로 **서비스 계층에는 더 이상 트랜잭션 로직이 남지 않고, 순수한 비즈니스 로직만**이 남게 된다.

## 2024-03-06 Wed
### 스프링과 트랜잭션 AOP
```
> 스프링이 제공하는 트랜잭션 AOP를 활용하는 것으로 순수한 서비스 게층으로부터 트랜잭션 처리 로직을 제거할 수 있게 된다.
> 개발자는 단지 @Transactional 어노테이션을 명시하는 것으로 손쉽게 트랜잭션을 처리할 수 있으며, 나머지는 스프링의 트랜잭션 AOP가 자동으로 처리한다.
```
* 상술한 프록시 개념은 스프링이 제공하는 AOP를 기반으로 손쉽게 개발할 수 있으나, 스프링은 기본적으로 트랜잭션 AOP를 처리하기 위한 모든 기능을 제공한다.
  * 다시 말해, 스프링 부트를 사용할 경우 트랜잭션 AOP를 처리하기 위해 필요한 모든 스프링 빈이 자동 등록된다.
  * 더 자세히는 스프링의 트랜잭션 AOP를 적용하기 위해 반드시 필요한 어드바이저와 어드바이스 및 포인트컷이 스프링 컨테이너에 자동 등록된다.
* 개발자는 트랜잭션 AOP가 필요한 로직에 `@Transactional` 어노테이션을 명시하는 것으로 스프링이 제공하는 트랜잭션 프록시를 자동으로 적용받을 수 있다.
  * 해당 어노테이션은 기본적으로 메소드에 명시하지만, 해당 클래스가 외부로 노출하는 모든 `public` 메소드에 적용하기 위해 클래스에 할당할 수도 있다.
* 이렇듯 스프링이 제공하는 AOP를 활용하는 경우, 필요한 모든 것이 스프링 컨테이너에 등록되어 있어야 함은 물론 사용 측면에서도 등록된 객체들을 사용해야 한다.
  * 예를 들어 트랜잭션 AOP는 스프링 컨테이너에 등록된 `PlatformTransactionManager`를 활용하므로 이 역시 스프링 빈에 등록이 되어 있어야 한다.

## 2024-03-07 Thu
### 트랜잭션 프록시의 동작 원리
* 스프링은 `@Transactional` 어노테이션이 명시된 클래스에 대해 `CGLIB` 라이브러리를 활용한 프록시를 생성한 후, 컨테이너에 등록한다.
* 트랜잭션 프록시는 내부적으로 트랜잭션 매니저를 주입받은 후, 필요한 시점에 트랜잭션을 시작한다.
  * 트랜잭션 매니저는 데이터 소스를 기반으로 커넥션을 획득한 후, 트랜잭션을 시작하기 위해 `autoCommit`을 false로 설정한 후 동기화 매니저에 보관한다.
* 트랜잭션 프록시는 실제 로직을 호출해야할 때 프록시 대상 서비스를 호출하며, 리포지토리 등 데이터 접근 로직에서는 동기화 매니저에 보관된 커넥션을 활용한다.

## 2024-03-08 Fri
### 선언적 트랜잭션 관리 기법과 프로그래밍적 트랜잭션 관리 기법
* 상술한 방식과 같이 `@Transactional` 어노테이션을 명시하는 것은 선언적 트랜잭션 관리 기법에 해당한다.
* 반면, 트랜잭션 템플릿 또는 트랜잭션 매니저를 활용하여 트랜잭션을 처리하는 코드를 직접 작성하는 방식은 프로그래밍적 트랜잭션 관리 기법에 해당한다.
* **실무에서는 대부분의 경우에 선언적 트랜잭션 관리 기법이 편리하기 때문에 `@Transactional` 어노테이션을 주로 활용**하게 된다.
  * 반면, 프로그래밍적 트랜잭션 관리 기법은 테스트를 위해 선택적으로 고려될 수 있다.

## 2024-03-09 Sat
### 스프링 부트와 자동 리소스 등록
```
> 데이터 소스와 트랜잭션 매니저는 직접 스프링 빈으로 등록하는 방식 보다는 스프링 부트가 제공하는 자동 리소스 등록 기능을 활용하는 것이 편리하다. 
```
* 스프링 부트의 등장 이전에는 데이터 소스와 트랜잭션 매니저를 개발자가 직접 빈으로 등록하곤 했으며, 이 과정에서 XML이 사용되기도 했다.
* 그러나 **스프링 부트의 등장으로 인해 많은 부분이 자동화되었으며, 데이터 소스와 트랜잭션 매니저 역시 설정을 기반으로 자동 등록**될 수 있게 되었다.


## 2024-03-10 Sun
### 데이터 소스의 자동 등록
* 스프링 부트는 데이터 소스를 `dataSource`라는 이름의 스프링 빈으로 자동 등록하지만, 개발자가 직접 데이터 소스를 등록한 경우에는 자동 등록하지 않는다.
* 이 때, **스프링 빈으로 자동 등록되는 데이터 소스는 `application.properties` 파일의 속성을 기반으로 자동 생성**된다.
  * 반면, `spring.datasource.url` 속성이 누락된 경우에는 기본적으로 내장 메모리 DB 생성을 시도한다.
```properties
spring.datasource.url=jdbc:h2:tcp://localhost/~/test
spring.datasource.username=sa
spring.datasource.password=my-secure-password
```
* **스프링 부트는 기본적으로 커넥션 풀을 제공하는 `HikariDataSource`를 자동 생성하며, 이와 관련된 설정 역시 설정 파일로 관리**할 수 있다.

## 2024-03-11 Mon
### 트랜잭션 매니저의 자동 등록
* 스프링 부트는 적절한 `PlatformTransactionManager` 역시 `transactionManager`라는 이름의 스프링 빈으로 자동 생성 후 컨테이너에 등록한다.
  * 물론 데이터 소스와 마찬가지로, 개발자가 트랜잭션 매니저 빈을 직접 생성하여 등록한 경우에는 자동 등록하지 않는다.
  * 이렇듯 **스프링 부트의 자동 등록 메커니즘은 기본적으로 개발자가 동일한 빈을 직접 생성한 경우에는 동작하지 않는다**.
* 이 때, **어떤 구체 클래스를 자동 생성되어 스프링 빈으로 등록할지는 현재 등록된 라이브러리를 기준으로 판단**한다.
  * 예를 들어, `JDBC` 기반 기술을 사용할 경우 `DataSourceTransactionManager`를 빈으로 등록한다.
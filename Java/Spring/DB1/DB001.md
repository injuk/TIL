# Spring DB I
## 2024-01-30 Tue
### 데이터 접근 기술의 어려움
* 데이터 접근 기술에 대한 학습을 어렵게 하는 요인은 크게 다음과 같다.
  1. 단순히 데이터베이스에 대한 기반 지식이 얕다
  2. SQL 래퍼나 ORM 등 데이터 접근 기술이 너무 다양하다
  3. 데이터 접근 기술의 역사 자체가 너무 오래되었다
* 상술한 이유에서 최근의 백엔드 개발자들은 내부 동작 원리는 모르는 채로 데이터 접근 기술의 사용법만 익히게 되곤 한다.

## 2024-01-31 Wed
### JDBC란?
* 현대적인 애플리케이션은 대부분 DB를 활용하여 중요한 데이터를 저장하게 되며, 이 과정에서 항상 다음과 같은 과정을 거치게 된다.
  1. 커넥션 연결: TCP/IP를 기반으로 커넥션을 연결한다.
  2. SQL 전달: 애플리케이션은 DB가 이해할 수 있는 SQL을 1.에서 연결한 커넥션을 통해 전달한다.
  3. 결과 반환: DB는 애플리케이션이 전달한 SQL을 실행하고, 그 결과를 응답한다.
* 그러나 **초기에는 수십 개 이상이 존재하는 모든 관계형 DB에 대해 상술한 세 가지 절차를 수행하는 방법이 모두 달랐다는 어려움이 존재**했다.
  * 이로 인해 개발자는 상술한 세 절차를 언제나 자신이 사용하는 DB에 맞도록 학습했어야 했으며, DB가 변경되는 경우 모든 코드까지도 수정이 필요했다.
* **JDBC는 상술한 배경에서 탄생하였으며, Java 진영의 표준 역할을 수행**하게 되었다.

## 2024-02-01 Thu
### JDBC 표준 인터페이스와 구현체
```
> JDBC는 인터페이스인 반면, Driver는 JDBC의 구현체이다.
```
* **JDBC는 Java 애플리케이션에서 DB에 접속할 수 있도록 하는 API이며, DB로부터 데이터를 쿼리하는 등 상호작용할 수 있는 방법을 제공**한다.
  * 덧붙여 JDBC는 `Java DataBase Connectivity`에 대한 두문자어에 해당한다.
* 이 때, **JDBC는 상술한 세 절차를 각각 다음과 같은 표준 인터페이스로 정의**한다.
  1. `java.sql.Connection`
  2. `java.sql.Statement`
  3. `java.sql.ResultSet`
* 이로 인해 **개발자는 인터페이스인 JDBC에만 사용해도 되는 반면, 실제 애플리케이션이 동작하기 위해서는 각 DB에 맞는 구현체가 필요**하게 된다.
  * 때문에 오라클이나 MySQL 등의 **DB 벤더사들은 모두 적절한 구현체를 라이브러리 형태로 제공하며, 이를 `JDBC Driver`라고 지칭**한다.
  * 예를 들어, 오라클 DB에 접근하기 위해 사용할 수 있는 JDBC 구현체는 `Oracle JDBC Driver`가 된다.

## 2024-02-02 Fri
### JDBC로 인해 해결되는 문제들과 한계
* JDBC라는 표준 인터페이스가 등장함에 따라 다음과 같은 문제는 해결될 수 있다.
  1. 개발자가 각 관계형 DB에 맞는 절차 수행 방식을 학습해야하는 문제
  2. DB를 변경할 때 애플리케이션 코드까지 변경해야하는 문제
* 그러나 여전히 각 DB 별 SQL 사용 방식이나 데이터 타입이 일부 다르므로, 특수한 요구상황에 대해서는 JDBC만으로 문제를 해결할 수 없는 한계 역시 존재한다.

## 2024-02-03 Sat
### JDBC 기반의 데이터 접근 기술
* JDBC는 출시된지 20년이 넘은, 매우 오래된 기술이며 사용 방법도 복잡한 편에 속한다.
  * 때문에, **최근의 데이터 접근 기술은 JDBC를 직접 사용하기보다는 별도의 라이브러리 등을 통해 이를 간접적으로 사용하도록 지원하는 형태**를 갖는다.
  * 실무에서도 복잡한 JDBC를 직접 사용하기보다는 별도의 데이터 접근 기술을 사용하는 것이 권장된다.
* 이 때, JDBC 기반의 데이터 접근 기술은 크게 다음과 같이 분류된다.
  1. SQL 매퍼: MyBatis나 JdbcTemplate이 이러한 분류에 속한다.
  2. ORM: JPA가 이러한 분류에 속하며, 표준 인터페이스인 JPA의 구현체로는 하이버네이트나 이클립스 링크 등이 존재한다.
* 일반적으로 **SQL 매퍼는 JDBC를 편리하게 사용하도록 지원하며, 반복적인 코드를 제거해주는 반면 개발자가 직접 SQL을 작성해야한다는 불편함이 존재**한다.
* 반면 ORM의 경우, **객체를 관계형 DB의 엔티티와 매핑하면서도 개발자가 반복적인 SQL을 작성할 필요가 없도록 동적으로 SQL을 작성하여 실행**한다.
  * 이러한 **ORM을 사용할 경우, 각각의 DB마다 SQL이 달라지는 문제 역시 해결**될 수 있다.

## 2024-02-04 Sun
### SQL 매퍼와 ORM의 비교
* SQL 매퍼의 경우, 개발자가 직접 SQL을 작성하는 것으로 번거로운 작업을 SQL 매퍼가 대리할 수 있으므로 진입장벽이 낮은 편에 속한다.
* 반면, ORM의 경우 SQL을 직접 작성하지 않으므로 생산성을 크게 높이는 대신 진입장벽은 높은 편에 속한다.
* 중요한 것은 **모든 데이터 접근 기술이 내부적으로는 JDBC를 사용한다는 점이며, 이로 인해 JDBC를 직접 사용하지 않더라도 동작 원리를 파악할 필요**가 있다.

## 2024-02-05 Mon
### JDBC 드라이버 매니저란?
```
> JDBC를 활용하여 연결하는 경우, 필요한 드라이버 구현체는 그저 라이브러리에만 포함되어만 있으면 드라이버 매니져에 의해 자동으로 인식된다.
```
* DB 커넥션을 예로 들었을 때, JDBC 패키지에는 `java.sql.Connection` 인터페이스가 정의되며 각 관계형 DB 벤더들은 이를 구현하는 구현체를 제공한다.
  * 결국 JDBC가 제공하는 인터페이스에 맞추어 애플리케이션을 개발할 수 있으나, 그럼에도 어떤 구현체가 자동으로 주입되는지는 이해할 필요가 있다.
* JDBC의 **드라이버 매니저는 라이브러리에 등록된 DB 드라이버 구현체들을 관리하며, 커넥션을 얻는 기능을 다음과 같이 간단한 형태로 사용**할 수 있다.
  * 이렇듯 애플리케이션에서 커넥션이 필요할 경우 `getConnection()`을 호출하며, 드라이버 매니저는 라이브러리에 등록된 드라이버 목록을 자동으로 인식한다.
  * 때문에 **DB에 대한 연결을 시도할 경우, 드라이버 매니저는 각 드라이버에 URL과 사용자 정보 등 추가 정보를 제공하여 커넥션 획득이 가능한지 확인**한다.
```java
public class DbConnectionHelper {
  public static Connection getConn() {
      Connection connection = DriverManager.getConnection("url", "username", "pw");
      return connection;
  }
}
```
* 이 때, **각 드라이버 구현체는 URL 정보를 확인하여 자신이 처리할 수 있는 요청인지 검증**한다.
  * 예를 들어 `jdbc:h2`로 시작하는 접두사를 갖는 URL의 경우, H2 드라이버는 커넥션을 생성하여 클라이언트에게 반환할 수 있다.
  * 반면 **MySQL 드라이버는 처리할 수 없다는 결과를 반환하며 연결 자체를 수행하지 않고, 다음 드라이버에게 검증 순서**가 넘어가게 된다.

## 2024-02-06 Tue
### PreparedStatement와 Statement
* **PreparedStatement의 경우, Statement의 자식으로서 `?` 기호를 활용한 파라미터 바인딩을 지원**한다.
  * 이 때, **SQL 인젝션 공격을 예방하기 위해서는 반드시 PreparedStatement를 활용하여 파라미터 바인딩을 적용**해주어야 한다.

## 2024-02-07 Wed
### Connection과 Statement, 그리고 ResultSet에 대한 예외 처리
* Connection 등은 실제로 DB와 TCP/IP 연결을 맺고 진행되므로, 제 때 닫아주지 않는다면 불필요한 메모리 점유가 발생하기 쉽다.
  * 때문에 사용이 끝난 객체에 대해서는 연결을 종료할 수 있도록, 항상 finally 절에서 close() 메소드를 호출해주는 것이 바람직하다.
  * **close()의 경우 `SQLException`을 던지지만 이를 잡아 처리할 방법은 딱히 없으므로, 일반적으로는 로그만을 남기고 추가 처리를 하지 않는 편**이다.
* 반면, **Connection과 Statement 및 ResultSet은 항상 역순으로 close()를 호출하여 닫아주도록 구현**해야 한다.
  * 즉, 세 인터페이스 중 ResultSet에 대한 close() 메소드 호출이 가장 우선시 되어야 한다.
# Spring DB I
## 2024-01-30 Tue
### 데이터 접근 기술의 어려움
* 데이터 접근 기술에 대한 학습을 어렵게 하는 요인은 크게 다음과 같다.
  1. 단순히 데이터베이스에 대한 기반 지식이 얕다
  2. SQL 래퍼나 ORM 등 데이터 접근 기술이 너무 다양하다
  3. 데이터 접근 기술의 역사 자체가 너무 오래되었다
* 상술한 이유에서 최근의 백엔드 개발자들은 내부 동작 원리는 모르는 채로 데이터 접근 기술의 사용법만 익히게 되곤 한다.

## 2024-01-31 Wed
### JDBC란?
* 현대적인 애플리케이션은 대부분 DB를 활용하여 중요한 데이터를 저장하게 되며, 이 과정에서 항상 다음과 같은 과정을 거치게 된다.
  1. 커넥션 연결: TCP/IP를 기반으로 커넥션을 연결한다.
  2. SQL 전달: 애플리케이션은 DB가 이해할 수 있는 SQL을 1.에서 연결한 커넥션을 통해 전달한다.
  3. 결과 반환: DB는 애플리케이션이 전달한 SQL을 실행하고, 그 결과를 응답한다.
* 그러나 **초기에는 수십 개 이상이 존재하는 모든 관계형 DB에 대해 상술한 세 가지 절차를 수행하는 방법이 모두 달랐다는 어려움이 존재**했다.
  * 이로 인해 개발자는 상술한 세 절차를 언제나 자신이 사용하는 DB에 맞도록 학습했어야 했으며, DB가 변경되는 경우 모든 코드까지도 수정이 필요했다.
* **JDBC는 상술한 배경에서 탄생하였으며, Java 진영의 표준 역할을 수행**하게 되었다.

## 2024-02-01 Thu
### JDBC 표준 인터페이스와 구현체
```
> JDBC는 인터페이스인 반면, Driver는 JDBC의 구현체이다.
```
* **JDBC는 Java 애플리케이션에서 DB에 접속할 수 있도록 하는 API이며, DB로부터 데이터를 쿼리하는 등 상호작용할 수 있는 방법을 제공**한다.
  * 덧붙여 JDBC는 `Java DataBase Connectivity`에 대한 두문자어에 해당한다.
* 이 때, **JDBC는 상술한 세 절차를 각각 다음과 같은 표준 인터페이스로 정의**한다.
  1. `java.sql.Connection`
  2. `java.sql.Statement`
  3. `java.sql.ResultSet`
* 이로 인해 **개발자는 인터페이스인 JDBC에만 사용해도 되는 반면, 실제 애플리케이션이 동작하기 위해서는 각 DB에 맞는 구현체가 필요**하게 된다.
  * 때문에 오라클이나 MySQL 등의 **DB 벤더사들은 모두 적절한 구현체를 라이브러리 형태로 제공하며, 이를 `JDBC Driver`라고 지칭**한다.
  * 예를 들어, 오라클 DB에 접근하기 위해 사용할 수 있는 JDBC 구현체는 `Oracle JDBC Driver`가 된다.

## 2024-02-02 Fri
### JDBC로 인해 해결되는 문제들과 한계
* JDBC라는 표준 인터페이스가 등장함에 따라 다음과 같은 문제는 해결될 수 있다.
  1. 개발자가 각 관계형 DB에 맞는 절차 수행 방식을 학습해야하는 문제
  2. DB를 변경할 때 애플리케이션 코드까지 변경해야하는 문제
* 그러나 여전히 각 DB 별 SQL 사용 방식이나 데이터 타입이 일부 다르므로, 특수한 요구상황에 대해서는 JDBC만으로 문제를 해결할 수 없는 한계 역시 존재한다.

## 2024-02-03 Sat
### JDBC 기반의 데이터 접근 기술
* JDBC는 출시된지 20년이 넘은, 매우 오래된 기술이며 사용 방법도 복잡한 편에 속한다.
  * 때문에, **최근의 데이터 접근 기술은 JDBC를 직접 사용하기보다는 별도의 라이브러리 등을 통해 이를 간접적으로 사용하도록 지원하는 형태**를 갖는다.
  * 실무에서도 복잡한 JDBC를 직접 사용하기보다는 별도의 데이터 접근 기술을 사용하는 것이 권장된다.
* 이 때, JDBC 기반의 데이터 접근 기술은 크게 다음과 같이 분류된다.
  1. SQL 매퍼: MyBatis나 JdbcTemplate이 이러한 분류에 속한다.
  2. ORM: JPA가 이러한 분류에 속하며, 표준 인터페이스인 JPA의 구현체로는 하이버네이트나 이클립스 링크 등이 존재한다.
* 일반적으로 **SQL 매퍼는 JDBC를 편리하게 사용하도록 지원하며, 반복적인 코드를 제거해주는 반면 개발자가 직접 SQL을 작성해야한다는 불편함이 존재**한다.
* 반면 ORM의 경우, **객체를 관계형 DB의 엔티티와 매핑하면서도 개발자가 반복적인 SQL을 작성할 필요가 없도록 동적으로 SQL을 작성하여 실행**한다.
  * 이러한 **ORM을 사용할 경우, 각각의 DB마다 SQL이 달라지는 문제 역시 해결**될 수 있다.

## 2024-02-04 Sun
### SQL 매퍼와 ORM의 비교
* SQL 매퍼의 경우, 개발자가 직접 SQL을 작성하는 것으로 번거로운 작업을 SQL 매퍼가 대리할 수 있으므로 진입장벽이 낮은 편에 속한다.
* 반면, ORM의 경우 SQL을 직접 작성하지 않으므로 생산성을 크게 높이는 대신 진입장벽은 높은 편에 속한다.
* 중요한 것은 **모든 데이터 접근 기술이 내부적으로는 JDBC를 사용한다는 점이며, 이로 인해 JDBC를 직접 사용하지 않더라도 동작 원리를 파악할 필요**가 있다.

## 2024-02-05 Mon
### JDBC 드라이버 매니저란?
```
> JDBC를 활용하여 연결하는 경우, 필요한 드라이버 구현체는 그저 라이브러리에만 포함되어만 있으면 드라이버 매니져에 의해 자동으로 인식된다.
```
* DB 커넥션을 예로 들었을 때, JDBC 패키지에는 `java.sql.Connection` 인터페이스가 정의되며 각 관계형 DB 벤더들은 이를 구현하는 구현체를 제공한다.
  * 결국 JDBC가 제공하는 인터페이스에 맞추어 애플리케이션을 개발할 수 있으나, 그럼에도 어떤 구현체가 자동으로 주입되는지는 이해할 필요가 있다.
* JDBC의 **드라이버 매니저는 라이브러리에 등록된 DB 드라이버 구현체들을 관리하며, 커넥션을 얻는 기능을 다음과 같이 간단한 형태로 사용**할 수 있다.
  * 이렇듯 애플리케이션에서 커넥션이 필요할 경우 `getConnection()`을 호출하며, 드라이버 매니저는 라이브러리에 등록된 드라이버 목록을 자동으로 인식한다.
  * 때문에 **DB에 대한 연결을 시도할 경우, 드라이버 매니저는 각 드라이버에 URL과 사용자 정보 등 추가 정보를 제공하여 커넥션 획득이 가능한지 확인**한다.
```java
public class DbConnectionHelper {
  public static Connection getConn() {
      Connection connection = DriverManager.getConnection("url", "username", "pw");
      return connection;
  }
}
```
* 이 때, **각 드라이버 구현체는 URL 정보를 확인하여 자신이 처리할 수 있는 요청인지 검증**한다.
  * 예를 들어 `jdbc:h2`로 시작하는 접두사를 갖는 URL의 경우, H2 드라이버는 커넥션을 생성하여 클라이언트에게 반환할 수 있다.
  * 반면 **MySQL 드라이버는 처리할 수 없다는 결과를 반환하며 연결 자체를 수행하지 않고, 다음 드라이버에게 검증 순서**가 넘어가게 된다.

## 2024-02-06 Tue
### PreparedStatement와 Statement
* **PreparedStatement의 경우, Statement의 자식으로서 `?` 기호를 활용한 파라미터 바인딩을 지원**한다.
  * 이 때, **SQL 인젝션 공격을 예방하기 위해서는 반드시 PreparedStatement를 활용하여 파라미터 바인딩을 적용**해주어야 한다.

## 2024-02-07 Wed
### Connection과 Statement, 그리고 ResultSet에 대한 예외 처리
* Connection 등은 실제로 DB와 TCP/IP 연결을 맺고 진행되므로, 제 때 닫아주지 않는다면 불필요한 메모리 점유가 발생하기 쉽다.
  * 때문에 사용이 끝난 객체에 대해서는 연결을 종료할 수 있도록, 항상 finally 절에서 close() 메소드를 호출해주는 것이 바람직하다.
  * **close()의 경우 `SQLException`을 던지지만 이를 잡아 처리할 방법은 딱히 없으므로, 일반적으로는 로그만을 남기고 추가 처리를 하지 않는 편**이다.
* 반면, **Connection과 Statement 및 ResultSet은 항상 역순으로 close()를 호출하여 닫아주도록 구현**해야 한다.
  * 즉, 세 인터페이스 중 ResultSet에 대한 close() 메소드 호출이 가장 우선시 되어야 한다.

## 2024-02-08 Thu
### DB 드라이버를 활용한 커넥션 생성 과정
* DB의 커넥션을 획득하고자 하는 경우, 일반적으로 다음과 같은 과정을 거치게 된다.
  1. 애플리케이션 로직이 DB 드라이버를 통해 커넥션을 조회한다.
  2. DB 드라이버는 실제 DB와 TCP/IP 커넥션을 시도한다.
  3. DB 드라이버는 TCP/IP 커넥션이 연결된 경우, ID나 PW 등 인증정보 및 기타 정보를 DB에 전달한다.
  4. DB는 ID와 PW 등의 인증정보를 기반으로 내부적인 인증 절차를 완료한 후, 내부적으로 DB 세션을 생성한다.
  5. 이 시점에서야 비로소 DB는 커넥션 생성이 완료되었다는 응답을 반환한다.
  6. 완료 응답을 수신한 DB 드라이버는 커넥션 객체를 생성하여 클라이언트인 애플리케이션 로직에 반환한다.
* 이렇듯 **드라이버 매니저를 활용하여 커넥션을 획득할 경우, 매 커넥션 조회 시점마다 DB 커넥션을 새로이 획득**하게 된다.
  * 물론 **매번 커넥션을 새로 생성하는 과정은 복잡하며, 시간 등의 비용도 많이 소모**하게 된다.
  * 또한, 상술한 과정을 거쳐 매번 커넥션을 새로 생성하는 시간은 고스란히 클라이언트의 로직 처리 시간에 추가되므로 사용자 경험 역시 떨어트릴 수 밖에 없다.

## 2024-02-09 Fri
### 커넥션 풀이란?
```
> 커넥션 풀이란 상술한 커넥션 문제를 해결하기 위한 방법이며, 단지 커넥션을 미리 여럿 생성해두고 재사용하는 것에 지나지 않는다.
> 커넥션 풀을 활용할 경우, TCP/IP 연결 기반의 커넥션을 맺고 DB 인증 및 세션을 생성하는 모든 시간이 단축되므로 단지 SQL 처리 시간만 소요되게 된다.
```
* **커넥션 풀을 사용할 경우, 애플리케이션을 시작하는 시점에 필요한 만큼 커넥션을 미리 확보하여 풀에 보관**하게 된다.
  * 이를 통해 **커넥션 풀에 포함된 커넥션은 이미 TCP/IP를 기반으로 DB와 커넥션 연결을 마친 상태이므로 즉시 SQL을 전달할 수 있는 상태에 해당**한다.
  * 이 때, 커넥션의 개수는 서비스의 특징 및 서버의 사양에 따라 다르지만 기본적으로 10개로 설정된다.
* 커넥션 풀을 사용할 경우, 애플리케이션 로직이 DB와 상호작용하는 순서는 다음과 같이 변경된다.
  1. **애플리케이션 로직은 더 이상 DB 드라이버를 기반으로 새로운 커넥션을 조회하지 않으며, 바로 커넥션 풀에 커넥션을 요청**하게 된다.
  2. 커넥션 풀에 커넥션을 요청할 경우, 커넥션 풀은 유휴 커넥션 중 하나를 반환한다.
  3. 반환된 **커넥션은 객체 참조로 애플리케이션 로직에서 활용하게 되며, SQL을 전달하는 등의 상호작용을 마친 경우 커넥션은 다시 커넥션 풀에 반환**된다.
* 이 때, **중요한 것은 애플리케이션 로직이 커넥션 풀로부터 반환받은 커넥션의 사용을 마친 경우 커넥션을 종료하는 대신 다시 풀에 반환한다는 점**에 있다.
  * 당연스럽게도, 커넥션을 종료할 경우 애써 맺어둔 모든 TCP/IP 연결이 끊어지게 되므로 커넥션 풀을 사용하는 의미가 없어지게 된다.

## 2024-02-10 Sat
### 커넥션 풀 - 결론
```
> 커넥션 풀이 제공하는 이점은 매우 크기에 실무에서는 커넥션 풀을 기본으로 사용하게 된다.
> 커넥션 풀은 주로 오픈소스 프로젝트를 활용하게 되며, 최근의 실무에서는 고민할 필요 없이 HikariCP를 선택하는 것이 일반적이다.
```
* 적절한 커넥션 풀의 크기는 서버나 DB 사양에 따라 달라지므로, 성능 테스트를 기반으로 결정되어야 한다.
* **커넥션 풀은 서버당 최대 커넥션 수를 제한하는 것으로, DB에 커넥션이 무한정 생성되는 것을 방지하는 간접적인 보호 효과도 제공**한다.
* **커넥션 풀은 개념적으로 단순하므로 직접 구현할 수도 있으나, 뛰어난 오픈소스 커넥션 풀이 많기에 오픈소스를 사용하는 것이 권장**된다.
  * 예를 들어, `commons-dbcp2`나 `tomcat-jdbc pool` 및 `HikariCP` 등의 오픈소스 커넥션 풀 프로젝트가 존재한다.
* 실무에서는 성능과 편의성 측면에서 `HikariCP`를 주로 사용하며, 이는 스프링 부트 2.0부터 기본 커넥션 풀로 지정된 오픈소스이기도 하다.
  * **성능 및 안전성 측면에서 이미 검증이 마쳐진 커넥션 풀이므로, 레거시 애플리케이션이 아닌 이상 고민할 필요 없이 `HikariCP`를 선택해도 무방**하다.

## 2024-02-11 Sun
### DataSource란?
```
> javax.sql.DataSource는 인터페이스이며, 커넥션을 획득하는 방법을 추상화한다.
```
* 상술한 바와 같이, 커넥션을 획득하는 방법은 JDBC의 드라이버 매니저를 활용하거나 커넥션 풀을 사용하는 방법 등 다양하다.
  * 예를 들어 드라이버 매니저를 기반으로 항상 새로운 커넥션을 생성하거나, `DBCP2` 또는 `HikariCP`의 커넥션 풀을 통해 생성할 수도 있다.
  * 그러나 **이러한 다양성으로 인해, 커넥션 획득 방식을 고정하게 되면 추후 방식을 변경하는 과정에서 애플리케이션 로직을 수정하게 될 가능성이 높다**.
* 이러한 이유에서 **`DataSource`가 탄생하게 되었으며, `DataSource`는 그저 커넥션을 획득하는 방법을 추상화하는 인터페이스에 불과**하다.
  * 해당 인터페이스는 단지 커넥션을 획득하는 방법만을 추상화하며, 애플리케이션은 이제 `DataSource.getConnection()` API에만 의존하게 된다.

## 2024-02-12 Mon
### DataSource - 결론
* **대부분의 커넥션 풀은 이미 `DataSource`를 구현하므로, 개발자는 각 커넥션 풀의 구현체에 직접 의존하는 대신 인터페이스에 의존**할 수 있다.
  * 이로 인해, 단지 애플리케이션이 `DataSource`에 의존하도록 코드를 구현하는 것으로 커넥션을 획득하면서 구현체를 변경할 수 있는 여지를 남길 수 있다.
* 반면, `DriverManager`는 `DataSource` 인터페이스를 사용하지 않으므로 `DriverManager`는 직접 사용해줄 필요가 있다.
  * 그러나 스프링은 이미 이러한 요구 사항에 대비하기 위해 `DriverManagerDataSource`라는 구현체를 제공한다.

## 2024-02-13 Tue
### DataSource를 사용하는 구현의 장점
* **`DriverManager` 등이 아닌 `DataSource`를 사용하는 것으로, 커넥션의 설정과 사용 로직을 분리**할 수 있게 된다.
  * 예를 들어, `DriverManager`를 사용하는 경우 매 번 DB 커넥션 정보를 전달하여 커넥션을 획득해야 한다.
  * 그러나 `DataSource`는 최초 호출시 커넥션 정보를 전달하며, 이후에는 `getConnection()` API를 기반으로 커넥션을 사용할 수 있게 된다.
* 이러한 **책임의 분리를 기반으로, 커넥션을 사용하는 모든 애플리케이션 로직은 설정에 대한 정보는 모른 채 단지 사용 방법에만 의존**할 수 있게 된다.
  * 나아가, 커넥션 설정 정보를 한 곳에 모아둔다는 점에서 관리 용이성 역시 향상될 수 있다.

## 2024-02-14 Wed
### DataSource를 활용한 커넥션 풀 사용
* `HikariCP`를 예로 들어, 커넥션 풀로부터 커넥션을 획득하기 위해서는 `HikariDataSource();` 구현체를 아래와 같이 활용할 수 있다.
  * 스프링의 경우, JDBC를 사용하게 되면 `HikariDataSource` 의존성 역시 자동으로 임포트된다.
```java
class HikariConnectionPoolTest {
    @Test
    void test() throws SQLException, InterruptedException {
      HikariDataSource ds = new HikariDataSource();
      ds.setJdbcUrl("url");
      ds.setUsername("username");
      ds.setPassword("password");
      
      // 풀 크기와 이름은 선택적으로 설정할 수 있다.
      ds.setMaximumPoolSize(10);
      ds.setPoolName("myTestPool");
      
      Connection conn = getConnectionFrom(ds);
      log.info("conn={}", conn);
      
      // 일반적으로 커넥션 풀 생성을 확인하기 위해서는 하술할 이유에 의해 Thread.sleep API를 호출해주어야 한다.
      // Thread.sleep(1000);
    }
    
    Connection getConnectionFrom(DataSource dataSource) throws SQLException {
        return dataSource.getConnection();
    }
}
```
* 이 때, **커넥션 풀 내적으로 커넥션을 생성하는 작업은 애플리케이션의 실행 속도에 영향을 주지 않기 위해 별도 스레드에서 동작하는 점에 유의**해야 한다.
  * 이 경우 커넥션을 생성하는 작업은 `{PoolName} connection addert` 스레드가 처리하며, 별도의 스레드를 기반으로 커넥션 풀을 채우게 된다.
  * 상술한 테스트의 경우, `Thread.sleep(1000);` API를 호출하지 않는다면 커넥션 풀에서 커넥션이 생성되는 것을 확인하기 전에 테스트가 종료되기 쉽다.
* `getConnection()` 등의 커넥션 획득 요청에 대해, 커넥션 풀 내부적으로 아직 필요한 만큼의 커넥션이 생성되지 않았다면 생성이 될 때까지 대기하게 된다.

## 2024-02-16 Fri
### 커넥션 풀이 관리하는 커넥션의 상태
* 커넥션 풀로부터 반환된 커넥션을 사용할 경우 `active` 상태가 되며, 커넥션의 사용을 종료하였을 때에는 반환하여 `idle` 상태로 만들어줄 필요가 있다.
* 반면, 커넥션 풀 이상의 요청이 발생했을 경우 커넥션을 대기하는 상태는 `waiting`으로 표시된다.
  * 이렇듯 풀이 가득 찬 상태의 경우, 기본적으로 유휴 커넥션이 확보될 때까지 이후의 요청들은 모두 블록된다.
  * **기본적인 설정의 경우 타임아웃은 30초로 세팅이 되지만, 운영 환경의 경우 이는 고객 경험을 크게 떨어트릴 수 있기 때문에 짧게 설정하는 것이 권장**된다.

## 2024-02-17 Sat
### 트랜잭션이란?
```
> 데이터를 영구히 저장하기 위해서는 파일 시스템을 활용할 수도 있겠지만, 데이터베이스는 트랜잭션을 지원한다는 점에서 메꿀 수 없는 차이가 발생한다.
```
* **트랜잭션은 직역했을 때 거래로 해석되며, DB에서도 이와 다를 바 없이 하나의 단위 거래를 안전하게 처리할 수 있도록 지원**한다.
  * 트랜잭션 안에서 처리되는 일련의 연산은 하나의 거래로 취급되어 하나라도 실패할 경우 상태를 취소하고, 모두 성공했을 때만 상태를 적용할 수 있어야 한다.
  * 이 때, **모든 작업이 성공하여 정상 상태를 DB에 반영하는 것을 `Commit`이라고 표현하는 반면 거래 이전으로 복구하는 것을 `Rollback`**이라고 한다.

## 2024-02-18 Sun
### 트랜잭션과 ACID
* 트랜잭션은 소위 ACID라는 표현으로 지칭하는 다음과 같은 특징을 갖는다.
  1. Atomicity: 트랜잭션 내의 모든 작업은 마치 하나의 작업인 것처럼 모두 실패하거나, 성공해야 한다.
  2. Consistency: 모든 트랜잭션은 DB의 무결성 제약 조건을 항상 준수하는 것으로 일관성 있는 DB 상태를 유지해야 한다.
  3. Isolation: 동시에 실행되는 다수의 트랜잭션은 서로에게 영향을 주지 않아야 하며, 동시성과 격리성 간의 trade-off는 격리 수준 옵션으로 결정한다.
  4. Durability: 트랜잭션이 성공할 경우 결과는 항상 기록되어야 하며, 설령 시스템 상 문제가 발생하더라도 로그 등을 활용하여 복구될 수 있어야 한다.
* **트랜잭션은 상술한 원자성과 일관성, 지속성을 보장하지만 격리성은 동시성과 관련된 trade-off가 발생하므로 ANSI 표준에 의해 네 단계로 다시 분류**된다.
  1. READ UNCOMMITTED
  2. READ COMMITTED
  3. REPEATABLE READ
  4. SERIALIZABLE

## 2024-02-19 Mon
### DB 연결 구조와 DB 세션
* 클라이언트가 WAS나 DB 접근 도구를 활용하여 DB에 연결을 요청할 경우 결과적으로는 커넥션을 맺게 된다.
  * 반면, **DB 내에서는 커넥션에 대응되는 세션이라는 것을 생성하는 것으로 커넥션 별 요청에 대한 처리 과정을 위임**한다.
  * 단적으로 말해, WAS 상에서 요청된 쿼리는 결과적으로 커넥션에 연결된 DB 세션이 처리하게 된다.
* **세션은 트랜잭션을 시작한 후 커밋 또는 롤백으로 완료하며, 완료 이후에는 또 다른 트랜잭션을 시작**할 수도 있다.
  * **세션은 클라이언트가 커넥션을 닫거나, DBA에 의해 명시적으로 종료되는 경우에만 종료**된다.
* 바꿔 말해, **커넥션 풀에 의해 커넥션이 N개 생성된 경우 DB 내의 세션 역시 N개가 생성되어 유지**된다.
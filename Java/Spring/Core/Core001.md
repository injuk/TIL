# Core
## 2022-06-18 Sat

### 스프링 제대로 공부하기
* 제대로 학습하는 스프링은 단순히 스프링의 핵심 기술들만을 익히는 것이 아닌, 객체 지향을 이해하고 이를 스프링에 접목시키는 과정에서 얻어진다.
* 스프링의 진정한 핵심 가치는 객체 지향 프로그래밍에 있으며, 스프링을 제대로 학습하기 어려운 이유 역시 OOP에 있다.
  * 때문에 스프링을 제대로 학습하여 그 본질을 배우는 과정은, 한 편으로는 객체 지향 설계의 본질을 이해하는 과정이기도 하다.
* 스프링을 정말 잘 아는 개발자는 단순히 스프링이 제공하는 기능을 사용하는 데에서 멈추지 않고, 객체 지향 애플리케이션의 설계와 아키텍쳐를 고민해야 한다.

### Java 진영의 겨울
* 2000년대 초반, Java 진영의 주류이자 표준 기술에는 Enterprise Java Beans가 있었다.
  * EJB는 마치 종합 선물 세트처럼 정말 많은 기술을 제공했으며, 실제로도 널리 보급되어 많이 사용되었다.
* 그러나 **EJB는 그 자체로도 엄청난 고가의 기술이었으며, 어렵고 복잡하고 느리다는 단점을 수반**했다.
* **가장 큰 단점은 EJB 의존적인 개발을 진행하게 된다는 것이었으므로, 이에 반발하여 순수한 Java로 회귀하자는 POJO 개념이 제창**된다.
* 스프링과 하이버네이트는 각각 EJB의 컨테이너와 엔티티 빈을 대체한다.
  * 스프링은 현재 사실 상의 표준이 된 기술이며, 하이버네이트는 EJB 진영이 엔티티 빈을 버리고 하이버네이트를 기반으로 한 표준인 JPA를 채택하도록 했다.
  * 때문에 JPA는 사실 상 초기의 하이버네이트를 그대로 가져와 만든 표준 인터페이스에서 시작했다.
  * **JPA는 표준 인터페이스이며, 이를 사용하기 위한 많은 구현체들이 존재하지만 현재 실무에서는 대부분 하이버네이트를 사용**한다.

## 2022-06-19 Sun
### 다시, 스프링이란?
* 스프링은 정확히 어떤 기술 하나를 지칭하는 것이 아닌, 많은 기술을 포함하는 프레임워크이다.
  1. 스프링: 스프링의 가장 핵심이 되는 프레임워크 그 자체이다.
  2. 스프링 부트: 여러 스프링 관련 기술을 편리하게 사용해줄 수 있도록 지원한다.
* 상술한 두 기술은 필수이며, 그 밖에 스프링 데이터, 스프링 세션, 스프링 시큐리티, 스프링 배치 등 여러 기술들을 선택적으로 사용할 수 있다.

### 스프링 프레임워크
* **모든 스프링 관련 기술 중 가장 중요한 것은 당연히 스프링 프레임워크 그 자체**이며, 스프링 프레임워크는 다음과 같은 기술들로 구성된다.
  * 핵심 기술: 스프링 DI 컨테이너, AOP, 이벤트, 등
  * 웹 관련 기술: 스프링 MVC, 스프링 WebFlux
  * 데이터 접근 관련 기술: 트랜잭션, JDBC, ORM 지원, 등
  * 기술 통합 관련: 캐싱, 이메일, 원격 접근, 스케쥴링, 등
  * 테스트 관련 기술: 스프링 기반의 테스트를 지원한다.
* **최근에는 단일 스프링 프레임워크보다는 여러 스프링의 기술을 쉽게 사용할 수 있도록 지원하는 스프링 부트를 함께 사용**한다.

### 스프링 부트?
* **스프링 부트는 스프링 프레임워크 자체를 편리하게 사용할 수 있도록 지원하며, 최근에는 실무에서 기본으로 사용**한다.
* 스프링 부트 이전의 스프링은 개발보다 스프링의 설정 복잡도가 매우 높았다.
  * 이전에는 스프링에 포함된 라이브러리 간의 종속성을 관리하기가 매우 어려웠으나 스프링 부트는 대부분의 서드 파티 라이브러리를 자동으로 구성해준다.
  * **스프링 부트는 손쉬운 빌드 구성을 위한 `*-starter` 이름 형식의 종속성을 제공**한다.
  * **관례에 의한 설정: 스프링 부트는 복잡한 대부분의 설정에 대한 디폴트 값을 갖고 있으며, 필요할 경우 임의의 설정을 손쉽게 수정**할 수 있다.
* **내장 웹 서버를 포함하는 스프링 부트를 통해 단독으로 실행할 수 있는 스프링 애플리케이션을 쉽게 생성**할 수 있다.
* **스프링 부트는 스프링 프레임워크 없이 단일로 사용할 수 있는 기술이 아니며, 오로지 스프링이 여러 기술을 쉽게 사용하도록 돕는데에 그 의의**가 있다.

### 스프링이라는 단어가 갖는 의미
* 스프링이라는 단어는 언제나 스프링 프레임워크를 가리키는 것은 아니며, 문맥에 따라 다음과 같은 의미로 사용될 수 있다는 점에 유의해야 한다.
  1. 스프링의 DI 컨테이너 기술: 스프링의 핵심 중 핵심이며, 스프링의 빈을 관리하는 DI 컨테이너 기술을 의미할 수 있다.
  2. 또는 스프링 프레임워크 그 자체
  3. 또는 스프링 프레임워크와 스프링 부트를 모두 포함하는 스프링의 생태계 전체: 최근 실무에서 가장 자주 사용되는 스프링의 의미이다.

### 스프링은 왜 탄생했는가?
* 모든 대형 프로젝트의 시작과, 그 핵심을 이루는 근본 개념은 매우 단순한 경우가 많다.
  * 그러나 이 단순함이 많은 사람들을 설득시킬 때 프로젝트는 점점 규모를 확장하며, 커다란 기술이 탄생하게 된다.
  * 스프링 역시 시작은 3만 줄의 짧은 코드였으나, 당시 Java 진영의 많은 개발자들이 이에 열광하여 오픈소스 프로젝트가 시작되었다.
* 스프링 이전에 주류였던 EJB를 사용하는 프로젝트는 반드시 EJB에 의존적일 수 밖에 없었으며, 코드 자체도 매우 지저분해지기 쉬웠다.
  * 이로 인해 Java가 갖는 객체 지향 언어로서의 장점을 살릴 수 없었으며, 동시에 EJB에 의존하는 프로젝트를 제작할 수 밖에 없었다.
  * 이러한 특징을 갖는 **EJB에 반발하여 순수했던 Java 언어 그 자체로 돌아가자는 의미에서 나온 개념이 POJO**이다.

### 스프링의 핵심
```
> 스프링은 좋은 객체 지향 애플리케이션을 개발할 수 있도록 지원해주는 프레임워크이다.
```
* 스프링은 객체 지향 언어로서의 특징을 갖는 Java 기반의 프레임워크이다.
* 때문에, **스프링은 객체 지향 언어가 갖는 강력한 특징을 살려내는 프레임워크로서 기능하는 것이 핵심**이다.
* 중요한 것은 양질의 객체 지향 애플리케이션을 지원한다는 점이며, 다음과 같은 내용은 스프링의 핵심을 말하는 개념이 아니다.
  1. 웹 애플리케이션의 제작을 쉽게해주는 기술
  2. 데이터베이스와 쉽게 상호작용할 수 있도록 도와주는 기술
  3. 웹 서버를 내장하는 프레임워크

### 좋은 객체 지향 프로그래밍
* 객체 지향 프로그래밍이란, 애플리케이션을 단순한 명령어의 모음으로 보는 관점에서 벗어나 객체들의 협력에 집중하는 패러다임이다.
  * 각 객체는 서로 메시지를 주고받고, 요구 사항을 해결하기 위해 서로 협력하여 데이터를 처리할 수 있다.
* **객체 지향 프로그래밍이 잘 적용된 경우, 프로그램의 유연성은 크게 향상되므로 필연적으로 발생할 수 밖에 없는 변경에 대응하기 쉬워진다**.
* 유연하고 변경이 용이한 소프트웨어는 마치 레고를 조립하듯이 조립되며, 부품을 갈아끼우듯이 쉽게 수정할 수 있는 특징을 갖는다.
  * 이러한 소프트웨어의 특징은 객체 지향 프로그래밍에서 말하는 다형성과 상통한다.

### 다형성
* 세상의 모든 것을 역할과 구현으로 구분한다고 했을 때, 각각은 프로그래밍의 인터페이스와 구현체에 대응된다.
  * 물론, 실세계의 모든 것을 프로그래밍적인 요소와 일대 일 대응시킬 수는 없지만 개념을 이해하는 데에는 큰 도움이 된다.
* **역할과 구현으로 모든 것을 구분할 수 있다면 세상은 단순해지고, 유연해지므로 변경이 쉬워진다**.
* 이를 프로그래밍에 도입했을 경우, 역활과 구현을 분리했을 때 다음과 같은 이점을 누릴 수 있게 된다.
  1. 클라이언트는 대상이 수행하는 역할인 인터페이스만 알고 있으면 된다.
  2. 클라이언트는 대상의 구체적인 내부 구현을 알 필요가 없다.
  3. 클라이언트는 대상의 역할이 변경되지 않았다면, 내부 구현이 크게 바뀌었더라도 아무런 영향을 받지 않는다.
  4. 클라이언트는 대상의 역할이 변경되지 않는다면, 역할을 구현하는 대상 자체가 변경되더라도 아무런 영향을 받지 않는다.

### Java를 활용하여 역할과 구현을 분리하기
* Java는 언어 자체적으로 다형성을 지원하므로, 역할과 구현을 다음과 같이 대응시킬 수 있다.
  1. 역할: Java의 인터페이스를 활용한다.
  2. 구현: 인터페이스를 클래스로 구현한다.
* 즉, 객체를 설계할 때에는 언제나 해당 객체의 역할과 구현을 명확히 분리해야 한다.
  * **객체 설계시 해당 객체의 역할을 우선적으로 결정하고, 그 이후에서야 역할을 수행할 수 있는 객체를 제작**한다. 

### 협력 속에서 생각하기
* 홀로 존재할 수 있는 객체는 없으며, 일반적으로 무언가를 요청하는 클라이언트 객체와 요청에 응답하는 서버 객체로 나뉘어 분류된다.
  * 이 때, void 형 메소드를 제공하는 서버 역시 클라이언트가 요청하는 작업을 수행할 것이므로 요청에 응답한 것으로 볼 수 있다.
  * **애플리케이션은 수 많은 클라이언트 객체와 서버 객체가 협력하는 형태로 구성**된다.

### 다형성의 본질
* 다형성을 지원하는 언어의 경우, 인터페이스를 구현하는 객체를 실행 시점에 유연하게 변경할 수 있다.
* 또한 **다형성의 본질을 이해하기 위해서는 협력이라는 객체 사이의 관계를 생각하는 것에서부터 시작**해야 한다.
  * 이를 통해 클라이언트를 변경하지 않고도 서버 객체의 실제 구현을 유연하게 변경할 수 있게 된다.

### 역할과 구현을 분리하기
* 실세계의 역할과 구현 개념은 객체 지향 세계에도 쉽게 가져올 수 있으며, 이 기반이 되는 것이 다형성이다.
* 역할과 구현이 분리된 설계는 유연하며, 쉽게 변경할 수 있다.
  * 클라이언트에 영향을 주지 않고도 변경이 가능하며, 이로 인해 확장성 또한 향상된다.
* 반면, **역할과 구현을 잘 분리하였더라도 역할 자체가 수정되면 클라이언트와 서버 객체 모두 역시 큰 변경이 가해져야한다는 문제도 존재**한다. 
  * 때문에 **객체 지향을 위해서는 인터페이스를 안정적으로 잘 설계하는 것이 매우 중요**하다.

### 스프링과 객체지향
* 상술한 이유에서 객체 지향의 많은 개념 중, 다형성은 특히나 더 중요하다.
* 스프링 프레임워크는 이렇듯 중요한 다형성을 극대화할 수 있도록 지원한다.
  * 예를 들어 스프링이 지원하는 IoC와 DI는 다형성을 활용하여 역할과 구현을 편리하게 다룰 수 있도록 한다.
  * 스프링을 적절히 활용할 경우, 마치 레고를 조립하듯이 구현을 편리하게 변경할 수 있게 된다.
* 극단적으로 **스프링 컨테이너가 제공하는 기능은 모두 다형성을 편리하게 사용하도록 지원하기 위해서 존재하며, 어찌 보면 이것이 전부**일 수도 있다. 

### SOLID 원칙
* SOLID 원칙은 로버트 마틴이 제안한 좋은 객체 지향 설계를 만드는 5가지 원칙을 정리한 목록을 일컫는다.
  1. Single Responsibility Principle: 단일 책임 원칙
  2. Open - Closed Principle: 개방 폐쇄 원칙
  3. Listcov Substitution Principle: 리스코프 치환 원칙
  4. Interface Segregation Principle: 인터페이스 분리 원칙
  5. Dependency Inversion Principle: 의존성 역전 원칙

### 단일 책임 원칙
```
> 하나의 클래스는 하나의 책임만을 가져야 한다.
```
* 단일 책임 원칙에서 말하는 책임의 개념은 언뜻 모호해보일 수 있다.
* 그러나 **중요한 판단 기준은 변경이며, 어떠한 클래스를 변경했을 때 파급 효과가 적다면 단일 책임 원칙을 잘 따른 것**으로 볼 수 있다.
  * 예를 들어, UI의 변경이나 객체의 생성과 사용을 분리하는 것이 있다.
  * 어떤 요구 사항의 변경을 반영하기 위해 클래스를 하나만 수정하였다면, 해당 클래스는 단일 책임 원칙을 잘 준수한 것으로 볼 수 있다.
  * 나아가 개발자가 계층을 잘 나누는 것은 단일 책임 원칙을 준수하기 위해서인 것으로 이해할 수있다.
* 객체가 갖는 책임의 범위를 적절히 조절하는 것은 객체 지향 설계의 묘미 중 하나이다.
  * 책임이 너무 작으면 객체가 기능이 너무 잘게 나뉘고, 너무 크면 객체가 많은 책임을 갖게 된다.

### 개방 폐쇄 원칙
```
> 소프트웨어의 요소는 확장에는 열려 있으나, 변경에는 닫혀 있어야 한다.
```
* 개방 폐쇄 원칙은 가장 허무맹랑해보이는 원칙처럼 보이지만, SOLID의 가장 중요한 원칙이다.
* **해당 원칙은 특정한 요구 사항을 반영하기 위해 기존 기능을 수정하는 것보다, 다형성을 활용하여 새로운 기능을 추가하는 것을 권장**한다.
  * 즉, 개방 폐쇄 원칙은 다형성과 밀접한 연관이 있는 원칙이다.

### 다형성을 적용했지만 개방 폐쇄 원칙은 준수할 수 없는 경우?
* 예를 들어, 다음의 코드는 다형성을 준수하여 역할과 구현을 분리하고자 했다고 하자.
  * 기본적으로 `InMemoryServer` 객체를 활용하여 기능을 구현했으나, 요구 사항의 변경으로 인해 `NotInMemoryServer` 객체를 사용해야 한다.
  * 그런데 **이를 위해서는 기존 `Client` 객체를 반드시 수정해야만 한다**.
  * 즉, **객체는 수정에 닫혀있어야 하나 구현체를 변경하기 위해서는 반드시 기존 객체를 수정해야하는 딜레마**에 빠지게 된다.
```
public class Client {
//    private static Server server = new InMemoryServer();
    private static Server server = new NotInMemoryServer();
    
    public static void main(String[] args) {
        server.doSomething();
    }
}

interface Server {
    void doSomething();
}

class InMemoryServer implements Server {
    @Override
    public void doSomething() {
        System.out.println("InMemory!");
    }
}

class NotInMemoryServer implements Server {
    @Override
    public void doSomething() {
        System.out.println("NotInMemory!");
    }
}
```
* **이는 `Client` 객체가 `Server` 객체의 실제 구현체를 직접 선택하는 데에서 기인하는 문제**이다.
  * 즉, 구현 객체를 수정하려면 반드시 클라이언트 코드가 변경되어야 하기에 다형성을 적용하더라도 OCP를 준수할 수 없게 된다.
* 이러한 **문제를 해결하기 위해서는 반드시 객체를 생성하고, 연관 관계를 맺어주는 별도의 조립자 또는 설정자 객체가 필요**하다.
  * 때문에 스프링은 OCP를 준수하기 위해서 DI와 IoC 컨테이너가 추가된 것으로 이해할 수도 있다.

### 리스코프 치환 원칙
```
> 소프트웨어 상의 객체는 소프트웨어의 정확성을 깨트리지 않으면서도 하위 타입의 인스턴스로 교체할 수 있어야 한다.
```
* 해당 원칙은 다형성에서 하위 클래스가 인터페이스의 규약을 전부 준수해야한다는 것을 의미한다.
* **다형성을 지원하기 위한 원칙이며, 인터페이스를 구현한 구현체를 신뢰할 수 있으려면 반드시 리스코프 치환 원칙을 준수할 수 있어야 한다**.
  * 이는 단순히 컴파일만을 위한 개념을 넘어서는 개념이다.

### 인터페이스 분리 원칙
```
> 특정한 하나의 클라이언트만을 위한 인터페이스 여러 개가 범용적인 인터페이스 하나보다 좋다.
```
* **인터페이스를 분리할수록 개별 인터페이스의 역할이 명확해지고, 대체 가능성은 높아진다**.

### 의존성 역전 원칙
```
> 개발자는 추상화에 의존하되, 구현에 의존하지 않아야 한다.
```
* 쉽게 봤을 때 클라이언트 코드는 상세한 구현 클래스가 아닌 인터페이스에 의존해야 함을 의미하며, 개방 폐쇄 원칙 못지 않게 중요한 원칙이다.
  * 의존성 주입 역시 DIP를 준수하기 위한 방법 중 하나이다.
* **이는 다형성과도 일맥상통하는 부분이 있으며, 클라이언트는 역할에 의존해야 한다는 의미로 이해**할 수 있다.
  * 객체들의 관계 역시 클라이언트가 추상적인 인터페이스에 의존해야 상세한 구현체를 유연하게 변경할 수 있다.
  * 반면, 클라이언트가 상세한 구현체에 의존하게 되면 두 객체 간의 결합도가 너무 높아져 변경이 어려워진다.

### 의존성 역전 원칙을 위배하는 경우
* 상술한 코드에서, `Client` 객체는 `Server` 인터페이스에 의존하지만 세부적인 구현 클래스 역시 new 연산자를 활용하여 명시하고 있다.
  * 즉, **`Client`는 상세한 구현체를 직접 선택하는 방식으로 의존**하고 있다.
* 이러한 경우는 의존성 역전 원칙을 위배하는 대표적인 예시이다.

### SOLID - 정리
```
> 객체 지향 프로그래밍의 핵심은 다형성이다.
```
* 다형성만으로는 상세한 구현체를 필요에 따라 갈아 치우듯이 개발하기는 어렵다.
* 다형성만으로는 구현 객체를 변경할 때 클라이언트 코드도 함께 변경이 필요할 수 밖에 없다.
  * 즉, **다형성만으로는 개방 폐쇄 원칙과 의존성 역전 원칙을 준수할 수 없다**.
  * 뭔가... 뭔가가 더 필요하다.
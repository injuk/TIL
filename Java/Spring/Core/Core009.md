# Core
## 2022-06-30 Thu

### 빈 스코프란?
* **빈 스코프란, 빈이 존재할 수 있는 범위**를 뜻한다.
  * 예를 들어, 싱글톤 스코프로 생성되는 스프링 빈은 스프링 컨테이너의 시작부터 종료까지 유지된다.
* 스프링이 지원하는 빈 스코프의 종류는 크게 다음과 같다.
  1. 싱글톤: **기본 스코프이며, 스프링 컨테이너의 시작부터 종료까지 유지되는 가장 넓은 범위의 스코프**이다.
     * 즉, 스프링 컨테이너와 같은 생명주기를 갖는 스코프이다.
  2. 프로토타입: **스프링 컨테이너가 빈 객체의 생성과 의존 관계 주입까지만 관여하고, 그 이후로는 관리하지 않는 매우 짧은 범위의 스코프**이다. 
     * **프로토타입의 빈은 요청이 들어왔을 때 빈을 생성하고, 의존 관계를 주입하고, 초기화 메소드까지는 호출한 후로는 전혀 관리**하지 않는다.
  3. 웹 관련 스코프 - request: 웹 요청이 들어와서부터 나갈 때까지 유지되는 스코프이다.
  4. 웹 관련 스코프 - session: 웹 세션이 생성되고 종료될 때까지만 유지되는 스코프이다.
  5. 웹 관련 스코프 - application: 웹 서블릿 컨텍스트와 같은 범위로 유지되는 스코프이다.
* 상술한 내용 중 웹 관련 스코프는 스프링 웹과 관련된 기능이 포함되어야만 사용이 가능하다.
* 이러한 **빈 스코프는 @Scope("스코프_이름") 어노테이션을 활용하여 명시**할 수 있다.
* **상술한 스코프 중 빈번히 사용되므로 상세하게 이해할 필요가 있는 항목은 싱글톤과 프로토타입, 그리고 request 스코프**이다.

### 싱글톤 스코프와 프로토타입 스코프
* 싱글톤 스코프의 빈을 조회할 경우, 스프링 컨테이너는 항상 같은 인스턴스의 스프링 빈을 반환한다.
  * 반면, **프로토타입 스코프 빈을 스프링 컨테이너에서 조회할 경우 컨테이너는 항상 새로운 인스턴스를 생성하여 반환**한다.
* 싱글톤 빈 요청 흐름은 크게 다음과 같다.
  1. 클라이언트는 임의의 싱글톤 스코프 빈을 스프링 컨테이너에 요청한다.
  2. 스프링 컨테이너는 자신이 관리 중인 빈 중 적절한 것을 찾아 반환한다.
  3. 이후 다른 클라이언트의 요청에 대해서도 스프링 컨테이너는 같은 객체 인스턴스의 스프링 빈을 반환한다.
* 그러나 프로토타입 빈 요청 흐름은 다음과 같으며, 싱글톤 스코프의 빈 요청 흐름과는 차이가 있다.
  1. 클라이언트가 프로토타입 스코프를 갖는 임의의 빈을 스프링 컨테이너에 요청한다.
  2. 스프링 컨테이너는 요청이 들어온 시점에 새로운 프로토타입 빈을 생성하고, 필요한 의존 관계를 주입한 후 초기화 메소드까지 호출한다.
  3. **완성된 빈 객체는 스프링 컨테이너가 클라이언트에게 반환하지만, 컨테이너 자신은 빈 객체 정보를 폐기하여 더 이상 관리하지 않는다**.
     * 즉, 요청된 빈을 생성하고 의존 관계를 주입하는 등의 과정은 수행해주지만 반환 이후에는 아무런 관리를 수행하지 않는다.
  4. 이후의 **동일한 요청에 대해, 스프링 컨테이너는 1. - 3. 과정을 반복하며 항상 새로운 프로토타입 빈을 생성하여 반환**한다.

### 프로토타입 스코프 - 정리
* **중요한 것은 스프링 컨테이너가 프로토타입 빈을 생성하고 의존 관계를 주입한 후, 필요한 경우에 한해 초기화 콜백 메소드까지 호출한다는 점**이다.
* 이렇게 모든 처리가 끝난 프로토타입 빈은 클라이언트에게 반환되고, 스프링 컨테이너는 더 이상 해당 빈을 관리하지 않는다.
  * 즉, 반환된 시점 이후로 프로토타입 빈을 관리할 책임은 클라이언트에게 있다.
* 때문에 **프로토타입 스코프의 빈 객체는 소멸 전 콜백 메소드인 @PreDestroy 등이 호출되지 않는다**.

### 프로토타입 스코프 작성해보기
```
public class PrototypeTest {

    @Test
    void prototypeBeanTest() {
        // 얘는 싱글톤 스코프와 달리 빈 등록 로그도 안뜸. 프로토타입 빈 스코프 객체는 스프링 컨테이너가 아예 관리하지 않는다는 의미!
        AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(PrototypeBean.class);

        System.out.println("get prototypeBean1"); // 이 시점에서 프로토타입 빈이 생성된다.
        PrototypeBean prototypeBean1 = ac.getBean(PrototypeBean.class);
        System.out.println("get prototypeBean2"); // 이 시점에서 프로토타입 빈이 생성된다.
        PrototypeBean prototypeBean2 = ac.getBean(PrototypeBean.class);

        System.out.println("prototypeBean1 = " + prototypeBean1);
        System.out.println("prototypeBean2 = " + prototypeBean2);

        assertThat(prototypeBean1).isNotSameAs(prototypeBean2);

        // 관리 책임이 클라이언트에게 있으므로, 소멸 전 콜백 메소드를 호출해야하는 경우에는 해당 메소드를 직접 호출해야 한다.
        prototypeBean1.destroy();
        prototypeBean2.destroy();
        
        // 클로즈하여 스프링 컨테이너를 종료한다.
        ac.close();
    }

    // @Component는 붙이지 않아도 무방하다.
    // AnnotationConfigApplicationContext(PrototypeBean.class)로 지정하면, 인자로 전달된 클래스가 컴포넌트 스캔 대상이 된 것처럼 동작한다!
    // 즉, 아래의 코드는 컴포넌트 스캔처럼 등록하는 예시이다.
    @Scope("prototype")
    static class PrototypeBean {
        @PostConstruct
        public void init() {
            System.out.println("PrototypeBean.init");
        }

        // 프로토타입 빈 스코프의 객체는 소멸 전 콜백 메소드가 호출되지 않는다.
        @PreDestroy
        public void destroy() {
            System.out.println("PrototypeBean.destroy");
        }
    }
}
```
* **싱글톤 빈은 스프링 컨테이너가 생성되는 시점에 초기화 메소드가 실행되지만, 프로토타입 빈은 스프링 컨테이너에서 해당 빈을 조회할 때 생성**된다. 
  * 때문에 프로토타입 빈은 2번 조회할 경우 2개가 생성된다.
* 싱글톤 빈은 스프링 컨테이너가 직접 관리하므로 스프링 컨테이너가 종료될 때 소멸 전 콜백 메소드가 호출된다.
* 그러나 프로토타입 빈은 스프링 컨테이너가 생성과 의존 관계 주입, 초기화 콜백 메소드 호출까지만 관여하고 그 이후로는 관리 책임을 클라이언트에게 넘긴다.
  * 때문에 프로토타입 빈은 스프링 컨테이너가 종료되는 시점에 소멸 전 콜백 메소드가 호출되지 않는다.
* 따라서 **프로토타입 빈 객체는 해당 빈을 조회한 클라이언트가 직접 관리해야 하며, 소멸 전 콜백 메소드 역시 클라이언트가 직접 호출**해야 한다.
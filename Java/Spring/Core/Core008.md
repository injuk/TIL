# Core
## 2022-06-29 Wed

### 빈 생명주기 콜백이란?
* **빈 생명주기 콜백은 스프링 빈이 등록되거나 소멸될 때 임의의 빈 내부의 메소드를 호출해주는 기능**이다.
* 예를 들어 데이터베이스의 커넥션 풀이나, 네트워크 소켓 등의 자원은 애플리케이션이 시작할 때 미리 연결해두는 커넥션 풀을 사용할 수 있다.
  * 또한, 애플리케이션이 종료될 때 연결을 미리 모든 연결을 종료할 수도 있다.
* 스프링은 빈 생명주기 콜백을 통해 이러한 초기화 작업과 종료 작업을 손쉽게 지원한다.
* **스프링 빈은 간단하게 봤을 때 다음과 같은 생명주기**를 갖는다.
  1. 모든 스프링 빈 객체를 생성한다.
  2. 모든 스프링 빈 객체 사이에 의존 관계를 주입한다.

### 빈 생명 주기와 콜백 메소드
* 이렇듯 스프링 빈은 객체를 생성하고, 의존 관계 주입을 마친 후에야 필요한 데이터를 사용할 수 있는 상태가 된다.
  * 때문에 **모든 초기화 작업은 의존 관계 주입이 완료된 후에 호출되어야 하지만, 문제는 개발자가 의존 관계 주입이 완료된 시점을 알아채는 방법**이다.
* 스프링은 의존 관계 주입이 완료된 경우, 스프링 빈에게 콜백 메소드를 통해 초기화 시점을 알려주는 여러 기능을 제공한다.
  * **또한, 스프링은 스프링 컨테이너의 종료 직전에 소멸 콜백을 주므로 안전한 종료 작업이 가능**하다.
* 결국, 스프링 빈 객체의 이벤트 생명주기는 다음과 같다.
  1. 스프링 컨테이너 생성
  2. 스프링 빈 생성: 생성자 주입 방식의 의존 관계 주입은 어느 정도는 이 단계에서 이루어진다.
  3. 의존 관계 주입: 반면, 필드 주입과 수정자 주입은 이 단계에서 이루어진다.
  4. 초기화 콜백 호출
  5. 사용
  6. 소멸 전 콜백
  7. 스프링 종료
* 특히, 이 중 초기화 콜백과 소멸 전 콜백의 역할은 다음과 같다.
  1. 초기화 콜백: **빈이 생성되고, 빈의 의존 관계 주입이 완료된 후에 호출**된다.
  2. 소멸 전 콜백: 빈이 소멸되기 직전에 호출된다.
* 스프링의 경우, 크게 다음과 같은 세 가지 방식으로 빈 생명주기 콜백을 지원한다.
  1. InitializingBean, DisposableBean 인터페이스
  2. 설정 정보에 초기화 메소드와 종료 메소드를 지정하기
  3. @PostConstruct, @PreDestroy 메소드 명시하기

### 참고사항 - 객체의 생성과 초기화 로직의 분리
* 생성자는 필수 정보를 받아 메모리를 할당하고, 객체를 실제로 생성하는 책임을 갖는다.
  * 반면, 초기화는 생성된 값을 통해 외부 커넥션을 연결하는 등 무거운 작업을 처리한다.
* 때문에 **생성자 내부에서 무거운 초기화 작업을 수행하는 것보다, 객체의 생성부와 초기화 부분을 명확히 나누는 방식이 유지보수성이 높다**.
  * 물론, 초기화 작업이 내부 필드를 변경하는 가벼운 작업인 경우에는 생성자를 활용하는 것이 바람직하다.
  * 덧붙여 객체의 생성과 초기화를 분리하는 경우 객체를 생성하고 나서, 최초 시도 시점까지 연결 등의 초기화 작업을 지연할 수도 있다.

### InitializingBean, DisposableBean 인터페이스
* 두 빈은 각각 객체가 생성되어 의존 관계 주입이 완료된 후에 호출되는 afterPropertiesSet 메소드와, 소멸 직전에 호출되는 destroy 메소드를 제공한다.
```
@Override
public void destroy() throws Exception {
    // 해당 메소드는 DisposableBean으로부터 구현하며, 소멸 직전에 호출될 기능을 명시한다.
    disconnect();
}

@Override
public void afterPropertiesSet() throws Exception {
    // 해당 메소드는 InitializingBean으로부터 구현하며, 객체가 생성되고 의존 관계 주입이 끝나면 호출된다.
    connect();
    call("초기화 연결 메시지");
}
```

### 인터페이스 방식의 단점
* 상술한 두 인터페이스는 스프링의 전용 인터페이스이므로, 코드가 스프링에 의존하게 된다.
  * 또한, 전용 인터페이스이므로 초기화 및 소멸 메소드 각각의 이름을 변경할 수 없다.
* **해당 방식은 자신이 코드를 수정할 수 없는 외부 라이브러리에는 적용이 불가능**하다.
* **인터페이스 방식의 초기화 및 소멸자 콜백 호출의 경우, 스프링 초기에 제시된 방법이므로 현재에는 거의 사용하지 않는다**.

### 빈 등록 초기화, 소멸 메소드
* 설정 정보에 명시되는 @Bean의 속성으로 초기화 및 소멸 메소드 각각을 지정할 수도 있다.
```
@Configuration
static class LifeCycleConfig {

    @Bean(initMethod = "init", destroyMethod = "destroy")
    public NetworkClient networkClient() {
        NetworkClient networkClient = new NetworkClient();
        networkClient.setUrl("http://hello-spring.dev");
        return networkClient;
    }
}
```
* 상술한 코드의 경우, networkClient 빈 객체는 초기화 콜백 메소드로 networkClient.init()을 호출한다.
  * 같은 원리에서, 소멸 전 콜백에서는 networkClient.destroy()를 호출한다.

### 설정 정보를 활용한 빈 등록 초기화, 소멸 메소드 지정 방식의 장점
* @Bean 어노테이션의 속성으로 메소드 이름을 자유롭게 지정할 수 있으며, 스프링 빈이 아니기에 스프링에 의존하지도 않는다.
* 무엇보다 **코드 대신 설정 정보를 사용하므로, 코드를 고칠 수 없는 외부 라이브러리에서도 초기화 및 종료 메소드를 적용**할 수 있다.

### 소멸 메소드의 추론
* 또한, 설정 정보를 활용한 방식은 소멸 메소드에 대해 추론 기능을 제공한다.
  * **대부분의 라이브러리는 close 또는 shutdown 등의 이름을 종료 메소드로 사용하므로, 소멸 메소드 추론에 의해 이러한 유형의 메소든느 자동 호출**된다.
  * 이로 인해 직접 스프링 빈으로 등록한 빈 객체의 경우, 적절한 이름의 종료 메소드가 있다면 destroyMethod를 명시하지 않아도 무방하다.
  * 반면, **추론 기능을 무슨 일이 있어도 사용하기 싫은 경우에는 `@Bean(destroyMethod="")`와 같은 형식으로 공백을 지정**한다.

### @PostConstruct, @PreDestroy 어노테이션 방식
* 상술한 두 방식보다는 해당 방식을 사용하는 것이 바람직하다.
  * 심지어, 스프링에서도 해당 방식을 권고하고 있다.
* 이름에서도 알 수 있듯, 두 어노테이션은 각각 초기화 콜백 메소드와 소멸 전 콜백 메소드에 해당한다.
```
@PreDestroy
public void destroy() {
    System.out.println("NetworkClient.destroy");
    disconnect();
}

@PostConstruct
public void init() {
    // 의존 관계 주입이 끝나면 호출
    System.out.println("NetworkClient.afterPropertiesSet");
    connect();
    call("초기화 연결 메시지");
}
```
* 이 때, 두 어노테이션의 import 구문은 다음과 같이 javax로 시작하는 것을 확인할 수 있다.
  * **javax로 시작하는 패키지는 Java 진영에서 공식적으로 지원하는 Java 표준이므로, 스프링 이외의 컨테이너에서도 적용이 가능**함을 의미한다.
  * 또한, 설정 파일을 굳이 명시할 필요가 없으므로 컴포넌트 스캔과도 잘 어울린다.
```
import javax.annotation.PostConstruct;
import javax.annotation.PreDestroy;
```
* 그러나 **해당 방식 역시 코드 수정이 불가능한 외부 라이브러리에는 적용할 수 없다는 단점이 존재**한다.
  * 외부 라이브러리에 대한 초기화, 소멸 전 콜백을 활용해야하는 경우에는 상술한 @Bean 어노테이션의 속성을 활용해야 한다.

### 결론
* **초기화 콜백과 소멸 전 콜백이 필요한 경우, @PostConstruct, @PreDestroy 어노테이션 방식을 사용**한다.
  * 인터페이스 방식은 사용을 지양한다.
* **코드를 수정할 수 없는 외부 라이브러리에 대한 생명주기 콜백 호출이 필요한 경우에 한해 @Bean(initMethod="", destroyMethod="")를 사용**한다.
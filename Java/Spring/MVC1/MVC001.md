# Spring MVC I
## 2024-03-22 Fri
### 웹 서버와 웹 애플리케이션 서버
```
> 웹 서버는 정적 리소스를 제공하는 반면, 웹 애플리케이션 서버는 여기에 더해 애플리케이션을 실행할 수 있다.
```
* 웹은 기본적으로 HTTP 통신을 기반으로 하므로, 클라이언트로부터 서버로의 데이터 전송과 서버의 응답은 모두 HTTP를 사용한다.
    * 이 때, HTTP로 주고받을 수 있는 데이터에는 사실상 제한이 없으며 이미지나 영상은 물론 JSON 등의 데이터까지도 전송이 가능하다.
* 이 때, **웹 서버는 HTTP를 기반으로 동작하며 HTML 등 정적 리소스를 반환하는 nginx나 아파치 서버 등을 의미**한다.
    * 이러한 특징으로 인해 **웹 서버는 모든 경우에 반드시 필요한 것은 아니며, 단순히 API를 기반으로 데이터만 주고 받는 경우에는 WAS만 사용**할 수도 있다.
* 반면 **웹 애플리케이션 서버는 애플리케이션 로직을 수행하는 것을 의미하며, HTTP 기반으로 동작하면서 정적 리소스를 반환하는 웹 서버의 기능을 포함**한다.
    * 이 때, WAS에는 톰캣과 Jetty 등이 포함되며 내부적으로는 서블릿이나 JSP 또는 스프링 MVC를 실행할 수 있다.
* 이러한 차이로 인해 웹 서버는 접속한 사용자마다 다른 정보를 반환할 수 없으나, 웹 애플리케이션 서버는 사용자 별로 다른 화면을 제공하는 것이 가능하다.

## 2024-03-23 Sat
### 웹 서버와 웹 애플리케이션 서버를 '정확'하게 구분하기?
* 일반적으로 웹 서버가 정적 리소스를 처리하는 반면 WAS는 애플리케이션 로직을 다루는 것으로 알려져 있으나, 정확히는 둘 사이의 용어나 경계가 모호하다.
  * 예를 들어, 웹 서버도 애플리케이션을 실행하는 기능을 포함할 수 있는 반면 WAS도 웹 서버의 기능을 포함한다.
* 이러한 이유에서, **일반적인 Java 애플리케이션은 서블릿 컨테이너 기능을 제공하면 WAS로 취급**하기도 한다.
* 그럼에도 가장 쉬운 분류 방법은 웹 서버가 정적 리소스를 처리하고, WAS는 애플리케이션 코드까지 실행할 수 있다는 차이를 두는 것이다.

## 2024-03-24 Sun
### 각 요소를 조합한 웹 애플리케이션 구성하기
* WAS는 애플리케이션 로직을 수행할 수 있으면서도 정적 리소스를 제공할 수 있으므로, 실제로는 WAS와 DB만으로 웹 애플리케이션을 구성할 수 있다.
* 그러나 이러한 경우 **WAS가 너무 많은 역할을 담당하게 되므로, 정적 리소스 처리로 인해 중요한 애플리케이션 코드가 지연되는 등 과부하가 발생**하기 쉽다.
  * 최악의 경우 WAS애 장애가 발생하게 되면 정적 리소스의 일종인 오류 화면조차 표현이 불가능해질 수 있다.
* 규모가 작은 애플리케이션의 경우 상술한 방식만으로도 구축할 수 있으나, 일반적인 경우 WAS 앞에 웹 서버를 두어 정적 리소스에 대한 처리를 위임하게 된다.
  * 반면, 웹 서버는 애플리케이션 로직과 같은 동적인 처리가 필요한 경우에 WAS에 요청을 위임하게 된다.
* 이러한 방식을 사용할 경우, 가벼운 정적 리소스는 웹 서버가 처리하게 되므로 WAS는 중요한 애플리케이션 로직에만 집중할 수 있다.
  * 나아가 **요청된 리소스의 종류에 따라 웹 서버를 증설하거나 WAS를 증설하는 등, 효율적이고도 유연한 리소스 관리가 가능**하다.
  * 또한 **잘 다운되는 WAS와 달리 웹 서버는 잘 다운되지 않으므로, WAS나 DB 장애 발생시 웹 서버가 오류 화면을 제공**할 수도 있다.

## 2024-03-25 Mon
### 백엔드 애플리케이션에 구현되어야 할 기초적인 기능
* 예를 들어 form을 기반으로 임의의 URI에 POST 요청을 보내는 기능을 구현하려면, 개발자는 크게 다음과 같은 내용을 개발해야 한다.
  1. HTTP는 기본적으로 TCP를 사용하므로, TCP/IP 연결을 대기하는 서버를 작성한다.
  2. 요청이 수신된 경우, 소켓에 연결한다.
  3. 모든 HTTP 요청은 기본적으로 단순한 텍스트에 불과하므로, 해당 내용을 분석하기 위해 파싱한다.
  4. `Content-Type`에 따라 HTTP 요청 본문까지 파싱한다.
  5. 파싱된 결과에 따라 적절한 API로 라우팅하여 처리 메소드를 호출한다.
  6. 적절한 비즈니스 로직을 실행하되, 필요한 경우 DB에 저장한다.
  7. 헤더와 HTML 등의 HTTP 응답 본문을 포함하는 HTTP 응답 메시지를 작성한다.
  8. TCP/IP를 기반으로 응답을 전달한다.
  9. 소켓을 종료한다.
* 상술한 내용에서, 정작 **중요한 것은 여섯 번째 과정인 순수한 비즈니스 로직이지만 단지 이를 위해 처리되는 전처리 및 후처리 단계가 너무 많고 반복적**이다.

## 2024-03-26 Tue
### 서블릿이란?
* **서블릿은 이러한 문제를 해결하기 위해 등장하였으며, 순수한 비즈니스 로직 외의 모든 전처리 및 후처리 단계를 제공**한다.
  * 따라서 개발자는 서블릿을 지원하는 WAS를 사용하는 것으로, 순수한 비즈니스 로직에만 집중할 수 있다.
* 기본적인 서블릿은 아래와 같이 작성할 수 있으며, **`urlPatterns`에 명시된 URI가 외부로부터 호출된 경우 서블릿의 코드가 실행**된다.
```java
@WebServlet(name ="myServlet", urlPatterns="/my")
public class MyServlet extends HttpServlet {
    @Override
    protected void service(HttpServletRequest req, HttpServletResponse res) {
        // 비즈니스 로직을 작성한다.
    }
}
```
* 서블릿은 상술한 전처리 및 후처리 단계 처리의 피로도를 낮추기 위해 다음과 같은 두 가지 클래스를 제공한다.
  * `HttpServletRequest`: 개발자가 요청 정보를 편리하게 활용할 수 있도록 HTTP 요청을 파싱하여 인자로 전달한다.
  * `HttpServletResponse`: 개발자가 요청에 대한 응답을 편리하게 생성할 수 있도록 HTTP 응답을 인스턴스화하여 인자로 전달한다.
* 이렇듯 **서블릿을 사용할 경우, 개발자는 HTTP 사양을 매우 편리하게 준수**할 수 있게 된다.
  * 물론 HTTP 스펙에 대한 전반적인 이해는 필수적이며, 어떤 요청이 인스턴스화 되고 어떤 인스턴스가 어떤 형태의 응답으로 변환될지 예상할 수 있어야 한다.

## 2024-03-27 Wed
### HTTP 요청에 대한 WAS의 처리 과정
* 웹 브라우저 등의 클라이언트가 서버에 HTTP 요청을 전송한 경우, 해당 요청은 크게 다음과 같은 과정을 거쳐 처리된다.
  1. 웹 브라우저는 HTTP를 기반으로 서버에 요청을 전송한다.
  2. WAS는 클라이언트의 요청을 기반으로 `HttpServletRequest`와 `HttpServletResponse` 객체를 생성한다.
  3. 만들어진 두 객체를 서블릿 컨테이너에 위치한 서블릿에 전달하여 실행한다.
  4. 서블릿의 실행이 종료될 경우, 서블릿 내에 작성된 코드에 의해 `HttpServletResponse` 객체에서 HTTP 응답을 표현하기 위한 데이터가 설정된다.
  5. `HttpServletResponse` 객체를 기반으로 HTTP 응답 메시지를 생성한 후, 클라이언트인 웹 브라우저에 이를 반환한다.
* 이렇듯 **HTTP 요청에 대해 WAS는 요청과 응답을 대표하는 객체를 생성한 후 서블릿을 호출하는 방식으로 동작**한다.
  * 때문에 개발자는 요청과 응답 객체를 기반으로 비즈니스 로직을 의미하는 서블릿 코드의 작성에만 집중할 수 있다.
  * 나아가 **서블릿 코드의 실행이 종료된 경우, WAS는 응답 객체의 내용을 기반으로 HTTP 응답을 생성**한다.

## 2024-03-28 Thu
### 서블릿 컨테이너란?
```
> 서블릿 컨테이너는 WAS 내부에 적재되어 개발자가 작성한 서블릿 객체를 생성하며, HTTP 요청을 처리하기 위한 서블릿 호출까지 담당한다.
```
* 개발자가 작성한 **서블릿 객체를 생성하기 위한 별도의 코드를 작성할 필요는 없으며, 서블릿 객체의 생성 책임은 서블릿 컨테이너**에 있다.
  * 이러한 **서블릿 컨테이너는 서블릿을 지원하는 WAS이며, 다시 말해 톰캣과 같이 서블릿을 지원하는 WAS를 곧 서블릿 컨테이너라고 지칭**한다.
* **서블릿 컨테이너는 또한 서블릿의 생명 주기를 담당하므로, WAS가 다운될 때 서블릿을 종료시키는 역할까지 수행**한다.
  * 즉, **서블릿 컨테이너의 책임은 서블릿 객체의 생성과 호출 및 관리**에 있다.
* 또한, 서블릿을 지원하는 WAS는 클라이언트로부터의 동시 요청을 처리하기 위해 멀티 스레드 기반의 처리 방식을 활용한다.
  * 때문에 동시성에 대한 처리는 개발자가 딱히 멀티 스레딩에 신경쓰지 않았더라도 WAS 차원에서 적용된다.

## 2024-03-29 Fri
### 서블릿과 서블릿 컨테이너의 특징
```
> 모든 서블릿 객체는 서블릿 컨테이너에 의해 싱글톤으로 관리된다.
```
* 클라이언트의 요청마다 서블릿 객체를 생성하는 것은 효율적이지 못하기에 서블릿 객체는 싱글톤으로 관리된다.
  * 즉, **각 요청은 동일한 서블릿 객체에 의해 처리될 수 있으므로 서블릿 객체는 공유 변수 사용에 있어 반드시 주의**를 기울여야 한다.
  * 물론, 서블릿 객체를 호출하는 과정에서 인자로 전달되는 `HttpServletRequest`와 `HttpServletResponse` 객체는 매 요청마다 새로 생성된다.
* 모든 **서블릿 객체는 최초로 호출되는 시점에 미리 생성되며, 이후 클라이언트의 요청에 대해서는 매번 기생성된 서블릿 객체를 재활용**횐다.
  * 나아가 이렇게 생성된 서블릿 객체들은 서블릿 컨테이너가 종료되는 시점에 함께 종료된다.

## 2024-03-30 Sat
### WAS의 스레드 활용
* 어떠한 클라이언트로부터 WAS가 요청을 받는 경우, WAS는 다음의 절차에 따라 응답한다.
  1. 클라이언트와 TCP/IP 기반의 연결을 수립한다.
  2. **스레드를 활용하여 서블릿 객체를 호출**한다.
  3. 서블릿을 통해 응답을 생성한 후, 반환한다.

## 2024-03-31 Sun
### 스레드란?
* 이렇듯 **서블릿에 작성된 코드를 하나하나 실행하는 것은 스레드이며, 애초에 Java는 메인 메소드를 실행할 때 main이라는 이름의 스레드가 이를 실행**한다.
  * 바꿔 말해 스레드 없이는 Java 애플리케이션을 실행할 수 없다.
* 스레드는 한 번에 하나의 코드만을 실행할 수 있으므로, 동시성 처리가 필요한 경우에는 스레드를 추가로 생성해줄 필요가 있다.
  * 만약 동시성 처리가 필요하지만 단일 스레드만 사용하여 애플리케이션을 실행한 경우, 첫 번째 연결의 응답이 완료되기 전에 요청된 두 번째 연결은 지연된다.
  * 즉, 이러한 **스레드의 동작은 기본적으로 블로킹 IO이므로 스레드보다 많은 수의 요청이 발생한 경우 장애로 이어지기 쉽다**.

## 2024-04-01 Mon
### 무분별한 스레드 생성의 문제점
* 그러나 요청마다 스레드를 새로 생성할 경우 동시성 문제를 일시적으로 해결할 수 있으나, 다음과 같은 문제에 봉착하게 된다.
  1. 스레드는 생성 비용이 비싸므로, 매 요청마다 스레드를 생성하는 과정에서 응답 시간이 지연되기 쉽다.
  2. 멀티 스레드 환경의 경우, 스레드 간의 컨텍스트 스위칭 비용이 발생한다.
  3. 전체 스레드 개수에 제한을 두지 않을 경우, 스레드가 계속해서 생성되어 결과적으로는 CPU 임계점을 넘어 서버가 다운될 수 있다.

## 2024-04-02 Tue
### WAS의 스레드 풀 활용
* 상술한 스레드 생성 문제로 인해, 대부분의 WAS는 설정을 기반으로 최대 스레드 개수를 관리할 수 있는 스레드 풀 개념을 활용한다.
  * **톰캣의 경우 스레드 풀에 기본적으로 200개의 스레드가 생성되며, 각 요청에 대해 기생성된 스레드를 할당하여 처리**한다.
  * 또한, **요청에 대해 응답이 완료된 경우 스레드를 종료하는 대신 풀에 반납하여 재사용성을 향상**시킨다.
* **스레드 풀을 사용하는 경우, 전체 스레드 개수 이상의 요청은 WAS 설정에 따라 일정 개수만큼 대기되거나 거절**될 수 있다.
* 상술한 특징으로 인해, 스레드 풀은 스레드를 생성하거나 종료하는 데에 소모되는 비용을 절약하고 응답 시간을 줄일 수 있다.
  * 또한, **전체 스레드 개수의 상한이 설정으로 관리되므로 너무 많은 요청이 수신되더라도 기존 요청을 안전하게 처리할 수 있다**.

## 2024-04-03 Wed
### 실무에서의 WAS 최적화
* **실무에서도 WAS의 주요한 최적화 포인트는 최대 스레드 개수로, 이를 잘 설정할 경우 극적인 성능 향상을 얻을 수도** 있다.
  * 예를 들어 최대 스레드 개수가 너무 낮으면 서버 리소스를 비효율적으로 사용하게 되며, 클라이언트의 응답 시간에 지연이 쉽게 발생할 수 있다.
  * 반면, 최대 스레드 개수가 너무 많다면 동시성 처리 과정에서 CPU 및 메모리 등 리소스 임계점 초과로 인해 서버가 다운되는 문제가 발생할 수 있다.
* 실무의 경우, 장애가 발생한 경우에 우선 클라우드 기반 서버를 늘린 후에 별도의 환경에서 최적화 및 테스트를 진행하는 식으로 대처하게 된다.
* 적합한 **최대 스레드 개수의 경우 애플리케이션 로직의 복잡도 또는 CPU 등 하드웨어 상황에 따라 모두 다르므로, 철저한 성능 테스트가 필수적**이다.
  * 이 때, 성능 테스트 과정에서는 아파치 `ab`나 네이버의 `nGrinder` 등의 도구를 활용해볼 수 있다.

## 2024-04-04 Thu
### WAS의 멀티 스레드 환경 지원
```
> WAS는 복잡한 멀티 스레드 환경을 지원하는 것으로 개발자의 개발 생산성을 크게 높여주는 데에 의의가 있다.
```
* 결국 **중요한 것은 WAS 차원에서 멀티 스레드 환경을 지원한다는 것으로, 덕분에 개발자는 멀티 스레드와 관련된 작업을 신경쓸 필요가 없다**.
  * 대신, 마치 싱글 스레드 프로그래밍을 진행하듯이 편하게 코딩을 진행할 수 있다.
* 이렇듯 **WAS가 멀티 스레드 관련된 내용을 대신 처리해주긴 하지만, 애플리케이션 상의 싱글톤 객체와 공유 변수 활용에 대해서는 특히 주의**를 기울여야 한다.

## 2024-04-05 Fri
### Java 웹 기술의 역사
* 개발자들이 모든 HTTP 연결에 대해 소켓을 처리하고, 멀티 스레드 환경을 구성하는 수고를 덜어주기 위해 서블릿이 고안되었다.
  * 그러나 서블릿은 Java를 기반으로 하기에 동적인 HTML 생성이 어려운 단점이 존재한다.
* 이러한 문제를 해결하기 위해 HTML의 작성이 편리한 JSP가 고안되었으며, 또한 JSP는 내부적으로는 서블릿을 기반으로 동작했다.
  * 그러나 JSP로 작성된 로직은 너무 많은 역할을 담당하여 유지보수성이 떨어지는 단점이 존재한다.
* 이러한 문제를 해결하기 위해 서블릿과 JSP를 조합한 MVC 패턴이 고안되었으며, 이러한 방식은 모델과 뷰 및 컨트롤러의 책임을 분리할 것을 제안한다.
  * 이는 곧 핵심적인 비즈니스 로직과 렌더링 로직의 책임을 분리하는 것과 같다.
* MVC 패턴이 유행함에 따라 개발자들은 MVC 패턴을 자동화하여 복잡한 웹 기술을 편리하게 사용할 수 있는 기능들을 제작하게 되었다.
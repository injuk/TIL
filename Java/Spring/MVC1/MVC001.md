# Spring MVC I
## 2024-03-22 Fri
### 웹 서버와 웹 애플리케이션 서버
```
> 웹 서버는 정적 리소스를 제공하는 반면, 웹 애플리케이션 서버는 여기에 더해 애플리케이션을 실행할 수 있다.
```
* 웹은 기본적으로 HTTP 통신을 기반으로 하므로, 클라이언트로부터 서버로의 데이터 전송과 서버의 응답은 모두 HTTP를 사용한다.
    * 이 때, HTTP로 주고받을 수 있는 데이터에는 사실상 제한이 없으며 이미지나 영상은 물론 JSON 등의 데이터까지도 전송이 가능하다.
* 이 때, **웹 서버는 HTTP를 기반으로 동작하며 HTML 등 정적 리소스를 반환하는 nginx나 아파치 서버 등을 의미**한다.
    * 이러한 특징으로 인해 **웹 서버는 모든 경우에 반드시 필요한 것은 아니며, 단순히 API를 기반으로 데이터만 주고 받는 경우에는 WAS만 사용**할 수도 있다.
* 반면 **웹 애플리케이션 서버는 애플리케이션 로직을 수행하는 것을 의미하며, HTTP 기반으로 동작하면서 정적 리소스를 반환하는 웹 서버의 기능을 포함**한다.
    * 이 때, WAS에는 톰캣과 Jetty 등이 포함되며 내부적으로는 서블릿이나 JSP 또는 스프링 MVC를 실행할 수 있다.
* 이러한 차이로 인해 웹 서버는 접속한 사용자마다 다른 정보를 반환할 수 없으나, 웹 애플리케이션 서버는 사용자 별로 다른 화면을 제공하는 것이 가능하다.

## 2024-03-23 Sat
### 웹 서버와 웹 애플리케이션 서버를 '정확'하게 구분하기?
* 일반적으로 웹 서버가 정적 리소스를 처리하는 반면 WAS는 애플리케이션 로직을 다루는 것으로 알려져 있으나, 정확히는 둘 사이의 용어나 경계가 모호하다.
  * 예를 들어, 웹 서버도 애플리케이션을 실행하는 기능을 포함할 수 있는 반면 WAS도 웹 서버의 기능을 포함한다.
* 이러한 이유에서, **일반적인 Java 애플리케이션은 서블릿 컨테이너 기능을 제공하면 WAS로 취급**하기도 한다.
* 그럼에도 가장 쉬운 분류 방법은 웹 서버가 정적 리소스를 처리하고, WAS는 애플리케이션 코드까지 실행할 수 있다는 차이를 두는 것이다.

## 2024-03-24 Sun
### 각 요소를 조합한 웹 애플리케이션 구성하기
* WAS는 애플리케이션 로직을 수행할 수 있으면서도 정적 리소스를 제공할 수 있으므로, 실제로는 WAS와 DB만으로 웹 애플리케이션을 구성할 수 있다.
* 그러나 이러한 경우 **WAS가 너무 많은 역할을 담당하게 되므로, 정적 리소스 처리로 인해 중요한 애플리케이션 코드가 지연되는 등 과부하가 발생**하기 쉽다.
  * 최악의 경우 WAS애 장애가 발생하게 되면 정적 리소스의 일종인 오류 화면조차 표현이 불가능해질 수 있다.
* 규모가 작은 애플리케이션의 경우 상술한 방식만으로도 구축할 수 있으나, 일반적인 경우 WAS 앞에 웹 서버를 두어 정적 리소스에 대한 처리를 위임하게 된다.
  * 반면, 웹 서버는 애플리케이션 로직과 같은 동적인 처리가 필요한 경우에 WAS에 요청을 위임하게 된다.
* 이러한 방식을 사용할 경우, 가벼운 정적 리소스는 웹 서버가 처리하게 되므로 WAS는 중요한 애플리케이션 로직에만 집중할 수 있다.
  * 나아가 **요청된 리소스의 종류에 따라 웹 서버를 증설하거나 WAS를 증설하는 등, 효율적이고도 유연한 리소스 관리가 가능**하다.
  * 또한 **잘 다운되는 WAS와 달리 웹 서버는 잘 다운되지 않으므로, WAS나 DB 장애 발생시 웹 서버가 오류 화면을 제공**할 수도 있다.

## 2024-03-25 Mon
### 백엔드 애플리케이션에 구현되어야 할 기초적인 기능
* 예를 들어 form을 기반으로 임의의 URI에 POST 요청을 보내는 기능을 구현하려면, 개발자는 크게 다음과 같은 내용을 개발해야 한다.
  1. HTTP는 기본적으로 TCP를 사용하므로, TCP/IP 연결을 대기하는 서버를 작성한다.
  2. 요청이 수신된 경우, 소켓에 연결한다.
  3. 모든 HTTP 요청은 기본적으로 단순한 텍스트에 불과하므로, 해당 내용을 분석하기 위해 파싱한다.
  4. `Content-Type`에 따라 HTTP 요청 본문까지 파싱한다.
  5. 파싱된 결과에 따라 적절한 API로 라우팅하여 처리 메소드를 호출한다.
  6. 적절한 비즈니스 로직을 실행하되, 필요한 경우 DB에 저장한다.
  7. 헤더와 HTML 등의 HTTP 응답 본문을 포함하는 HTTP 응답 메시지를 작성한다.
  8. TCP/IP를 기반으로 응답을 전달한다.
  9. 소켓을 종료한다.
* 상술한 내용에서, 정작 **중요한 것은 여섯 번째 과정인 순수한 비즈니스 로직이지만 단지 이를 위해 처리되는 전처리 및 후처리 단계가 너무 많고 반복적**이다.

## 2024-03-26 Tue
### 서블릿이란?
* **서블릿은 이러한 문제를 해결하기 위해 등장하였으며, 순수한 비즈니스 로직 외의 모든 전처리 및 후처리 단계를 제공**한다.
  * 따라서 개발자는 서블릿을 지원하는 WAS를 사용하는 것으로, 순수한 비즈니스 로직에만 집중할 수 있다.
* 기본적인 서블릿은 아래와 같이 작성할 수 있으며, **`urlPatterns`에 명시된 URI가 외부로부터 호출된 경우 서블릿의 코드가 실행**된다.
```java
@WebServlet(name ="myServlet", urlPatterns="/my")
public class MyServlet extends HttpServlet {
    @Override
    protected void service(HttpServletRequest req, HttpServletResponse res) {
        // 비즈니스 로직을 작성한다.
    }
}
```
* 서블릿은 상술한 전처리 및 후처리 단계 처리의 피로도를 낮추기 위해 다음과 같은 두 가지 클래스를 제공한다.
  * `HttpServletRequest`: 개발자가 요청 정보를 편리하게 활용할 수 있도록 HTTP 요청을 파싱하여 인자로 전달한다.
  * `HttpServletResponse`: 개발자가 요청에 대한 응답을 편리하게 생성할 수 있도록 HTTP 응답을 인스턴스화하여 인자로 전달한다.
* 이렇듯 **서블릿을 사용할 경우, 개발자는 HTTP 사양을 매우 편리하게 준수**할 수 있게 된다.
  * 물론 HTTP 스펙에 대한 전반적인 이해는 필수적이며, 어떤 요청이 인스턴스화 되고 어떤 인스턴스가 어떤 형태의 응답으로 변환될지 예상할 수 있어야 한다.

## 2024-03-27 Wed
### HTTP 요청에 대한 WAS의 처리 과정
* 웹 브라우저 등의 클라이언트가 서버에 HTTP 요청을 전송한 경우, 해당 요청은 크게 다음과 같은 과정을 거쳐 처리된다.
  1. 웹 브라우저는 HTTP를 기반으로 서버에 요청을 전송한다.
  2. WAS는 클라이언트의 요청을 기반으로 `HttpServletRequest`와 `HttpServletResponse` 객체를 생성한다.
  3. 만들어진 두 객체를 서블릿 컨테이너에 위치한 서블릿에 전달하여 실행한다.
  4. 서블릿의 실행이 종료될 경우, 서블릿 내에 작성된 코드에 의해 `HttpServletResponse` 객체에서 HTTP 응답을 표현하기 위한 데이터가 설정된다.
  5. `HttpServletResponse` 객체를 기반으로 HTTP 응답 메시지를 생성한 후, 클라이언트인 웹 브라우저에 이를 반환한다.
* 이렇듯 **HTTP 요청에 대해 WAS는 요청과 응답을 대표하는 객체를 생성한 후 서블릿을 호출하는 방식으로 동작**한다.
  * 때문에 개발자는 요청과 응답 객체를 기반으로 비즈니스 로직을 의미하는 서블릿 코드의 작성에만 집중할 수 있다.
  * 나아가 **서블릿 코드의 실행이 종료된 경우, WAS는 응답 객체의 내용을 기반으로 HTTP 응답을 생성**한다.

## 2024-03-28 Thu
### 서블릿 컨테이너란?
```
> 서블릿 컨테이너는 WAS 내부에 적재되어 개발자가 작성한 서블릿 객체를 생성하며, HTTP 요청을 처리하기 위한 서블릿 호출까지 담당한다.
```
* 개발자가 작성한 **서블릿 객체를 생성하기 위한 별도의 코드를 작성할 필요는 없으며, 서블릿 객체의 생성 책임은 서블릿 컨테이너**에 있다.
  * 이러한 **서블릿 컨테이너는 서블릿을 지원하는 WAS이며, 다시 말해 톰캣과 같이 서블릿을 지원하는 WAS를 곧 서블릿 컨테이너라고 지칭**한다.
* **서블릿 컨테이너는 또한 서블릿의 생명 주기를 담당하므로, WAS가 다운될 때 서블릿을 종료시키는 역할까지 수행**한다.
  * 즉, **서블릿 컨테이너의 책임은 서블릿 객체의 생성과 호출 및 관리**에 있다.
* 또한, 서블릿을 지원하는 WAS는 클라이언트로부터의 동시 요청을 처리하기 위해 멀티 스레드 기반의 처리 방식을 활용한다.
  * 때문에 동시성에 대한 처리는 개발자가 딱히 멀티 스레딩에 신경쓰지 않았더라도 WAS 차원에서 적용된다.

## 2024-03-29 Fri
### 서블릿과 서블릿 컨테이너의 특징
```
> 모든 서블릿 객체는 서블릿 컨테이너에 의해 싱글톤으로 관리된다.
```
* 클라이언트의 요청마다 서블릿 객체를 생성하는 것은 효율적이지 못하기에 서블릿 객체는 싱글톤으로 관리된다.
  * 즉, **각 요청은 동일한 서블릿 객체에 의해 처리될 수 있으므로 서블릿 객체는 공유 변수 사용에 있어 반드시 주의**를 기울여야 한다.
  * 물론, 서블릿 객체를 호출하는 과정에서 인자로 전달되는 `HttpServletRequest`와 `HttpServletResponse` 객체는 매 요청마다 새로 생성된다.
* 모든 **서블릿 객체는 최초로 호출되는 시점에 미리 생성되며, 이후 클라이언트의 요청에 대해서는 매번 기생성된 서블릿 객체를 재활용**횐다.
  * 나아가 이렇게 생성된 서블릿 객체들은 서블릿 컨테이너가 종료되는 시점에 함께 종료된다.
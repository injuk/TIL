# Spring MVC I
## 2024-04-22 Mon
### HTTP Servlet Response를 활용한 리다이렉트 구현
* 예를 들어 HTTP 응답의 코드가 `302`이고 `Location` 헤더에 적절한 경로가 정의된 경우, 웹 브라우저 등은 자동으로 해당 경로에 리다이렉트하도록 동작한다.
  * 서블릿을 활용할 경우, 이러한 코드 역시 다음과 같이 간단히 구현해볼 수 있다.
```kotlin
@WebServlet(name = "responseHeaderServlet", urlPatterns = ["/response-header"])
class ResponseHeaderServlet: HttpServlet() {
    override fun service(request: HttpServletRequest?, response: HttpServletResponse?) {

        response?.run {
//            응답 코드가 302이고, Location 헤더에 리다이렉트 대상을 설정한다.
            status = HttpServletResponse.SC_FOUND
            setHeader("Location", "/basic/hello-form.html")
          
//          또는 아래와 같이 한 줄로 처리할 수도 있다! 
//          sendRedirect("/basic/hello-form.html")

            setHeader("Cache-Control", "no-cache, no-store, must-revalidate")
            setHeader("Pragma", "no-cache")
        }
    }
}
```

## 2024-04-23 Tue
### HTTP Servlet Response를 활용한 HTML 응답
* HTTP 서블릿 응답 역시, 크게 다음과 같은 세가지 분류로 나눠볼 수 있다.
  1. 단순 텍스트로 응답하기
  2. HTML을 응답하기
  3. JSON 형태 등의 응답 본문을 갖는 HTTP API로 응답하기
* 이 때, 단순 텍스트 응답의 경우 상술한 `writer.println("good")` 방식에 해당한다.
* 반면, HTML 응답의 경우 서블릿을 활용하여 다음과 같이 간단히 작성해볼 수 있다.
```kotlin
@WebServlet(name = "responseHtmlServlet", urlPatterns = ["/response-html"])
class ResponseHtmlServlet: HttpServlet() {
    override fun service(request: HttpServletRequest?, response: HttpServletResponse?) {
        if(response != null) {
            response.contentType = "text/html"
            response.characterEncoding = "utf-8"

            with(response.writer) {
                println("<html>")
                println("<body>")
                println("<div>나의 HTML!!!</div>")
                println("</body>")
                println("</html>")
            }
        }
    }
}
```

## 2024-04-24 Wed
### HTTP Servlet Response를 활용한 JSON 응답
* 어떠한 요청에 대해 JSON 또는 XML을 응답 본문에 포함시키는 것은 주로 HTTP API 서버에서 활용되며, 이는 다음과 같이 간단히 구현해볼 수 있다.
  * **JSON을 예로 들어, 이 역시 문자열에 불과하므로 컨텐츠 타입만 잘 설정해주면 큰 문제 없이 구현** 할 수 있다.
  * 또한, 임의의 객체를 JSON 형태의 문자열로 변환하기 위해서는 상술했던 Jackson을 아래와 같이 활용할 수 있다.
```kotlin
@WebServlet(name = "responseJsonServlet", urlPatterns = ["/response-json"])
class ResponseJsonServlet: HttpServlet() {
    companion object {
        private val logger = LoggerFactory.getLogger(RequestBodyJsonServlet::class.java)
        private val mapper = ObjectMapper().registerModules(
            KotlinModule.Builder()
                .build()
        )
    }
    override fun service(request: HttpServletRequest?, response: HttpServletResponse?) {
        response?.run {
            contentType = "application/json"

            HelloData(
                username = "ingnoh",
                age = 3,
            ).also {
                val body = mapper.writeValueAsString(it)

                writer.write(body)
            }
        }
    }
}
```
* 이 때, **`application/json`은 스펙상 UTF8을 사용하도록 명시가 되어 있으므로 캐릭터 셋을 별도로 명시할 필요가 없다**.
  * 애초에 캐릭터 셋과 같은 추가 파라미터를 지원하지도 않으며, 이를 명시하는 것은 오히려 무의미한 파라미터를 구태여 추가하는 것으로 이해할 수 있다.

## 2024-04-25 Thu
### 서블릿의 한계와 템플릿 엔진의 등장
* 서블릿을 활용할 경우 동적인 HTML을 생성하여 사용자에게 응답할 수 있으나, 정작 HTML을 처리하는 것 자체에 대한 지원이 없어 매우 비효율적이다.
  * 이는 Java 코드 상에 HTML을 끼워넣기 때문으로, 역으로 HTML에 Java 코드를 끼워넣을 수 있다면 생산성을 더 높아질 수 있다.
* 이러한 배경에서 **Thymeleaf 등의 템플릿 엔진이 등장했으며, 이는 HTML 문서 상 필요한 곳만 코드를 작성하여 동적인 문서를 생성**할 수 있도록 한다.
  * JSP 역시 템플릿 엔진의 일종이나, 현재로서는 성능과 기능 면에서 다른 템플릿 엔진에 밀려 사장되는 추세를 보이고 있다.

## 2024-04-26 Fri
### JSP 활용하기
* JSP를 사용할 경우, jsp 확장자 파일의 첫 줄은 반드시 `<%@ page contentType="text/html;charset=UTF-8" language="java" %>`여야 한다.
* 이는 해당 문서가 JSP 문서임을 의미하며, 이렇게 **작성된 JSP는 내부적으로는 서블릿으로 변환**된다.
  * 또한, 내부적으로 서블릿으로 변환되는 JSP의 특성상 `HttpServletRequest`와 `HttpServletResponse`는 별도의 작업 없이 바로 접근이 가능하다.
* JSP 상에서는 Java 코드를 그대로 사용할 수 있으며, Java를 작성하기 위한 문법은 크게 다음과 같다.
  1. `<%@ page import="패키지명" %>`: Java의 import 구문과 같다.
  2. `<% // Java 코드 %>`: 해당 블록 내에서 Java 코드를 작성할 수 있다.
  3. `<%= // Java 코드 %>`: 해당 블록 내에서 작성된 Java 코드를 그대로 출력한다.
* 이렇게 작성된 **JSP 문서는 전체적으로 서블릿 코드와 같지만, HTML을 중심으로 작성되며 부분적으로만 Java 코드가 작성된다는 점에서 차이**가 있다.
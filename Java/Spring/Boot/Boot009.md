# Spring Boot
## 2025-07-27 Sun
### 그라파나 설치하기
* 그라파나 공식 홈페이지에서 파일을 다운로드한 후 압축을 풀 경우, `bin` 폴더 내에 `grafana-server` 파일을 실행해준다.
    * macOS의 경우, 해당 경로에서 `./grafana-server` 명령어를 입력한다.
    * 이 때, 프로메테우스와의 상호작용을 위해 프로메테우스를 종료하지 않도록 한다.
* 그라파나의 기본 포트는 3000번이며, 접속 후 기본 사용자 정보인 `admin` - `admin`을 입력하여 접속한다.
    * 이렇듯 그라파나는 기본적인 콘솔을 지원하며, 프로메테우스와 연동할 경우 지표 정보를 쉽게 시각화할 수 있도록 지원한다.

## 2025-07-28 Mon
### 그라파나와 프로메테우스를 연동하기
* 그라파나는 프로메테우스를 통해 데이터를 조회하고 시각화하는 역할을 수행하며, 이는 그라파나가 일종의 래퍼 역할을 담당하는 것으로 이해할 수 있다.
* 임의의 애플리케이션은 마이크로미터 표준 측정 방식을 통해 지표 정보를 생성하고, 프로메테우스는 프로메테우스 구현체를 통해 이를 지속적으로 수집한다.
    * 이렇게 수집된 지표 정보는 프로메테우스에 저장될 것이므로, 그라파나는 이를 조회하여 시각화하는 역할을 담당한다.
* 그라파나 콘솔에 접속한 후, 설정의 `Add data source` 버튼을 클릭하여 프로메테우스 서버 정보를 입력한다.
    * 입력을 마친 후 하단의 `Save & test` 버튼을 클릭할 경우, 큰 문제가 없다면 연동된 것을 확인할 수 있게 된다.
* 프로메테우스 연결 정보를 입력한 후, 다시 설정 페이지에 접속할 경우 `Data sources`에 프로메테우스가 등록된 것을 확인할 수 있다.

## 2025-07-29 Tue
### 대시보드와 패널
* 그라파나 대시보드를 실행하기 위해서는 모니터링 대상 애플리케이션과 프로메테우스, 그라파나가 반드시 모두 실행된 상태여야 한다.
* 좌측의 메뉴로부터 대시보드 메뉴를 찾아 진입한 후, `New` 버튼을 클릭하여 새로운 대시보드를 생성한다.
    * 버튼 클릭시 대시보드는 바로 생성되며, 우측 상단의 `Save dashboard` 버튼을 클릭하여 이름을 지정할 수 있다.
* 우측 상단의 `Add panel` 버튼을 활용하여 지표 정보를 시각화할 수 있다.
    * 이렇듯 **그라파나의 대시보드는 시각화된 결과를 의미하지 않으며, 시각화된 결과는 패널이라는 이름의 구성 요소로 관리**된다.
    * 반면, **대시보드는 여러 패널을 포함하는 하나의 큰 단위로 이해**할 수 있다.

## 2025-07-30 Wed
### 그라파나와 공유 대시보드
* 상술한 그라파나의 대시보드와 패널을 통해, 적절한 지표 정보를 시각화된 그래프 형태로 확인할 수 있다.
    * 그러나 최초로 대시보드를 설정하는 과정은 예상 이상으로 번거로우며, 수작업으로 진행되기에 휴먼 에러 발생 가능성이 높다.
* 그라파나는 대시보드 설정을 공유할 수 있도록 하는 공유 대시보드 기능을 지원하며, 예를 들어 스프링에 특화된 공유 대시보드들을 가져다 사용할 수 있다.
* 예를 들어, `https://grafana.com/grafana/dashboards` 링크에서 여러 사용자들에 의해 생성된 공유 대시보드들을 확인할 수 있다.

## 2025-07-31 Thu
### 공유 대시보드의 장점
* 다른 사용자들이 이미 만들어둔 공유 대시보드를 활용할 경우, 직접 작업하지 않으므로 편리하면서도 유지보수성이 좋다.
    * 덕분에 양질의 모니터링 환경을 편리하게 구성할 수 있다.
* 반면, 각 대시보드에 포함된 패널의 지표 설정을 분석하는 것으로 추후 원하는 그라파나 대시보드를 구성해야할 때에 대비할 수 있다.
    * 그라파나 대시보드 구성은 러닝 커브가 다소 있는 편이지만, 다른 사용자들이 제작해둔 양질의 공유 대시보드는 좋은 교재가 되어준다.
    * 실무적인 관점에서, 그라파나를 깊이 있게 학습하는 것도 좋지만 마치 도구를 사용하듯 바로 사용 가능한 정도로 실용성에 초점을 두는 것을 고려할 수 있다.

## 2025-08-01 Fri
### 그라파나와 지표 정보를 활용한 모니터링 대상
* 애플리케이션에서 실제로 문제가 발생한 경우, 그라파나를 통해 이를 조기에 모니터링한 후 대응할 수 있어야 한다.
* 이 때, **실무에서는 일반적으로 다음과 같은 상황이 자주 발생하므로 이들 지표 정보를 그라파나를 통해 각각 어떻게 모니터링하는지 알아두는 것은 필수적**이다.
    1. CPU 사용량 초과
    2. JVM 메모리 사용량 초과
    3. 커넥션 풀 고갈
    4. 에러 로그 급증

## 2025-08-02 Sat
### 그라파나를 활용한 CPU 지표 확인
* 에를 들어 애플리케이션에 CPU 관련한 문제가 발생한 상황을 가정하기 위해서는 다음과 같은 CPU 부하를 주는 코드를 작성해볼 수 있다.
    * Postman 등의 도구를 통해 해당 API를 호출할 경우, for 문 처리를 위해 즉각적인 응답이 반환되지 않고 다소 시간이 걸리는 것을 확인할 수 있다.
```kotlin
@Slf4j
@RestController
class TestController {

    @GetMapping("cpu")
    fun cpu(): String {
        log.info("cpu!")
        var value: Long = 0
        for (i in 1..1000000000000L) {
            value++
        }

        return "result: $value"
    }
}
```
* 이를 통해 그라파나 대시보드로부터 CPU 사용량 증가 지표 정보를 확인할 수 있으나, 프로메테우스의 지표 수집은 동기적이지 않으므로 약간의 시간이 필요하다.

## 2025-08-03 Sun
### 그라파나를 활용한 JVM 메모리 지표 확인
* 에를 들어 애플리케이션에 JVM 메모리와 관련된 문제가 발생한 상황을 가정하기 위해서는 다음과 같이 데이터를 메모리에 누적하는 코드를 작성해볼 수 있다.
```kotlin
@Slf4j
@RestController
class TestController {
    private val myList: List<String> = mutableListOf()

    @GetMapping("jvm")
    fun jvm(): String {
        log.info("jvm!")
        for (i in 1..10000000L) {
            myList.add("idx: $i")
        }

        return "done"
    }
}
```
* 이를 통해 그라파나 대시보드로부터 JVM 메모리 사용량 증가 지표 정보를 확인할 수 있다.
* 반면, 해당 API를 연속적으로 수십 회 이상 호출할 경우 일정 시점부터는 더 이상 브라우저가 서버로부터 응답을 받지 못하는 상황이 찾아오게 된다.
    * 이는 `OutOfMemoryError` 때문이며, 서버 로그를 활용할 경우 동명의 예외가 발생한 것을 확인할 수 있다.
* 이는 GC를 적용할 수 없도록 데이터가 누적되는 경우에 주로 발생하며, 실무의 경우 새로운 서버를 띄우고 문제가 발생한 서버를 트러블슈팅하는 식으로 조치한다.
* 또한, **메모리 이슈의 경우 해당 시점으로부터는 지표 정보 역시 잘 수집되지 않을 수 있으므로 이러한 문제는 조기에 발견하고 처리하는 것이 바람직**하다.

## 2025-08-04 Mon
### 그라파나를 활용한 JDBC 커넥션 지표 확인
* 에를 들어 애플리케이션에 JDBC 커넥션과 관련된 문제가 발생한 상황을 가정하기 위해서는 다음과 같이 의도적으로 커넥션을 닫지 않는 코드를 작성해볼 수 있다.
    * **스프링 부트는 일반적으로 HikariCP를 사용하여 커넥션을 가져오며, 사용 후에는 반드시 커넥션을 닫아주어야 커넥션 풀에 반환되어 재사용이 가능**하다.
```kotlin
@Slf4j
@RestController
class TestController(
    private val dataSource: DataSource,
) {
    @GetMapping("jdbc")
    fun jdbc(): String {
        log.info("jdbc!")
        val conn = dataSource.getConnection()
        log.info("conn={}", conn)

        // 의도적으로 커넥션을 닫지 않고 유지하기
        // conn.close()

        return "done"
    }
}
```
* 상술한 코드의 경우, **API를 호출할 때마다 커넥션이 닫히지 않아 점유된 상태를 유지하는 데드 커넥션 현상이 발생**하게 된다.
    * 다시 말해, **커넥션 풀에 커넥션을 반환하지 않으므로 사용된 커넥션은 모두 액티브한 상태를 유지**하게 된다.

## 2025-08-05 Tue
### JDBC 커넥션 지표와 Pending 커넥션
* 해당 API를 지속적으로 호출할 경우 일정 시점부터는 더 이상 브라우저가 서버로부터 응답을 받지 못하는 상황이 찾아오게 된다.
    * 이는 애플리케이션이 사용 가능한 모든 커넥션을 소진했기 때문으로, 지표에서는 `Pending Connection` 개수로 이를 확인 할 수 있다.
    * 예를 들어 대시보드의 임의의 시점에서 `Active` 10, `Idle` 0 및 `Pending` 1이 노출된다면 10개의 커넥션을 사용하고 1개가 대기 중임을 의미한다.
* 반면, **스프링 부트 애플리케이션은 기본적으로 30초간 커넥션을 얻지 못할 경우 `Timeout`으로 처리**한다.
    * 이 경우, 대시보드에는 `Connection Timeout Count` 지표로 해당 정보를 확인할 수 있다.
* **실무의 경우 `JDBC Template`과 `JPA`가 자주 사용되므로 커넥션을 자동으로 처리하여 커넥션을 깜빡하고 닫지 않는 현상은 잘 발생하지 않는다**.
    * 오히려 **임의의 쿼리가 최적화되지 않았거나 락이 설정된 것으로 인해 응답이 오래 걸릴 경우 발생하기 쉬우므로 해당 부분을 개선하는 것이 바람직**하다.

## 2025-08-06 Wed
### 그라파나를 활용한 에러 로그 지표 확인
* 에를 들어 애플리케이션에 에러 로그가 급증하는 상황을 가정하기 위해서는 다음과 같이 의도적으로 많은 에러 코드를 출력하는 코드를 작성해볼 수 있다.
```kotlin
@Slf4j
@RestController
class TestController {
    @GetMapping("error-log")
    fun errorLog(): String {
        log.error("errorLog!")

        return "failed"
    }
}
```
* 해당 API를 수십 회 이상 호출할 경우, 그라파나 대시보드의 `ERROR logs` 패널에서 해당 정보를 확인할 수 있다.

## 2025-08-07 Thu
### 그라파나의 의의
```
> 지표 정보를 확인하는 것은 `정확한 값`에 집착하기 위함이 아니며, 대략적인 값과 그 추세로부터 통찰을 얻는 데에 의의가 있다.
```
* 여러 사용자에게 실시간 서비스를 제공하는 경우, 상술한 각 지표는 모두 주요한 의미를 가지며 개발자는 1초라도 빨리 장애 상황을 인식할 수 있어야 한다.
* 반면, 예상치 장애가 발생한 경우 우선 시각화된 대시보드를 통해 어떤 문제가 발생했는지 파악한 후 적절한 조치를 취해야 한다.
* 이렇듯 **그라파나와 같은 지표 정보를 시각화하는 도구를 사용할 경우, 장애 상황에서 문제를 빠르게 파악하고 트러블 슈팅 범위를 크게 좁힐 수 있다**.
* 또한, **여러 지표 정보와 이에 대한 시각화는 100%의 정확도에는 못미치는 대략적인 값과 추세를 실시간으로 확인하는 데에 그 의의**를 두어야 한다.
    * 오히려 **지표 정보 값은 정확하지 않을 수 있고, 심지어는 누락되어 수집되지 않는 지표 정보도 발생할 수 있다는 점을 기꺼이 받아들여야 한다**.
    * 바꿔 말해, 그라파나를 사용하는 이유는 정확한 시점과 해당 시점에서 발생한 정확한 수치의 값을 파악하기 위함이 아니라는 점을 기억할 필요가 있다.

## 2025-08-08 Fri
### 비즈니스 메트릭의 필요성
* **여지껏 다룬 모든 지표는 모든 서버 애플리케이션에서 활용 가능한 범용적인 지표 정보였으며, 바꿔 말해 임의의 도메인에 특화된 지표로 볼 수는 없다**.
* 각각의 서버 애플리케이션의 경우 해당 서버가 다루는 도메인이 있으며, 개발자는 각 도메인에 특화된 정보를 모니터링하고 싶을 수 있다.
    * 예를 들어, 배달 애플리케이션의 경우 주문 수와 취소 수 및 재고 수량 등의 지표 정보를 확인하고 싶을 수 있다.
    * 이러한 지표 정보들은 모든 서버 애플리케이션에서 공통으로 사용할 수 있는 개념이 아니며, 오히려 각 비즈니스에 특화된 내용으로 이해할 수 있다.
* **이러한 지표 정보들을 비즈니스 메트릭이라는 용어로 지칭하며, 이를 통해 기술적으로 해결할 수 없는 비즈니스적인 문제를 빠르게 파악할 수 있다**.
    * 예를 들어, 주문 취소 수가 급증하더라도 서버 자체적인 성능 지표인 CPU나 메모리 사용량에는 영향이 없다.
    * 반면, 비즈니스 도메인과 관련된 지표 정보를 모니터링하고 있다면 이러한 문제를 빠르게 파악하여 조치할 수 있다.
* 물론, 비즈니스 메트릭은 각 비즈니스 도메인마다 달라질 수 밖에 없기에 필요한 지표 정보 각각을 개발자가 직접 등록하고 확인하는 작업이 전제된다.

## 2025-08-09 Sat
### 실무적인 지표 정보 모니터링 전략
* 비즈니스 도메인과 관련된 모든 지표를 처음부터 모두 예상하여 지표 정보를 수집할 수 있도록 개발한 후 모니터링하는 것은 다소 비현실적일 수 있다.
* 반면, 시스템이 기본으로 제공하는 지표 정보의 경우 모든 서버 애플리케이션에서 유용하게 사용될 수 있는 정보이므로 기본적으로 모니터링해야 한다.
* 이에 따라, 실무에서 적용 가능할 정도로 실용적인 모니터링 전략은 다음과 같이 생각해볼 수 있다.
    1. 기본적인 지표 정보의 경우, 모든 백엔드 서버에서 기본적으로 모니터링하도록 한다.
    2. 임의의 비즈니스에 특화된 비즈니스 메트릭의 경우, 필수적인 것을 우선적으로 모니터링하되 필요에 따라 수집되는 지표의 종류를 점진적으로 늘려나간다.
* 이러한 전략을 기반으로 필요에 따라 지표 정보를 모니터링할 경우, 개발 비용이 너무 과도하지 않으면서도 세밀한 모니터링이 가능하다.

## 2025-08-17 Sun
### MeterRegistry란?
* **마이크로미터를 활용하면 나만의 지표 정보를 직접 등록할 수 있으며, 이 경우 `MeterRegistry`라는 이름의 핵심적인 컴포넌트가 활용**된다.
* **해당 컴포넌트는 액추에이터를 활용하는 경우라면 스프링을 통해 자동으로 주입 받을 수 있으며, 이를 통해 카운터와 게이지 등을 등록**할 수 있다.
    * 앞서 다룬 바와 같이, 카운터는 점진적으로 증가하는 단일 누적 측정 지표이며 값을 증가시키거나 0으로 초기화하는 것이 가능하다.
    * 마이크로미터의 경우, 카운터 지표의 값을 감소시키는 기능을 지원하긴 하지만 이는 카운터 지표의 목적과는 맞지 않는다.

## 2025-08-18 Mon
### 카운터 유형의 비즈니스 메트릭 적용하기
* 예를 들어 주문 기능을 제공하는 서비스가 있고, 주문 수와 취소 수 지표를 카운터 유형으로 분류했다고 가정할 경우 다음과 같이 작성하여 정보를 수집할 수 있다.
```kotlin
@Service
@Slf4j
class OrderService(
    private val registry: MeterRegistry,
) {
    fun order() {
        log.info("order")

        val counter: Counter = Counter.builder("my.order")
            .tag("className", this.javaClass.name)
            .tag("method", "order")
            .description("this is my order metric")
            .register(registry)

        counter.increment()
    }

    fun cancel() {
        log.info("cancel")

        val counter: Counter = Counter.builder("my.order")
            .tag("className", this.javaClass.name)
            .tag("method", "cancel")
            .description("this is my cancel metric")
            .register(registry)

        counter.increment()
    }
}
```

## 2025-08-19 Tue
### Counter 빌더를 활용한 카운터 유형의 지표 생성
* 상술한 코드와 같이 카운터는 `Counter.builder(name)` 빌더로 생성이 가능하며, 인자에는 지표의 이름을 명시한다.
    * 즉, 상술한 코드로부터 수집되는 모든 지표의 이름은 `my.order`로 설정된다.
* 각 **지표 정보는 분류를 위해 태그 정보를 명시할 수 있으며, 이를 통해 프로메테우스로부터 레이블을 필터링하는 것이 가능**하다.
    * 상술한 코드의 경우 주문과 취소 모두 동일한 이름의 지표를 사용하지만, 추후 태그를 활용하여 이를 필터링하도록 유도하게 된다.
* **`registry()` 메소드를 통해 `MeterRegistry` 컴포넌트에 카운터 유형의 지표를 등록하며, 이를 통해서만 비즈니스 메트릭이 정상적으로 동작**한다.
* 마지막으로 `increment()` 메소드를 호출할 경우, 해당하는 카운터 유형의 지표 값을 하나 증가시키게 된다.
    * 바꿔 말해 해당 메소드가 한 번 호출될 때마다 카운터 유형의 지표 정보가 하나씩 증가하게 된다.
* 반면, 해당 비즈니스 메트릭을 등록하고 나서 액추에이터에서 바로 확인할 경우 아무런 데이터가 반환되지 않는 것을 확인할 수 있다.
    * 이는 **비즈니스 메트릭과 같은 커스텀한 지표 정보는 정보가 하나라도 수집되어야 사용자에게 노출될 수 있기 떄문**이다.

## 2025-08-20 Wed
### 카운터 유형의 지표 정보를 프로메테우스에서 확인하기
* 상술한 비즈니스 메트릭을 프로메테우스에서 확인할 경우, 지표 정보의 이름은 `my.order`가 아닌 `my_order_total`로 변경되어 있는 것을 알 수 있다.
    * 이는 프로메테우스가 `.`을 `_`로 변경하고, 카운터 지표의 경우 관례상 `_total`이라는 접미사를 사용하기 때문이다.
* 또한, `my_order_total{class="ga.injuk.order.OrderService",method="order",} 1.0` 형태로 `method`라는 태그 정보가 할당되어 있다.
    * 반면, 가장 오른쪽에 명시된 값인 `1.0`은 해당 지표 정보의 수이므로 `1.0`은 현재 서버의 주문 건수가 단 1건이었음을 의미한다.

## 2025-08-21 Thu
### AOP를 활용한 지표 정보 관리의 필요성
* 앞서 작성한 `OrderService`는 지표 정보를 관리하기 위한 로직이 비즈니스 로직에 침투하므로, 단일 책임 원칙을 위반하게 될 수 밖에 없다.
    * 예를 들어, `Counter`의 빌더를 활용하는 코드는 애플리케이션 관점에서 중요하지만 비즈니스 도메인과는 전혀 관련 없는 코드에 해당한다.
    * 일반적으로, **비즈니스 도메인을 다루는 서비스 계층은 이러한 애플리케이션 관심사로부터 분리되는 것이 바람직**하다.
* **지표 정보와 관련된 기능은 스프링 AOP를 적용하기에 적합하며, 마이크로미터는 이러한 상황에서 사용 가능한 AOP 구성 요소를 이미 제공**한다.

## 2025-08-22 Fri
### @Counted 어노테이션을 활용한 지표 생성
* 마이크로미터는 카운터 유형의 비즈니스 메트릭은 다음과 같이 `@Counted` 어노테이션을 활용하는 것으로 쉽게 수집할 수 있다.
    * 이 때, 해당 어노테이션의 인자로는 `my.order`와 같은 지표 이름을 명시할 수 있다.
```kotlin
@Service
@Slf4j
class OrderService {
    @Counted("my.order")
    fun order() {
        log.info("order")
        // 비즈니스 로직이 있다고 가정한다.
    }

    @Counted("my.order")
    fun cancel() {
        log.info("cancel")
        // 비즈니스 로직이 있다고 가정한다.
    }
}
```
* 앞서 다루었던 `Counter` 빌더가 `tag`를 지원하듯, AOP 방식은 `tag`에 클래스와 메소드 이름을 기준으로 자동 분류된다.
    * 이렇듯 `@Counted`를 활용할 경우 `result`나 `exception`, `method`나 `class`라는 `tag`가 자동으로 적용된다.

## 2025-08-23 Sat
### CountedAspect 빈 등록하기
* 반면, **상술한 어노테이션을 명시하는 데에서 그치지 않고 반드시 다음과 같은 `CountedAspect` 빈을 명시적으로 등록**해주어야 한다.
    * 이렇듯 `CountedAspect`가 빈으로 등록되어 있어야 어노테이션을 활용한 AOP가 의도한대로 동작할 수 있다.
    * 즉, **`CountedAspect`를 `@Counted`와 같은 AOP를 동작시키는 모듈로 이해**할 수 있다.
```kotlin
@Configuration
class OrderConfig {
    @Bean
    fun countedAspect(registry: MeterRegistry): CountedAspect
            = CountedAspect(registry)
}
```

## 2025-08-24 Sun
### Timer란?
* `Timer`는 특별한 지표 측정 도구로, 시간이 어느 정도 소요됐는지와 같은 정보를 측정하기 위해 사용된다.
    * 이러한 특징으로 인해 카운터와 유사한 성질을 가지며, 단지 `Timer`를 사용하는 것으로 소요 시간을 함께 측정할 수 있다.
* `Timer`의 경우, 기본적으로 다음과 같은 여러 정보를 한 번에 측정하는 방식으로 동작한다.
    1. `seconds_count`: 카운터 유형의 지표이며, 누적 실행 수를 의미한다.
    2. `seconds_sum`: 전체 실행 시간의 합을 의미한다.
    3. `seconds_max`: 게이지 유형의 지표이며, 실행에 가장 오래 걸린 시간을 의미한다.
* 반면, `Timer`는 내부적으로 `Time window` 개념을 갖기에 약 1분에서 3분 정도마다 최대 실행 시간을 다시 계산한다.
* 또한, 실행 시간의 합과 누적 실행 수 정보가 이미 수집되고 있으므로 필요한 경우 `secods_sum / seconds_count`를 활용한 평균을 구할 수 있다.

## 2025-08-25 Mon
### Timer 빌더를 활용한 시간 측정
* 상술한 `Timer` 기능을 활용하기 위해서는 `Timer.builder`와 같은 빌더를 다음과 같이 활용할 수 있다.
  * 이 때, 빌더의 인자로 전달되는 `name`에는 이름을 명시하며 프로메테우스가 필터링할 수 있도록 적절한 `tag`를 명시할 수 있다.
  * 또한, 수동으로 주입 받은 `MeterRegistry`에 타이머를 등록해주어야만 `Timer`는 실제로 동작할 수 있다.
```kotlin
@Service
@Slf4j
class OrderService(
    private val registry: MeterRegistry,
) {
    fun order() {
        val timer = Timer.builder("my.order")
            .tag("class", this.getClass().getName())
            .tag("method", "order")
            .description("order")
            .register(registry)
        
        timer.record {
            log.info("order")
            // 비즈니스 로직이 있다고 가정한다.
            Thread.sleep(500)
        }
    }

    fun cancel() {
        val timer = Timer.builder("my.order")
            .tag("class", this.getClass().getName())
            .tag("method", "cancel")
            .description("cancel")
            .register(registry)

        timer.record {
            log.info("cancel")
            // 비즈니스 로직이 있다고 가정한다.
            Thread.sleep(500)
        }
    }
}
```
* 이렇듯 `Timer`를 활용하여 시간을 측정하고자 하는 경우, `Timer`가 제공하는 `record` 메소드를 활용할 수 있다.
  * 해당 메소드 내에 실제로 시간을 측정하고자 하는 로직을 함수 형태로 전달해주는 것으로 시간을 측정할 수 있게 된다.

## 2025-08-26 Tue
### @Timed 어노테이션을 활용한 AOP 적용
* 상술한 코드는 `Timer` 유형의 지표를 수동으로 등록하는 경우에 해당하며, 일반적으로는 `@Timed` 어노테이션을 다음과 같이 적용하여 AOP를 활용할 수 있다.
```kotlin
@Timed(value = "my.order")
@Service
@Slf4j
class OrderService {
    fun order() {
        log.info("order")
        // 비즈니스 로직이 있다고 가정한다.
        Thread.sleep(500)
    }

    fun cancel() {
        log.info("cancel")
        // 비즈니스 로직이 있다고 가정한다.
        Thread.sleep(500)
    }
}
```
* **`@Timed` 어노테이션은 타입이나 메소드 모두에 적용할 수 있으며, 코드와 같이 타입에 적용한 경우 해당 타입의 모든 공개 메소드에 타이머가 적용**된다.
  * 즉, 타이머를 적용하고자 하지 않은 메소드의 접근 제어자가 `public`으로 설정되어 있다면 타이머가 적용될 가능성이 있으므로 주의해야 한다.

## 2025-08-27 Wed
### TimedAspect 빈 등록하기
* 반면, 앞선 `CountedAspect`와 유사한 이유에서 **반드시 다음과 같은 `TimedAspect` 빈을 명시적으로 등록**해주어야 한다.
    * 이렇듯 `TimedAspect`가 빈으로 등록되어 있어야 어노테이션을 활용한 시간 측정 AOP가 의도한대로 동작할 수 있다.
    * 즉, **`TimedAspect`를 `@Timed`와 같은 AOP를 동작시키는 모듈로 이해**할 수 있다.
```kotlin
@Configuration
class OrderConfig {
    @Bean
    fun timedAspect(registry: MeterRegistry): TimedAspect
            = TimedAspect(registry)
}
```

## 2025-08-28 Thu
### 게이지 유형의 지표 등록하기
* 게이지는 임의로 오르내릴 수 있는 단일 숫자 값을 의미하는 지표 정보이며, 값의 현재 상태를 모니터링하는 데에 유용하다.
  * 게이지 유형의 지표는 CPU 사용량 등과 같이 그 값이 증가하거나 감소할 수 있는 특징을 갖는다.
  * 나아가 임의의 지표의 유형을 카운터나 게이지로 분류하기 위해서는 값의 감소 가능성을 확인해볼 수 있다.
* 게이지 유형의 지표 정보를 수집하기 위해서는 다음과 같은 간단한 코드를 작성해볼 수 있다.
  * 이는 `my.gauge`라는 이름으로 게이지 유형의 지표를 등록하며, 인자에 전달된 람다를 활용하는 방식에 해당한다. 
```kotlin
@Component
class MyGaugeMetric(
    private val myService: MyService,
    private val registry: MeterRegistry,
) {
    
    @PostConstruct
    fun init() {
        Gauge.builder("my.gauge", myService) { service ->
            println("gauge call")
            return service.getStock()
        }
            .also {
                register(registry)
            }
    }
}
```
* 상술한 형태로 작성한 클래스를 사용할 경우, **외부에서 지표 정보를 수집하는 등 지표 정보를 확인할 때마다 게이지 빌더에 전달된 람다 함수가 호출**된다.
  * 이 때, 해당 **람다의 반환 값이 게이지 값**이 된다.

## 2025-08-29 Fri
### 게이지 유형의 지표 수집 원리
* 상술한 컴포넌트를 빈에 등록한 후 애플리케이션을 실행할 경우, 주기적으로 `gauge call` 이라는 로그가 출력되는 것을 확인할 수 있다.
* 이는 **프로메테우스의 설정에 따라 주기적으로 지표 정보가 수집되기 때문으로, 게이지 유형의 지표는 이렇듯 지표 정보가 수집될 때마다 값을 반환**한다.
  * 따라서 프로메테우스 애플리케이션 자체를 종료할 경우, 지표 정보가 더 이상 수집되지 않기에 로그도 더 이상 출력되지 않는다. 
  * 다시 말해, 게이지 빌더에 전달된 람다가 호출되어 그 반환 값이 프로메테우스에 의해 수집되는 것으로 이해할 수 있다.
* 또한, 프로메테우스가 아닌 액추에이터의 엔드포인트를 활용하여 조회하는 경우에도 동일한 로그가 출력되는 것을 확인할 수 있다.
  * 이로 미루어보았을 때, **게이지 유형의 지표는 어떠한 방식으로든 지표 정보가 수집될 때 현재 값을 그대로 반환하는 방식으로 동작하는 것**을 알 수 있다.

## 2025-08-30 Sat
### 빈을 활용한 간단한 게이지 유형의 지표 등록
* 앞서 작성했던 게이지 유형의 지표 수집 코드는 빈을 활용하여 다음과 같이 간단한 방식으로도 구현할 수 있다.
    * 이 때, `register(registry)` 메소드의 반환값이 `MeterBinder`임에 주의하여 구현한다.
```kotlin
@Configuration
class MyConfig {
    
    @Bean
    fun getSize(service: MyService): MeterBinder = { registry ->
        Gauge.builder("my.gauge", myService) { service ->
            println("gauge call")
            return service.getStock()
        }
            .also {
                register(registry)
            }
    }
}
```

## 2025-08-31 Sun
### 태그란?
* 여지껏 `.tag([태그명])` 형태로 데이터를 분류하기 위한 값을 명시해왔으며, 이를 태그 또는 레이블이라는 용어로 지칭한다.
* **태그를 적절히 활용할 경우, 데이터를 나누어 확인할 수 있기에 원하는 조건에 맞는 지표 정보를 조회하는 데에 큰 도움**을 줄 수 있다.
* 반면, **태그는 카디널리티가 낮으면서도 그룹화 가능한 단위에만 적용하는 것이 바람직**하다.
  * 즉, **관계형 DB의 인덱스와 달리 선택도가 낮아 한 번에 큰 단위로만 분류되는 성별이나 주문 상태 및 결제 수단 등의 분류를 태그로 관리**할 수 있다.
* 관계형 DB의 **기본 키로 사용되는 등 선택도가 높은 분류 기준은 태그에 따른 검색 결과가 너무 세분화되어 오히려 시각화하기 어렵다**.
  * 이 경우, 데이터가 너무 세밀하게 쪼개지므로 모니터링 성능에도 악영향을 주기 쉽다.
  * **선택도가 높은 단위에 대해 모니터링을 적용하고자 하는 경우, 태그보다는 오히려 적절한 로깅을 고려하는 것이 바람직**하다. 

## 2025-09-01 Mon
### 실무에서의 모니터링 구성 단계
* 임의의 애플리케이션에 대해 모니터링을 도입하고자 하는 경우에는 다음과 같은 세 가지 단계를 기억하는 것이 권장된다.
    1. 대시보드
    2. 애플리케이션 추적
    3. 로그
* 각각의 단계는 서로 다른 범위를 조망하므로, 임의의 하나만을 골라 사용하는 것이 아닌 상호 보완적으로 혼용하는 것이 권장된다.
    * 이렇듯 **각 단계는 서로 다른 용도를 갖고, 순차적으로 넓은 범위에서 좁은 범위로 애플리케이션의 상태를 관찰할 수 있도록 지원**한다.
    * **문제 상황 발생시 트러블슈팅을 시도하는 경우에도 높은 단계의 모니터링을 활용하여 넓은 범위부터 관찰을 시작하는 것이 권장**된다.

## 2025-09-02 Tue
### 대시보드를 활용한 모니터링
* 대시보드는 전체적인 애플리케이션의 상태, 즉 시스템의 상황을 한 눈에 확인할 수 있으므로 가장 높은 위치의 뷰로 이해할 수 있다.
    * 앞서 다루었던 그라파나는 대표적인 대시보드에 해당한다.
    * **대시보드의 경우 CPU와 같은 시스템 지표나 쓰레드 풀 및 커넥션 풀과 같은 애플리케이션 지표, 주문수와 같은 비즈니스 지표에 적합**하다.

## 2025-09-03 Wed
### 애플리케이션 추적을 활용한 모니터링
* 애플리케이션 추적은 핀포인트나 와탭 등의 서드파티 애플리케이션을 활용하여 개별 HTTP 요청을 추적하는 데에 적합하다.
    * 반면, 서드파티 애플리케이션 중 일부는 MSA 상에서의 분산 추적을 지원하기도 한다.
* 만약 대시보드와 애플리케이션 추적 중 하나만을 도입할 수 있다면 애플리케이션 추적의 도입이 우선적이며, 되도록 개발 초기에 도입하는 것이 바람직하다.
    * 대표적으로 핀포인트를 설정한 후 대시보드를 구축하는 방식으로 모니터링 환경을 구성할 수 있다.

## 2025-09-04 Thu
### 로그를 활용한 모니터링
* **로그는 가장 자세한 추적 단계이며, 원하는대로 커스터마이징이 가능하다는 강력한 특징**을 갖는다.
* 로그를 도입할 경우 동일한 HTTP 요청에 대해 묶어 처리할 수 있는 방법이 중요하며, `MDC`를 적용하는 것이 필수적이다.
    * 대표적으로 **개별 HTTP 요청에 대해 `UUID`와 같이 랜덤한 식별자를 부여하고, 동일한 HTTP 요청에 대해 이를 활용하도록 구현**할 수 있다.
    * 이러한 기능을 라이브러리 차원에서 손쉽게 적용할 수 있도록 지원하는 것이 `MDC`이며, 실무의 경우에도 직접 구현하는 방식보다는 `MDC`를 활용하게 된다.
* 반면, **로그를 파일 형태로 남기고자 하는 경우 일반 로그와 에러 로그를 구분하여 저장하는 것이 권장**된다.
    * 이를 통해 **문제 상황 발생시 에러 로그 파일만을 조회하여 문제의 원인을 보다 빠르게 파악**할 수 있다.
* 최근에는 로그를 클라우드에 저장하기도 하며, 이 경우에도 에러 로그는 별도로 분리하는 등 검색이 쉽게 될 수 있도록 구분해주어야 한다.

## 2025-09-05 Fri
### 알림 설정하기
* **모니터링을 적용한 경우, 임의의 지표가 일정 수치를 넘어가면 업무용 메신저나 메일 및 문자를 통해 개발자에게 이를 알릴 수 있도록 구성**해야 한다.
* 이 때, 알림은 반드시 다음과 같은 두 종류로 구분하여 관리하는 것이 바람직하다.
    1. 경고: 개발자가 하루에 한 번 정도만 수동으로 확인해도 무방한 수준의 알림에 적용한다.
    2. 심각: 개발자가 즉시 확인해야 하는 상황에 적합하며, 업무용 메신저나 문자를 통해 즉시 알림을 받을 수 있도록 구성한다.
* 시스템 사용량을 예로 들어, 디스크 사용량이 70%인 경우는 경고로 분류하는 반면 80%이상인 경우에 심각으로 분류할 수 있다.
    * **중요한 것은 종류 구분 그 자체이며, 업무용 메신저로 슬랙을 사용하는 경우를 예로 들었을 때 각 종류에 대해 별도의 채널을 운영하는 것이 권장**된다.
* 이렇게 **알림 종류를 분류하는 것은 모니터링 효율성을 위한 것도 있으나, 개발자 자신의 삶에도 큰 영향을 끼친다는 점에서 중요**하다.
    * 두 종류의 알림을 구분하지 않으면 각 개발자의 업무와 삶에 큰 악영향을 끼칠 수 있으므로, 여러 시행착오를 겪어서라도 이를 의식적으로 분류해야 한다.
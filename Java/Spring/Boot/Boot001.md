# Spring Boot
## 2025-01-16 Thu
### 스프링 부트의 특징
* 익히 다뤄온 스프링은 Java 진영의 사실상 표준이나, 그 오랜 역사로 인해 기능이 너무 많고 광범위한 특징을 갖는다.
  * 이는 새로운 개발자들의 진입장벽으로 기능하며, 너무 많은 유연성을 제공하므로 기술을 선택하는 것 자체가 어려워졌다.
* **스프링 부트는 무겁고 불편하다는 스프링의 인식을 개선하기 위해 고안되었으며, 스프링을 쉽고 편리하게 사용할 수 있도록 지원**한다.
  * 실무 관점에서도 최근 대부분의 프로젝트는 스프링 부트를 사용하게 되었으므로, 스프링은 스프링 부트를 통해 비로소 완성되었다고 볼 수도 있다.
* 스프링 부트는 크게 다음과 같은 핵심 기능을 제공한다.
  1. 내장 서버: 톰캣 등의 별도 서버 설치 없이도 손쉽게 웹 애플리케이션을 동작시킬 수 있도록 지원한다.
  2. 자동 라이브러리 관리: best practice를 기반으로 수많은 라이브러리들을 자동으로 선택하고 관리한다.
  3. 자동 구성: 복잡한 스프링 설정을 자동화하여 개발자들이 최대한 쉽고 빠르게 애플리케이션을 개발할 수 있도록 지원한다.
  4. 외부 설정: 개발 및 운영 환경 등 서로 다른 환경에서 애플리케이션을 손쉽게 개발할 수 있도록 편리한 외부 설정 조회 기능을 지원한다.  
  5. 모니터링 및 관리 기능: 애플리케이션이 제공하는 수많은 지표들을 자동으로 수집하고 관리할 수 있는 기능을 제공한다.
* 그러나 **스프링 부트는 편리하지만 여전히 너무 많은 기능을 제공하기에, 실무에 맞는 적절한 정도의 학습이 필수적**이다.
  * 즉, 너무 깊거나 너무 넓게 학습하지 않도록 주의를 기울일 필요가 있다.

## 2025-01-17 Fri
### 스프링의 등장
* 초기 Java 진영에는 표준 기술로 `Java Beans`, 즉 EJB라는 개념이 있었다.
  * EJB는 트랜잭션 관리와 분산 기술 등 이론적인 토대가 잡혀 있는 것처럼 보였고, 무엇보다 표준 기술이라는 점에서 큰 관심을 얻었다.
* 그러나 문제는 가격으로, 당시에 EJB를 사용하기 위해서는 필요한 소프트웨어 설치에 서버당 수천만원의 비용이 소모되었다.
* 또한, EJB는 복잡성이 매우 큰 기술이었고 무엇보다 애플리케이션이 EJB에 강결합된다는 단점을 수반했다.
  * 순수한 Java 코드의 사용을 권장하는 POJO 역시 이에 반발해서 나온 것으로 이해할 수 있다.
* 어찌되었건 EJB는 표준 기술이었기에 금융권이나 SI 시장에서 자주 채택되었고, 이에 반발한 SI 기업 출신의 개발자 로드 존슨이 스프링 프레임워크를 제안하는 데에 이르렀다.
  * 로드 존슨은 EJB 없이도 확장성 있는 고품질의 애플리케이션을 개발할 수 있음을 책으로 서술했고, 현재의 스프링 핵심 개념은 모두 해당 책에서 시작된 것으로 봐도 무방하다.
  * 결과적으로는 스프링이 EJB 컨테이너를 대체하게 되었고, 현재에는 스프링이 Java 진영의 사실상 표준으로 자리잡게 되었다.
* 스프링은 로드 존슨이 2002년에 출간한 책을 시작으로 2003년에 1.0 버전이 출시되었으며, 현재까지도 생태계를 키워오고 있다.

## 2025-01-18 Sat
### 스프링 프레임워크가 갖는 특징
* 스프링 프레임워크는 DI 컨테이너에 더해 MVC나 DB 접근 기술 등 수많은 기능을 제공하는 것으로 개발자들이 자주 접하는 다양한 문제의 해결에 직접적으로 기여한다.
  * 또한, 이 과정에서 다양한 라이브러리를 편리하게 사용할 수 있도록 통합해준다.
  * 때문에 스프링을 사용하는 개발자의 생산성은 크게 높아지고, 점차 넓은 범위에서 스프링이 사용되기에 이르렀다.
* 스프링 프레임워크는 현재에 이르러 Java 진영의 사실상 표준으로 자리잡았으며, 기존 표준 기술인 EJB를 완전히 대체하는데에 성공했다.
* 스프링은 지금까지도 계속해서 기능이 확장되어오고 있으며, 무엇보다도 스프링을 중심으로 한 스프링 시큐리티 등의 별도의 프로젝트가 추가되는 방식으로 그 생태계가 점차 거대해지고 있다.

## 2025-01-19 Sun
### 스프링 프레임워크의 확장과 관련된 문제
> 스프링에 의해 EJB 지옥에서 해방된 개발자들이 마주친 것은 아이러니하게도 스프링의 설정 지옥이었다.
* 상술한 바와 같이 스프링과 그 생태계가 점점 거대해짐에 따라 관련된 기능 역시 많아졌으며, 기저에 필요한 라이브러리도 크게 늘어났다.
* 즉, 스프링으로 신규 프로젝트를 시작할 때의 설정 과정은 점차 번거로워지고 있으며 이는 곧 스프링으로 신규 프로젝트를 시작하는 것이 점점 어려워지는 것과도 같다.
  * 극단적으로, 스프링은 자기 자신을 활용한 신규 프로젝트를 시작하기도 전에 포기하는 개발자가 점차 늘어나는 상황에 직면하게 된다.
  * 이러한 상황이 악화되던 2010년 무렵의 스프링은 개발자들에 의해 무겁고, 불편한 프레임워크라고 여겨지곤 했다.
  * 이는 스프링 프레임워크 자체적으로 개발자들에게 많은 선택의 여지를 남겨두기 때문으로, 숙련된 개발자에게는 유용하지만 일반적인 개발자들에게는 그 자체로 진입 장벽으로서 기능하곤 했다.

## 2025-01-20 Mon
### 스프링 부트의 등장
* 부트, 부팅은 최소한의 개입으로 완전히 동작하는 것을 의미하며 곧 무언가를 시작하기 전에 모든 준비를 마치겠다는 의미를 갖는다.
  * 다시 말해 스프링 부트 역시 시작을 위한 복잡한 설정을 직접 해결하며, 덕분에 개발자는 새로운 애플리케이션을 쉽고 빠르게 시작할 수 있게 된다.
  * 결국 스프링 부트는 스프링을 편리하게 사용할 수 있도록 지원하는 역할을 담당하지만, 최근에는 사실상 기본이 되었다.

## 2025-01-21 Tue
### 스프링 부트의 다섯 가지 핵심 기능
> 스프링 부트는 수많은 기능을 갖지만, 그 중 가장 핵심적인 것을 약 다섯 가지로 추려볼 수 있다.
* 스프링 부트는 톰캣과 같은 웹 서버를 내장하므로, 별도의 웹 서버를 설치하지 않고 WAS 역할을 수행할 수 있다.
* 스프링 부트는 손쉬운 구성을 위한 스타터 의존성을 제공하고, 스프링과 외부 라이브러리 간의 버전을 자동으로 관리해준다.
* 스프링 부트는 프로젝트의 시작에 필요한 스프링, 그리고 외부 라이브러리와 관련된 빈을 자동으로 등록한다.
* 스프링 부트는 환경에 따라 달라질 필요가 있는 외부 설정을 공통화한다.
* 스프링 부트는 애플리케이션의 상태를 모니터링하기 위한 여러 메트릭에 더불어 상태 확인 기능을 제공한다.

## 2025-01-22 Wed
### 스프링 기술 스택 결정하기
* 스프링 기반의 애플리케이션을 개발하는 경우, 필수적이라고 볼 수 있는 스프링과 스프링 부트의 조합에 더해 스프링 데이터나 스프링 세션 및 스프링 클라우드 등의 스프링 생태계의 여러 기술들을 선택적으로 고려할 수 있다.
* 중요한 것은 스프링 부트를 포함한 모든 기술 스택은 스프링을 중심으로 동작하며, 스프링을 선택적으로 사용할 수는 없다는 점에 있다.
  * 스프링 부트 역시 본질에 해당하는 스프링을 쉽게 사용하도록 지원하는 도구에 불과하다.
  * 다만, 단순한 도구로 취급하기엔 막강한 편의 기능을 제공하기에 사실상 필수로 취급하는 것이 권장된다.

## 2025-01-23 Thu
### 스프링 부트 학습의 중요성
* 스프링 부트로 인해 스프링 기반 애플리케이션 개발이 편리해진 것은 사실이지만, 문제는 스프링 부트가 너무 많은 것을 자동화한다는 점에 있다.
  * 즉, 어떠한 이슈가 발생했을 때 그 원리를 이해하지 못한 경우 트러블슈팅에 손을 못대는 경우가 발생할 수 있다.
* 최소한 스프링 부트가 어떠한 원리에 의해 동작하는지 이해하는 것은 필수적이며, 이를 통해 스프링 부트와 관련된 복잡한 이슈의 원인을 파악하고 트러블슈팅을 시도할 수 있게 된다.
* 또한, 스프링 부트는 그 자체로도 수많은 편의 기능을 제공하기 때문에 스프링 부트를 깊게 이해할수록 개발 시간을 단축하는 효과를 얻게 된다.
  * 즉, 바퀴를 재발명할 필요가 없다!  

## 2025-01-24 Fri
### 전통적인 방식과 최근 방식의 배포
* **전통적인 방식으로 Java 웹 애플리케이션을 개발하는 경우, 우선 톰캣과 같은 WAS를 서버에 설치하는 것이 전제**되어야 했다.
  * 이후 애플리케이션이 WAS에서 동작할 수 있도록 서블릿 스펙에 맞추어 코드를 작성하고, WAR로 빌드한 결과물을 WAS에 배포하는 방식으로 개발을 진행했다.
* 반면, **최근 방식의 경우 스프링 부트가 자체적으로 톰캣을 내장 라이브러리 형태로 포함한다는 점에서 전통적인 방식과는 큰 차이**가 있다.
  * 즉, **이는 곧 애플리케이션 코드 상에 톰캣과 같은 WAS가 라이브러리 형태로 저장되는 것**과 같다.
  * 때문에 개발자는 단순히 코드를 작성한 후 JAR로 빌드하고, 이를 원하는 위치에서 실행시키기만 하는 것으로 WAS를 함께 실행할 수 있게 되었다.
  * 이는 극단적으로 바꿔 말해 개발자는 단지 `main()` 메소드만을 호출하며, WAS 설치 및 설정 등의 복잡한 작업을 더 이상 수행할 필요가 없음을 의미한다.

## 2025-01-25 Sat
### 전통을 체험하기
```
> 웹 애플리케이션 개발 과정에 있어 전통적인 프로세스를 따라보는 것은 스프링 부트의 현재를 더 깊이 있게 이해하는 데에 도움을 준다. 
```
* 스프링 부트를 최근에 학습한 개발자들은 WAR로 빌드하여 WAS에 배포하는 방식에 익숙하지 않지만, 이러한 방식을 알아둘 가치는 충분하다.
* 과거의 개발 프로세스를 이해하는 것은 곧 현재의 방식이 어떻게 발전해왔고, 이를 왜 사용해야하는지에 대해 더 깊이 있게 이해할 수 있도록 하는 초석이 된다.
  * 예를 들어, 서블릿 컨테이너를 설정하고 스프링 컨테이너와 디스패처 서블릿을 각각 생성하여 스프링 MVC와 연결하는 작업 등을 경험해볼 필요가 있다.

## 2025-01-26 Sun
### 톰캣용 서블릿 기반 웹 애플리케이션 작성하기
* 서블릿과 WAR를 활용하여 톰캣에서 동작할 수 있는 웹 애플리케이션을 개발하는 경우, 아래와 같이 gradle을 설정해줄 필요가 있다.
```groovy
plugins {
  id 'java'
  id 'war'
}

// ...중략

dependencies {
  implementation 'jakarta.servlet:jakarta.servlet-api:6.0.0' // 서블릿 의존성
}
```
* 이 떄, **웹 애플리케이션에서 사용할 메인 페이지인 `index.html`은 `src/main/webapp` 경로에 작성**한다.
* 반면, 아무리 간단한 HTML 파일이더라도 이를 톰캣과 같은 WAS의 서블릿에서 동작시키기 위해서는 서블릿 스펙에 맞추어 개발할 필요가 있다.
  * 이러한 **서블릿은 `src/main/java` 하위의 임의의 패키지에 `HttpServlet` 클래스를 아래와 같이 확장하는 것으로 작성**할 수 있다.
```java
/**
 * http://localhost:8080/test 호출시 아래 서블릿이 동작하도록 구현  
 */
@WebServlet(urlPatterns = "/test")
public class MyServlet extends HttpServlet {
  @Override
  protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
    System.out.println("MyServlet.service");
    resp.getWriter().println("test"); // 클라이언트의 요청에 대해 'test' 라는 문자열로 응답한다.
  }
}
```

## 2025-01-27 Mon
### WAR의 구조
* 사용 중인 빌드 도구에 따라 애플리케이션을 WAR로 빌드해야 하며, 상술한 설정의 경우 gradle의 `war` 플러그인에 의해 빌드가 가능하다.
  * 예를 들어 래퍼를 사용하는 경우, `./gradlew build` 명령어를 통해 WAR를 빌드할 수 있다.
  * 이 때, 빌드 결과물은 IntelliJ를 기준으로 `build/libs` 폴더 하위에 `.war` 확장자를 갖는 WAR 파일로 생성된다.
  * 반면, gradle의 `war` 플러그인은 해당 프로젝트를 빌드할 때 결과물을 WAR 파일로 생성하도록 동작한다. 
* 생성된 WAR 파일은 필요한 경우 `jar -xvf [파일명].war` 명령어로 풀어볼 수 있으며, 다음과 같은 파일을 포함한다.
  1. `index.html`: 메인 페이지 역할을 담당할 HTML로, 앞서 `webapp` 폴더에 작성한 HTML과 같다.
  2. `META-INF`: Java의 설정과 관련된 파일들이 위치한다.
  3. `WEB-INF`: `WEB-INF/classes` 경로에 패키지 구조에 따라 바이트코드로 변환된 소스 코드가, `WEB-INF/lib`에는 라이브러리용 JAR가 위치한다.
* 이 때, `WEB-INF` 하위 경로를 더 자세히 분류하면 다음과 같다.
  1. `classes`: 실행 대상 클래스들이 위치하는 경로에 해당한다.
  2. `lib`: 라이브러리 용도의 JAR 파일들이 위치하는 경로에 해당한다.
  3. `web.xml`: 생략 가능하며, 웹 서버의 배치 설정 파일에 해당한다.
* 이렇듯 **`WEB-INF` 폴더의 하위 경로는 Java 클래스 및 관련된 라이브러리와 설정 정보가 위치하며, 그 외는 HTML 등의 정적 리소스를 위해 사용**한다.

## 2025-01-28 Tue
### JAR와 WAR의 차이
* Java의 경우, **여러 클래스 및 관련된 리소스를 묶은 단위인 JAR**라는 압축 파일을 생성할 수 있다.
  * 이러한 **JAR는 `java -jar [파일명].jar` 형태로 JVM 상에서 직접 실행되거나, 다른 곳으로부터 참조되는 라이브러리 형태로 사용**될 수 있다.
  * 반면, **직접 실행 가능한 JAR의 경우 `main()` 메소드가 필수적이며 `MANIFEST.MF` 파일에 메인 메소드를 포함하는 클래스를 명시**해야 한다.
* 반면, **WAR의 경우 WAS에 배포하기 위해 사용되는 파일로 JVM 상에서 실행되는 JAR와 달리 WAS 상에서 실행이 가능**하다.
  * 물론 WAS 역시 Java 환경에서 실행되며, WAR는 이러한 WAS 상에서 실행되는 것으로 이해할 수 있다.
  * 이러한 **WAR 파일은 정해진 구조를 반드시 준수해야 하며, WAS 상에서 실행되기 위한 정적 리소스 등을 모두 포함하기에 JAR보다 복잡한 구조**를 갖는다.

## 2025-01-29 Wed
### WAS에 WAR를 배포하기
* 톰캣과 같은 WAS에 WAR 파일을 배포하기 위해서는 우선 톰캣을 종료하고, 톰캣이 설치된 폴더에 위치한 `webapps` 하위 폴더를 모두 삭제해주어야 한다.
  * 이 때, 톰캣을 종료하기 위해서는 톰캣 폴더에 위치한 쉘 스크립트인 `shutdown.sh`을 활용한다.
  * 톰캣을 처음 설치한 경우, `webapps` 폴더에는 톰캣 측에서 준비한 기본적인 리소스가 포함되나 이는 제거해도 무방하다.
* 그 이후에는 빌드된 WAR 파일을 톰캣이 설치된 폴더에 위치한 `webapps`에 `ROOT.war`라는 이름으로 붙여넣는다.
  * 이 때, 옮겨진 WAR 파일의 이름은 반드시 대문자로 표기된 `ROOT`여야 한다.
* 모든 준비가 완료된 경우, 톰캣 폴더에 위치한 쉘 스크립트인 `startup.sh`을 활용하여 톰캣을 실행한다.
  * 이 때, 실행된 웹 애플리케이션의 로그 정보는 톰캣이 설치된 폴더의 하위에 위치한 `logs`에 `catalina.out` 형태로 저장된다.
  * 또한, 톰캣은 실행되는 과정에서 `ROOT.war`의 압축을 자동으로 해제하여 사용한다.
* 그러나 이러한 배포 과정은 운영 환경에서는 감내할 수 있으나, 개발 단계에서는 계속해서 상기 과정을 반복하는 것이 번거로울 수 있다.
  * 때문에 IntelliJ나 Eclipse와 같은 IDE는 이러한 번거로운 과정을 상당수 자동화하는 기능을 제공한다.

## 2025-01-30 Thu
### 서블릿 컨테이너 초기화의 필요성
* WAS를 실행하는 시점에 필터와 서블릿을 등록하거나, 스프링 관련 설정을 처리하는 등 여러 초기화 작업이 필요할 수 있다.
  * 예를 들어, 스프링을 사용하는 경우 스프링 컨테이너를 생성한 후 서블릿과 스프링을 연결하는 디스패쳐 서블릿을 등록해야 한다.
* WAS는 이러한 작업을 위해 초기화 기능을 제공하며, 이를 활용하는 것으로 WAS 실행 시점에 필요한 초기화 과정을 진행할 수 있다.
  * 기존에는 이러한 작업을 `web.xml`을 활용하여 진행하였으나, 최근에는 서블릿 스펙 자체적으로 Java 코드를 활용한 초기화 기능을 지원한다.

## 2025-01-31 Fri
### ServletContainerInitializer 인터페이스
* 서블릿은 `ServletContainerInitializer`라는 서블릿 컨테이너 초기화 기능을 위한 인터페이스를 다음과 같이 제공한다.
  * 이 때, 서블릿 컨테이너는 실행 시점에 초기화용 메소드인 `onStartup()`을 호출한다.
  * 이를 통해 애플리케이션에 필요한 기능들을 사전에 초기화하거나 등록할 수 있게 된다.
```java
package jakarta.servlet;

public interface ServletContainerInitializer {
	public void onStartup(Set<Class<?>> c, ServletContext ctx) throws ServletException;
}
```
* 이 때, `ServletContainerInitializer` 인터페이스의 `onStartUp()`메소드의 인자는 각각 다음과 같은 의미를 갖는다.
  1. `Set<Class<?>> c`: 더 유연한 초기화 기능을 제공하며, `@HandleTypes` 어노테이션과 함께 사용된다.
  2. `ServletContext ctx`:  서블릿 컨테이너 자체의 기능을 제공하며, 이를 통해 필터 또는 서블릿 등을 등록할 수 있다.

## 2025-02-01 Sat
### ServletContainerInitializer 등록하기
> ServletContainerInitializer 인터페이스를 구현하는 초기화 클래스를 생성했더라도 톰캣은 인식할 수 없으므로, 이를 등록해줄 필요가 있다.
* `src/main/resources/META-INF/services` 경로에 `jakarta.servlet.ServletContainerInitializer` 라는 이름의 파일을 생성한다.
  * 이 때, `jakarta.servlet.ServletContainerInitializer`은 `ServletContainerInitializer`의 패키지 경로를 의미한다.
  * 이러한 명명법은 사실상 규약이라고 이해할 수 있으며, 때문에 `META-INF`나 `services` 등의 경로에 대해 오타가 있을 경우 톰캣은 이를 인식할 수 없다. 
* 생성된 파일에는 다음과 같이 개발자가 직접 작성한 `ServletContainerInitializer`의 이름을 패키지 경로와 함께 작성한다.
```text
ga.injuk.study.container.MyInitializerV1
```
* 톰캣이 실행될 때 해당 경로의 파일을 읽어들이며, 개발자가 작성한 `ServletContainerInitializer` 구현체의 `onStartup()` 메소드를 호출한다.

## 2025-02-02 Sun
### 프로그래밍 방식의 서블릿 등록
* 서블릿 컨테이너는 `애플리케이션 초기화`라는 용어로 지칭할 수 있는, 더 유연한 초기화 기능을 지원한다.
  * 이 때, 해당 용어는 정식 용어가 아님에 주의해야 한다.
* 이러한 애플리케이션 초기화 기능을 활용하기 위해서는 아래와 같은 인터페이스의 작성이 필수적이다.
```java
public interface ApplicationInit {
    void onStartup(ServletContext servletContext);
}
```
* 이제 상술한 인터페이스를 기반으로 아래와 같은 구현체 클래스를 작성하는 것으로 서블릿을 수동으로 등록한 후 적절히 매핑할 수 있다.
```java
public class ApplicationInitServlet implements ApplicationInit {
    @Override
    public void onStartup(ServletContext servletContext) {
        // 순수 서블릿 코드 등록하기
        ServletRegistration.Dynamic myServlet = servletContext.addServlet("myServlet", new MyServlet());
        myServlet.addMapping("/my-servlet");
    }
}
```

## 2025-02-03 Mon
### 서블릿을 등록하는 두 가지 방법
* 서블릿을 등록하는 방법은 크게 다음과 같은 두 가지 방식으로 나뉘며, 각기 다른 장단점을 갖는다.
  1. `@WebServlet` 어노테이션을 활용한 등록
  2. `ServletContext`를 활용한 프로그래밍 방식의 등록
* 어노테이션 방식은 편리하다는 장점을 갖지만, 마치 하드코딩된 것처럼 동작하기에 애플리케이션에 유연성을 부여하기 어렵다.
* 반면, 프로그래밍 방식의 등록은 더 많은 코드 작성이 필요하므로 번거롭고 불편하지만 유연성 측면에서 훨씬 더 큰 이점을 갖는다.
  * 예를 들어, 서블릿의 매핑 경로 등록하는 과정에서 필요에 따라 외부 설정을 읽어들이거나, `if` 분기를 활용한 매핑이 가능하다.
# Spring Boot
## 2025-03-04 Tue
### 라이브러리 관리의 어려움과 스프링 부트
* 새로운 애플리케이션의 개발을 시작하는 경우, 사실상 반드시 어떤 라이브러리를 활용하고 의존할지 고민하는 과정이 수반된다.
  * 예를 들어 스프링 WEB 의존성이나 내장 톰캣, JSON 처리기 및 로거 등에 대해 어떤 라이브러리를 사용할지 선택해야 한다.
* 반면, 라이브러리의 종류 선택에 그치지 않고 각 라이브러리의 버전 역시 반드시 고려되어야 한다는 점에서 개발자에게 고통을 줄 수 있다.
  * 각 라이브러리들이 버전에 따라 잘 호환이 될 수도 있으나, 호환되지 않는 상황이 종종 발생하곤 한다.
  * 이러한 문제들로 인해 프로젝트의 최초 설정에는 많은 시간이 소비되며, 이는 고스란히 생산성 저하로 이어진다.
* 반면, **스프링 부트는 개발자가 각각의 라이브러리를 편하게 관리할 수 있도록 지원하는 다양한 기능을 제공**한다.
  * 예를 들어, 스프링 부트는 기본적으로 외부 라이브러리 버전을 관리해주는 동시에  스프링 부트 스타터를 제공한다.
  * 특히, 스프링 부트 스타터는 프로젝트에 필요한 라이브러리들을 각각의 best practice에 따라 선택할 수 있도록 지원한다.

## 2025-03-05 Wed
### 라이브러리 직접 관리하기
* 새로운 스프링 부트 애플리케이션을 개발하기 위해, 그래들을 다음과 같이 설정했다고 가정하자.
```groovy
plugins {
  id 'org.springframework.boot' version '3.0.2'
  id 'java'
}

// ...중략
dependencies {
  implementation 'org.springframework.spring-webmvc:6.0.4'
  implementation 'org.apache.tomcat.embed:tomcat-embed-core:10.1.5'
  // ...후략
}
```
* 상술한 `build.gradle` 설정에서 알 수 있듯, 필요한 라이브러리와 각 라이브러리의 버전을 반드시 명시해주어야 한다.
  * 또한, 이 과정에서 각 라이브러리와 라이브러리 버전이 호환된다는 것을 반드시 확인한 후에 의존성을 추가해주어야 한다.
* 결국 **라이브러리 버전을 개발자가 직접 관리하는 경우, 각 라이브러리와 버전을 이해하고 라이브러리 별 호환성 체크까지 처리할 것이 강요**된다.
  * 이러한 수동 의존성 관리는 기본적으로 어려우며, 비록 헬로 월드 수준의 간단한 애플리케이션을 개발하는 데에도 반드시 필요하다는 점에서 진입 장벽이 된다.

## 2025-03-06 Thu
### 스프링 부트와 라이브러리 버전 관리 플러그인
> 상술한 어려움을 해결하기 위해, 스프링 부트는 개발자 대신 수 많은 라이브러리의 버전을 대신 관리해준다.
* **스프링 부트의 라이브러리 버전 관리 기능을 활용하는 경우, 개발자는 원하는 라이브러리만을 명시하고 버전을 생략**할 수 있다.
  * 이 경우, 스프링 부트는 자체적으로 스프링 부트 버전에 맞춘 최적화된 라이브러리 버전을 자동으로 선택해준다.
* 이 때, 이러한 **스프링 부트의 라이브러리 버전 관리 기능은 다음과 같이 `io.spring.dependency-management` 플러그인으로 처리**된다.
```groovy
plugins {
  id 'org.springframework.boot' version '3.0.2'
  id 'java'
  id 'io.spring.dependency-management' version '1.1.0' // 스프링 부트의 라이브러리 버전 관리 플러그인
}

// ...중략
dependencies {
  // 스프링 부트의 라이브러리 버전 관리 플러그인을 사용하므로, 각 라이브러리의 버전 정보를 생략할 수 있다.
  implementation 'org.springframework.spring-webmvc'
  implementation 'org.apache.tomcat.embed:tomcat-embed-core'
  // ...후략
}
```

## 2025-03-07 Fri
### 스프링 부트의 라이브러리 버전 관리 플러그인 동작 원리
* **`io.spring.dependency-management` 플러그인을 사용할 경우, `spring-boot-dependencies`에 있는 `bom` 정보를 자동으로 참고**하게 된다.
  * 반면, **해당 `bom`은 `org.springframework.boot` 플러그인에서 사용하는 라이브러리**이기에 개발자의 관점에서는 의존성으로 보여지지 않는다.
* 버전 정보 `bom`은 연관된 깃허브 리포지토리에서도 확인 가능하며, 해당 문서는 현재 선택한 스프링 부트 버전에 따른 라이브러리 별 버전 정보를 명시하고 있다.
  * 예를 들어, `id 'org.springframework.boot' version '3.0.2'` 플러그인을 명시한 경우 스프링 부트 버전은 `3.0.2`가 된다.
  * 때문에 해당 부분의 스프링 부트 버전을 변경할 경우, 관련된 라이브러리들의 버전도 함께 변경된다.
  * 추가적으로, `bom`은 `Bill Of Materials`의 약자로서 제품을 구성하는 모든 자재들의 목록인 자재 명세서를 의미한다.
* **스프링 부트의 라이브러리 버전 관리 플러그인을 사용할 경우, 명시된 스프링 부트 버전에 호환된다는 것이 검증된 라이브러리 버전들이 자동으로 적용**된다.
* 반면, **스프링 부트 차원에서 검증되지 않는 라이브러리들도 있으며 이 경우에는 이전의 방법처럼 개발자가 버전을 직접 명시**해줄 필요가 있다.
  * 예를 들어, 아직 대중적으로 잘 알려지지 않아 빈번히 사용되지 않는 라이브러리들은 스프링 부트 차원에서 검증되지 않기에 개발자가 직접 확인해야 한다.
* 이렇듯 **스프링 부트의 라이브러리 버전 관리 플러그인은 스프링을 포함한 여러 외부 라이브러리들에 대해 최적화된 버전 사용을 보장받을 수 있도록 지원**한다.
  * 이로 인해 **개발자는 단지 스프링 부트의 버전만 명시해도 무방하며, 각 라이브러리의 버전과 각각의 호환성은 스프링 부트 차원에서 체크**하게 된다.
  * 물론 사람이 하는 일이기에 100% 안전하지는 않을 수 있으나, 스프링 부트가 라이브러리 별 호환성을 체크하기에 비교적 안전하게 라이브러리를 활용할 수 있다.

## 2025-03-08 Sat
### 스프링 부트 스타터란?
* 상술한 그래들 의존성 설정에서 확인할 수 있듯, **헬로 월드 수준의 간단한 웹 애플리케이션에도 생각보다 많은 라이브러리가 필요**하다.
  * 개발자 입장에서는 매우 간단한 웹 애플리케이션을 개발하는 것임에도 대중적인 라이브러리들을 모두 명시해 주어야한다는 점에서 진입 장벽이 될 수 있다.
* **이상적인 것은 목적에 따라 자주 사용되는 라이브러리들을 하나의 단위로 묶어 관리하는 것이며, 스프링 부트는 이를 위해 스프링 부트 스타터를 제공**한다.
  * 즉, 스프링 부트 스타터를 사용할 경우 개발자들은 쉽고 편리하게 프로젝트를 시작할 수 있게 된다.
* 추가적으로 스프링 부트가 관리하는 스프링 부트 스타터에 명시된 라이브러리의 버전을 변경하는 것도 가능하나, 일반적으로 버전을 변경할 필요는 없다.
  * **실무의 경우, 간혹 이와 같은 문제가 발생할 수 있으므로 스프링 부트 스타터에 포함된 외부 라이브러리의 버전을 변경할 방법은 알아두는 것이 바람직**하다.

## 2025-03-09 Sun
### 웹 애플리케이션 개발을 위한 스프링 부트 스타터 의존성
* 그래들을 예로 들어, `build.gradle`의 의존성을 다음과 같이 명시하는 것으로 수많은 라이브러리들을 명시할 필요가 없어진다.
  * 명시된 **`spring-boot-starter-web` 의존성은 스프링 웹 MVC 기반 애플리케이션 개발에 필요한 모든 라이브러리를 모아둔 세트로 이해**할 수 있다.
```groovy
dependencies {
  implementation 'org.springframework.boot:spring-boot-starter-web'
}
```
* 상술한 바와 같이, **스프링 부트 스타터를 활용할 경우 애플리케이션의 목적과 관련된 라이브러리를 하나로 모아 쉽게 관리**할 수 있다.
  * 예를 들어, 임의의 스프링 부트 스타터에 의존할 경우 관련된 라이브러리 모음을 한 번에 사용할 수 있게 된다.
  * 또한, **임의의 스프링 부트 스타터는 또 다른 스프링 부트 스타터를 포함할 수도 있다**.
 
## 2025-03-10 Mon
### 자주 사용되는 스프링 부트 스타터
* 일반적으로 **스프링 부트 스타터는 `spring-boot-starter-*`과 같은 형태의 명명법을 적용**한다.
  * 예를 들어, `spring-boot-starter-web`은 스프링 웹 MVC 기반의 라이브러리를 모아둔 모음에 해당한다.
  * 반면, 비공식적인 스프링 부트 스타터의 경우 대부분 `[프로젝트명]-spring-boot-starter`와 같은 형태의 명명법을 적용한다.
* 이 때, 실무에서 자주 사용되는 스프링 부트 스타터들은 크게 다음과 같이 정리할 수 있다.
  1. `spring-boot-starter`: 핵심 스타터로, 자동 구성이나 로깅 등의 라이브러리를 포함한다.
  2. `spring-boot-starter-jdbc`: JDBC나 HikariCP 커넥션 풀과 관련된 라이브러리에 해당한다.
  3. `spring-boot-starter-data-jpa`: 스프링 데이터 JPA와 하이버네이트 등을 포함한다.
  4. `spring-boot-starter-web`: 스프링 MVC나 톰캣 등 웹 애플리케이션 개발을 위한 라이브러리들이 포함된다.
  5. `spring-boot-starter-validation`: 하이버네이트 밸리데이터와 같은 Java 빈 검증기 라이브러리 모음에 해당한다.
* 이 밖에도 여러 스프링 부트 스타터가 존재하며, 특히 `spring-boot-starter`는 단독으로 사용되기 보다는 다른 스타터에 포함되는 식으로 활용된다.

## 2025-03-11 Tue
### 반복적인 설정의 불편함
* 예를 들어 JDBC와 DB를 사용하는 애플리케이션을 개발하는 경우, 다음과 같은 스프링 빈이 필수적이라고 볼 수 있다.
  1. `JdbcTemplate`
  2. `DataSource`
  3. `TransactionManager`
* 이는 바꿔 말해 DB를 사용하기 위해서는 이러한 객체들의 인스턴스화 및 스프링 빈 등록 과정이 전제된다는 것에 해당한다.
  * 즉, DB를 사용하는 새로운 애플리케이션을 개발하는 경우 이러한 스프링 빈의 수동 등록 과정이 반복적으로 작성되어야 한다.
* **스프링 부트는 이를 해결하기 위해 자동 구성 기능을 제공하며, 프로젝트마다 반복적으로 사용되는 빈을 편리하게 생성 및 등록할 수 있도록 지원**한다.

## 2025-03-12 Wed
### 스프링 부트와 자동 구성
> 스프링 부트는 일반적으로 자주 사용되는 다양한 빈들을 자동으로 등록해주는 자동 구성 기능을 제공한다.
* 예를 들어, DB를 사용하는 애플리케이션에서 자주 사용되는 `DataSource` 또는 `TransactionManager` 따위의 빈은 스프링 부트 차원에서 자동 등록된다.
  * 덕분에 개발자는 반복적이고 복잡한 빈 등록 과정 없이 애플리케이션을 빠르게 개발해나갈 수 있게 된다.
* 이 때, 이러한 스프링 부트의 자동 구성은 `spring-boot-autoconfigure` 프로젝트 내에서 관리된다.
  * 사실, 해당 프로젝트는 스프링 부트를 사용하는 경우 자동으로 포함되는 라이브러리로 이해할 수 있다.
  * 이는 각 스프링 부트 스타터가 내부적으로 항상 포함하는 `spring-boot-starter` 라이브러리에 해당 라이브러리가 포함되기 때문이다.
* 또한, 스프링 부트의 자동 구성 기능을 이해하기 위해서는 다음과 같은 개념을 반드시 이해할 필요가 있다.
  1. `@Conditional`: 특정 조건에 맞는 경우에 설정이 동작하도록 한다.
  2. `@AutoConfiguration`: 자동 구성이 어떻게 동작하는지, 즉 내부적인 동작 방식과 관련이 있다.

## 2025-03-13 Thu
### 자동 구성과 관련된 어노테이션 훑어보기
> 스프링 부트는 자동 구성 기능을 위해 여러 어노테이션을 제공한다.
* `@AutoConfiguration` 어노테이션은 자동 구성을 사용하기 위해 필수적으로 등록되는 어노테이션에 해당한다.
  * 해당 어노테이션은 내부적으로 `@Configuration` 어노테이션을 포함하며, 이로 인해 빈을 등록하기 위한 설정으로 사용하는 것이 가능하다.
  * 또한, 해당 어노테이션에 `after` 인자를 전달하는 것으로 자동 구성 순서를 지정할 수도 있다.
* `@ConditionalOnClass` 어노테이션은 일반적인 `if`문과 유사한 기능을 수행하며, 지정된 클래스가 존재하는 경우에만 동작하도록 설정한다.
  * 유사한 형태를 띄는 `@ConditionalXXX` 어노테이션들이 있으며, 이러한 어노테이션들은 모두 스프링 부트가 제공하는 자동 구성 기능의 핵심을 구성한다.
* `@ConditionalOnMissingBean` 어노테이션은 인자에 명시된 유형의 빈이 없을 때에만 자동 구성을 실행하며, 이로 인해 개발자의 설정을 우선할 수 있다.
  * **해당 어노테이션은 `JdbcTemplate` 빈과 같이 동일한 유형의 빈이 여럿 등록되는 경우 충돌이 발생할 수 있는 가능성이 있는 경우에 활용**할 수 있다.

## 2025-03-14 Fri
### 스프링 부트가 제공하는 자동 구성 대상
* 상술한 예를 들어, JDBC와 DB를 활용하는 애플리케이션은 다음과 같은 자동 구성 기능들이 필요한 빈을 등록한다.
  1. `JdbcTemplateAutoConfiguration`: `JdbcTemplate` 빈을 자동 구성한다.
  2. `DataSourceAutoConfiguration`: `DataSource` 빈을 자동 구성한다.
  3. `DataSourceTransactionManagerAutoConfiguration`: `TransactionManager` 빈을 자동 구성한다.
* 이들 자동 구성으로 인해 필요한 빈들이 각각 자동 등록되며, 이 밖에도 스프링 부트는 수 많은 자동 구성 기능을 제공한다.
  * 이 때, 자동 구성이 가능한 대상들은 모두 스프링 부트의 공식 문서에 정리되어 있으므로 필요한 경우 참고할 수 있다.
* 앞서 다뤘듯, 이러한 **자동 구성은 `spring-boot-autoconfigure` 프로젝트에 모여 있으며 스프링 부트의 경우 해당 라이브러리를 기본으로 포함**한다.

## 2025-03-15 Sat
### Auto Configuration과 관련된 두 가지 용어
* Auto Configuration은 크게 `자동 설정` 또는 `자동 구성`이라는 용어 중 하나로 번역되어 사용된다.
* 이 때, 일반적으로 자동 설정이란 빈을 자동으로 등록하여 스프링이 동작할 수 있는 환경을 설정하므로 더 넓은 의미로 사용된다.
* 반면, 자동 구성은 스프링이 실행되는 과정에서 필수적으로 필요한 빈들을 일종의 구성 요소로써 자동 배치하는 것과 같이 상대적으로 더 좁은 의미에 가깝다.
* 그러나 **이러한 용어의 구분에 크게 집착할 필요는 없으며, 문맥에 따라 미묘한 차이 포함할 수 있다는 점을 기억하는 것이 바람직**하다.

## 2025-03-16 Sun
### @Conditional 어노테이션
* 예를 들어 특정한 조건을 만족하는 경우를 쉽게 판별할 수 있도록 스프링 부트는 `@Conditional` 어노테이션을 제공한다.
* 이 때, 이러한 기능을 사용하기 위해서는 우선 다음과 같은 `Condition` 인터페이스를 구현할 필요가 있다.
```java
public interface Condition {
    boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata);
}
```
* `Condition` 인터페이스가 제공하는 `matches()` 메소드가 참을 반환할 경우 조건을 만족한 것으로 판정하여 동작하며, 거짓을 반환할 경우 동작하지 않는다.
  * 이 때, `ConditionContext`는 스프링 컨테이너나 환경 정보 등의 정보를 포함하고 `AnnotatedTypeMetadata`는 어노테이션의 메타데이터를 포함한다.

## 2025-03-17 Mon
### @Conditional 어노테이션 활용하기
* 어떠한 조건에 따라 적용될 수 있도록 `Condition` 인터페이스를 구현하는 경우, 다음과 같은 클래스를 작성해볼 수 있다.
```java
public class MyCondition implements Condition {
  @Override
  public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
      // 여기에 로직 적으로 적용 여부를 반환할 수 있도록 작성한다.
      return true;
  }
}
```
* 이렇게 작성된 `Condition` 구현체는 다음과 같이 `@Configuration` 클래스에 적용할 수 있다.
  * 이 경우, **`MyCondition` 클래스의 `matches()` 메소드가 참을 반환하는 경우에만 `MyConfig`의 빈들이 등록**된다.
  * 반면, 스프링이 로딩되는 과정은 복잡하기 때문에 해당 `Condition` 구현체가 여러 번 호출될 수 있다.
```java
@Configuration
@Conditional(MyCondition.class)
public class MyConfig {
  // ...생략
}
```

## 2025-03-18 Tue
### 다양한 @Conditional 어노테이션 활용하기
* 반면, 유사한 코드를 계속해서 다시 개발하는 일이 없도록 스프링은 이미 수많은 `@Conditional` 어노테이션을 제공한다.
* 예를 들어, 환경 변수나 실행 인자 등을 기반으로 적용 여부를 결정한다면 `@ConditionalOnProperty` 어노테이션을 활용할 수 있다.
  * 해당 어노테이션의 경우 `@ConditionalOnProperty(name = "[프로퍼티명]", havingValue = "[검증대상값])` 형태로 사용할 수 있다.
  * 물론, 해당 어노테이션 역시 내부적으로는 `@Conditional` 어노테이션을 사용하며 인자로 `Condition` 인터페이스의 구현체를 명시하고 있다.

## 2025-03-19 Wed
### 스프링이 제공하는 @ConditionalOnXXX 어노테이션 - I
* 스프링은 `@Conditional` 어노테이션과 관련하여 개발자가 편리하게 사용할 수 있을만한 수 많은 어노테이션을 다음과 같이 제공한다.
  1. `@ConditionalOnClass`: 명시된 클래스가 있는 경우에만 동작한다.
  2. `@ConditionalOnMissingClass`: 명시된 클래스가 없는 경우에만 동작한다.
  3. `@ConditionalOnBean`: 명시된 빈이 등록된 경우에만 동작한다.
  4. `@ConditionalOnMissingBean`: 명시된 빈이 등록되지 않은 경우에만 동작한다.
  5. `@ConditionalOnProperty`: 명시된 환경 정보가 있는 경우에만 동작한다.

## 2025-03-20 Thu
### 스프링이 제공하는 @ConditionalOnXXX 어노테이션들 - II
* 스프링은 또한 다음과 같은 `@Conditional` 관련 어노테이션들을 제공한다.
  1. `@ConditionalOnResource`: 명시된 리소스가 있는 경우에만 동작한다.
  2. `@ConditionalOnWebApplication`: 웹 애플리케이션인 경우에만 동작한다.
  3. `@ConditionalOnNotWebApplication`: 웹 애플리케이션이 아닌 경우에만 동작한다.
  4. `@ConditionalOnExpression`: `SpEL` 표현식을 만족하는 경우에만 동작한다.
* 이렇듯 **`@ConditionalOnXXX` 어노테이션들은 직관적인 이름을 갖기에 동작을 바로 이해할 수 있으며, 주로 스프링 부트의 자동 구성에 사용**된다.
* 추가적으로, `@Conditional` 어노테이션 자체는 스프링에 포함되는 반면 스프링 부트가 이를 확장한 `@ConditionalOnXXX` 어노테이션을 제공한다.

## 2025-03-21 Fri
### 번외 - 나만의 라이브러리 만들기
* 애플리케이션을 라이브러리 형태로 배포하고자 하는 경우, 실행 가능한 JAR로 작성할 필요가 없으므로 스프링 부트와 관련된 플러그인을 사용하지 않아야 한다.
  * 스프링 부트 플러그인을 사용할 경우, 빌드시 기본적으로 실행 가능한 JAR 형태의 결과물이 생성된다.
  * 그러나 라이브러리 형태의 애플리케이션은 단독으로 실행될 필요 없이 다른 프로젝트에 포함되어 사용되어야 하므로, 이러한 기능이 필요하지 않다.
  * 반면, 스프링 부트 플러그인을 사용하지 않을 경우 스프링과 관련된 의존성들의 버전을 직접 명시해주어야 하는 단점 역시 존재한다.
* 필요한 기능을 개발 완료한 경우, `./gradlew build` 명령어 등을 입력하여 JAR 파일로 빌드할 수 있다.
  * 라이브러리라고 해서 번듯한 무언가가 되는 것은 아니며, 그저 여러 클래스를 묶어둔 일종의 묶음이라고 이해할 수 있다.

## 2025-03-22 Sat
### 번외 - 나만의 라이브러리 사용하기
* 상술한 라이브러리를 별도의 프로젝트에서 참조하는 방식으로 사용하는 경우, `Nexus`와 같은 사설 리포지토리를 사용하지 않는다면 다음과 같이 임포트할 수 있다.
  * 반면, 나만의 라이브러리를 임포트하는 프로젝트의 최상단에 `libs`라는 이름의 폴더가 생성되어 있는 것을 전제함에 주의해야 한다.
```groovy
dependencies {
  implementation files('libs/my_application_v1.jar')
  // ...생략
}
```
* 이는 JAR 파일을 로컬 환경에 직접 갖고 있는 경우에만 사용 가능하며, 아래와 같이 입력한 후 그래들을 `reload`하여 프로젝트에 적용할 수 있다.
  * IntelliJ와 같은 통합 개발 환경의 경우, 그래들 `reload`가 완료되는 시점에서 해당 JAR 파일에 포함된 클래스들이 인식된다.
* 반면, 나만의 라이브러리에 포함된 클래스 중 일부가 컨트롤러 등 스프링 빈으로 등록되는 것을 전제로 한다면 이를 별도의 설정 클래스에서 수동 등록해야 한다.
  * 이는 나만의 라이브러리가 스프링 부트의 자동 구성 기능을 제공하지 않고, 컴포넌트 스캔 설정을 수정하지도 않은 경우에 해당한다.
* 그러나 이러한 설정 방식은 개발자가 해당 라이브러리에 포함된 스프링 빈의 등록 방법을 모두 이해하고, 이를 코드로 직접 개발해야 한다는 번거로움이 수반된다.
* 이러한 작업은 귀찮으면서도 휴먼 에러의 발생 가능성이 높으므로, 이를 자동으로 처리할 수 있도록 스프링 부트의 자동 구성을 활용하는 것을 고려해볼 수 있다. 

## 2025-03-23 Sun
### 번외 - 나만의 라이브러리에 자동 구성 기능을 추가하기
* 예를 들어 `@RestController` 어노테이션이 명시된 컨트롤러에 대해 실행 인자에 따른 자동 구성 기능을 제공하고자 하는 경우, 다음과 같이 구현할 수 있다.
```java
import javax.management.MXBean;

@AutoConfiguration
@ConditionalOnProperty(name = "mode", havingValue = "on")
public class MyAutoConfiguration {
  @Bean
  public MyController myController() {
    return new MyController();
  }
} 
```

## 2025-03-24 Mon
### 번외 - 자동 구성 대상 명시하기
* **여기에 그치지 않고, `META-INF` 경로에 포함된 파일에 자동 구성 대상을 다음과 같이 반드시 명시해주어야 자동 구성 기능을 제공**할 수 있게 된다.
  * 스프링 부트는 애플리케이션 시작시 아래와 같은 패키지 경로에 포함된 `긴 이름의 파일`에 명시된 정보를 읽어들여 자동 구성에 활용한다.
  * 아래의 경우, **명시된 내용은 패키지를 포함한 자동 구성 클래스인 `myapp.MyAutoConfiguration`이므로 해당 설정 파일이 자동으로 처리**된다.
```shell
# src/main/resources/META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports
myapp.MyAutoConfiguration
```
* 이 때, 파일 이름이 `org.springframework.boot.autoconfigure.AutoConfiguration.imports`와 같이 긴 것에 주의해야 한다.
* 상술한 모든 과정을 올바르게 진행할 경우, 애플리케이션이 실행되는 과정에서 찾아낸 모든 `@AutoConfiguration` 설정을 조건에 따라 실행하게 된다.
  * 예를 들어, **스프링 부트 애플리케이션은 실행 과정에서 자신이 포함하는 모든 라이브러리로부터 상술한 파일들을 읽어들인 후 필요한 자동 구성을 실행**한다.
  * 때문에 `-Dmode=on`과 같은 인자와 함께 애플리케이션을 실행한 경우 `MyAutoConfiguration` 클래스에 명시된 내용에 따라 스프링 빈을 등록한다.

## 2025-03-25 Tue
### 스프링 부트의 자동 구성 원리
* 상술한 바와 같이, 스프링 부트는 `src`로부터 시작하여 `org.[...생략].AutoConfiguration.imports` 파일을 조회하여 자동 구성에 활용한다.
  * 이 때, **스프링은 애플리케이션에 포함된 모든 라이브러리에 대해 해당 파일을 찾아 내용을 조회하여 필요한 자동 구성을 등록하는 형태로 동작**한다.
* 스프링 부트의 자동 구성은 크게 다음과 같은 순서에 따라 동작하는 것으로 이해할 수 있다.
  1. `@SpringBootApplication`: 일반적으로 `main()`이 위치하는, 해당 어노테이션이 할당된 클래스를 설정 정보로 사용한다는 의미를 갖는다.
  2. `@EnableAutoConfiguration`: `@SpringBootApplication`에 포함되어 있으며, 스프링 부트의 자동 구성을 활성화하는 기능을 제공한다.
  3. `@Import(AutoConfigurationImportSelector.class)`: `@EnableAutoConfiguration`에 포함되며, 인자로 클래스를 전달 받는다.
* 이 때, `@Import` 어노테이션은 일반적으로 `@Configuration`과 같은 스프링 설정 정보를 포함하기 위해 사용한다.
  * 반면, 상술한 **`@Import`에 인자로 전달된 `AutoConfigurationImportSelector` 클래스는 `@Configuration` 어노테이션을 포함하지 않는다**.

## 2025-03-26 Wed
### ImportSelector 인터페이스의 필요성
* `@Import` 어노테이션을 통해 설정 정보를 추가하는 방법은 크게 다음과 같이 분류할 수 있다.
  1. 정적인 방식: `@Import([클래스명])`과 같이 입력하는 것으로 설정 정보를 추가할 수 있으나, 대상은 동적으로 변경이 불가능하다.
  2. 동적인 방식: `@Import([ImportSelector구현체])`와 같이 입력하는 것으로 설정 대상을 동적으로 결정할 수 있다.
* 즉, 정적인 방식의 경우 아래와 같은 코드를 통해 설정 정보인 `MyConfiguration` 클래스를 정적으로 추가할 수 있다.
```java
@Configuration
@Import(MyConfiguration.class)
public class ApplicationConfiguration {}
```
* 반면, 상술한 방식은 설정 정보가 임의의 조건에 따라 동적으로 결정되는 경우에 대응이 불가능하기에 스프링은 `ImportSelector` 인터페이스를 제공한다.
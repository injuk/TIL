# Spring Boot
## 2025-03-04 Tue
### 라이브러리 관리의 어려움과 스프링 부트
* 새로운 애플리케이션의 개발을 시작하는 경우, 사실상 반드시 어떤 라이브러리를 활용하고 의존할지 고민하는 과정이 수반된다.
  * 예를 들어 스프링 WEB 의존성이나 내장 톰캣, JSON 처리기 및 로거 등에 대해 어떤 라이브러리를 사용할지 선택해야 한다.
* 반면, 라이브러리의 종류 선택에 그치지 않고 각 라이브러리의 버전 역시 반드시 고려되어야 한다는 점에서 개발자에게 고통을 줄 수 있다.
  * 각 라이브러리들이 버전에 따라 잘 호환이 될 수도 있으나, 호환되지 않는 상황이 종종 발생하곤 한다.
  * 이러한 문제들로 인해 프로젝트의 최초 설정에는 많은 시간이 소비되며, 이는 고스란히 생산성 저하로 이어진다.
* 반면, **스프링 부트는 개발자가 각각의 라이브러리를 편하게 관리할 수 있도록 지원하는 다양한 기능을 제공**한다.
  * 예를 들어, 스프링 부트는 기본적으로 외부 라이브러리 버전을 관리해주는 동시에  스프링 부트 스타터를 제공한다.
  * 특히, 스프링 부트 스타터는 프로젝트에 필요한 라이브러리들을 각각의 best practice에 따라 선택할 수 있도록 지원한다.

## 2025-03-05 Wed
### 라이브러리 직접 관리하기
* 새로운 스프링 부트 애플리케이션을 개발하기 위해, 그래들을 다음과 같이 설정했다고 가정하자.
```groovy
plugins {
  id 'org.springframework.boot' version '3.0.2'
  id 'java'
}

// ...중략
dependencies {
  implementation 'org.springframework.spring-webmvc:6.0.4'
  implementation 'org.apache.tomcat.embed:tomcat-embed-core:10.1.5'
  // ...후략
}
```
* 상술한 `build.gradle` 설정에서 알 수 있듯, 필요한 라이브러리와 각 라이브러리의 버전을 반드시 명시해주어야 한다.
  * 또한, 이 과정에서 각 라이브러리와 라이브러리 버전이 호환된다는 것을 반드시 확인한 후에 의존성을 추가해주어야 한다.
* 결국 **라이브러리 버전을 개발자가 직접 관리하는 경우, 각 라이브러리와 버전을 이해하고 라이브러리 별 호환성 체크까지 처리할 것이 강요**된다.
  * 이러한 수동 의존성 관리는 기본적으로 어려우며, 비록 헬로 월드 수준의 간단한 애플리케이션을 개발하는 데에도 반드시 필요하다는 점에서 진입 장벽이 된다.

## 2025-03-06 Thu
### 스프링 부트와 라이브러리 버전 관리 플러그인
> 상술한 어려움을 해결하기 위해, 스프링 부트는 개발자 대신 수 많은 라이브러리의 버전을 대신 관리해준다.
* **스프링 부트의 라이브러리 버전 관리 기능을 활용하는 경우, 개발자는 원하는 라이브러리만을 명시하고 버전을 생략**할 수 있다.
  * 이 경우, 스프링 부트는 자체적으로 스프링 부트 버전에 맞춘 최적화된 라이브러리 버전을 자동으로 선택해준다.
* 이 때, 이러한 **스프링 부트의 라이브러리 버전 관리 기능은 다음과 같이 `io.spring.dependency-management` 플러그인으로 처리**된다.
```groovy
plugins {
  id 'org.springframework.boot' version '3.0.2'
  id 'java'
  id 'io.spring.dependency-management' version '1.1.0' // 스프링 부트의 라이브러리 버전 관리 플러그인
}

// ...중략
dependencies {
  // 스프링 부트의 라이브러리 버전 관리 플러그인을 사용하므로, 각 라이브러리의 버전 정보를 생략할 수 있다.
  implementation 'org.springframework.spring-webmvc'
  implementation 'org.apache.tomcat.embed:tomcat-embed-core'
  // ...후략
}
```

## 2025-03-07 Fri
### 스프링 부트의 라이브러리 버전 관리 플러그인 동작 원리
* **`io.spring.dependency-management` 플러그인을 사용할 경우, `spring-boot-dependencies`에 있는 `bom` 정보를 자동으로 참고**하게 된다.
  * 반면, **해당 `bom`은 `org.springframework.boot` 플러그인에서 사용하는 라이브러리**이기에 개발자의 관점에서는 의존성으로 보여지지 않는다.
* 버전 정보 `bom`은 연관된 깃허브 리포지토리에서도 확인 가능하며, 해당 문서는 현재 선택한 스프링 부트 버전에 따른 라이브러리 별 버전 정보를 명시하고 있다.
  * 예를 들어, `id 'org.springframework.boot' version '3.0.2'` 플러그인을 명시한 경우 스프링 부트 버전은 `3.0.2`가 된다.
  * 때문에 해당 부분의 스프링 부트 버전을 변경할 경우, 관련된 라이브러리들의 버전도 함께 변경된다.
  * 추가적으로, `bom`은 `Bill Of Materials`의 약자로서 제품을 구성하는 모든 자재들의 목록인 자재 명세서를 의미한다.
* **스프링 부트의 라이브러리 버전 관리 플러그인을 사용할 경우, 명시된 스프링 부트 버전에 호환된다는 것이 검증된 라이브러리 버전들이 자동으로 적용**된다.
* 반면, **스프링 부트 차원에서 검증되지 않는 라이브러리들도 있으며 이 경우에는 이전의 방법처럼 개발자가 버전을 직접 명시**해줄 필요가 있다.
  * 예를 들어, 아직 대중적으로 잘 알려지지 않아 빈번히 사용되지 않는 라이브러리들은 스프링 부트 차원에서 검증되지 않기에 개발자가 직접 확인해야 한다.
* 이렇듯 **스프링 부트의 라이브러리 버전 관리 플러그인은 스프링을 포함한 여러 외부 라이브러리들에 대해 최적화된 버전 사용을 보장받을 수 있도록 지원**한다.
  * 이로 인해 **개발자는 단지 스프링 부트의 버전만 명시해도 무방하며, 각 라이브러리의 버전과 각각의 호환성은 스프링 부트 차원에서 체크**하게 된다.
  * 물론 사람이 하는 일이기에 100% 안전하지는 않을 수 있으나, 스프링 부트가 라이브러리 별 호환성을 체크하기에 비교적 안전하게 라이브러리를 활용할 수 있다.

## 2025-03-08 Sat
### 스프링 부트 스타터란?
* 상술한 그래들 의존성 설정에서 확인할 수 있듯, **헬로 월드 수준의 간단한 웹 애플리케이션에도 생각보다 많은 라이브러리가 필요**하다.
  * 개발자 입장에서는 매우 간단한 웹 애플리케이션을 개발하는 것임에도 대중적인 라이브러리들을 모두 명시해 주어야한다는 점에서 진입 장벽이 될 수 있다.
* **이상적인 것은 목적에 따라 자주 사용되는 라이브러리들을 하나의 단위로 묶어 관리하는 것이며, 스프링 부트는 이를 위해 스프링 부트 스타터를 제공**한다.
  * 즉, 스프링 부트 스타터를 사용할 경우 개발자들은 쉽고 편리하게 프로젝트를 시작할 수 있게 된다.
* 추가적으로 스프링 부트가 관리하는 스프링 부트 스타터에 명시된 라이브러리의 버전을 변경하는 것도 가능하나, 일반적으로 버전을 변경할 필요는 없다.
  * **실무의 경우, 간혹 이와 같은 문제가 발생할 수 있으므로 스프링 부트 스타터에 포함된 외부 라이브러리의 버전을 변경할 방법은 알아두는 것이 바람직**하다.

## 2025-03-09 Sun
### 웹 애플리케이션 개발을 위한 스프링 부트 스타터 의존성
* 그래들을 예로 들어, `build.gradle`의 의존성을 다음과 같이 명시하는 것으로 수많은 라이브러리들을 명시할 필요가 없어진다.
  * 명시된 **`spring-boot-starter-web` 의존성은 스프링 웹 MVC 기반 애플리케이션 개발에 필요한 모든 라이브러리를 모아둔 세트로 이해**할 수 있다.
```groovy
dependencies {
  implementation 'org.springframework.boot:spring-boot-starter-web'
}
```
* 상술한 바와 같이, **스프링 부트 스타터를 활용할 경우 애플리케이션의 목적과 관련된 라이브러리를 하나로 모아 쉽게 관리**할 수 있다.
  * 예를 들어, 임의의 스프링 부트 스타터에 의존할 경우 관련된 라이브러리 모음을 한 번에 사용할 수 있게 된다.
  * 또한, **임의의 스프링 부트 스타터는 또 다른 스프링 부트 스타터를 포함할 수도 있다**.
 
## 2025-03-10 Mon
### 자주 사용되는 스프링 부트 스타터
* 일반적으로 **스프링 부트 스타터는 `spring-boot-starter-*`과 같은 형태의 명명법을 적용**한다.
  * 예를 들어, `spring-boot-starter-web`은 스프링 웹 MVC 기반의 라이브러리를 모아둔 모음에 해당한다.
  * 반면, 비공식적인 스프링 부트 스타터의 경우 대부분 `[프로젝트명]-spring-boot-starter`와 같은 형태의 명명법을 적용한다.
* 이 때, 실무에서 자주 사용되는 스프링 부트 스타터들은 크게 다음과 같이 정리할 수 있다.
  1. `spring-boot-starter`: 핵심 스타터로, 자동 구성이나 로깅 등의 라이브러리를 포함한다.
  2. `spring-boot-starter-jdbc`: JDBC나 HikariCP 커넥션 풀과 관련된 라이브러리에 해당한다.
  3. `spring-boot-starter-data-jpa`: 스프링 데이터 JPA와 하이버네이트 등을 포함한다.
  4. `spring-boot-starter-web`: 스프링 MVC나 톰캣 등 웹 애플리케이션 개발을 위한 라이브러리들이 포함된다.
  5. `spring-boot-starter-validation`: 하이버네이트 밸리데이터와 같은 Java 빈 검증기 라이브러리 모음에 해당한다.
* 이 밖에도 여러 스프링 부트 스타터가 존재하며, 특히 `spring-boot-starter`는 단독으로 사용되기 보다는 다른 스타터에 포함되는 식으로 활용된다.

## 2025-03-11 Tue
### 반복적인 설정의 불편함
* 예를 들어 JDBC와 DB를 사용하는 애플리케이션을 개발하는 경우, 다음과 같은 스프링 빈이 필수적이라고 볼 수 있다.
  1. `JdbcTemplate`
  2. `DataSource`
  3. `TransactionManager`
* 이는 바꿔 말해 DB를 사용하기 위해서는 이러한 객체들의 인스턴스화 및 스프링 빈 등록 과정이 전제된다는 것에 해당한다.
  * 즉, DB를 사용하는 새로운 애플리케이션을 개발하는 경우 이러한 스프링 빈의 수동 등록 과정이 반복적으로 작성되어야 한다.
* **스프링 부트는 이를 해결하기 위해 자동 구성 기능을 제공하며, 프로젝트마다 반복적으로 사용되는 빈을 편리하게 생성 및 등록할 수 있도록 지원**한다.

## 2025-03-12 Wed
### 스프링 부트와 자동 구성
> 스프링 부트는 일반적으로 자주 사용되는 다양한 빈들을 자동으로 등록해주는 자동 구성 기능을 제공한다.
* 예를 들어, DB를 사용하는 애플리케이션에서 자주 사용되는 `DataSource` 또는 `TransactionManager` 따위의 빈은 스프링 부트 차원에서 자동 등록된다.
  * 덕분에 개발자는 반복적이고 복잡한 빈 등록 과정 없이 애플리케이션을 빠르게 개발해나갈 수 있게 된다.
* 이 때, 이러한 스프링 부트의 자동 구성은 `spring-boot-autoconfigure` 프로젝트 내에서 관리된다.
  * 사실, 해당 프로젝트는 스프링 부트를 사용하는 경우 자동으로 포함되는 라이브러리로 이해할 수 있다.
  * 이는 각 스프링 부트 스타터가 내부적으로 항상 포함하는 `spring-boot-starter` 라이브러리에 해당 라이브러리가 포함되기 때문이다.
* 또한, 스프링 부트의 자동 구성 기능을 이해하기 위해서는 다음과 같은 개념을 반드시 이해할 필요가 있다.
  1. `@Conditional`: 특정 조건에 맞는 경우에 설정이 동작하도록 한다.
  2. `@AutoConfiguration`: 자동 구성이 어떻게 동작하는지, 즉 내부적인 동작 방식과 관련이 있다.

## 2025-03-13 Thu
### 자동 구성과 관련된 어노테이션 훑어보기
> 스프링 부트는 자동 구성 기능을 위해 여러 어노테이션을 제공한다.
* `@AutoConfiguration` 어노테이션은 자동 구성을 사용하기 위해 필수적으로 등록되는 어노테이션에 해당한다.
  * 해당 어노테이션은 내부적으로 `@Configuration` 어노테이션을 포함하며, 이로 인해 빈을 등록하기 위한 설정으로 사용하는 것이 가능하다.
  * 또한, 해당 어노테이션에 `after` 인자를 전달하는 것으로 자동 구성 순서를 지정할 수도 있다.
* `@ConditionalOnClass` 어노테이션은 일반적인 `if`문과 유사한 기능을 수행하며, 지정된 클래스가 존재하는 경우에만 동작하도록 설정한다.
  * 유사한 형태를 띄는 `@ConditionalXXX` 어노테이션들이 있으며, 이러한 어노테이션들은 모두 스프링 부트가 제공하는 자동 구성 기능의 핵심을 구성한다.
* `@ConditionalOnMissingBean` 어노테이션은 인자에 명시된 유형의 빈이 없을 때에만 자동 구성을 실행하며, 이로 인해 개발자의 설정을 우선할 수 있다.
  * **해당 어노테이션은 `JdbcTemplate` 빈과 같이 동일한 유형의 빈이 여럿 등록되는 경우 충돌이 발생할 수 있는 가능성이 있는 경우에 활용**할 수 있다.

## 2025-03-14 Fri
### 스프링 부트가 제공하는 자동 구성 대상
* 상술한 예를 들어, JDBC와 DB를 활용하는 애플리케이션은 다음과 같은 자동 구성 기능들이 필요한 빈을 등록한다.
  1. `JdbcTemplateAutoConfiguration`: `JdbcTemplate` 빈을 자동 구성한다.
  2. `DataSourceAutoConfiguration`: `DataSource` 빈을 자동 구성한다.
  3. `DataSourceTransactionManagerAutoConfiguration`: `TransactionManager` 빈을 자동 구성한다.
* 이들 자동 구성으로 인해 필요한 빈들이 각각 자동 등록되며, 이 밖에도 스프링 부트는 수 많은 자동 구성 기능을 제공한다.
  * 이 때, 자동 구성이 가능한 대상들은 모두 스프링 부트의 공식 문서에 정리되어 있으므로 필요한 경우 참고할 수 있다.
* 앞서 다뤘듯, 이러한 **자동 구성은 `spring-boot-autoconfigure` 프로젝트에 모여 있으며 스프링 부트의 경우 해당 라이브러리를 기본으로 포함**한다.

## 2025-03-15 Sat
### Auto Configuration과 관련된 두 가지 용어
* Auto Configuration은 크게 `자동 설정` 또는 `자동 구성`이라는 용어 중 하나로 번역되어 사용된다.
* 이 때, 일반적으로 자동 설정이란 빈을 자동으로 등록하여 스프링이 동작할 수 있는 환경을 설정하므로 더 넓은 의미로 사용된다.
* 반면, 자동 구성은 스프링이 실행되는 과정에서 필수적으로 필요한 빈들을 일종의 구성 요소로써 자동 배치하는 것과 같이 상대적으로 더 좁은 의미에 가깝다.
* 그러나 **이러한 용어의 구분에 크게 집착할 필요는 없으며, 문맥에 따라 미묘한 차이 포함할 수 있다는 점을 기억하는 것이 바람직**하다.
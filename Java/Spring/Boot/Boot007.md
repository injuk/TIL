# Spring Boot
## 2025-06-06 Fri
### 프로덕션 준비 기능이란?
```
> 서비스를 운영하는 개발자에게 있어 운영 상의 장애는 언제나 발생할 수 있는 일이지만, 그렇다고 해서 모니터링을 소홀히하지는 않아야 한다.
```
* 개발자는 애플리케이션을 개발하는 과정에서 기능적인 요구 사항만을 처리하는 것이 아니며, 서비스를 모니터링하고 감시하는 활동 역시 중요하다.
  * 다시 말해, 서비스가 운영 단계까지 이르게 되면 서비스 자체적인 문제가 없는지 지속적으로 확인할 필요가 있다.
* 이렇듯 **서비스를 운영할 때 필요한 여러 기능들을 프로덕션 준비 기능이라고 지칭하며, 이는 운영 환경에 준비되어야 하는 비기능적인 요소들을 포함**한다.
  * 에를 들어 지표와 추적, 감사와 모니터링 등의 비기능적 요소를 준비할 필요가 있다.
  * 이를 통해 애플리케이션의 동작 여부와 필요한 로그의 출력, 커넥션 풀의 가용 수준 등을 확인할 수 있어야 한다.

## 2025-06-07 Sat
### 스프링 부트와 프로덕션 준비 기능
```
> 액추에이터는 시스템을 움직이거나 제어하는 데에 활용될 수 있는 기계 장치를 의미한다.
```
* 스프링 부트는 프로덕션 준비 기능을 편리하게 사용할 수 있도록 여러 편의 기능을 제공하며, 이는 액추에이터라는 이름으로 지칭된다.
  * 예를 들어 액추에이터로 인해 자동 등록되는 여러 엔드포인트를 활용하여 애플리케이션의 상태나 로그들을 확인할 수 있도록 지원한다.
  * 나아가 실무에서 자주 사용되는 마이크로미터나 프로메테우스, 그라파나와 같은 모니터링 시스템과 쉽게 연동할 수 있도록 지원하는 기능 역시 제공한다.

## 2025-06-08 Sun
### 프로젝트에 액추에이터 적용하기
* 액추에이터가 제공하는 여러 프로덕션 준비 기능을 활용하기 위해서는 아래와 같은 의존성을 추가해야 한다.
```groovy
implementation 'org.springframework.boot:spring-boot-starter-actuator'
```
* 스프링 웹 MVC 기반의 애플리케이션을 예로 들어, 상술한 의존성에 의해 애플리케이션을 실행시킨 후 `/actuator` 경로로 GET 요청을 전달할 수 있게 된다.
* 상술한 요청에 의해 반환되는 경로는 크게 다음과 같으며, 각각의 경로 역시 GET 요청을 처리할 수 있다.
  * `/actuator/health`: `{"status":"UP"}`과 같은 응답이 반환되며, 이는 단순히 현 서버의 정상 동작성을 표현한다.
  * `/actuator/health/{*path}`
* 이러한 **기본 기능은 단순히 애플리케이션의 정상성만을 검증하므로, 액추에이터의 다양한 기능을 활용하기 위해서는 추가적인 설정이 필요**하다.

## 2025-06-09 Mon
### 액추에이터의 추가 기능을 노출하기
* 액추에이터는 다양한 기능을 제공하는 반면, 이들은 기본적으로 웹에 노출되지 않으므로 다음과 같은 설정을 명시하여 기능을 노출시켜야 한다.
```yaml
management:
  endpoints:
    web:
      exposure:
        include: "*"
```
* 이는 액추에이터가 사용하는 설정이며, 애플리케이션을 재실행한 후 다시 `/actuator` 경로에 GET 요청을 전송할 경우 수많은 경로가 반환된다.
* **액추에이터가 제공하는 수많은 기능을 엔드포인트라는 용어로 지칭하며, 예를 들어 `beans`는 등록된 빈 목록을 반환**한다.
  * 이렇듯 액추에이터의 다양한 기능은 `/actuator/{엔드포인트명}` 형태의 경로를 통해 접근하는 것이 가능하다.

## 2025-06-10 Tue
### 액추에이터 엔드포인트 설정하기
```
> 액추에이터의 엔드포인트를 사용하기 위해서는 각 엔드포인트를 활성화하고, 노출하는 과정이 먼저 진행되어야 한다.
```
* 임의의 기능에 대한 엔드포인트를 활성화한다는 것은 해당 기능 자체의 사용 여부를 `on` 또는 `off`로 설정하는 것을 지칭한다.
* 반면, **엔드포인트를 노출하는 것은 상술한 과정에서 활성화된 엔드포인트를 HTTP 또는 JMX 중 어디에 노출할지 선택하는 것을 의미**한다.
  * 예를 들어 두 위치 중 하나에만 노출하거나, 두 위치에 모두 노출하는 식으로 노출 위치를 명시할 수 있다.
  * 물론, 임의의 엔드포인트에 대한 활성화 자체가 이루어지지 않았다면 노출 역시 되지 않는다.
* 그러나 액추에이터의 각 엔드포인트는 기본적으로 활성화되어 있으므로, 개발자는 설정을 통해 어떤 엔드포인트를 노출할지 결정해야 한다.
  * 일반적으로 JMX는 잘 사용되지 않으므로, HTTP에 어떤 엔드포인트를 노출할지 결정하게 된다.

## 2025-06-11 Wed
### 모든 엔드포인트를 HTTP에 노출하기
* 상술한 내용을 기반으로, 다음과 같은 설정은 활성화된 모든 엔드포인트를 HTTP로 노출한다는 것을 의미한다.
```yaml
management:
  endpoints:
    web: # HTTP로 노출한다.
      exposure:
        include: "*"
```
* 반면, `shutdown`이라는 엔드포인트는 기본적으로 활성화되어 있지 않기에 상술한 설정을 통해서도 노출되지 않는다.
  * 결국 **임의의 액추에이터 기능을 활용하기 위해서는 대응되는 엔드포인트가 활성화되고, 노출되도록 설정되어야 함**을 알 수 있다.

## 2025-06-12 Thu
### 새로운 엔드포인트를 활성화하고 노출하기
* 액추에이터가 제공하는 다양한 기능 중, `shutdown` 기능을 활성화하는 설정은 다음과 같이 작성할 수 있다.
  * 이렇듯 임의의 엔드포인트를 활성화하는 경우, `management.endpoint.[엔드포인트명].enabled`를 `true`로 설정해주어야 한다.
```yaml
management:
  endpoint:
    shutdown:
      enabled: true
  endpoints:
    web:
      exposure:
        include: "*"
```
* 해당 설정을 통해 `shutdown` 기능은 명시적으로 활성화되며, `management.endpoints.web.exposure.include`가 `*`로 설정되어 있기에 노출된다.
  * 해당 기능을 활용하고자 하는 경우, 서버의 동작을 변경하는 것이므로 노출된 `/actuator/shutdown` 엔드포인트를 `POST` 메소드 호출해주어야 한다.

## 2025-06-13 Fri
### 임의의 엔드포인트를 선택적으로 노출하기
* 활성화되어 있는 여러 엔드포인트를 모두 노출하는 대신 선택적인 기능만을 외부에 노출하고자 하는 경우, 설정을 다음과 같이 작성할 수 있다.
```yaml
management:
  endpoints:
    jmx:
      exposure:
        include: "health,info" # health와 info 엔드포인트만을 노출한다.
```
* 반면, 임의의 엔드포인트를 제외하고 모두 노출하고자 하는 경우의 설정은 다음과 같이 `exclude`를 사용한다.
```yaml
management:
  endpoints:
    web:
      exposure:
        include: "*"
        exclude: "env,beans" # env와 beans 엔드포인트를 제외한 모든 엔드포인트를 노출한다.
```

## 2025-06-14 Sat
### 액추에이터의 다양한 엔드포인트
* 여러 액추에이터 기능에 대응되는 엔드포인트를 외부로 노출하는 것으로, 개발자는 애플리케이션 내부의 많은 기능을 관리하거나 모니터링할 수 있다.
* 액추에이터가 제공하는 기능 중 자주 사용되는 것은 크게 다음과 같이 정리할 수 있다.
  1. `beans`: 스프링 컨테이너에 등록된 빈을 조회할 수 있다.
  2. `conditions`: `condition` 기능을 통해 빈을 등록하는 경우의 평가 조건에 부합하는지 여부를 조회할 수 있다.
  3. `configprops`: `@ConfigurationProperties`를 조회할 수 있다.
  4. `env`: `Environment`와 관련된 정보를 조회할 수 있다.
  5. `health`: 애플리케이션의 헬스 정보를 조회할 수 있다.
  6. `httpexchanges`: HTTP 호출에 대한 응답 정보를 조회할 수 있는 반면, `HttpExchangeRepository`를 구현하는 빈을 등록해주어야 한다.
  7. `info`: 애플리케이션의 정보를 조회할 수 있다.
  8. `loggers`: 애플리케이션에 설정된 로거 정보를 조회할 수 있으며, 이를 변경하는 것 역시 가능하다.
  9. `metrics`: 애플리케이션의 메트릭 정보를 조회할 수 있다.
  10. `mappings`: `@RequestMapping`에 의해 설정된 정보를 조회할 수 있다.
  11. `threaddump`: 애플리케이션의 쓰레드 덤프를 실행하여 이를 조회할 수 있다.
  12. `shutdown`: 애플리케이션을 종료하는 반면, 해당 기능은 기본적으로 비활성화된다.

## 2025-06-15 Sun
### 액추에이터를 활용한 헬스 정보 확인하기
```
> 액추에이터와 같은 도구를 활용하여 애플리케이션의 헬스 정보를 확인할 수 있다면 문제 발생시 이를 빠르게 인지할 수 있다.
``` 
* **헬스 정보는 단순히 애플리케이션이 요청에 응답할 수 있는지 여부를 떠나 DB의 응답과 디스크 사용량 등의 다양한 정보를 포함**한다.
* 이 때, 액추에이터의 경우 헬스 정보를 더욱 자세히 표현하기 위해서는 다음과 같은 설정을 명시할 필요가 있다.
```yaml
management:
  endpoint:
    health:
      show-details: always
```
* 특히, DB의 경우 JDBC 스펙에서 제공되는 기능을 활용하여 정상성을 확인할 수 있다.
  * 오래된 방식으로는 우선 더미 쿼리를 DB에 요청하고, 실제 응답이 반환된 경우 DB의 상태가 정상이라고 판단하는 것이 있다.
* 상술한 설정을 통해 연결된 DB와 서버의 디스크 사용량, Ping 정상성 여부를 종합하여 상태를 결정한다.
  * 이는 **세 상태를 모두 종합하는 최종 상태이므로, 셋 중 하나라도 DOWN 상태라면 전체 상태 역시 DOWN으로 노출**된다.

## 2025-06-16 Mon
### 간소화된 헬스 정보 확인하기
* 반면, 너무 상세한 정보를 노출하고 싶지 않은 경우 외부 설정 데이터를 다음과 같이 설정할 수 있다.
```yaml
management:
  endpoint:
    health:
      # show-details: always
      show-components: always
```
* 이 경우, 상세한 정보 없이 단순히 DB와 서버의 디스크 사용량 및 Ping 각각의 항목에 대한 UP 또는 DOWN만을 노출시킨다.

## 2025-06-17 Tue
### 액추에이터와 헬스 정보 - 참고
* **액추에이터의 경우 `db` 뿐만 아니라 `mongo`와 `redis` 등의 주요한 헬스 기능을 기본으로 제공**한다.
  * 단지 **액추에이터 의존성을 주입하는 것만으로도 각각의 헬스 기능이 자동으로 등록되어 사용자의 요청시 반환되는 정보에 포함**된다.
* 추가적으로, 개발자가 원하는 경우 필요한 헬스 기능은 직접 구현하여 등록한 후 활용하는 것 역시 가능하다.
* **실무의 경우, 항상 엔드포인트를 호출하여 JSON 데이터를 직접 확인하는 방식보다는 이를 별도의 서비스를 통해 주기적으로 모니터링하는 방식**을 택한다.
  * 이를 직접 구현하는 경우 적절한 대시보드의 도입을 고려하고, 문제가 발생한 경우 서버에 연결하여 트러블슈팅을 시도할 수 있다.
  * 반면, 이미 작성된 모니터링 시스템을 활용하는 경우 DOWN으로 전환되는 등의 문제 발생시 개발자가 알림을 받도록 설정하는 것 역시 가능하다.
  * 중요한 것은 **이를 통해 문제 발생시 트러블슈팅 시간이 크게 줄어든다는 것으로, 개발자는 더욱 더 빠르게 문제에 대처할 수 있게 된다**.

## 2025-06-18 Wed
### 액추에이터를 활용한 애플리케이션 정보 확인하기
* 액추에이터가 기본적으로 제공하는 `info` 엔드포인트를 활용할 경우, 다음과 같은 애플리케이션의 기본 정보를 확인하는 것이 가능하다.
  1. `java`: Java 런타임 정보를 확인할 수 있다.
  2. `os`: 운영체제 정보를 확인할 수 있다.
  3. `env`: `Environment` 클래스가 제공하는 정보 중 `info.` 접두사를 갖는 정보를 확인할 수 있다.
  4. `build`: 애플리케이션의 빌드 정보를 제공하며, 해당 기능은 `META-INF/build-info.properties` 파일이 작성되었음을 전제한다.
  5. `git`: 애플리케이션의 `git` 정보를 제공하며, 해당 기능 역시 `git.properties` 파일이 작성되었음을 전제한다.
* 이 때, **`info` 엔드포인트와 관련된 여러 기능 중 `env`와 `java` 및 `os`는 기본적으로 비활성화**된다.

## 2025-06-19 Thu
### java와 os 애플리케이션 정보 확인하기
* 액추에이터를 활용하여 Java 런타임 및 운영체제 정보를 확인하고자 하는 경우, 외부 설정 데이터 파일에 다음과 같은 내용을 작성해줄 필요가 있다.
  * 이 때, `management.info` 형태이며 `management.endpoint.info` 형태가 아님에 주의해야 한다.
```yaml
management:
  info:
    java:
      enabled: true
    os:
      enabled: true
```
* 해당 액추에이터 설정을 적용한 후, 애플리케이션을 시작하면 `/actuator/info` 경로를 통해 필요한 애플리케이션 정보를 확인하는 것이 가능하다.

## 2025-06-20 Fri
### env 애플리케이션 정보 확인하기
* 상술한 `env` 설정의 경우, 다음과 같은 외부 설정 데이터 파일을 작성하게 된다.
```yaml
management:
  info:
    env:
      enabled: true

info:
  app:
    name: my-awesome-application
    alias: maa
```
* 이 경우, **`/actuator/info` 엔드포인트를 호출할 경우 `info` 경로 하위에 작성한 `app.name`과 `app.alias`가 결과에 포함**된다.
  * 즉, `env`를 활용할 경우 애플리케이션에 자신만의 정보를 설정하고 이를 외부에서 확인하는 것이 가능하다.

## 2025-06-21 Sat
### build 애플리케이션 정보 확인하기
* `build` 애플리케이션 정보를 확인하기 위해서는 사전 준비해야할 파일이 있으나, 이는 그래들을 다음과 같이 활용하여 손쉽게 준비할 수 있다.
  * `build.gradle`과 같은 빌드 설정 파일에 아래와 같은 설정을 추가하고 애플리케이션을 빌드할 경우, 빌드 결과물에 필요한 파일이 모두 자동으로 포함된다.
```groovy
// ...생략
springBoot {
  buildInfo()
}
```
* 반면, **`build`의 경우 기본적으로 활성화된 기능이므로 상술한 파일이 빌드 결과물에 포함되어 있기만 하다면 이를 바로 확인**할 수 있다.
  * 같은 원리에서, `git` 애플리케이션 정보  역시 필요한 플러그인을 설치한다면 빌드 결과물에 자동 포함되는 파일을 통해 기능을 활용하는 것이 가능하다.

## 2025-06-22 Sun
### 액추에이터 로거 엔드포인트 활용하기
* `loggers` 엔드포인트를 통해 로깅과 관련된 정보를 확인하거나, 이를 실시간으로 변경하는 것이 가능하다.
* 반면, 액추에이터와 무관하게 스프링 부트 차원에서 임의의 패키지 및 하위 패키지들의 로깅 레벨을 수정하기 위해서는 다음과 같은 설정을 작성할 수 있다.
```yaml
logging:
  level:
    ga.injuk.controller: debug # 해당 패키지 및 하위 패키지 모두의 로깅 레벨을 debug로 적용한다!
```
* `/actuator/loggers` 엔드포인트로 확인할 경우, 상술한 설정에 의해 로깅 레벨이 설정된 패키지를 제외하고는 기본 설정이 적용되는 것을 확인할 수 있다.
  * 이 경우, `ROOT`의 `configuredLevel` 정보가 `INFO`로 설정된 것을 확인할 수 있으며 해당 정보가 기본 설정에 해당한다.
  * 즉, **로깅 레벨을 별도로 설정하지 않는다면 스프링 부트의 `ROOT` 설정에 의해 로깅 레벨은 기본으로 `INFO`가 적용**된다.
  * 반면 **상술한 설정을 작성할 경우, `ga.injuk.controller` 패키지 및 하위 패키지들은 예외적으로 `DEBUG` 로깅 레벨이 적용**된다.

## 2025-06-23 Mon
### 임의의 로거 정보 확인하기
* 상술한 설정에 의해 `ga.injuk.controller` 패키지의 로깅 레벨을 설정했으므로, 해당 로거의 이름을 기준으로 조회하는 것 역시 가능하다.
* 이 경우, `/actuator/loggers/{로거명}` 형태의 엔드포인트를 호출하며 로거명은 패키지명을 그대로 사용한다.
  * 즉, `ga.injuk.controller` 패키지의 로거 정보를 상세 조회하기 위해서는 `/actuator/loggers/ga.injuk.controller`를 호출한다.
* 해당 엔드포인트 경로를 호출할 경우, 일반적으로 아래와 같은 형태의 응답이 반환된다.
```json
{
  "configuredLevel": "DEBUG",
  "effectiveLevel": "DEBUG"
}
```
* 덧붙여, **`configuredLevel`은 개발자에 의한 명시적 설정 적용시에만 노출되는 정보이며 임의의 패키지에 실제로 적용되는 로깅 레벨**을 의미한다.
  * 그러나 **`effectiveLevel`은 `configuredLevel`이 설정되지 않은 경우에 해당 로거의 부모의 로깅 레벨**을 적용하는 값으로 이해할 수 있다.
  * 반면, `configuredLevel`이 설정된 경우 `effectiveLevel`에는 `configuredLevel`과 동일한 로깅 레벨이 적용된다.

## 2025-06-24 Tue
### 실시간 로깅 레벨 변경하기
* 일반적으로, 개발 서버는 `DEBUG` 로깅 레벨을 사용하지만 요청이 많은 운영 환경에서는 성능 및 디스크 영향을 줄이기 위해 `INFO` 로깅 레벨을 활용한다.
* 반면, 운영 서버에 긴급한 문제가 발생하여 급히 `DEBUG` 또는 `TRACE` 따위의 로깅 레벨을 적용하고자 하는 경우가 발생할 수 있다.
  * 일반적으로는 로깅 레벨과 같은 설정 정보를 변경한 후, 서버를 재시작하는 방법을 생각해볼 수 있다.
* **액추에이터가 제공하는 `loggers` 엔드포인트를 활용할 경우, 애플리케이션을 재시작하지 않고서도 로깅 레벨을 변경**할 수 있다.
* 이는 서버의 상태를 변경하는 것이므로 요청시 반드시 `POST` 메소드를 사용해야 하며, 요청 본문을 다음과 같이 작성해야 한다.
```json
{
  "configuredLevel": "DEBUG"
}
```
* 이러한 로깅 레벨 변경 시도는 외부 설정 파일과 같은 물리 파일에 영향을 주지 않으므로, 서버를 재시작할 경우 다시 기본적인 로깅 레벨이 적용된다.

## 2025-06-25 Wed
### HTTP 요청 및 응답 기록 확인하기
* 과거 있었던 HTTP 요청 및 응답 기록을 확인하고자 하는 경우 `httpexchanges` 엔드포인트를 사용해야 한다.
  * 반면, 해당 엔드포인트를 원하는대로 사용하기 위해서는 `HttpExchangeRepository` 인터페이스의 구현체를 빈으로 등록해야 한다.
  * 바꿔 말해, **해당 인터페이스의 구현체를 빈으로 등록하지 않았다면 `httpexchanges` 엔드포인트는 활성화되지 않는다**.
  * 스프링 부트의 경우, 기본적으로 `InMemoryHttpExchangeRepository` 구현체를 제공하므로 이를 개발자가 직접 빈으로 등록하여 활용할 수 있다.
* `InMemoryHttpExchangeRepository`는 기본적인 `capacity`를 100으로 지원하며, 이를 넘는 과거 요청 기록은 삭제된다.
  * 만약 `capacity` 값을 달리 적용하고자 하는 경우에는 해당 클래스가 제공하는 `setCapacity()` 메소드를 활용해볼 수 있다.
* 그러나 **해당 기능은 단순하고 제한적인 기능만을 제공하므로, 운영 환경에서는 별도의 모니터링 도구의 도입을 고려하는 것이 바람직**하다.
  * 대표적으로 네이버에서 오픈 소스로 관리하는 `Pinpoint`나 `Zipkin` 등의 기술이 있다.

## 2025-06-26 Thu
### 액추에이터와 보안
* 액추에이터가 제공하는 기능들은 애플리케이션 자체적인 정보를 외부로 노출하며, 심지어는 서버의 상태를 변경할 수도 있으므로 충분한 주의를 기울여야 한다.
* 때문에 **외부적으로 공개된 환경에서 액추에이터 엔드포인트를 노출하는 것은 좋지 않으며, 이는 내부망에만 노출하는 것이 바람직**하다.
  * 예를 들어 외부 망에는 8080 포트만 공개한 경우, 해당 포트를 통해 서비스 기능을 노출하되 내부망에만 노출되는 별도의 포트에 액추에이터를 노출할 수 있다.
* 다음과 같이 **외부 설정 파일에 `management.server.port=30728` 형태로 작성할 경우, 액추에이터 기능을 별도의 포트에 노출**할 수 있다.
```yaml
management:
  server:
    port: 30728 # 이제 애플리케이션 서버와는 다른 포트에 엔드포인트 기능을 노출하게 된다.
```
* 그러나 외부적인 요인으로 인해 포트를 분리할 수 없는 경우에는 `/actuator` 경로에 서블릿 필터나 스프링 인터셉터, 스프링 시큐리티를 적용할 수 있다.
  * 이는 **결국 인증된 사용자만 접근 가능하도록 추가적인 개발을 진행하는 것을 의미**한다.

## 2025-06-27 Fri
### 액추에이터의 경로를 변겅하기
* `/actuator`와 같은 경로는 이미 너무 잘 알려진 경로에 해당하므로, 이를 변경하기 위해서는 다음과 같은 설정을 작성해줄 필요가 있다.
```yaml
management:
  endpoints:
    web: 
      base-path: "/my-actuator"
```
* 상술한 바와 같이 작성할 경우 `/actuator/{기능}`이 아닌 `/my-actuator/{기능}`과 같은 사용자 정의 엔드포인트를 사용할 수 있게 된다.

## 2025-06-28 Sat
### 모니터링의 중요성
* 앞서 다루었듯, **서비스를 운영하는 개발자 입장에서 장애는 언제든지 발생할 수 있다는 점을 인정하고 이에 대비하여 모니터링을 철저히하는 것이 바람직**하다.
  * 이 경우, 애플리케이션이 동작하는 서버의 CPU와 메모리 및 커넥션과 고객 요청 수 등의 수 많은 지표를 확인하는 것이 중요하다.
  * 이를 토대로 어디에 문제가 발생하는지 빠르게 찾아낼 수 있으며, 원인을 파악하여 대처하는 것이 가능하다.
* 이러한 모니터링을 돕기 위한 수 많은 도구가 있으며, 대부분의 경우 시스템의 정보를 이러한 모니터링 도구에 전달하는 방식으로 활용하게 된다.
  * 바꿔말해, 이러한 모니터링 도구를 활용하기 위해서는 그들이 원하는 형태의 지표 데이터를 전달해줄 필요가 있다.
  * 다행히도, 대부분의 경우 이러한 데이터 매핑 과정은 라이브러리에 의해 자동화되곤 한다.

## 2025-06-29 Sun
### 마이크로미터란?
* 상술한 바와 같이, 세상의 수많은 모니터링 도구들은 모니터링 기능을 위해 저마다 서로 다른 데이터 형태를 요구한다.
* 때문에 모니터링 도구 A를 사용할 경우 A가 요구하는 데이터 매핑을 처리하게 되지만, 이를 도구 B로 변경할 경우 많은 범위의 코드 수정이 필요할 수 있다.
  * 즉, 개발자 입장에서는 단순한 도구 변경에 지나지 않아야 할 변경 사항이 운영 코드에 영향을 미칠 가능성을 무시할 수 없게 된다.
* **마이크로미터는 이러한 문제를 해결하기 위한 라이브러리이며, 표준 측정 방식을 추상화된 계층을 통해 제공한다 점에서 큰 의의**를 갖는다.
* 모니터링에 필요한 여러 메트릭 정보는 마이크로미터가 제공하는 표준 측정 방식에 맞추어 전달되며, 개발자는 자신의 모니터링 도구에 맞는 구현체를 사용하게 된다.
  * 물론, **유명한 모니터링 도구들의 경우 각 모니터링 도구에 맞는 구현체가 이미 개발되어 있으므로 개발자는 그저 이를 가져다 사용하기만** 할 수 있다.

## 2025-06-30 Mon
### 마이크로미터의 특징
```
> 개발자는 마이크로미터가 정한 표준에 맞는 메트릭을 전달하는 것만으로도 유명한 모니터링 도구들을 편리하게 사용할 수 있다.
```
* 마이크로미터는 애플리케이션 메트릭 파사드라는 용어로도 지칭되며, 애플리케이션의 메트릭 정보를 마이크로미터가 정한 표준 방식으로 모아 제공한다.
  * 다시 말해, 마이크로미터는 추상화 계층을 도입하여 모니터링 구현체를 쉽게 변경할 수 있도록 다형성을 제공한다.
  * 이는 마치 `SLF4J`가 로그 계층을 추상화하는 것과 유사하다.
* 스프링 진영의 경우, 많은 상황에서 스프링이 직접 추상화를 진행하지만 마이크로미터는 이미 잘 만들어진 라이브러리이기에 스프링은 이를 활용한다.
  * 앞서 다루었던 스프링 부트의 액추에이터 역시 이러한 마이크로미터를 기본으로 내장하여 필요한 기능들을 제공한다.

## 2025-07-01 Tue
### 액추에이터와 metrics 엔드포인트
* CPU 사용량이나 JVM 정보, 커넥션 정보 등의 지표를 수집하기 위해서는 개발자가 이를 각각 수집하고 마이크로미터에 등록해야할 것처럼 보인다.
  * 그러나 마이크로미터는 다양한 지표 수집 기능을 이미 제공하며, 액추에이터는 이러한 지표 수집 기능을 `@AutoConfiguration`을 통해 자동으로 등록한다.
  * 다시 말해, 액추에이터만 사용하더라도 수 많은 지표 정보를 손쉽게 사용하는 것이 가능하다.
* 스프링 부트 액추에이터는 기본으로 제공되는 지표를 확인할 수 있도록 `metrics` 엔드포인트를 제공하며, 이를 조회할 경우 다음과 같은 정보를 확인할 수 있다.
  1. `system.cpu.count`
  2. `system.cpu.usage`
  3. `jvm.memory.max`
  4. `jvm.memory.used`
  5. `hikaricp.connections.active`
  6. `hikaricp.connections.idle`
  7. `disk.free`
  8. `disk.total`
* 이는 기본적으로 제공되는 다양한 지표 중 일부에 불과하며, 이렇듯 **아무런 설정 없이도 마이크로미터는 수 많은 지표 정보를 기본적으로 수집**한다.

## 2025-07-02 Wed
### metrics 엔드포인트를 활용한 지표 정보 조회
* 마이크로미터에 의해 수집된 지표 정보는 `/actuator/metrics/[지표명]` 형태의 엔드포인트를 조회하는 것으로 확인할 수 있다.
  * 상술한 지표 이름 목록을 예로 들었을 때, JVM 메모리 사용량은 `/actuator/metrics/jvm.memory.used` 형태의 엔드포인트로 조회할 수 있다.
```json
{
  "name": "jvm.memory.used",
  "description": "The amount of used memory",
  "baseUnit": "bytes",
  "measurements": [
    {
      "statistic": "VALUE",
      "value": 42
    }
  ],
  "availableTags": [
    {
      "tag": "area",
      "values": [
        "heap",
        "noheap"
      ]
    },
    {
      "tag": "id",
      "values": [
        "G1 Survivor Space",
        "Compressed Class Space",
        "Metaspace",
        "CodeCache",
        "G1 Old Gen",
        "G1 Eden Space"
      ]
    }
  ]
}
```

## 2025-07-03 Thu
### metrics 엔드포인트와 태그 필터
* 마이크로미터가 기본으로 수집하는 여러 지표는 해당 지표에 대해 보다 세부적인 정보를 제공할 수 있도록 태그 필터를 제공한다.
  * 이 경우, 임의의 지표 정보에 적용 가능한 태그 필터 목록은 `availableTags` 프로퍼티에 표현된다.
* 반환 데이터 중 **`availableTags`의 `tag`는 임의의 지표 정보를 필터하기 위한 조건으로, `tag=[키]:[값]` 형태의 쿼리 파라미터로 사용**할 수 있다.
  * 예를 들어 `/actuator/metrics?tag=area:heap`를 입력한 경우, 전체 메모리 사용량 중 힙 메모리 사용량만을 반환한다.
* 반면, **필터를 여러 개 적용하고자 하는 경우 `?tag=[키]:[값]&tag=[키]:[값]`과 같이 `tag` 쿼리 파라미터를 여러번 명시**할 수 있다.

## 2025-07-04 Fri
### 마이크로미터와 액추에이터의 다양한 지표
* 마이크로미터와 액추에이터는 기본적으로 다음과 같은 다양한 지표 정보를 제공한다.
  1. JVM 메트릭
  2. 시스템 메트릭
  3. 애플리케이션 시작 메트릭
  4. 스프링 MVC 메트릭
  5. 톰캣 메트릭
  6. 데이터 소스 메트릭
  7. 로그 메트릭
* 뿐만 아니라, **개발자가 원한다면 자신만의 사용자 정의 지표 정보를 추가적으로 정의하는 것 역시 가능**하다.

## 2025-07-05 Sat
### JVM 메트릭이란?
* JVM 메트릭은 `jvm` 접두사를 가지며, 다음과 같은 다양한 지표 정보를 제공한다.
  1. 메모리 및 버퍼 풀의 세부 정보
  2. 쓰레기 수집 관련 통계 정보
  3. 스레드 활용과 관련된 정보
  4. 로드 및 언로드 된 클래스 수
  5. JVM의 버전 정보
  6. JIT 컴파일 시간과 관련된 정보
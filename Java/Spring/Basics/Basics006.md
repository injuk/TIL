# Basics
## 2022-06-15 Wed

### H2란?
* 앞서 다룬 메모리 리포지토리의 경우, 메모리에 데이터를 저장하므로 애플리케이션을 재실행할 때마다 모든 데이터가 지워진다.
  * 그러나 비즈니스 로직에 필요한 도메인 객체는 영속화될 필요가 있으므로, 백엔드 서버에는 데이터베이스가 필수적이다.
* H2 연결시 설정은 다음과 같이 입력한다.
  1. Saved Settings: Generic H2 (Embedded)
  2. Driver Class: org.h2.Driver
  3. JDBC URL: `jdbc:h2:tcp://localhost/~/test`
     * 해당 설정을 통해 파일에 직접 접근하는 것이 아닌 소켓 연결이 가능해진다.
  4. 연결 후 다음과 같은 테이블을 생성한다.
```
create table member
(
  id bigint generated by default as identity,
  name varchar(255),
  primary key (id)
);
```
* `id bigint generated by default as identity`의 경우, 값을 설정하지 않고 INSERT한 경우 데이터베이스가 값을 스스로 채워준다.
  * `insert into member(name) values ('ingnoh');` 등의 쿼리를 통해 H2 데이터베이스에 값을 삽입할 수 있다.
  * 삽입된 정보는 `select * from member;` 등의 쿼리를 통해 확인할 수 있다.
* **실무에서는 상술한 내용과 같은 DDL의 경우 별도의 `.sql` 확장자 파일에 저장하여 버전 관리 시스템을 통해 관리하는 것이 이상적**이다. 

### pure JDBC
* **Java의 경우, 데이터베이스와의 상호작용을 위해 기본적으로 반드시 JDBC를 사용**해야 한다.
  * 아래의 코드는 JDBC를 활용하여 H2 데이터베이스와 상호작용하기 위해 build.gradle에 명시해야 할 의존성 목록이다.
  * 특히, **데이터베이스에 연결하기 위해 데이터베이스가 제공하는 클라이언트가 필요하며 이는 `com.h2database:h2` 의존성에 포함**된다.
```
dependencies {
	// for JDBC
	implementation 'org.springframework.boot:spring-boot-starter-jdbc'
	runtimeOnly 'com.h2database:h2'
}
```
* 또한, **데이터베이스에 연결하기 위해 필요한 접속정보는 `resources/application.proerties`에 쉽게 작성**할 수 있다.

### 설정 파일을 통한 DataSource 관리
* @Configuration 어노테이션이 명시된 클래스에 아래와 같이 작성하는 것으로 리포지토리 구현체를 손쉽게 교체할 수 있다.
* 특히, DataSource 역시 스프링이 관리하는 의존성 주입 대상이 될 수 있다.
  * 이 때, **스프링은 `application-properties`에 명시된 연결 정보를 토대로 해당 객체를 자동으로 빈으로 등록하여 주입**한다.
```
@Configuration
public class SpringConfig {

    private DataSource dataSource;

    public SpringConfig(DataSource dataSource) {
        this.dataSource = dataSource;
        System.out.println(dataSource);
    }

    @Bean
    public MemberService memberService() {
        return new MemberService(
                memberRepository()
        );
    }

    @Bean
    public MemberRepository memberRepository() {

        return new JdbcMemberRepository(dataSource);
//        return new MemoryMemberRepository();
    }
}
```
* **이러한 방식을 적용할 경우 다른 코드를 수정할 필요가 전혀 없으며, 신규 추가된 클래스를 사용하도록 설정 파일만을 수정**하면 된다.
  * 이는 **객체 지향적인 설계를 손쉽게 도입할 수 있는 스프링의 주요한 장점**이기도 하다.
  * 스프링을 사용하지 않는 pure Java 코드의 경우, 의존성이 수정되는 경우 연관된 모든 부분을 반드시 수정해야 한다.
  * 이는 **개방 폐쇄 원칙을 준수하기 쉽도록 하며, 애플리케이션을 조립하는 코드 외의 비즈니스 로직을 수정할 필요가 없게 만들어준다**.
  * 즉, **별도의 동작 코드를 전혀 수정하지 않고 오로지 애플리케이션을 조립하기 위해 사용하는 설정 파일을 수정하는 것만으로도 실제 동작을 수정**할 수 있다.

## 2022-06-16 Thu
### 통합 테스트 작성하기
* **순수 Java 코드로 작성하는 인메모리 데이터베이스의 경우는 상관이 없지만, 실제 데이터베이스를 사용하는 구현체가 추가된 경우 통합 테스트를 작성**한다.
* 또한, **통합 테스트의 경우 최대한 실제와 유사한 환경에서 테스트를 진행할 수 있어야하므로 스프링 역시 동작**시켜야 한다. 
  * 이러한 통합 테스트에는 @SpringBootTest와 @Transactional 어노테이션을 명시하여 상술한 결과를 얻을 수 있다.
  * 이 경우, **데이터베이스를 활용하는 통합 테스트는 일반적으로 테스트용 데이터베이스를 별도로 구성**한다.
* 통합 테스트와 단위 테스트를 포함한 모든 테스트 코드의 경우 가장 좋은 의존성 주입 방법인 생성자 방식보다 더 편한 방식을 채택해도 무방하다.
  * **예를 들어 @Autowired 어노테이션을 명시하는 방식이 있으며, 이는 테스트 코드가 실제 운영 환경에 배포되지 않기 때문에 편의성을 추구하는 것**이다.

### 데이터베이스와 트랜잭션
* 데이터베이스는 기본적으로 트랜잭션 개념을 갖고, 때문에 쿼리 요청 후 커밋을 진행해야만 한다.
  * 커밋은 자동으로 수행되느냐 마느냐의 차이일 뿐, 반드시 실행된다고 이해할 수 있다.
  * **데이터베이스는 트랜잭션 개념으로 인해 쿼리를 요청한 후 커밋을 수행하지 않은 경우에는 쿼리 결과를 실제 데이터에 반영하지 않는다**.
* 이를 통합 테스트 코드에 도입하는 경우, 다음과 같은 흐름으로 트랜잭션을 응용할 수 있다.
  1. 트랜잭션을 열고 INSERT 쿼리를 요청한다.
  2. SELECT 쿼리를 요청하여 1.에서 삽입한 데이터를 확인하는 방식으로 테스트 결과를 검증한다.
  3. 쿼리 결과에 대해 커밋하지 않고, 롤백을 수행한 후 트랜잭션을 닫는다.

### @Transactional과 @SpringBootTest 어노테이션
* **모든 테스트 코드는 기본적으로 반복 가능해야 한다**.
  * 로컬에 구성된 실제 데이터베이스를 활용하는 통합 테스트의 경우 @AfterEach 등을 통해 DELETE 쿼리를 수행할 수도 있으나, 이는 매우 번거로운 방식이다.
  * 이 경우, 스프링은 데이터베이스의 트랜잭션을 활용하기 위한 @Transactional 어노테이션을 제공하므로 이를 테스트에 활용할 수 있다.
* **트랜잭션은 테스트를 수행하더라도 결과를 실제 데이터에 반영하지 않도록 하며, 정확히 이러한 경우에 @Transactional 어노테이션을 활용**할 수 있다.
* **@Transactional 어노테이션을 테스트 케이스에 명시하는 경우, 테스트를 실행하는 과정에서 우선 트랜잭션을 열고 테스트가 종료된 후 롤백을 수행**한다.
  * 즉, **데이터베이스에 쿼리 결과가 반영되지 않으므로 테스트를 몇 번이고 반복하여 실행할 수 있다**.
  * 해당 어노테이션은 테스트 케이스를 감싸는 클래스에 명시하며, 이를 통해 모든 테스트 케이스마다 트랜잭션을 활용하도록 할 수 있다.
* **@Transactional 어노테이션은 일반적인 Java 코드와 테스트 케이스에서의 동작이 다르다**.
  1. 일반적인 Java 코드 상에 명시된 경우, 트랜잭션을 활용하며 롤백 없이 정상적으로 커밋을 요청한다.
  2. 테스트 케이스에 명시된 경우, 쿼리를 모두 실행한 후 반드시 롤백하도록 동작한다.
* **테스트 케이스에 @SpringBootTest 어노테이션을 명시한 경우, 스프링 컨테이너와 테스트는 함께 실행**된다.
  * 결과적으로 실제 스프링 컨테이너를 실행한 후 테스트를 진행하므로, 실제 환경과 유사한 테스트가 가능해진다.
* 아래는 두 어노테이션을 적용한 클래스의 예시이다.
```
// 통합 테스트에 필요한 두 어노테이션을 명시한다.
@SpringBootTest
@Transactional
public class MemberServiceIntegrationTest {
    // 생성자를 활용한 의존성 주입 대신 더 쉬운 방식을 택하였다.
    @Autowired MemberService service;
    @Autowired MemberRepository repository;

    @Test
    void 가입() {
        Member member = new Member();
        member.setName("ingnoh_test");
        // 아래 메소드를 실행하더라도, @Transactional 어노테이션에 의해 실제 데이터베이스에는 커밋되지 않는다.
        Long memberId = service.join(member);

        Member findMember = service.findMember(memberId).get();
        assertThat(member.getName()).isEqualTo(findMember.getName());
    }
}
```

### @SpringBootTest 어노테이션의 한계?
* 테스트 케이스는 그 성격에 따라 크게 다음과 같이 분류할 수 있다.
  1. 단위 테스트: 순수한 Java 코드만을 사용하며, 최소한의 단위를 테스트한다. 
  2. 통합 테스트: 스프링 컨테이너와 실제 데이터베이스를 모두 활용하여 테스트를 진행한다.
* **@SpringBootTest 어노테이션을 명시하지 않는 단위 테스트의 경우, 테스트 코드의 역할은 그대로 수행하면서도 실행 시간이 매우 짧다**.
  * 반면, 해당 어노테이션을 명시하는 테스트 케이스는 통합 테스트이므로, 실제 테스트 코드의 양이 많아질수록 테스트에 필요한 시간은 늘어난다.
* **기본적으로 순수한 단위 테스트가 통합 테스트보다 좋은 테스트 케이스일 확률이 높다**.
* **애플리케이션은 언제나 각 단위로 쪼개어 효율적으로 테스트를 진행할 수 있는 상태를 지향해야하며, 통합 테스트 없이도 많은 것을 테스트할 수 있어야 한다**.
  * 예를 들어 **반드시 스프링 컨테이너와 데이터베이스가 필요한 테스트 케이스의 경우, 근본적인 테스트 설계가 잘못되었을 가능성**이 크다.
  * 언제나 단위 테스트가 통합 테스트보다 좋다고 단언할 수 없으나, 그러할 확률이 높다.
* **실무에서는 언젠가 통합 테스트를 작성해야하는 상황이 발생하기 마련이지만, 중요한 것은 좋은 단위 테스트를 작성할 수 있는 능력을 기르는 것**이다.

### @Autowired 어노테이션의 생략
* **빈으로 등록되는 클래스의 생성자가 하나만 존재하는 경우, 생성자 주입 방식에서 @Autowired 어노테이션을 생략할 수 있다**.
  * 당연히 생성자가 둘 이상 존재하는 클래스는 반드시 @Autowired 어노테이션을 명시해주어야 한다.

### JDBC Template
* **스프링의 JDBC 템플릿은 MyBatis와 유사한 라이브러리이며, 순수 JDBC 코드에서 필요한 반복적인 코드를 대부분 제거**해준다.
  * 그러나 SQL 쿼리 자체는 직접 작성해야만 한다.
  * **JDBC 템플릿은 실무에서도 자주 사용되는 라이브러리**이다.
* JDBC 템플릿을 사용하는 리포지토리는 다음과 같이 작성하며, 이 때 `JdbcTemplate` 객체를 반드시 멤버로 갖도록 해야한다.
  * **그러나 `JdbcTemplate` 객체는 자동으로 의존성 주입을 받을 수 없으므로, `DataSource`를 활용하여 생성**해야 한다.
```
public class JdbcTemplateMemberRepository implements MemberRepository {
    
    private final JdbcTemplate jdbcTemplate;

    // 생성자를 통해 DataSource 객체를 전달받는다.
    public JdbcTemplateMemberRepository(DataSource dataSource) {
        // 전달받은 DataSource 객체를 활용하여 JdbcTemplate 객체를 생성한다.
        jdbcTemplate = new JdbcTemplate(dataSource);
    }
}
```
* **JDBC 템플릿은 매우 복잡한 순수 JDBC 코드에 템플릿 메소드 패턴 등을 적용하여 압축한 라이브러리**이다.
  * 예를 들어, 조회 쿼리는 다음과 같이 간단하게 작성할 수 있다.
  * **조회 쿼리의 경우, 결과는 RowMapper 클래스를 통해 적절한 타입으로 매핑되어 반환되므로 RowMapper의 사용이 필수적**이다.
```
public class JdbcTemplateMemberRepository implements MemberRepository {

    private final JdbcTemplate jdbcTemplate;

    public JdbcTemplateMemberRepository(DataSource dataSource) {
        jdbcTemplate = new JdbcTemplate(dataSource);
    }

    // 기타 메소드 생략

    @Override
    public Optional<Member> findById(Long id) {
         List<Member> result = jdbcTemplate.query("select * from member where id = ?", memberRowMapper(), id);
         return result.stream().findAny();
    }
    
    private RowMapper<Member> memberRowMapper() {
        return (rs, rowNum) -> {
            Member member = new Member();
            member.setId(rs.getLong("id"));
            member.setName(rs.getString("name"));
            
            return member;
        };
    }
}
```

### JDBC 템플릿을 활용한 삽입
* JDBC 템플릿을 활용하는 생성 메소드는 다음과 같이 작성할 수 있다.
```
@Override
public Member save(Member member) {
    SimpleJdbcInsert jdbcInsert = new SimpleJdbcInsert(jdbcTemplate);
    jdbcInsert.withTableName("member").usingGeneratedKeyColumns("id");

    Map<String, Object> parameters = new HashMap<>();
    parameters.put("name", member.getName());
    
    Number key = jdbcInsert.executeAndReturnKey(new MapSqlParameterSource(parameters));
    member.setId(key.longValue());
    
    return member;
}
```
* **`SimpleJdbcInsert`를 적절히 활용할 경우, 메소드 내부에 쿼리를 직접 작성할 필요가 없다**.
* `SimpleJdbcInsert` 객체의 `executeAndReturnKey` 메소드를 활용할 경우, 자동 생성된 데이터베이스 키를 반환받아 사용할 수 있다.

### 통합 테스트 진행하기
* 이렇게 새로운 리포지토리를 작성한 경우, 기존에 작성해둔 통합 테스트를 돌리는 것으로 동작을 쉽게 검증할 수 있다.
  * 기존 통합 테스트를 재활용하므로 실제로 스프링을 띄울 필요조차 없으며, 접근 가능한 데이터베이스만 있으면 테스트가 가능하다.
  * 테스트를 통해 오류를 미연에 방지하고, 애플리케이션을 더욱 견고하게 만들 수 있게 된다.
* **개발자의 작업 중 많은 부분이 사소한 이유로 인해 실패하므로, 사전에 잘 작성해둔 테스트 코드는 실무에서 특히 그 위력을 발휘**한다.
  * **더 좋은 테스트를 작성하고자 항상 노력해야하며, 테스트 코드 역시 운영 코드와 마찬가지로 양질의 퀄리티를 보장할 수 있도록 유지보수해**나가야 한다.
  * **이상적으로는 실제 운영 코드 작성에 비해 테스트 코드에 들이는 시간의 비중이 6할**을 넘어야한다.
  * B2C의 경우, 작은 버그 하나가 수 억 대의 손실로 돌아오므로 서비스의 규모가 커질수록 테스트 코드의 작성을 아까워하지 말아야 한다.
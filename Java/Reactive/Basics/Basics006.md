# Reactive
## 2023-11-26 Sun
### Sinks란?
```
> Sinks는 리액티브 스트림즈의 Signal을 프로그래밍적인 방식으로, 명시적으로 전송할 수 있도록 지원하는 요소에 해당한다. 
```
* 리액티브 스트림즈의 구성 요소 중 하나인 `Processor`는 `Publisher`와 `Subscriber`의 모든 특징을 갖는다.
* 그러나 최근 Reactor에서는 `Processor`의 기능을 개선한 `Sinks`가 지원되고 있으며, `Processor`와 관련된 API는 제거된다.
* 앞서 다룬 내용은 모두 Flux나 Mono가 `onNext() Signal` 등을 내부적으로 전송하는 방식에 해당한다.
  * 반면, **`Sinks`를 활용하는 것으로 `Signal`은 명시적으로 전송**될 수 있다.

## 2023-11-27 Mon
### Sinks와 Operator 방식의 비교
```
> Sinks는 프로그래밍적인 방식으로 Signal을 전송하면서도 멀티스레드 기반 환경에서 스레드 안전성을 보장받을 수 있도록 지원한다.
```
* Reactor에서 프로그래밍 방식으로 `Signal`을 전송하는 가장 일반적인 방식은 크게 다음과 같다.
  1. `generate() Operator`
  2. `create() Operator`
* 이 때, 상술한 **두 `Operator`는 싱글스레드 기반 환경에서 `Signal`을 전송하기 위해 사용되던 전통적인 방식에 해당**한다.
* 반면, **`Sinks`는 멀티스레드 방식으로 `Signal`을 전송하면서도 그 과정에서 스레드 안전성이 보장되도록 지원**한다.
  * 즉, `Sinks`는 상술한 두 `Operator`를 완전히 대체하려는 개념은 아니다.
* 또한 **`Sinks`는 공유 자원에 대한 동시 접근을 감지하고, 접근하려는 스레드 중 하나가 빠르게 실패할 수 있도록하는 것으로 스레드 안전성을 보장**한다.

## 2023-11-28 Tue
### Sinks의 종류
* Reactor에서 `Sinks`를 활용하여 `Signal`을 전송하는 방식은 크게 다음과 같이 구분할 수 있다.
  1. `Sinks.One`: `Sinks.one()` 메소드를 활용하여 한 건의 데이터를 전송하는 방법을 정의하는 기능 명세에 해당한다.
  2. `Sinks.Many`: `Sinks.many()` 메소드를 활용하여 여러 건의 데이터를 여러 방법으로 전송하는 기능을 정의한 기능 명세에 해당한다.

## 2023-11-29 Wed
### Sinks.One이란?
```
> Sinks.One은 Mono 방식으로 Subscriber가 데이터를 소비하도록 지원하는, Sinks 클래스 내부에 인터페이스로 정의된 Sinks의 사양으로 이해할 수 있다. 
```
* `Sinks.One`은 하나의 데이터를 프로그래밍적인 방식으로 `Emit`하는 역할 또는 상술한 스펙 역할을 수행한다.
  * 즉, **`Sinks.one()` 메소드를 호출하여 하나의 데이터를 `Emit`하기 위한 기능 명세를 반환**받을 수 있다.
* **`Sinks.One` 사양을 활용할 경우, 아무리 많은 수의 데이터를 `Emit`한다 해도 처음 이외의 데이터들은 모두 버려진다**.
  * 때문에 버려지는 데이터를 처리하기 위한 `FAIL_FAST` 등의 `EmitFailureHandler` 구현체를 활용할 수 있다.
  * 예를 들어, `FAIL_FAST`는 에러가 발생한 경우 재시도하지 않은 대신 즉시 실패 처리하여 빠르게 실패할 수 있도록 동작한다.
  * 이러한 빠른 실패 처리는 교착 상태 등을 미연에 방지하며, 결과적으로는 스레드 안전성을 보장하는 수단이 된다.

## 2023-11-30 Thu
### Sinks.Many란?
* **`Sinks.Many`는 `Sinks.Many`가 아닌 `ManySpec` 인터페이스를 반환**한다.
  * `Sinks.One`의 경우 단순히 하나의 데이터만을 `Emit`하므로 별도의 사양을 정의하는 대신 디폴트 스펙을 활용한다.
  * 반면, `Sinks.Many`의 경우 데이터를 `Emit`할 수 있도록 여러 기능을 정의하는 `ManySpec`을 반환한다.
* `Sinks.Many`에 의해 반환되는 `ManySpec`은 크게 다음과 같은 세 가지 기능을 별도의 스펙으로 정의한다.
  1. `UnicastSpec`: **단 하나의 `Subscriber`에게만 데이터를 `Emit`하는 경우에 사용**할 수 있다.
  2. `MulticastSpec`: **하나 이상의 `Subscriber`에게 데이터를 `Emit`하고자 하는 경우에 사용**할 수 있다.
  3. `MulticastReplaySpec`: **하나 이상의 `Subscriber`에게 데이터를 `Emit`하며, 이미 `Emit`된 데이터를 다시 `Emit`할 수 있게 지원**한다.
* 이 때, 상술한 **각자의 스펙은 모두 스펙 유형의 인스턴스를 반환하고 최종적으로 스펙에 정의된 기능을 사용**한다.
  * 예를 들어, `Sinks.many().unicast()`를 호출할 경우 `UnicastSpec` 인스턴스가 반환된다.

## 2023-12-01 Fri
### MulticastSpec과 MulticastReplaySpec의 특징
* 또한, **`Sinks`는 `Publisher` 역할을 수행하는 경우 기본적으로 `Hot Publisher`와 같이 동작**한다.
  * 때문에 `MulticastSpec`을 활용하더라도 구독 시점 이전에 이미 `Emit`된 데이터는 전달받을 수 없다.
  * 대신, `MulticastReplaySpec`이 지원하는 `limit()` 또는 `all()` 등의 메소드를 활용하여 이미 `Emit`된 데이터를 다시 전달받을 수 있다.
  * 이렇듯 **`MulticastReplaySpec`은 이미 `Emit`된 데이터 중 임의의 시점으로 되돌린 시점의 데이터부터 `Emit`하는 역할을 수행**한다.

## 2023-12-02 Sat
### Sinks - 결론
* `Sinks`는 `Publisher`와 `Subscriber`의 기능을 모두 갖는, 일종의 향상된 `Processor`와 같은 기능을 제공한다.
* `Sinks`가 데이터를 `Emit`하는 사양을 정의한 것은 크게 `Sinks.One`과 `ManySpec`로 구분할 수 있다.
* `Sinks.Many`의 `MulticastReplaySpec`은 이미 `Emit`된 데이터 중 임의의 시점으로 되돌린 시점의 데이터부터 `Emit`하는 역할을 수행한다.
  * 반면, `MulticastSpec`은 단지 하나 이상의 `Subscriber`에게 데이터를 `Emit`하는 역할을 수행한다.

## 2023-12-03 Sun
### 스레드의 두 분류
* 컴퓨터 시스템에서 사용되는 스레드라는 용어는 크게 다음과 같은 두 분류로 구분될 수 있다.
  1. 물리적인 스레드
  2. 논리적인 스레드
* 반면, CPU의 코어는 명령어를 처리하는 개별 유닛을 가리키며 코어의 수가 많을수록 더 많은 수의 명령어를 동시에 병렬로 처리할 수 있다.
  * 예를 들어, CPU를 구매할 때 2코어 4스레드라는 표현을 보았다면 이 경우 코어와 스레드 모두 물리적인 유닛을 지칭한다.
* **물리적인 스레드는 개별 코어 유닛을 논리적으로 분할한 개념이며, 일종의 논리적인 코어로 이해**할 수 있다.
* 그러나 **논리적인 스레드는 소프트웨어적으로 생성되는 스레드를 의미하며, 프로그래밍에서 사용되는 스레드라는 용어는 모두 논리적인 스레드에 포함**된다.
  * 또한, 이러한 **논리적 스레드는 프로세스 내에서 실행되는 세부적인 작업의 범위**가 된다.
  * **논리적인 스레드는 메모리가 허용하는 범위 내에서는 사실상 무한정 생성할 수 있으나, 물리적인 스레드의 가용 범위 안에서만 실행**될 수 있다.
* 이 때, **중요한 것은 물리적인 스레드가 병렬성과 관련이 있는 반면 논리적인 스레드는 동시성과 관련이 있다는 점**이다.
  * 물리적인 스레드는 실제로 동시에 실행되므로 여러 작업을 동시에 처리하지만, 논리적인 스레드는 마치 동시에 실행되는 것처럼 보이게 하는 동시성을 갖는다.
* 중요한 것은 **논리적인 스레드의 작업은 마치 동시에 실행되는 것처럼 보이지만, 실제로는 물리적인 스레드 개수 내에서 실행된다는 점**이다.

## 2023-12-04 Mon
### Scheduler란?
* Reactor의 **스케쥴러는 Reactor `Sequence`에서 사용되는 스레드를 관리해주는 역할을 수행**하며, 운영체제의 스케쥴러와 유사한 의미를 갖는다.
  * 예를 들어, 운영체제 차원의 스케쥴러는 실행되는 프로세스를 선택하고 실행하는 등의 라이프 사이클을 관리하는 관리자 역할을 수행한다.
* 즉, **Reactor의 스케쥴러는 비동기 프로그래밍을 위해 사용되는 스레드를 관리해주는 역할을 수행**한다.
  * 때문에 **스케쥴러를 활용하여 어떠한 스레드에서 어떤 작업을 처리할지 제어**할 수 있다.
* 일반적으로 Java 기반의 멀티스레드 프로그래밍은 제어가 어렵고 복잡하지만, Reactor는 스케쥴러를 제공하여 이를 지원한다.
  * 에를 들어, **스케쥴러를 통해 코드를 간결하게 만들고 스레드의 제어권을 스케쥴러에게 넘겨 개발자의 부담을 줄일 수 있다**.

## 2023-12-05 Tue
### Scheduler와 Operator
* Reactor의 경우, 스케쥴러는 전용의 `Operator`를 통해 사용해볼 수 있다.
  * 예를 들어, `subscribeOn()`과 `publishOn()` 및 `parallel()`이 스케쥴러 전용의 `Operator`에 해당한다.
* **스케쥴러 `Operator`의 인자로 적절한 스케쥴러를 전달할 경우, 해당 스케쥴러의 특성에 맞는 스레드가 Reactor의 `Sequence`에 할당**된다.

## 2023-12-06 Wed
### subscribeOn() Operator란?
```
> 해당 subscribeOn() Operator는 구독이 발생한 직후에 실행될 스레드를 지정한다.
```
* `Subscriber`에 의한 구독이 발생할 경우 `Publisher`는 데이터를 최초로 `Emit`하는 반면, `subscribeOn()` 연산자는 구독 직후에 실행된다.
  * 때문에 **해당 연산자는 원본 `Publisher`의 동작을 처리하기 위한 스레드를 지정하는 것으로 이해**할 수 있다.
  * 즉, 해당 연산자에는 인자로써 적절한 스케쥴러를 전달하는 것으로 동작을 처리하기 위한 스레드를 할당하게 된다.
* **스케쥴러에 의해 실행 스레드가 할당된 경우, 이후의 `Operator` 체인 상에서 별도의 스케쥴러를 지정하지 않는다면 계속해서 같은 스레드에서 실행**된다.

## 2023-12-07 Thu
### publishOn() Operator란?
```
> Publisher는 Reactor의 Sequence로부터 발생한 Signal을 Downstream으로 전송한다.
> 이 때, publishOn() Operator는 Downstream으로 Signal을 전송하는 과정을 처리하는 스레드를 제어하기 위해 활용할 수 있다.
```
* **해당 연산자는 코드 상에서 보았을 때 아래 쪽의 `Downstream` 실행 스레드를 변경하는 역할을 수행**한다.
  * 또한, `subscribeOn()` 연산자와 마찬가지로 인자에 스케쥴러를 전달하여 해당 스케쥴러의 특징을 갖는 스레드로 변경시킬 수 있다.
* **중요한 것은 해당 연산자가 코드 상에서 `publishOn()`이 명시된 위치를 기준으로 `Downstream`의 실행 스레드를 변경한다는 사실**이다.

## 2023-12-08 Fri
### parallel() Operator란?
* `subscribeOn()`과 `publishOn()`은 모두 동시성을 갖는 논리적인 스레드에 해당되는 반면, `parallel()`은 병렬성을 갖는 물리적인 스레드에 해당한다.
* 다시 말해, **`parallel() Operator`는 라운드 로빈 방식으로 CPU의 논리적인 코어 개수만큼의 스레드를 병렬로 실행**한다.
  * 예를 들어, 4코어 12스레드 CPU 상에서 해당 연산자를 사용한 경우 총 12개의 스레드를 병렬로 실행한다.
  * 반면, 작업의 유형에 따라 물리적인 스레드를 전부 사용하지 않고자하는 경우에는 해당 연산자의 인자에 정수를 전달하여 스레드 수를 명시할 수도 있다.
* 이 때, **`parallel() Operator`는 단지 CPU의 물리적인 스레드 수에 맞게 `Emit`된 데이터를 골고루 분배하는 역할만을 담당**한다.
  * 반면, **실제로 병렬 분배된 작업을 처리할 스레드를 할당하는 것은 `runOn() Operator`가 담당**한다.

## 2023-12-09 Sat
### Reactor와 Scheduler - 중간 정리
* **Reactor의 스케쥴러는 비동기 프로그래밍을 위해 사용되는 스레드를 관리하는 역할을 담당**한다.
* `subscribeOn() Operator`는 **구독이 발생한 직후에 실행될 스레드를 지정하는 연산자**에 해당한다.
* `publishOn() Operator`는 **`Downstream`으로 `Signal`을 전송하는 과정에서 실행되는 스레드를 제어하는 역할을 담당하는 연산자**에 해당한다.
* `parallel() Operator`는 **라운드 로빈 방식으로 CPU의 논리적인 코어 수만큼 스레드를 병렬로 실행하기 위해 사용하는 연산자**에 해당한다.
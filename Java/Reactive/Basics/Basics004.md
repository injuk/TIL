# Reactive
## 2023-11-02 Thu
### 리액티브 프로그래밍을 위한 사전 지식 - 함수형 인터페이스
```
> 리액티브 프로그래밍을 잘 활용하기 위해서는 함수형 프로그래밍 기법을 어느 정도 이해할 필요가 있다.
> 함수형 인터페이스란 단 하나의 추상 메소드를 정의한 인터페이스를 의미하며, Java에서 함수형 프로그래밍 방식을 지원하기 위해 Java 8부터 도입되었다. 
```
* Java 8부터 함수형 인터페이스를 기반으로 한 람다 표현식이 도입됨에 따라 Java에서도 함수형 프로그램과 유사한 효과를 얻을 수 있게 되었다.
  * 이 때, **함수형 인터페이스란 단 하나의 추상 메소드만을 정의하는 인터페이스를 의미**한다.
  * 함수형 프로그래밍을 위해서는 우선 함수가 일급 시민으로 취급될 필요가 있으며, Java 8부터는 함수형 인터페이스를 통해 함수를 값으로 취급할 수 있다.

## 2023-11-03 Fri
### 리액티브 프로그래밍을 위한 사전 지식 - 람다 표현식
```
> Java의 람다 표현식은 함수형 인터페이스에 정의된 추상 메소드를 간결하게 구현하도록 지원한다.
```
* Java에서의 함수형 프로그래밍은 함수형 인터페이스에 대한 익명 구현 객체를 활용할 수 있으나, 이는 가독성을 떨어트리기 쉬우므로 주로 람다 표현식을 사용한다.
  * 즉, **Java 8의 람다 표현식은 인터페이스에 대한 익명 구현 객체보다 더 함수형 프로그래밍에 걸맞는 표현법으로 이해**할 수 있다.
  * 또한, 상술한 설명에 따라 람다 표현식은 Java의 함수인 메소드 자체를 파라미터로 전달하는 것이 아닌 람다 표현식으로 단순화된 인스턴스를 전달한다.
* Java의 **람다 표현식은 `(파라미터) -> (람다 본문)`의 형태로 표현되며, 함수형 인터페이스를 구현하는 클래스의 메소드를 단순화한 표현식에 해당**한다.
* 또한, 람다 표현식은 클로져와 유사한 개념인 `람다 캡쳐링`을 통해 파라미터로 전달된 변수 뿐만 아니라 람다 표현식 외부에서 정의된 변수에도 접근할 수 있다.
  * **람다 표현식 외부에 정의된 변수를 자유 변수라고 지칭하며, 자유 변수는 코드 상에서 마치 `final` 처럼 초기 값을 유지해야한다는 제약이 존재**한다.

## 2023-11-04 Sat
### 리액티브 프로그래밍을 위한 사전 지식 - 메소드 레퍼런스
```
> 메소드 레퍼런스는 람다 표현식을 더 간결하게 표현할 수 있도록 지원되는 개념이다.
```
* 람다 표현식이 함수형 인터페이스에 정의된 추상 메소드를 간결히 작성하게 지원하듯, 메소드 레퍼런스는 이를 한 층 더 간결화한다.
  * 이러한 메소드 레퍼런스를 표현하기 위해서는 `클래스명::메소드명`과 같은 형태로 작성한다.
* 이 때, 메소드 레퍼런스로 주로 사용할 수 있는 유형은 크게 다음과 같이 분류된다.
  1. 클래스의 정적 메소드: `StringUtils::upperCase`와 같이 정적 메소드로 정의된 요소를 사용할 수 있다.
  2. 클래스에 정의된 메소드: `String::toUpperCase`와 같이 클래스에 정의된 멤버 메소드를 사용할 수 있다.
  3. 인스턴스의 메소드: `myObj::myFunc`와 같은 형태로 사용하며, 주로 람다 표현식 외부에 정의된 객체의 메소드를 호출하는 경우에 사용된다.
  4. 클래스의 생성자: `MyClass::new`와 같은 형태로 사용되며, 람다 표현식 내에서 임의의 클래스에 대한 생성자를 호출하는 경우에 사용된다.

## 2023-11-05 Sun
### 리액티브 프로그래밍을 위한 사전 지식 - 함수 디스크립터
```
> 함수 디스크립터를 기반으로 함수형 인터페이스의 매개 변수 형식과 반환형을 더 직관적으로 이해할 수 있다.
```
* 상술한 내용만으로도 리액티브 프로그래밍을 이해하는 데에는 지장이 없으나, 더 깊은 이해를 위해서는 함수 디스크립터를 이해할 필요가 있다.
* **함수 디스크립터란, 일반화된 람다 표현식을 기반으로 해당 함수형 인터페이스가 어떤 매개 변수를 갖고 무엇을 반환하는지 설명**한다.
* Java의 경우 다양한 형태의 함수형 인터페이스에 대응되는 함수 디스크립터가 정의되어 있으며, 크게 다음과 같이 분류할 수 있다.
  1. `(T) -> boolean`: 함수형 인터페이스 `Predicate<T>`에 대응한다.
  2. `(T) -> void`: 함수형 인터페이스 `Consumer<T>`에 대응한다.
  3. `(T) -> R`: 함수형 인터페이스 `Function<T, R>`에 대응한다.
  4. `() -> T`: 함수형 인터페이스 `Supplier<T>`에 대응한다.
  5. `(L, R) -> boolean`: 함수형 인터페이스 `BiPredicate<L, R>`에 대응한다.
  6. `(T, U) -> void`: 함수형 인터페이스 `BiConsumer<T, U>`에 대응한다.
  7. `(T, U) -> R`: 함수형 인터페이스 `BiFunction<T, U, R>`에 대응한다.
* 이 때, `Bi-`라는 접두사가 붙는 함수형 인터페이스들은 각각 유사한 이름을 갖는 함수형 인터페이스들에 하나의 매개 변수를 추가한 확장형으로 이해할 수 있다.

## 2023-11-06 Mon
### Reactor란?
```
> Reactor는 스프링 프레임워크 개발 팀의 주도 아래 개발된 리액티브 스트림즈의 구현체이다.
> Reactor는 스프링 프레임워크 5 버전부터 리액티브 스택에 포함되었으며, WebFlux 기반의 리액티브 애플리케이션을 개발하기 위한 핵심 역할을 담당한다.
```
* 또한, **Reactor Core 라이브러리는 스프링 WebFlux 프레임워크에 라이브러리로써 포함**된다.
* Reactor는 리액티브 스트림즈를 구현하는 구현체인 리액티브 라이브러리로써 크게 다음과 같은 특징을 갖는다.
  1. `Non-Blocking`: JVM 상에서 실행되는 논블로킹 애플리케이션을 개발하기 위한 핵심 기술에 해당한다.
  2. `Java's Functional API`: Reactor에서 `Publisher`와 `Subscriber` 간의 상호작용은 Java의 함수형 프로그래밍 API를 활용한다.
  3. `Flux[N]`: `Flux`는 N개의 데이터, 즉 최대 무한대의 데이터를 `Emit`할 수 있는 `Publisher` 타입에 해당한다.
  4. `Mono[0|1]`: `Mono`는 단발성 데이터를 `Emit`하는 데에 최적화된 `Publisher` 타입에 해당한다.
  5. `Well-suited for microservices`: Reactor는 마이크로 서비스 기반의 시스템에서, 서비스들 간에 지속적으로 발생하는 IO를 처리하기에 적합하다.
  6. `Backpressure-ready network`: Reactor는 `Publisher`로부터 전달되는 많은 데이터를 `Subscriber`가 적절히 처리하도록 배압을 지원한다.
* 특히, Reactor는 배압을 위해 다양한 전략을 제공하는 식으로 `Subscriber`가 과부하되지 않도록 제어한다.
* Reactor를 활용하는 코드는 크게 `데이터를 생성하여 제공`하고, `데이터를 가공한 후`에 `전달받은 데이터를 처리`하는 식으로 작성된다.
  * 이러한 **세 단계는 데이터의 가공 처리 단계의 복잡성과 스레드 제어 방식과는 무관하게 적용되는 필수 단계에 해당**한다.

## 2023-11-07 Tue
### 마블 다이어그램이란?
```
> 마블 다이어그램은 Reactor Sequence에서 진행되는 데이터 흐름을 이해하는 데에 큰 도움을 주는 도구에 해당한다.
```
* 마블 다이어그램은 여러가지 구슬(Marble)과 도형으로 구성된 다이어그램으로, Reactor가 제공하는 여러 `Operator`를 이해하는데 큰 도움을 준다.
  * Reactor는 굉장히 많은 `Operator`를 지원하며, 각각의 `Operator`는 자신을 잘 설명하는 마블 다이어그램을 갖는다.
* 마블 다이어그램을 완전히 이해하지 못했더라도 리액티브 프로그래밍을 지원할 수는 있으나, 여러 `Operator`를 이해하기엔 어려움이 따를 수 있다.
  * 때문에 처음 사용하는 `Operator`를 이해하고 사용하기에 앞서 우선 해당 `Operator`의 마블 다이어그램을 확인하는 습관을 들이는 것이 바람직하다.

## 2023-11-08 Wed
### Mono란?
```
> Mono는 0개 혹은 1개의 데이터만을 Emit하는 Publisher 타입이므로, HTTP 요청이나 응답에 매우 적합하다.
```
* **Mono는 Reactor가 제공하는 `Publisher` 타입의 하나로, 특히 0개 또는 1개의 데이터를 `Emit`하는 `Publisher`에 해당**한다.
  * 이는 RxJava가 제공하는 `Publisher` 타입 중 한 건의 데이터를 `Emit`하는 Single과 0 또는 1개의 데이터를 `Emit`하는 Maybe와 유사하다.
* Mono를 활용하여 0개 또는 1개의 데이터를 `Emit`하기 위해서는 다음과 같은 `Operator`를 활용해볼 수 있다.
  1. `just()`: 단건 데이터를 `Emit`할 수 있는 반면, 둘 이상의 데이터를 전달했을 경우에는 내부적으로 `fromArray() Operator`를 활용한다.
  2. `empty()`: 데이터를 하나도 `Emit`하지 않는 경우에 활용할 수 있는 `Operator`에 해당한다.
* 특히, `empty() Operator`의 경우 데이터를 단 한 건도 `Emit`하지 않은 채로 `onComplete Signal`을 전송한다.
  * 이렇듯 `empty() Operator`는 데이터를 전달받지 않았음에도 작업 종료를 알리고 적절한 후처리를 적용하고자 하는 경우에 활용할 수 있다.

## 2023-11-09 Thu
### subscribe 메소드의 파라미터
* `subscribe()` 메소드는 세 개의 람다 표현식 파라미터를 전달 받아 동작할 수 있으며, 각각 다음과 같은 역할을 수행한다.
  1. 첫 번째 람다 표현식은 `Publisher`가 `onNext Signal`을 전송한 경우에 실행되며, `Subscriber`가 데이터를 전달받기 위해 사용된다.
  2. 두 번째 람다 표현식은 `Publisher`가 `onError Signal`을 전송한 경우에 실행되며, 발생한 에러를 예외 형태로 전달받기 위해 사용된다.
  3. 세 번째 람다 표현식은 `Publisher`가 `onComplete Signal`을 전송한 경우에 실행되며, `Publisher`의 `Emit`이 종료되었음을 알 수 있게 된다.
* 특히, 세 번째 파라미터로 전달된 람다 표현식을 활용하여 데이터의 `Emit`이 종료된 경우에 대한 후처리를 진행하도록 구현할 수 있다.

## 2023-11-10 Fri
### Flux란?
```
> Flux는 0개 또는 1개 이상의 데이터를 Emit할 수 있는 Publisher 타입이므로, Mono의 데이터 Emit 범위를 포함한다.
```
* Flux는 둘 이상의 Mono를 `concatWith() Operator`로 연결하여 변환할 수도 있다.
  * 이 때, 해당 `Operator`는 수신 객체와 파라미터로 전달된 객체가 각각 `Emit`하는 데이터를 연결하여 새로운 `Publisher`의 데이터 소스를 생성한다.
  * 이렇게 연결된 데이터 소스는 새로운 Flux의 데이터 소스로 변환되어 차례대로 데이터를 `Emit`할 수 있게 된다.
* 이러한 `concatWith() Operator`는 하나의 결과를 만드는 문자열 `concat()`과 달리 두 데이터 소스를 연결하여 새로운 데이터 소스를 생성한다.
  * 이렇게 생성된 새로운 데이터 소스는 데이터를 차례로 `Emit`하는 Flux로서 기능한다.
* 반면, 수신 객체와 파라미터 객체로만 동작하는 `concatWith()` 대신 원하는 만큼의 데이터 소스를 전달 받는 `concat() Operator`를 활용할 수도 있다.
  * 이 경우, `concat() Operator`에 의해 연결된 데이터 소스는 자연스러 새로운 Flux로 기능하게 된다.

## 2023-11-11 Sat
### 리액티브 프로그래밍의 Hot과 Cold
* IT 분야에서는 Hot과 Cold라는 표현을 일반적으로 다음과 같이 사용한다.
  1. Hot: 어떠한 작업을 처음부터 다시할 필요 없이 적용하여 같은 작업을 반복하지 않는다.
  2. Cold: 어떠한 작업을 위해 시스템을 재시작하거나, 작업을 위한 과정에서 같은 작업을 반복한다.
* **리액티브 프로그래밍에서도 두 표현은 종종 사용되며, 일반적으로 Hot은 어떠한 것을 재시작하지 않는 반면 Cold는 재시작한다는 의미로 사용**한다.

## 2023-11-12 Sun
### Cold Sequence란?
```
> Cold Sequence란, Publisher가 다수의 Subscriber로부터의 구독 시점이 다르더라도 매번 데이터 Emit을 처음부터 시작하는 흐름을 의미한다.
```
* 앞서 다룬 바와 같이 **시퀀스는 `Publisher`가 `Emit`하는 데이터의 연속적인 흐름을 정의한 것으로, 코드 상에서는 `Operator` 체인 형태로 표현**된다.
  * 이 때, Cold와 Hot 개념은 시퀀스에 적용되어 어떠한 데이터의 흐름에 차이를 주게 된다.
* 이러한 관점에서, **`Cold Sequence`는 `Subscriber`가 구독을 시도할 때마다 데이터의 흐름이 처음부터 재시작되는 시퀀스를 의미**한다.
  * 때문에 **다수의 `Subscirber`가 임의의 `Publisher`를 구독하려 하지만 그 시점이 다른 경우에도 모든 `Subscriber`는 동일한 데이터를 수신**한다.
  * 이 때, 이러한 `Cold Sequence` 방식으로 동작하는 `Publisher`는 `Cold Publisher`라고도 지칭할 수 있다.
* 마블 다이어그램 상에서 `Cold Sequence`를 표현할 경우, 시퀀스의 타임라인은 새로운 `Subscriber`가 구독을 시작할 때마다 새로이 추가된다.

## 2023-11-13 Mon
### Hot Sequence란?
```
> Hot Sequence란, Publisher가 데이터를 Emit하는 과정이 한 번만 발생하고, Subscriber는 구독한 이후에 Emit된 데이터만 전달받는 데이터 흐름이다.
```
* `Cold Sequence`의 경우, `Subscriber`의 구독이 발생한 시점과 관계 없이 항상 데이터를 처음부터 전달받을 수 있다.
  * 반면, **`Hot Sequence`에서 `Subscriber`는 구독이 발생한 시점 이후에 `Emit`된 데이터만을 전달받을 수 있다**.
* **`Cold Sequence` 기반의 원본 Flux를 `Hot Sequence`로 변환하고자 하는 경우, `share() Operator`를 활용**할 수 있다.
  * 해당 **`Operator`는 호출시 최초로 반환된 원본 Flux를 여러 `Subscriber`가 공유할 수 있도록 지원**한다.
* 반면, **`Cold Sequence` 기반의 원본 Mono를 `Hot Sequence`로 변환하고자 하는 경우에는 `cache() Operator`를 활용**할 수 있다.
  * 해당 `Operator`의 경우, Mono가 1개 이하의 데이터만을 `Emit`하므로 `Emit`된 데이터를 캐싱한 후에 이후의 구독에 대해 캐시된 결과를 반환한다.
  * 이 경우 `Subscriber`에 의한 매 구독마다 동일한 데이터가 반환되므로, 예를 들어 인증 토큰이 만료되기 전까지 캐시하는 등의 용도로 활용해볼 수 있다.
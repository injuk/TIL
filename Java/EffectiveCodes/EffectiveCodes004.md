# EffectiveCodes
## 2022-03-04 Fri

## 제네릭
* 제네릭은 Java 5부터 지원된 기능으로, 클래스가 처리할 수 있는 타입을 컴파일러에게 알려주는 역할을 한다.
* 컴파일러는 실제 타입에 대한 형변환 코드를 자동으로 추가하거나, 잘못된 타입의 객체를 사용하려는 시도를 컴파일 과정에서 차단한다.
* 제네릭을 활용하면 안전하고 명확한 프로그래밍이 가능하지만, 코드가 다소 복잡해지는 단점이 있다.

### 제네릭과 관련된 용어
* 타입 매개변수: 클래스 또는 인터페이스 선언에 사용되는 T, E, K, V 등의 매개변수이다.
  * 실제 타입 매개변수: 타입 매개변수에 대입된 String 등의 실제 타입을 가리키는 용어이다.
* 제네릭 클래스 / 제네릭 인터페이스: 클래스 / 인터페이스에 선언에 타입 매개변수가 사용된 클래스 / 인터페이스를 가리킨다.
* 제네릭 타입: 제네릭 클래스와 제네릭 인터페이스를 통틀어 가리키는 용어이다.
* 매개변수화 타입: 각 제네릭 타입은 매개변수화 타입을 정의하며, 제네릭 타입에서 사용할 실제 타입을 매개변수로 전달한다.
  * 예를 들어, List<String>은 String을 사용하는 List를 명시하는 매개변수화 타입이다.
* 로우 타입: 제네릭 타입에서 괄호와 타입 매개변수가 사용되지 않는 상태이며, 제네릭 타입을 정의할 때 함께 정의된다.
```
List<E> : 제네릭 타입, 제네릭 인터페이스
          E는 타입 매개변수
List<String> : 매개변수화 타입
               String은 실제 타입 매개변수
List : 타입 매개변수를 사용하지 않는 로우 타입
```

### 로우 타입은 사용하지 않기
* **로우 타입은 제네릭 타입의 타입 정보가 제거된 것처럼 동작하며, 이는 제네릭이 도입된 Java 5 이전 코드와의 호환성을 위해 제공**되는 개념이다.
* 컬렉션을 예로 들어, 로우 타입 컬렉션은 의도와 다른 클래스의 인스턴스를 추가하더라도 오류가 발생하지 않는다.
  * 대신 인스턴스를 읽어들이며 형변환하는 과정에서 오류가 발생할 것이다.
* **오류는 가능한 한 발생 즉시 발견하는 것이 좋으며, 컴파일 시점에 발견되는 것이 가장 이상적**이다.
* 로우 타입의 경우, 런타임에서 발생한 오류의 발생 시점과 원인 코드가 물리적으로 먼 곳에 떨어질 가능성이 높고, 이를 디버깅하기가 어려워진다.
  * 해당 컬렉션에서 사용해야 할 클래스를 주석으로 명시한다고 한들, 컴파일러는 주석을 이해하지 못하므로 의미가 없다.
* **제네릭을 활용하면 사용해야할 클래스 타입 정보가 주석이 아닌 타입 선언 자체에 정의**된다.
  * 컴파일러는 해당 컬렉션이 다뤄야할 타입을 명확하게 인지하며, 다른 타입의 클래스를 사용하려는 시도가 발견되면 오류를 발생시킨다.
  * 때문에 **아무런 오류 없이 컴파일된다면 해당 코드의 정상성 역시 보장**된다.
  * 컴파일러는 또한 요소를 읽어들이는 모든 코드에 보이지 않는 형변환을 추가하여 코드의 성공을 보장한다.
* **타입 매개 변수가 없는 제네릭 타입인 로우 타입을 사용하는 것은 언어 차원에서 오류를 발생시키지는 않지만, 절대 사용하지 말아야 한다**.
  * **로우 타입은 제네릭이 보장하는 안전성과 표현력을 활용할 수 없는 방식이다.**.
* **실제 타입 매개변수가 무엇이될지 신경쓰고 싶지 않아 로우 타입을 적용하고 싶은 상황이라면, 대신 물음표 기호를 적용한 매개변수화 타입을 활용**한다.
  * ?는 비한정적 와일드카드 타입으로, 어떠한 타입도 담을 수 있는 범용적인 제네릭 타입이다.
* 비한정적 와일드카드 타입은 안전하고, 로우 타입은 안전하지 않다.
  * 예를 들어, **로우 타입 컬렉션에는 아무런 요소나 추가할 수 있지만, 비한정적 와일드카드 타입 컬렉션에는 null 이외의 요소를 추가할 수 없다**.
  * 이러한 제약을 따르고 싶지 않다면 제네릭 메소드 또는 한정적 와일드카드 타입을 사용해야 한다.
```
class Test {
    public static void testWildCard(List<?> list) {
        // 아래와 같이 사용할 수 없다. 비한정적 와일드카드 타입에 어떤 타입이 적용될지 알 수 없기 때문이다.
        // list.add("Hello");
        list.add(null);
    }
    public static void testRaw(List list) {
        // 반면 로우 타입은 모든 타입을 마음대로 추가할 수 있어 안전성이 보장되지 않는다.
        list.add("Hello");
        list.add(null);
    }
}
```
* 반면 로우 타입은 다음과 같은 상황에 사용이 권장된다.
  1. class 리터럴을 명시하는 경우, 매개변수화 타입을 사용할 수 없으므로 로우 타입을 사용한다.
     * 예를 들어 List<String>.class는 사용할 수 없으므로 List.class로 명시한다.
  2. **instanceof 연산자에서는 로우 타입을 사용**한다.
     * 이는 런타임 시점에서 제네릭 타입 정보가 지워지므로 instanceof 연산자는 비한정적 와일드카드 타입 이외의 매개변수화 타입에 적용할 수 없기 때문이다. 
     * 로우 타입과 비한정적 와일드카드 타입은 instanceof 연산자에서 완전히 똑같이 동작하므로, 코드의 가독성을 위해 로우 타입이 권장된다.

### 로우 타입의 결론
* 로우 타입을 사용하면 런타임에 예외가 발생할 수 있으므로 사용을 지양한다.
* 로우 타입은 제네릭 도입 이전의 코드와의 호환성을 위해 제공되는 기능에 불과하다.
* List<Object>는 모든 타입의 객체를 저장할 수 있는 매개변수화 타입이며, 제네릭 타입이므로 안전하다.
* List<?>는 어떤 특정한 타입의 객체만 저장할 수 있는 와일드카드 타입이며, 제네릭 타입이므로 안전하다.
* List는 로우타입이며, 제네릭 타입 시스템에 속하지 않아 안전하지 않다.

### 비검사 경고는 제거하기
* 제네릭을 사용하면 수많은 컴파일러 경고와 마주치게 된다.
* 이러한 비검사 경고는 대부분 쉽게 제거할 수 있지만, 곧바로 해결되지 않는 경고도 포기하지 말아야 한다.
  * **가능한 한 모든 비검사 경고를 제거하여 코드의 타입 안정성은 보장**해야 한다.
  * 이를 통해 런타임의 ClassCastException 발생 가능성을 없애고, 코드의 정상성을 보장할 수 있다.
* 경고를 제거할 수는 없지만, 로직상 타입 안전하다고 확신이 드는 경우에는 @SuppressWarnings("unchecked") 어노테이션을 활용한다.
  * 해당 어노테이션을 통해 경고를 숨길 수 있지만, 타입 안전성이 검증되지 않은 경우에는 여전히 런타임 에러 발생 가능성이 존재하게 된다.
  * 그러나 **안전하다고 검증된 비검사 경고를 그대로 두면 수 많은 비검사 경고에 진짜 중요한 문제를 알리는 경고가 묻힐 수 있다**.
* @SuppressWarnings 어노테이션은 어떤 선언에도 적용할 수 있지만, 가능한 한 좁은 범위에 적용하는 것이 바람직하다.
  * 지역 변수 선언에 적용하는 것이 이상적이며, 절대 클래스 전체에 적용하지 말아야 한다.
  * 이를 위해 **새로운 지역 변수를 선언해야 하는 수고가 들 수 있지만, @SuppressWarnings 어노테이션에는 그만한 가치가 있다**.
* @SuppressWarnings 어노테이션을 사용하는 경우, 해당 경고를 무시해도 되는 이유를 주석으로 작성하는 것이 바람직하다.
  * 이를 통해 다른 개발자가 해당 코드를 잘 못 수정하여 타입 안정성을 잃게 되는 상황을 방지할 수 있다.
  * 코드가 안전하다는 근거를 찾기 어렵더라도 끈기를 갖고 찾아내야 하며, 이 과정에서 생각하지 못한 결함을 찾아낼 수도 있다.

### 비검사 경고의 결론
* 모든 비검사 경고는 런타임에서 발생할 수 있는 ClassCastException 가능성을 의미하므로, 무시하지 말고 최대한 제거해야 한다.
* 경고를 없앨 방법을 찾아낼 수 없다면, 코드의 타입 안전성을 증명하고 최대한 범위를 줄인 @SuppressWarnings("unchecked") 어노테이션을 적용한다.
  * @SuppressWarnings 어노테이션으로 경고를 숨기려는 근거는 반드시 주석으로 작성해야 한다.

### 배열보다는 리스트를 활용하기
* 배열과 제네릭은 다음과 같은 주요한 차이가 있다.
1. 배열은 공변이므로, Sub[]는 Super[]의 하위 타입으로 취급된다.
   * 배열의 경우, 잘못된 타입을 저장하려는 실수를 런타임 시점에서 알 수 있지만, 제네릭은 컴파일조차 되지 않는다.
2. 배열은 실체화 타입되며, 런타임에도 자신이 다뤄야할 요소의 타입을 확인하는 절차가 포함된다.
   * 반면 제네릭은 런타임 시점에 타입 정보가 소거되며, 요소의 타입은 컴파일 시점에만 검사되어 런타임에는 알 수 없게 된다.
   * 이러한 타입 소거는 제네릭 이전의 코드와 호환성을 보장하기 위한 장치이다.
* 상술한 이유에서 배열은 제네릭과 어우러지지 못하며, 배열을 제네릭 타입으로도 사용할 수 없다.
  * 제네릭 배열은 안전하지 않으며, 런타임 시점에 ClassCastException이 발생할 수 있으므로 언어 차원에서 지원하지 않도록 구현되어 있다.
  * 제네릭의 목표는 타입 안전성 보장이며, 런타임 시점에서 발생할 수 있는 ClassCastException을 방지하는 것이 주요 목표이다.
* 제네릭 타입, 매개변수화 타입은 실체화 불가 타입이다.
  * 이러한 타입은 실체화되지 않으므로 런타임에서는 컴파일 시점보다 타입 정보를 적게 갖는다.
* 배열 대신 제네릭 컬렉션을 사용하면 코드가 복잡해지고 성능이 다소 낮아지나, 타입 안전성과 상호 운용성이 높아진다.

### 배열보다 리스트 활용의 결론
* 배열과 제네릭은 정 반대의 타입 규칙이 적용되는 차이가 있다.
  * 배열은 공변이고 실체화된다.
  * 제네릭은 불공변이고 실체화되지 않아 타입 정보가 소거된다.
* 배열은 런타임에서 타입 안전하지만, 컴파일 타임에는 타입 안전하지 못하다.
* 제네릭은 컴파일 타임에서 타입 안전하지만, 런타임에서 타입 안전하지 못하다.
* 이러한 이유에서 **배열과 제네릭을 혼용하기는 어려움이 따르며, 혼용 중 오류가 발생하면 우선 배열을 제네릭 컬렉션으로 대체하는 방법을 적용**한다.

### 가능하면 제네릭 타입으로 만들기
* JDK가 제공하는 제네릭 타입과 메소드를 사용하는 것은 쉽지만, 새로운 제네릭 타입을 만들기는 어렵다.
  * 그러나 어려운 만큼의 값어치를 해내는 일이다!
* 일반 클래스를 제네릭 클래스로 만드는 방법은 다음과 같다.
  1. 클래스 선언에 타입 매개 변수를 추가한다.
  2. 클래스 내부에 사용된 타입 중 적절한 것을 타입 매개 변수로 수정한다.
  3. 컴파일해보고, 발생하는 오류와 경고를 해결한다.
* 3.의 과정에서, 주로 배열과 관련된 오류와 마주치기 쉽다.
* 배열을 사용하는 코드를 제네릭으로 만들기 위해 사용 가능한 해결책은 크게 다음의 두 가지로 나뉜다.
  1. 제네릭 배열 생성을 금지하는 제약을 명시적으로 우회하기 위해 Object 베열을 생성하고 제네릭 배열로 형변환한다.
  2. 배열을 사용하는 필드의 타입을 E[]가 아닌 Object[]로 만들어준다.
* 1.의 방법의 경우, 다음과 같다.
  * 아래 방식을 적용한 후에는 컴파일 오류 대신 경고가 발생하며, 클래스의 모든 로직을 확인하여 타입 안전성이 보장되는지 확인한다.
  * 모든 메소드의 동작에서 타입 안전성이 확실히 보장되는 경우, @SuppressWarnings("unchecked") 어노테이션을 적용한다.
```
private E[] elements;
// ...생략
// 아래는 생성자 내부의 초기화 코드이다.
  // elements = new E[10]; // E는 런타임에서 소거되므로 배열화할 수 없다.
  elements = (E[]) new Object[10]; // Object 배열로 생성하고 E형 배열로 형변환하여 우회할 수 있다. 
```
* 2.의 방식의 경우, 다음과 같다.
  * 아래의 방식에서 E는 실체화 불가 타입이므로, 컴파일러는 런타임 시점의 형변환이 안전한지 증명할 수 없기 때문에 경고가 발생한다.
  * 해당 경고 역시 타입 안전성이 보장되는지 직접 증명한 후에 @SuppressWarnings("unchecked") 어노테이션을 명시하여 경고를 숨겨주어야 한다.
```
private Object[] elements;
// ...생략
// 아래는 메소드 내부의 코드이다.
E fetched = (E) elements[--size]; // 값을 가져올 필요가 있는 경우 Object 타입의 요소를 E로 명시적 형변환한다.
```
* 상술한 두 방식 모두 각기 다른 이유에서 지지를 얻는다.
  1. 결과 코드가 더 짧고 가독성이 좋으나, 힙 오염의 발생 가능성이 있다.
  2. 매 요소를 사용할 때마다 형변환을 해주어야 하므로 코드가 길어지나, 힙 오염의 발생 가능성이 없다.
* **제네릭 타입을 정의하는 과정에서 배열보다 리스트를 우선 사용하는 원칙과 위배되는 경우가 발생할 수도 있다**. 
  * 제네릭 타입 내부에서 리스트를 항상 사용할 수 있는 것은 아니며, 이는 Java가 List를 기본 타입으로 제공하지 않기 때문이다.
  * 리스트는 배열보다 항상 좋다고 볼 수 없으며, 심지어 List 구현체 역시 내부적으로는 배열을 통해 구현된다.
* 기본적으로 대다수의 제네릭 타입은 타입 매개변수에 아무런 제약을 두지 않으므로, 모든 타입이 적용될 수 있다.
  * 제네릭 타입에 제약을 두고자 하는 경우, <E extends Object>와 같이 한정적 타입 매개변수를 적용할 수 있다.
  * 한정적 타입 매개변수는 타입 매개변수에 특정한 클래스의 하위 타입만 적용이 가능하도록 한정한다.
  * 이 때, 모든 클래스는 자신의 하위 타입이므로 한정적 타입 매개변수로 제한된 제네릭 타입에 적용할 수 있다.

### 제네릭 타입의 결론
* **제네릭은 클라이언트 코드에서 직접 형변환을 수행하지 않아도 되도록 하며, 더 안전하고 사용성이 높다**.
* 새로운 타입을 설계하는 경우, 형변환 없이 사용할 수 있도록 제네릭 타입으로 정의하는 것을 고려해야 한다.
* **기존에 사용 중이던 타입에서 제네릭이었어야 하는 클래스가 있다면 망설임 없이 제네릭 타입으로 변경**해야 한다.
  * 이는 기존 클라이언트 코드에는 영향을 주지 않으면서도 새로운 클라이언트 코드의 작성을 용이하게 만들어준다.

## 2022-03-05 Sat
### 가능하면 제네릭 메소드로 만들기
* 클래스와 마찬가지로 메소드 역시 제네릭으로 작성할 수 있다.
* 제네릭 메소드 역시 코드가 길어지지만 타입 안전성이 보장되고, 사용이 쉽다.
* 제네릭 메소드를 작성할 때, 자기 자신이 포함되는 표현식으로 타입 매개변수의 허용 범위를 한정지을 수 있다.
  * 이를 재귀적 타입 한정이라고 하며, 주로 Comparable 인터페이스와 함께 사용한다.
* Comparable을 예로 들어, 거의 대부분의 타입은 자신과 같은 타입의 원소와만 비교가 가능하다.
  * 예를 들어, String 클래스는 String 간의 비교를 위해 Comparable<String>을 구현한다.
* **이러한 특징을 이용하여 메소드에 <E extends Comparable<E>>를 작성하는 것으로 비교 가능성을 명시**할 수 있다.
  * 이는 해당 메소드에 적용 가능한 모든 타입 E가 자기 자신과 같은 타입과의 비교가 가능하다는 뜻을 내포한다.
* 재귀적 타입 한정은 더욱 더 복잡해질 수 있지만, 대개는 상술한 예시의 복잡성 정도에 그치는 경우가 많다.

### 제네릭 메소드의 결론
* 클라이언트에서 명시적으로 형변환을 작성해주어야 하는 메소드보다 제네릭 메소드가 안전하고, 편리하다.
  * 메소드 역시 제네릭 메소드로 구현하여 인자 또는 결과물을 형변환하지 않아도 되는 방식이 더 좋다.
* **형변환을 반드시 필요로 하는 기존 메소드는 적극적으로 제네릭 메소드로 변환하는 것이 바람직**하다.
  * 이러한 습관은 기존 클라이언트 코드에 영향을 주지 않는 채로, 새로운 클라이언트 코드의 작성을 용이하게 만들어준다.

### 한정적 와일드카드를 활용하여 API의 유연성을 높이기
* 매개변수화 타입은 불공변이므로, 서로 다른 타입의 매개변수화 타입간의 관계는 상 하위를 구분할 수 없다.
  * List를 예로 들어, List<String>은 List<Object>의 기능을 완벽히 대체할 수 없으므로 하위 타입이 아니다.
* 그러나 불공변 방식을 고수하기보다 유연한 방식이 필요한 상황이 발생할 수 있으며, 이 때 한정적 와일드카드를 사용할 수 있다.
* [클래스명]<? extends E>는 E의 하위 타입인 클래스를 가리키는 한정적 와일드카드이다.
* [클래스명]<? super E>는 E의 상위 타입인 클래스를 가리키는 한정적 와일드카드이다.
* **한정적 와일드카드를 활용했을 때 코드가 깔끔히 컴파일된다면, 관련된 모든 내용이 타입 안전하다는 의미를 갖는다**.
* 이렇듯 **제네릭의 유연성을 극대화하려면 요소의 생산자나 소비자용 입력 매개변수에 와일드카드 타입을 사용**해야 한다.
  * 반면 **입력 매개변수가 생산자와 소비자 역할을 동시에하는 경우라면 와일드카드 타입이 아닌 정확한 타입 명시가 적절**하다.
* PECS 공식: 어떤 상황에 어떤 와일드카드 타입을 사용해야하는지 기억하기 위한 공식이다.
  * PECS는 Producer-Extends, Consumer-Super의 약자이다.
  * 따라서 **매개변수화 타입 T가 생산자라면 <? extends T>, 소비자라면 <? super T>를 사용**해야 한다.
* **제네릭 메소드의 반환 타입에는 한정적 와일드카드 타입을 사용하지 말아야 한다**.
  * 이는 코드의 유연성을 높여주지 못하고, 오히려 클라이언트 코드에서 와일드카드 타입의 사용을 강요하는 안티 패턴이다.
* 제대로 적용된 와일드카드 타입은 클라이언트 코드에서 아무런 신경을 쓸 필요 없게 한다.
  * 만약 **클라이언트 코드의 작성 도중 와일드카드 타입을 고려해야하는 경우라면, API 자체에 문제가 있을 가능성**이 높다.
* 다음의 예시처럼 PECS 공식을 두 번 적용할 수도 있다.
  * 입력 매개변수 list는 메소드 내부에서 사용할 값을 생산하는 역할을 하므로, extends를 적용한다.
  * 타입 매개변수 목록에서 Comparable 인터페이스는 전달 받은 값을 소비하여 선후관계를 반환하므로, super를 적용한다.
```
public static <E extends Comparable<E>> E max(List<E> list)
public static <E extends Comparable<? super E>> E max(List<? extends E> list)
```
* **Comparable과 Comparator는 언제나 소비자이므로, 항상 <? super E> 한정적 와일드카드를 적용하는 것이 바람직**하다.
* 타입 매개변수와 와일드카드에는 공통되는 부분이 있으며, 메소드를 정의할 때 둘 중 어느 것을 사용해도 무방한 경우가 많다.
* **기본적으로 메소드 선언에 타입 매개변수가 하나 뿐이라면 와일드카드로 대체하는 것이 바람직**하다.
  * 비한정적 타입 매개변수를 사용한 경우, 비한정적 와일드카드로 바꾸어준다.
  * 한정적 타입 매개변수를 사용한 경우, 한정적 와일드카드로 바꾸어준다.

### 한정적 와일드카드의 결론
* 비록 코드가 복잡해질지라도, 와일드카드 타입을 적용하면 API의 유연성은 훨씬 높아진다.
  * 따라서 공유를 위한 라이브러리를 작성하는 경우라면 반드시 와일드카드 타입을 적용하는 것이 바람직하다.
* 대부분의 와일드카드 형식은 PECS 공식으로 결정할 수 있다.
  * 이 때, Comparable과 Comparator는 언제나 소비자의 역할이다.

### 제네릭과 가변인수를 함께 사용할 때에는 신중히 사용하기
* 가변인수는 메소드에 넘겨주는 인수의 수를 클라이언트 코드에서 자유롭게 조절할 수 있지만, 내부적으로 생성되는 배열이 클라이언트에 노출되는 허점이 있다.
* 메소드 선언시 및 사용시 실체화 불가 타입과 varargs 매개변수를 혼용하면 컴파일러는 힙 오염과 관련된 경고를 노출시킨다.
  * 힙 오염이란, 매개변수화 타입의 변수가 타입이 다른 객체를 참조하는 경우를 말한다.
  * 다른 타입 객체를 참조하는 힙 오염은 컴파일러가 자동 생성하는 형변환이 실패할 수 있음을 의미하므로, 타입 안전성이 보장되지 않을 수 없다.
* 그러나 **제네릭이나 매개변수화 타입의 varargs 매개변수를 사용하는 메소드는 실무에서 매우 유용하므로, Java는 두 개념의 혼용을 막지 않는다**.
* @SafeVarargs 어노테이션은 Java 7에서 추가되었으며, 메소드 작성자가 해당 메소드의 타입 안전성을 보장하는 기능을 수행한다.
  * Java 7 이전에는 메소드 작성자가 해줄 수 있는 일이 없었으므로, 메소드 사용자가 @SuppressWarnings 어노테이션을 덕지덕지 붙여야만 했다.
* **@SafeVarargs 어노테이션은 메소드가 타입 안전한게 확실한 상황에서만 사용해야 하며, 다음의 두 원칙을 통해 메소드의 타입 안전성을 확인**할 수 있다.
  1. 메소드가 varargs 배열에 아무 것도 저장하지 않아야 한다.
  2. varargs 배열의 참조가 메소드 외부로 노출되지 않아야 한다.
* 즉, **varargs 배열이 메소드 사용자가 전달한 인수들을 순수하게 전달하는 역할로만 사용되어야 메소드가 타입 안전**할 수 있다.
* **@SafeVarargs 어노테이션은 제네릭이나 매개변수화 타입의 varargs 매개변수를 받는 모든 메소드에 추가해야 한다**.
  * 때문에 **안전하지 않은 varargs 메소드는 절대 작성하지 않아야 한다**.
* 작성한 varargs 메소드 중 힙 오염과 관련된 경고가 발생하는 코드가 있다면 반드시 상술한 두 원칙을 토대로 안전성을 점검하고 조치해야 한다.
* 또는 varargs 매개변수 대신 List를 사용하고, 클라이언트 코드에서 List.of로 인수를 넘기도록 한다.
  * **이러한 방식은 컴파일러가 메소드의 타입 안전성을 항상 검증할 수 있지만, 클라이언트 코드의 가독성이 다소 떨어지고 성능상의 단점**이 있다.

### 제네릭과 가변인수의 결론
* 가변인수는 배열을 노출하여 추상화가 완벽하지 못하고, 배열과 제네릭의 타입 규칙이 다르기 때문에 가변인수와 제네릭을 혼용하기는 어렵다.
  * 이렇듯 타입 안전하지 않음에도 그 사용상의 이점 덕분에 혼용은 Java 언어 차원에서 허용된다.
* 메소드에 제네릭 varargs 매개변수를 사용하려면, 메소드의 타입 안전성을 철저히 검증한 후에 @SafeVarargs 어노테이션을 사용하여 사용성을 높여야 한다.

### 타입 안전 이종 컨테이너 패턴을 고려하기
* 컬렉션 또는 단일 원소 컨테이너에서 매개변수화되는 대상은 컨테이너 자신이므로, 매개변수화 가능한 타입의 수가 제한된다.
* 더 유연한 활용을 위해, 컨테이너 자체 대신 키를 매개변수화하고 컨테이너와 상호작용할 때 매개변수화된 키를 함께 제공하는 방식을 활용할 수 있다.
* **이를 통해 제네릭 타입 시스템은 값의 타입과 키의 타입이 동일함을 보장해주며, 이러한 방식을 타입 안전 이종 컨테이너 패턴이라고 한다**.
  * class 리터럴의 타입은 Class가 아닌 Class<T>이기 때문에 이러한 방식이 동작할 수 있다.
  * **class 리터럴은 타입 토큰이라는 용어로도 부를 수 있다**.
* **타입 안전 이종 컨테이너를 적용할 경우, 타입 안전성도 보장되면서 모든 키의 타입이 제각각인 유연한 컨테이너를 구현**할 수 있다.
* Class<T>가 제공하는 cast 연산자는 형변환 연산자의 동적인 버전으로, 타입 안전 이종 컨테이너에서 활용될 수 있다.
  * 해당 메소드는 인스턴스의 타입을 검사하여, 맞는 경우에는 인스턴스를 반환하고 아닌 경우에는 ClassCastException을 던지는 식으로 동작한다.
  * cast 메소드의 시그니쳐는 Class 클래스가 제네릭이라는 이점을 활용하므로, cast의 반환 타입은 Class 객체의 타입 매개변수와 같음이 보장된다.
* 타입 안전 이종 컨테이너는 제네릭 등의 실체화 불가 타입을 키로 사용할 수 없다.
  * **이는 매개변수화된 타입에 대해 class 리터럴을 사용할 수 없으며, 모두 동일한 Class 객체를 공유하기 때문**이다.
  * 예를 들어, List<String>과 List<Integer> 등은 모두 List.class라는 Class 객체를 공유하므로 구분이 불가능하다.
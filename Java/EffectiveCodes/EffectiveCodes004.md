# EffectiveCodes
## 2022-03-04 Fri

## 제네릭
* 제네릭은 Java 5부터 지원된 기능으로, 클래스가 처리할 수 있는 타입을 컴파일러에게 알려주는 역할을 한다.
* 컴파일러는 실제 타입에 대한 형변환 코드를 자동으로 추가하거나, 잘못된 타입의 객체를 사용하려는 시도를 컴파일 과정에서 차단한다.
* 제네릭을 활용하면 안전하고 명확한 프로그래밍이 가능하지만, 코드가 다소 복잡해지는 단점이 있다.

### 제네릭과 관련된 용어
* 타입 매개변수: 클래스 또는 인터페이스 선언에 사용되는 T, E, K, V 등의 매개변수이다.
  * 실제 타입 매개변수: 타입 매개변수에 대입된 String 등의 실제 타입을 가리키는 용어이다.
* 제네릭 클래스 / 제네릭 인터페이스: 클래스 / 인터페이스에 선언에 타입 매개변수가 사용된 클래스 / 인터페이스를 가리킨다.
* 제네릭 타입: 제네릭 클래스와 제네릭 인터페이스를 통틀어 가리키는 용어이다.
* 매개변수화 타입: 각 제네릭 타입은 매개변수화 타입을 정의하며, 제네릭 타입에서 사용할 실제 타입을 매개변수로 전달한다.
  * 예를 들어, List<String>은 String을 사용하는 List를 명시하는 매개변수화 타입이다.
* 로우 타입: 제네릭 타입에서 괄호와 타입 매개변수가 사용되지 않는 상태이며, 제네릭 타입을 정의할 때 함께 정의된다.
```
List<E> : 제네릭 타입, 제네릭 인터페이스
          E는 타입 매개변수
List<String> : 매개변수화 타입
               String은 실제 타입 매개변수
List : 타입 매개변수를 사용하지 않는 로우 타입
```

### 로우 타입은 사용하지 않기
* **로우 타입은 제네릭 타입의 타입 정보가 제거된 것처럼 동작하며, 이는 제네릭이 도입된 Java 5 이전 코드와의 호환성을 위해 제공**되는 개념이다.
* 컬렉션을 예로 들어, 로우 타입 컬렉션은 의도와 다른 클래스의 인스턴스를 추가하더라도 오류가 발생하지 않는다.
  * 대신 인스턴스를 읽어들이며 형변환하는 과정에서 오류가 발생할 것이다.
* **오류는 가능한 한 발생 즉시 발견하는 것이 좋으며, 컴파일 시점에 발견되는 것이 가장 이상적**이다.
* 로우 타입의 경우, 런타임에서 발생한 오류의 발생 시점과 원인 코드가 물리적으로 먼 곳에 떨어질 가능성이 높고, 이를 디버깅하기가 어려워진다.
  * 해당 컬렉션에서 사용해야 할 클래스를 주석으로 명시한다고 한들, 컴파일러는 주석을 이해하지 못하므로 의미가 없다.
* **제네릭을 활용하면 사용해야할 클래스 타입 정보가 주석이 아닌 타입 선언 자체에 정의**된다.
  * 컴파일러는 해당 컬렉션이 다뤄야할 타입을 명확하게 인지하며, 다른 타입의 클래스를 사용하려는 시도가 발견되면 오류를 발생시킨다.
  * 때문에 **아무런 오류 없이 컴파일된다면 해당 코드의 정상성 역시 보장**된다.
  * 컴파일러는 또한 요소를 읽어들이는 모든 코드에 보이지 않는 형변환을 추가하여 코드의 성공을 보장한다.
* **타입 매개 변수가 없는 제네릭 타입인 로우 타입을 사용하는 것은 언어 차원에서 오류를 발생시키지는 않지만, 절대 사용하지 말아야 한다**.
  * **로우 타입은 제네릭이 보장하는 안전성과 표현력을 활용할 수 없는 방식이다.**.
* **실제 타입 매개변수가 무엇이될지 신경쓰고 싶지 않아 로우 타입을 적용하고 싶은 상황이라면, 대신 물음표 기호를 적용한 매개변수화 타입을 활용**한다.
  * ?는 비한정적 와일드카드 타입으로, 어떠한 타입도 담을 수 있는 범용적인 제네릭 타입이다.
* 비한정적 와일드카드 타입은 안전하고, 로우 타입은 안전하지 않다.
  * 예를 들어, **로우 타입 컬렉션에는 아무런 요소나 추가할 수 있지만, 비한정적 와일드카드 타입 컬렉션에는 null 이외의 요소를 추가할 수 없다**.
  * 이러한 제약을 따르고 싶지 않다면 제네릭 메소드 또는 한정적 와일드카드 타입을 사용해야 한다.
```
class Test {
    public static void testWildCard(List<?> list) {
        // 아래와 같이 사용할 수 없다. 비한정적 와일드카드 타입에 어떤 타입이 적용될지 알 수 없기 때문이다.
        // list.add("Hello");
        list.add(null);
    }
    public static void testRaw(List list) {
        // 반면 로우 타입은 모든 타입을 마음대로 추가할 수 있어 안전성이 보장되지 않는다.
        list.add("Hello");
        list.add(null);
    }
}
```
* 반면 로우 타입은 다음과 같은 상황에 사용이 권장된다.
  1. class 리터럴을 명시하는 경우, 매개변수화 타입을 사용할 수 없으므로 로우 타입을 사용한다.
     * 예를 들어 List<String>.class는 사용할 수 없으므로 List.class로 명시한다.
  2. **instanceof 연산자에서는 로우 타입을 사용**한다.
     * 이는 런타임 시점에서 제네릭 타입 정보가 지워지므로 instanceof 연산자는 비한정적 와일드카드 타입 이외의 매개변수화 타입에 적용할 수 없기 때문이다. 
     * 로우 타입과 비한정적 와일드카드 타입은 instanceof 연산자에서 완전히 똑같이 동작하므로, 코드의 가독성을 위해 로우 타입이 권장된다.

### 로우 타입의 결론
* 로우 타입을 사용하면 런타임에 예외가 발생할 수 있으므로 사용을 지양한다.
* 로우 타입은 제네릭 도입 이전의 코드와의 호환성을 위해 제공되는 기능에 불과하다.
* List<Object>는 모든 타입의 객체를 저장할 수 있는 매개변수화 타입이며, 제네릭 타입이므로 안전하다.
* List<?>는 어떤 특정한 타입의 객체만 저장할 수 있는 와일드카드 타입이며, 제네릭 타입이므로 안전하다.
* List는 로우타입이며, 제네릭 타입 시스템에 속하지 않아 안전하지 않다.

### 비검사 경고는 제거하기
* 제네릭을 사용하면 수많은 컴파일러 경고와 마주치게 된다.
* 이러한 비검사 경고는 대부분 쉽게 제거할 수 있지만, 곧바로 해결되지 않는 경고도 포기하지 말아야 한다.
  * **가능한 한 모든 비검사 경고를 제거하여 코드의 타입 안정성은 보장**해야 한다.
  * 이를 통해 런타임의 ClassCastException 발생 가능성을 없애고, 코드의 정상성을 보장할 수 있다.
* 경고를 제거할 수는 없지만, 로직상 타입 안전하다고 확신이 드는 경우에는 @SuppressWarnings("unchecked") 어노테이션을 활용한다.
  * 해당 어노테이션을 통해 경고를 숨길 수 있지만, 타입 안전성이 검증되지 않은 경우에는 여전히 런타임 에러 발생 가능성이 존재하게 된다.
  * 그러나 **안전하다고 검증된 비검사 경고를 그대로 두면 수 많은 비검사 경고에 진짜 중요한 문제를 알리는 경고가 묻힐 수 있다**.
* @SuppressWarnings 어노테이션은 어떤 선언에도 적용할 수 있지만, 가능한 한 좁은 범위에 적용하는 것이 바람직하다.
  * 지역 변수 선언에 적용하는 것이 이상적이며, 절대 클래스 전체에 적용하지 말아야 한다.
  * 이를 위해 **새로운 지역 변수를 선언해야 하는 수고가 들 수 있지만, @SuppressWarnings 어노테이션에는 그만한 가치가 있다**.
* @SuppressWarnings 어노테이션을 사용하는 경우, 해당 경고를 무시해도 되는 이유를 주석으로 작성하는 것이 바람직하다.
  * 이를 통해 다른 개발자가 해당 코드를 잘 못 수정하여 타입 안정성을 잃게 되는 상황을 방지할 수 있다.
  * 코드가 안전하다는 근거를 찾기 어렵더라도 끈기를 갖고 찾아내야 하며, 이 과정에서 생각하지 못한 결함을 찾아낼 수도 있다.

### 비검사 경고의 결론
* 모든 비검사 경고는 런타임에서 발생할 수 있는 ClassCastException 가능성을 의미하므로, 무시하지 말고 최대한 제거해야 한다.
* 경고를 없앨 방법을 찾아낼 수 없다면, 코드의 타입 안전성을 증명하고 최대한 범위를 줄인 @SuppressWarnings("unchecked") 어노테이션을 적용한다.
  * @SuppressWarnings 어노테이션으로 경고를 숨기려는 근거는 반드시 주석으로 작성해야 한다.
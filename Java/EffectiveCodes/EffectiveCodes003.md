# EffectiveCodes
## 2022-03-01 Tue

## 클래스와 인터페이스
* 클래스와 인터페이스는 추상화의 기본 단위이며, Java의 핵심이다.
  * 때문에 Java에서는 클래스와 인터페이스 설계에 사용하는 강력한 요소를 많이 지원한다.
* 이러한 요소를 적절히 활용하여 클래스와 인터페이스를 쓰기 편하고, 견고하고, 유연하게 만들 수 있다.

### 클래스와 멤버의 접근 권한은 최소화하기
* **잘 설계된 컴포넌트와 그렇지 못한 컴포넌트의 가장 큰 차이는 클래스 내부 데이터와 구현 정보가 외부 컴포넌트로부터 얼마나 잘 숨겨지느냐**에 달렸다.
  * 잘 설계된 컴포넌트는 내부 구현을 완벽히 숨기고 구현과 API를 분리한다.
  * 이러한 컴포넌트는 오직 API를 통해서만 다른 컴포넌트와 소통하며, 서로의 내부 동작 방식에는 전혀 개의치 않아야 한다.
* 이렇듯 **정보 은닉, 캡슐화는 소프트웨어 설계의 근간**이 되어 준다.
  * 정보 은닉은 시스템을 구성하는 컴포넌트들을 독립시켜 개발, 테스트, 최적화, 분석, 수정을 개별적으로 할 수 있도록 뒷받침하는 역할을 수행한다.
* **Java는 언어 차원에서 정보 은닉을 위한 다양한 장치를 제공하며, 핵심은 접근 제한자**이다.
* 정보 은닉을 위해 접근 제한자를 사용하는 기본 원칙은 매우 간단하다.
```
> 모든 클래스와 멤버의 접근성을 가능한 한 최대한 좁혀야 한다.
> 소프트웨어가 올바르게 동작하는 한, 가능한 최저의 접근 수준을 부여해야만 한다.
```
* 톱 레벨 클래스와 인터페이스에 부여할 수 있는 접근 수준은 다음과 같다.
  1. package private: 패키지 내부에서만 사용할 수 있는 내부 구현으로 취급한다. 
     * **패키지 외부에서 사용할 이유가 없는 클래스는 package private으로 선언**해야 한다.
  2. public: 패키지 외부에서 제한 없이 사용할 수 있는 공개 API가 된다.
* **package private의 경우, 내부 구현이므로 클라이언트 코드에 피해를 주는 일 없이 언제든지 수정 및 교체, 제거가 가능**하다.
  * 반면 **public으로 선언한 경우 공개 API가 되므로, 하위 호환을 위해 영원히 관리해야** 한다.
* package private 클래스 역시 특정한 클래스에서만 접근한다면, 해당 클래스 내부의 private static 클래스로 중첩시켜 캡슐화할 수 있다.
* 공개 API로 사용할 클래스를 신중히 결정한 후, 그 외의 모든 멤버를 private으로 설정한다.
  * 이후에는 같은 패키지에서 접근이 필요한 클래스에 한해 package private으로 변경해준다.
  * 이러한 **권한 해제 작업이 반복된다면, 컴포넌트를 더 분해해야 하는 것은 아닌지 다시 확인**한다.
* private과 package private은 내부 구현에 속하므로 공개 API의 멤버더라도 영향을 크게 주지 않는다.
  * 반면 protected 멤버는 접근 가능한 범위가 엄청나게 넓어지고 공개 API의 일부로서의 지원 대상이 된다.
  * 따라서 **protected 멤버는 적을 수록 좋다**.
* **부모 클래스의 메소드를 재정의할 때는 부모 클래스의 접근 제한자보다 좁게 설정할 수 없다는 제약은 멤버 접근성을 좁히지 못하도록 방해**한다. 
  * 아쉽게도 해당 제약은 리스코프 치환 원칙을 준수하기 위해 필수적이다.
* 코드를 테스트하기 위해 private 멤버의 접근 제한자를 public으로 풀어두지 말아야 한다.
  * 그보다는 package private을 적용하고, 같은 패키지에 테스트 코드를 배치하는 방법을 활용한다.
* public 클래스의 필드는 되도록 public이 아니어야 한다.
  * public 가변 필드를 갖는 클래스는 일반적으로 스레드 안전하지 않다.
  * **예외적으로, 클래스의 추상 개념을 완성하기 위해 필요한 정적 필드는 public static final이어도 좋다**.
* **길이가 0이 아닌 배열은 모두 변경이 가능하므로, 클래스에서 public static final 배열 필드를 두지 말아야 한다**.
  * 또는 이러한 필드를 반환하는 접근자 메소드도 제공하지 말아야 한다.
  * 반드시 배열 필드를 두어야 한다면, 필드를 private으로 두고 public 불변 리스트를 제공하거나 복사본을 반환하는 public 메소드를 정의한다.
* **Java 9에서는 모듈 시스템이 도입**되었으며, 두가지 암묵적인 접근 수준이 추가되었다.
  * **모듈은 클래스를 묶은 패키지들의 묶음**이다.
* 모듈은 자신이 포함하는 패키지 중 공개할 것들을 별도의 .java 파일에 선언한다.
  * 이 경우, **패키지 내부의 protected 또는 public 멤버도 해당 패키지가 공개되지 않았다면 외부 모듈에서는 접근할 수 없다**.
    * 모듈 내부에서는 일반적인 접근 제어자의 규칙을 따른다.
  * **모듈 시스템을 적절히 활용하면 클래스를 외부에 공개하지 않으면서도, 모듈 내부의 패키지 사이에서는 자유로운 공유가 가능**하다.
* 숨겨진 패키지 내부의 public과 protected 멤버는 일반적인 접근 제어자의 수준을 따르지 않는, 암묵적으로 추가된 접근 수준이다.
  * 다시 말해, 숨겨진 패키지 내부의 public은 공개 API 형식이지만 외부 모듈에서는 접근할 수 없기에 기존의 public과는 분명히 다른 제한 수준을 갖는다.
  * **반드시 이런 형태의 접근 수준을 적용해야만 하는 경우는 흔치 않으며, 그마저도 대부분 클래스를 패키지 내부에서 재배치하는 것으로 해결**된다.

### 접근 권한의 결론
* 프로그램을 구성하는 각 요소의 접근성은 가능한 한 최소로 하되, 필요한 것만 골라 public API로 공개한다.
* **public 클래스는 반드시 필요한 public static final 필드 외의 public 필드를 갖지 않아야** 한다.
  * 이 때, public static final 필드가 참조하는 객체 역시 불변인 점을 확실히 해야 한다.

### public 클래스에서는 public 필드가 아닌 접근자를 사용하기
* **public 클래스는 절대 가변적인 필드를 public하게 노출하지 말아야** 한다.
* 인스턴스 필드만을 모아두는 외에는 아무런 역할을 수행하지 못하는 클래스를 작성할 때가 있다.
  * 이러한 클래스는 public 필드를 외부에서 직접 접근할 수 있으므로 캡슐화의 이점을 전혀 제공하지 못한다.
* public 클래스라면 public 필드를 private 필드로 바꾸고 public한 접근자를 제공하도록 수정한다.
  * **이를 통해 클래스 내부 표현 방식을 언제든지 바꿀 수 있는 유연성을 얻을 수 있게 된다**.
* 반면 **package private 클래스 또는 private 중첩 클래스는 데이터 필드를 public으로 노출해도 좋다**.
  * 이러한 방식으로 인해 클라이언트의 코드가 클래스 내부 표현 방식에 종속되지만, 어차피 클라이언트 코드도 해당 클래스를 포함하는 패키지 내부에서만 동작한다.
    * private 클래스는 한 단계 더 나아가 해당 클래스가 포함되는 외부 클래스까지로 접근이 제한된다.
  * **결과, 이러한 방식을 채택함으로써 접근자를 제공하는 방식보다 훨씬 깔끔한 사용이 가능**하다.
  * 즉, 어차피 외부에서 접근할 방법이 없는 코드이므로 내부적으로 더 유지보수가 좋은 방식을 선택하는 것이다.
* java.awt.package의 Point, Dimension 클래스 등은 이러한 규칙을 지키지 못하는 대표적인 사례이다.
  * 이러한 클래스는 내부를 노출함으로써 발생하는 심각한 성능 문제를 해결하지 못하므로, 절대 따라하지 않도록 한다.
* **public 클래스의 필드가 불변하다면 직접 노출하는 단점이 줄어들 수 있지만, 여전히 대부분의 문제가 해결되지 않아 불안정**하다.
  * 예를 들어, API를 직접 수정하지 않고서는 표현 방식을 변경할 수 없거나 필드를 읽어들일 때의 부수 작업을 수행할 수 없다.
  * 이는 내부 정보가 직접적으로 노출되고, 클라이언트가 이러한 내부 정보인 필드를 직접 참조하는 식으로 코드가 작성되기 때문이다.

### public 클래스와 public 필드의 결론
* public 클래스는 절대로 가변 필드를 public으로 직접 노출하지 않도록 한다.
* 불변 필드라면 public한 노출에서 기인하는 문제가 줄어들지만, 완전히 제거되지는 않는다.
* **반면 package private 클래스나 private 중첩 클래스는 불변, 가변에 관계 없이 필드를 public하게 노출하는 것이 유지 보수에 더 좋을 수 있다**.

### 변경 가능성은 최소화하기
* 인스턴스 내부의 값을 수정할 수 없는 클래스는 불변 클래스이며, 불변 클래스의 값은 객체가 파괴될 때까지 달라지지 않는다.
  * 이러한 **불변 클래스는 가변 클래스보다 설계 및 구현, 사용이 훨씬 쉬우며 안전**하다.
* 클래스를 불변하게 만들기 위해서는 다음의 규칙을 따르도록 한다.
  1. 객체의 상태를 변경하는 메소드를 제공하지 않는다.
  2. 클래스를 확장할 수 없도록 한다.
  3. 모든 필드를 final로 선언한다.
  4. 모든 필드를 private으로 선언한다.
  5. 자신 외에는 내부의 가변 컴포넌트에 접근할 수 없도록 한다.
     * 예를 들어, **클래스에 가변 객체를 참조하는 필드가 하나라도 있다면 클라이언트 코드에서는 해당 객체의 참조를 얻을 방법이 없어야** 한다.
* **클래스 내부의 가변 컴포넌트는 클라이언트가 객체 참조를 얻을 수도, 접근자 메소드가 값을 그대로 반환하지도 않아야** 한다.
  * 반드시 생성자, 접근자 모두에서 방어적 복사를 수행해야 한다.
* **불변 클래스는 근본적으로 스레드 안전하며, 별도의 동기화 작업이 필요 없다**.
  * 이는 클래스를 스레드 안전하게 만드는 가장 쉬운 방법이다.
* **불변 클래스는 자주 사용되는 인스턴스를 캐싱하여 같은 인스턴스를 중복 생성하지 않도록 하는 정적 팩토리를 제공**할 수 있다.
  * 기본 타입에 대응되는 래퍼 클래스와 BigInteger 등이 여기에 해당한다.
* **이러한 정적 팩토리의 활용은 여러 클라이언트 코드가 인스턴스를 공유하도록 하여 메모리 효율을 높이고 쓰레기 처리 비용을 낮춘다**.
  * 때문에 **새로운 클래스를 설계할 때 public 생성자를 제공하는 대신 정적 팩토리 패턴을 적용하면, 필요에 따라 캐싱 기능을 덧붙일 수 있다**.
* **불변 클래스는 자유롭게 공유가 가능하며, 방어적 복사도 필요가 없다**.
  * 때문에 불변 객체는 clone 메소드나 복사 생성자를 제공할 필요가 없다.
  * String 클래스의 복사 생성자는 이러한 사실을 이해하지 못한 초창기에 작성된 것이므로, 되도록 사용하지 않아야 한다.
* 불변 클래스는 그 자체로 실패 원자성을 제공한다.
  * 실패 원자성: 메소드에서 예외가 발생한 후에도 객체는 여전히 메소드 호출 전과 같은 상태를 유지해야한다는 특징이다.
* **불변 클래스에서는 값이 다른 경우에는 항상 독립된 객체를 생성해야 한다는 단점**이 있다.
* 불변 클래스의 원하는 객체를 완성하기까지의 단계가 많고, 중간 단계에서 만들어진 객체들이 모두 버려져야 한다면 성능 문제가 뒤따른다.
  * 이를 해결하는 방법은 크게 두가지이다.
  1. 흔히 사용할 수 있는 다단계 연산을 예측하고 기본 기능으로 제공한다.
     * 클라이언트에서 수행할 연산을 모두 정확히 예측할 수 있다면, package private한 가변 동반 클래스를 제공한다.
     * 예를 들어 BigInteger 클래스는 이러한 동작을 모두 정확히 예측한다.
  2. 클라이언트의 연산을 예상할 수 없다면 가변 동반 클래스 자체를 public으로 제공한다.
    * 예를 들어 String 클래스는 StringBuilder 클래스를 사용자에게 제공한다.
* **클래스를 상속하지 못하게 하는 가장 쉬운 방법은 final 클래스로 정의하는 것이지만, public 정적 팩토리를 제공하는 것이 더 유연**하다.
  * **이 경우, 모든 생성자를 private 또는 package private으로 정의하고 public 정적 팩토리를 제공**한다.
  * 이 방식은 언제나 최선인 경우가 많다!
* 정적 팩토리 방식은 public, protected 생성자가 없으므로 클래스의 확장이 사실상 불가능하다.
  * 반면 다수의 구현 클래스를 활용한 유연성을 제공하고, 이후의 릴리스에서 캐싱 기능을 추가하는 성능 향상을 적용할 수도 있다.

### 변경 가능성의 결론
* 클래스는 반드시 필요한 경우가 아니라면 불변이어야 한다.
* 불변 클래스는 특정 상황에서의 잠재적인 성능 저하를 제외하고는 장점 뿐인 방식이다.
  * 성능 저하는 불변 클래스와 쌍을 이루는 가변 동반 클래스를 public으로 제공하는 방식으로 해결할 수 있다.
* 게터가 있다고 해서 항상 세터를 만들 필요는 없다.
* **모든 클래스를 불변으로 만들 수는 없지만, 가변 클래스 역시 변경 가능한 부분은 최소화**해야 한다.
* 다른 **합리적인 이유가 없다면, 클래스의 모든 필드는 private final로 정의**하는 것이 좋다.
  * 이를 위해 **생성자는 항상 초기화가 완벽히 완료된 상태의 객체를 생성**해야만 한다.
* 다른 **합리적인 이유가 없다면 생성자와 정적 팩토리 에외는 public 초기화 메소드를 제공하지 않아야** 한다.
  * 객체의 재활용을 위해 상태를 다시 초기화하는 메소드 역시 복잡성만을 높일 뿐, 성능적인 이점은 제공하지 못한다.

## 2022-03-02 Wed
### 상속보다 컴포지션을 사용하기
* 상속은 코드를 재사용하기 위한 강력한 수단이지만, 항상 최선은 아니다.
  * 일반적인 구체 클래스를 패키지 경계를 넘어서 상속하는 것은 매우 위험하다.
* 상속은 캡슐화를 깨트리며, 상위 클래스의 내부 구현이 바뀌면 코드 한 줄 건드리지 않은 하위 클래스가 오동작할 수 있다.
* 상속이 깨지기 쉬운 이유는 대부분 하위 클래스에서 메소드를 재정의하는 과정에서 발생한다.
  1. 상위 클래스의 내부 구현이 바뀌는 경우, 해당 메소드를 사용하는 다른 메소드가 영향을 받을 수 있다.
  2. 새로운 메소드를 추가하더라도, 상위 클래스에 우연히 동일한 메소드가 추가되면 내가 작성한 코드는 컴파일되지 않는다.
* **이러한 문제점들을 피해가기 위해, 구체 클래스를 확장하는 대신 내부의 private 필드로 참조하는 컴포지션을 적용할 수 있다**.
  * 기존 클래스는 새로운 클래스의 private 필드로 참조된다.
  * 새로운 클래스의 메소드들은 기존 클래스의 메소드를 호출하는 forwarding 메소드로 작성한다.
  * 이러한 컴포지션과 전달(forwarding)의 조합은 넓은 의미에서 위임이라고 할 수 있다.
  * 이렇듯 기존 클래스의 인스턴스를 감싸는 클래스는 래퍼 클래스라고 부를 수 있으며, 새로운 기능을 덧붙이는 경우에는 데코레이터 패턴이 된다.
* **컴포지션을 통해 새로운 클래스는 기존 클래스의 내부 구현 방식에서 벗어날 수 있게 된다**.
  * 당연히 기존 클래스에 메소드가 추가되더라도 영향을 받지 않는다.
* **전달 메소드와 래퍼 클래스를 사용함에 있어 성능이나 메모리 사용량에 주는 영향은 사실상 없으므로, 해당 방식은 단점이 거의 없다**. 
* 전달 메소드를 작성하는 작업이 지루할지 모르지만, 데코레이터 패턴을 적용한 전달 클래스를 인터페이스마다 하나만 만들어두면 원하는 기능은 쉽게 덧붙일 수 있다.
* **상속은 반드시 하위 클래스가 상위 클래스의 진짜 자식인 경우에만 적용**한다.
  * 즉, is-a 관계를 반드시 지키는 경우에만 상속을 적용하고, 그렇지 않은 경우에는 내부의 private 필드를 활용한 상기 방식을 사용한다.
  * 이러한 사례는 Java 라이브러리의 Stack, Properties에서도 찾아볼 수 있다. 예를 들어, Stack은 Vector가 아닌데도 확장하고 있다!
* 컴포지션을 적용해야 하는 상황에서 상속을 적용하는 것은 내부 구현을 불필요하게 노출하는 것과 같다.
  * 결과 API는 내부의 세부 사항인 구현에 종속된다.
  * 무엇보다, **외부에서 클래스 내부의 코드에 접근 및 수정이 가능하다는 점이 가장 위험**하다.

### 컴포지션의 결론
* 상속은 코드 재사용 측면에서 강력하지만, 캡슐화를 해치는 문제가 있다.
* 상속은 상위 클래스와 하위 클래스의 관계가 is-a일 때만 적용이 가능하다.
  * **이 경우에도 하위 클래스의 패키지가 상위 클래스와 다르거나, 상위 클래스가 상속을 위해 설계되지 않았다면 위험**하다.
* **확장하려는 클래스에 결함이 있는 경우, 상속받은 하위 클래스에도 이러한 결함이 그대로 전파**된다.
  * **컴포지션은 오히려 이러한 결함을 숨기는 API를 새롭게 설계하여 대처할 수 있다**.
* 상속의 취약점에 대처하려면 컴포지션과 전달을 사용하자.
  * 특히 **래퍼 클래스는 상속받은 하위 클래스보다 견고하므로, 래퍼 클래스로 구현할 인터페이스가 있다면 더욱 컴포지션이 적절**하다.

### 상속을 고려하여 설계하고 문서화하기
* 상속을 고려한 설계와 문서화를 위해, 상속용 클래스는 재정의할 수 있는 메소드들을 내부적으로 어떻게 이용하는지 문서로 남겨야 한다.
  * 재정의할 수 있는 메소드란, public / protected 중 final이 아닌 모든 메소드이다.
* 상속용 클래스는 내부에 포함된 재정의할 수 있는 메소드를 호출할 수 있는 모든 상황을 문서로 남겨야 한다.
* 이러한 문서화 규약에 의해 다음과 같은 모순이 발생한다.
  * **이러한 모순은 상속이 캡슐화를 해치는 개념이기 때문에 발생**한다.
```
> 좋은 API 문서란 '어떻게'가 아닌 '무엇을'하는지 설명해야 한다.
> 상속용 클래스는 재정의 가능한 메소드를 호출할 수 있는 모든 상황을 문서로 남겨야 한다.
  > 즉, 이는 '무엇을'이 아닌 '어떻게'와 관련된 내용이다.
```
* 이렇듯 **클래스를 안전하게 상속할 수 있도록 하기 위해서는 원래라면 작성하지 않았어야 할 내부 구현 방식을 자세히 설명해야 한다**.
* 상속을 하기로 결정했다면, 하위 클래스를 작성하는 개발자가 사용하기 편리할만한 메소드를 미리 예측하여 protected로 제공해야할 수도 있다.
  * 사용하기 편리할만한 기능을 제공하기 위해 샹쇽용 클래스를 시험하는 방법은 직접 하위 클래스를 3개 정도 만들어보는 것이 유일한 방법이다.
  * 이 때, 하위 클래스 중 하나 이상은 제 3자에 의해 작성되어야 한다.
* **상속용 클래스의 생성자는 어떠한 방식으로든 재정의 가능한 메소드를 호출하지 않아야 한다**.
  * 상위 클래스의 생성자는 하위 클래스가 하위 클래스 생성자에 의해 초기화되기 전에 재정의 가능한 메소드를 호출하므로, 클래스가 원하는대로 동작하지 않는다.
  * 아래의 예시는 Child 인스턴스 생성시 Parent() > hello() > Child() 순으로 호출되므로, final인 name이 null인 시점이 명시적으로 드러난다.
  * private, final, static 메소드는 재정의가 불가능하므로 생성자에서 호출해도 무방하다.
```
class Parent {
    Parent() {
        hello();
    }
    void hello() {}
}

class Child extends Parent {
    private final String name;
    Child() {
        this.name = "injuk";
    }
    @Override void hello() {
        System.out.println(this.name);
    }
}
```
* 이렇듯 클래스를 상속용으로 설계하려면 엄청난 노력이 들고, 클래스 자체에 안기는 제약도 크다.
* 상속용으로 설계되지 않은 일반 클래스 또한 상속시에는 마찬가지 상위 클래스 수정으로 인한 하위 클래스의 오동작에서 자유로울 수 없다.
* 때문에 **상속용으로 설계되지 않은 클래스는 다음과 같은 방식으로 상속 자체를 금지하는 것이 바람직**하다.
  1. 클래스를 final로 만든다.
  2. 클래스의 생성자를 private이나 package private으로 작성하고, public한 정적 팩토리 메소드를 제공한다.
  * final은 쉬운 적용이 가능하며, 정적 팩토리는 장기적인 유연성을 둘 수 있다.
  * 상속을 금지하기 위해서는 둘 중 어느 방법을 선택해도 무방하다.
* 래퍼 클래스 패턴 역시 기능을 추가하기 위해 상속 대신 사용할 수 있을만한 대안으로 볼 수 있다.
* 어떻게 해서라도 **구체 클래스의 상속이 반드시 필요한 경우, 클래스 내부에서는 재정의 가능한 메소드를 호출하지 않고 이를 문서로 남겨야 한다**.
  * 이러한 방법을 활용하면 메소드를 재정의해도 다른 메소드에 영향을 주지 않으므로, 상속해도 그리 위험하지 않은 클래스를 작성할 수 있다.

### 상속과 문서화의 결론
* 상속용 클래스를 설계하려면 클래스 내부에서 자신의 메소드를 활용하는 모든 상황을 문서로 남겨야 한다.
* 한 번 문서화한 내용은 해당 클래스를 사용하는 한은 반드시 지켜야 한다.
* 또는 하위 클래스를 작성할 때 편리하게 사용할만한 메소드를 미리 예측하여 protected로 제공해야할 수도 있다.
* 이렇듯 **상속을 위한 설계는 매우 어려우므로, 클래스를 반드시 확장해야하는 경우가 아니라면 상속을 금지하는 것이 좋다**.
  * 상속을 금지하려면 클래스를 final로 정의하거나, 외부에서 접근할 수 있는 생성자를 제공하지 않도록 한다.

### 추상 클래스보다는 인터페이스를 활용하기
* Java의 다중 구현 메커니즘은 인터페이스와 추상 클래스 두가지 형태로 제공된다.
  * Java 8에서 인터페이스에 default 메소드가 추가됨에 따라 두 방식 모두 인스턴스 메소드를 구현 형태로 제공할 수 있다.
* 반면 추상 클래스를 구현하는 클래스는 반드시 추상 클래스의 하위 클래스가 되어야 한다.
  * **이는 다중 상속을 제공하지 않는 Java 특성 상 인터페이스에 비교하여 제약을 갖는 것**과 같다.
* **추상 클래스는 이미 작성된 기존 클래스가 이를 확장하도록 끼워 넣기 어렵지만, 인터페이스는 기존 클래스에도 쉽게 추가하여 구현**할 수 있다.
* 인터페이스는 믹스인을 정의하기에도 적절하다.
  * 믹스인 인터페이스는 클래스가 원래의 타입 이외에도 어떠한 기능을 제공하는지 선언하는 효과를 준다.
  * 추상 클래스는 기존 클래스에 덧씌우는 형태로 작성할 수 없으므로 믹스인에 적합하지 않다.
* **인터페이스로는 계층 구조가 없는 타입 구조를 정의할 수 있다**.
  * 클래스로 같은 구조를 만들기 위해서는 가능한 조합 전부를 클래스로 작성해야 한다.
* **인터페이스 메소드 중 구현 방법이 명백한 것이 있다면, 이를 default 메소드로 제공할 수도 있다**.
  * default 메소드는 자신이 작성하지 않은 인터페이스에는 추가할 수 없다.
* **인터페이스와 추상 골격 구현 클래스를 함께 제공하는 것으로 인터페이스와 추상 클래스 모두의 장점을 취할 수도 있다**.
  * **인터페이스로는 타입과 default 메소드를 정의하고, 골격 구현 클래스는 기반 메소드외의 필요한 메소드를 모두 구현**한다.
  * 이는 템플릿 메소드 패턴에 해당하며, 사용자는 골격 구현 클래스를 확장하는 것으로 인터페이스를 구현하기 위한 대부분의 작업을 마치게 된다.

### 인터페이스 사용의 결론
* 일반적으로 다중 구현용 타입에는 인터페이스가 가장 적합한 방법이다.
* 복잡한 인터페이스라면 구현하는 수고를 덜어줄 골격 구현을 함께 제공하는 방법을 고려하는 것이 바람직하다.
* 구현이 명백히 예측되는 메소드는 골격 구현의 default 메소드로 제공하여 인터페이스를 구현하는 곳에서 활용할 수 있도록 한다.
  * 이 때, equals 등 Object의 메소드는 default 메소드로 작성하지 않아야 한다.
  * 반면 인터페이스 자체적인 제약으로 구현히 명백할 수 없는 메소드는 추상 클래스 형태로 골격 구현을 제공하는 경우가 많다.
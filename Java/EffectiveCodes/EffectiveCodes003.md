# EffectiveCodes
## 2022-03-01 Tue

## 클래스와 인터페이스
* 클래스와 인터페이스는 추상화의 기본 단위이며, Java의 핵심이다.
  * 때문에 Java에서는 클래스와 인터페이스 설계에 사용하는 강력한 요소를 많이 지원한다.
* 이러한 요소를 적절히 활용하여 클래스와 인터페이스를 쓰기 편하고, 견고하고, 유연하게 만들 수 있다.

### 클래스와 멤버의 접근 권한은 최소화하기
* **잘 설계된 컴포넌트와 그렇지 못한 컴포넌트의 가장 큰 차이는 클래스 내부 데이터와 구현 정보가 외부 컴포넌트로부터 얼마나 잘 숨겨지느냐**에 달렸다.
  * 잘 설계된 컴포넌트는 내부 구현을 완벽히 숨기고 구현과 API를 분리한다.
  * 이러한 컴포넌트는 오직 API를 통해서만 다른 컴포넌트와 소통하며, 서로의 내부 동작 방식에는 전혀 개의치 않아야 한다.
* 이렇듯 **정보 은닉, 캡슐화는 소프트웨어 설계의 근간**이 되어 준다.
  * 정보 은닉은 시스템을 구성하는 컴포넌트들을 독립시켜 개발, 테스트, 최적화, 분석, 수정을 개별적으로 할 수 있도록 뒷받침하는 역할을 수행한다.
* **Java는 언어 차원에서 정보 은닉을 위한 다양한 장치를 제공하며, 핵심은 접근 제한자**이다.
* 정보 은닉을 위해 접근 제한자를 사용하는 기본 원칙은 매우 간단하다.
```
> 모든 클래스와 멤버의 접근성을 가능한 한 최대한 좁혀야 한다.
> 소프트웨어가 올바르게 동작하는 한, 가능한 최저의 접근 수준을 부여해야만 한다.
```
* 톱 레벨 클래스와 인터페이스에 부여할 수 있는 접근 수준은 다음과 같다.
  1. package private: 패키지 내부에서만 사용할 수 있는 내부 구현으로 취급한다. 
     * **패키지 외부에서 사용할 이유가 없는 클래스는 package private으로 선언**해야 한다.
  2. public: 패키지 외부에서 제한 없이 사용할 수 있는 공개 API가 된다.
* **package private의 경우, 내부 구현이므로 클라이언트 코드에 피해를 주는 일 없이 언제든지 수정 및 교체, 제거가 가능**하다.
  * 반면 **public으로 선언한 경우 공개 API가 되므로, 하위 호환을 위해 영원히 관리해야** 한다.
* package private 클래스 역시 특정한 클래스에서만 접근한다면, 해당 클래스 내부의 private static 클래스로 중첩시켜 캡슐화할 수 있다.
* 공개 API로 사용할 클래스를 신중히 결정한 후, 그 외의 모든 멤버를 private으로 설정한다.
  * 이후에는 같은 패키지에서 접근이 필요한 클래스에 한해 package private으로 변경해준다.
  * 이러한 **권한 해제 작업이 반복된다면, 컴포넌트를 더 분해해야 하는 것은 아닌지 다시 확인**한다.
* private과 package private은 내부 구현에 속하므로 공개 API의 멤버더라도 영향을 크게 주지 않는다.
  * 반면 protected 멤버는 접근 가능한 범위가 엄청나게 넓어지고 공개 API의 일부로서의 지원 대상이 된다.
  * 따라서 **protected 멤버는 적을 수록 좋다**.
* **부모 클래스의 메소드를 재정의할 때는 부모 클래스의 접근 제한자보다 좁게 설정할 수 없다는 제약은 멤버 접근성을 좁히지 못하도록 방해**한다. 
  * 아쉽게도 해당 제약은 리스코프 치환 원칙을 준수하기 위해 필수적이다.
* 코드를 테스트하기 위해 private 멤버의 접근 제한자를 public으로 풀어두지 말아야 한다.
  * 그보다는 package private을 적용하고, 같은 패키지에 테스트 코드를 배치하는 방법을 활용한다.
* public 클래스의 필드는 되도록 public이 아니어야 한다.
  * public 가변 필드를 갖는 클래스는 일반적으로 스레드 안전하지 않다.
  * **예외적으로, 클래스의 추상 개념을 완성하기 위해 필요한 정적 필드는 public static final이어도 좋다**.
* **길이가 0이 아닌 배열은 모두 변경이 가능하므로, 클래스에서 public static final 배열 필드를 두지 말아야 한다**.
  * 또는 이러한 필드를 반환하는 접근자 메소드도 제공하지 말아야 한다.
  * 반드시 배열 필드를 두어야 한다면, 필드를 private으로 두고 public 불변 리스트를 제공하거나 복사본을 반환하는 public 메소드를 정의한다.
* **Java 9에서는 모듈 시스템이 도입**되었으며, 두가지 암묵적인 접근 수준이 추가되었다.
  * **모듈은 클래스를 묶은 패키지들의 묶음**이다.
* 모듈은 자신이 포함하는 패키지 중 공개할 것들을 별도의 .java 파일에 선언한다.
  * 이 경우, **패키지 내부의 protected 또는 public 멤버도 해당 패키지가 공개되지 않았다면 외부 모듈에서는 접근할 수 없다**.
    * 모듈 내부에서는 일반적인 접근 제어자의 규칙을 따른다.
  * **모듈 시스템을 적절히 활용하면 클래스를 외부에 공개하지 않으면서도, 모듈 내부의 패키지 사이에서는 자유로운 공유가 가능**하다.
* 숨겨진 패키지 내부의 public과 protected 멤버는 일반적인 접근 제어자의 수준을 따르지 않는, 암묵적으로 추가된 접근 수준이다.
  * 다시 말해, 숨겨진 패키지 내부의 public은 공개 API 형식이지만 외부 모듈에서는 접근할 수 없기에 기존의 public과는 분명히 다른 제한 수준을 갖는다.
  * **반드시 이런 형태의 접근 수준을 적용해야만 하는 경우는 흔치 않으며, 그마저도 대부분 클래스를 패키지 내부에서 재배치하는 것으로 해결**된다.

### 접근 권한의 결론
* 프로그램을 구성하는 각 요소의 접근성은 가능한 한 최소로 하되, 필요한 것만 골라 public API로 공개한다.
* **public 클래스는 반드시 필요한 public static final 필드 외의 public 필드를 갖지 않아야** 한다.
  * 이 때, public static final 필드가 참조하는 객체 역시 불변인 점을 확실히 해야 한다.

### public 클래스에서는 public 필드가 아닌 접근자를 사용하기
* **public 클래스는 절대 가변적인 필드를 public하게 노출하지 말아야** 한다.
* 인스턴스 필드만을 모아두는 외에는 아무런 역할을 수행하지 못하는 클래스를 작성할 때가 있다.
  * 이러한 클래스는 public 필드를 외부에서 직접 접근할 수 있으므로 캡슐화의 이점을 전혀 제공하지 못한다.
* public 클래스라면 public 필드를 private 필드로 바꾸고 public한 접근자를 제공하도록 수정한다.
  * **이를 통해 클래스 내부 표현 방식을 언제든지 바꿀 수 있는 유연성을 얻을 수 있게 된다**.
* 반면 **package private 클래스 또는 private 중첩 클래스는 데이터 필드를 public으로 노출해도 좋다**.
  * 이러한 방식으로 인해 클라이언트의 코드가 클래스 내부 표현 방식에 종속되지만, 어차피 클라이언트 코드도 해당 클래스를 포함하는 패키지 내부에서만 동작한다.
    * private 클래스는 한 단계 더 나아가 해당 클래스가 포함되는 외부 클래스까지로 접근이 제한된다.
  * **결과, 이러한 방식을 채택함으로써 접근자를 제공하는 방식보다 훨씬 깔끔한 사용이 가능**하다.
  * 즉, 어차피 외부에서 접근할 방법이 없는 코드이므로 내부적으로 더 유지보수가 좋은 방식을 선택하는 것이다.
* java.awt.package의 Point, Dimension 클래스 등은 이러한 규칙을 지키지 못하는 대표적인 사례이다.
  * 이러한 클래스는 내부를 노출함으로써 발생하는 심각한 성능 문제를 해결하지 못하므로, 절대 따라하지 않도록 한다.
* **public 클래스의 필드가 불변하다면 직접 노출하는 단점이 줄어들 수 있지만, 여전히 대부분의 문제가 해결되지 않아 불안정**하다.
  * 예를 들어, API를 직접 수정하지 않고서는 표현 방식을 변경할 수 없거나 필드를 읽어들일 때의 부수 작업을 수행할 수 없다.
  * 이는 내부 정보가 직접적으로 노출되고, 클라이언트가 이러한 내부 정보인 필드를 직접 참조하는 식으로 코드가 작성되기 때문이다.

### public 클래스와 public 필드의 결론
* public 클래스는 절대로 가변 필드를 public으로 직접 노출하지 않도록 한다.
* 불변 필드라면 public한 노출에서 기인하는 문제가 줄어들지만, 완전히 제거되지는 않는다.
* **반면 package private 클래스나 private 중첩 클래스는 불변, 가변에 관계 없이 필드를 public하게 노출하는 것이 유지 보수에 더 좋을 수 있다**.

### 변경 가능성은 최소화하기
* 인스턴스 내부의 값을 수정할 수 없는 클래스는 불변 클래스이며, 불변 클래스의 값은 객체가 파괴될 때까지 달라지지 않는다.
  * 이러한 **불변 클래스는 가변 클래스보다 설계 및 구현, 사용이 훨씬 쉬우며 안전**하다.
* 클래스를 불변하게 만들기 위해서는 다음의 규칙을 따르도록 한다.
  1. 객체의 상태를 변경하는 메소드를 제공하지 않는다.
  2. 클래스를 확장할 수 없도록 한다.
  3. 모든 필드를 final로 선언한다.
  4. 모든 필드를 private으로 선언한다.
  5. 자신 외에는 내부의 가변 컴포넌트에 접근할 수 없도록 한다.
     * 예를 들어, **클래스에 가변 객체를 참조하는 필드가 하나라도 있다면 클라이언트 코드에서는 해당 객체의 참조를 얻을 방법이 없어야** 한다.
* **클래스 내부의 가변 컴포넌트는 클라이언트가 객체 참조를 얻을 수도, 접근자 메소드가 값을 그대로 반환하지도 않아야** 한다.
  * 반드시 생성자, 접근자 모두에서 방어적 복사를 수행해야 한다.
* **불변 클래스는 근본적으로 스레드 안전하며, 별도의 동기화 작업이 필요 없다**.
  * 이는 클래스를 스레드 안전하게 만드는 가장 쉬운 방법이다.
* **불변 클래스는 자주 사용되는 인스턴스를 캐싱하여 같은 인스턴스를 중복 생성하지 않도록 하는 정적 팩토리를 제공**할 수 있다.
  * 기본 타입에 대응되는 래퍼 클래스와 BigInteger 등이 여기에 해당한다.
* **이러한 정적 팩토리의 활용은 여러 클라이언트 코드가 인스턴스를 공유하도록 하여 메모리 효율을 높이고 쓰레기 처리 비용을 낮춘다**.
  * 때문에 **새로운 클래스를 설계할 때 public 생성자를 제공하는 대신 정적 팩토리 패턴을 적용하면, 필요에 따라 캐싱 기능을 덧붙일 수 있다**.
* **불변 클래스는 자유롭게 공유가 가능하며, 방어적 복사도 필요가 없다**.
  * 때문에 불변 객체는 clone 메소드나 복사 생성자를 제공할 필요가 없다.
  * String 클래스의 복사 생성자는 이러한 사실을 이해하지 못한 초창기에 작성된 것이므로, 되도록 사용하지 않아야 한다.
* 불변 클래스는 그 자체로 실패 원자성을 제공한다.
  * 실패 원자성: 메소드에서 예외가 발생한 후에도 객체는 여전히 메소드 호출 전과 같은 상태를 유지해야한다는 특징이다.
* **불변 클래스에서는 값이 다른 경우에는 항상 독립된 객체를 생성해야 한다는 단점**이 있다.
* 불변 클래스의 원하는 객체를 완성하기까지의 단계가 많고, 중간 단계에서 만들어진 객체들이 모두 버려져야 한다면 성능 문제가 뒤따른다.
  * 이를 해결하는 방법은 크게 두가지이다.
  1. 흔히 사용할 수 있는 다단계 연산을 예측하고 기본 기능으로 제공한다.
     * 클라이언트에서 수행할 연산을 모두 정확히 예측할 수 있다면, package private한 가변 동반 클래스를 제공한다.
     * 예를 들어 BigInteger 클래스는 이러한 동작을 모두 정확히 예측한다.
  2. 클라이언트의 연산을 예상할 수 없다면 가변 동반 클래스 자체를 public으로 제공한다.
    * 예를 들어 String 클래스는 StringBuilder 클래스를 사용자에게 제공한다.
* **클래스를 상속하지 못하게 하는 가장 쉬운 방법은 final 클래스로 정의하는 것이지만, public 정적 팩토리를 제공하는 것이 더 유연**하다.
  * **이 경우, 모든 생성자를 private 또는 package private으로 정의하고 public 정적 팩토리를 제공**한다.
  * 이 방식은 언제나 최선인 경우가 많다!
* 정적 팩토리 방식은 public, protected 생성자가 없으므로 클래스의 확장이 사실상 불가능하다.
  * 반면 다수의 구현 클래스를 활용한 유연성을 제공하고, 이후의 릴리스에서 캐싱 기능을 추가하는 성능 향상을 적용할 수도 있다.

### 변경 가능성의 결론
* 클래스는 반드시 필요한 경우가 아니라면 불변이어야 한다.
* 불변 클래스는 특정 상황에서의 잠재적인 성능 저하를 제외하고는 장점 뿐인 방식이다.
  * 성능 저하는 불변 클래스와 쌍을 이루는 가변 동반 클래스를 public으로 제공하는 방식으로 해결할 수 있다.
* 게터가 있다고 해서 항상 세터를 만들 필요는 없다.
* **모든 클래스를 불변으로 만들 수는 없지만, 가변 클래스 역시 변경 가능한 부분은 최소화**해야 한다.
* 다른 **합리적인 이유가 없다면, 클래스의 모든 필드는 private final로 정의**하는 것이 좋다.
  * 이를 위해 **생성자는 항상 초기화가 완벽히 완료된 상태의 객체를 생성**해야만 한다.
* 다른 **합리적인 이유가 없다면 생성자와 정적 팩토리 에외는 public 초기화 메소드를 제공하지 않아야** 한다.
  * 객체의 재활용을 위해 상태를 다시 초기화하는 메소드 역시 복잡성만을 높일 뿐, 성능적인 이점은 제공하지 못한다.

## 2022-03-02 Wed
### 상속보다 컴포지션을 사용하기
* 상속은 코드를 재사용하기 위한 강력한 수단이지만, 항상 최선은 아니다.
  * 일반적인 구체 클래스를 패키지 경계를 넘어서 상속하는 것은 매우 위험하다.
* 상속은 캡슐화를 깨트리며, 상위 클래스의 내부 구현이 바뀌면 코드 한 줄 건드리지 않은 하위 클래스가 오동작할 수 있다.
* 상속이 깨지기 쉬운 이유는 대부분 하위 클래스에서 메소드를 재정의하는 과정에서 발생한다.
  1. 상위 클래스의 내부 구현이 바뀌는 경우, 해당 메소드를 사용하는 다른 메소드가 영향을 받을 수 있다.
  2. 새로운 메소드를 추가하더라도, 상위 클래스에 우연히 동일한 메소드가 추가되면 내가 작성한 코드는 컴파일되지 않는다.
* **이러한 문제점들을 피해가기 위해, 구체 클래스를 확장하는 대신 내부의 private 필드로 참조하는 컴포지션을 적용할 수 있다**.
  * 기존 클래스는 새로운 클래스의 private 필드로 참조된다.
  * 새로운 클래스의 메소드들은 기존 클래스의 메소드를 호출하는 forwarding 메소드로 작성한다.
  * 이러한 컴포지션과 전달(forwarding)의 조합은 넓은 의미에서 위임이라고 할 수 있다.
  * 이렇듯 기존 클래스의 인스턴스를 감싸는 클래스는 래퍼 클래스라고 부를 수 있으며, 새로운 기능을 덧붙이는 경우에는 데코레이터 패턴이 된다.
* **컴포지션을 통해 새로운 클래스는 기존 클래스의 내부 구현 방식에서 벗어날 수 있게 된다**.
  * 당연히 기존 클래스에 메소드가 추가되더라도 영향을 받지 않는다.
* **전달 메소드와 래퍼 클래스를 사용함에 있어 성능이나 메모리 사용량에 주는 영향은 사실상 없으므로, 해당 방식은 단점이 거의 없다**. 
* 전달 메소드를 작성하는 작업이 지루할지 모르지만, 데코레이터 패턴을 적용한 전달 클래스를 인터페이스마다 하나만 만들어두면 원하는 기능은 쉽게 덧붙일 수 있다.
* **상속은 반드시 하위 클래스가 상위 클래스의 진짜 자식인 경우에만 적용**한다.
  * 즉, is-a 관계를 반드시 지키는 경우에만 상속을 적용하고, 그렇지 않은 경우에는 내부의 private 필드를 활용한 상기 방식을 사용한다.
  * 이러한 사례는 Java 라이브러리의 Stack, Properties에서도 찾아볼 수 있다. 예를 들어, Stack은 Vector가 아닌데도 확장하고 있다!
* 컴포지션을 적용해야 하는 상황에서 상속을 적용하는 것은 내부 구현을 불필요하게 노출하는 것과 같다.
  * 결과 API는 내부의 세부 사항인 구현에 종속된다.
  * 무엇보다, **외부에서 클래스 내부의 코드에 접근 및 수정이 가능하다는 점이 가장 위험**하다.

### 컴포지션의 결론
* 상속은 코드 재사용 측면에서 강력하지만, 캡슐화를 해치는 문제가 있다.
* 상속은 상위 클래스와 하위 클래스의 관계가 is-a일 때만 적용이 가능하다.
  * **이 경우에도 하위 클래스의 패키지가 상위 클래스와 다르거나, 상위 클래스가 상속을 위해 설계되지 않았다면 위험**하다.
* **확장하려는 클래스에 결함이 있는 경우, 상속받은 하위 클래스에도 이러한 결함이 그대로 전파**된다.
  * **컴포지션은 오히려 이러한 결함을 숨기는 API를 새롭게 설계하여 대처할 수 있다**.
* 상속의 취약점에 대처하려면 컴포지션과 전달을 사용하자.
  * 특히 **래퍼 클래스는 상속받은 하위 클래스보다 견고하므로, 래퍼 클래스로 구현할 인터페이스가 있다면 더욱 컴포지션이 적절**하다.

### 상속을 고려하여 설계하고 문서화하기
* 상속을 고려한 설계와 문서화를 위해, 상속용 클래스는 재정의할 수 있는 메소드들을 내부적으로 어떻게 이용하는지 문서로 남겨야 한다.
  * 재정의할 수 있는 메소드란, public / protected 중 final이 아닌 모든 메소드이다.
* 상속용 클래스는 내부에 포함된 재정의할 수 있는 메소드를 호출할 수 있는 모든 상황을 문서로 남겨야 한다.
* 이러한 문서화 규약에 의해 다음과 같은 모순이 발생한다.
  * **이러한 모순은 상속이 캡슐화를 해치는 개념이기 때문에 발생**한다.
```
> 좋은 API 문서란 '어떻게'가 아닌 '무엇을'하는지 설명해야 한다.
> 상속용 클래스는 재정의 가능한 메소드를 호출할 수 있는 모든 상황을 문서로 남겨야 한다.
  > 즉, 이는 '무엇을'이 아닌 '어떻게'와 관련된 내용이다.
```
* 이렇듯 **클래스를 안전하게 상속할 수 있도록 하기 위해서는 원래라면 작성하지 않았어야 할 내부 구현 방식을 자세히 설명해야 한다**.
* 상속을 하기로 결정했다면, 하위 클래스를 작성하는 개발자가 사용하기 편리할만한 메소드를 미리 예측하여 protected로 제공해야할 수도 있다.
  * 사용하기 편리할만한 기능을 제공하기 위해 샹쇽용 클래스를 시험하는 방법은 직접 하위 클래스를 3개 정도 만들어보는 것이 유일한 방법이다.
  * 이 때, 하위 클래스 중 하나 이상은 제 3자에 의해 작성되어야 한다.
* **상속용 클래스의 생성자는 어떠한 방식으로든 재정의 가능한 메소드를 호출하지 않아야 한다**.
  * 상위 클래스의 생성자는 하위 클래스가 하위 클래스 생성자에 의해 초기화되기 전에 재정의 가능한 메소드를 호출하므로, 클래스가 원하는대로 동작하지 않는다.
  * 아래의 예시는 Child 인스턴스 생성시 Parent() > hello() > Child() 순으로 호출되므로, final인 name이 null인 시점이 명시적으로 드러난다.
  * private, final, static 메소드는 재정의가 불가능하므로 생성자에서 호출해도 무방하다.
```
class Parent {
    Parent() {
        hello();
    }
    void hello() {}
}

class Child extends Parent {
    private final String name;
    Child() {
        this.name = "injuk";
    }
    @Override void hello() {
        System.out.println(this.name);
    }
}
```
* 이렇듯 클래스를 상속용으로 설계하려면 엄청난 노력이 들고, 클래스 자체에 안기는 제약도 크다.
* 상속용으로 설계되지 않은 일반 클래스 또한 상속시에는 마찬가지 상위 클래스 수정으로 인한 하위 클래스의 오동작에서 자유로울 수 없다.
* 때문에 **상속용으로 설계되지 않은 클래스는 다음과 같은 방식으로 상속 자체를 금지하는 것이 바람직**하다.
  1. 클래스를 final로 만든다.
  2. 클래스의 생성자를 private이나 package private으로 작성하고, public한 정적 팩토리 메소드를 제공한다.
  * final은 쉬운 적용이 가능하며, 정적 팩토리는 장기적인 유연성을 둘 수 있다.
  * 상속을 금지하기 위해서는 둘 중 어느 방법을 선택해도 무방하다.
* 래퍼 클래스 패턴 역시 기능을 추가하기 위해 상속 대신 사용할 수 있을만한 대안으로 볼 수 있다.
* 어떻게 해서라도 **구체 클래스의 상속이 반드시 필요한 경우, 클래스 내부에서는 재정의 가능한 메소드를 호출하지 않고 이를 문서로 남겨야 한다**.
  * 이러한 방법을 활용하면 메소드를 재정의해도 다른 메소드에 영향을 주지 않으므로, 상속해도 그리 위험하지 않은 클래스를 작성할 수 있다.

### 상속과 문서화의 결론
* 상속용 클래스를 설계하려면 클래스 내부에서 자신의 메소드를 활용하는 모든 상황을 문서로 남겨야 한다.
* 한 번 문서화한 내용은 해당 클래스를 사용하는 한은 반드시 지켜야 한다.
* 또는 하위 클래스를 작성할 때 편리하게 사용할만한 메소드를 미리 예측하여 protected로 제공해야할 수도 있다.
* 이렇듯 **상속을 위한 설계는 매우 어려우므로, 클래스를 반드시 확장해야하는 경우가 아니라면 상속을 금지하는 것이 좋다**.
  * 상속을 금지하려면 클래스를 final로 정의하거나, 외부에서 접근할 수 있는 생성자를 제공하지 않도록 한다.

### 추상 클래스보다는 인터페이스를 활용하기
* Java의 다중 구현 메커니즘은 인터페이스와 추상 클래스 두가지 형태로 제공된다.
  * Java 8에서 인터페이스에 default 메소드가 추가됨에 따라 두 방식 모두 인스턴스 메소드를 구현 형태로 제공할 수 있다.
* 반면 추상 클래스를 구현하는 클래스는 반드시 추상 클래스의 하위 클래스가 되어야 한다.
  * **이는 다중 상속을 제공하지 않는 Java 특성 상 인터페이스에 비교하여 제약을 갖는 것**과 같다.
* **추상 클래스는 이미 작성된 기존 클래스가 이를 확장하도록 끼워 넣기 어렵지만, 인터페이스는 기존 클래스에도 쉽게 추가하여 구현**할 수 있다.
* 인터페이스는 믹스인을 정의하기에도 적절하다.
  * 믹스인 인터페이스는 클래스가 원래의 타입 이외에도 어떠한 기능을 제공하는지 선언하는 효과를 준다.
  * 추상 클래스는 기존 클래스에 덧씌우는 형태로 작성할 수 없으므로 믹스인에 적합하지 않다.
* **인터페이스로는 계층 구조가 없는 타입 구조를 정의할 수 있다**.
  * 클래스로 같은 구조를 만들기 위해서는 가능한 조합 전부를 클래스로 작성해야 한다.
* **인터페이스 메소드 중 구현 방법이 명백한 것이 있다면, 이를 default 메소드로 제공할 수도 있다**.
  * default 메소드는 자신이 작성하지 않은 인터페이스에는 추가할 수 없다.
* **인터페이스와 추상 골격 구현 클래스를 함께 제공하는 것으로 인터페이스와 추상 클래스 모두의 장점을 취할 수도 있다**.
  * **인터페이스로는 타입과 default 메소드를 정의하고, 골격 구현 클래스는 기반 메소드외의 필요한 메소드를 모두 구현**한다.
  * 이는 템플릿 메소드 패턴에 해당하며, 사용자는 골격 구현 클래스를 확장하는 것으로 인터페이스를 구현하기 위한 대부분의 작업을 마치게 된다.

### 인터페이스 사용의 결론
* 일반적으로 다중 구현용 타입에는 인터페이스가 가장 적합한 방법이다.
* 복잡한 인터페이스라면 구현하는 수고를 덜어줄 골격 구현을 함께 제공하는 방법을 고려하는 것이 바람직하다.
* 구현이 명백히 예측되는 메소드는 골격 구현의 default 메소드로 제공하여 인터페이스를 구현하는 곳에서 활용할 수 있도록 한다.
  * 이 때, equals 등 Object의 메소드는 default 메소드로 작성하지 않아야 한다.
  * 반면 인터페이스 자체적인 제약으로 구현히 명백할 수 없는 메소드는 추상 클래스 형태로 골격 구현을 제공하는 경우가 많다.

## 2022-03-03 Thu
### 인터페이스는 구현하는 쪽을 고려하여 설계하기
* Java 8 이전에는 기존에 작성된 구현 클래스를 깨지 않고서는 새로운 메소드를 인터페이스에 추가할 수 없었다.
* **Java 8은 이러한 요구사항에 맞추어 default 메소드 기능을 추가했지만, 새로운 메소드를 추가함에서 기인하는 위험성이 완전히 사라진 것은 아니다**.
  * **Java 7 이전의 모든 Java 애플리케이션은 인터페이스에 새로운 메소드가 추가될 일이 없다는 전제 하에 작성되었기 때문**이다.
  * 이러한 경우, default 메소드는 실제 구현 클래스에 대해 어떠한 정보도 없이 일방적으로 삽입된다.
* 때문에 default 메소드는 컴파일에 성공하더라도 기존 구현 클래스에 런타임 오류를 일으킬 가능성이 있다.
* **기존 인터페이스에 default 메소드로 새로운 기능을 추가하는 일은 반드시 필요한 경우가 아니면 가능한 한 피하도록 한다**.
  * 반면, 새로운 인터페이스를 설게하는 경우라면 표준적인 메소드 구현을 제공할 수 있으므로 매우 유용하게 사용할 수 있다.
* 인터페이스를 설게할 때에는 반드시 세심한 주의를 기울이고, 최소한 세 가지 다른 방식으로 구현해보아야 한다.
  * 이러한 방식은 인터페이스의 릴리스 이전에 결함을 바로잡을 수 있도록 한다.
  * **인터페이스 릴리스 후에도 결함을 바로잡을 수 있지만, 이러한 가능성에는 기대지 않는 것이 바람직**하다.

### 인터페이스는 타입을 정의하는 용도로만 사용하기
* **인터페이스는 해당 인터페이스를 구현하는 클래스의 인스턴스를 참조할 수 있는 타입의 역할을 수행**한다!!!
  * 어떤 구체 클래스가 인터페이스를 구현한다는 것은, 해당 클래스로 무엇을 할 수 있는지 클라이언트에게 알려준다.
  * **인터페이스는 반드시 이러한 용도로만 사용**해야 한다.
* 이러한 지침에 명백하게 위배되는 안티 패턴의 예시는 메소드 없이 static final로만 구성된 상수 인터페이스이다.
  * **클래스 내부에서 사용하는 상수는 외부의 인터페이스가 아닌 내부의 구현에 해당**한다.
  * 즉, 해당 안티 패턴은 내부 구현을 클래스의 API로 노출하는 형태이다.
  * 최악의 경우, 클라이언트 코드는 내부 구현인 상수 인터페이스들의 상수에 종속될 가능성이 있다.
* 상수를 공개할 목적이라면 다음의 방식을 고려할 수 있다.
  1. 특정 클래스나 인터페이스와 강하게 연관된 상수라면, 클래스나 인터페이스 자체에 추가한다.
  2. enum으로 표현하기 적합한 경우라면, public enum으로 작성한다.
  3. 위 두 경우에 해당하지 않는 경우, 인스턴스화할 수 없는 유틸리티 클래스에 포함하여 공개한다.
     * 해당 경우, 유틸리티 클래스에 포함시킨 상수를 자주 사용해야 한다면 static import를 활용한다.
* **인터페이스는 반드시 타입을 정의하는 용도로만 사용하며, 상수를 공개하기 위한 수단으로 사용하는 것을 지양**해야 한다.

### 클래스에서 태그 필드를 사용하기보다는 계층 구조를 적용하기
* **하나의 클래스가 여러 의미를 표현할 수 있으며, 현재 인스턴스의 의미를 태그용 필드로 알려주는 클래스는 백해무익**하다.
  * 여러 의미를 하나의 클래스 내부에 모아두므로 불필요한 코드가 너무 많아지며, 이로 인해 메모리 효율과 가독성도 떨어진다.
  * 필드의 초기화 과정은 모두 개발자에게 달려 있으며, 이 과정에서 컴파일러의 도움을 받지 못하므로 오류는 런타임에서 발생하게 된다.
* 무엇보다, **이러한 클래스는 인스턴스 타입만으로는 현재의 의미를 알 방법이 전혀 없다**.
  * 태그를 사용하는 클래스는 언제나 장황하고, 불안정하고, 비효율적이다.
* **Java는 타입 하나로 다양한 의미의 객체를 표현하는 수단으로 클래스 계층 구조를 활용한 subtyping을 제공**한다.
  * 계층 구조를 적용하면 컴파일러의 도움을 받기 쉬우며, 계층 구조를 확장하기도 쉽다.
  * 즉, 타입 사이의 자연스러운 계층 관계를 반영하면 유연성과 컴파일 타임의 타입 검사 능력이 향상된다.
* **태그 필드를 사용하는 클래스가 필요한 상황은 거의 없으며, 대신 계층 구조의 적용을 고려**하자.

### 멤버 클래스는 가능한 한 static으로 만들기
* 다른 클래스 안에 정의된 클래스는 중첩 클래스라고 부르며, 다음과 같은 네 종류가 있다.
  1. 정적 멤버 클래스
  2. 비정적 멤버 클래스
  3. 익명 클래스
  4. 지역 클래스
* 정적 멤버 클래스는 일반적으로 외부 클래스와 함께 쓰일 때에만 유용한 public 도우미 클래스에 사용한다.
* 비정적 멤버 클래스와 정적 멤버 클래스는 static의 유무로 구분하지만, 의미상의 차이가 분명하다.
  * 비정적 멤버 클래스는 [클래스명].this의 형태로 외부 클래스의 인스턴스 참조를 사용할 수 있다.
* **개념상 중첩 클래스의 인스턴스가 외부 클래스의 인스턴스와 독립적으로 존재할 수 있다면 정적 멤버 클래스로 정의**한다.
* 반면 비정적 멤버 클래스의 인스턴스와 외부 클래스 인스턴스 사이의 관계는 인스턴스화 시점에 결정되며, 더 이상 변경이 불가능하다.
  * 또한 **이러한 관계 정보는 비정적 멤버 클래스의 인스턴스 내부에 설정되어 메모리 공간을 처지하고, 생성 시간도 더 오래 걸린다**.
* 멤버 클래스에서 외부 인스턴스에 접근할 필요가 업사면 반드시 static을 활용하여 정적 멤버 클래스로 작성한다.
  * 비정적 멤버 클래스는 외부 인스턴스로의 숨은 참조를 갖게 되며, 이를 위한 시간과 공간 자원을 더 소모한다.
  * **최악의 경우, GC에 의해 외부 클래스의 인스턴스가 수집되지 않는 메모리 누수가 발생**할 수 있다.
* 익명 클래스는 사용 시점에 선언과 동시에 인스턴스가 생성되며, static이 아닌 문맥에서만 외부 클래스의 인스턴스를 참조할 수 있다.
  * 익명 클래스는 instanceof 검사나 클래스의 이름을 활용할 수 없으며, 코드 중간에 등장하므로 짧지 않으면 가독성이 떨어진다.
  * 이러한 **익명 클래스는 주로 정적 팩토리 메소드의 구현에 사용**된다.
* 지역 클래스는 가장 드물게 사용되는 방식이며, 지역 변수를 선언할 수 있는 위치라면 어디에서나 정의가 가능하다.
  * 지역 클래스는 멤버 클래스처럼 이름을 통해 반복 활용이 가능하며, static이 아닌 문맥에서 외부 참조가 가능하며, 가독성을 위해 짧게 작성해야 한다.

### 멤버 클래스의 결론
* 메소드 밖에서 사용해야 하거나, 메소드 내부에 정의하기 너무 긴 경우 멤버 클래스로 정의한다.
  * 멤버 클래스의 인스턴스 각각이 외부 인스턴스를 참조한다면 비정적으로, 그렇지 않다면 정적으로 정의한다.
* 중첩 클래스가 메소드 하나에서만 사용되면서, 인스턴스를 생성하는 시점이 한 곳이고 적절한 클래스 혹은 인터페이스가 존재하는 경우에는 익명 클래스를 활용한다.
  * 그렇지 않은 경우에는 지역 클래스를 활용한다.
* 즉, 멤버 클래스는 클래스 외부에서도 사용되며, 익명 클래스와 지역 클래스는 클래스 내부에서만 사용되는 차이가 있다.
  * 멤버 클래스는 외부 클래스의 인스턴스에 대한 참조 필요성에 따라 비정적 또는 정적으로 구분한다.
  * 익명 클래스와 지역 클래스는 활용할만한 클래스 또는 인터페이스의 존재 유무에 따라 구분한다.

### 최상위 수준 클래스는 하나의 파일에 하나만 정의하기
* **하나의 소스 코드에 최상위 수준 클래스를 여럿 설정하더라도 컴파일이 가능하지만, 이는 백해무익한 행위**이다.
  * 이 경우, 컴파일러에게 어떤 소스 코드를 먼저 건네주어 컴파일하느냐에 따라 동작이 달라질 수 있다.
* 이러한 문제를 해결하려면, 단순히 최상위 수준 클래스를 여러 소스 코드로 분리하면 된다.
* 어떻게 해서라도 **여러 클래스를 하나의 파일에 정의하고 싶다면 정적 멤버 클래스의 활용을 고려할 수 있다**.
  * 다른 클래스에 포함되는 부차적인 클래스라면 정적 멤버 클래스로 정의하는 것이 일반적으로 더 나은 해결책이 될 수 있다.
* **소스 코드 파일 하나에는 최상위 수준 클래스, 또는 최상위 수준 인터페이스를 하나만 담는 것이 언제나 좋다**.
  * 이를 통해 컴파일러는 하나의 클래스에 대한 여러 정의를 만드는 상황이 사라지며, 어떤 순서로 컴파일하더라도 애플리케이션의 동작은 달라지지 않는다.
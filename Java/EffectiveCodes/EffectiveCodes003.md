# EffectiveCodes
## 2022-03-01 Tue

## 클래스와 인터페이스
* 클래스와 인터페이스는 추상화의 기본 단위이며, Java의 핵심이다.
  * 때문에 Java에서는 클래스와 인터페이스 설계에 사용하는 강력한 요소를 많이 지원한다.
* 이러한 요소를 적절히 활용하여 클래스와 인터페이스를 쓰기 편하고, 견고하고, 유연하게 만들 수 있다.

### 클래스와 멤버의 접근 권한은 최소화하기
* **잘 설계된 컴포넌트와 그렇지 못한 컴포넌트의 가장 큰 차이는 클래스 내부 데이터와 구현 정보가 외부 컴포넌트로부터 얼마나 잘 숨겨지느냐**에 달렸다.
  * 잘 설계된 컴포넌트는 내부 구현을 완벽히 숨기고 구현과 API를 분리한다.
  * 이러한 컴포넌트는 오직 API를 통해서만 다른 컴포넌트와 소통하며, 서로의 내부 동작 방식에는 전혀 개의치 않아야 한다.
* 이렇듯 **정보 은닉, 캡슐화는 소프트웨어 설계의 근간**이 되어 준다.
  * 정보 은닉은 시스템을 구성하는 컴포넌트들을 독립시켜 개발, 테스트, 최적화, 분석, 수정을 개별적으로 할 수 있도록 뒷받침하는 역할을 수행한다.
* **Java는 언어 차원에서 정보 은닉을 위한 다양한 장치를 제공하며, 핵심은 접근 제한자**이다.
* 정보 은닉을 위해 접근 제한자를 사용하는 기본 원칙은 매우 간단하다.
```
> 모든 클래스와 멤버의 접근성을 가능한 한 최대한 좁혀야 한다.
> 소프트웨어가 올바르게 동작하는 한, 가능한 최저의 접근 수준을 부여해야만 한다.
```
* 톱 레벨 클래스와 인터페이스에 부여할 수 있는 접근 수준은 다음과 같다.
  1. package private: 패키지 내부에서만 사용할 수 있는 내부 구현으로 취급한다. 
     * **패키지 외부에서 사용할 이유가 없는 클래스는 package private으로 선언**해야 한다.
  2. public: 패키지 외부에서 제한 없이 사용할 수 있는 공개 API가 된다.
* **package private의 경우, 내부 구현이므로 클라이언트 코드에 피해를 주는 일 없이 언제든지 수정 및 교체, 제거가 가능**하다.
  * 반면 **public으로 선언한 경우 공개 API가 되므로, 하위 호환을 위해 영원히 관리해야** 한다.
* package private 클래스 역시 특정한 클래스에서만 접근한다면, 해당 클래스 내부의 private static 클래스로 중첩시켜 캡슐화할 수 있다.
* 공개 API로 사용할 클래스를 신중히 결정한 후, 그 외의 모든 멤버를 private으로 설정한다.
  * 이후에는 같은 패키지에서 접근이 필요한 클래스에 한해 package private으로 변경해준다.
  * 이러한 **권한 해제 작업이 반복된다면, 컴포넌트를 더 분해해야 하는 것은 아닌지 다시 확인**한다.
* private과 package private은 내부 구현에 속하므로 공개 API의 멤버더라도 영향을 크게 주지 않는다.
  * 반면 protected 멤버는 접근 가능한 범위가 엄청나게 넓어지고 공개 API의 일부로서의 지원 대상이 된다.
  * 따라서 **protected 멤버는 적을 수록 좋다**.
* **부모 클래스의 메소드를 재정의할 때는 부모 클래스의 접근 제한자보다 좁게 설정할 수 없다는 제약은 멤버 접근성을 좁히지 못하도록 방해**한다. 
  * 아쉽게도 해당 제약은 리스코프 치환 원칙을 준수하기 위해 필수적이다.
* 코드를 테스트하기 위해 private 멤버의 접근 제한자를 public으로 풀어두지 말아야 한다.
  * 그보다는 package private을 적용하고, 같은 패키지에 테스트 코드를 배치하는 방법을 활용한다.
* public 클래스의 필드는 되도록 public이 아니어야 한다.
  * public 가변 필드를 갖는 클래스는 일반적으로 스레드 안전하지 않다.
  * **예외적으로, 클래스의 추상 개념을 완성하기 위해 필요한 정적 필드는 public static final이어도 좋다**.
* **길이가 0이 아닌 배열은 모두 변경이 가능하므로, 클래스에서 public static final 배열 필드를 두지 말아야 한다**.
  * 또는 이러한 필드를 반환하는 접근자 메소드도 제공하지 말아야 한다.
  * 반드시 배열 필드를 두어야 한다면, 필드를 private으로 두고 public 불변 리스트를 제공하거나 복사본을 반환하는 public 메소드를 정의한다.
* **Java 9에서는 모듈 시스템이 도입**되었으며, 두가지 암묵적인 접근 수준이 추가되었다.
  * **모듈은 클래스를 묶은 패키지들의 묶음**이다.
* 모듈은 자신이 포함하는 패키지 중 공개할 것들을 별도의 .java 파일에 선언한다.
  * 이 경우, **패키지 내부의 protected 또는 public 멤버도 해당 패키지가 공개되지 않았다면 외부 모듈에서는 접근할 수 없다**.
    * 모듈 내부에서는 일반적인 접근 제어자의 규칙을 따른다.
  * **모듈 시스템을 적절히 활용하면 클래스를 외부에 공개하지 않으면서도, 모듈 내부의 패키지 사이에서는 자유로운 공유가 가능**하다.
* 숨겨진 패키지 내부의 public과 protected 멤버는 일반적인 접근 제어자의 수준을 따르지 않는, 암묵적으로 추가된 접근 수준이다.
  * 다시 말해, 숨겨진 패키지 내부의 public은 공개 API 형식이지만 외부 모듈에서는 접근할 수 없기에 기존의 public과는 분명히 다른 제한 수준을 갖는다.
  * **반드시 이런 형태의 접근 수준을 적용해야만 하는 경우는 흔치 않으며, 그마저도 대부분 클래스를 패키지 내부에서 재배치하는 것으로 해결**된다.

### 접근 권한의 결론
* 프로그램을 구성하는 각 요소의 접근성은 가능한 한 최소로 하되, 필요한 것만 골라 public API로 공개한다.
* **public 클래스는 반드시 필요한 public static final 필드 외의 public 필드를 갖지 않아야** 한다.
  * 이 때, public static final 필드가 참조하는 객체 역시 불변인 점을 확실히 해야 한다.
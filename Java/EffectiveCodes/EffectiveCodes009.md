# EffectiveCodes
## 2022-03-14 Mon

## 예외
### 예외는 정말 예외인 상황에만 사용하기
* 예외는 반드시 예외 상황에서만 사용해야 하며, 절대 애플리케이션의 흐름을 제어하기 위한 용도로 사용하지 말아야 한다.
  * 나아가 잘 설계된 API는 클라이언트가 정상적인 흐름에서 예외를 사용할 일이 없어야 한다.

### 복구 가능한 경우에는 검사 예외를, 프로그래밍 오류에는 런타임 예외를 사용하기
* Java는 문제 상황을 알리는 타입인 throwable로 검사 예외, 런타임 예외, 에러를 제공한다.
* 이 중, 호출하는 쪽에서 복구하리라고 여겨지는 상황에서는 검사 예외를 사용한다.
  * 검사 예외를 던지면 호출자가 해당 예외를 처리하거나 바깥으로 다시 던지도록 강제하게 된다.
  * **즉, 검사 예외는 API 설계자가 API 사용자에게 예외 상황으로부터의 회복을 강제**한다.
  * **때문에 메소드 선언에 포함된 검사 예외 각각은 메소드 호출시 발생할 수 있는 결과 중 하나임을 API 사용자에게 알리는 역할을 한다**.
* 비검사 throwable인 런타임 예외와 에러는 동작 측면에서는 큰 차이점이 없다.
* **프로그램이 던진 비검사 예외 또는 에러의 경우, 복구가 불가능하거나 더 실행해도 손해가 더 큰 경우를 말한다**.
* 프로그래밍 오류는 런타임 예외를 사용하여 표현한다.
  * 예를 들어, API 사용의 전제조건을 만족하지 못하는 경우에는 런타임 예외를 활용할 수 있다.
* **예외 상황으로부터 복구가 가능한 것으로 보인다면 검사 예외를, 그렇지 않거나 확실하지 않은 경우네는 비검사 예외를 선택하도록 한다**.
* 에러는 일반적으로 JVM이 더 이상 수행을 계속할 수 없는 상황을 나타내기 위해 사용하며, 일반적으로 상속하여 하위 클래스를 만들지 않는다.
  * 즉, **개발자가 직접 구현하는 비검사 throwable은 모두 RuntimeException의 하위 클래스여야 한다**.
* 검사 예외도 아니고 런타임 예외도 아닌 throwable은 정의하지 말아야 한다.
  * 이러한 방식은 검사 예외보다 좋은 게 없으면서 사용자를 헷갈리게 한다.
* **검사 예외를 직접 정의하는 경우, 예외 상황에 대한 정보 및 예외로부터 회복하기 위해 필요한 정보를 제공할 수 있는 메소드를 정의하는 것이 바람직**하다.
  * 그렇지 않을 경우 예외로부터 발생한 메시지를 토대로 필요한 정보를 파싱해야 하는데, 이는 바람직하지 않은 상황이다.
  * 메시지 문자열을 파싱하여 얻은 코드는 모든 환경에서 일관적으로 동작하지 못할 수 있다.

### 필요 없는 검사 예외의 사용은 지양하기
* 검사 예외는 제대로 활용하면 API의 질과 안정성을 높일 수 있다.
* **그러나 검사 예외를 과하게 사용하면 API의 사용성만을 떨어트린다**.
  * 예를 들어, API 사용자는 검사 예외를 처리하기 위해 catch 블록을 두어 처리하거나, 바깥으로 재전파해야 한다.
  * 어느쪽이든 API 사용자 입장에서는 예외 처리를 위한 부담 요소이며, 이는 특히 메소드가 단 하나의 검사 예외를 던지는 경우에서 가장 크다.
* API를 제대로 사용해도 발생할 수 있는 예외이거나, 개발자가 조치를 취할 수 있는 경우라면 검사 예외를 사용해도 무방하다.
  * 둘 모두에 해당하지 않는 경우, 비검사 예외를 사용하는 것이 좋다.
* **검사 예외를 회피하는 가장 쉬운 방법은 적절한 타입을 담는 옵셔널을 반환하는 방법이다**.
  * **이러한 방식은 예외가 발생한 이유를 명시하는 부가 정보를 포함할 수 없다는 단점도 존재**한다.
* 또는 검사 예외를 던지는 메소드를 2개로 쪼개어 비검사 예외로 리팩토링할 수도 있다.
  * 쪼개진 메소드 중 첫 번째는 예외 여부를 boolean 형태로 반환하는 메소드이며, 두 번째 메소드는 기존 메소드의 기능을 담당한다.
  * 이러한 리팩토링은 모든 상황에 적용할 수 없지만, 적용한 경우에는 API의 사용성을 높여줄 수 있다.
* 이러한 리팩토링은 외부 동기화 없이 여러 스레드에서 사용하는 경우, 또는 외부 요인에 의해 상태가 변할 수 있는 경우에 적합하지 못하다.
  * 예외 상황을 체크하는 메소드와 실제 동작을 수행하는 메소드 사이에서 상태가 변경될 수 있기 때문이다.

### 검사 예외의 결론
* 적시에 사용한 검사 예외는 프로그램의 안전성을 높이지만, 남용하면 API의 사용성만 떨어트릴 뿐이다.
* API 호출자가 예외로부터 복구할 방법이 없다고 판단되면 비검사 예외를 던진다.
* 복구가 가능하고 호출자가 해당하는 처리를 해주기를 바라는 경우라면, 우선 옵셔널 반환을 고려한다.
* 옵셔널만으로는 상황을 처리하기에 충분한 정보를 제공할 수 없는 경우에만 검사 예외를 던지도록 한다.

## 2022-03-15 Tue
### 표준 예외를 사용하기
* **경험이 많은 개발자는 더 많은 코드를 재사용할 수 있으며, 예외 역시 재사용이 가능한 코드**이다.
  * Java 라이브러리는 대부분의 API에서 사용하기에 충분한 예외를 제공한다.
* 표준 예외를 재사용하는 경우, API는 다른 개발자들에게 익숙하고 배우기 쉬운 코드가 된다.
  * 또한, **예외 클래스 수가 적을수록 메모리 사용량 및 클래스 적재에 필요한 시간도 줄게 된다**.
* 자주 재사용될 수 있는 예외는 다음과 같다.
  1. IllegalArgumentException: 메소드 호출자가 인수에 적절하지 못한 값을 넘길 때 던질 수 있는 예외이다.
  2. IllegalStateException: 객체의 상태가 완전히 초기화되지 않아 메소드를 수행하기 위해 적절하지 않은 경우에 던질 수 있는 예외이다.
  3. NullPointerException: null을 허용하지 않는 메소드에 null을 사용한 경우에 던질 수 있는 예외이다.
  4. IndexOutOfBoundsException: 인덱스 범위를 넘어서려는 시도에 대해 던질 수 있는 예외이다.
  5. ConcurrentModificationException: 단일 스레드로 사용하려고 설계된 객체를 여러 스레드가 동시에 수정하려고 하는 경우에 던질 수 있는 예외이다.
  6. UnsupportedOperationException: 호출된 메소드를 지원하지 않는 경우에 던질 수 있는 예외이다.
* **Exception, RuntimeException, Throwable, Error는 추상 클래스로 취급하며, 직접 재사용하지 말아야 한다**.
* **상술한 예외 이외에도 재사용 가능한 예외가 많이 있으며, 상황에 부합하는 적절한 표준 예외를 활용**해야 한다.
  * 이 때, API 문서를 참고하여 예외가 어떤 상황에서 사용되는지 확인해야 한다.
* 표준 예외가 제공하는 정보보다 더 많은 내용을 제공하고자 하는 경우, 표준 예외를 확장하는 새로운 예외를 작성하여도 무방하다.
* IllegalStateException과 IllegalArgumentException 중 어느 예외를 사용할지 고민된다면, 인수와 무관하게 호출 성공 여부를 토대로 결정한다.
  * 예를 들어, 인수 값과 관계 없이 실패했을 상황에는 IllegalStateException을 던질 수 있도록 한다.

### 추상화 수준에 걸맞는 예외를 사용하기
* **메소드가 저수준의 예외를 처리하지 않고 그대로 외부로 전파하는 경우, 작업과 관련 없어보이는 엉뚱한 예외가 튀어나온 것 처럼 보일 수 있다**.
  * 또한 이러한 방식은 내부 구현 방식을 드러내어 상위 레벨의 API를 오염시킬 수 있다.
* **저수준 예외를 잡는 상위 계층에서는 자신의 추상화 수준에 맞는 예외로 바꾸는 예외 번역을 적용한 후에 다시 전파**해야 한다.
* **예외를 번역하는 경우, 저수준의 예외가 디버깅에 도움을 줄 수 있을 것으로 판단된다면 예외 연쇄를 사용**한다.
  * **예외 연쇄란, 고수준 예외의 생성자에 원인 예외를 건내어 근본 원인인 저수준 예외를 고수준 예외에 싣는 방식**이다.
  * 대부분의 표준 예외는 예외 연쇄를 위한 생성자를 갖추고 있다. 
  * 그렇지 않은 경우에는 Throwable의 initCause 메소드를 활용하는 것으로 원인은 직접 명시할 수 있다.
* **예외 연쇄는 문제의 원인을 getCause 메소드로 애플리케이션에서 접근할 수 있게 하며, 원인과 고수준 예외의 스택 트레이스를 잘 통합해주는 역할**을 한다.
* 예외 번역은 예외 전파의 남용보다는 좋지만, 역시 남용해서는 좋을 것이 없다.
  * 가능하다면, 저수준의 메소드를 반드시 성공하도록 하는 것이 이상적이다.
  * 예외를 피할 수 없다면, 상위 계층에서 예외를 암시적으로 처리한 후 java.util.logging 등을 통해 로깅할 수 있다.
  * 이러한 방식은 클라이언트 코드에 예외를 전파하지 않으면서도 로그 분석을 통한 추가 조치를 가능케 한다.

### 추상화 수준에 걸맞는 예외 사용의 결론
* 저수준의 예외를 방지하거나 처리할 수 없고, 예외를 그대로 고수준에 노출하고 싶지 않다면 예외 번역을 사용할 수 있다.
* 예외 번역을 활용하는 경우, 예외 연쇄를 통해 상위 계층에 걸맞는 고수준 예외를 던지면서도 근본 원인을 함께 전달하여 오류를 쉽게 분석할 수 있다.

### 메소드가 던지는 모든 예외를 문서화하기
* 메소드가 던지는 예외는 해당 메소드의 사용에 있어서 중요한 정보이므로, 발생 가능한 예외를 문서화하는 데에 충분한 시간을 들여야 한다.
* 발생 가능한 예외를 문서화하지 않는다면 다른 개발자가 해당 클래스나 인터페이스를 사용하기 어려울 수 있으며, 최악의 경우 불가능할 수도 있다.
* 검사 예외는 항상 따로 선언하고, 각 예외가 발생하는 상황을 javadoc의 @throws 태그를 활용하여 정확히 문서화한다.
  * 이 때, Exception이나 Throwable과 같은 공통 상위 예외로 뭉뚱그려 표현하지 말아야 한다.
  * 예외적으로 main 메소드는 JVM만이 호출하므로, Exception을 던지도록 뭉뚱그려 정의해도 좋다.
* 비검사 예외도 검사 예외처럼 문서화해두는 것이 이상적이다.
  * 잘 작성된 비검사 예외는 해당 메소드를 성공시키기 위한 전제 조건이 된다.
  * public 메소드라면 응당 필요한 전제 조건은 문서화되어야 하며, 비검사 예외의 문서화는 이를 지킨 좋은 예시에 속한다.
* 발생 가능한 비검사 예외를 문서화하는 것은 인터페이스 메소드에서 특히 중요하다.
  * 비검사 예외 조건은 인터페이스의 일반 규약에 속하며, 해당 인터페이스를 구현하는 구현체의 일관된 동작을 보장해줄 수 있다.
* **메소드가 던질 수 있는 예외는 모두 @throwa를 활용하여 문서화하되, 메소드의 throws 절에는 검사 예외만 작성**한다.
* 하나의 클래스에 속한 다수의 메소드가 같은 이유에서 같은 예외를 던진다면, 예외를 메소드 각각이 아닌 클래스 설명에 추가할 수 있다.

### 예외의 상세 메시지에 실패 관련 정보를 포함하기
* 예외를 적절히 처리하지 못해 프로그램이 실패하는 경우, Java 시스템은 예외의 스택 트레이스 정보를 함께 출력한다.
  * **스택 트레이스 정보는 예외 객체의 toString 메소드를 호출했을 때 반환되는 문자열**이다.
* **스택 트레이스는 오류의 원인을 분석해야하는 개발자에게 주어지는 유일한 정보인 경우가 많으므로, 가능한 한 많은 정보를 포함해야 한다**.
* **실패 순간을 포착하기 위해 예외와 관련된 모든 매개 변수와 필드의 값을 실패 메시지에 담는 것이 바람직**하다.
  * 물론 비밀번호 등의 민감한 정보는 포함하지 않아야 한다.
* 예외 메시지는 최종 사용자에게 전달되는 오류 메시지와는 다른 특징을 갖기에 같을 필요가 없다.
  * 최종 사용자에게는 가독성 있고 친절한 안내 메시지가 전달되어야 한다.
  * 예외 메시지는 개발자에게 제공될 것이므로, 가독성은 떨어지더라도 많은 정보를 포함하는 것이 중요하다.
* 예외는 실패와 관련된 정보를 얻을 수 있는 접근자 메소드를 제공하는 것이 좋고, 이는 검사 예외에서 큰 역할을 할 수 있다.
  * 그러나 가능하다면 비검사 예외라고 상세 정보를 알려주는 접근자를 제공하는 것이 바람직하다.

### 가능하다면 실패 원자적으로 만들기
* **호출된 메소드가 실패하더라도, 메소드에 사용된 객체는 메소드 호출 전 상태를 유지하는 것이 좋다**.
  * 이러한 특징을 갖는 메소드를 실패 원자적인 메소드라고 한다.
* 메소드를 실패 원자적으로 만드는 방법은 크게 다음과 같다.
  1. 불변 객체를 만들어 사용한다.
  2. 메소드 작업 수행 전에 모든 매개 변수의 유효성을 검사한다.
  3. 실패할 가능성이 있는 모든 코드를 객체의 상태를 바꾸는 코드보다 앞에 배치한다.
  4. 객체의 임시 복사본을 만들어 작업을 수행한 후, 작업이 성공한 경우에 한해 원래 겍체와 교체한다.
  5. 작업 도중 발생하는 실패를 가로채 복구하는 코드를 작성하여 작업 전 상태로 되돌린다.
     * 이러한 방식은 자주 사용되지는 않는다.
* **실패 원자성은 일반적으로 권장되지만, 항상 갖출 수 있는 항목은 아니다**.
  * 또는 **실패 원자성을 달성하기 위한 비용이나 복잡성이 너무 큰 경우도 있으므로, 항상 갖춰야만 하는 것도 아니다**.
* Error는 복구할 수 없으므로 실패 원자성을 갖추려는 시도조차 할 필요가 없다.
* 메소드 명세에 기술된 예외에 대해서는 실패 원자성을 갖추는 것이 기본 원칙이다.
  * 만약 실패 원자성을 갖추지 못한 메소드의 경우, 이러한 사실과 실패시의 객체 상태를 API 설명에 명시해야 한다.

### 예외는 절대 무시하지 않기
* 당연한 사실이지만, 이를 어기는 경우는 생각보다 많이 발생한다.
* **API 작성자가 메소드 선언에 예외를 명시하는 까닭은 해당 메소드를 호출하는 경우에 적절한 조치를 취해야한다고 말하는 것**이다.
* **예외는 오류에 적절히 대처하기 위해 존재하지만, catch 블록을 비워두는 식으로 예외를 무시하면 예외의 존재 이유가 없어진다**.
* **예외를 무시해야할 때도 있으며, 이 경우 예외를 무시하기로 한 이유를 catch 블록에 주석으로 작성하고 예외 변수의 이름을 ignored로 작성**한다.
* 예외는 검사 예외, 비검사 예외를 불문하고 무시되지 말아야 한다.
  * 빈 catch 블록 등을 무시하면 프로그램은 항상 오류 발생 가능성을 내재한 상태가 된다.
* **예외를 적절히 처리하면 오류를 완전히 피할 수 있으며, 최소한 밖으로 전파되도록 놔두는 것으로 오류 상황에 필요한 디버깅 정보와 함께 중단할 수 있다**.
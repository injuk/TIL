# EffectiveCodes
## 2022-03-14 Mon

## 예외
### 예외는 정말 예외인 상황에만 사용하기
* 예외는 반드시 예외 상황에서만 사용해야 하며, 절대 애플리케이션의 흐름을 제어하기 위한 용도로 사용하지 말아야 한다.
  * 나아가 잘 설계된 API는 클라이언트가 정상적인 흐름에서 예외를 사용할 일이 없어야 한다.

### 복구 가능한 경우에는 검사 예외를, 프로그래밍 오류에는 런타임 예외를 사용하기
* Java는 문제 상황을 알리는 타입인 throwable로 검사 예외, 런타임 예외, 에러를 제공한다.
* 이 중, 호출하는 쪽에서 복구하리라고 여겨지는 상황에서는 검사 예외를 사용한다.
  * 검사 예외를 던지면 호출자가 해당 예외를 처리하거나 바깥으로 다시 던지도록 강제하게 된다.
  * **즉, 검사 예외는 API 설계자가 API 사용자에게 예외 상황으로부터의 회복을 강제**한다.
  * **때문에 메소드 선언에 포함된 검사 예외 각각은 메소드 호출시 발생할 수 있는 결과 중 하나임을 API 사용자에게 알리는 역할을 한다**.
* 비검사 throwable인 런타임 예외와 에러는 동작 측면에서는 큰 차이점이 없다.
* **프로그램이 던진 비검사 예외 또는 에러의 경우, 복구가 불가능하거나 더 실행해도 손해가 더 큰 경우를 말한다**.
* 프로그래밍 오류는 런타임 예외를 사용하여 표현한다.
  * 예를 들어, API 사용의 전제조건을 만족하지 못하는 경우에는 런타임 예외를 활용할 수 있다.
* **예외 상황으로부터 복구가 가능한 것으로 보인다면 검사 예외를, 그렇지 않거나 확실하지 않은 경우네는 비검사 예외를 선택하도록 한다**.
* 에러는 일반적으로 JVM이 더 이상 수행을 계속할 수 없는 상황을 나타내기 위해 사용하며, 일반적으로 상속하여 하위 클래스를 만들지 않는다.
  * 즉, **개발자가 직접 구현하는 비검사 throwable은 모두 RuntimeException의 하위 클래스여야 한다**.
* 검사 예외도 아니고 런타임 예외도 아닌 throwable은 정의하지 말아야 한다.
  * 이러한 방식은 검사 예외보다 좋은 게 없으면서 사용자를 헷갈리게 한다.
* **검사 예외를 직접 정의하는 경우, 예외 상황에 대한 정보 및 예외로부터 회복하기 위해 필요한 정보를 제공할 수 있는 메소드를 정의하는 것이 바람직**하다.
  * 그렇지 않을 경우 예외로부터 발생한 메시지를 토대로 필요한 정보를 파싱해야 하는데, 이는 바람직하지 않은 상황이다.
  * 메시지 문자열을 파싱하여 얻은 코드는 모든 환경에서 일관적으로 동작하지 못할 수 있다.

### 필요 없는 검사 예외의 사용은 지양하기
* 검사 예외는 제대로 활용하면 API의 질과 안정성을 높일 수 있다.
* **그러나 검사 예외를 과하게 사용하면 API의 사용성만을 떨어트린다**.
  * 예를 들어, API 사용자는 검사 예외를 처리하기 위해 catch 블록을 두어 처리하거나, 바깥으로 재전파해야 한다.
  * 어느쪽이든 API 사용자 입장에서는 예외 처리를 위한 부담 요소이며, 이는 특히 메소드가 단 하나의 검사 예외를 던지는 경우에서 가장 크다.
* API를 제대로 사용해도 발생할 수 있는 예외이거나, 개발자가 조치를 취할 수 있는 경우라면 검사 예외를 사용해도 무방하다.
  * 둘 모두에 해당하지 않는 경우, 비검사 예외를 사용하는 것이 좋다.
* **검사 예외를 회피하는 가장 쉬운 방법은 적절한 타입을 담는 옵셔널을 반환하는 방법이다**.
  * **이러한 방식은 예외가 발생한 이유를 명시하는 부가 정보를 포함할 수 없다는 단점도 존재**한다.
* 또는 검사 예외를 던지는 메소드를 2개로 쪼개어 비검사 예외로 리팩토링할 수도 있다.
  * 쪼개진 메소드 중 첫 번째는 예외 여부를 boolean 형태로 반환하는 메소드이며, 두 번째 메소드는 기존 메소드의 기능을 담당한다.
  * 이러한 리팩토링은 모든 상황에 적용할 수 없지만, 적용한 경우에는 API의 사용성을 높여줄 수 있다.
* 이러한 리팩토링은 외부 동기화 없이 여러 스레드에서 사용하는 경우, 또는 외부 요인에 의해 상태가 변할 수 있는 경우에 적합하지 못하다.
  * 예외 상황을 체크하는 메소드와 실제 동작을 수행하는 메소드 사이에서 상태가 변경될 수 있기 때문이다.

### 검사 예외의 결론
* 적시에 사용한 검사 예외는 프로그램의 안전성을 높이지만, 남용하면 API의 사용성만 떨어트릴 뿐이다.
* API 호출자가 예외로부터 복구할 방법이 없다고 판단되면 비검사 예외를 던진다.
* 복구가 가능하고 호출자가 해당하는 처리를 해주기를 바라는 경우라면, 우선 옵셔널 반환을 고려한다.
* 옵셔널만으로는 상황을 처리하기에 충분한 정보를 제공할 수 없는 경우에만 검사 예외를 던지도록 한다.

## 2022-03-15 Tue
### 표준 예외를 사용하기
* **경험이 많은 개발자는 더 많은 코드를 재사용할 수 있으며, 예외 역시 재사용이 가능한 코드**이다.
  * Java 라이브러리는 대부분의 API에서 사용하기에 충분한 예외를 제공한다.
* 표준 예외를 재사용하는 경우, API는 다른 개발자들에게 익숙하고 배우기 쉬운 코드가 된다.
  * 또한, **예외 클래스 수가 적을수록 메모리 사용량 및 클래스 적재에 필요한 시간도 줄게 된다**.
* 자주 재사용될 수 있는 예외는 다음과 같다.
  1. IllegalArgumentException: 메소드 호출자가 인수에 적절하지 못한 값을 넘길 때 던질 수 있는 예외이다.
  2. IllegalStateException: 객체의 상태가 완전히 초기화되지 않아 메소드를 수행하기 위해 적절하지 않은 경우에 던질 수 있는 예외이다.
  3. NullPointerException: null을 허용하지 않는 메소드에 null을 사용한 경우에 던질 수 있는 예외이다.
  4. IndexOutOfBoundsException: 인덱스 범위를 넘어서려는 시도에 대해 던질 수 있는 예외이다.
  5. ConcurrentModificationException: 단일 스레드로 사용하려고 설계된 객체를 여러 스레드가 동시에 수정하려고 하는 경우에 던질 수 있는 예외이다.
  6. UnsupportedOperationException: 호출된 메소드를 지원하지 않는 경우에 던질 수 있는 예외이다.
* **Exception, RuntimeException, Throwable, Error는 추상 클래스로 취급하며, 직접 재사용하지 말아야 한다**.
* **상술한 예외 이외에도 재사용 가능한 예외가 많이 있으며, 상황에 부합하는 적절한 표준 예외를 활용**해야 한다.
  * 이 때, API 문서를 참고하여 예외가 어떤 상황에서 사용되는지 확인해야 한다.
* 표준 예외가 제공하는 정보보다 더 많은 내용을 제공하고자 하는 경우, 표준 예외를 확장하는 새로운 예외를 작성하여도 무방하다.
* IllegalStateException과 IllegalArgumentException 중 어느 예외를 사용할지 고민된다면, 인수와 무관하게 호출 성공 여부를 토대로 결정한다.
  * 예를 들어, 인수 값과 관계 없이 실패했을 상황에는 IllegalStateException을 던질 수 있도록 한다.

### 추상화 수준에 걸맞는 예외를 사용하기
* **메소드가 저수준의 예외를 처리하지 않고 그대로 외부로 전파하는 경우, 작업과 관련 없어보이는 엉뚱한 예외가 튀어나온 것 처럼 보일 수 있다**.
  * 또한 이러한 방식은 내부 구현 방식을 드러내어 상위 레벨의 API를 오염시킬 수 있다.
* **저수준 예외를 잡는 상위 계층에서는 자신의 추상화 수준에 맞는 예외로 바꾸는 예외 번역을 적용한 후에 다시 전파**해야 한다.
* **예외를 번역하는 경우, 저수준의 예외가 디버깅에 도움을 줄 수 있을 것으로 판단된다면 예외 연쇄를 사용**한다.
  * **예외 연쇄란, 고수준 예외의 생성자에 원인 예외를 건내어 근본 원인인 저수준 예외를 고수준 예외에 싣는 방식**이다.
  * 대부분의 표준 예외는 예외 연쇄를 위한 생성자를 갖추고 있다. 
  * 그렇지 않은 경우에는 Throwable의 initCause 메소드를 활용하는 것으로 원인은 직접 명시할 수 있다.
* **예외 연쇄는 문제의 원인을 getCause 메소드로 애플리케이션에서 접근할 수 있게 하며, 원인과 고수준 예외의 스택 트레이스를 잘 통합해주는 역할**을 한다.
* 예외 번역은 예외 전파의 남용보다는 좋지만, 역시 남용해서는 좋을 것이 없다.
  * 가능하다면, 저수준의 메소드를 반드시 성공하도록 하는 것이 이상적이다.
  * 예외를 피할 수 없다면, 상위 계층에서 예외를 암시적으로 처리한 후 java.util.logging 등을 통해 로깅할 수 있다.
  * 이러한 방식은 클라이언트 코드에 예외를 전파하지 않으면서도 로그 분석을 통한 추가 조치를 가능케 한다.

### 추상화 수준에 걸맞는 예외 사용의 결론
* 저수준의 예외를 방지하거나 처리할 수 없고, 예외를 그대로 고수준에 노출하고 싶지 않다면 예외 번역을 사용할 수 있다.
* 예외 번역을 활용하는 경우, 예외 연쇄를 통해 상위 계층에 걸맞는 고수준 예외를 던지면서도 근본 원인을 함께 전달하여 오류를 쉽게 분석할 수 있다.

### 메소드가 던지는 모든 예외를 문서화하기
* 메소드가 던지는 예외는 해당 메소드의 사용에 있어서 중요한 정보이므로, 발생 가능한 예외를 문서화하는 데에 충분한 시간을 들여야 한다.
* 발생 가능한 예외를 문서화하지 않는다면 다른 개발자가 해당 클래스나 인터페이스를 사용하기 어려울 수 있으며, 최악의 경우 불가능할 수도 있다.
* 검사 예외는 항상 따로 선언하고, 각 예외가 발생하는 상황을 javadoc의 @throws 태그를 활용하여 정확히 문서화한다.
  * 이 때, Exception이나 Throwable과 같은 공통 상위 예외로 뭉뚱그려 표현하지 말아야 한다.
  * 예외적으로 main 메소드는 JVM만이 호출하므로, Exception을 던지도록 뭉뚱그려 정의해도 좋다.
* 비검사 예외도 검사 예외처럼 문서화해두는 것이 이상적이다.
  * 잘 작성된 비검사 예외는 해당 메소드를 성공시키기 위한 전제 조건이 된다.
  * public 메소드라면 응당 필요한 전제 조건은 문서화되어야 하며, 비검사 예외의 문서화는 이를 지킨 좋은 예시에 속한다.
* 발생 가능한 비검사 예외를 문서화하는 것은 인터페이스 메소드에서 특히 중요하다.
  * 비검사 예외 조건은 인터페이스의 일반 규약에 속하며, 해당 인터페이스를 구현하는 구현체의 일관된 동작을 보장해줄 수 있다.
* **메소드가 던질 수 있는 예외는 모두 @throwa를 활용하여 문서화하되, 메소드의 throws 절에는 검사 예외만 작성**한다.
* 하나의 클래스에 속한 다수의 메소드가 같은 이유에서 같은 예외를 던진다면, 예외를 메소드 각각이 아닌 클래스 설명에 추가할 수 있다.
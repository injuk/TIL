# EffectiveCodes
## 2022-03-10 Thu

## 메소드
### 매개변수의 유효성을 검사하기
* 메소드, 생성자 등은 대부분 입력 매개변수의 값이 만족해야하는 조건을 갖는다.
* **이러한 조건은 문서화되어야 하며, 메소드 본문이 시작되기 전에 최대한 빠르게 오류를 잡아낼 수 있어야 한다**.
  * 특히 public, protected 메소드는 매개변수의 값이 비정상인 경우에 던지는 예외를 반드시 문서화해야 한다.
  * 일반적인 원칙으로, **오류는 가능한 한 빨리 발생한 곳과 가까이에서 잡아내야 한다**.
* 메소드 본문이 실행되기 전에 매개변수의 정상성을 확인하면 매개변수의 값이 잘못된 경우 즉시 원하는 예외를 던질 수 있다.
* **null을 검증하는 경우, Java 7부터 추가된 정적 메소드인 Objects.requireNonNull을 활용**할 수 있다.
  * Objects.requireNonNull 메소드는 유연하고 사용성도 좋으므로, 이제 직접 null 확인 코드를 작성하여 체크할 필요가 없다.
* **공개되지 않은 메소드라면 패키지 제작자인 개발자 자신이 메소드 호출 환경을 통제할 수 있으므로, 오직 유효한 값이 넘겨지리라는 것을 보증**할 수 있다.
  * 응당 유효성을 보증해야 하며, 이를 위해 public이 아닌 메소드에서 assert 문을 사용하여 검증할 수 있다.
* **메소드가 직접 사용하지 않지만, 추후에 사용될 값을 매개변수로 받아 저장하는 형태는 더욱 주의 깊게 검사**해야 한다.
  * **생성자는 이러한 원칙의 특수한 사례이며, 생성자에 전달된 매개변수의 유효성 검사는 클래스 불변식을 어기지 않기 위해 반드시 필요한 과정**이다.
* 매개변수의 유효성을 반드시 검사하지 않아도 되는 예외 상황도 존재하며, 그 예시는 다음과 같다.
  1. 유효성 검사 비용이 지나치게 높거나, 실용성이 없는 경우.
  2. 메소드 본문의 연산 과정에서 암묵적으로 검사가 수행되는 경우.
* 그러나 **암묵적인 유효성 검사에 너무 의존하면 메소드의 실패 원자성을 보장하지 못할 수 있으므로, 과신하지 말아야 한다**.
* **메소드는 최대한 범용적으로 설계하되, 매개변수의 제약사항을 반드시 고려하고 문서화와 유효성 검사 코드를 작성하는 습관을 함양하는 것이 바람직**하다.

### 적절한 시점에 방어적 복사본을 만들기
* Java는 안전한 언어이지만, 아무런 노력 없이 다른 클래스로부터의 침범을 모두 자동으로 막을 수 있는 것은 아니다.
  * 때문에 **언제나 클라이언트 코드가 우리의 클래스 불변식을 깨트리고 싶어한다고 가정하고 방어적인 프로그래밍을 수행**하여야 한다.
  * 즉, 클라이언트 코드로부터 클래스를 보호하는 데에 충분히 시간을 투자해야 한다.
* 클래스 내부의 final 멤버 변수에 참조 타입을 사용하는 경우를 예로 들어, 참조 타입이 가변이라면 불변식은 쉽게 깨질 수 있다.
  * 특히 Date와 같은 낡은 API에서 쉽게 발견되는 문제이며, 새로운 코드를 작성할 때 Date는 더 이상 사용하지 말아야 한다.
* **매개변수의 유효성을 검사하기 전에 방어적 복사본을 만든 후, 복사본으로 유효성을 검사하도록 코드를 작성**한다.
  * 순서가 부자연스러워 보일 수 있지만, 멀티스레딩 환경에서는 유효성 검사 후 복사본을 만드는 찰나에 위험이 생길 수 있으므로 반드시 이 순서를 유지해야 한다.
* **이러한 방어적 복사 과정에서, 복사 대상 클래스가 제 3자에 의해 확장될 수 있는 타입이라면 clone 메소드를 절대 사용하지 말아야 한다**.
  * **final이 아닌 클래스에서는 clone이 악의적인 의도로 재정의되었을 가능성을 배제할 수 없다**.
* **생성자 뿐만 아니라, 접근자에서도 필드를 그대로 반환한다면 내부의 가변 정보가 직접 드러나게 된다**.
  * **이를 방지하기 위해 접근자 메소드 역시 가변 필드의 방어적 복사본을 반환하도록 구현**한다.
* **방어적 복사는 불변 객체를 위해서만 사용하는 개념이 아니다**.
* **메소드나 생성자 모두 클라이언트 코드가 제공한 참조를 내부의 필드에 보관하는 경우라면 객체의 잠재적인 변경 가능성을 반드시 고려**해야 한다.
  * **변경될 수 있는 객체라면, 클래스 내부에 넘겨진 객체가 임의로 변경되더라도 클래스가 오동작하지 않는지 고려**한다.
  * **오동작 가능성이 조금이라도 있거나, 이를 확신할 수 없다면 반드시 방어적 복사본을 만들어 저장하도록 정의**해야 한다.
* **접근자 메소드에서도 마찬가지이며, 클래스의 가변성과 관계 없이 가변인 내부 객체를 클라이언트에 반환할 때에는 반드시 모든 상황을 신중히 고려**해야 한다.
  * 안심할 수 없는 경우가 조금이라도 있다면 반드시 원본 대신 방어적 복사본을 활용하도록 한다.
* **방어적 복사는 필연적으로 성능 저하가 수반되며, 언제나 사용할 수 있는 방식도 아니다**.
  * 때문에 **클래스 작성시 가능한 한 불변 객체를 조합하여 구성해야 방어적 복사를 수행해야 할 일이 줄어든다**.
* 복사 비용이 너무 크거나, 클라이언트가 요소를 잘 못 수정할 일이 없다고 확신할 수 있다면 방어적 복사 대신 문서화를 선택할 수 있다.
  * 예를 들어, 구성 요소를 수정했을 경우 책임은 클라이언트 코드에 있음을 명시할 수 있다.

### 메소드 시그니쳐는 신중히 설게하기
* 메소드 이름은 신중히 정의해야 한다.
  1. 같은 패키지에 속하는 다른 이름들과 일관성 있게 명명한다.
  2. 개발자들 사이에서 널리 받아들여지는 이름을 사용한다.
  3. 긴 이름은 지양한다.
* 편의 메소드를 너무 많이 작성하지 않아야 한다.
  1. 메소드가 많은 클래스는 익히고, 사용하고, 테스트하고, 유지보수하기 어렵다.
  2. 인터페이스 역시 마찬가지로, 메소드가 너무 많으면 구현과 사용이 어렵다.
  3. **확신이 서지 않는다면 새로운 메소드를 만들지 않아야 한다**!
* 매개변수 목록은 4개 이하로 유지한다.
  * 특히, 같은 타입의 매개 변수가 여럿 연달아 나오는 것은 지양해야 한다.
  * 순서를 기억하기도 어려울 뿐더러 컴파일도 정상적으로 수행되므로 디버깅이 어렵다.
* 과하게 긴 매개변수 목록은 다음과 같은 방법을 통해 줄일 수 있다.
  1. 메소드를 여럿으로 쪼갠다.
  2. 매개변수 여럿을 하나로 묶어주는 도우미 클래스를 작성한다.
     * 일반적으로, 도우미 클래스는 정적 멤버 클래스인 경우가 많다.
* **매개변수의 타입으로는 클래스보다 인터페이스가 더 좋다**.
  * 예를 들어, HashMap을 매개변수로 넘기는 대신 Map을 넘기도록 구현한다.
  * 이 경우, TreeMap, ConcurrentHashMap, 등의 Map 구현체는 물론 **아직 존재하지 않는 Map도 매개변수로 넘겨줄 수 있다**.
  * 인터페이스 대신 구현 클래스를 사용하면 클라이언트가 강제로 해당 클래스에 의존하게 만든다.
* 일반적으로 boolean을 반환하는 것보다는 원소 2개를 포함하는 열거 타입을 반환하는 것이 좋다.
  * 예외적으로, 메소드 이름상 boolean을 받아야 의미가 명확한 것은 예외이다.
  * 열거 타입을 활용하면 코드를 읽고 쓰기가 쉬워지며, 추후에 새로운 값을 추가하기도 용이하다.

### 다중 정의는 신중히 활용하기
* **재정의한 메소드는 런타임에 동적으로 선택되지만, 다중 정의한 메소드는 컴파일 타임에 정적으로 선택**된다.
* **다중 정의된 메소드에서 객체의 런타임 타입은 전혀 중요하지 않으며, 선택은 컴파일 타임에 컴파일 타임 타입에 의해서만 결정**된다.
* 개발자에게는 재정의가 정상적인 동작 방식이고, 다중 정의가 예외적인 동작으로 보이기 쉽다.
  * 따라서 다중 정의로 인해 혼란스러워지는 상황을 애당초 피하도록 한다.
* **안전하고 보수적으로 코드를 작성하려면 매개변수 수가 같은 다중 정의는 아예 만들지 않아야 한다**.
  * 다중 정의 대신 메소드 이름을 모두 다르게 지어지는 것을 고려할 수 있는 방식이다.
* 생성자는 이름을 다르게 정의할 수 없으므로, 두 번째 이후의 생성자는 무조건 다중 정의이다.
  * **하지만 정적 팩토리라는 대안을 활용할 수 있는 경우가 많다**.
* 매개 변수 수가 같은 다중 정의 메소드가 많아졌더라도, 어떤 것이 주어진 매개 변수 집합을 처리할지 명확하다면 이상이 없다.
  * 다시 말해, 매개 변수 중 하나 이상이 근본적으로 다른 타입이기에 서로를 향해 형변환할 수 없는 상황이다.
  * **이러한 조건을 충족하면 호출될 다중 정의 메소드는 컴파일 타임에 영향을 받지 않고 런타임 타입만으로 결정될 수 있다**.
* **다중 정의된 메소드에 같은 객체를 입력했을 때 완전히 같은 동작을 수행한다면, 해로울 것은 없다**.
  * 이를 구현하는 일반적인 방식은 더 특수한 다중 정의 메소드에서 더 일반적인 다중 정의 메소드로 작업을 포워딩하는 것이다.

### 다중 정의의 결론
* 언어 차원에서 다중 정의를 지원한다고 해서 다중 정의를 반드시 활용해야하는 것은 아니다.
* 일반적으로, 매개 변수의 수가 같다면 다중 정의를 지양하는 것이 바람직하다.
* 특히 생성자의 경우 다중 정의를 완전히 피할 수 없는 상황이 생길 수 있다.
  * 이러한 경우에는 헷갈릴 만한 매개 변수를 형변환하여 정확한 다중 정의 메소드가 선택되도록 구현한다.
* 기존 클래스를 수정하여 새로운 인터페이스를 구현하는 등의 경우에는 같은 객체를 입력받는 다중 정의 메소드들이 모두 같은 동작을 수행하도록 구현한다.
* 상술한 원칙이 지켜지지 않는 경우, 개발자는 다중 정의된 메소드나 생성자를 효과적으로 사용할 수도 없을 뿐더러 디버깅에 어려움을 겪을 수 있다.

## 2022-03-11 Fri
### 가변 인수는 신중하게 사용하기
* 가변 인수는 명시된 타입의 인수를 0개 이상 받아 처리할 수 있다.
  * 가변 인수 메소드는 우선 인수의 개수와 길이가 같은 배열을 생성하고, 인수를 배열에 저장하여 메소드를 시작한다.
* **가변 인수 메소드는 인수의 개수가 정해지지 않았을 때 고려할 수 있는 매우 유용한 방법**이다.
* **가변 인수 메소드를 무작정 작성한 경우, 인수를 0개만 넣어 호출할 때 컴파일 시점이 아닌 런타임에서 실패할 가능성**이 있다.
  * 때문에 args 검사를 명시적으로 반드시 수행해야 하고, 향상된 for 문을 사용하기도 어렵다.
* 이러한 문제는, 인수를 두 개로 나누어 첫 번째 인수를 필수 인수로, 두번째 인수를 가변 인수로 작성하여 해결할 수 있다.
* **가변 인수 메소드는 매 호출시마다 새로운 배열을 생성하므로, 성능에 민감한 상황에서는 걸림돌**이 될 수 있다.
  * 이러한 경우, 메소드 호출시 전달된 인수 개수의 통계 정보를 활용하여 최적화할 수 있다.
  * **예를 들어 해당 메소드 전체 호출의 95%가 인수의 개수를 3개 이하로 사용했다면, 인수의 개수가 1, 2, 3개인 메소드를 각각 다중정의하여 처리**한다.
  * 이 경우, 전체 메소드 전체 호출의 5%만을 가변 인수 메소드가 처리하여 배열을 생성하게 될 것이다.

### null 보다는 빈 컬렉션이나 빈 배열을 반환하기
* **빈 배열이나 빈 컬렉션을 체크하여 null을 반환하는 등 특별히 취급할 이유는 전혀 없다**.
  * 빈 배열 또는 컬렉션을 그대로 반환하지 않고 null을 반환하는 API는 사용이 어렵고, 오류 처리 코드를 늘리는 반면 성능이 크게 좋아지지도 않는다.
* **컬렉션이나 배열과 같은 컨테이너가 비었을 때 null을 반환하는 메소드는 클라이언트 측의 null 방어 코드 작성을 강요**한다. 
* 빈 컨테이너를 할당하기 위한 비용은 크게 신경쓸 만한 수준이 되지 않는다.
  * 만약 실제로도 빈 컨테이너의 할당이 성능을 떨어트리는 원인이 되고 있다면, 미리 준비된 빈 불변 컬렉션 또는 빈 배열을 반환한다.
* 예를 들어 **컬렉션의 경우 Collections.emptyList 또는 Collections.emptySet이 있으며, 길이가 0인 배열은 모두 불변**이다.
  * 이러한 **성능 최적화는 반드시 필요한 경우에만 적용하되, 수정 전과 수정 후의 성능을 측정하여 실제로 성능이 개선되는지 반드시 확인한 후에 적용**한다.

### 옵셔널 반환은 신중하게 하기
* Java 8 이전에는 메소드가 특정한 조건에서 값을 반환할 수 없을 때 사용할 수 있는 선택지는 둘이었다.
  1. 예외를 던진다.
  2. 반환형이 참조 타입인 경우, null을 반환한다.
* 두 방법은 모두 나름대로의 허점이 존재한다.
  1. 예외는 진짜 예외 상황에서만 사용해야 하며, 스택 트레이스로 인한 비용이 크다.
  2. null을 반환하는 코드를 사용하는 경우, null 처리 코드의 작성이 강제된다.
     * 또한, 자칫하면 코드와 먼 곳에서 NPE가 발생할 가능성이 있다.
* Java 8 이후로 Optional<T>이라는 새로운 선택지가 추가되었다.
* **Optional은 null이 아닌 T 타입 참조를 하나 담거나, 아무 것도 담지 않을 수 있는 불변 컨테이너**이다.
* 일반적으로, T를 반환해야하지만 특정 조건에서는 아무 것도 반환하지 않을 수도 있다면 Optional<T>를 반환하도록 정의한다.
  * 이를 통해 유효한 반환이 없을 경우 빈 결과를 반환하게 된다.
* 옵셔널을 반환하는 메소드는 예외를 던지는 메소드보다 유연하고 사용성이 좋으며, null을 반환하는 메소드보다 잠재적인 오류 가능성이 적다.
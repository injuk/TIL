# EffectiveCodes
## 2022-03-10 Thu

## 메소드
### 매개변수의 유효성을 검사하기
* 메소드, 생성자 등은 대부분 입력 매개변수의 값이 만족해야하는 조건을 갖는다.
* **이러한 조건은 문서화되어야 하며, 메소드 본문이 시작되기 전에 최대한 빠르게 오류를 잡아낼 수 있어야 한다**.
  * 특히 public, protected 메소드는 매개변수의 값이 비정상인 경우에 던지는 예외를 반드시 문서화해야 한다.
  * 일반적인 원칙으로, **오류는 가능한 한 빨리 발생한 곳과 가까이에서 잡아내야 한다**.
* 메소드 본문이 실행되기 전에 매개변수의 정상성을 확인하면 매개변수의 값이 잘못된 경우 즉시 원하는 예외를 던질 수 있다.
* **null을 검증하는 경우, Java 7부터 추가된 정적 메소드인 Objects.requireNonNull을 활용**할 수 있다.
  * Objects.requireNonNull 메소드는 유연하고 사용성도 좋으므로, 이제 직접 null 확인 코드를 작성하여 체크할 필요가 없다.
* **공개되지 않은 메소드라면 패키지 제작자인 개발자 자신이 메소드 호출 환경을 통제할 수 있으므로, 오직 유효한 값이 넘겨지리라는 것을 보증**할 수 있다.
  * 응당 유효성을 보증해야 하며, 이를 위해 public이 아닌 메소드에서 assert 문을 사용하여 검증할 수 있다.
* **메소드가 직접 사용하지 않지만, 추후에 사용될 값을 매개변수로 받아 저장하는 형태는 더욱 주의 깊게 검사**해야 한다.
  * **생성자는 이러한 원칙의 특수한 사례이며, 생성자에 전달된 매개변수의 유효성 검사는 클래스 불변식을 어기지 않기 위해 반드시 필요한 과정**이다.
* 매개변수의 유효성을 반드시 검사하지 않아도 되는 예외 상황도 존재하며, 그 예시는 다음과 같다.
  1. 유효성 검사 비용이 지나치게 높거나, 실용성이 없는 경우.
  2. 메소드 본문의 연산 과정에서 암묵적으로 검사가 수행되는 경우.
* 그러나 **암묵적인 유효성 검사에 너무 의존하면 메소드의 실패 원자성을 보장하지 못할 수 있으므로, 과신하지 말아야 한다**.
* **메소드는 최대한 범용적으로 설계하되, 매개변수의 제약사항을 반드시 고려하고 문서화와 유효성 검사 코드를 작성하는 습관을 함양하는 것이 바람직**하다.

### 적절한 시점에 방어적 복사본을 만들기
* Java는 안전한 언어이지만, 아무런 노력 없이 다른 클래스로부터의 침범을 모두 자동으로 막을 수 있는 것은 아니다.
  * 때문에 **언제나 클라이언트 코드가 우리의 클래스 불변식을 깨트리고 싶어한다고 가정하고 방어적인 프로그래밍을 수행**하여야 한다.
  * 즉, 클라이언트 코드로부터 클래스를 보호하는 데에 충분히 시간을 투자해야 한다.
* 클래스 내부의 final 멤버 변수에 참조 타입을 사용하는 경우를 예로 들어, 참조 타입이 가변이라면 불변식은 쉽게 깨질 수 있다.
  * 특히 Date와 같은 낡은 API에서 쉽게 발견되는 문제이며, 새로운 코드를 작성할 때 Date는 더 이상 사용하지 말아야 한다.
* **매개변수의 유효성을 검사하기 전에 방어적 복사본을 만든 후, 복사본으로 유효성을 검사하도록 코드를 작성**한다.
  * 순서가 부자연스러워 보일 수 있지만, 멀티스레딩 환경에서는 유효성 검사 후 복사본을 만드는 찰나에 위험이 생길 수 있으므로 반드시 이 순서를 유지해야 한다.
* **이러한 방어적 복사 과정에서, 복사 대상 클래스가 제 3자에 의해 확장될 수 있는 타입이라면 clone 메소드를 절대 사용하지 말아야 한다**.
  * **final이 아닌 클래스에서는 clone이 악의적인 의도로 재정의되었을 가능성을 배제할 수 없다**.
* **생성자 뿐만 아니라, 접근자에서도 필드를 그대로 반환한다면 내부의 가변 정보가 직접 드러나게 된다**.
  * **이를 방지하기 위해 접근자 메소드 역시 가변 필드의 방어적 복사본을 반환하도록 구현**한다.
* **방어적 복사는 불변 객체를 위해서만 사용하는 개념이 아니다**.
* **메소드나 생성자 모두 클라이언트 코드가 제공한 참조를 내부의 필드에 보관하는 경우라면 객체의 잠재적인 변경 가능성을 반드시 고려**해야 한다.
  * **변경될 수 있는 객체라면, 클래스 내부에 넘겨진 객체가 임의로 변경되더라도 클래스가 오동작하지 않는지 고려**한다.
  * **오동작 가능성이 조금이라도 있거나, 이를 확신할 수 없다면 반드시 방어적 복사본을 만들어 저장하도록 정의**해야 한다.
* **접근자 메소드에서도 마찬가지이며, 클래스의 가변성과 관계 없이 가변인 내부 객체를 클라이언트에 반환할 때에는 반드시 모든 상황을 신중히 고려**해야 한다.
  * 안심할 수 없는 경우가 조금이라도 있다면 반드시 원본 대신 방어적 복사본을 활용하도록 한다.
* **방어적 복사는 필연적으로 성능 저하가 수반되며, 언제나 사용할 수 있는 방식도 아니다**.
  * 때문에 **클래스 작성시 가능한 한 불변 객체를 조합하여 구성해야 방어적 복사를 수행해야 할 일이 줄어든다**.
* 복사 비용이 너무 크거나, 클라이언트가 요소를 잘 못 수정할 일이 없다고 확신할 수 있다면 방어적 복사 대신 문서화를 선택할 수 있다.
  * 예를 들어, 구성 요소를 수정했을 경우 책임은 클라이언트 코드에 있음을 명시할 수 있다.
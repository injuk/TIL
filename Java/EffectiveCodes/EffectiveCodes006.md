# EffectiveCodes
## 2022-03-08 Tue

## 람다와 스트림
### 익명 클래스보다는 람다를 사용하기
* Java 8 이전에는 Java에서 함수를 표현할 때 추상 메소드를 하나만 담은 인터페이스를 사용하곤 했다.
  * 이러한 **인터페이스는 추상적인 기능을 나타내며, 구체적인 동작은 인터페이스를 구현하는 익명 클래스를 통해 정의**된다.
* 그러나 기존의 익명 클래스 방식은 코드가 길어지며 가독성이 떨어지는 단점이 있었기에 Java는 함수형 프로그래밍에 적합하지 않았다.
* 이렇듯 **메소드를 하나만 갖는 인터페이스는 Java 8 이후에서 함수형 인터페이스로 취급되며, 그 인스턴스를 람다식을 활용하여 생성**할 수 있게 되었다.
* 람다로 정의된 코드는 함수 또는 익명 클래스와 역할이 유사하지만, 코드는 훨씬 간결하게 작성된다.
* 람다식은 컴파일러가 타입을 추론하므로 타입을 명시할 필요가 없지만, 컴파일러가 추론할 수 없는 경우에는 개발자가 타입을 명시해야 한다.
  * 타입 추론 규칙은 매우 복잡하며, 애당초 이를 완벽히 이해하는 개발자는 거의 없으므로 외울 필요도 없다.
  * **기본적으로 타입을 명시해야만 가독성이 향상되는 경우를 제외하고는 타입 명시를 생략하되, 컴파일러 오류가 발생할 때에만 타입을 명시**하도록 한다.
  * **컴파일러는 타입 추론에 필요한 정보를 대부분 제네릭에서 얻으므로, 람다를 사용하는 경우 제네릭을 적극적으로 활용하고 로우 타입을 지양**해야 한다.
* **람다는 일반적인 메소드 또는 클래스와 달리 이름이 없고 문서화가 불가능**하다.
  * 따라서 람다식 자체로 동작이 명확히 설명되지 않거나, 코드의 길이가 길어지는 경우에는 람다식을 적용하지 말아야 한다.
  * **람다식은 한 줄일 때 효과가 가장 좋고, 최대 세 줄을 넘지 않는 것이 이상적**이다.
* **람다식의 사용이 어렵거나 가독성이 떨어진다면, 코드를 줄이거나 람다식을 사용하지 말아야 한다**.
* **익명 클래스의 입지는 크게 줄었으나, 람다는 추상 메소드가 하나인 함수형 인터페이스에서만 적용이 가능하므로 익명 클래스를 완전히 대체하지 못한다**.
* 다음의 경우는 람다가 익명 클래스를 대체하지 못하는 경우로, 이러한 경우에는 익명 클래스를 사용해야 한다.
  1. 추상 클래스의 인스턴스화를 위해서는 람다를 사용할 수 없다.
  2. 추상 메소드가 여러 개인 인터페이스의 인스턴스화를 위해서는 람다를 사용할 수 없다.
  3. **람다는 자신을 참조할 수 없으므로, 함수 객체가 자신을 this로 참조해야하는 경우에는 반드시 익명 클래스를 사용**한다.
     * **익명 클래스의 인스턴스가 this로 자신을 참조하는 것과 달리, 람다의 this는 함수 객체 자신이 아닌 바깥 인스턴스를 참조**한다.
* **즉, 익명 클래스는 함수형 인터페이스가 아닌 경우의 인스턴스화에만 사용**한다.
* **람다의 직렬화는 최대한 지양해야 하며, 함수 객체를 직렬화해야 하는 경우에는 private 정적 중첩 클래스를 사용**한다.

### 람다보다는 메소드 참조를 사용하기
* **람다가 익명 클래스와 비교하여 가독성과 간결함을 한 단계 향상시켰다면, 메소드 참조는 람다보다도 더 간결한 코드를 만들어준다**.
  * **메소드 참조는 함수 객체 자체를 람다보다 간결하게 표현하므로, 람다 대신 메소드의 참조를 활용하여 같은 결과를 더 보기 좋게 얻을 수 있다**.
  * 메소드 또는 람다의 매개 변수 수가 늘어날수록 메소드 참조로 제거할 수 있는 코드의 양도 많아진다.
* 때로는 람다의 매개 변수명, 구조 자체가 메소드 참조를 적용한 경우보다 개발자에게 더 좋은 가이드가 되는 경우도 있다.
  * 즉, **람다로 표현한 경우가 메소드 참조를 사용한 경우보다 가독성이 좋은 경우 억지로 메소드 참조를 적용할 필요는 없다**.
    * 예를 들어, java.util.Function의 함수형 인터페이스인 Function.identity()를 사용하는 것보다는 (x -> x)가 가독성이 높다.
  * 때문에 **메소드 참조를 사용한 경우가 짧고 명확한 경우에만 메소드 참조를 사용하고, 그렇지 않은 경우에는 람다를 사용하는 것이 바람직**하다.
* **람다로 구현했을 때 너무 길거나 복잡한 경우는 메소드 참조를 활용할 수 있는 좋은 예시**로, 다음과 같이 메소드 참조를 활용할 수 있다.
  1. 람다로 표현한 기능을 새로운 메소드에 정의한다.
     * 이 때, **새로운 메소드는 람다와 달리 기능이 잘 드러나는 이름을 명명하거나 적절한 내용을 문서로 작성해줄 수 있다**.
  2. 람다 대신 작성한 메소드의 참조를 사용한다.
* 메소드 참조의 유형은 크게 다음의 다섯 가지로 나뉜다.
  1. 정적 메소드 참조: 가장 흔한 유형이다.
  2. 한정적 인스턴스 메소드 참조: 수신 객체를 특정하는 메소드 참조이다.
  3. 비한정적 인스턴스 메소드 참조: 수신 객체를 특정하지 않는 메소드 참조이다.
  4. 클래스 생성자 메소드 참조: 클래스의 생성자를 가리키는 메소드 참조이며, 팩토리 객체로 사용된다.
  5. 배열 생성자 메소드 참조: 배열의 생성자를 가리키는 메소드 참조이다.
* **한정적 인스턴스 메소드 참조는 기본적으로 정적 메소드 참조와 유사하며, 함수 객체가 받는 인수와 참조되는 메소드가 받는 인수가 같다**.
* **비한정적 인스턴스 메소드 참조는 함수 객체를 적용하는 시점에 수신 객체를 전달하므로, 수신 객체 전달을 위한 매개 변수를 전달해야 한다**.
  * 이 경우 수신 객체 전달용 매개 변수가 매개 변수 목록의 첫 번째에 위치하며, 그 이후의 매개 변수 목록은 참조되는 메소드 선언에 정의된 목록과 같다.
  * **비한정적 인스턴스 메소드 참조는 주로 함수 객체 적용 시점에 수신 객체를 알 수 있는 스트림 파이프라인에서의 매핑과 필터에 사용**된다.

### 표준 함수형 인터페이스를 사용하기
* Java가 람다를 지원하면서 API를 작성하는 모범 사례도 크게 바뀌었다.
  * 예를 들어, 상위 클래스의 메소드를 재정의하여 원하는 동작을 구현하는 템플릿 메소드의 매력이 크게 줄었다.
  * **이를 대체하는 현대적인 방식은 같은 효과의 함수 객체를 받는 정적 팩토리나 생성자를 제공하는 것**이다.
* **즉, 이후로는 함수 객체를 받는 생성자나 메소드를 더 많이 작성해야 한다**.
  * **이는 곧 API를 새로 설계하는 개발자가 반드시 람다도 염두에 두어야 함을 의미하기도** 한다.
  * 이 때, 함수형 매개변수 타입을 올바르게 선택할 수 있어야 한다.
* Java 표준 라이브러리인 **java.util.function 패키지에는 다양한 용도에 맞는 표준 함수형 인터페이스가 이미 정의**되어 있다.
  * 따라서 **함수형 인터페이스를 정의하기 전에, 우선 용도에 맞는 표준 함수형 인터페이스가 존재하는지 확인하는 것이 바람직**하다.
  * 이를 통해 API가 다루는 개념의 수가 줄게 되므로 API를 익히기 쉬워진다.
* **표준 함수형 인터페이스는 유용한 default 메소드를 많이 제공하므로, 다른 코드와의 상호 운용성도 향상**시킬 수 있다.
* **표준 함수형 인터페이스 중 다음과 같은 기본 인터페이스 6개를 기억하는 것으로 나머지 인터페이스의 기능은 쉽게 유추**할 수 있다.
  1. UnaryOperator: 하나의 인수를 받아 값을 반환하며, 반환값과 인수의 타입이 같은 함수이다.
  2. BinaryOperator: 두 개의 인수를 받아 값을 반환하며, 반환값과 인수의 타입이 같은 함수이다.
  3. Predicate: 인수 하나를 받아 boolean을 반환하는 함수이다.
  4. Function: 인수와 반환값의 타입이 다른 함수이다.
  5. Supplier: 인수를 받지 않고 값을 반환하는 함수이다.
  6. Consumer: 인수를 하나 받고 값은 반환하지 않는 함수이다.
* 이 외의 변형은 다 외우기엔 수도 많고 규칙성도 없지만, 실무에서 자주 사용될 형태의 인터페이스 중 상당수를 제공하기에 유용하다.
* **표준 함수형 인터페이스 대부분은 기본 타입만 지원하며, 박싱된 기본 타입의 사용은 최대한 지양**해야 한다.
  * 박싱된 기본 타입은 계산량이 많아질수록 성능이 확연히 떨어진다.
* **표준 함수형 인터페이스 중 용도에 맞는 인터페이스가 없는 경우를 제외하고, 다음의 조건을 하나라도 만족한다면 인터페이스를 직접 작성할지 고려**해야 한다.
  1. API에서 자주 사용되며, 함수형 인터페이스의 이름 자체가 용도를 명확히 설명하는 경우.
  2. 인터페이스를 구현하는 과정에서 반드시 따라야할 규약이 있는 경우.
  3. 유용한 default 메소드를 제공할 수 있는 경우.
* 함수형 인터페이스 역시 인터페이스이므로, 직접 정의하기로 결정했다면 최대한 주의를 기울여 설계해야 한다.
* 다음과 같은 이유에서 **직접 정의한 함수형 인터페이스에는 반드시 @FunctionalInterface 어노테이션을 작성**해야 한다.
  1. 해당 클래스의 코드나 문서를 읽는 개발자로 하여금 해당 인터페이스가 람다용으로 설계된 것임을 명확히 알린다.
  2. 해당 인터페이스가 오직 하나의 추상 메소드만 가지는 것을 보장한다.
  3. 2.로 인해, 유지보수 과정에서 누군가 함수형 인터페이스에 새로운 추상 메소드를 추가하지 못하도록 강제한다.
* **서로 다른 함수형 인터페이스를 같은 위치의 인수로 받는 메소드를 다중정의 하는 것은 가능한 한 지양**해야 한다.
  * 이는 클라이언트 코드를 작성하는 개발자에게 불필요한 모호함을 안겨주며, 최악의 경우 형변환을 강제해야만 하는 경우를 발생시킬 수도 있다.

## 2022-03-09 Wed
### 스트림은 주의해서 사용하기
* Java 8에서 추가된 스트림은 대량 데이터 처리 작업을 지원하기 위한 기능이다.
* 스트림 API가 제공하는 추상 개념은 크게 다음과 같은 두 가지로 구분할 수 있다.
  1. 스트림: 데이터 원소의 유한, 또는 무한 시퀀스를 표현하는 개념.
  2. 스트림 파이프라인: 스트림의 원소들로 수행하는 연산 단계를 표현하는 개념.
* 스트림의 원소들은 어디서부터 올 수 있으며, 대표적으로는 배열, 컬렉션, 파일, 또는 다른 스트림이 있다.
* **스트림의 원소들은 객체의 참조나 int, long, double 기본 타입 값**이다.
* 스트림 파이프라인은 크게 다음으로 구성된다.
  1. 대량의 데이터 원소를 뜻하는 소스 스트림.
  2. 소스 스트림을 또 다른 스트림으로 변환하는 하나 이상의 중간 연산.
  3. 마지막 중간 연산이 반환하는 스트림에 최후의 연산을 수행하는 종단 연산.
* **스트림 파이프라인은 종단 연산이 호출되는 시점에 지연 평가**된다. 
  * 이러한 **지연 평가는 무한 스트림을 다룰 수 있도록 하는 개념이며, 종단 연산에서 사용되지 않는 데이터는 계산에 사용되지 않는다**.
  * 반대로, **종단 연산이 없는 스트림은 아무런 작업을 수행하지 않는 것과 같으므로 절대 누락하지 않아야 한다**.
* **스트림 API는 사실상 어떠한 계산도 수행할 수 있을 정도로 다재다능하지만, 항상 사용해야만 한다는 의미는 아니다**.
  * 적절히 사용된 스트림은 코드를 간결하게 하지만, 잘 못 사용할 경우 읽기 어렵고 유지보수도 힘든 코드를 만들게 된다.
* 스트림을 과도하게 사용하여 가독성이 떨어지는 것처럼 보인다면, 로직이 많은 부분을 별도의 도우미 메소드로 추출하는 방법을 고려한다.
  * **적절한 도우미 메소드의 활용은 일반적인 반복문보다 스트림 파이프라인에서 훨씬 강력**하다.
* **모든 반복문을 스트림으로 바꾸는 것보다는 스트림과 반복문이 적절히 조합되는 것이 최선인 경우가 많다**.
  * 때문에 우선 기존 코드를 스트림을 사용하는 경우로 리팩토링하되, 새 코드가 더 좋아 보일 때만 변경 사항을 반영하도록 한다.
* 스트림 파이프라인은 반복되는 연산을 람다나 메소드 참조 등의 함수 객체로 표현하며, 반복문에서는 일반적인 코드 블록을 사용한다.
  * **그러나 함수 객체로는 불가능하지만 코드 블록으로만 수행할 수 있는 종류의 연산이 다음과 같이 존재**한다.
  1. 코드 블록에서는 스코프 안의 지역변수를 읽고 수정할 수 있지만, 람다는 final이거나 사실상 final인 변수를 읽을 수만 있다.
  2. **코드 블록에서는 return, break, continue 등의 반복 조절 기능과 검사 예외를 던질 수 있으나, 람다는 아무런 작업도 수행할 수 없다**.
* 상술한 기능을 수행해야 하는 경우, 람다를 사용하는 스트림보다는 코드 블록을 활용하는 고전적인 반복문이 더 적절하다.
* 반면 다음과 같은 작업은 스트림 API가 가장 빛을 발할 수 있는 요구사항에 해당한다. 
  1. 원소 시퀀스를 일관되게 변환하는 작업.
  2. 원소 시퀀스를 필터링하여 분류해야 하는 작업.
  3. 원소 시퀀스를 하나의 연산으로 결합해야 하는 작업.
  4. 원소 시퀀스를 컬렉션에 모아야 하는 작업.
  5. 원소 시퀀스에서 특정한 조건을 만족하는 원소를 찾는 작업.
* 상술한 요구사항에 해당하는 경우에는 고전적인 반복문보다 스트림 API를 적용하는 것이 적절하다.
* **스트림과 반복문 중 어느 것을 써야할지 명확히 드러나지 않는 경우에는 팀원들의 스트림 이해도에 따라 구현**한다.
  * 예를 들어, 팀원들이 스트림을 이해할 수 있고 선호하는 경우에는 스트림을 적용하는 것이 바람직하다.

### 스트림의 결론
* 스트림을 사용하는 것이 적절한 경우가 있고, 반복문이 적절한 경우도 있음을 명심하자.
* 또한, 대부분의 작업은 둘을 조합했을 때 가장 이상적인 결과를 낳곤 한다.
* **둘 중 어느 것이 더 좋은 방식인지 확신이 서지 않는 요구사항의 경우, 둘을 활용한 각각의 방식을 작성해보고 더 보기 좋은 쪽을 선택하는 것이 바람직**하다.

### 스트림에서는 순수 함수를 사용하기
* 스트림 API가 진입장벽이 있는 이유는, 스트림 API가 함수형 프로그래밍과 깊은 관련이 있는 패러다임이기 때문이다.
* **스트림 패러다임의 핵심은 계산을 일련의 변환 과정으로 재구성하는 것이며, 각 변환 단계는 부작용(side effect)이 없는 순수 함수여야 한다**.
  * **스트림 뿐만 아니라 스트림과 관련된 객체에 전달되는 모든 함수 객체는 부작용 없는 순수 함수여야 한다**.
* 스트림 API가 제공하는 종단 연산 중 forEach는 기능이 가장 적고, 가장 스트림답지 못한 연산이다.
  * **따라서 스트림 연산 결과를 확인해야하는 경우가 아니라면 연산에 적용하는 것은 지양**해야 한다.
* **스트림을 바르게 사용하려면 toList, toSet, toMap, groupingBy, joining 등의 수집기를 잘 활용할 수 있어야 한다**.
# EffectiveCodes
## 2022-03-08 Tue

## 람다와 스트림
### 익명 클래스보다는 람다를 사용하기
* Java 8 이전에는 Java에서 함수를 표현할 때 추상 메소드를 하나만 담은 인터페이스를 사용하곤 했다.
  * 이러한 **인터페이스는 추상적인 기능을 나타내며, 구체적인 동작은 인터페이스를 구현하는 익명 클래스를 통해 정의**된다.
* 그러나 기존의 익명 클래스 방식은 코드가 길어지며 가독성이 떨어지는 단점이 있었기에 Java는 함수형 프로그래밍에 적합하지 않았다.
* 이렇듯 **메소드를 하나만 갖는 인터페이스는 Java 8 이후에서 함수형 인터페이스로 취급되며, 그 인스턴스를 람다식을 활용하여 생성**할 수 있게 되었다.
* 람다로 정의된 코드는 함수 또는 익명 클래스와 역할이 유사하지만, 코드는 훨씬 간결하게 작성된다.
* 람다식은 컴파일러가 타입을 추론하므로 타입을 명시할 필요가 없지만, 컴파일러가 추론할 수 없는 경우에는 개발자가 타입을 명시해야 한다.
  * 타입 추론 규칙은 매우 복잡하며, 애당초 이를 완벽히 이해하는 개발자는 거의 없으므로 외울 필요도 없다.
  * **기본적으로 타입을 명시해야만 가독성이 향상되는 경우를 제외하고는 타입 명시를 생략하되, 컴파일러 오류가 발생할 때에만 타입을 명시**하도록 한다.
  * **컴파일러는 타입 추론에 필요한 정보를 대부분 제네릭에서 얻으므로, 람다를 사용하는 경우 제네릭을 적극적으로 활용하고 로우 타입을 지양**해야 한다.
* **람다는 일반적인 메소드 또는 클래스와 달리 이름이 없고 문서화가 불가능**하다.
  * 따라서 람다식 자체로 동작이 명확히 설명되지 않거나, 코드의 길이가 길어지는 경우에는 람다식을 적용하지 말아야 한다.
  * **람다식은 한 줄일 때 효과가 가장 좋고, 최대 세 줄을 넘지 않는 것이 이상적**이다.
* **람다식의 사용이 어렵거나 가독성이 떨어진다면, 코드를 줄이거나 람다식을 사용하지 말아야 한다**.
* **익명 클래스의 입지는 크게 줄었으나, 람다는 추상 메소드가 하나인 함수형 인터페이스에서만 적용이 가능하므로 익명 클래스를 완전히 대체하지 못한다**.
* 다음의 경우는 람다가 익명 클래스를 대체하지 못하는 경우로, 이러한 경우에는 익명 클래스를 사용해야 한다.
  1. 추상 클래스의 인스턴스화를 위해서는 람다를 사용할 수 없다.
  2. 추상 메소드가 여러 개인 인터페이스의 인스턴스화를 위해서는 람다를 사용할 수 없다.
  3. **람다는 자신을 참조할 수 없으므로, 함수 객체가 자신을 this로 참조해야하는 경우에는 반드시 익명 클래스를 사용**한다.
     * **익명 클래스의 인스턴스가 this로 자신을 참조하는 것과 달리, 람다의 this는 함수 객체 자신이 아닌 바깥 인스턴스를 참조**한다.
* **즉, 익명 클래스는 함수형 인터페이스가 아닌 경우의 인스턴스화에만 사용**한다.
* **람다의 직렬화는 최대한 지양해야 하며, 함수 객체를 직렬화해야 하는 경우에는 private 정적 중첩 클래스를 사용**한다.

### 람다보다는 메소드 참조를 사용하기
* **람다가 익명 클래스와 비교하여 가독성과 간결함을 한 단계 향상시켰다면, 메소드 참조는 람다보다도 더 간결한 코드를 만들어준다**.
  * **메소드 참조는 함수 객체 자체를 람다보다 간결하게 표현하므로, 람다 대신 메소드의 참조를 활용하여 같은 결과를 더 보기 좋게 얻을 수 있다**.
  * 메소드 또는 람다의 매개 변수 수가 늘어날수록 메소드 참조로 제거할 수 있는 코드의 양도 많아진다.
* 때로는 람다의 매개 변수명, 구조 자체가 메소드 참조를 적용한 경우보다 개발자에게 더 좋은 가이드가 되는 경우도 있다.
  * 즉, **람다로 표현한 경우가 메소드 참조를 사용한 경우보다 가독성이 좋은 경우 억지로 메소드 참조를 적용할 필요는 없다**.
    * 예를 들어, java.util.Function의 함수형 인터페이스인 Function.identity()를 사용하는 것보다는 (x -> x)가 가독성이 높다.
  * 때문에 **메소드 참조를 사용한 경우가 짧고 명확한 경우에만 메소드 참조를 사용하고, 그렇지 않은 경우에는 람다를 사용하는 것이 바람직**하다.
* **람다로 구현했을 때 너무 길거나 복잡한 경우는 메소드 참조를 활용할 수 있는 좋은 예시**로, 다음과 같이 메소드 참조를 활용할 수 있다.
  1. 람다로 표현한 기능을 새로운 메소드에 정의한다.
     * 이 때, **새로운 메소드는 람다와 달리 기능이 잘 드러나는 이름을 명명하거나 적절한 내용을 문서로 작성해줄 수 있다**.
  2. 람다 대신 작성한 메소드의 참조를 사용한다.
* 메소드 참조의 유형은 크게 다음의 다섯 가지로 나뉜다.
  1. 정적 메소드 참조: 가장 흔한 유형이다.
  2. 한정적 인스턴스 메소드 참조: 수신 객체를 특정하는 메소드 참조이다.
  3. 비한정적 인스턴스 메소드 참조: 수신 객체를 특정하지 않는 메소드 참조이다.
  4. 클래스 생성자 메소드 참조: 클래스의 생성자를 가리키는 메소드 참조이며, 팩토리 객체로 사용된다.
  5. 배열 생성자 메소드 참조: 배열의 생성자를 가리키는 메소드 참조이다.
* **한정적 인스턴스 메소드 참조는 기본적으로 정적 메소드 참조와 유사하며, 함수 객체가 받는 인수와 참조되는 메소드가 받는 인수가 같다**.
* **비한정적 인스턴스 메소드 참조는 함수 객체를 적용하는 시점에 수신 객체를 전달하므로, 수신 객체 전달을 위한 매개 변수를 전달해야 한다**.
  * 이 경우 수신 객체 전달용 매개 변수가 매개 변수 목록의 첫 번째에 위치하며, 그 이후의 매개 변수 목록은 참조되는 메소드 선언에 정의된 목록과 같다.
  * **비한정적 인스턴스 메소드 참조는 주로 함수 객체 적용 시점에 수신 객체를 알 수 있는 스트림 파이프라인에서의 매핑과 필터에 사용**된다.
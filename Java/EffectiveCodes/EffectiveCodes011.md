# EffectiveCodes
## 2022-03-17 Thu

## 직렬화
* 객체 직렬화란, Java 객체를 바이트 스트림으로 인코딩하는 직렬화와 바이트 스트림을 다시 객체로 구성하는 역직렬화 메커니즘이다.
* 직렬화된 객체는 다른 VM에 전송하거나, 디스크에 저장해둔 후 필요한 시점에 다시 역직렬화할 수 있다.

### 직렬화의 대안을 찾기
* 직렬화는 근본적으로 위험성이 큰 기능이다.
* 직렬화의 근본적인 문제는 공격 범위가 너무 넓고, 지속적으로 넓어져 방어하기 어렵다는 사실이다.
* 아주 신중하게 작성한 바이트 스트림만을 역직렬화해야 한다.
  * 신뢰할 수 없는 바이트 스트림을 역직렬화하는 일 자체가 공격에 노출되는 행위이다.
* **직렬화 위험을 피하는 가장 좋은 방법은 아무것도 역직렬화하지 않는 것**이다.
* **새로 작성하는 시스템에서 Java 직렬화를 사용해야할 이유는 전혀 없다**.
  * 해당 기능이 필요한 경우, 객체와 바이트 시퀀스를 변환해주는 다른 메커니즘을 사용하도록 한다.
  * **이러한 메커니즘의 선두주자로는 JSON, 프로토콜 버퍼 등이 있다**.
* **레거시 코드 등의 문제로 직렬화를 완전히 배제할 수 없다면, 신뢰할 수 없는 데이터를 절대 역직렬화하지 않아야 한다**.
* 직렬화를 반드시 사용해야 하고, 역직렬화한 데이터가 안전한지 확신할 수 없다면 객체 역직렬화 필터링 기능을 사용한다.
  * 해당 기능은 Java 9에서 도입되었으며, 데이터 스트림이 역직렬화되기 전에 필터를 설치하여 특정 클래스를 수용하거나 거부할 수 있다.
  * 객체 역직렬화 필터링은 화이트리스트 방식을 사용하는 기본 거부 모드로 사용하는 것이 바람직하다.
  * 객체 역직렬화 필터링으로도 객체 직렬화를 악용하는 모든 공격을 막아낼 수는 없다.
* 레거시 코드로부터 객체 직렬화를 사용하고 있다면, 시간과 노력을 들어서라도 JSON, 프로토콜 버퍼로의 전환을 고민해야 한다.

### 직렬화의 결론
* 직렬화는 위험하니 사용을 지양해야 하며, 시스템을 처음부터 설계한다면 JSON이나 프로토콜 버퍼를 고려한다.
* 신뢰할 수 없는 데이터는 절대로 역직렬화하지 말아야 한다.
* 반드시 역직렬화를 해야 한다면 객체 역직렬화 필터링을 사용하되, 이조차도 모든 공격을 방어할 수는 없다는 점을 명심한다.

### Serializable 구현은 신중하게 결정하기
* **어떤 클래스가 객체 직렬화를 지원하도록 하려면 Serializable 인터페이스만 구현하면 되지만, 직렬화 클래스를 지원하는 것은 훨씬 복잡한 일**이다.
* Serializable 인터페이스를 구현한 클래스는 다음과 같은 문제점이 발생할 수 있다.
  1. 릴리즈한 이후에는 최초의 내부 구현 방식이 고정되어 수정이 어려워진다.
     * 직렬화 가능한 클래스를 만들어야 한다면, 장기적인 안목으로 감당할 수 있을 만큼 좋은 품질을 갖는 직렬화 형태도 함께 설계해야 한다.
  2. 버그와 보안 구멍이 생길 위험성이 높아진다.
  3. 해당 클래스의 새로운 버전을 릴리즈할 때마다 테스트 양이 늘어난다.
* Serializable 인터페이스의 구현 여부는 쉽게 결정할 내용이 아니다.
* 상속용으로 설계된 클래스와 인터페이스는 대부분 Serializable 인터페이스를 구현하지 말아야 한다.
  * 이는 반드시 지켜야할 원칙은 아니다.
    * 예를 들어 상속용 클래스에서 직렬화를 지원하지 않는 경우, 하위 클래스에서 직렬화를 지원하게 만들기 위한 부담도 늘어난다.
  * 이를 위배하는 경우, 클래스를 확장하거나 인터페이스를 구현하는 클래스 작성자에게 큰 부담을 주게 된다.
* 내부 클래스는 Serializable 인터페이스를 구현하지 말아야 한다.

### Serializable 구현의 결론
* Serializable 인터페이스의 구현은 쉽지만, 장기적으로 사용될 수 있도록 하는 것은 매우 어렵다.
* 임의의 클래스가 여러 버전이 상호작용 될 일이 없고, 서버가 신뢰할 수 없는 데이터에 노출될 가능성이 없는 등 보호된 환경에서 사용될 클래스만 구현하도록 한다.
* 그렇지 않은 경우의 Serializable 인터페이스 구현은 아주 신중하게 진행되어야 하며, 상속 가능한 클래스라면 주의사항이 더욱 많아진다.

## 2022-03-18 Fri
### 커스텀 직렬화 형태를 고려하기
* 클래스가 Serializable 인터페이스를 구현하고, 기본 직렬화 형태를 사용한다면 현재의 구현 방식을 버릴 수 없게 된다.
* 신중히 고민한 후, 기본 직렬화 형태를 사용하더라도 문제가 없는 경우에만 사용하도록 한다.
* 또한, 객체의 물리적인 표현과 논리적인 내용이 같은 경우에는 기본 직렬화 형태를 사용하더라도 무방하다.
* 객체의 물리적인 표현과 논리적인 내용의 차이가 큰 경우에 기본 직렬화를 사용하는 경우, 다음과 같은 문제점이 수반된다.
  1. 공개 API의 현재 내부 표현 방식을 수정할 수 없게 된다.
  2. 너무 많은 공간을 차지할 수 있다.
  3. 시간이 너무 많이 소요될 수 있다.
  4. 스택 오버플로우가 발생할 수 있다.
* 때문에 객체의 물리적인 표현과 논리적인 내용의 차이가 크다면 합리적인 커스텀 직렬화 형태를 설계하는 것이 바람직하다.
* 기본 직렬화 형태의 사용 여부와 관계 없이 객체의 전체 상태를 읽는 메소드에 적용하는 동기화 메커니즘은 직렬화에도 적용해야 한다.
* 어떠한 직렬화 형태를 사용하든 직렬화 가능 클래스  모두에 직렬 버전 UUID를 명시적으로 부여해야 한다.
  * 구버전으로 직렬화된 인스턴스와의 호환을 끊는 경우를 제외하고는 직렬 버전 UUID를 수정하지 않아야 한다.

### readObject 메소드는 방어적으로 작성하기
* readObject 메소드는 실질적인 public 생성자 역할을 수행한다.
* 따라서 readObject 메소드를 사용하는 경우에도 인수의 유효성을 검사하고, 필요한 경우 매개변수를 방어적으로 복사해야 한다.
  * 일반적으로 방어적 복사를 우선 수행하고, 그 다음 유효성을 검사한다.
  * 이러한 원칙을 준수하지 않을 경우, 공격자는 손쉽게 해당 클래스의 불변식을 깨트릴 수 있다.
* 객체를 역직렬화하는 경우, 클라이언트 코드가 소유하지 않아야 하는 객체 참조를 갖는 모든 필드를 반드시 방어적으로 복사해야 한다.
  * final 필드는 방어적 복사할 수 없으므로, readObject 메소드를 활용하려면 final 키워드를 제거해야 한다.
  * final 키워드를 제거하는 데서 오는 불안전함이 직렬화 공격에 노출되는 것보다는 낫다.
* transient 필드를 제외한 모든 필드의 값을 유효성 검사 없이 대입하는 public 생성자를 추가해도 무방한 경우에만 기본 readObject 메소드를 사용한다.
  * 그렇지 않은 경우, 방어적 복사를 수행하거나 직렬화 프록시 패턴을 적용한다.
* final이 아닌 직렬화 가능 클래스의 경우, 생성자와 마찬가지로 readObject 메소드도 재정의 가능한 메소드를 호출하지 않아야 한다.

### 인스턴스 수의 통제를 위해서라면 readResolve보다 열거 타입을 사용하기
* 불변식을 지키기 위해 인스턴스를 통제할 필요가 있다면 열거 타입을 사용하는 것이 바람직하다.
* 직렬화 가능한 인스턴스 통제 클래스를 열거 타입을 활용하여 구현할 경우, 선언한 상수 외의 다른 객체가 존재하지 않음을 Java 언어 차원에서 보장한다.
* readResolve 메소드의 접근성은 매우 중요하며, final 클래스라면 private으로 정하도록 한다.
* 직렬화와 인스턴스 통제가 모두 필요하다면 readResolve 메소드를 작성하되, 해당 클래스의 모든 참조 타입 필드를 transient 키워드로 정의한다.

### 직렬화된 인스턴스보다는 직렬화 프록시의 사용을 검토하기
* Serializable 인터페이스를 구현하기로 결정한 순간 생성자 이외의 방식으로 인스턴스화가 가능해진다.
* 이는 곧 버그와 보안 문제로 이어지지만, 이러한 위험성을 크게 줄이기 위해 직렬화 프록시 패턴을 사용할 수 있다.
* 직렬화 프록시 패턴의 구현 방식은 다음과 같다.
  1. 직렬화하려는 클래스의 논리적인 상태를 정밀하게 표현하는 중첩 클래스를 설계하고 private static으로 정의한다.
     * 이 때, 중첩 클래스가 외부 클래스의 직렬화 프록시 역할을 수행한다.
  2. 중첩 클래스의 생성자는 하나만 정의하며, 외부 클래스를 매개변수로 받아 인수로 넘어온 인스턴스의 데이터를 복사하도록 정의한다.
  3. 외부 클래스와 직렬화 프록시 클래스 모두 Serializable 인터페이스를 구현하도록 작성한다.
* 이러한 방식은 생성자 없이 인스턴스를 생성하는 직렬화의 위험한 특성을 상당 부분 제거한다.
* 직렬화 프록시 패턴은 클래스의 필드 중 final 키워드가 정의된 필드의 final을 제거할 필요가 없다.
* 직렬화 프록시 패턴에도 다음과 같은 한계가 존재한다.
  1. 클라이언트 코드가 확장할 수 있는 클래스에는 적용할 수 없다.
  2. 객체 그래프 상 순환이 존재하는 클래스에는 적용할 수 없다.
  3. 방어적 복사와 비교하여 다소 성능이 떨어진다.
* 제 3자에 의해 확장될 수 없는 클래스는 가능하다면 직렬화 프록시 패턴을 활용한다.
  * 이는 일반적으로 클래스의 불변식을 안정적으로 직렬화해주는 가장 쉬운 방법이다.
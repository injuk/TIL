# EffectiveCodes
## 2022-03-16 Wed

## 동시성
### 공유 중인 가변 데이터는 동기화하여 사용하기
* 동기화는 크게 다음과 같은 의의를 갖는다.
  1. 배타적 실행, 한 스레드가 변경하는 순간에 다른 스레드가 변경하지 못하도록 막는다.
  2. 스레드 간 통신, **동기화된 메소드 또는 블록에서 진행된 이전 수정 작업의 최종 결과만을 볼 수 있도록 보장**한다.
* Java 언어 명세상, long과 double 이외의 변수를 읽고 쓰는 동작은 원자적이다.
  * **그러나 하나의 스레드가 저장한 값이 다른 스레드에게 보이는지 보장하지는 않는다**.
  * 동기화를 적절히 처리하지 않는 경우, 하나의 스레드가 수정한 값을 다른 스레드가 언제 쯤 보게될지 보장할 수 없다.
* volatile 키워드는 배타적 수행과는 관계 없지만, 항상 가장 최근에 기록된 값을 읽어들일 수 있도록 스레드 간 통신을 지원한다.
* java.util.concurrent.atomic 패키지에는 락 없이도 스레드 안전한 개발을 지원하는 클래스들이 포함된다.
  * 예를 들어, **volatile은 통신만 지원하지만 해당 패키지는 배타적 실행까지 지원하며 성능도 우수**하다.
* 그러나 **가장 좋은 방법은 애초에 가변 데이터를 공유하지 않는 것**이다.
  * 대신 불변 데이터를 공유하거나, 아무것도 공유하지 않아야 한다.
  * 가변 데이터는 가능한 한 단일 스레드에서만 사용한다.

### 가변 데이터 동기화의 결론
* 여러 스레드가 가변 데이터를 공유한다면, 데이터를 읽고 쓰는 동작을 반드시 동기화한다.
* 배타적 실행은 필요 없고 스레드끼리의 통신만 필요한 경우, volatile 한정자만으로도 동기화할 수 있지만 올바로 사용하기가 어려울 수 있다.

### 과도한 동기화는 피하기
* 충분하지 못한 동기화에 문제가 있듯, 과도한 동기화 역시 문제가 생길 수 있다.
  * 과도한 동기화는 성능을 떨어트리고, 예측할 수 없는 동작으로 이어질 수도 있다.
* **응답 불가와 잘못된 계산 결과를 반환하는 안전 실패를 피하려면 동기화 메소드나 동기화 블록 안에서의 제어권을 절대 클라이언트 코드에 넘기지 말아야 한다**.
  1. 동기화된 영역 안에서는 재정의할 수 있는 메소드를 호출하지 않아야 한다.
  2. 클라이언트가 넘겨진 함수 객체를 호출하지 않아야 한다.
* **기본적으로 동기화 영역에서는 일을 가능한 한 적게 수행하는 것이 바람직**하다.
* 가변 클래스를 작성하는 경우, 다음과 같은 두 원칙 중 하나를 따르도록 해야 한다.
  1. 동기화를 전혀 하지 않고, 해당 클래스를 동시에 사용해야 하는 클래스가 외부에서 동기화하도록 한다.
     * 이는 java.util 패키지가 채택한 방식이다.
  2. 동기화를 내부에서 수행하여 스레드 안전한 클래스로 만들되, 1.의 방법보다 동시성이 월등히 개선되는 경우에만 적용한다.
     * 이는 java.util.concurrent 패키지가 채택한 방식이다.
* **두 원칙 중 적절한 것을 선택하기 어렵다면, 동기화하지 말고 문서에 스레드 안전하지 않은 클래스임을 명시해도 무방**하다.
* Java의 라이브러리에는 이러한 지침을 따르지 않은 클래스가 많다.
  * StringBuffer는 대부분의 경우 단일 스레드에서 사용되지만, 내부적으로 동기화를 수행한다.
    * 때문에 동기화하지 않는 StringBuffer인 StringBuilder가 추후에 추가되었다.
  * **java.util.Random은 스레드 안전하므로, 추후 동기화하지 않는 버전인 java.util.concurrent.ThreadLocalRandom으로 대체**되었다.

### 과도한 동기화의 결론
* 멀티 코어가 만연한 현재는 과도한 동기화를 피하는 것이 무엇보다 중요하다.
* 동기화 영역 내부에서의 작업은 최소화하고, 절대 외부로부터 전달된 메소드를 호출하지 말아야 한다.
* 필요한 이유가 있을 때에만 클래스 내부에서 동기화하고, 동기화 여부는 반드시 문서에 명시한다.

### 스레드보다는 실행자, 태스크, 스트림을 사용하기
* **java.util.concurrent 패키지에는 인터페이스 기반의 유연한 태스크 실행 기능을 포함하는 실행자 프레임워크가 존재**한다.
* **필요한 실행자 대부분은 java.util.concurrent.Executors의 정적 팩토리로 생성**할 수 있다.
* **작업 큐를 직접 만들거나, 스레드를 직접 다루는 것은 일반적으로 지양**해야 한다.
  * 스레드를 직접 다루면 Thread가 작업 단위와 수행 메커니즘 두 역할을 모두 수행하게 된다.
* 실행자 프레임워크에서는 작업 단위와 실행 메커니즘은 분리된다.
  * 이 때, **작업 단위를 나타내는 핵심적인 추상 개념을 태스크라고 한다**. 
* **태스크는 다시 Runnable과 Callable로 나뉘며, 태스크를 수행하는 일반적인 메커니즘이 실행자 서비스**이다.
  * 즉, **마치 데이터의 모음을 컬렉션 프레임워크가 담당하듯 실행자 프레임워크가 전반적인 작업 수행을 담당**해줄 수 있다.
# CodingTest
## 2022-02-21 Mon

## 관례적이고 효과적인 용법
* 외국어를 실전에서 사용하려면, 최소한 다음의 세 가지 조건이 충족되어야 한다.
  1. 문법: 언어의 구조에 통달하기
  2. 어휘: 언어에서 표현할 대상의 이름을 알기
  3. 용법: 일상의 이야기를 풀어내는 관례적이고 효과적인 방법
* 프로그래밍 언어도 이와 같아서, 개발자는 언어의 핵심과 어휘, 용법 모두에 숙달되어야 한다.
* 입으로 내 뱉은 말과 달리, 애플리케이션은 계속해서 수정해나갈 수 있다.
  * 즉, 코드는 단순히 동작하고 다른 사람이 읽기 쉬운 데에서 그치면 안 된다.
  * **이상적인 코드는 구조를 수정하기 쉬워야 한다**.
```
> 작은 것은 아름답지만, 단순한 것이 쉬움을 의미하지는 않는다.
```

## 2022-02-22 Tue
## 객체의 생성과 파괴
* 객체는 만들어야할 때, 올바르게 만들어져야 한다.
* 객체는 적시에 파괴되고, 때로는 파괴되기 전에 정리 작업을 수행해야 한다.

### 1. 생성자보다 정적 팩토리 메소드를 활용하기
* 일반적으로 클라이언트 코드가 클래스의 인스턴스를 얻는 방법은 public 생성자이다.
* **개발자는 기존의 public 생성자와 더불어(또는 제외하고) 정적 팩토리 메소드를 클라이언트에게 제공할 수 있다**.
* 정적 팩토리 메소드를 제공하는 경우의 장점은 다음과 같다.
1. 메소드가 이름을 가질 수 있다.
   * **전통적인 생성자와, 파라미터 목록을 전달하는 방식은 매개 변수의 의미를 적절히 설명할 수 없다**.
     * 전통적인 생성자에 매개 변수 목록의 순서를 섞어 새로운 생성자를 정의하는 방식은 이해하거나 기억하기 어렵다.
   * 반면 **정적 팩토리 메소드는 적절한 명명을 통해 매개 변수와 결과의 연관성을 잘 설명할 수 있다**.
   * 만약 **하나의 클래스에서 메소드 시그니쳐가 동일한 여러 생성자가 필요한 경우, 정적 팩토리 메소드와 명시적인 명명을 활용**하자.
2. 필요한 경우, 호출 시점마다 새로운 인스턴스를 생성하지 않을 수 있다.
   * **반복되는 인스턴스와 요청에 같은 인스턴스를 반환하는 방식으로 정적 팩토라 메소드는 인스턴스의 생명 주기를 통제할 수 있다**.
3. 필요한 경우, **정적 팩토리 메소드 반환형의 하위 타입 인스턴스를 반환할 수 있다**.
   * 이러한 방식은 반환할 객체의 클래스를 자유롭게 선택할 수 있도록 유연성을 제공한다.
   * 이를 통해 실제 구현 클래스를 공개하지 않고도 그 실체인 객체를 반환할 수 있으므로, API를 작게 유지할 수 있다.
     * 작아진 API는 개발자의 러닝 커브를 낮추는 직접적인 효과가 있다.
4. 입력된 파라미터에 따라 매 번 다른 클래스의 인스턴스를 반환할 수 있다.
   * 이는 3.의 연장으로, 해당 메소드 반환형의 하위 객체라면 무엇을 반환하든 상관없다는 의미를 갖는다.
   * 예를 들어, EnumSet 클래스는 정적 팩토리 메소드를 호출하여 조건부로 RegularEnumSet 또는 JumboEnumSet을 반환한다.
     * 이 때, 반환 조건은 단순히 전달된 원소의 개수이다.
     * **반환되는 실제 객체가 EnumSet의 구현체이므로 이러한 방식이 가능하며, 클라이언트는 각 구현체에 대해 정확히 알 필요가 없다**.
   * **클라이언트는 정적 팩토리 메소드가 반환하는 인스턴스가 실제로 어떤 구체 클래스인지 알 수 없고, 알 필요도 없다**.
5. **정적 팩토리 메소드를 작성하는 시점에 실제로 반환되는 객체의 클래스가 존재하지 않아도 개발을 진행할 수 있다**.
   * 이로 인해 정적 팩토리 메소드 방식은 매우 유연하다.
* 반면, 정적 팩토리 메소드를 제공하는 경우의 단점은 다음과 같다.
1. 상속을 위해서는 반드시 public 또는 protected 생성자가 필요하지만, 정적 팩토리 메소드를 활용하는 경우 상속을 활용할 수 없을 수도 있다.
   * 그러나 이러한 단점은 상속 대신 컴포지션을 사용하도록 유도하는 장점으로 비추어질 수도 있다.
2. 정적 팩토리 메소드는 개발자가 찾기 어렵다.
   * 정적 팩토리 메소드를 제공하는 클래스의 클라이언트는 인스턴스화 방식을 알아내야만 한다.
   * 이러한 단점을 해소하기 위해, 정적 팩토리 메소드에 일반적으로 사용하는 명명 관습이 존재한다.
* 상술한 정적 팩토리 메소드의 명명 관습은 다음과 같다.
  1. from: 파라미터를 하나만 받고. 해당 타입의 인스턴스를 반환한다.
  2. of: 여러 파라미터를 받고, 적절한 타입의 인스턴스를 반환한다.
  3. create: 매 번 새로운 인스턴스를 생성하여 반환한다.
* public 생성자를 '절대로' 사용하지 말아야 한다는 결론을 내리지 않아야 한다.
  * **두 방식을 적소에 사용하되, 습관적으로 public 생성자를 작성하는 습관은 지양**하도록 한다.
  * **대부분의 경우 정적 팩토리 메소드 방식이 더 많은 장점을 갖는다**.

### 2. 생성자에 매개 변수가 많다면 빌더 패턴을 고려하기
* 정적 팩토리와 생성자는 선택적인 매개 변수가 많은 경우에 대응하기가 어렵다는 단점을 공유한다.
* 개발자들은 이러한 상황에 대응하기 위해 다음과 같은 패턴을 고려하였다.
  1. 매개 변수 목록의 여러 조합으로 생성자를 모두 생성하는 점층적 생성자 패턴
    * 그러나, 당연히 이는 선택적인 매개 변수가 많아질수록 생성자의 개수가 기하급수적으로 늘어날 것이다.
  2. 원하는 매개 변수에 대해 세터를 호츌하는 자바 빈즈 패턴
     * 해당 패턴은 점층적 생성자 패턴의 단점을 상당수 해결한다.
     * 그러나 클래스를 불변으로 만들 수 없으며, 인스턴스 하나를 완성하기 위해 여러 메소드를 호출해야만 한다.
     * 인스턴스를 설정하는 과정에서 인스턴스의 일관성도 유지되지 않는다.
* **빌더 패턴은 점층적 생성자 패턴의 안정성과 자바 빈즈 패턴의 가독성을 겸비한 대안**이다.
  * 때문에 빌더 패턴으로 작성된 코드는 읽기 쉽고, 작성하기도 쉽다.
* 빌더 패턴은 계층적으로 설계된 클래스와 함께 사용할 수 있다.
* 빌더 패턴의 단점은 다음과 같다.
  1. 빌더 패턴은 인스턴스화 이전에 반드시 빌더를 작성해야 하므로, 성능에 민감한 상황에서는 문제가 될 수 있다.
     * 빌더 생성 비용이 엄청나게 큰 것은 아니다.
  2. 빌더 패턴은 점층적 생성자 패턴보다는 코드가 장황하며, 매개 변수가 4개 이상은 되어야 의미가 있다.
     * 그러나 API는 시간이 지날수록 매개 변수가 많아지는 경향이 있다.
     * 때문에 **생성자 또는 정적 팩토리를 사용하다 빌더 패턴으로 전환하는 것보다 애초에 빌더로 시작하는 것이 좋을 때가 많다**.
* **빌더 패턴은 생성자나 정적 팩토리에서 많은 매개 변수를 처리해야 하고, 일부가 필수적이지 않은 경우에 사용을 고려할 수 있다**.

## 2022-02-23 Wed
### 3. private 생성자 또는 enum을 활용하여 싱글톤을 보장하기
* 싱글톤 클래스는 단 하나만 생성할 수 있는 클래스이다.
* 일반적으로 싱글톤을 정의하는 방식은 다음과 같은 두 가지이다.
  1. public 필드: 생성자를 private으로 숨기고, 인스턴스에 접근할 수 있는 수단을 public static으로 공개하기.
     * 해당 클래스가 싱글톤을 제공한다는 사실이 명백히 드러나며, 간결하다.
  2. 정적 팩토리 메소드: 생성자를 private으로 숨기고, 정적 팩토리 메소드를 public static 멤버로 제공하기.
     * API의 수정 없이 싱글톤에서 일반 클래스로 돌릴 수 있다.
     * 정적 팩토리를 제네릭 싱글톤 팩토리로 만들 수 있다.
     * 정적 팩토리의 메소드 참조를 supplier로 사용할 수 있다.
     * **이러한 장점이 필요하지 않다면, 1.번 방식을 사용하는 것이 바람직**하다.
  * 위 두 방식은 직렬화 후 역직렬화 시 새로운 인스턴스가 만들어지는 문제가 있다.
  3. 원소가 하나 뿐인 enum을 정의한다.
     * 1에서 소개한 public 필드 방식과 유사하지만, 더 간결하고 직렬화를 위한 추가 노력이 필요하지 않다.
* **대부분의 경우 원소가 하나 뿐인 enum 방식이 싱글톤을 만드는 가장 좋은 방식**이다.
  * 반면, 싱글톤이 enum 이외의 클래스를 상속하는 경우에는 사용할 수 없다.
  * **대신 enum이 다른 인터페이스를 구현하도록 선언할 수 있다**.

### 4. 인스턴스화를 방지하기 위해 private 생성자를 활용하기
* 정적 메소드와 정적 필드만을 담는 클래스는 일반적으로 유틸리티 클래스 등에 사용된다.
  * 이러한 클래스는 애당초 인스턴스화를 고려하고 설계하지 않는다.
* 그러나 생성자를 명시하지 않은 클래스는 컴파일러가 자동으로 public 생성자를 만들어준다.
  * 클라이언트 코드를 작성하는 사용자 입장에서, 이러한 public 생성자가 의도된 것인지 확인할 방법은 없다.
* **클래스 내부에 private 생성자를 명시적으로 작성하면 컴파일러에 의한 public 생성자 자동 생성을 방지**할 수 있다.
* 이러한 방식은 **상속시 부모 클래스의 생성자를 묵시적으로 호출하는 상황을 방지하므로, 상속에 의한 인스턴스화도 막을 수 있다**.

### 5. 자원 객체를 직접 명시하기 보다는 의존 객체 주입을 활용하기
* 대부분의 클래스는 하나 이상의 자원에 의존한다.
* 이를 private static과 같은 유틸리티 형태나, 싱글톤으로 적용하는 방식은 유연하지 못하며, 많은 쓰임새에 대응할 수 없도록 한다.
* **클래스가 사용하는 자원에 따라 동작이 달라질 수 있다면 정적 유틸리티 클래스 방식이나 싱글톤이 적절하지 않다**.
  * **대신 클라이언트가 원하는 자원을 명시하고, 클래스는 가능한 많은 자원 인스턴스를 지원하도록 구현하는 것이 바람직**하다.
* **인스턴스 생성시 생성자에 자원을 넘겨주는 의존성 주입 방식은 이러한 요구 사항에 걸맞는 방식**이다.
* 의존 객체 주입 방식은 흔히 사용되는 패턴이며, 불변성을 보장할 수 있으므로 여러 클라이언트가 의존 객체를 안심하고 공유할 수 있다.
* **의존 객체 주입 방식은 테스트 용이성을 개선하지만, 의존성이 많아질수록 코드가 난잡해지는 단점**이 있다.
  * 이러한 문제는 Spring과 같은 의존성 객체 주입 프레임워크를 사용하는 것으로 해소할 수 있다.
* 만약 클래스가 내부적으로 하나 이상의 다른 자원 객체에 의존하고, 그 자원이 클래스에 직접적으로 영향을 주느 경우에는 싱글톤과 정적 유틸리티 클래스 방식을 적용하지 않아야 한다.
  * 이러한 자원을 클래스 내부에서 생성할 수도 없어야 하며, 대신 외부에서 필요한 자원을 생성자에 명시적으로 전달하도록 구현되어야 한다.
  * 이러한 의존 객체 주입은 클래스의 유연성과 재사용성, 테스트 용이성을 향상시킨다.

# EffectiveCodes
## 2022-03-06 Sun

## 열거 타입과 어노테이션
### int 상수 대신 열거 타입(enum)을 사용하기
* 열거 타입은 일정 개수의 상수 값을 정의하고, 그 이외의 값은 허용하지 않는 참조 타입이다.
* 열거 타입이 지원되기 전에는 정적 정수 상수를 하나의 클래스에 묶어 표현하곤 했다.
  * 이러한 방식은 타입 안전하지 않고, 표현력도 좋지 않으며 네임 스페이스를 구분할 수 없는 등 단점이 많다.
* **열거 타입은 기존의 정수, 문자열 열거 패턴의 단점을 극복하고, 나아가 여러 장점을 갖는 Java 언어의 대안**이다.
* **Java의 열거 타입은 내부적으로는 완전한 형태의 클래스이므로 다른 언어의 열거 타입보다 강력**하다.
* 열거 타입은 다음과 같은 특징을 갖고, 기존 열거 패턴의 여러 단점을 해소하는 여러 장점들을 제공한다.
  1. 열거 타입은 기본적으로 클래스이다.
  2. 열거 타입은 상수 하나당 자신의 인스턴스를 하나씩 만들어 public static final 필드로 공개한다.
  3. 열거 타입은 밖에서 접근할 수 있는 생성자가 없으므로, 사실상 final 클래스이다.
     * 이 덕분에 클라이언트에서 인스턴스를 직접 생성할 수 없어 상수 당 하나의 인스턴스만이 보장된다.
     * 즉, **열거 타입은 싱글톤 패턴을 일반화한 형태**이다.
  4. 열거 타입은 컴파일 시점의 타입 안전성을 보장한다.
     * **특정한 열거 타입을 매개변수로 받는 메소드에 전달되는 값은 null이 아닌 경우 반드시 해당 열거 타입에 포함되는 값**이다.
  5. 각 열거 타입은 자신의 네임 스페이스가 존재하므로, 같은 이름의 상수도 공존할 수 있다.
  6. **열거 타입은 새로운 상수를 추가하거나 이름을 바꾸더라도 클라이언트 코드를 다시 컴파일할 필요가 없다**.
     * 정수 타입은 static final 변수의 이름이 아닌 값 자체가 클라이언트 코드에 하드코딩되므로, 변경시 재컴파일이 필요하다.
     * 반면 열거 타입에서 클라이언트에 공개되는 것은 필드의 이름뿐이므로 다시 컴파일할 필요가 없다.
  7. 열거 타입의 toString 메소드는 적절한 형태의 문자열을 반환한다.
  8. **열거 타입에는 임의의 메소드나 필드를 추가할 수 있고, 인터페이스를 구현할 수도 있다**.
* **열거 타입은 단순하게는 상수의 모음이지만, 실제로는 클래스이므로 메소드와 필드를 추가하여 고차원의 추상적인 개념 하나를 스스로 표현**할 수 있다.
* **열거 타입에서 상수를 하나 제거하더라도 해당 상수를 참조하지 않는 클라이언트 코드에는 아무런 영향을 주지 않는다**.
  * 제거된 상수를 참조하던 클라이언트는 디버깅을 돕는 적절한 컴파일 오류가 발생한다.
* 열거타입을 선언한 클래스, 또는 패키지에서만 유용한 기능은 private이나 package private으로 구현한다.
* **여러 클래스에서 사용되는 열거 타입은 최상위 수준 클래스로 작성**한다.
  * 반면 **특정한 최상위 수준 클래스에서만 사용되는 열거 타입은 해당 클래스의 멤버로 정의**한다.
* **열거 타입의 생성자에서는 오직 상수 변수에만 접근할 수 있으며, 다른 열거 타입의 정적 필드에 접근할 수 없다**.
  * 이는 각 열거 타입이 public static final 필드이기 때문으로, 아직 초기화되지 않은 정적 필드를 생성자에서 접근할 수는 없다.
* **열거 타입의 상수 일부가 같은 동작을 공유한다면 전략 열거 타입 패턴을 활용**할 수 있다.
  * **전략 열거 타입 패턴이란, 동일한 동작을 하나의 전략으로 분류하여 열거 타입 내부에 포함된 열거 타입에서 분류된 동작을 정의하는 패턴**이다.
  * 이는 대부분의 경우에서 switch 문보다 유지보수성과 유연성이 좋다.
* 열거 타입은 메모리에 적재하기 위한 공간과 시간을 제외하고는 정수 상수와 성능 차이가 없으며, 잘 체감도 되지 않는다.
* 열거 타입은 다음 상황에서 사용을 고려할 수 있다.
  1. 필요한 값 목록을 컴파일 시점에 모두 알 수 있는 상수 집합.
  2. 요일과 같이 본질적으로 열거 타입인 경우.
  3. 명령어 옵션 등 사용 가능한 값을 컴파일 시점에 모두 알 수 있는 상수 집합.
* **열거 타입은 상수의 개수가 변경되더라도 바이너리 수준에서 호환되도록 설계되었으므로, 고정 불변할 필요가 없다**.

### 클래스로서의 열거 타입 활용
* 열거 타입 상수 각각을 특정한 필드와 연결하는 처리는 생성자에서 수행한다.
* 열거 타입은 근본적으로 불변이므로 모든 필드가 final이어야 한다.
* 열거 타입의 필드는 public일 수 있지만, private으로 두고 접근자 메소드를 제공하는 것이 더 바람직하다.
* 열거 타입은 자신이 관리하는 상수의 값을 배열에 담아 반환하는 정적 메소드인 values를 제공하므로, 이를 통해 값을 쉽게 순회할 수 있다.
* 열거 타입의 상수 별로 다른 동작을 수행하고 싶은 경우, 열거 타입 클래스에 추상 메소드를 작성하는 방식을 활용한다.
  * 이후 각 상수의 클래스 몸체에서 상수에 맞는 방식으로 추상 메소드를 재정의한다.

### 열거 타입의 결론
* 열거 타입은 확실히 정수 열거 패턴보다 뛰어나다.
* 대다수의 열거 타입은 생성자와 메소드가 필요 없지만, 각 상수 값을 특정한 필드와 연관짓거나 상수마다 다른 동작을 구현해야 하는 경우에는 정의할 수 있다.
  * 열거 타입의 상수 별 다른 동작을 구현하려면 switch 문은 적절하지 않으며, 대신 상수별 메소드 구현을 사용한다.
  * 이 때, 열거 타입 상수 중 일부에 동일한 동작을 적용해야 한다면 전략 열거 타입 패턴을 사용할 수 있다.

### ordinal 메소드 대신 인스턴스 필드를 사용하기
* 대부분의 열거 타입 상수는 하나의 정수에 대응되도록 작성된다.
* 또한, 모든 열거 타입은 해당 상수가 열거 타입의 몇 번째 위치인지 반환하는 ordinal 메소드를 제공한다.
* 상술한 이유에서 열거 타입 상수에 정수를 연관짓는 경우, ordinal을 통해 값을 반환받고자 할 수 있다.
* 이러한 **ordinal 메소드의 사용은 다음과 같은 이유에서 유지보수가 어려우므로, 절대 사용하지 말아야 한다**.
  1. 상수의 선언 순서가 변경되는 순간 열거 타입의 메소드는 원하는 동작을 수행하지 않는다.
  2. 이미 사용 중인 정수 값과 동일한 값을 추가할만한 방법이 없다.
  3. 값을 중간에 비워둘 수 없으며, 반드시 더미 데이터를 추가해야하는 경우가 생긴다.
  4. **ordinal 메소드는 애초에 EnumSet, EnumMap과 같은 범용 자료구조에서 사용할 목적으로 설계된 메소드**이다.
* **열거 타입에 대응되는 값을 얻어야할 필요가 있다면, ordinal 메소드보다 인스턴스 필드를 정의하는 방식을 사용하는 것이 바람직**하다.

### 비트 필드 대신 EnumSet을 사용하기
* 열거할 값들이 주로 집합으로 사용될 경우, 2의 거듭제곱 값을 활용한 정수 열거 패턴을 사용하곤 했다.
* 이러한 방식은 비트 연산을 통해 합집합과 교집합 등의 연산을 효율적으로 수행할 수 있었으나, 정수 열거 패턴의 단점을 그대로 답습하곤 한다.
  * 나아가 정수 열거 상수를 출력할 때보다 필드 값을 더 해석하기 어렵고, 최대 비트 수를 API 설계 단계에 미리 선택할 필요가 있었다.
* 이러한 기존 방식은 java.util.EnumSet으로 완벽히 대체가 가능하다.
  * 때문에 이제는 열거할 수 있는 타입을 집합 형태로 사용해야 하는 경우에도 비트 필드를 사용할 필요가 없다.

### ordinal 인덱싱 대신 EnumMap을 사용하기
* 배열 또는 리스트에서 요소를 가져올 때 ordinal 메소드로 인덱스를 얻어올 수도 있다.
* 이러한 방식은 동작은 가능하지만, 다음과 같은 문제점이 존재한다.
  1. 배열은 제네릭과 호환되지 않으므로 비검사 형변환을 수행해야 한다.
  2. 배열은 인덱스의 의미를 알 수 없으므로, 각 값에 대한 레이블을 직접 명시해야 한다.
  3. **정수는 열거 타입과 달리 타입 안전하지 않으므로, 정확한 정수값의 사용을 개발자가 직접 보증해야 한다**.
* 이러한 방식은 주로 열거 타입 상수를 값으로 매핑하기 위해 사용하므로, 적절한 Map 구현체의 활용을 고려해볼 수 있다.
  * **EnumMap은 이러한 요구사항에 정확히 부합하며, 열거 타입을 키로 사용하는 Map 구현체**이다.
* EnumMap은 열거 타입 자체가 출력용 문자열을 제공하므로 레이블을 명시할 필요 없고, 안전하며 성능도 좋다.
  * Map 구현체로서의 EnumMap은 타입 안전성을 보장하며, 내부적으로 배열을 사용하여 성능적인 이점까지 취한다.
* 이렇듯 배열의 인덱스를 얻기 위해 ordinal을 사용하는 것은 일반적으로 좋지 않으므로, 대신 EnumMap의 사용을 고려해야 한다.

## 2022-03-07 Mon
### 확장할 수 있는 열거 타입이 필요할 때에는 인터페이스를 활용하기
* 대부분의 상황에서 열거 타입을 확장하는 것은 좋은 방향이 아니지만, 확장 가능한 열거 타입이 필요한 경우가 없는 것은 아니다.
  * 예를 들어, 동작을 결정하는 연산 코드의 예시가 있다.
* 이러한 요구사항에는 열거 타입이 임의의 인터페이스를 구현할 수 있는 특징을 활용한다.
  * 즉, 인터페이스로 연산을 정의하고 열거 타입이 이를 구현하도록 한다.
* 열거 타입은 확장할 수 없지만, 인터페이스와 인터페이스를 구현하는 열거 타입을 활용하여 유사한 효과를 낼 수 있다.
  * 이를 통해 클라이언트는 인터페이스를 구현하여 자신만의 열거 타입을 만들어 사용할 수 있다.
* 이를 **사용하는 클라이언트 코드는 열거 타입을 직접 명시하는 것이 아닌 인터페이스 기반으로 작성되어 있어야 한다**. 
  * 이를 통해 열거 타입의 인스턴스가 사용되는 모든 곳을 확장한 열거 타입의 인스턴스로 대체할 수 있다.
* 이러한 방식은 확장 가능한 열거 타입인 양 위장할 수 있지만, 열거 타입끼리 구현을 상속할 수 없다는 단점도 존재한다.
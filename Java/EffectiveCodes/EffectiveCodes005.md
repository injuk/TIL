# EffectiveCodes
## 2022-03-06 Sun

## 열거 타입과 어노테이션
### int 상수 대신 열거 타입(enum)을 사용하기
* 열거 타입은 일정 개수의 상수 값을 정의하고, 그 이외의 값은 허용하지 않는 참조 타입이다.
* 열거 타입이 지원되기 전에는 정적 정수 상수를 하나의 클래스에 묶어 표현하곤 했다.
  * 이러한 방식은 타입 안전하지 않고, 표현력도 좋지 않으며 네임 스페이스를 구분할 수 없는 등 단점이 많다.
* **열거 타입은 기존의 정수, 문자열 열거 패턴의 단점을 극복하고, 나아가 여러 장점을 갖는 Java 언어의 대안**이다.
* **Java의 열거 타입은 내부적으로는 완전한 형태의 클래스이므로 다른 언어의 열거 타입보다 강력**하다.
* 열거 타입은 다음과 같은 특징을 갖고, 기존 열거 패턴의 여러 단점을 해소하는 여러 장점들을 제공한다.
  1. 열거 타입은 기본적으로 클래스이다.
  2. 열거 타입은 상수 하나당 자신의 인스턴스를 하나씩 만들어 public static final 필드로 공개한다.
  3. 열거 타입은 밖에서 접근할 수 있는 생성자가 없으므로, 사실상 final 클래스이다.
     * 이 덕분에 클라이언트에서 인스턴스를 직접 생성할 수 없어 상수 당 하나의 인스턴스만이 보장된다.
     * 즉, **열거 타입은 싱글톤 패턴을 일반화한 형태**이다.
  4. 열거 타입은 컴파일 시점의 타입 안전성을 보장한다.
     * **특정한 열거 타입을 매개변수로 받는 메소드에 전달되는 값은 null이 아닌 경우 반드시 해당 열거 타입에 포함되는 값**이다.
  5. 각 열거 타입은 자신의 네임 스페이스가 존재하므로, 같은 이름의 상수도 공존할 수 있다.
  6. **열거 타입은 새로운 상수를 추가하거나 이름을 바꾸더라도 클라이언트 코드를 다시 컴파일할 필요가 없다**.
     * 정수 타입은 static final 변수의 이름이 아닌 값 자체가 클라이언트 코드에 하드코딩되므로, 변경시 재컴파일이 필요하다.
     * 반면 열거 타입에서 클라이언트에 공개되는 것은 필드의 이름뿐이므로 다시 컴파일할 필요가 없다.
  7. 열거 타입의 toString 메소드는 적절한 형태의 문자열을 반환한다.
  8. **열거 타입에는 임의의 메소드나 필드를 추가할 수 있고, 인터페이스를 구현할 수도 있다**.
* **열거 타입은 단순하게는 상수의 모음이지만, 실제로는 클래스이므로 메소드와 필드를 추가하여 고차원의 추상적인 개념 하나를 스스로 표현**할 수 있다.
* **열거 타입에서 상수를 하나 제거하더라도 해당 상수를 참조하지 않는 클라이언트 코드에는 아무런 영향을 주지 않는다**.
  * 제거된 상수를 참조하던 클라이언트는 디버깅을 돕는 적절한 컴파일 오류가 발생한다.
* 열거타입을 선언한 클래스, 또는 패키지에서만 유용한 기능은 private이나 package private으로 구현한다.
* **여러 클래스에서 사용되는 열거 타입은 최상위 수준 클래스로 작성**한다.
  * 반면 **특정한 최상위 수준 클래스에서만 사용되는 열거 타입은 해당 클래스의 멤버로 정의**한다.
* **열거 타입의 생성자에서는 오직 상수 변수에만 접근할 수 있으며, 다른 열거 타입의 정적 필드에 접근할 수 없다**.
  * 이는 각 열거 타입이 public static final 필드이기 때문으로, 아직 초기화되지 않은 정적 필드를 생성자에서 접근할 수는 없다.
* **열거 타입의 상수 일부가 같은 동작을 공유한다면 전략 열거 타입 패턴을 활용**할 수 있다.
  * **전략 열거 타입 패턴이란, 동일한 동작을 하나의 전략으로 분류하여 열거 타입 내부에 포함된 열거 타입에서 분류된 동작을 정의하는 패턴**이다.
  * 이는 대부분의 경우에서 switch 문보다 유지보수성과 유연성이 좋다.
* 열거 타입은 메모리에 적재하기 위한 공간과 시간을 제외하고는 정수 상수와 성능 차이가 없으며, 잘 체감도 되지 않는다.
* 열거 타입은 다음 상황에서 사용을 고려할 수 있다.
  1. 필요한 값 목록을 컴파일 시점에 모두 알 수 있는 상수 집합.
  2. 요일과 같이 본질적으로 열거 타입인 경우.
  3. 명령어 옵션 등 사용 가능한 값을 컴파일 시점에 모두 알 수 있는 상수 집합.
* **열거 타입은 상수의 개수가 변경되더라도 바이너리 수준에서 호환되도록 설계되었으므로, 고정 불변할 필요가 없다**.

### 클래스로서의 열거 타입 활용
* 열거 타입 상수 각각을 특정한 필드와 연결하는 처리는 생성자에서 수행한다.
* 열거 타입은 근본적으로 불변이므로 모든 필드가 final이어야 한다.
* 열거 타입의 필드는 public일 수 있지만, private으로 두고 접근자 메소드를 제공하는 것이 더 바람직하다.
* 열거 타입은 자신이 관리하는 상수의 값을 배열에 담아 반환하는 정적 메소드인 values를 제공하므로, 이를 통해 값을 쉽게 순회할 수 있다.
* 열거 타입의 상수 별로 다른 동작을 수행하고 싶은 경우, 열거 타입 클래스에 추상 메소드를 작성하는 방식을 활용한다.
  * 이후 각 상수의 클래스 몸체에서 상수에 맞는 방식으로 추상 메소드를 재정의한다.

### 열거 타입의 결론
* 열거 타입은 확실히 정수 열거 패턴보다 뛰어나다.
* 대다수의 열거 타입은 생성자와 메소드가 필요 없지만, 각 상수 값을 특정한 필드와 연관짓거나 상수마다 다른 동작을 구현해야 하는 경우에는 정의할 수 있다.
  * 열거 타입의 상수 별 다른 동작을 구현하려면 switch 문은 적절하지 않으며, 대신 상수별 메소드 구현을 사용한다.
  * 이 때, 열거 타입 상수 중 일부에 동일한 동작을 적용해야 한다면 전략 열거 타입 패턴을 사용할 수 있다.

### ordinal 메소드 대신 인스턴스 필드를 사용하기
* 대부분의 열거 타입 상수는 하나의 정수에 대응되도록 작성된다.
* 또한, 모든 열거 타입은 해당 상수가 열거 타입의 몇 번째 위치인지 반환하는 ordinal 메소드를 제공한다.
* 상술한 이유에서 열거 타입 상수에 정수를 연관짓는 경우, ordinal을 통해 값을 반환받고자 할 수 있다.
* 이러한 **ordinal 메소드의 사용은 다음과 같은 이유에서 유지보수가 어려우므로, 절대 사용하지 말아야 한다**.
  1. 상수의 선언 순서가 변경되는 순간 열거 타입의 메소드는 원하는 동작을 수행하지 않는다.
  2. 이미 사용 중인 정수 값과 동일한 값을 추가할만한 방법이 없다.
  3. 값을 중간에 비워둘 수 없으며, 반드시 더미 데이터를 추가해야하는 경우가 생긴다.
  4. **ordinal 메소드는 애초에 EnumSet, EnumMap과 같은 범용 자료구조에서 사용할 목적으로 설계된 메소드**이다.
* **열거 타입에 대응되는 값을 얻어야할 필요가 있다면, ordinal 메소드보다 인스턴스 필드를 정의하는 방식을 사용하는 것이 바람직**하다.

### 비트 필드 대신 EnumSet을 사용하기
* 열거할 값들이 주로 집합으로 사용될 경우, 2의 거듭제곱 값을 활용한 정수 열거 패턴을 사용하곤 했다.
* 이러한 방식은 비트 연산을 통해 합집합과 교집합 등의 연산을 효율적으로 수행할 수 있었으나, 정수 열거 패턴의 단점을 그대로 답습하곤 한다.
  * 나아가 정수 열거 상수를 출력할 때보다 필드 값을 더 해석하기 어렵고, 최대 비트 수를 API 설계 단계에 미리 선택할 필요가 있었다.
* 이러한 기존 방식은 java.util.EnumSet으로 완벽히 대체가 가능하다.
  * 때문에 이제는 열거할 수 있는 타입을 집합 형태로 사용해야 하는 경우에도 비트 필드를 사용할 필요가 없다.

### ordinal 인덱싱 대신 EnumMap을 사용하기
* 배열 또는 리스트에서 요소를 가져올 때 ordinal 메소드로 인덱스를 얻어올 수도 있다.
* 이러한 방식은 동작은 가능하지만, 다음과 같은 문제점이 존재한다.
  1. 배열은 제네릭과 호환되지 않으므로 비검사 형변환을 수행해야 한다.
  2. 배열은 인덱스의 의미를 알 수 없으므로, 각 값에 대한 레이블을 직접 명시해야 한다.
  3. **정수는 열거 타입과 달리 타입 안전하지 않으므로, 정확한 정수값의 사용을 개발자가 직접 보증해야 한다**.
* 이러한 방식은 주로 열거 타입 상수를 값으로 매핑하기 위해 사용하므로, 적절한 Map 구현체의 활용을 고려해볼 수 있다.
  * **EnumMap은 이러한 요구사항에 정확히 부합하며, 열거 타입을 키로 사용하는 Map 구현체**이다.
* EnumMap은 열거 타입 자체가 출력용 문자열을 제공하므로 레이블을 명시할 필요 없고, 안전하며 성능도 좋다.
  * Map 구현체로서의 EnumMap은 타입 안전성을 보장하며, 내부적으로 배열을 사용하여 성능적인 이점까지 취한다.
* 이렇듯 배열의 인덱스를 얻기 위해 ordinal을 사용하는 것은 일반적으로 좋지 않으므로, 대신 EnumMap의 사용을 고려해야 한다.

## 2022-03-07 Mon
### 확장할 수 있는 열거 타입이 필요할 때에는 인터페이스를 활용하기
* 대부분의 상황에서 열거 타입을 확장하는 것은 좋은 방향이 아니지만, 확장 가능한 열거 타입이 필요한 경우가 없는 것은 아니다.
  * 예를 들어, 동작을 결정하는 연산 코드의 예시가 있다.
* 이러한 요구사항에는 열거 타입이 임의의 인터페이스를 구현할 수 있는 특징을 활용한다.
  * 즉, 인터페이스로 연산을 정의하고 열거 타입이 이를 구현하도록 한다.
* 열거 타입은 확장할 수 없지만, 인터페이스와 인터페이스를 구현하는 열거 타입을 활용하여 유사한 효과를 낼 수 있다.
  * 이를 통해 클라이언트는 인터페이스를 구현하여 자신만의 열거 타입을 만들어 사용할 수 있다.
* 이를 **사용하는 클라이언트 코드는 열거 타입을 직접 명시하는 것이 아닌 인터페이스 기반으로 작성되어 있어야 한다**. 
  * 이를 통해 열거 타입의 인스턴스가 사용되는 모든 곳을 확장한 열거 타입의 인스턴스로 대체할 수 있다.
* 이러한 방식은 확장 가능한 열거 타입인 양 위장할 수 있지만, 열거 타입끼리 구현을 상속할 수 없다는 단점도 존재한다.

### 명명 패턴보다는 어노테이션을 활용하기
* 전통적으로 도구나 프레임워크의 특별한 요소에는 사전 정의된 명명 패턴을 사용하곤 했다.
* 그러나 이러한 방식은 다음과 같은 단점이 있다.
  1. 오타를 허용하지 않는다.
  2. 올바른 프로그램 요소에서만 사용되리라고 보증할 수 없다.
  3. 프로그램 요소를 매개 변수로 전달할 방법이 없다.
* **어노테이션은 상술한 명명 패턴의 모든 단점을 해결해주는 개념**이다.
* 어노테이션 중 다른 어노테이션 선언에 달아주는 종류는 메타 어노테이션이라고 하며, @Retention과 @Target 등이 있다.
  * @Retention: 어노테이션의 유지 기간을 명시한다.
  * @Target: 어노테이션을 붙일 수 있는 대상의 종류를 명시한다.
* **어노테이션은 Java 애플리케이션 자체에 직접적인 영향을 주지 않으며, 오로지 어노테이션을 사용하는 프로그램에게 추가 정보를 제공하기 위해서 사용**된다.
  * 즉, **어노테이션은 Target 코드의 의미는 그대로 둔 채 어노테이션과 관련된 프로그램이 별도의 처리를 수행할 수 있는 기회를 제공**한다.
* **어노테이션으로 할 수 있는 작업을 명명 패턴으로 처리해야할 이유는 없다**.
* **일반적인 개발자가 어노테이션 타입을 직접 정의할 일은 거의 없지만, Java 개발자라면 예외 없이 Java가 제공하는 어노테이션 타입을 사용해야 한다**.

### Override 어노테이션은 일관되게 사용하기
* Java가 기본적으로 제공하는 어노테이션 중 일반적인 개발자에게 가장 중요한 어노테이션은 @Override이다.
* **@Override 어노테이션을 일관된 규칙으로 사용하면 여러 버그들을 미연에 방지**할 수 있다.
  * 예를 들어, 메소드 시그니쳐를 잘 못 작성하여 재정의가 아닌 다중 정의를 하는 상황을 방지할 수 있다.
* **상위 클래스의 메소드를 재정의하는 경우, 반드시 @Override 어노테이션을 작성하도록 한다**.
  * 예외적으로, 추상 클래스의 추상 메소드를 구현하는 경우에는 굳이 @Override를 작성하지 않아도 좋다.
  * 추상 메소드를 재정의하지 않은 경우에는 컴파일러가 해당 사실을 오류로서 알려주므로, 굳이 @Override를 단다고 해서 얻을 수 있는 이점이 없다.
* @Override 어노테이션은 클래스 뿐만 아니라 인터페이스의 메소드를 재정의하는 경우에도 사용할 수 있다.
  * 이를 통해 작성하려는 메소드의 시그니쳐가 올바른지 다시 한 번 확인할 수 있다.
  * 만약 **구현하려는 인터페이스에 디폴트 메소드가 없는 경우, @Override를 생략하여 코드를 깔끔히 유지할 수도 있다**.
* **추상 클래스 또는 인터페이스에서 상위 클래스나 상위 인터페이스의 메소드를 재정의하는 경우 역시 @Override를 작성하는 것이 좋다**.
* 이렇듯 **재정의한 모든 메소드에 @Override 어노테이션을 작성하면 개발자의 실수를 컴파일러가 바로잡아줄 수 있다**.

### 정의하려는 대상이 타입이라면 마커 인터페이스를 사용하기
* **마커 인터페이스란 아무런 메소드를 포함하지 않고, 단지 자신을 구현하는 클래스가 어떤 속성을 갖는지 표시하기 위한 인터페이스**이다.
  * 예를 들어, 직렬화 가능성을 표현하는 Serializable 인터페이스가 있다.
* 마커 어노테이션이 마커 인터페이스보다 더 세련되었다는 의견은 사실이 아니며, 둘은 명확한 장단점이 있다.
* 마커 인터페이스는 마커 어노테이션에 비교했을 때,
  1. 이를 구현한 클래스의 인스턴스를 구분하는 타입 정보로 사용할 수 있지만, 마커 어노테이션은 그럴 수 없다.
     * **마커 인터페이스는 타입이므로, 마커 어노테이션이라면 런타임에 발견할 오류를 컴파일 시점에 잡아낼 수 있다**.
  2. 적용 대상을 면밀히 구분할 수 있는 반면, 마커 어노테이션은 그럴 수 없다.
     * **마커 어노테이션은 @Target이 Element.TYPE인 경우 클래스, 인터페이스, 열거 타입, 어노테이션 모두에 정의할 수 있다**.
     * 반면 마커 인터페이스는 적용 대상 클래스가 인터페이스를 구현하도록 하는 것으로 대상을 정밀하게 지정할 수 있다.
* 마커 어노테이션은 마커 인터페이스에 비교했을 때,
  1. 어노테이션 시스템의 지원을 받을 수 있으므로, 어노테이션을 적극적으로 활용하는 프레임워크에서의 일관성 유지에 장점이 있다.
* 마커 어노테이션과 마커 인터페이스의 용도 구분은 크게 다음으로 구분할 수 있다.
  * **클래스 또는 인터페이스 이외의 프로그램 요소에 마킹해야 하는 경우, 마커 어노테이션을 활용**한다.
  * 또한 **어노테이션을 활발하게 활용하는 프레임워크에서 사용할 예정이라면, 마커 어노테이션을 활용**한다.
  * **클래스 또는 인터페이스에 마킹해야 하는 경우, 마킹이 된 객체를 매개변수로 받는 메소드를 작성할 가능성에 대해 자문**한다.
    * 그럴 가능성이 높다면, 마커 인터페이스를 활용한다.
    * 그럴 가능성이 절대 없음을 확신한다면, 마커 어노테이션을 활용한다. 

### 마커 인터페이스의 결론
* 마커 인터페이스와 마커 어노테이션은 각자 적절한 용도가 있다.
* 새로 추가할 메소드 없이 타입만을 정의하는 경우라면 마커 인터페이스를 활용한다.
  * 앞서 다룬 바와 같이, **타입을 정의하는 경우에는 인터페이스를 사용**한다.
* 클래스나 인터페이스 이외의 프로그램 요소에 마킹하는 경우라면 마커 어노테이션을 활용한다.
* 어노테이션을 적극적으로 활용하는 프레임워크에 추가하기 위한 마커라면 마커 어노테이션을 활용한다.
* **@Target이 ElementType.TYPE인 마커 어노테이션을 작성하고자 하는 경우, 마커 어노테이션의 활용을 충분히 고려한 후에 결정**한다. 
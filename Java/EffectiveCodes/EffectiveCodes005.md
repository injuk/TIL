# EffectiveCodes
## 2022-03-06 Sun

## 열거 타입과 어노테이션
### int 상수 대신 열거 타입(enum)을 사용하기
* 열거 타입은 일정 개수의 상수 값을 정의하고, 그 이외의 값은 허용하지 않는 참조 타입이다.
* 열거 타입이 지원되기 전에는 정적 정수 상수를 하나의 클래스에 묶어 표현하곤 했다.
  * 이러한 방식은 타입 안전하지 않고, 표현력도 좋지 않으며 네임 스페이스를 구분할 수 없는 등 단점이 많다.
* **열거 타입은 기존의 정수, 문자열 열거 패턴의 단점을 극복하고, 나아가 여러 장점을 갖는 Java 언어의 대안**이다.
* **Java의 열거 타입은 내부적으로는 완전한 형태의 클래스이므로 다른 언어의 열거 타입보다 강력**하다.
* 열거 타입은 다음과 같은 특징을 갖고, 기존 열거 패턴의 여러 단점을 해소하는 여러 장점들을 제공한다.
  1. 열거 타입은 기본적으로 클래스이다.
  2. 열거 타입은 상수 하나당 자신의 인스턴스를 하나씩 만들어 public static final 필드로 공개한다.
  3. 열거 타입은 밖에서 접근할 수 있는 생성자가 없으므로, 사실상 final 클래스이다.
     * 이 덕분에 클라이언트에서 인스턴스를 직접 생성할 수 없어 상수 당 하나의 인스턴스만이 보장된다.
     * 즉, **열거 타입은 싱글톤 패턴을 일반화한 형태**이다.
  4. 열거 타입은 컴파일 시점의 타입 안전성을 보장한다.
     * **특정한 열거 타입을 매개변수로 받는 메소드에 전달되는 값은 null이 아닌 경우 반드시 해당 열거 타입에 포함되는 값**이다.
  5. 각 열거 타입은 자신의 네임 스페이스가 존재하므로, 같은 이름의 상수도 공존할 수 있다.
  6. **열거 타입은 새로운 상수를 추가하거나 이름을 바꾸더라도 클라이언트 코드를 다시 컴파일할 필요가 없다**.
     * 정수 타입은 static final 변수의 이름이 아닌 값 자체가 클라이언트 코드에 하드코딩되므로, 변경시 재컴파일이 필요하다.
     * 반면 열거 타입에서 클라이언트에 공개되는 것은 필드의 이름뿐이므로 다시 컴파일할 필요가 없다.
  7. 열거 타입의 toString 메소드는 적절한 형태의 문자열을 반환한다.
  8. **열거 타입에는 임의의 메소드나 필드를 추가할 수 있고, 인터페이스를 구현할 수도 있다**.
* **열거 타입은 단순하게는 상수의 모음이지만, 실제로는 클래스이므로 메소드와 필드를 추가하여 고차원의 추상적인 개념 하나를 스스로 표현**할 수 있다.
* **열거 타입에서 상수를 하나 제거하더라도 해당 상수를 참조하지 않는 클라이언트 코드에는 아무런 영향을 주지 않는다**.
  * 제거된 상수를 참조하던 클라이언트는 디버깅을 돕는 적절한 컴파일 오류가 발생한다.
* 열거타입을 선언한 클래스, 또는 패키지에서만 유용한 기능은 private이나 package private으로 구현한다.
* **여러 클래스에서 사용되는 열거 타입은 최상위 수준 클래스로 작성**한다.
  * 반면 **특정한 최상위 수준 클래스에서만 사용되는 열거 타입은 해당 클래스의 멤버로 정의**한다.
* **열거 타입의 생성자에서는 오직 상수 변수에만 접근할 수 있으며, 다른 열거 타입의 정적 필드에 접근할 수 없다**.
  * 이는 각 열거 타입이 public static final 필드이기 때문으로, 아직 초기화되지 않은 정적 필드를 생성자에서 접근할 수는 없다.
* **열거 타입의 상수 일부가 같은 동작을 공유한다면 전략 열거 타입 패턴을 활용**할 수 있다.
  * **전략 열거 타입 패턴이란, 동일한 동작을 하나의 전략으로 분류하여 열거 타입 내부에 포함된 열거 타입에서 분류된 동작을 정의하는 패턴**이다.
  * 이는 대부분의 경우에서 switch 문보다 유지보수성과 유연성이 좋다.
* 열거 타입은 메모리에 적재하기 위한 공간과 시간을 제외하고는 정수 상수와 성능 차이가 없으며, 잘 체감도 되지 않는다.
* 열거 타입은 다음 상황에서 사용을 고려할 수 있다.
  1. 필요한 값 목록을 컴파일 시점에 모두 알 수 있는 상수 집합.
  2. 요일과 같이 본질적으로 열거 타입인 경우.
  3. 명령어 옵션 등 사용 가능한 값을 컴파일 시점에 모두 알 수 있는 상수 집합.
* **열거 타입은 상수의 개수가 변경되더라도 바이너리 수준에서 호환되도록 설계되었으므로, 고정 불변할 필요가 없다**.

### 클래스로서의 열거 타입 활용
* 열거 타입 상수 각각을 특정한 필드와 연결하는 처리는 생성자에서 수행한다.
* 열거 타입은 근본적으로 불변이므로 모든 필드가 final이어야 한다.
* 열거 타입의 필드는 public일 수 있지만, private으로 두고 접근자 메소드를 제공하는 것이 더 바람직하다.
* 열거 타입은 자신이 관리하는 상수의 값을 배열에 담아 반환하는 정적 메소드인 values를 제공하므로, 이를 통해 값을 쉽게 순회할 수 있다.
* 열거 타입의 상수 별로 다른 동작을 수행하고 싶은 경우, 열거 타입 클래스에 추상 메소드를 작성하는 방식을 활용한다.
  * 이후 각 상수의 클래스 몸체에서 상수에 맞는 방식으로 추상 메소드를 재정의한다.

### 열거 타입의 결론
* 열거 타입은 확실히 정수 열거 패턴보다 뛰어나다.
* 대다수의 열거 타입은 생성자와 메소드가 필요 없지만, 각 상수 값을 특정한 필드와 연관짓거나 상수마다 다른 동작을 구현해야 하는 경우에는 정의할 수 있다.
  * 열거 타입의 상수 별 다른 동작을 구현하려면 switch 문은 적절하지 않으며, 대신 상수별 메소드 구현을 사용한다.
  * 이 때, 열거 타입 상수 중 일부에 동일한 동작을 적용해야 한다면 전략 열거 타입 패턴을 사용할 수 있다.

### ordinal 메소드 대신 인스턴스 필드를 사용하기
* 대부분의 열거 타입 상수는 하나의 정수에 대응되도록 작성된다.
* 또한, 모든 열거 타입은 해당 상수가 열거 타입의 몇 번째 위치인지 반환하는 ordinal 메소드를 제공한다.
* 상술한 이유에서 열거 타입 상수에 정수를 연관짓는 경우, ordinal을 통해 값을 반환받고자 할 수 있다.
* 이러한 **ordinal 메소드의 사용은 다음과 같은 이유에서 유지보수가 어려우므로, 절대 사용하지 말아야 한다**.
  1. 상수의 선언 순서가 변경되는 순간 열거 타입의 메소드는 원하는 동작을 수행하지 않는다.
  2. 이미 사용 중인 정수 값과 동일한 값을 추가할만한 방법이 없다.
  3. 값을 중간에 비워둘 수 없으며, 반드시 더미 데이터를 추가해야하는 경우가 생긴다.
  4. **ordinal 메소드는 애초에 EnumSet, EnumMap과 같은 범용 자료구조에서 사용할 목적으로 설계된 메소드**이다.
* **열거 타입에 대응되는 값을 얻어야할 필요가 있다면, ordinal 메소드보다 인스턴스 필드를 정의하는 방식을 사용하는 것이 바람직**하다.
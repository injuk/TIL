# Basics
## 2022-07-26 Tue

### JPA가 지원하는 쿼리 방식
* **데이터베이스에서 데이터를 특정 조건으로 조회하려면 결국 SQL을 사용해야하므로, JPA는 기본적으로 다음과 같은 다양한 쿼리 방식을 지원**한다.
  1. JPQL
  2. JPA Criteria
  3. QueryDSL
  4. 네이티브 SQL
  5. JDBC API, MyBatis, Spring JDBC Template, 등...
* 이렇듯 ORM 기술은 단순한 단건 조회, 단건 생성 등에 대해서 제공하는 메소드 이외에도 복잡한 쿼리를 지원할 수 있어야 한다.
* 이 중, JPA Criteria와 QueryDSL은 Java 코드를 통해 JPQL을 빌드할 수 있는 방법을 제공하는 제너레이터로 이해할 수 있다.
* **네이티브 SQL의 경우, JPA와 표준 SQL 만으로는 해결이 안되는 특정 데이터베이스 종속적인 쿼리를 지원하기 위해 JPA가 지원하는 기능**이다.
* **실무에서는 대부분 JPQL로 모든 요구사항을 충족시킬 수 있으며, 간혹 충족할 수 없는 경우 네이티브 SQL 또는 MyBatis, JDBC Template를 활용**한다.

### JPQL이란?
```
> JPQL이란, 객체를 대상으로 검색하는 객체 지향 SQL이다.
```
* JPA에서, 식별자를 활용한 가장 단순한 조회는 find 메소드를 통해 해결할 수 있다.
  * 반면, 이러한 방식은 조건부 검색 등 상대적으로 더 복잡한 쿼리를 요청해야하는 경우에 대응할 수 없다.
* 이렇듯 JPA를 활용하면 엔티티 객체를 중심으로 개발을 진행하게 되지만, 문제는 검색 쿼리를 요청하는 경우에 발생한다.
  * 이는 **검색 시에도 테이블 대신 엔티티 객체를 대상으로 검색하기 때문이지만, 모든 데이터베이스 데이터를 메모리 상 객체로 변환하여 검색할 수는 없다**.
  * 즉, **애플리케이션이 필요한 데이터베이스만 검색하려면 결국 검색 조건을 포함하는 SQL의 작성이 필수적**이다.
* JPA는 이러한 SQL을 추상화하는 객체 지향 쿼리 언어인 JPQL을 제공하며, 문법 역시 기존 SQL과 유사하게 사용할 수 있다.
* **SQL이 데이터베이스 테이블을 대상으로 쿼리하는 반면, JPQL은 엔티티 객체를 대상으로 쿼리를 수행**한다.
  * 결국 JPQL을 사용하면, 최종적으로는 SQL로 번역되어 요청된다.
* 이 때, 간단한 JPQL 쿼리의 예시는 다음과 같이 작성하여 요청해볼 수 있다.
  * 쿼리의 내용 중 `Member m`은 테이블이 아닌 엔티티 클래스로서의 Member를 의미한다.
  * JPA는 이러한 JPQL을 분석하여 적절한 SQL 쿼리를 생성하여 데이터베이스에 요청하는 방식으로 동작한다.
```
String query = "select m from Member m where m.name like '%ingnoh%'";
List<Member> result = em.createQuery(query, Member.class)
  .getResultList();
```
* **JPQL은 데이터베이스의 테이블이 아닌 객체를 대상으로 검색하며, SQL을 추상화하므로 임의의 데이터베이스 SQL에 의존하지 않도록 한다**.

### JPA Criteria란?
* **JQPL에서 사용되는 쿼리는 근본적으로 String에 불과하므로, 동적 쿼리를 작성하기에는 명확한 한계**가 있다.
  * 문자열을 더하는 연산은 가능하지만, 이는 휴먼 에러가 너무나도 발생하기 쉽다는 단점이 존재한다. 
  * **반면, MyBatis 등의 SQL 매퍼는 동적 쿼리를 쉽게 정의할 수 있다는 장점이 존재**한다.
* Criteria는 이러한 동작 쿼리 문제를 해결하며, 여러 추가적인 장점을 제공하기 위한 대안으로 고안되었다.
  * 이를 통해 문자열이 아닌 Java 코드만으로 JPQL을 작성하는 JQPL 빌더 기능을 제공받을 수 있다.
* **Criteria를 사용하는 경우, 문자열이 아닌 Java 코드 상에서 쿼리를 동적으로 생성하므로 많은 오류를 컴파일 시점에서 인식할 수 있다는 장점**이 있다.
  * 그러나 **Criteria 역시 복잡한 쿼리를 생성하기에는 너무 어렵고 코드가 장황해진다는 단점 역시 존재**한다.
* **Criteria는 이렇듯 JPA 표준 스펙에서 제공하는 개념이지만, 유지보수성이 낮다는 이유로 인해 실무에서는 잘 사용되지 않는다**.
  * 그러나 여전히 **실무에서는 동적 쿼리가 자주 사용되며, Criteria와 같은 컴파일 시점의 SQL 문법 확인 기능 역시 제공받을 필요**가 있다.
  * 이러한 이유에서, 실무에서는 일반적으로 QueryDSL의 사용이 권장된다.

### QueryDSL이란?
* QueryDSL은 JPA Criteria와 마찬가지로 Java 코드를 기반으로 한 JPQL 빌더 역할을 수행하며, 컴파일 시점에 문법 오류를 찾을 수 있도록 한다.
* 그러나 **JPA Criteria와 달리 동적쿼리 작성이 편리하고, 단순하고 쉬워 유지보수성도 높으므로 실무에서 사용이 권장**된다.
  * QueryDSL은 사실상 JPQL과 일대 일 매칭되므로, JPQL을 정확히 이해한 경우 QueryDSL은 공식 문서만으로도 사용이 가능할 수 있다.
  * 이는 그만큼 QueryDSL의 공식 문서가 잘 작성되어 있기 때문이기도 하다.
* **실무에서는 95% 이상의 쿼리가 JPQL과 QueryDSL 조합으로 해결이 가능**하다.

### 네이티브 SQL이란?
* **JPA는 SQL을 직접 사용하는 기능을 네이티브 SQL 형태로 제공하며, 이는 JPQL만으로는 해결할 수 없는 데이터베이스 의존적인 기능에 활용**된다.
  * 예를 들어, Oracle의 `CONNECT BY` 등의 기능이 포함된다.
* **네이티브 SQL은 실제 SQL을 문자열 형태로 작성하고, 엔티티 매니저의 createNativeQuery 메소드를 호출하여 사용**할 수 있다.
```
String query = "SELECT * FROM MEMBER WHERE NAME = 'ingnoh'";
List<Member> results = em.createNativeQuery(query, Member.class)
  .getResultList();
```
* 그러나 **실무에서는 일반적으로 네이티브 SQL보다는 Spring JDBC Template을 사용하는 편**이다.

### JDBC 직접 사용, 또는 Spring JDBC Template 사용하기
* JPA를 사용하는 과정에서 JDBC 커넥션을 직접 사용하거나, Spring의 JDBC Template 또는 SQL 매퍼인 MyBatis를 함께 사용할 수 있다.
* 단, 반드시 영속성 컨텍스트를 적시에 강제로 flush 해 줄 필요가 있다.
  * 예를 들어, JPA를 우회하여 SQL을 실행하기 전에 영속성 컨텍스트를 직접 flush 한다.
* **기본적으로 트랜잭션이 커밋되는 시점이나 createQuery 또는 createNativeQuery 메소드가 호출되는 경우, JPA는 자동으로 flush를 호출**한다.
  * 이렇듯 JPA는 쿼리를 직접 요청하는 경우 암시적으로 flush를 호출하여 쿼리 결과를 그 때 그 때 데이터베이스에 반영한다.
  * 때문에 **이러한 동작을 JPA의 기본 동작으로 혼동하여 flush를 호출하지 않는 실수를 범하지 않아야 한다**.
* 실무에서 JPQL과 QueryDSL로 해결이 안되는 약 5%의 복잡한 통계성 쿼리는 Spring JDBC Template 등을 활용하여 쿼리를 직접 요청할 수 있다.
  * 그러나 이마저도 대부분의 경우에는 JPQL과 QueryDSL로 풀어낼 수 있다.
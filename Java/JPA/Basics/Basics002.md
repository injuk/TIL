# Basics
## 2022-07-12 Tue

### JPA에서 중요한 개념들
* 올바른 JPA의 사용을 위해서 반드시 이해해야하는 것은 다음과 같다.
  1. 객체와 관계형 데이터베이스의 매핑
  2. 영속성 컨텍스트
* 객체와 관계형 데이터베이스의 매핑은 설계와 같은 정적인 지식을 필요로 하며, 크게 다음과 같이 분류할 수 있다.
  * 데이터베이스의 설계
  * 객체의 설계
  * JPA를 활용한 매핑
* 반면 **영속성 컨텍스트의 경우, 실제로 JPA는 내부적으로 어떻게 동작하는지에 대한 지식을 나타낸다**.
  * 때문에 영속성 컨텍스트를 명확히 이해할 경우, JPA의 내부 동작 원리를 알 수 있게 된다.

### 영속성 컨텍스트란?
* **영속성 컨텍스트란 엔티티를 영구 저장하는 환경을 의미하며, JPA를 이해하는 데에 있어 가장 중요한 용어**이다.
* 앞서 다룬 **em.persiste(entity)의 경우, 실제로는 데이터베이스에 즉시 영속화하는 것이 아닌 영속성 컨텍스트에 저장하는 것**이다.
* **영속성 컨텍스트는 논리적인 개념이며, 개발자는 엔티티 매니저를 통해서만 영속성 컨텍스트에 접근**할 수 있다.
  * 엔티티 매니저가 내부적으로 영속성 컨텍스트라는 공간을 포함하는 것으로 이해해도 무방하다.

### 엔티티 생명주기
* 엔티티는 영속성 컨텍스트와 밀접한 연관이 있으며, 다음과 같이 분류되는 상태를 가질 수 있다.
  1. 비영속 상태: 영속성 컨텍스트와 전혀 관계 없는 새로운 상태이다.
  2. 영속 상태: 영속성 컨텍스트에 의해 관리되는 상태이다.
  3. 준영속 상태: 영속성 컨텍스트에 저장되었으나, 현재에는 분리된 상태이다.
  4. 삭제 상태: 말 그대로 삭제된 상태를 말한다.

### 비영속 상태
* 비영속 상태란, 엔티티 객체가 new 연산자 등에 의해 막 생성된 상태일 수 있다.
* 비영속 엔티티는 엔티티 매니저에 포함되는 영속성 컨텍스트와는 완전히 무관한 상태를 갖는다.
  * 즉, **비영속 상태의 엔티티는 JPA와는 전혀 관계가 없다**.

### 영속 상태
* **비영속 상태의 엔티티 객체를 em.persist 등의 메소드를 통해 영속성 컨텍스트에 저장한 상황**을 가리킨다. 
  * **영속 상태의 엔티티는 영속성 컨텍스트에 의해 관리**된다.
* **중요한 것은 영속 상태에 진입한 엔티티는 그 즉시 데이터베이스에 저장되지는 않는다는 사실**이다.
  * 즉, 엔티티가 영속 상태가 된다고 해서 즉시 데이터베이스에 쿼리를 요청하지는 않는다.
  * **실제 쿼리는 트랜잭션을 커밋하는 시점에 영속성 컨텍스트에 의해 관리되던 엔티티 객체들의 상태에 따라 쿼리가 요청**된다.

### 준영속 상태와 삭제 상태
* 준영속 상태란 em.detach 등의 메소드에 의해 엔티티가 영속성 컨텍스트에서 분리된 상태를 의미한다.
* 삭제 상태란 em.remove 등의 메소드에 의해 객체가 삭제된 상태를 의미한다.
  * 이 때, 해당 메소드는 실제로 데이터베이스에 영속화된 데이터에 대해 DELETE 쿼리를 요청한다.

### 영속성 컨텍스트의 이점
* 영속성 컨텍스트와 같은 메커니즘은 개발자에게 다음과 같은 이점을 제공한다.
  1. 1차 캐시를 제공한다.
  2. 엔티티의 동일성을 보장한다.
  3. 트랜잭션을 지원하는 쓰기 지연 기능을 제공한다.
  4. 변경 감지 기능을 제공한다.
  5. 지연 로딩 기능을 제공한다.
* 이는 모두 **애플리케이션과 데이터베이스 사이에 영속성 컨텍스트가 마치 버퍼처럼 중간 계층으로 존재함으로써 제공되는 이점**이다.

## 2022-07-13 Wed
### 1차 캐시란?
* **영속성 컨텍스트는 내부적으로 1차 캐시라는 개념을 포함하며, 이는 마치 맵과 같은 형태**를 갖는다.
  * **1차 캐시는 키로서 엔티티의 PK를 사용하며, 키에 대응되는 값으로서 엔티티 자체를 캐싱**한다.
* 때문에 1차 캐시에 캐싱된 엔티티를 동일한 트랜잭션 내에서 조회하는 경우, 1차 캐시로부터 조회하므로 데이터베이스에 접근할 필요가 없다는 이점을 얻을 수 있다.
  * 정확히 말해서 JPA는 em.find와 같은 메소드가 호출된 경우 우선 1차 캐시를 조회한다.
  * 1차 캐시에서 조회한 결과에 따라 캐시의 엔티티를 그대로 반환하거나 데이터베이스를 조회한다.
* **1차 캐시에서 발견하지 못하여 데이터베이스로부터 조회한 엔티티의 경우, 우선 1차 캐시에 저장한 후에 클라이언트 코드에게 반환**한다.
* 그러나 1차 캐시로 인해 얻을 수 있는 성능 향상은 크지 않다.
  * 이는 **엔티티 매니저가 기본적으로 트랜잭션 단위로 동작하며, 트랜잭션이 종료되면 영속성 컨텍스트와 함께 1차 캐시 역시 사라지기 때문**이다.
  * 즉, **고객 한 명의 요청이 종료되면 영속성 컨텍스트는 지워진다**.

### 영속 상태인 엔티티의 동일성 보장
* JPA의 경우 1차 캐시의 도입으로 인해 `REPEATABLE READ` 등급의 트랜잭션 격리 수준을 데이터베이스가 아닌 애플리케이션 차원에서 제공한다.
* 이는 마치 Java 컬렉션 API에서 동일한 요소를 가져와``==` 비교를 수행했을 경우 동일성이 보장되는 것과 같다.
  * 즉, **동일한 영속성 컨텍스트에 의해 영속 상태로 관리되는 엔티티의 식별자에 따라 동일성을 보장**한다.

### 엔티티 영속화시 트랜잭션을 지원하는 쓰기 지연 기능
* **JPA를 사용하는 경우, 엔티티 매니저는 데이터 변경을 위해 반드시 트랜잭션을 시작**해야 한다.
* 이 때, 트랜잭션이 시작된 후에 시도된 영속화를 의미하는 INSERT 쿼리는 요청 즉시 보내지지 않는다.
* 대신 **트랜잭션 도중에 발생한 모든 INSERT 쿼리를 모아두며, 트랜잭션이 커밋되는 순간에 데이터베이스에 INSERT SQL을 한 번에 요청**한다.

### 쓰기 지연 SQL 저장소
* **영속성 컨텍스트의 내부에는 1차 캐시와 더불어 쓰기 지연 SQL 저장소 역시 존재**한다.
* 이를 토대로, em.persist(entityA)와 em.persist(entityB) 라는 코드를 연속으로 호출한 경우, 다음과 같이 동작한다.
  1. 해당 entityA의 식별자와 엔티티 자체를 1차 캐시에 저장한다.
  2. **동시에 JPA가 영속화될 엔티티를 미리 분석하여 INSERT 쿼리를 생성한 후 쓰기 지연 SQL 저장소에 저장**해둔다.
  3. 여기까지 트랜잭션이 커밋되지 않았으므로 데이터베이스와의 통신은 발생하지 않는다.
  4. 이윽고 entityB의 식별자와 엔티티 자체를 1차 캐시에 저장한다.
  5. **동시에 JPA가 영속화될 엔티티를 분석하여 INSERT 쿼리를 생성한 후 쓰기 지연 SQL 저장소에 저장**해둔다.
  6. 이 시점에서 entityA와 entityB 각각에 대한 INSERT 쿼리는 쓰기 지연 SQL 저장소에 저장된 상태이다.
  7. **모든 영속화 작업이 종료되어 트랜잭션이 커밋 시도된 경우, 쓰기 지연 SQL 저장소에 저장되었던 쿼리들은 flush 동작에 의해 데이터베이스에 요청**된다.
  8. 실제 데이터베이스가 커밋되며 영속화 작업이 종료된다.
* 이렇듯 INSERT 쿼리는 엔티티 매니저의 트랜잭션이 커밋될 때까지 영속 상태가 된 엔티티와 함께 영속성 컨텍스트 내부에 쌓여간다.

### JPA는 왜 INSERT 쿼리를 즉시 요청하지 않을까?
* 만약 em.persist 메소드가 호출될 때마다 INSERT 쿼리를 요청하는 경우, 해당 프레임워크는 데이터베이스와의 상호작용에 있어 최적화할 여지조차 없다.
* 때문에 **JPA는 쓰기 지연 SQL 저장소 개념을 도입하였고, 이로 인해 개발자는 INSERT 쿼리에 대한 버퍼링 효과**를 누릴 수 있게 된다.
* 하이버네이트의 경우 persistence.xml에서 `hibernate.jdbc.batch_size` 설정을 지원한다.
  * 예를 들어 **해당 값이 10으로 설정되어 10번의 INSERT 쿼리가 요청된 경우, 하이버네이트는 하나의 네트워크 IO를 통해 영속화를 요청한 후 커밋**한다.
* **이러한 옵션을 적절히 사용하는 경우, JPA를 사용하면서도 오히려 성능 상의 이점을 누릴 수 있게 된다**.
  * MyBatis와 같은 SQL 매퍼를 사용하는 경우, 이러한 쓰기 지연 기능을 직접 구현하기는 매우 까다로운 작업이 된다.

### 엔티티 수정과 변경 감지 기능
* 트랜잭션 안에서 데이터베이스에 영속화된 엔티티를 조회한 경우, 해당 엔티티는 영속 상태가 된다.
* 이 때, 영속 상태의 엔티티가 갖는 데이터를 수정한 경우 별도의 em.persist 메소드 호출은 전혀 필요가 없다.
  * 이는 **트랜잭션이 커밋된 시점에 JPA가 엔티티의 모든 변경 사항을 감지하여 자동으로 업데이트 쿼리를 생성한 후 데이터베이스에 요청하기 때문**이다.
  * 이러한 JPA의 엔티티 수정 기능을 가리켜 변경 감지 또는 Dirty checking이라고 부를 수 있다.
* 변경 감지를 활용한 엔티티의 수정 역시 마치 Java 컬렉션 API의 요소를 수정하는 것과 유사하게 동작하는 것을 확인할 수 있다.

### 변경 감지 동작 원리
* **변경 감지 기능은 영속성 컨텍스트를 기반으로 동작하며, 그 근간에는 역시 1차 캐시와 쓰기 지연 SQL 저장소가 존재**한다.
* JPA에서 트랜잭션을 커밋하고자 하는 경우, 다음과 같은 동작이 발생한다.
  1. 내부적으로 flush 메소드를 호출한다.
  2. **1차 캐시 내부에 저장되어 있는 각 엔티티와, 대응되는 스냅샷을 모두 비교**한다.
     * 이 때, **스냅샷은 엔티티가 최초로 영속 상태가 된 순간의 상태를 의미**한다.
  3. **모든 엔티티와 스냅샷을 비교하는 과정에서, 변경 사항이 존재하는 엔티티를 분석하여 UPDATE 쿼리를 생성하고 쓰기 지연 SQL 저장소에 저장**한다.
  4. 적재된 UPDATE 쿼리를 토대로 데이터베이스에 변경 사항을 반영한 후에 트랜잭션을 커밋한다.

### 엔티티의 삭제
* 영속화된 데이터를 삭제하고자하는 경우, 삭제 대상 엔티티를 우선 em.find로 조회하여 영속 상태로 만든다.
* 그 이후 em.remove 메소드를 호출하여 해당 엔티티를 삭제한다.
  * 이 때, **DELETE 쿼리 역시 상술한 동작 원리와 유사하게 트랜잭션이 커밋되는 시점에 생성되어 데이터베이스에 반영**된다.

### 플러시란?
* **플러시는 영속성 컨텍스트의 변경 내용을 데이터베이스에 반영하는 작업**을 말한다.
  * 일반적으로는 데이터베이스 트랜잭션이 커밋되는 시점에 플러시가 발생한다.
  * **플러시는 쓰기 지연 SQL 저장소에 적재되었던 INSERT 또는 UPDATE, DELETE 쿼리들을 요청하는 식으로 동작**한다.
* 즉, **플러시는 영속성 컨텍스트의 변경 사항과 데이터베이스를 일관화시키는 작업**이다.
  * 이는 INSERT 등 엔티티의 변경 사항이 트랜잭션 도중 영속성 컨텍스트에서 관리되기 때문이다.

### 플러시가 발생하면?
* 데이터베이스 트랜잭션이 커밋되면 자동으로 플러시가 발생하며, 다음과 같은 작업들이 동작한다.
  1. 변경 감지
  2. 수정된 엔티티를 쓰기 지연 SQL 저장소에 등록
  3. 쓰기 지연 SQL 저장소의 등록, 수정, 삭제 쿼리를 데이터베이스에 전송
* 이 때, 플러시가 발생한다고 해서 데이터베이스 트랜잭션이 커밋되는 것은 아니다.

### 영속성 컨텍스트를 플러시하기
* 영속성 컨텍스트를 플러시하기 위해서는 다음과 같은 작업을 수행할 수 있다.
  1. em.flush 메소드 호출하기: 플러시를 직접 호출한다.
  2. 트랜잭션을 커밋하기: 플러시는 자동으로 호출된다.
  3. JPQL 쿼리를 실행하기: 플러시는 자동으로 호출된다.
* 이 중 **em.flush 메소드를 직접 호출하는 방식은 테스트 이외에는 사용할 일이 거의 없다**.
* 이 떄, **플러시를 명시적으로 호출하더라도 1차 캐시는 비워지지 않는다는 점에 주의**해야 한다.
  * 플러시는 모든 데이터를 요청한 후에 지우는 것이 아니며, 오로지 쓰기 지연 SQL 저장소의 쿼리만을 활용한다.

### 왜 JPQL을 호출하면 플러시될까?
* 예를 들어 하나의 트랜잭션 안에서 세 개의 엔티티를 영속화한 직후 JPQL을 통해 엔티티 목록을 조회한다고 하자.
  * 이 시점에서 트랜잭션이 커밋되지 않았으므로 실제 INSERT 쿼리는 요청되지 않는다.
  * 그러나 개발자의 입장에서, 세 개의 엔티티를 영속화하였으나 목록 조회 결과로부터 어떠한 엔티티도 발견되지 않는 것은 어색하다.
  * **JPA는 이러한 문제점을 방지하고자 기본적으로 JPQL을 사용하는 경우, 사용 직후에 플러시를 호출**한다.

### 플러시 모드 옵션
* 플러시 모드 옵션은 em.setFlushMode 메소드를 호출하여 설장할 수 있다.
  1. FlushModeType.AUTO:  커밋이나 쿼리를 실행할 때 플러시를 호출하며, 기본값이다.
  2. FlushModeType.COMMIT: 커밋 시점에만 플러시를 호출한다.
* 이러한 두 플러시 모드 옵션은 실무에서는 사용할 일이 거의 없다.
* 상술한 시나리오에서, 영속화한 엔티티와 JPQL을 통해 조회하는 테이블이 전혀 다르다고 가정하는 경우, 굳이 JPQL 호출 시점에 쿼리를 요청할 필요는 없다.
  * 이러한 경우에 FlushModeType.COMMIT 옵션을 적용해볼 수도 있다.
  * 그럼에도 체감될 정도로 성능이 향상되지는 않으므로, 되도록이면 AUTO 옵션을 애용하는 것이 바람직하다.

### 플러시의 특징
* **플러시는 영속성 컨텍스트를 비우지 않으며, 오로지 영속성 컨텍스트의 변경 사항을 데이터베이스에 동기화하는 작업만 수행**한다.
* 이 때, 중요한 것은 트랜잭션이라는 데이터베이스의 작업 단위이다.
  * 중요한 것은 커밋 직전에만 동기화를 마치면 된다는 의미이다.

## 2022-07-14 Thu
### 준영속 상태란?
* **준영속 상태는 영속 상태의 엔티티가 영속성 컨텍스트로부터 분리된 상태이며, 영속성 컨텍스트가 제공하는 기능을 더 이상 사용할 수 없다**.
  * 예를 들어, 준영속 상태의 엔티티는 변경 감지 등의 기능을 더 이상 활용할 수 없다.
* 엔티티를 준영속 상태로 만드는 방법은 크게 다음과 같이 분류할 수 있다.
  1. em.detach: 특정한 엔티티만을 준영속 상태로 전환한다.
  2. em.clear: 엔티티 매니저가 갖는 영속성 컨텍스트를 완전히 초기화한다.
  3. em.close: 영속성 컨텍스트를 종료한다.
* 이러한 준영속 상태로의 전환 방법도 실무에서는 잘 사용되지 않지만, 종종 1차 캐시에 관계 없이 어떠한 쿼리가 발생하는지 확인하고 싶은 경우에 사용할 수 있다.
  * 즉, detach와 clear 등의 메소드 역시 테스트 케이스 작성에 주로 사용된다.

### 중간 정리
* JPA에서 가장 중요한 두가지는 다음과 같다.
  1. 객체와 관계형 데이터베이스를 잘 매핑하는 것: 정적인 매핑 과정을 의미한다.
  2. 영속성 컨텍스트를 이해하는 것: JPA가 실제로 동작하는 원리 자체를 의미한다.
* **영속성 컨텍스트란 엔티티를 영구 저장하기 위한 환경이며, 엔티티 매니저를 통해 접근할 수 있는 논리적인 개념**이다.
* 영속 상태는 em.persist 또는 em.find의 대상 엔티티가 갖는 상태이다.
* 영속성 컨텍스트가 제공하는 1차 캐시는 동시에 요청한 클라이언트마다 별도의 캐시를 갖게 되므로, 성능 상의 이점보다는 메커니즘 상의 이점을 누릴 수 있게 한다.
* 트랜잭션을 지원하는 쓰기 지연은 버퍼링을 의미하며, 데이터베이스에 변경을 가하는 쿼리를 트랜잭션 커밋 시점까지 모아두었다가 한 번에 요청할 수 있다.
* 플러시는 트랜잭션 커밋 또는 쿼리를 요청할 때 실행되며, 플러시 모드는 가급적 수정하지 않고 기본 상태인 AUTO를 활용한다.
* **플러시는 영속성 컨텍스트를 완전히 비우는 개념이 아닌, 영속성 컨텍스트와 실제 데이터베이스를 동기화하는 작업**이다.
* **JPA 전체적으로 트랜잭션이라는 작업 단위가 매우 중요하며, 영속성 컨텍스트와 트랜잭션의 생명 주기를 맞추어 설계해야 문제가 생기지 않는다**.
  * 즉, 트랜잭션이 종료되면 영속성 컨텍스트 역시 종료되도록 설계하여 개발을 진행해여 영속성 컨텍스트와 데이터베이스 사이의 동기화에 문제가 발생하지 않는다.
* JPA는 트랜잭션이라는 작업 단위에 많은 부분을 위임하며, 커밋 직전에만 데이터를 동기화하면 되므로 생각만큼 데이터 동기화와 관련된 이슈를 걱정할 필요는 없다.
# Basics
## 2022-07-14 Thu

### 엔티티 매핑
* 엔티티의 매핑은 JPA에서 가장 중요한 두 가지 중 하나이다.
  * 예를 들어, 또 다른 중요한 개념인 영속성 컨텍스트는 JPA 내부적인 동작 원리를 강조한다.
  * 반면 **엔티티 매핑은 설계적인 측면을 강조하며, 객체와 관계형 데이터베이스를 어떻게 매핑하여 사용할지와 같은 정적인 측면을 의미**한다.
* 엔티티 매핑은 주로 어노테이션을 명시하여 진행하며, 다음과 같은 매핑을 사용할 수 있다.
  1. 객체와 테이블 간의 매핑: @Entity, @Table
  2. 필드와 컬럼 간의 매핑: @Column
  3. 기본 키 매핑: @Id
  4. 연관관계의 매핑: @ManyToOne, @JoinColumn

### @Entity
* 해덩 어노테이션이 명시된 클래스는 JPA가 관리하는 엔티티가 된다.
  * 따라서 **JPA를 통해 관리할 테이블과 매핑하는 클래스는 반드시 @Entity 어노테이션을 명시**해야 한다.
* **엔티티 클래스는 JPA가 관리하기 위해 반드시 public 또는 protected 접근 제어자로 정의된 기본 생성자를 가져야 한다**.
  * 또한, 엔티티 클래스는 final이거나 enum, interface, inner 클래스일 수 없다.
  * **엔티티 클래스를 통해 저장할 필드에는 final 키워드도 사용하지 않아야 한다**.
* 상술한 이유에서, @Entity 어노테이션이 명시된 클래스를 보면 다음과 같은 내용을 유추할 수 있다.
  1. 해당 클래스는 JPA에 의해 관리될 것이다.
  2. **해당 클래스는 실제 데이터베이스의 JPA가 관리하는 테이블과 매핑될 것**이다.
* 해당 어노테이션에는 `name` 속성을 명시하여 JPA에서 관리할 엔티티의 이름을 지정할 수 있으며, 기본적으로는 클래스의 이름을 그대로 사용한다.
  * **해당 속성은 JPA가 내부적으로 구분하는 이름을 의미하지만, 굳이 name 속성을 통해 모든 엔티티 객체의 이름을 정의할 필요는 없다**.
  * 즉, 다른 패키지에 동일한 클래스 이름이 존재하는 경우가 아니라면 기본 값을 사용하는 것이 바람직하다.

### @Table
* 해당 어노테이션은 엔티티 객체의 이름과 다른 이름을 갖는 테이블과 매핑하고 싶은 경우에 사용한다.
* 예를 들어, 회사의 규정상 엔티티의 이름과 동일한 테이블이 아닌 축약어를 사용해야하는 경우에 `@Table(name = "테이블명")` 형태로 명시할 수 있다.
  * 이 경우, 해당 엔티티와 관련된 모든 쿼리는 @Table 어노테이션의 `name` 속성에 명시된 값의 테이블을 대상으로 요청된다.

### 데이터베이스 스키마의 자동 생성
* **JPA는 매핑 정보만으로도 어떠한 테이블에 어떠한 쿼리를 요청해야할지 분석**할 수 있다.
  * 나아가, JPA는 애플리케이션 로딩 시점에 데이터베이스 테이블을 생성하는 기능까지도 지원한다.
  * 당연히 이러한 기능은 운영 상황에서는 사용을 지양해야 하지만, 개발 단계 또는 로컬 환경에서는 큰 도움을 줄 수 있다.
* 이렇듯 **JPA는 애플리케이션의 실행 시점에 DDL을 자동 생성하며, 테이블 중심의 개발 대신 객체 중심의 개발을 가능케** 한다.
  * 즉, 테이블을 우선 모두 정의한 후에 객체를 설계하는 기존 방식 대신 객체의 설계부터 집중할 수 있다.
  * 이 때, **JPA는 설정된 데이터베이스 방언을 활용하여 데이터베이스에 맞는 적절한 DDL을 생성**한다.
* 생성된 DDL은 운영 환경에서는 아예 사용하지 않거나, 참고 삼아 다듬은 후에 사용하는 것이 바람직하다.

### 데이터베이스 스키마 자동 생성 옵션
* persistence.xml의 `hibernate.hbm2ddl.auto` 속성을 통해 다음과 같은 데이터베이스 스키마 자동 생성 기능을 지원받을 수 있다.
  1. create: 기존 테이블을 DROP한 후에 다시 CREATE한다.
  2. create-drop: create와 같으나, 종료 시점에도 테이블을 DROP한다.
  3. update: 변경 분량만 반영하지만, 운영 환경에서는 절대 사용하지 않아야 한다.
  4. validate: 엔티티와 테이블이 정상적으로 매핑되었는지만을 확인한다.
  5. none: 아무 것도 사용하지 않는다.
* 예를 들어, create 속성은 애플리케이션 동작 시점에 엔티티가 매핑된 모든 클래스를 테이블로 매핑한다.
* update의 경우, 예를 들어 기존 테이블에 없던 컬럼을 추가하고 싶지만 DROP 대신 ALTER를 통해 테이블을 수정하고 싶은 경우에 사용할 수 있다.
  * 이 때, update 속성은 기존 데이터와 테이블을 삭제하지 않고 새로운 컬럼의 추가만을 지원한다.
  * 때문에 **엔티티의 속성이 제거되었더라도, 대응되는 테이블 컬럼을 제거하지는 않는다**.
  * 이는 개발자의 부주의로 테이블 컬럼을 제거하였을 때 크나큰 문제가 발생할 가능성이 있기 때문이다.
* 사실 none이라는 속성은 JPA 스펙 상 존재하지 않으며, 임의의 문자열을 적어도 똑같은 기능을 수행하지만 관례상 none으로 표기하곤 한다.

### 데이터베이스 스키마 자동 생성 기능의 주의사항
* 운영 환경에서는 절대로 create, create-drop, update 속성을 사용하지 않아야 한다.
  * 개발 초기 단계에서는 create 또는 update 속성을 활용해도 무방하다.
  * 테스트 서버에서는 update 또는 validate를 설정할 수 있다.
  * **스테이징과 운영 환경에서는 validate 또는 none을 사용**해야 한다.
* **운영 환경에 몇천만 건의 데이터가 저장되어 있는 경우, update 속성을 통해 자칫 ALTER 쿼리라도 요청했다간 락에 의해 시스템이 중단될 수도** 있다.
  * 이렇듯 애플리케이션 로딩 시점에 JPA가 알아서 ALTER 쿼리를 요청한다는 것 자체가 매우 위험하다.
* 그러나 **가장 이상적인 것은 개발자 자신이 직접 DDL을 정의하고, 개발 또는 테스트 환경에서 테스트를 진행하는 것**이다.
  * 이 과정에서 문제가 발생하지 않은 경우에만 운영 환경에 적용하거나 DBA에게 전달할 것을 검토할 수 있게 된다.

### DDL 제약 조건 추가하기
* @Column 어노테이션의 여러 속성을 통해 DDL에 제약 조건을 추가할 수도 있다.
  1. unique: 해당 컬럼이 유니크한가?
  2. length: 해당 컬럼의 최대 길이는 어느 정도인가?
* 특히, 이렇게 정의된 유니크 제약조건은 애플리케이션 자체보다는 데이터베이스에 영향을 준다.
  * 즉 **DDL 생성 기능은 DDL을 자동 생성할 때만 사용되며, JPA의 실행 로직에는 전혀 영향을 주지 않는다**.
* JPA가 실행될 때마다 런타임에 영향을 주지는 않으며, JPA는 오로지 개발자의 필요에 따라 DDL 생성 기능만을 제공한다.

## 2022-07-15 Fri
### 필드와 컬럼 매핑 
* JPA에서 엔티티와 테이블을 매핑하는 것은 크게 어려울 일이 없는 작업이지만, 필드와 컬럼을 매핑하는 과정에서는 많은 작업을 해야할 수도 있다.
* 예를 들어, 컬럼 매핑 과정에서 다음과 같은 어노테이션을 활용할 수 있다.
  1. @Column(name = ""): 객체 필드 명과 테이블 컬럼명이 다른 경우, 테이블 컬럼명을 명시한다.
  2. @Enumerated: Java에서는 enum타입을 유용하게 사용하지만 데이터베이스에는 완벽히 매핑되는 타입이 없다.
     * 이러한 불일치성을 해결하기 위해 해당 어노테이션을 통해 데이터베이스에 저장될 타입을 명시할 수 있다.
  3. @Temporal: Java는 일반적으로 날짜와 시간을 모두 표현하는 Date 타입을 사용하지만, 데이터베이스는 날짜와 시간, 날짜 + 시간을 모두 사용한다.
     * 이러한 불일치성을 해결하기 위해 데이터베이스에 저장될 타입을 명시할 수 있다.
  4. @Lob: 해당 어노테이션은 VARCHAR와 같은 형태만으로는 해결할 수 없는 큰 데이터를 표현하기 위해 명시한다.
     * String 형 필드에 @Lob 어노테이션을 명시한 경우, 기본적으로 컬럼은 clob으로 매핑된다.
  5. @Transient: 특정 필드는 데이터베이스의 컬럼으로 매핑하고 싶지 않은 경우에 명시한다.

### @Column
* 해당 어노테이션은 필드와 컬럼을 매핑하는 과정에서 가장 자주 사용되며, 다음과 같은 속성을 가질 수 있다.
  1. name: 필드와 매핑될 실제 테이블의 컬럼명을 명시한다.
  2. insertable, updatable: 등록 또는 변경 가능 여부를 boolean 형으로 명시한다.
     * 기본적으로 모두 true로 설정되어 있으며, 데이터베이스를 직접 고치지 않는 이상 코드 상에서의 등록과 변경을 방지할 수 있다.
  3. nullable: DDL 생성시에 사용되며, 해당 컬럼의 null 가능성을 명시한다.
  4. unique: DDL 생성시에 사용되며, 해당 컬럼의 unique 가능성을 명시한다.
     * 그러나 **해당 속성으로 명시된 UQ 제약 조건은 이름을 알아보기 어려운 난수형태로 명명되므로, 잘 사용되지 않는 옵션**이다.
     * 또한 복합 유니크 조건을 명시할 수도 없으므로, 일반적으로는 엔티티 자체에 @Table(uniqueConstraints) 어노테이션을 명시하여 사용한다.
  5. columnDefinition: 데이터베이스 컬럼에 사용될 정보를 직접 명시할 수 있다.
  6. length: String 타입에만 명시할 수 있으며, 문자 길이 제약조건을 명시하기 위해 사용할 수 있다.
  7. precision, scale: BigDecimal 또는 BigInteger 타입에만 명시할 수 있다.
     * precision: 소수점을 포함하는 전체 자리수를 의미한다.
     * scale: 소수의 자리수를 의미한다.
     * 두 타입 모두 double, float 타입에는 적용되지 않으며 매우 정밀한 소수를 다루는 경우에만 사용된다.
  
### @Enumerated
* 해당 어노테이션은 Java의 enum 타입을 데이터베이스 컬럼에 매핑하기 위해 사용할 수 있다.
* 이 때, 어노테이션의 속성으로 다음과 같은 타입을 명시할 수 있다.
  1. EnumType.ORDINAL: enum 필드의 순서를 데이터베이스에 저장한다.
  2. EnumType.STRING: enum 필드의 이름을 데이터베이스에 저장한다.
* 이 때, **기본값은 EnumType.ORDINAL로 적용되지만 절대 ORDINAL을 사용하지 않아야 한다**.
  * **ORDINAL 설정은 추후 enum이 수정된 경우 이를 데이터베이스에 이미 영속화된 데이터들에 반영하기가 매우 어렵다**.
* 따라서 데이터베이스에 저장되는 몇 글자를 아끼기보다는 큰 장애를 방지하기 위해 애초에 STRING 속성을 사용하는 것이 바람직하다.
  * 이 경우, 추후 새로운 enum이 추가되더라도 순서에 의한 문제가 발생하지 않는다.

### @Temporal
* Date, Calendar 등의 Java 날짜 타입을 데이터베이스에 명시하기 위해 사용한다.
* 이 때, 해당 어노테이션의 속성으로는 다음과 같은 타입을 사용할 수 있다.
  1. TemporalType.DATE: 날짜만을 명시하며, 데이터베이스의 date 타입과 매핑된다.
  2. TemporalType.TIME: 시간만을 명시하며, 데이터베이스의 time 타입과 매핑된다.
  3. TemporalType.TIMESTAMP: 날짜와 시간을 모두 명시하며, 데이터베이스의 timestamp 타입과 매핑된다.
* **최근에 주로 사용되는 LocalDate, LocaleDateTime을 사용하는 경우에는 최신 하이버네이트가 자체적으로 지원할 수 있으므로 생략이 가능**하다.
  * 최신 하이버네이트는 해당 어노테이션이 명시되어 있지 않더라도 타입만으로 추론이 가능하다.

### @Lob
* 데이터베이스의 BLOB, CLOB과 매핑하기 위해 명시하는 어노테이션이며, 상술한 어노테이션들과 달리 별도의 속성을 제공하지 않는다.
  * 대신 매핑하는 필드의 타입에 따라 문자의 경우에는 CLOB, 나머지는 BLOB으로 다음과 같이 매핑된다.
    1. CLOB: String, char[], java.sql.CLOB 타입의 객체들
    2. BLOB: byte[], java.sql.BLOB 타입의 객체들

### @Transient
* 필드를 매핑하지 않기 위해 명시하는 어노테이션이며, 데이터베이스에 저장도 되지 않고 조회도 하지 않는다.
* 주로 비즈니스 로직 상 메모리 상에서 임시로 값을 보관해두고자 하는 필드에 적용한다.

## 2022-07-16 Sat
### 기본 키 매핑
* 기본 키 매핑에는 크게 다음과 같은 어노테이션이 사용된다.
  1. @Id: 엔티티 클래스의 특정 필드가 기본 키로 사용됨을 명시한다.
  2. @GeneratedValue: 기본 키를 자동 생성하는 경우에 명시한다.
     * 기본 키 생성 전략을 명시하는 경우, `@GeneratedValue(strategy = GenerationType.AUTO)`와 같은 형태로 명시한다.
* 상술했듯, **기본 키를 직접 할당한 값으로 매핑하는 경우에는 @Id 어노테이션만을 명시해도 무방**하다.
  * 반면, **기본 키를 자동 생성하고자 하는 경우 @GeneratedValue 어노테이션을 반드시 명시하고 속성 값으로 자동 생성 전략을 명시**한다.
* 실무에서는 일반적으로 기본 키 자동 생성 전략을 주로 사용하며, 이 때 사용 가능한 전략은 다음과 같다.
  1. IDENTITY: MySQL에서 사용하며, 기본 키 생성 전략을 데이터베이스에 위임한다.
  2. SEQUENCE: Oracle에서 사용하며, 데이터베이스의 시퀀스 오브젝트를 사용한다.
     * 이 경우, @SequenceGenerator 어노테이션을 함께 명시할 수도 있다.
  3. TABLE: 모든 데이터베이스에서 사용이 가능하며, 키를 생성하기 위한 테이블을 사용한다.
     * 이 경우, @TableGenerator 어노테이션을 함께 명시해야 한다.
  4. AUTO: **기본으로 적용되는 값이며, 데이터베이스 방언에 따라 상술한 세 전략 중 하나를 자동으로 지정**한다.
     * 예를 들어 Oracle 데이터베이스에 연결했다면 SEQUENCE 전략이 사용되겠지만, **반드시 직접 확인한 후에 사용을 고려하는 것이 바람직**하다.

### Identity 전략
* 해당 전략은 기본 키 생성을 데이터베이스에 위임하며, MySQL의 AUTO_INCREMENT를 예로 들 수 있다.
  * 해당 전략은 주로 MySQL, PostgreSQL, SQL Server 등에서 사용된다.
* **JPA는 일반적으로 트랜잭션 커밋 시점에 INSERT 쿼리를 요청하므로, AI 전략의 경우 반드시 데이터베이스에 데이터를 영속화한 후에 기본 키를 알 수 있다**.
  * 때문에 **해당 전략은 em.persist 시점에 즉시 INSERT 쿼리를 요청한 후에 데이터베이스로부터 식별자를 조회**한다.
  * 이는 **영속성 컨텍스트에서 엔티티를 관리하기 위한 키 값으로 식별자가 필수적이기 때문**이다.
  * 이러한 측면에서 JPA가 제공하는 버퍼링의 이점을 제공받지 못하는 것 같지만, 실제로는 버퍼링으로 인한 성능 향상이 크지 않다.
* AI 전략을 사용하는 경우, int와 같은 원시 타입 대신 Integer와 같은 래퍼 클래스를 사용해야 한다.
  * 그러나 **int는 최대 약 10억까지의 값까지만을 적용할 수 있으므로, 적어도 Long 타입을 사용하는 것이 권장**된다.
  * 또한, 애플리케이션 전체적으로 봤을 때 Integer 타입 대신 Long 타입을 사용하는 것은 사실상 영향을 주지 않는다.

### Sequence 전략
* Oracle 데이터베이스에서 사용되는 전략이며, 내부적으로 시퀀스 오브젝트를 만들어 자동으로 값을 할당해나간다.
  * 이 때, 기본적으로 하이버네이트는 hibernate_sequence 라는 이름의 시퀀스를 사용한다.
  * 이를 변경하고자 하는 경우 @SequenceGenerator 어노테이션을 사용할 수 있다.
* **@SequenceGenerator 어노테이션을 통해 별도의 시퀀스 테이블을 사용하는 경우, 반드시 allocationSize 속성을 명시하여 성능을 최적화**해야 한다.
  * **영속성 컨텍스트에서 관리하기 위해서 기본 키는 필수이므로, JPA는 해당 전략에서 우선 시퀀스 번호를 가져와 알고 있을 필요**가 있다.
  * 해당 전략은 시퀀스 번호를 데이터베이스로부터 조회하여 사용하므로, Identity 전략과 달리 SQL 쓰기 지연의 이점을 누릴 수 있다.
  * 그러나 매 영속화 시도 시마다 `call next value for {시퀀스_테이블_명}`을 데이터베이스로부터 조회하여 적용하는 것은 성능 상 손해가 발생할 수 있다.
  * 때문에 **JPA는 allocationSize 속성을 제공하며, 이를 통해 우선 여러 개의 시퀀스 번호를 가져와 네트워크 IO를 최소화**한다. 

### Table 전략
* 해당 전략은 기본 키를 자동 생성하기 위해 별도의 전용 테이블을 생성하며, Oracle의 데이터베이스 시퀀스 개념을 흉내낸다.
  * 때문에 **모든 데이터베이스 종류에 유연하게 적용이 가능하지만, 상대적으로 성능이 떨어진다는 단점 역시 존재**한다.
  * 이는 시퀀스 등의 기능은 모두 성능 최적화가 되어 있으나, 해당 전략은 그렇지 못하기 때문이다.
* 또한, 해당 전략 역시 성능 최적화를 위해 allocationSize 속성을 반드시 조정해주어야 한다.
* 그러나 **데이터베이스마다 관례적으로 사용되는 전략이 존재하므로, 해당 전략은 운영 환경에서는 잘 사용되지 않는다**.

### 권장되는 식별자 설정 전략
* **데이터베이스의 기본 키는 반드시 NOT NULL, UQ로 설정하되 변하지 않는 값을 사용**하도록 한다.
  * 사실 애플리케이션의 생명 주기 동안 절대 변하지 않는 기본 키를 찾기는 매우 어렵다. 
* 그러나 이러한 **조건을 미래에까지 반드시 충족하는 자연 키는 찾기 어려우므로, 대체 키를 사용하는 것이 바람직**하다.
  * 자연 키란 비즈니스적으로 의미가 있는 전화 번호나 주민 등록 번호 등의 값을 의미한다.
  * 또한, 대체 키는 비즈니스와 전혀 관계가 없는 랜덤한 값을 의미한다.
* 예를 들어, Long 형 + 대체 키 + 키 생성 전략을 조합하여 사용할 수 있다.
  * 또는 **어떠한 전략을 사용하더라도 무방하지만, 절대로 비즈니스와 관련된 값을 기본 키로 설정하지는 않는 것이 바람직**하다.

### 엔티티 클래스 작성 팁
* 가능하다면 데이터베이스 구조를 알기 위해 데이터베이스를 열 필요조차 없이, 엔티티 클래스 내에서 많은 정보를 알 수 있게 하는 것이 바람직하다.
  * 예를 들어, **컬럼 길이 또는 테이블 UQ 제약 조건 등은 가능한 한 엔티티 클래스에 명시되는 것이 한 눈에 보인다**.
  * 심지어는 영속화될 모든 필드에 대해 `@Column(name = "컬럼명")`을 명시하는 경우도 있으나, 이는 개발자의 성향에 따라 다르다.
* 또한, 특정한 두 개의 엔티티 사이에 연관 관게가 있는 경우에는 다음과 같은 방법으로 관계를 표현할 수 있다.
  1. 서로의 식별자를 자신의 필드로 갖는다.
  2. 서로의 엔티티 객체를 자신의 필드로 갖는다.
* 이 중, 식별자를 필드로 갖는 방식은 반드시 데이터베이스 조회 쿼리를 추가로 요청하여 상대 엔티티의 정보를 알아내야만 하는 문제가 있다.
  * 즉, 객체지향적이라기보다는 데이터베이스 의존적인 개발 방식이며 객체 그래프를 활용한 참조도 불가능하다.
* 따라서 **실무에서 JPA를 사용하는 경우, 연관 관계를 Java의 참조 그래프로 표현하는 것이 바람직**하다.
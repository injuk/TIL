# Basics
## 2022-07-14 Thu

### 엔티티 매핑
* 엔티티의 매핑은 JPA에서 가장 중요한 두 가지 중 하나이다.
  * 예를 들어, 또 다른 중요한 개념인 영속성 컨텍스트는 JPA 내부적인 동작 원리를 강조한다.
  * 반면 **엔티티 매핑은 설계적인 측면을 강조하며, 객체와 관계형 데이터베이스를 어떻게 매핑하여 사용할지와 같은 정적인 측면을 의미**한다.
* 엔티티 매핑은 주로 어노테이션을 명시하여 진행하며, 다음과 같은 매핑을 사용할 수 있다.
  1. 객체와 테이블 간의 매핑: @Entity, @Table
  2. 필드와 컬럼 간의 매핑: @Column
  3. 기본 키 매핑: @Id
  4. 연관관계의 매핑: @ManyToOne, @JoinColumn

### @Entity
* 해덩 어노테이션이 명시된 클래스는 JPA가 관리하는 엔티티가 된다.
  * 따라서 **JPA를 통해 관리할 테이블과 매핑하는 클래스는 반드시 @Entity 어노테이션을 명시**해야 한다.
* **엔티티 클래스는 JPA가 관리하기 위해 반드시 public 또는 protected 접근 제어자로 정의된 기본 생성자를 가져야 한다**.
  * 또한, 엔티티 클래스는 final이거나 enum, interface, inner 클래스일 수 없다.
  * **엔티티 클래스를 통해 저장할 필드에는 final 키워드도 사용하지 않아야 한다**.
* 상술한 이유에서, @Entity 어노테이션이 명시된 클래스를 보면 다음과 같은 내용을 유추할 수 있다.
  1. 해당 클래스는 JPA에 의해 관리될 것이다.
  2. **해당 클래스는 실제 데이터베이스의 JPA가 관리하는 테이블과 매핑될 것**이다.
* 해당 어노테이션에는 `name` 속성을 명시하여 JPA에서 관리할 엔티티의 이름을 지정할 수 있으며, 기본적으로는 클래스의 이름을 그대로 사용한다.
  * **해당 속성은 JPA가 내부적으로 구분하는 이름을 의미하지만, 굳이 name 속성을 통해 모든 엔티티 객체의 이름을 정의할 필요는 없다**.
  * 즉, 다른 패키지에 동일한 클래스 이름이 존재하는 경우가 아니라면 기본 값을 사용하는 것이 바람직하다.

### @Table
* 해당 어노테이션은 엔티티 객체의 이름과 다른 이름을 갖는 테이블과 매핑하고 싶은 경우에 사용한다.
* 예를 들어, 회사의 규정상 엔티티의 이름과 동일한 테이블이 아닌 축약어를 사용해야하는 경우에 `@Table(name = "테이블명")` 형태로 명시할 수 있다.
  * 이 경우, 해당 엔티티와 관련된 모든 쿼리는 @Table 어노테이션의 `name` 속성에 명시된 값의 테이블을 대상으로 요청된다.

### 데이터베이스 스키마의 자동 생성
* **JPA는 매핑 정보만으로도 어떠한 테이블에 어떠한 쿼리를 요청해야할지 분석**할 수 있다.
  * 나아가, JPA는 애플리케이션 로딩 시점에 데이터베이스 테이블을 생성하는 기능까지도 지원한다.
  * 당연히 이러한 기능은 운영 상황에서는 사용을 지양해야 하지만, 개발 단계 또는 로컬 환경에서는 큰 도움을 줄 수 있다.
* 이렇듯 **JPA는 애플리케이션의 실행 시점에 DDL을 자동 생성하며, 테이블 중심의 개발 대신 객체 중심의 개발을 가능케** 한다.
  * 즉, 테이블을 우선 모두 정의한 후에 객체를 설계하는 기존 방식 대신 객체의 설계부터 집중할 수 있다.
  * 이 때, **JPA는 설정된 데이터베이스 방언을 활용하여 데이터베이스에 맞는 적절한 DDL을 생성**한다.
* 생성된 DDL은 운영 환경에서는 아예 사용하지 않거나, 참고 삼아 다듬은 후에 사용하는 것이 바람직하다.

### 데이터베이스 스키마 자동 생성 옵션
* persistence.xml의 `hibernate.hbm2ddl.auto` 속성을 통해 다음과 같은 데이터베이스 스키마 자동 생성 기능을 지원받을 수 있다.
  1. create: 기존 테이블을 DROP한 후에 다시 CREATE한다.
  2. create-drop: create와 같으나, 종료 시점에도 테이블을 DROP한다.
  3. update: 변경 분량만 반영하지만, 운영 환경에서는 절대 사용하지 않아야 한다.
  4. validate: 엔티티와 테이블이 정상적으로 매핑되었는지만을 확인한다.
  5. none: 아무 것도 사용하지 않는다.
* 예를 들어, create 속성은 애플리케이션 동작 시점에 엔티티가 매핑된 모든 클래스를 테이블로 매핑한다.
* update의 경우, 예를 들어 기존 테이블에 없던 컬럼을 추가하고 싶지만 DROP 대신 ALTER를 통해 테이블을 수정하고 싶은 경우에 사용할 수 있다.
  * 이 때, update 속성은 새로운 컬럼의 추가만을 지원한다.
  * 때문에 **엔티티의 속성이 제거되었더라도, 대응되는 테이블 컬럼을 제거하지는 않는다**.
  * 이는 개발자의 부주의로 테이블 컬럼을 제거하였을 때 크나큰 문제가 발생할 가능성이 있기 때문이다.
* 사실 none이라는 속성은 JPA 스펙 상 존재하지 않으며, 임의의 문자열을 적어도 똑같은 기능을 수행하지만 관례상 none으로 표기하곤 한다.

### 데이터베이스 스키마 자동 생성 기능의 주의사항
* 운영 환경에서는 절대로 create, create-drop, update 속성을 사용하지 않아야 한다.
  * 개발 초기 단계에서는 create 또는 update 속성을 활용해도 무방하다.
  * 테스트 서버에서는 update 또는 validate를 설정할 수 있다.
  * **스테이징과 운영 환경에서는 validate 또는 none을 사용**해야 한다.
* **운영 환경에 몇천만 건의 데이터가 저장되어 있는 경우, update 속성을 통해 자칫 ALTER 쿼리라도 요청했다간 락에 의해 시스템이 중단될 수도** 있다.
  * 이렇듯 애플리케이션 로딩 시점에 JPA가 알아서 ALTER 쿼리를 요청한다는 것 자체가 매우 위험하다.
* 그러나 **가장 이상적인 것은 개발자 자신이 직접 DDL을 정의하고, 개발 또는 테스트 환경에서 테스트를 진행하는 것**이다.
  * 이 과정에서 문제가 발생하지 않은 경우에만 운영 환경에 적용하거나 DBA에게 전달할 것을 검토할 수 있게 된다.

### DDL 제약 조건 추가하기
* @Column 어노테이션의 여러 속성을 통해 DDL에 제약 조건을 추가할 수도 있다.
  1. unique: 해당 컬럼이 유니크한가?
  2. length: 해당 컬럼의 최대 길이는 어느 정도인가?
* 특히, 이렇게 정의된 유니크 제약조건은 애플리케이션 자체보다는 데이터베이스에 영향을 준다.
  * 즉 **DDL 생성 기능은 DDL을 자동 생성할 때만 사용되며, JPA의 실행 로직에는 전혀 영향을 주지 않는다**.
* JPA가 실행될 때마다 런타임에 영향을 주지는 않으며, JPA는 오로지 개발자의 필요에 따라 DDL 생성 기능만을 제공한다.
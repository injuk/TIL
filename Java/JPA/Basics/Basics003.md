# Basics
## 2022-07-14 Thu

### 엔티티 매핑
* 엔티티의 매핑은 JPA에서 가장 중요한 두 가지 중 하나이다.
  * 예를 들어, 또 다른 중요한 개념인 영속성 컨텍스트는 JPA 내부적인 동작 원리를 강조한다.
  * 반면 **엔티티 매핑은 설계적인 측면을 강조하며, 객체와 관계형 데이터베이스를 어떻게 매핑하여 사용할지와 같은 정적인 측면을 의미**한다.
* 엔티티 매핑은 주로 어노테이션을 명시하여 진행하며, 다음과 같은 매핑을 사용할 수 있다.
  1. 객체와 테이블 간의 매핑: @Entity, @Table
  2. 필드와 컬럼 간의 매핑: @Column
  3. 기본 키 매핑: @Id
  4. 연관관계의 매핑: @ManyToOne, @JoinColumn

### @Entity
* 해덩 어노테이션이 명시된 클래스는 JPA가 관리하는 엔티티가 된다.
  * 따라서 **JPA를 통해 관리할 테이블과 매핑하는 클래스는 반드시 @Entity 어노테이션을 명시**해야 한다.
* **엔티티 클래스는 JPA가 관리하기 위해 반드시 public 또는 protected 접근 제어자로 정의된 기본 생성자를 가져야 한다**.
  * 또한, 엔티티 클래스는 final이거나 enum, interface, inner 클래스일 수 없다.
  * **엔티티 클래스를 통해 저장할 필드에는 final 키워드도 사용하지 않아야 한다**.
* 상술한 이유에서, @Entity 어노테이션이 명시된 클래스를 보면 다음과 같은 내용을 유추할 수 있다.
  1. 해당 클래스는 JPA에 의해 관리될 것이다.
  2. **해당 클래스는 실제 데이터베이스의 JPA가 관리하는 테이블과 매핑될 것**이다.
* 해당 어노테이션에는 `name` 속성을 명시하여 JPA에서 관리할 엔티티의 이름을 지정할 수 있으며, 기본적으로는 클래스의 이름을 그대로 사용한다.
  * **해당 속성은 JPA가 내부적으로 구분하는 이름을 의미하지만, 굳이 name 속성을 통해 모든 엔티티 객체의 이름을 정의할 필요는 없다**.
  * 즉, 다른 패키지에 동일한 클래스 이름이 존재하는 경우가 아니라면 기본 값을 사용하는 것이 바람직하다.

### @Table
* 해당 어노테이션은 엔티티 객체의 이름과 다른 이름을 갖는 테이블과 매핑하고 싶은 경우에 사용한다.
* 예를 들어, 회사의 규정상 엔티티의 이름과 동일한 테이블이 아닌 축약어를 사용해야하는 경우에 `@Table(name = "테이블명")` 형태로 명시할 수 있다.
  * 이 경우, 해당 엔티티와 관련된 모든 쿼리는 @Table 어노테이션의 `name` 속성에 명시된 값의 테이블을 대상으로 요청된다.

### 데이터베이스 스키마의 자동 생성
* **JPA는 매핑 정보만으로도 어떠한 테이블에 어떠한 쿼리를 요청해야할지 분석**할 수 있다.
  * 나아가, JPA는 애플리케이션 로딩 시점에 데이터베이스 테이블을 생성하는 기능까지도 지원한다.
  * 당연히 이러한 기능은 운영 상황에서는 사용을 지양해야 하지만, 개발 단계 또는 로컬 환경에서는 큰 도움을 줄 수 있다.
* 이렇듯 **JPA는 애플리케이션의 실행 시점에 DDL을 자동 생성하며, 테이블 중심의 개발 대신 객체 중심의 개발을 가능케** 한다.
  * 즉, 테이블을 우선 모두 정의한 후에 객체를 설계하는 기존 방식 대신 객체의 설계부터 집중할 수 있다.
  * 이 때, **JPA는 설정된 데이터베이스 방언을 활용하여 데이터베이스에 맞는 적절한 DDL을 생성**한다.
* 생성된 DDL은 운영 환경에서는 아예 사용하지 않거나, 참고 삼아 다듬은 후에 사용하는 것이 바람직하다.

### 데이터베이스 스키마 자동 생성 옵션
* persistence.xml의 `hibernate.hbm2ddl.auto` 속성을 통해 다음과 같은 데이터베이스 스키마 자동 생성 기능을 지원받을 수 있다.
  1. create: 기존 테이블을 DROP한 후에 다시 CREATE한다.
  2. create-drop: create와 같으나, 종료 시점에도 테이블을 DROP한다.
  3. update: 변경 분량만 반영하지만, 운영 환경에서는 절대 사용하지 않아야 한다.
  4. validate: 엔티티와 테이블이 정상적으로 매핑되었는지만을 확인한다.
  5. none: 아무 것도 사용하지 않는다.
* 예를 들어, create 속성은 애플리케이션 동작 시점에 엔티티가 매핑된 모든 클래스를 테이블로 매핑한다.
* update의 경우, 예를 들어 기존 테이블에 없던 컬럼을 추가하고 싶지만 DROP 대신 ALTER를 통해 테이블을 수정하고 싶은 경우에 사용할 수 있다.
  * 이 때, update 속성은 기존 데이터와 테이블을 삭제하지 않고 새로운 컬럼의 추가만을 지원한다.
  * 때문에 **엔티티의 속성이 제거되었더라도, 대응되는 테이블 컬럼을 제거하지는 않는다**.
  * 이는 개발자의 부주의로 테이블 컬럼을 제거하였을 때 크나큰 문제가 발생할 가능성이 있기 때문이다.
* 사실 none이라는 속성은 JPA 스펙 상 존재하지 않으며, 임의의 문자열을 적어도 똑같은 기능을 수행하지만 관례상 none으로 표기하곤 한다.

### 데이터베이스 스키마 자동 생성 기능의 주의사항
* 운영 환경에서는 절대로 create, create-drop, update 속성을 사용하지 않아야 한다.
  * 개발 초기 단계에서는 create 또는 update 속성을 활용해도 무방하다.
  * 테스트 서버에서는 update 또는 validate를 설정할 수 있다.
  * **스테이징과 운영 환경에서는 validate 또는 none을 사용**해야 한다.
* **운영 환경에 몇천만 건의 데이터가 저장되어 있는 경우, update 속성을 통해 자칫 ALTER 쿼리라도 요청했다간 락에 의해 시스템이 중단될 수도** 있다.
  * 이렇듯 애플리케이션 로딩 시점에 JPA가 알아서 ALTER 쿼리를 요청한다는 것 자체가 매우 위험하다.
* 그러나 **가장 이상적인 것은 개발자 자신이 직접 DDL을 정의하고, 개발 또는 테스트 환경에서 테스트를 진행하는 것**이다.
  * 이 과정에서 문제가 발생하지 않은 경우에만 운영 환경에 적용하거나 DBA에게 전달할 것을 검토할 수 있게 된다.

### DDL 제약 조건 추가하기
* @Column 어노테이션의 여러 속성을 통해 DDL에 제약 조건을 추가할 수도 있다.
  1. unique: 해당 컬럼이 유니크한가?
  2. length: 해당 컬럼의 최대 길이는 어느 정도인가?
* 특히, 이렇게 정의된 유니크 제약조건은 애플리케이션 자체보다는 데이터베이스에 영향을 준다.
  * 즉 **DDL 생성 기능은 DDL을 자동 생성할 때만 사용되며, JPA의 실행 로직에는 전혀 영향을 주지 않는다**.
* JPA가 실행될 때마다 런타임에 영향을 주지는 않으며, JPA는 오로지 개발자의 필요에 따라 DDL 생성 기능만을 제공한다.

## 2022-07-15 Fri
### 필드와 컬럼 매핑 
* JPA에서 엔티티와 테이블을 매핑하는 것은 크게 어려울 일이 없는 작업이지만, 필드와 컬럼을 매핑하는 과정에서는 많은 작업을 해야할 수도 있다.
* 예를 들어, 컬럼 매핑 과정에서 다음과 같은 어노테이션을 활용할 수 있다.
  1. @Column(name = ""): 객체 필드 명과 테이블 컬럼명이 다른 경우, 테이블 컬럼명을 명시한다.
  2. @Enumerated: Java에서는 enum타입을 유용하게 사용하지만 데이터베이스에는 완벽히 매핑되는 타입이 없다.
     * 이러한 불일치성을 해결하기 위해 해당 어노테이션을 통해 데이터베이스에 저장될 타입을 명시할 수 있다.
  3. @Temporal: Java는 일반적으로 날짜와 시간을 모두 표현하는 Date 타입을 사용하지만, 데이터베이스는 날짜와 시간, 날짜 + 시간을 모두 사용한다.
     * 이러한 불일치성을 해결하기 위해 데이터베이스에 저장될 타입을 명시할 수 있다.
  4. @Lob: 해당 어노테이션은 VARCHAR와 같은 형태만으로는 해결할 수 없는 큰 데이터를 표현하기 위해 명시한다.
     * String 형 필드에 @Lob 어노테이션을 명시한 경우, 기본적으로 컬럼은 clob으로 매핑된다.
  5. @Transient: 특정 필드는 데이터베이스의 컬럼으로 매핑하고 싶지 않은 경우에 명시한다.

### @Column
* 해당 어노테이션은 필드와 컬럼을 매핑하는 과정에서 가장 자주 사용되며, 다음과 같은 속성을 가질 수 있다.
  1. name: 필드와 매핑될 실제 테이블의 컬럼명을 명시한다.
  2. insertable, updatable: 등록 또는 변경 가능 여부를 boolean 형으로 명시한다.
     * 기본적으로 모두 true로 설정되어 있으며, 데이터베이스를 직접 고치지 않는 이상 코드 상에서의 등록과 변경을 방지할 수 있다.
  3. nullable: DDL 생성시에 사용되며, 해당 컬럼의 null 가능성을 명시한다.
  4. unique: DDL 생성시에 사용되며, 해당 컬럼의 unique 가능성을 명시한다.
     * 그러나 **해당 속성으로 명시된 UQ 제약 조건은 이름을 알아보기 어려운 난수형태로 명명되므로, 잘 사용되지 않는 옵션**이다.
     * 또한 복합 유니크 조건을 명시할 수도 없으므로, 일반적으로는 엔티티 자체에 @Table(uniqueConstraints) 어노테이션을 명시하여 사용한다.
  5. columnDefinition: 데이터베이스 컬럼에 사용될 정보를 직접 명시할 수 있다.
  6. length: String 타입에만 명시할 수 있으며, 문자 길이 제약조건을 명시하기 위해 사용할 수 있다.
  7. precision, scale: BigDecimal 또는 BigInteger 타입에만 명시할 수 있다.
     * precision: 소수점을 포함하는 전체 자리수를 의미한다.
     * scale: 소수의 자리수를 의미한다.
     * 두 타입 모두 double, float 타입에는 적용되지 않으며 매우 정밀한 소수를 다루는 경우에만 사용된다.
  
### @Enumerated
* 해당 어노테이션은 Java의 enum 타입을 데이터베이스 컬럼에 매핑하기 위해 사용할 수 있다.
* 이 때, 어노테이션의 속성으로 다음과 같은 타입을 명시할 수 있다.
  1. EnumType.ORDINAL: enum 필드의 순서를 데이터베이스에 저장한다.
  2. EnumType.STRING: enum 필드의 이름을 데이터베이스에 저장한다.
* 이 때, **기본값은 EnumType.ORDINAL로 적용되지만 절대 ORDINAL을 사용하지 않아야 한다**.
  * **ORDINAL 설정은 추후 enum이 수정된 경우 이를 데이터베이스에 이미 영속화된 데이터들에 반영하기가 매우 어렵다**.
* 따라서 데이터베이스에 저장되는 몇 글자를 아끼기보다는 큰 장애를 방지하기 위해 애초에 STRING 속성을 사용하는 것이 바람직하다.
  * 이 경우, 추후 새로운 enum이 추가되더라도 순서에 의한 문제가 발생하지 않는다.

### @Temporal
* Date, Calendar 등의 Java 날짜 타입을 데이터베이스에 명시하기 위해 사용한다.
* 이 때, 해당 어노테이션의 속성으로는 다음과 같은 타입을 사용할 수 있다.
  1. TemporalType.DATE: 날짜만을 명시하며, 데이터베이스의 date 타입과 매핑된다.
  2. TemporalType.TIME: 시간만을 명시하며, 데이터베이스의 time 타입과 매핑된다.
  3. TemporalType.TIMESTAMP: 날짜와 시간을 모두 명시하며, 데이터베이스의 timestamp 타입과 매핑된다.
* **최근에 주로 사용되는 LocalDate, LocaleDateTime을 사용하는 경우에는 최신 하이버네이트가 자체적으로 지원할 수 있으므로 생략이 가능**하다.
  * 최신 하이버네이트는 해당 어노테이션이 명시되어 있지 않더라도 타입만으로 추론이 가능하다.

### @Lob
* 데이터베이스의 BLOB, CLOB과 매핑하기 위해 명시하는 어노테이션이며, 상술한 어노테이션들과 달리 별도의 속성을 제공하지 않는다.
  * 대신 매핑하는 필드의 타입에 따라 문자의 경우에는 CLOB, 나머지는 BLOB으로 다음과 같이 매핑된다.
    1. CLOB: String, char[], java.sql.CLOB 타입의 객체들
    2. BLOB: byte[], java.sql.BLOB 타입의 객체들

### @Transient
* 필드를 매핑하지 않기 위해 명시하는 어노테이션이며, 데이터베이스에 저장도 되지 않고 조회도 하지 않는다.
* 주로 비즈니스 로직 상 메모리 상에서 임시로 값을 보관해두고자 하는 필드에 적용한다. 
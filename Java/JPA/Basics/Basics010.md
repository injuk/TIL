# Basics
## 2022-07-31 Sun

### JPQL 경로 표현식
* **JPQL에서의 경로 표현식이란, `m.name`과 같이 참조 연산자를 활용하여 객체를 탐색하는 것**을 말한다.
* 이 때, 경로 표현식은 다음과 같이 구분할 수 있다.
  1. 상태 필드: 단순히 값을 저장하는 필드이다.
  2. 단일 값 연관 필드: 연관 관계를 위한 필드이며, @ManyToOne과 같이 대상이 엔티티인 경우에 사용한다.
  3. 컬렉션 값 연관 필드: 연관 관계를 위한 필드이며, @OneToMany와 같이 대상이 컬렉션인 경우에 사용한다.
* **상술한 세 방식은 어떤 종류를 사용하느냐에 따라 내부적인 동작 방식이 달라지므로, 반드시 이를 구분할 수 있어야** 한다.

### 경로 표현식의 특징
* 상태 필드의 경우, 경로 탐색의 끝에 해당하므로, 더 이상 탐색하지 않는다.
  * 예를 들어, `m.name`으로 탐색은 종료되며 name 뒤에 참조 연산자를 추가하여 더 탐색해나갈 수는 없다.
* 단일 값 연관 경로의 경우, **암시적인 inner 조인이 발생**하며, 추가적인 탐색이 가능하다.
  * 예를 들어, 탐색 대상이 엔티티이므로 `m.team.name`과 같이 추가 탐색이 가능하다.
  * 이렇듯 **객체에서는 참조 연산자를 통해 간단한 탐색이 가능하지만, 실제 데이터베이스에서는 반드시 조인이 발생한다는 사실을 기억**해야 한다.
  * 실무에서는 조인 자체가 성능에 지대한 영향을 주며, 반드시 쿼리 튜닝이 필요한 항목이므로 암시적인 조인이 발생하는 해당 방식은 사용에 주의를 기울여야 한다.
  * **이상적인 것은 암시적인 조인이 발생하지 않도록 하는 것이며, 가능한 한 JPQL과 SQL의 형태를 맞춰주는 것이 튜닝에 유리**하다.
* 컬렉션 값 연관 경로의 경우, **암시적인 inner 조인이 발생**하지만 참조 연산자를 활용하는 추가적인 탐색은 불가능하다.
  * 반면, `t.members.size`와 같이 컬렉션 자체의 크기를 구하는 것은 예외적으로 허용된다.
  * 요구 사항 **구현 과정에서 반드시 컬렉션 요소의 속성에 접근하고자 하는 경우, FROM 절에서 명시적으로 조인하여 별칭을 통해 탐색이 가능**하다.
* 상술했듯, **실무에서는 위험성이 큰 암시적인 조인이 발생하는 방식을 사용하지 말고 필요한 경우에 명시적으로 조인하는 방식이 권장**된다.
  * 때문에 JPQL과 SQL의 형태를 맞춰주는 것은 쿼리 튜닝이 쉬워진다는 점에서 중요하다.

### 명시적 조인과 암시적 조인
* 명시적인 조인은 말 그대로 JOIN 키워드를 직접 명시하는 조인을 의미한다.
* 반면, 암시적인 조인의 경우 경로 표현식에 의해 암시적인 SQL inner 조인이 발생하는 경우를 말한다.
  * 이 때, 경로 표현식에 의한 조인은 inner 조인만 가능하다.
  * 경로 표현식에 있어 암시적인 outer 조인은 불가능하며, 필요한 경우에는 반드시 명시적인 조인을 사용해야 한다.

### 경로 탐색을 사용하는 암시적인 조인 시 주의사항
* 경로 탐색 과정에서 발생한 암시적인 조인은 항상 inner 조인이다.
* 컬렉션 값 연관 필드의 경우 경로 탐색이 종료되며, 추가 탐색을 원하는 경우에는 명시적인 조인을 통해 별칭을 얻어야 한다.
* **경로 탐색은 SELECT, WHERE 절에서만 사용하지만 암시적인 조인으로 인해 SQL의 FROM, JOIN 절에 영향**을 준다.
* **실무에서는 가능하다면 암시적 조인보다는 명시적인 조인을 사용**해야 한다.
  * **조인은 SQL 튜닝에 있어 매우 중요한 포인트이며, 암시적인 조인을 사용하는 경우 조인이 발생하는 시점을 코드 상에서 한 눈에 파악하기 어렵다**.

### 페치 조인이란?
* **페치 조인이란, SQL이 제공하는 조인의 일종이 아니며 JPQL이 성능 최적화를 위해 제공하는 기능**이다.
  * **기능상으로는 연관된 엔티티 또는 컬렉션을 SQL 한 번에 함께 조회하는 기능을 의미**한다.
  * 페치 조인을 이해하지 못하고서는 사실상 실무에서 JPA를 사용할 수 없다.
* **페치 조인은 `[ left [outer] | inner ] join fetch 경로`의 형태로 사용**한다.

### 엔티티 페치 조인
* 회원 엔티티를 조회할 때 연관된 모든 팀 엔티티를 함께 조회하는 페치 조인 쿼리는 다음과 같다.
  * 아래의 코드에서, select 절에서 t에 대한 내용을 작성하지 않는 것을 확인할 수 있다.
```
select m from Member m join fetch m.team
```
* 반면, 위 쿼리는 SQL로는 다음과 같이 번역된다.
```
SELECT M.*, T.* FROM MEMBER M INNER JOIN TEAM T ON M.TEAM_ID=T.ID
```
* **페치 조인을 활용하면 JPQL 쿼리를 통해 어떤 형태의 객체 그래프를 조회할지 명시적이고도 동적인 타이밍에 정의**할 수 있다.
* 예를 들어, 회원과 팀이 다음과 같은 연관 관계를 맺는 경우를 가정한다.
  1. 회원과 팀은 N:1 관계를 갖는다.
  2. 회원 1과 회원 2는 팀 A에, 회원 3은 팀 B에, 회원 4는 팀에 소속되지 않았고 팀 C 역시 회원이 가입되지 않았다.
  3. 이 경우, fetch join의 결과로 반환되는 데이터는 연관 관계를 맺고 있는 회원 1, 회원 2, 회원 3이 각각 팀 A, 팀 B에 포함되었다는 정보가 조회된다.
  4. 또한, **fetch join 조회 이후 회원 1, 회원 2, 회원 3, 팀 A, 팀 B는 영속성 컨텍스트에 의해 관리**된다.
* **fetch join을 사용하지 않고 지연 로딩이 적용된 회원을 조회하는 경우, 회원의 팀 필드는 프록시 객체로 반환되므로 팀에 접근할 때마다 쿼리가 요청**된다.
```
select m from Member m
```
* 상술한 시나리오의 경우, 회원 1의 팀 정보에 접근할 때 팀 A의 정보는 데이터베이스에 쿼리를 요청하여 조회한다.
  * 그 후, 회원 2의 팀 정보인 팀 A는 1차 캐시의 정보를 그대로 반환한다.
  * 회원 3의 팀은 1차 캐시에 존재하지 않으므로, 다시 데이터베이스에 쿼리를 요청하여 조회한다.
  * **회원의 모든 소속 팀이 다른 경우, 쿼리는 최초 전체 멤버를 조회하는 1번에 더해 회원 수마다 추가로 호출되는 N + 1 문제가 발생**한다.
  * N + 1 문제란, 최초 1회의 쿼리에서 얻은 N개의 결과만큼 추가 쿼리를 요청하는 이슈를 말한다.
* 중요한 것은, **즉시 로딩과 지연 로딩 모두 N + 1문제로부터 완전히 자유로울 수 없다는 사실**이다.
  * 이를 **원천적으로 해결하는 방법은 사실상 fetch join 뿐**이다.
```
select m from Member m join fetch m.team
```
* 상술한 JPQL을 사용하는 경우, 지연 로딩과는 달리 결과에 포함된 회원과 팀은 모두 실제 엔티티가 조회되어 영속성 컨텍스트에 의해 관리된다.
  * **페치 조인은 기본적으로 inner join으로 적용되며, `left join fetch` 와 같은 형태로 작성하는 경우에야 outer join이 적용**된다.
  * 이러한 특징으로 실무에서 페치 조인은 필수적이며, 그 중에서도 주로 조회 목적으로 사용되곤 한다.
* **지연 로딩이 적용된 연관 관계에서도 JPQL에 join fetch를 명시했다면, 항상 페치 조인이 우선 적용**된다.

### 컬렉션 페치 조인
* @ManyToOne 관계에서 사용된 상술한 페치 조인과 달리, 컬렉션 페치 조인은 @OneToMany 관계에서 사용된다.
  * 상술한 시나리오의 경우, 회원이 아닌 팀 입장에서 회원을 페치 조인하는 경우에 해당한다.
* 그러나 **컬렉션 페치 조인을 사용하는 경우, 결과가 부풀려질 수 있다는 사실에 주의**해야 한다.
  * 다시 상술한 시나리오에서, 팀 A에는 회원 1과 회원 2가 소속된다.
  * 이 경우, 데이터베이스에 조인 쿼리 요청시 결과로 반환되는 팀 A의 row는 각각의 회원 정보로 인해 2개가 된다.
  * **JPQL 역시 내부적으로는 데이터베이스에 쿼리를 요청하는 것에 지나지 않으므로, 팀 A에 대한 조회 결과는 회원 수만큼 발생**하게 된다.
* **JPA 입장에서는 컬렉션에 중복된 데이터가 존재하는 것을 어떻게 처리할지 결정하지 않으며, 이에 대한 처리를 개발자에게 위임**한다.
  * JPA가 조회된 결과를 분석하여 중복된 데이터를 마음대로 제거할 수도 있으나, 어떤 개발자는 오히려 중복된 데이터가 포함된 컬렉션을 원할 수도 있다.
  * 또한, 데이터베이스로부터 조회된 데이터를 그대로 반환하는 것이 마치 SQL을 통해 데이터베이스로부터 직접 조회한 것과 같은 효과를 준다.
  * 이러한 이유에서 JPA는 JPQL로 조회된 결과를 후처리하지 않으며, 그대로 반환하게 된다.
* 페치 조인으로 조회한 결과는 식별자에 따라 영속성 컨텍스트로 관리되므로, 팀 A라는 엔티티는 영속성 컨텍스트에 하나만 관리된다.
  * 그러나 **페치 조인의 결과로 반환되는 컬렉션에는 해당 팀 A를 참조하는 요소가 팀 A에 포함된 회원 수만큼 존재**하게 된다.
* 이렇듯 **페치 조인으로 조회된 결과가 부풀려지는 것은 1:N 관계에서만 발생할 수 있으며, N:1 관계에서는 발생하지 않는다**.
  * N:1 관계에서는 조건에 따라 오히려 데이터가 줄어들 수 있다.

### 컬렉션으로부터 중복 제거하기
* **컬렉션 페치 조인의 결과로 중복이 발생할 수 있다는 사실은 이해하지만, 그럼에도 중복을 모두 제거하고 싶다면 DISTINCT를 활용**할 수 있다.
```
select distinct t from Team t join fetch t.members
```
* SQL의 DISTINCT는 중복 결과를 제거하는 의미를 갖지만, JPQL은 다음과 같은 기능을 제공한다.
  1. SQL에 DISTINCT를 추가한다.
  2. **애플리케이션으로부터 엔티티의 중복을 제거**한다.
* 이는 SQL의 DISTINCT 만으로는 모든 중복을 제거할 수 없으므로, JPA는 데이터베이스가 아닌 애플리케이션 단위에서 중복을 제거하도록 지원한다.
  * SQL의 경우, 중복된 데이터의 모든 컬럼의 값이 같아야 중복된 값으로 판단하여 DISTINCT의 제거 대상이 된다.
  * 정확히는 **데이터베이스에 조회를 요청할 때 DISTINCT를 추가하고, 결과를 애플리케이션 단위에서 받아 중복된 엔티티를 모두 제거하는 식으로 동작**한다.
* **JPA가 SQL을 통해 조회한 데이터를 수신한 경우, DISTINCT 키워드가 포함되어 있었다면 결과로부터 동일한 식별자를 갖는 모든 엔티티를 찾아 제거**한다.

### 페치 조인과 일반 조인의 차이점
* **일반 조인의 경우, 실행시 연관된 엔티티를 함께 조회하지는 않는다**.
* **JPQL은 결과를 반환할 때 연관 관계를 고려하지 않으며, 단지 SELECT 절에 지정된 엔티티만을 조회**한다.
  * 예를 들어, 상술한 시나리오 중 팀을 기준으로 조회하는 경우 팀 엔티티만 조회하고 회원 엔티티는 실제로 조회하지 않는다.
  * 때문에 팀에 소속된 회원의 정보를 조회하는 시점에 데이터베이스 쿼리를 요청하여 필요한 데이터를 가져오게 된다.
* **페치 조인의 경우, 연관된 엔티티를 함께 조회하는 즉시 로딩이 적용**된다.
  * 정확히는 **페치 조인은 객체 그래프를 SQL 한 번에 모두 조회하는 개념으로 이해**할 수 있다.
  * **대부분의 N + 1 문제는 사실상 페치 조인을 통해 모두 해결한다고 이해**할 수 있다.
# Basics
## 2022-07-31 Sun

### JPQL 경로 표현식
* **JPQL에서의 경로 표현식이란, `m.name`과 같이 참조 연산자를 활용하여 객체를 탐색하는 것**을 말한다.
* 이 때, 경로 표현식은 다음과 같이 구분할 수 있다.
  1. 상태 필드: 단순히 값을 저장하는 필드이다.
  2. 단일 값 연관 필드: 연관 관계를 위한 필드이며, @ManyToOne과 같이 대상이 엔티티인 경우에 사용한다.
  3. 컬렉션 값 연관 필드: 연관 관계를 위한 필드이며, @OneToMany와 같이 대상이 컬렉션인 경우에 사용한다.
* **상술한 세 방식은 어떤 종류를 사용하느냐에 따라 내부적인 동작 방식이 달라지므로, 반드시 이를 구분할 수 있어야** 한다.

### 경로 표현식의 특징
* 상태 필드의 경우, 경로 탐색의 끝에 해당하므로, 더 이상 탐색하지 않는다.
  * 예를 들어, `m.name`으로 탐색은 종료되며 name 뒤에 참조 연산자를 추가하여 더 탐색해나갈 수는 없다.
* 단일 값 연관 경로의 경우, **암시적인 inner 조인이 발생**하며, 추가적인 탐색이 가능하다.
  * 예를 들어, 탐색 대상이 엔티티이므로 `m.team.name`과 같이 추가 탐색이 가능하다.
  * 이렇듯 **객체에서는 참조 연산자를 통해 간단한 탐색이 가능하지만, 실제 데이터베이스에서는 반드시 조인이 발생한다는 사실을 기억**해야 한다.
  * 실무에서는 조인 자체가 성능에 지대한 영향을 주며, 반드시 쿼리 튜닝이 필요한 항목이므로 암시적인 조인이 발생하는 해당 방식은 사용에 주의를 기울여야 한다.
  * **이상적인 것은 암시적인 조인이 발생하지 않도록 하는 것이며, 가능한 한 JPQL과 SQL의 형태를 맞춰주는 것이 튜닝에 유리**하다.
* 컬렉션 값 연관 경로의 경우, **암시적인 inner 조인이 발생**하지만 참조 연산자를 활용하는 추가적인 탐색은 불가능하다.
  * 반면, `t.members.size`와 같이 컬렉션 자체의 크기를 구하는 것은 예외적으로 허용된다.
  * 요구 사항 **구현 과정에서 반드시 컬렉션 요소의 속성에 접근하고자 하는 경우, FROM 절에서 명시적으로 조인하여 별칭을 통해 탐색이 가능**하다.
* 상술했듯, **실무에서는 위험성이 큰 암시적인 조인이 발생하는 방식을 사용하지 말고 필요한 경우에 명시적으로 조인하는 방식이 권장**된다.
  * 때문에 JPQL과 SQL의 형태를 맞춰주는 것은 쿼리 튜닝이 쉬워진다는 점에서 중요하다.

### 명시적 조인과 암시적 조인
* 명시적인 조인은 말 그대로 JOIN 키워드를 직접 명시하는 조인을 의미한다.
* 반면, 암시적인 조인의 경우 경로 표현식에 의해 암시적인 SQL inner 조인이 발생하는 경우를 말한다.
  * 이 때, 경로 표현식에 의한 조인은 inner 조인만 가능하다.
  * 경로 표현식에 있어 암시적인 outer 조인은 불가능하며, 필요한 경우에는 반드시 명시적인 조인을 사용해야 한다.

### 경로 탐색을 사용하는 암시적인 조인 시 주의사항
* 경로 탐색 과정에서 발생한 암시적인 조인은 항상 inner 조인이다.
* 컬렉션 값 연관 필드의 경우 경로 탐색이 종료되며, 추가 탐색을 원하는 경우에는 명시적인 조인을 통해 별칭을 얻어야 한다.
* **경로 탐색은 SELECT, WHERE 절에서만 사용하지만 암시적인 조인으로 인해 SQL의 FROM, JOIN 절에 영향**을 준다.
* **실무에서는 가능하다면 암시적 조인보다는 명시적인 조인을 사용**해야 한다.
  * **조인은 SQL 튜닝에 있어 매우 중요한 포인트이며, 암시적인 조인을 사용하는 경우 조인이 발생하는 시점을 코드 상에서 한 눈에 파악하기 어렵다**.

### 페치 조인이란?
* **페치 조인이란, SQL이 제공하는 조인의 일종이 아니며 JPQL이 성능 최적화를 위해 제공하는 기능**이다.
  * **기능상으로는 연관된 엔티티 또는 컬렉션을 SQL 한 번에 함께 조회하는 기능을 의미**한다.
  * 페치 조인을 이해하지 못하고서는 사실상 실무에서 JPA를 사용할 수 없다.
* **페치 조인은 `[ left [outer] | inner ] join fetch 경로`의 형태로 사용**한다.

### 엔티티 페치 조인
* 회원 엔티티를 조회할 때 연관된 모든 팀 엔티티를 함께 조회하는 페치 조인 쿼리는 다음과 같다.
  * 아래의 코드에서, select 절에서 t에 대한 내용을 작성하지 않는 것을 확인할 수 있다.
```
select m from Member m join fetch m.team
```
* 반면, 위 쿼리는 SQL로는 다음과 같이 번역된다.
```
SELECT M.*, T.* FROM MEMBER M INNER JOIN TEAM T ON M.TEAM_ID=T.ID
```
* **페치 조인을 활용하면 JPQL 쿼리를 통해 어떤 형태의 객체 그래프를 조회할지 명시적이고도 동적인 타이밍에 정의**할 수 있다.
* 예를 들어, 회원과 팀이 다음과 같은 연관 관계를 맺는 경우를 가정한다.
  1. 회원과 팀은 N:1 관계를 갖는다.
  2. 회원 1과 회원 2는 팀 A에, 회원 3은 팀 B에, 회원 4는 팀에 소속되지 않았고 팀 C 역시 회원이 가입되지 않았다.
  3. 이 경우, fetch join의 결과로 반환되는 데이터는 연관 관계를 맺고 있는 회원 1, 회원 2, 회원 3이 각각 팀 A, 팀 B에 포함되었다는 정보가 조회된다.
  4. 또한, **fetch join 조회 이후 회원 1, 회원 2, 회원 3, 팀 A, 팀 B는 영속성 컨텍스트에 의해 관리**된다.
* **fetch join을 사용하지 않고 지연 로딩이 적용된 회원을 조회하는 경우, 회원의 팀 필드는 프록시 객체로 반환되므로 팀에 접근할 때마다 쿼리가 요청**된다.
```
select m from Member m
```
* 상술한 시나리오의 경우, 회원 1의 팀 정보에 접근할 때 팀 A의 정보는 데이터베이스에 쿼리를 요청하여 조회한다.
  * 그 후, 회원 2의 팀 정보인 팀 A는 1차 캐시의 정보를 그대로 반환한다.
  * 회원 3의 팀은 1차 캐시에 존재하지 않으므로, 다시 데이터베이스에 쿼리를 요청하여 조회한다.
  * **회원의 모든 소속 팀이 다른 경우, 쿼리는 최초 전체 멤버를 조회하는 1번에 더해 회원 수마다 추가로 호출되는 N + 1 문제가 발생**한다.
  * N + 1 문제란, 최초 1회의 쿼리에서 얻은 N개의 결과만큼 추가 쿼리를 요청하는 이슈를 말한다.
* 중요한 것은, **즉시 로딩과 지연 로딩 모두 N + 1문제로부터 완전히 자유로울 수 없다는 사실**이다.
  * 이를 **원천적으로 해결하는 방법은 사실상 fetch join 뿐**이다.
```
select m from Member m join fetch m.team
```
* 상술한 JPQL을 사용하는 경우, 지연 로딩과는 달리 결과에 포함된 회원과 팀은 모두 실제 엔티티가 조회되어 영속성 컨텍스트에 의해 관리된다.
  * **페치 조인은 기본적으로 inner join으로 적용되며, `left join fetch` 와 같은 형태로 작성하는 경우에야 outer join이 적용**된다.
  * 이러한 특징으로 실무에서 페치 조인은 필수적이며, 그 중에서도 주로 조회 목적으로 사용되곤 한다.
* **지연 로딩이 적용된 연관 관계에서도 JPQL에 join fetch를 명시했다면, 항상 페치 조인이 우선 적용**된다.

### 컬렉션 페치 조인
* @ManyToOne 관계에서 사용된 상술한 페치 조인과 달리, 컬렉션 페치 조인은 @OneToMany 관계에서 사용된다.
  * 상술한 시나리오의 경우, 회원이 아닌 팀 입장에서 회원을 페치 조인하는 경우에 해당한다.
* 그러나 **컬렉션 페치 조인을 사용하는 경우, 결과가 부풀려질 수 있다는 사실에 주의**해야 한다.
  * 다시 상술한 시나리오에서, 팀 A에는 회원 1과 회원 2가 소속된다.
  * 이 경우, 데이터베이스에 조인 쿼리 요청시 결과로 반환되는 팀 A의 row는 각각의 회원 정보로 인해 2개가 된다.
  * **JPQL 역시 내부적으로는 데이터베이스에 쿼리를 요청하는 것에 지나지 않으므로, 팀 A에 대한 조회 결과는 회원 수만큼 발생**하게 된다.
* **JPA 입장에서는 컬렉션에 중복된 데이터가 존재하는 것을 어떻게 처리할지 결정하지 않으며, 이에 대한 처리를 개발자에게 위임**한다.
  * JPA가 조회된 결과를 분석하여 중복된 데이터를 마음대로 제거할 수도 있으나, 어떤 개발자는 오히려 중복된 데이터가 포함된 컬렉션을 원할 수도 있다.
  * 또한, 데이터베이스로부터 조회된 데이터를 그대로 반환하는 것이 마치 SQL을 통해 데이터베이스로부터 직접 조회한 것과 같은 효과를 준다.
  * 이러한 이유에서 JPA는 JPQL로 조회된 결과를 후처리하지 않으며, 그대로 반환하게 된다.
* 페치 조인으로 조회한 결과는 식별자에 따라 영속성 컨텍스트로 관리되므로, 팀 A라는 엔티티는 영속성 컨텍스트에 하나만 관리된다.
  * 그러나 **페치 조인의 결과로 반환되는 컬렉션에는 해당 팀 A를 참조하는 요소가 팀 A에 포함된 회원 수만큼 존재**하게 된다.
* 이렇듯 **페치 조인으로 조회된 결과가 부풀려지는 것은 1:N 관계에서만 발생할 수 있으며, N:1 관계에서는 발생하지 않는다**.
  * N:1 관계에서는 조건에 따라 오히려 데이터가 줄어들 수 있다.

### 컬렉션으로부터 중복 제거하기
* **컬렉션 페치 조인의 결과로 중복이 발생할 수 있다는 사실은 이해하지만, 그럼에도 중복을 모두 제거하고 싶다면 DISTINCT를 활용**할 수 있다.
```
select distinct t from Team t join fetch t.members
```
* SQL의 DISTINCT는 중복 결과를 제거하는 의미를 갖지만, JPQL은 다음과 같은 기능을 제공한다.
  1. SQL에 DISTINCT를 추가한다.
  2. **애플리케이션으로부터 엔티티의 중복을 제거**한다.
* 이는 SQL의 DISTINCT 만으로는 모든 중복을 제거할 수 없으므로, JPA는 데이터베이스가 아닌 애플리케이션 단위에서 중복을 제거하도록 지원한다.
  * SQL의 경우, 중복된 데이터의 모든 컬럼의 값이 같아야 중복된 값으로 판단하여 DISTINCT의 제거 대상이 된다.
  * 정확히는 **데이터베이스에 조회를 요청할 때 DISTINCT를 추가하고, 결과를 애플리케이션 단위에서 받아 중복된 엔티티를 모두 제거하는 식으로 동작**한다.
* **JPA가 SQL을 통해 조회한 데이터를 수신한 경우, DISTINCT 키워드가 포함되어 있었다면 결과로부터 동일한 식별자를 갖는 모든 엔티티를 찾아 제거**한다.

### 페치 조인과 일반 조인의 차이점
* **일반 조인의 경우, 실행시 연관된 엔티티를 함께 조회하지는 않는다**.
* **JPQL은 결과를 반환할 때 연관 관계를 고려하지 않으며, 단지 SELECT 절에 지정된 엔티티만을 조회**한다.
  * 예를 들어, 상술한 시나리오 중 팀을 기준으로 조회하는 경우 팀 엔티티만 조회하고 회원 엔티티는 실제로 조회하지 않는다.
  * 때문에 팀에 소속된 회원의 정보를 조회하는 시점에 데이터베이스 쿼리를 요청하여 필요한 데이터를 가져오게 된다.
* **페치 조인의 경우, 연관된 엔티티를 함께 조회하는 즉시 로딩이 적용**된다.
  * 정확히는 **페치 조인은 객체 그래프를 SQL 한 번에 모두 조회하는 개념으로 이해**할 수 있다.
  * **대부분의 N + 1 문제는 사실상 페치 조인을 통해 모두 해결한다고 이해**할 수 있다.

### 페치 조인의 특징과 한계점
* 페치 조인 대상에는 별칭을 적용할 수 없다.
  * 하이버네이트에서는 가능하지만, 그럼에도 가급적이면 별칭을 할당하지 않는 것이 바람직하다.
  * 페치 조인은 기본적으로 특정 엔티티와 연관된 모든 엔티티를 함께 가져오는 용도로 사용된다.
  * 이 때, **조인 대상에 별칭을 적용한다는 것은 잠정적으로 where절 등을 통해 조회 대상의 수를 줄이려는 의도가 포함**된다.
  * 그러나 **이러한 경우에는 페치 조인을 사용하지 않아야 하며, 사이드 이펙트를 줄이기 위해 별도로 조회하는 것이 바람직**하다.
* 페치 조인은 어디까지나 객체 그래프 탐색을 위해 연관된 모든 엔티티를 조회하는 것이 목적이므로, 엔티티의 수를 줄이는 후처리는 오류를 발생시키기 쉽다.
  * 예를 들어 팀과 연관된 회원 엔티티 중 조건을 충족하는 다섯 개만 조회하고 싶은 경우, 애초에 페치 조인이 아닌 회원 엔티티 조회로 시작하는 것이 적절하다.
* 둘 이상의 컬렉션을 페치 조인할 수는 없다.
  * 예를 들어, **팀이 연관된 회원 엔티티 목록과 주문 엔티티 목록을 별도로 갖고 있는 경우에는 페치 조인**할 수 없다.
  * 1:N에서도 조회 결과가 부풀려지는 현상이 두드러지므로, 1:N:M 관계에서는 이러한 문제가 더 심화될 수 있다. 
* **컬렉션을 페치 조인하는 경우, 페이징 API를 사용할 수는 없다**.
  * **일대 일 또는 다대 일과 같은 단일 값 연관 필드들은 데이터가 부풀려질 일이 없으므로 페치 조인을 적용하더라도 페이징이 가능**하다.
  * 반면, **일대 다 관계의 경우 페치 조인을 통해 데이터가 부풀려지므로 페이징이 불가능**하다.
  * 또한, 하이버네이트의 경우 경로를 남기고 메모리에서 페이징을 진행하나 이는 매우 위험한 방식이다.
* **페치 조인은 곧 전체 객체 그래프의 탐색이지만, 페이징 API는 조회된 객체 그래프의 수를 강제로 줄이는 식으로 동작**한다.
  * 즉, **페치 조인의 사상과 맞지 않으므로 일대 다 관계에서의 객체 그래프 탐색시 실제 엔티티 수와 맞지 않는 조회 결과를 만들어 내는 페이징은 불가능**하다.
  * **하이버네이트는 이를 지원하긴 하지만 우선 데이터베이스의 모든 데이터를 메모리에 적재한 후에 페이징을 처리하므로 위험**할 수 밖에 없다.
* 굳이 페이징을 사용해야만 하는 경우, 다음과 같은 방식으로 문제를 해결할 수 있다.
  1. 팀을 기준으로 페치 조인하는 것이 아닌 회원을 기준으로 페치 조인하여 다대 일 관계로 변경한다.
  2. 우선 페치 조인을 사용하지 않도록 쿼리를 수정하고, 페이징을 적용하여 조회한 후 지연 로딩을 통해 연관된 엔티티를 조회한다.
     * 예를 들어, `select t from Team t` 쿼리에 페이징을 적용하여 우선 팀을 조회한다.
     * 이후 팀에 포함된 members 필드에 접근하여 지연 로딩을 적용한다.
     * 당연히 해당 방식은 N + 1 문제로부터 자유롭지 못하며, 성능 역시 떨어질 수 밖에 없다.
  3. 또는 2. 방식을 **개선하기 위해 지연 로딩이 적용된 Team.members에 `@BatchSize(size = 100)` 어노테이션을 명시**할 수 있다.
     * 이 때, BatchSize는 persistence.xml에 `hibernate.default_batch_fetch_size`라는 글로벌 옵션으로 적용할 수도 있다.
     * **실무에서는 글로벌 옵션 방식이 더 권장되며, size는 1000 이하의 값을 적절히 적용하는 것이 바람직**하다.
* **페치 조인은 연관된 엔티티들을 SQL 한 번으로 조회하여 성능을 최적화하며, 엔티티에 직접 적용하는 로딩 전략보다 우선 적용**된다.
  * 즉, `@OneToMany(fetch = FetchType.LAZY)`와 같은 글로벌 로딩 전략보다 페치 조인이 우선 순위가 더 높다.
  * **실무의 경우, 글로벌 로딩 전략은 기본적으로 모두 지연 로딩을 적용할 것이므로 최적화가 필요한 곳을 찾아 페치 조인을 적용하는 식으로 작업**하게 된다.
  * **JPA에서 발생하는 성능 문제의 8할은 N + 1문제이며, 이는 대부분의 경우 페치 조인으로 해결이 가능**하다.

### 페치 조인 - 결론
```
> 모든 문제를 페치 조인으로 해결할 수는 없다.
```
* **페치 조인은 객체 그래프를 유지해야할 때 사용하면 효과적**이다.
* **여러 테이블을 조인하여 엔티티가 가진 형태와는 전혀 다른 결과를 조회해야하는 경우, 페치 조인 대신 일반 조인을 사용**한다.
  * 이 때, **필요한 데이터만 조회하여 Dto로 반환하는 것이 효과적**이다.
* 이렇듯 페치 조인을 활용하는 방식은 크게 세 가지로 분류된다.
  1. 페치 조인을 통해 엔티티를 조회한 결과를 그대로 반환하는 경우
  2. 또는 페치 조인 후 애플리케이션 차원에서 Dto로 변환하는 경우
  3. 또는 JPQL을 설계하는 시점에서 new operation을 통해 Dto로 변환하여 조회하는 경우
* **페치 조인은 실무에서 사용성도 높고, 그 중요성도 높으므로 반드시 이해하고 넘어가는 것이 중요**하다.

### JPQL과 다형성 쿼리
* 엔티티가 상속 관계를 사용하는 경우, type 키워드를 통해 조회 대상을 특정한 엔티티의 자식으로 한정지을 수 있다.
* 예를 들어, Item 엔티티를 상속받는 Book 또는 Album 엔티티만 조회하는 경우의 JPQL은 다음과 같이 작성된다.
```
select i from Item i where type(i) in (Book, Album)
```
* 이 경우, 실제 SQL은 다음과 같이 요청된다.
```
select i from i where i.DTYPE in ('B', 'A')
```

### TREAT
* TREAT 키워드는 Java의 타입 캐스팅과 유사한 개념으로, 상속 구조 상의 부모 타입을 특정한 자식 타입으로 취급하는 경우에 사용이 가능하다.
* 예를 들어, Item을 조회하던 중 임의의 엔티티를 자식인 Book 엔티티로 취급하는 쿼리는 다음과 같다.
```
select i from Item i where treat(i as Book).auther = 'hong'
```
* 이 경우, 실제 SQL은 다음과 같이 요청된다.
  * 이러한 **SQL 쿼리는 상속 관계를 사용하는 JPA의 전략에 따라 바뀔 수 있다**.
  * 예를 들어, 아래의 쿼리는 단일 테이블 전략을 사용하는 경우의 쿼리에 해당한다.
```
select i.* from Item i where i.DTYPE = 'B' and i.auther = 'hong'
```

### JPQL 엔티티 직접 사용하기
* JPQL의 경우, 엔티티를 직접 사용하면 SQL에서 해당 엔티티의 기본 키 값을 사용하게 된다.
* 예를 들어, 다음과 같은 두 가지 방식의 JPQL 쿼리를 작성할 수 있다.
```
select count(m.id) from Member m
select count(m) from Member m
```
* 첫 번째 방식은 엔티티의 아이디를 사용하는 반면, 두 번째 방식은 엔티티를 직접 사용한다.
* 그러나 **두 쿼리 모두 실행시 실제 SQL은 다음과 같이 기본 키 값을 사용하도록 변경**된다.
```
select count(m.id) as cnt from Member m
```
* 이는 **엔티티 자체를 파라미터로 전달하거나, 엔티티의 식별자를 직접 전달하더라도 동일하며 실제 SQL은 항상 기본 키 값을 사용하도록 변경**된다.
  * **JPA에서는 `select m from Member m where m = :member` 형태의 JPQL로 엔티티를 파라미터로 전달할 수 있다**.
* 이렇듯 **엔티티가 JPA를 통해 데이터베이스에 전달된 경우, 쿼리 상에서는 엔티티를 구분하는 식별자인 기본 키 값을 사용**하게 된다.
* **이는 연관 관계에 있어 외래키로 사용된 엔티티를 파라미터로 전달한 경우에도 마찬가지이며, 실제 SQL 상에서는 엔티티의 외래 키 값을 사용**하게 된다.
```
select m from Member m where m.team = :team
```
* 상술한 JPQL 쿼리 역시 실제 SQL로는 다음과 같이 매핑된다.
```
select m.* from Member m where m.TEAM_ID=[팀ID]
```
* 이러한 JPA 만의 특징은 객체와 달리 데이터베이스는 엔티티를 식별자를 통해 구분하기 때문에 두드러진다.
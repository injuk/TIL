# Basics
## 2022-07-17 Sun

### 단방향 연관 관계 매핑
* **JPA를 사용하는 개발자는 객체와 테이블 연관 관계의 차이를 이해하고, 객체의 참조와 테이블의 외래 키를 적절히 매핑할 수 있어야 한다**.
  * 예를 들어, 객체는 관계를 추적하기 위해 참조 연산자를 사용하지만 테이블은 FK를 사용한다.
  * 이렇듯 객체지향과 관계형 데이터베이스 사이에서 오는 불일치성을 해결하기 위해 연관 관계의 차이를 이해할 수 있어야 한다.
* 연관 관계는 말 그대로 두 엔티티 사이의 관계를 가리키며, 다음과 같은 항목들을 갖는다.
  1. 방향: 연관 관계는 단방향이거나 양방향일 수 있다.
  2. 다중성: 두 엔티티의 관계는 1:1이거나 1:N, M:N일 수 있다.
  3. 연관 관계의 주인: **객체의 양방향 연관 관계에서는 관리를 위한 주인 개념이 필요**하다. 

### 연관 관계가 왜 필요한가?
* **객체 지향 설계의 목표는 자율적인 객체들의 협력 공동체를 만드는 것이며, 단일 객체 또는 단일 테이블로 요구 사항을 해결할 수는 없다**.
* 객체를 관계형 데이터베이스의 개념인 테이블에 맞추어 설계할 경우, 두 엔티티 사이의 연관 관계는 생기지 않는다.
  * 이 경우, 객체는 서로의 FK 정보만을 필드로 갖게 되므로 상호 작용을 위해서는 반드시 데이터베이스를 조회할 필요가 있다.
  * 즉, **객체 간 연관 관계를 의미하는 참조 연산자를 사용할 수 없으며 단순한 값인 FK 정보만을 필드로 갖게 된다**.
* 이렇듯 **객체를 테이블에 맞춘 데이터 중심의 모델링은 적절한 협력 관계를 만들 수 없다**. 
  * **테이블은 외래 키를 활용한 JOIN 쿼리로 원하는 결과를 요청하지만, 객체는 참조 연산자를 활용하는 큰 차이**가 있다.
  * 즉, 외래 키와 참조라는 커다란 패러다임의 차이가 존재한다.

### 단방향 연관 관계
* 단방향 연관 관계는 가장 기본적이며, 가장 중요한 연관 관계에 해당한다.
* 상술한 **단점을 해소하는 객체지향적인 모델링의 경우, 테이블의 FK는 그대로 둔 채 코드 상에서는 엔티티가 연관된 엔티티의 객체를 참조하는 것**이다.
  * 예를 들어, 팀이 여러 회원을 포함하는 관계의 경우 회원은 `Long teamId;`가 아닌 `Team team`을 갖는다.
  * 이를 통해 객체는 자신과 연관된 팀 엔티티를 참조 연산자를 통해 탐색할 수 있게 된다.
* 그러나 **JPA의 경우, 엔티티가 다른 엔티티 객체를 포함하는 경우 반드시 연관 관계에 대한 정보를 어노테이션으로 명시하도록 강제**한다.
  * 또한 **이러한 @ManyToOne 등의 어노테이션을 통해 연관 관계 정보를 명시한 후, @JoinColumn을 통해 테이블의 FK 정보도 함께 명시**해주어야 한다.

### 양방향 연관 관계
* 상술한 예시에서, 회원 뿐만 아니라 팀 역시 자신에게 속한 회원 목록에 접근해야하는 경우를 양방향 연관 관계라고 하다.
* 이러한 양방향 연관 관계를 JPA를 통해 적절히 매핑하고, 연관 관계의 주인을 선정하는 것은 JPA에서 가장 어렵고도 중요한 개념에 속한다.
  * 이렇듯 **난이도를 높이는 주범은 역시 참조를 통해 연관 관계를 맺는 객체와 FK 및 JOIN 연산을 활용하는 관계형 데이터베이스 간의 패러다임 차이**이다.
  * 이러한 **두 패러다임 각각의 특징과 그 차이를 적절히 이해하는 경우, 연관 관계의 주인이라는 개념의 필요성을 이해**할 수 있게 된다.
  * 해당 개념은 이것이 왜 필요한지를 반드시 이해해야 하며, JPA가 제공하는 편의 기능 중 하나로만 접근하는 것은 지양해야 한다.

### 관계형 데이터베이스에서의 양방향 연관 관계
* **단방향 연관 관계 방식에서 바뀔 필요가 없다**!
  * 관계형 데이터베이스는 애초에 두 테이블이 설계될 때 각각 PK와 FK를 갖도록 구현된다.
  * 때문에 회원은 자신의 FK와 팀의 PK를 통해 팀에 접근하고, 팀은 자신의 PK와 회원의 FK를 통해 언제든지 서로를 참조할 수 있다.
* 정확히는 서로의 PK와 FK를 활용하는 테이블 간의 연관 관계에는 방향 개념이 존재할 필요가 없다.
  * 이렇듯 관계형 데이터베이스는 강력한 JOIN 기능을 통해 연관된 엔티티 목록을 확인하기가 쉽다.

### 객체 지향과 JPA에서의 양방향 연관 관계
* 객체 지향에서 연관된 객체를 탐색하는 방법은 객체 자신의 필드로 포함된 참조 뿐이므로, 양방향 연관 관계의 구현을 위해서는 서로가 참조를 갖고 있어야 한다.
  * 이는 객체의 참조와 테이블 간의 참조에 있어서 가장 큰 차이점에 해당한다.
* 이 때, 다음과 같은 JPA의 어노테이션을 활용하여 팀과 회원 엔티티 간의 관계가 1:N임을 명시한다.
```
@OneToMany(mappedBy = "team")
List<Member> members = new ArrayList<>();
```
* 상술한 **어노테이션은 현재 members 필드에 의해 team이라는 필드를 갖는 엔티티와 1:N 관계를 맺고 있음을 의미**한다.
  * 즉, team에 의해 자신이 매핑되었음을 명시한다.
* 이러한 방식으로 구현할 경우, 엔티티 매니저를 통해 조회한 객체를 활용한 양방향 탐색이 가능해진다.

### 양방향 연관 관계는 좋은가?
* 객체 관점에서, 양방향 연관 관계는 유지보수 과정에서 점점 확인해야할 부분을 늘리는 단점이 존재한다.
  * 때문에 **객체 입장에서는 단방향 연관 관계가 더 좋다**고도 볼 수 있다.

### mappedBy 속성은 왜 필요한가?
* 회원 엔티티에서는 `@ManyToOne`만 명시해도 무방했으나, 팀 엔티티에서는 `@OneToMany(mappedBy = "team")`과 같이 속성을 추가로 명시하였다.
* 해당 속성의 존재 의의를 이해하기 위해서는 상술한 객체와 관계형 데이터베이스 테이블 간의 연관 관계 차이점을 되돌아볼 필요가 있다.
  1. 객체는 엔티티 각각이 갖는 참조를 통해 서로를 조회하기 위해 두 개의 단방향 연관 관계를 정의해야 한다.
  2. 반면, 관계형 데이터베이스의 테이블은 FK를 추가하는 한 개의 양방향 연관 관계만을 정의한다.
* 즉, **객체는 양방향 연관 관계의 구현을 위해 두 개의 단방향 연관 관계를 설정하지만 테이블은 태생적으로 하나의 양방향 연관 관계**를 갖는다. 
* 그러나 **JPA 입장에서는 하나의 외래 키로 표현된 연관 관계를 표현하기 위해 설정된 두 개의 참조 중 어느 것을 외래 키로 관리할지 알 수 있어야 한다**.
  * 예를 들어, 팀의 회원이 변경되거나 회원이 새로운 팀에 가입하는 경우 회원의 팀 정보를 변경 해야할지 팀의 회원 목록을 변경해야 할지 알 수 없다.
  * 이는 **두 엔티티 간의 연관 관계를 의미하는 테이블의 FK 값을 어떤 객체의 참조를 통해 관리할지에 대한 의문과 상통**한다. 
  * 즉, Member.team과 Team.members 필드 중 어떠한 참조를 통해 FK를 관리할지 결정이 필요하다.

### 연관 관계의 주인
* 상술한 **FK 관리 문제의 해결책은 두 엔티티 중 하나를 연관 관계의 주인으로 설정하는 것**이다.
  * 연관 관계의 주인은 두 패러다임 간의 불일치를 해소하기 위해 도입된 개념이므로, 양방향 연관 관계를 매핑하는 과정에서만 사용한다. 
* 이 때, **연관 관계의 주인으로 선정된 엔티티만이 FK를 등록하거나 수정하는 등, 관리**할 수 있다.
  * 반면 **연관 관계의 주인이 아닌 엔티티는 FK에 대한 읽기 동작만이 가능**하다.
* mappedBy 속성은 연관 관계의 주인 선정과 연관이 있는 속성이며, **연관 관계의 주인은 mappedBy 속성을 표기하지 않아야 한다**.
  * 반면, **주인이 아닌 엔티티는 mappedBy 속성을 통해 현재 연관 관계의 주인은 누구인지 정확히 명시할 의무**가 있다.
  * 이러한 이유에서 단순한 연관 관계 매핑 정보를 명시하는 @JoinColumn 어노테이션과 mappedBy 속성은 서로 관계가 없다.

### 연관 관계 주인 선정하기
* **반드시 테이블에 FK가 존재하는 엔티티를 연관 관계의 주인으로 선정**한다.
  * 때문에 상술한 예시의 경우, FK를 통해 팀과 연관 관계를 맺는 회원 엔티티가 연관 관계의 주인이 되어야 한다.
  * 그러나 이는 JPA 측에서 정의한 절대적인 원칙은 아니며, 많은 개발자들이 JPA를 사용하는 과정에서 수립한 개념으로 이해할 수 있다.
* 이러한 원칙을 준수하지 않는 경우, 팀 엔티티에 대한 수정 작업의 결과로 발생한 UPDATE 쿼리가 회원 테이블을 수정할 가능성이 높다. 
  * 이는 헷갈릴 뿐더러, 성능 역시 상대적으로 떨어지는 문제점이 존재한다.
* 이 경우, 연관 관계의 주인 엔티티로부터 시작된 매핑이 진짜 연관 관계 매핑에 해당한다.
* 반면, 연관 관계의 주인이 아닌 엔티티로부터 시작된 매핑은 가짜 매핑에 해당하므로 읽기 동작만을 제공한다.
  * 즉, **연관 관계의 주인이 아닌 엔티티 측의 필드를 수정하더라도 실제 엔티티 간의 연관 관계에는 아무런 영향을 주지 못한다**.
* 상술한 예시에서 팀 엔티티가 갖는 컬렉션인 members에 새로운 회원을 추가하더라도 실제로는 아무런 일도 발생하지 않으며, 데이터베이스에도 영속화되지 않는다.
  * 그러나 **읽기 동작은 허용하므로 Team.members를 호출할 경우 JPA는 조회 쿼리를 통해 값을 반환**한다.

### 연관 관계의 주인과 비즈니스 중요도
* 주인이라는 워딩으로 인해 연관 관계의 주인으로 선정된 엔티티는 언뜻 비즈니스 중요도도 높을 것처럼 보인다.
* 그러나 **연관 관계의 주인은 단지 패러다임의 불일치를 해소하기 위한 것으로, 비즈니스와는 전혀 무관한 개념**이다.
  * **연관 관계의 주인 선정 기준 역시 비즈니스 중요도가 아닌, 단순히 1:N 관계에서 N을 차지하는 엔티티가 선정**된다.

## 2022-07-18 Mon
### 양방향 연관 관계 매핑시 주의사항
* 양방향 연관 관계는 크고 작은 실수가 많이 발생하며, 특히 양방향 연관 관계의 주인 엔티티 필드에 값을 입력하지 않아 null이 적용된 경우가 많다.
  * 예를 들어, 연관 관계의 주인인 회원에는 팀의 값을 저장하지 않았지만 팀에는 회원의 값을 저장한 경우에 해당한다.
  * mappedBy가 적용된 측은 읽기 전용이므로, JPA는 애초에 값을 추가하거나 수정할 때 해당 필드는 신경쓰지 않는다.
* 이 경우, **순수한 객체 관계를 고려하여 양측에 모두 값을 입력하는 것이 바람직하며 문제를 미연에 방지할 수도 있다**.
* 그러나 연관 관계가 맺어지는 두 엔티티 모두에 값을 직접 설정하는 작업은 둘 중 하나의 작업을 잊기 쉬우며, 이는 휴먼 에러로 인한 버그로 이어질 수 있다.
  * 때문에 **연관 관계 편의 메소드를 작성하여, 하나의 메소드 호출로 양 측 엔티티에 모두 값을 설정할 수 있도록 구현하는 것이 바람직**하다.
  * 이러한 **연관 관계 편의 메소드를 양 측 엔티티 전부에 정의하는 것은 무한 루프 등의 버그 가능성을 높이므로, 한 쪽 엔티티에만 로직을 정의**한다.
  * 연관 관계 편의 메소드를 작성하는 엔티티는 연관 관계의 주인 개념과는 관계가 없으므로, 애플리케이션 개발 과정에서 보다 자연스러운 엔티티에 추가하도록 한다.
* 또한, **양방향 연관 관계를 매핑하는 경우에는 toString, lombok, JSON 생성 라이브러리 등에서 무한 루프의 발생 가능성을 조심**해야 한다.
  * 예를 들어, toString 메소드가 회원과 팀 모두에 설정되어 있는 경우 members.toString()과 team.toString()이 계속해서 호출될 수 있다.
  * 이러한 **문제를 방지하기 위해 lombok 라이브러리의 toString은 사용을 지양하고, 엔티티를 컨트롤러에 그대로 반환하지 않도록 한다**.
  * 스프링의 지원으로 인해 엔티티를 반환하는 것 자체는 가능하지만, 이는 무한 루프 뿐만 아니라 엔티티의 변경이 API 변경을 일으키는 문제 역시 발생할 수 있다.
  * 따라서 **엔티티는 가능한 한 Dto로 변환하는 과정을 거친 후에 컨트롤러에 반환하는 것이 바람직**하다.

### 양방향 연관 관계 정리하기
* 단방향 연관 관계 매핑만으로도 사실상 연관 관계 매핑은 완료된 것으로 볼 수 있다.
  * 사실 양방향 연관 관계는 객체 그래프 탐색 기능이 추가된 것 뿐이다.
* 사실상 **JPA를 활용하여 모델링하는 경우, 초기 단계에서는 반드시 단방향 연관 관계만을 매핑하고 설계를 끝내야 한다**!
  * 설계 관점에서, 객체에 양방향 연관 관계 매핑을 추가하는 것은 오히려 개발 과정에서 고려할 부분을 높이는 경우가 많다.
* 그러나 **JPQL에서는 역방향으로 탐색하는 경우가 잦으므로, 우선 단방향 연관 관계를 잘 설정한 후 필요한 경우에 양방향 연관 관계를 설정**하도록 한다.
  * 이러한 접근 방식은 실제 테이블에도 영향을 주지 않는다.
* 상술한 이유에서, JPA를 활용한 설계는 다음과 같은 순서로 진행된다.
  1. 우선 1:N 관계의 N 측에 단방향 연관 관계를 설정한다.
  2. 설계를 완료한다.
  3. **애플리케이션을 개발하는 과정에서, 역방향 탐색이 정말로 필요해지는 순간에 양방향 연관 관계를 설정**한다.
* 또한, 상술했듯 **연관 관계의 주인은 비즈니스 로직 상의 중요도가 아닌 단순한 FK의 위치를 기준으로 결정**해야 한다.

### 연관 관계 매핑 과정
* 상술했듯, **엔티티 간의 모든 연관 관계는 반드시 단방향 연관 관계에서부터 시작**한다.
  * 이 때, 1:N 관계를 갖는 두 엔티티 사이에서는 FK를 갖는 엔티티만 적절히 매핑해도 연관 관계는 자연스럽게 수립된다.
* **양방향 연관 관계는 객체 입장에서는 복잡도가 증가하여 크게 좋을 게 없는 관계이므로, 가능한 한 단방향 연관 관계 매핑으로 모든 것을 완료**하도록 한다.
* 또한, 애플리케이션 개발 과정에서 양방향 연관 관계가 반드시 필요한 상황이 닥치더라도 우선 객체 간 관심사의 분리가 적절히 나누어졌는지 확인한 후에 진행한다.
  * 사실상 **양방향 연관 관계가 아니어도 대부분의 경우에는 애플리케이션을 개발하는데 아무런 지장이 없을 가능성이 높다**.
* 물론 양방향 연관 관계가 절대악은 아니며, 실무에서는 편리한 조회를 위해 복잡한 JPQL을 작성하는 과정에서 양방향 연관 관계를 추가하게 될 가능성이 높다.
  * 잘 설계되어 적용된 양방향 연관 관계는 애플리케이션을 보다 더 객체지향적으로 구성하는 데에 도움을 준다.
* **양방향 연관 관계를 적용할지에 대한 중요한 판단 기준은 비즈니스 규칙이며, 규칙 상 사용하지 않을 연관 관계는 매핑하지 않고 관심사를 분리**하도록 한다.
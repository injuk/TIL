# Basics
## 2022-07-17 Sun

### 단방향 연관 관계 매핑
* **JPA를 사용하는 개발자는 객체와 테이블 연관 관계의 차이를 이해하고, 객체의 참조와 테이블의 외래 키를 적절히 매핑할 수 있어야 한다**.
  * 예를 들어, 객체는 관계를 추적하기 위해 참조 연산자를 사용하지만 테이블은 FK를 사용한다.
  * 이렇듯 객체지향과 관계형 데이터베이스 사이에서 오는 불일치성을 해결하기 위해 연관 관계의 차이를 이해할 수 있어야 한다.
* 연관 관계는 말 그대로 두 엔티티 사이의 관계를 가리키며, 다음과 같은 항목들을 갖는다.
  1. 방향: 연관 관계는 단방향이거나 양방향일 수 있다.
  2. 다중성: 두 엔티티의 관계는 1:1이거나 1:N, M:N일 수 있다.
  3. 연관 관계의 주인: **객체의 양방향 연관 관계에서는 관리를 위한 주인 개념이 필요**하다. 

### 연관 관계가 왜 필요한가?
* **객체 지향 설계의 목표는 자율적인 객체들의 협력 공동체를 만드는 것이며, 단일 객체 또는 단일 테이블로 요구 사항을 해결할 수는 없다**.
* 객체를 관계형 데이터베이스의 개념인 테이블에 맞추어 설계할 경우, 두 엔티티 사이의 연관 관계는 생기지 않는다.
  * 이 경우, 객체는 서로의 FK 정보만을 필드로 갖게 되므로 상호 작용을 위해서는 반드시 데이터베이스를 조회할 필요가 있다.
  * 즉, **객체 간 연관 관계를 의미하는 참조 연산자를 사용할 수 없으며 단순한 값인 FK 정보만을 필드로 갖게 된다**.
* 이렇듯 **객체를 테이블에 맞춘 데이터 중심의 모델링은 적절한 협력 관계를 만들 수 없다**. 
  * **테이블은 외래 키를 활용한 JOIN 쿼리로 원하는 결과를 요청하지만, 객체는 참조 연산자를 활용하는 큰 차이**가 있다.
  * 즉, 외래 키와 참조라는 커다란 패러다임의 차이가 존재한다.

### 단방향 연관 관계
* 단방향 연관 관계는 가장 기본적이며, 가장 중요한 연관 관계에 해당한다.
* 상술한 **단점을 해소하는 객체지향적인 모델링의 경우, 테이블의 FK는 그대로 둔 채 코드 상에서는 엔티티가 연관된 엔티티의 객체를 참조하는 것**이다.
  * 예를 들어, 팀이 여러 회원을 포함하는 관계의 경우 회원은 `Long teamId;`가 아닌 `Team team`을 갖는다.
  * 이를 통해 객체는 자신과 연관된 팀 엔티티를 참조 연산자를 통해 탐색할 수 있게 된다.
* 그러나 **JPA의 경우, 엔티티가 다른 엔티티 객체를 포함하는 경우 반드시 연관 관계에 대한 정보를 어노테이션으로 명시하도록 강제**한다.
  * 또한 **이러한 @ManyToOne 등의 어노테이션을 통해 연관 관계 정보를 명시한 후, @JoinColumn을 통해 테이블의 FK 정보도 함께 명시**해주어야 한다.

### 양방향 연관 관계
* 상술한 예시에서, 회원 뿐만 아니라 팀 역시 자신에게 속한 회원 목록에 접근해야하는 경우를 양방향 연관 관계라고 하다.
* 이러한 양방향 연관 관계를 JPA를 통해 적절히 매핑하고, 연관 관계의 주인을 선정하는 것은 JPA에서 가장 어렵고도 중요한 개념에 속한다.
  * 이렇듯 **난이도를 높이는 주범은 역시 참조를 통해 연관 관계를 맺는 객체와 FK 및 JOIN 연산을 활용하는 관계형 데이터베이스 간의 패러다임 차이**이다.
  * 이러한 **두 패러다임 각각의 특징과 그 차이를 적절히 이해하는 경우, 연관 관계의 주인이라는 개념의 필요성을 이해**할 수 있게 된다.
  * 해당 개념은 이것이 왜 필요한지를 반드시 이해해야 하며, JPA가 제공하는 편의 기능 중 하나로만 접근하는 것은 지양해야 한다.

### 관계형 데이터베이스에서의 양방향 연관 관계
* **단방향 연관 관계 방식에서 바뀔 필요가 없다**!
  * 관계형 데이터베이스는 애초에 두 테이블이 설계될 때 각각 PK와 FK를 갖도록 구현된다.
  * 때문에 회원은 자신의 FK와 팀의 PK를 통해 팀에 접근하고, 팀은 자신의 PK와 회원의 FK를 통해 언제든지 서로를 참조할 수 있다.
* 정확히는 서로의 PK와 FK를 활용하는 테이블 간의 연관 관계에는 방향 개념이 존재할 필요가 없다.
  * 이렇듯 관계형 데이터베이스는 강력한 JOIN 기능을 통해 연관된 엔티티 목록을 확인하기가 쉽다.

### 객체 지향과 JPA에서의 양방향 연관 관계
* 객체 지향에서 연관된 객체를 탐색하는 방법은 객체 자신의 필드로 포함된 참조 뿐이므로, 양방향 연관 관계의 구현을 위해서는 서로가 참조를 갖고 있어야 한다.
  * 이는 객체의 참조와 테이블 간의 참조에 있어서 가장 큰 차이점에 해당한다.
* 이 때, 다음과 같은 JPA의 어노테이션을 활용하여 팀과 회원 엔티티 간의 관계가 1:N임을 명시한다.
```
@OneToMany(mappedBy = "team")
List<Member> members = new ArrayList<>();
```
* 상술한 **어노테이션은 현재 members 필드에 의해 team이라는 필드를 갖는 엔티티와 1:N 관계를 맺고 있음을 의미**한다.
  * 즉, team에 의해 자신이 매핑되었음을 명시한다.
* 이러한 방식으로 구현할 경우, 엔티티 매니저를 통해 조회한 객체를 활용한 양방향 탐색이 가능해진다.

### 양방향 연관 관계는 좋은가?
* 객체 관점에서, 양방향 연관 관계는 유지보수 과정에서 점점 확인해야할 부분을 늘리는 단점이 존재한다.
  * 때문에 **객체 입장에서는 단방향 연관 관계가 더 좋다**고도 볼 수 있다.

### mappedBy 속성은 왜 필요한가?
* 회원 엔티티에서는 `@ManyToOne`만 명시해도 무방했으나, 팀 엔티티에서는 `@OneToMany(mappedBy = "team")`과 같이 속성을 추가로 명시하였다.
* 해당 속성의 존재 의의를 이해하기 위해서는 상술한 객체와 관계형 데이터베이스 테이블 간의 연관 관계 차이점을 되돌아볼 필요가 있다.
  1. 객체는 엔티티 각각이 갖는 참조를 통해 서로를 조회하기 위해 두 개의 단방향 연관 관계를 정의해야 한다.
  2. 반면, 관계형 데이터베이스의 테이블은 FK를 추가하는 한 개의 양방향 연관 관계만을 정의한다.
* 즉, **객체는 양방향 연관 관계의 구현을 위해 두 개의 단방향 연관 관계를 설정하지만 테이블은 태생적으로 하나의 양방향 연관 관계**를 갖는다. 
* 그러나 **JPA 입장에서는 하나의 외래 키로 표현된 연관 관계를 표현하기 위해 설정된 두 개의 참조 중 어느 것을 외래 키로 관리할지 알 수 있어야 한다**.
  * 예를 들어, 팀의 회원이 변경되거나 회원이 새로운 팀에 가입하는 경우 회원의 팀 정보를 변경 해야할지 팀의 회원 목록을 변경해야 할지 알 수 없다.
  * 이는 **두 엔티티 간의 연관 관계를 의미하는 테이블의 FK 값을 어떤 객체의 참조를 통해 관리할지에 대한 의문과 상통**한다. 
  * 즉, Member.team과 Team.members 필드 중 어떠한 참조를 통해 FK를 관리할지 결정이 필요하다.

### 연관 관계의 주인
* 상술한 **FK 관리 문제의 해결책은 두 엔티티 중 하나를 연관 관계의 주인으로 설정하는 것**이다.
  * 연관 관계의 주인은 두 패러다임 간의 불일치를 해소하기 위해 도입된 개념이므로, 양방향 연관 관계를 매핑하는 과정에서만 사용한다. 
* 이 때, **연관 관계의 주인으로 선정된 엔티티만이 FK를 등록하거나 수정하는 등, 관리**할 수 있다.
  * 반면 **연관 관계의 주인이 아닌 엔티티는 FK에 대한 읽기 동작만이 가능**하다.
* mappedBy 속성은 연관 관계의 주인 선정과 연관이 있는 속성이며, **연관 관계의 주인은 mappedBy 속성을 표기하지 않아야 한다**.
  * 반면, **주인이 아닌 엔티티는 mappedBy 속성을 통해 현재 연관 관계의 주인은 누구인지 정확히 명시할 의무**가 있다.
  * 이러한 이유에서 단순한 연관 관계 매핑 정보를 명시하는 @JoinColumn 어노테이션과 mappedBy 속성은 서로 관계가 없다.

### 연관 관계 주인 선정하기
* **반드시 테이블에 FK가 존재하는 엔티티를 연관 관계의 주인으로 선정**한다.
  * 때문에 상술한 예시의 경우, FK를 통해 팀과 연관 관계를 맺는 회원 엔티티가 연관 관계의 주인이 되어야 한다.
  * 그러나 이는 JPA 측에서 정의한 절대적인 원칙은 아니며, 많은 개발자들이 JPA를 사용하는 과정에서 수립한 개념으로 이해할 수 있다.
* 이러한 원칙을 준수하지 않는 경우, 팀 엔티티에 대한 수정 작업의 결과로 발생한 UPDATE 쿼리가 회원 테이블을 수정할 가능성이 높다. 
  * 이는 헷갈릴 뿐더러, 성능 역시 상대적으로 떨어지는 문제점이 존재한다.
* 이 경우, 연관 관계의 주인 엔티티로부터 시작된 매핑이 진짜 연관 관계 매핑에 해당한다.
* 반면, 연관 관계의 주인이 아닌 엔티티로부터 시작된 매핑은 가짜 매핑에 해당하므로 읽기 동작만을 제공한다.
  * 즉, **연관 관계의 주인이 아닌 엔티티 측의 필드를 수정하더라도 실제 엔티티 간의 연관 관계에는 아무런 영향을 주지 못한다**.
* 상술한 예시에서 팀 엔티티가 갖는 컬렉션인 members에 새로운 회원을 추가하더라도 실제로는 아무런 일도 발생하지 않으며, 데이터베이스에도 영속화되지 않는다.
  * 그러나 **읽기 동작은 허용하므로 Team.members를 호출할 경우 JPA는 조회 쿼리를 통해 값을 반환**한다.

### 연관 관계의 주인과 비즈니스 중요도
* 주인이라는 워딩으로 인해 연관 관계의 주인으로 선정된 엔티티는 언뜻 비즈니스 중요도도 높을 것처럼 보인다.
* 그러나 **연관 관계의 주인은 단지 패러다임의 불일치를 해소하기 위한 것으로, 비즈니스와는 전혀 무관한 개념**이다.
  * **연관 관계의 주인 선정 기준 역시 비즈니스 중요도가 아닌, 단순히 1:N 관계에서 N을 차지하는 엔티티가 선정**된다.
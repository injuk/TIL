# Basics
## 2022-07-24 Sun

### JPA의 데이터 타입 분류
* JPA는 데이터 타입을 크게 다음과 같이 분류한다.
  1. 엔티티 타입
  2. 값 타입
* **엔티티 타입이란 @Entity 어노테이션을 명시하는 객체이며, 데이터가 변하더라도 식별자를 통해 추적이 가능**하다. 
  * 예를 들어, 회원 엔티티의 이름 또는 나이 데이터가 변경되더라도 id와 같은 식별자를 통해 엔티티를 식별할 수 있다.
  * 극단적으로는 엔티티가 포함하는 모든 데이터 필드가 수정되었더라도 식별자를 통해 엔티티를 추적할 수 있다.
* 반면, **값 타입이란 int나 Integer와 같이 단순한 값으로 사용하는 Java의 기본 타입 또는 객체를 의미**한다. 
  * 100 또는 200 등과 같은 값 타입은 식별자가 존재하지 않으므로, 데이터가 변경된 경우에 추적은 불가능하다.
  * int를 예로 들어 **100이라는 데이터를 200으로 수정한 경우, 값은 완전히 다른 값으로 대체되는 것으로 이해**할 수 있다.

### 값 타입의 분류
* 값 타입은 다시 다음과 같이 분류할 수 있다.
  1. 기본 값 타입: int나 double과 같은 Java의 기본 값 타입과 래퍼 클래스, String 등을 의미한다.
  2. 임베디드 타입: 복합 값 타입이라고 지칭할 수 있으며, 사용자 정의 값 타입을 의미한다.
  3. 컬렉션 값 타입: Java가 제공하는 컬렉션 API를 통해 기본 값 타입 또는 임베디드 타입을 관리할 수 있다. 

### 기본 값 타입이란?
* **기본 값 타입은 String 또는 int와 같은 Java의 기본 데이터 타입을 의미하며, 생명 주기를 엔티티에 의존**한다.
  * 예를 들어, 회원 엔티티를 제거하면 이에 종속된 이름, 나이 등의 필드 역시 함께 삭제된다.
* **값 타입은 공유되지 않아야 한다**.
  * 예를 들어, 회원 A에 대한 기본 값 타입의 수정이 다른 회원 엔티티의 속성에 영향을 주지 않아야 한다.
  * 즉, 값의 관리 과정에서 다른 엔티티에 영향을 주는 사이드 이펙트가 발생하지 않아야 한다.
* Java의 경우 언어 자체적으로 기본 타입은 절대로 공유되지 않는다는 특징이 있으므로, 기본 값 타입을 사용하는 것은 안전하다.
  * 이는 Java의 기본 값 타입이 항상 값을 복사하는 식으로 동작하기 때문이다.
* 반면, **래퍼 클래스 또는 String과 같은 특수한 클래스는 공유가 가능한 객체이지만 값을 변경할 수는 없는 불변 객체의 특징**을 갖는다.
* 결론적으로 Java의 기본 값 타입과 래퍼 클래스, String은 엔티티 간에 영향을 주는 사이드 이펙트가 발생하지 않는다.

### 임베디드 타입이란?
* **임베디드 타입은 복합 값 타입이라고도 하며, 새로운 값 타입을 개발자가 직접 정의할 수 있는 기능**을 말한다.
  * 복합 값 타입이라는 용어로 지칭하는 이유는 주로 int, String과 같은 기본 값 타입을 모아 새로운 타입을 정의하기 때문이다.
* 복합 값 타입 역시 int, String과 같은 값 타입으로 취급된다.
  * **복합 값 타입은 값 타입이지 엔티티 타입이 아니기 때문에 값의 추적이 불가능하며, 수정시 완전히 새로운 값으로 대체**된다.
* 복합 값 타입은 어려울게 없으며, 단지 엔티티에서 사용되는 값 중 공통되기 쉬운 속성을 새로운 값 객체로 추출한 것에 지나지 않는다.
* 이러한 이유에서 개발자에 의해 정의된 복합 값 타입을 JPA에서 사용하는 경우, 다음과 같은 어노테이션을 명시해야 한다.
  1. @Embeddable: 값 타입을 새로이 정의하는 클래스에 명시한다.
  2. @Embedded: 새로이 정의된 값 타입을 실제로 사용하는 위치에 명시한다.
* 이 때, **새로 정의한 복합 값 타입은 반드시 기본 생성자를 포함해야 한다**.

### 임베디드 타입은 왜 사용하는가?
* 복합 값 타입을 적절히 사용할 경우, 다음과 같은 이점을 얻을 수 있다.
  1. 기간 등의 클래스를 복합 값 타입으로 정의할 경우, 시스템 전체적으로 공유하여 코드의 재사용성을 높일 수 있다.
  2. 새로이 정의된 복합 값 클래스 내부적으로 높은 응집도를 유지할 수 있다.
  3. 기간을 Period 라는 복합 값 타입으로 정의한 경우, `Period.isWork()`와 같이 해당 값 타입에 사용할 수 있는 의미 있는 메소드를 추가할 수 있다.
  4. **복합 값 타입을 포함하는 모든 값 타입은 값 타입을 소유하는 엔티티에 의존적으로 생명 주기가 관리**된다.
     * 값 타입은 기본적으로 엔티티가 제거되면 연관된 값 타입은 모두 함께 제거되며, 엔티티가 새로이 생성되는 시점에 종속된다.
* 반면, **복합 값 타입은 어디까지나 객체지향 프로그래밍에 도움을 주는 개념이므로 관계형 데이터베이스의 테이블 입장에서는 바뀌는 점이 없다**.
  * 때문에 주소 또는 기간을 각각 Address, Period 클래스라는 복합 값 타입으로 추출하였다고 해도 테이블에는 추출된 클래스의 속성 명이 컬럼으로 매핑된다.
  * **테이블은 객체가 복합 값 타입을 사용하든 사용하지 않든 똑같이 단일 테이블로 유지되며, 대신 약간의 매핑 작업만 처리**해주면 된다.

### 임베디드 타입 정의 예시
* 복합 값 타입은 상술한 @Embeddable과 @Embedded 어노테이션을 명시하여 쉽게 구현할 수 있다.
  * 둘 중 하나만 명시해도 정상 동작하지만, 둘 모두 명시하는 것이 권장된다.
```
// Member.java
public class Member {
  // ...생략
  @Embedded
  private Period workPeriod;
  // ...생략
}

// Period.java
@Embeddable
public class Period {
  private LocalDateTime startTime; 
  private LocalDateTime endTime; 
  // 게터와 세터를 명시한다.
}
```

### 임베디드 타입과 테이블 매핑
* **복합 값 타입은 엔티티의 값 중 하나일 뿐이므로, 복합 값 타입을 도입하기 전과 후의 테이블 매핑 구조는 달라지지 않는다**.
* 객체와 테이블을 아주 세밀하게 매핑할 수 있으며, 잘 설계된 ORM 애플리케이션은 매핑 대상 테이블 수보다 매핑이 될 클래스의 수가 더 많은 특징을 갖는다.
  * 복합 값 타입을 잘 활용하면 공통으로 사용될 값들을 하나로 모으는 데에 그치지 않고, 유용한 메소드를 추가로 정의할 수도 있다.
  * 또한, **엔티티가 매핑을 위해 많은 속성을 필요로 한다고 해도 코드 상에서는 명시적인 이름을 갖는 클래스의 형태를 갖기에 가독성과 유지보수성도 높아진다**.
  * **실무에서는 값 타입을 찍어내듯이 만들지는 않지만, 적절하게 생성된 값 타입은 용어와 코드를 공통화하는 큰 장점이 존재**한다.
* 이 때, **복합 값 타입 자체가 null로 초기화된 경우 매핑된 모든 컬럼의 값 역시 null**이 된다.
  * 예를 들어, 회원 엔티티의 주소를 의미하는 복합 값 타입인 `private Address address;` 필드 자체가 null로 초기화된 경우를 의미한다.

### 임베디드 타입과 연관 관계
* **복합 값 타입은 다른 복합 값 타입을 포함하거나, 심지어는 엔티티를 포함할 수도 있다**.
  * 이 경우, 사실 복합 값 타입 내부적으로 포함할 엔티티에 대한 FK 값만을 포함하는 것이므로 생각보다 어렵지 않게 구현이 가능하다.

### @AttributeOverride 어노테이션
* 하나의 엔티티에서 동일한 값 타입을 사용하는 경우, 관계형 데이터베이스의 테이블의 컬럼 명은 중복될 가능성이 존재한다.
  * 예를 들어, 주소 정보를 Address라는 복합 값 타입으로 추출하여 정의하였으나 회원 엔티티가 집 주소와 회사 주소를 동시에 갖게 될 가능성이 있다.
* 따라서 **@AttributeOverrides 또는 @AttributeOverride 어노테이션을 명시하여 컬럼 명 속성을 재정의**할 수 있다.
  * 이 경우, 재정의 대상 컬럼이 단 하나일 경우에는 @AttributeOverride 어노테이션만 사용해도 무방하다.
```
public class Member {
  // ...생략
  @Embedded
  private Address home; 
  
  @Embedded
  @AttributeOverrides(
    @AttributeOverride(name = "city", column = @Column(name = "work_city"),
    @AttributeOverride(name = "street", column = @Column(name = "work_street"),
    @AttributeOverride(name = "zipcode", column = @Column(name = "work_zipcode")
  )
  private Address work;
  // ...생략
}
```
* 그러나 **실무에서는 해당 기능이 잘 사용되지는 않는다**.

### 값 타입의 특징
```
> 값 타입은 복잡한 객체 세상을 단순화하기 위해 고안된 개념이므로, 단순하고 안전하게 다룰 수 있어야 한다.
```
* 상술한 복합 값 타입 등을 여러 엔티티에서 공유하는 경우, 사이드 이펙트가 발생할 위험이 높다.
  * **JPA를 활용하여 개발하는 과정에서 공유 문제를 신경쓰지 않은 이유는 기본 값 타입이 공유로 인한 사이드 이펙트가 발생하지 않는 구조이기 때문**이다.
  * 반면, **애초에 실제로 어떤 값 타입을 여러 엔티티에서 공유하도록 설계했다면 이는 복합 값 타입이 아닌 엔티티를 사용해야하는 문제**이다. 
* 이러한 이유에서 **객체 상태의 값 타입을 그대로 공유하는 것은 위험하므로, 대신 객체 상태인 값을 복사하여 사용하는 것이 바람직**하다.

### 객체 타입의 한계점
* 이렇듯 항상 값을 복사하여 사용한다면 객체 참조의 공유로 인한 사이드 이펙트를 피할 수 있다.
* 그러나 **문제는 복합 값 타입과 같이 개발자가 직접 정의한 타입은 Java의 기본 타입이 아닌 객체 타입이라는 사실**이다.
  * **Java의 기본 타입은 값을 대입하면 값을 복사하므로 공유 참조 문제가 발생할 수 없지만, 객체 타입은 참조값을 직접 대입하는 것을 막을 방법이 없다**.
  * 즉, 객체의 공유 참조는 피할 수 없다.

### 불변 객체란?
* 상술한 **객체 참조 공유로 인한 사이드 이펙트를 원천적으로 차단하는 방법은 객체를 수정이 불가능한 불변 객체로 만드는 것**이다.
  * 즉, 참조를 전달하는 방법을 막을 수 없으므로 대신 수정을 불가능하게 한다.
  * 따라서 **값 타입 역시 반드시 생성 시점 이후에는 값의 수정이 절대로 불가능한 불변 객체로 설계**해야 한다.
* **객체를 불변 객체로 만드는 경우, 객체의 생성자를 통해 값을 설정하고 세터 메소드는 제공하지 않아야** 한다.
  * 예를 들어 Java의 Integer 또는 String은 대표적인 불변 객체에 해당한다.
* 이렇듯 **객체를 불변으로 정의하는 작은 제약만으로도 사이드 이펙트라는 커다란 재앙을 미연에 방지**할 수 있다.
* **값 객체의 값을 수정하고자 하는 경우, 값 객체의 세터를 활용하는 것이 아닌 완전히 새로운 값 객체를 만들어 바꿔 끼는 형태로 사용하는 것이 바람직**하다.
* **JPA에서 값 타입의 사이드 이펙트로 발생한 버그는 추적이 매우 어려우므로, 값 타입 등을 새로이 정의하는 경우에는 반드시 불변 객체로 정의**한다.

## 2022-07-25 Mon
### 값 타입의 비교
* **값 타입은 다른 인스턴인 경우에도 내부에 포함된 값이 같은 경우, 동일하다고 판정할 수 있어야 한다**.
  * 예를 들어, 2차원 좌표계의 한 점을 의미하는 값 타입인 Point 클래스의 경우 `new Point(1, 1).equals(new Point(1, 1));`의 결과는 true여야 한다.
* 이 때, 두 값의 비교에 사용되는 기준은 다음과 같다.
  1. 동일성 비교: == 연산자를 활용하며, 객체의 참조 값을 비교한다.
  2. 동등성 비교: equals 메소드를 활용하며, 인스턴스가 갖는 값 자체를 비교한다.
* **값 타입은 equals 메소드를 활용한 동등성 비교를 통해 동등성을 비교해야하므로, 값 타입 객체는 반드시 equals 메소드를 적절하게 재정의**해야 한다.
  * 이 때, **equals 메소드는 왠만해서는 IDE가 자동으로 재정의해주는 것을 사용하는 것이 바람직**하다.
  * 사실 실무에서는 엄격한 요구사항에 맞추어 equals 메소드를 통해 값 타입을 비교하는 경우가 많지는 않다.

### 값 타입 컬렉션이란?
* 값 타입 컬렉션이란, 마치 연관 관계 매핑에서 엔티티를 컬렉션에 담아 사용하는 것처럼 값 타입을 컬렉션에 담아 사용하는 것을 의미한다.
  * 이 경우, **관계형 데이터베이스는 컬렉션을 동일한 테이블에 저장할 수 없으므로 각 컬렉션은 FK를 갖는 별도의 테이블 형태로 관리**되어야 한다.
  * 또한, 해당 테이블의 PK는 FK에 더해 전체 컬럼의 값을 조합한 결과가 된다.
  * **별도로 분리되는 테이블을 식별자 기반으로 관리할 경우, 해당 테이블은 값 타입이 아닌 엔티티로 승격되어야 하므로 식별자를 사용하지 않게 된다**.
* 값 타입 컬렉션은 값 타입을 하나 이상 저장하기 위해서 사용하며, @ElementCollection과 @CollectionTable 어노테이션을 사용한다.
  * @ElementCollection: 임의의 엔티티가 갖는 값 타입 컬렉션 필드에 명시한다.
  * @CollectionTable: 역시 엔티티가 갖는 값 타입 컬렉션 필드에 명시하며, name 속성에 값 타입 컬렉션을 관리할 테이블 매핑 정보를 정의한다.
  * **@CollectionTable 어노테이션의 경우, joinColumns 속성을 통해 분리된 테이블에서 사용할 FK 정보를 명시**한다.
* 아래와 같은 `Set<String>`의 경우, @Column 어노테이션을 통해 값이 저장될 컬럼명을 명시할 수 있다.
  * **반면, `List<Address> addresses` 와 같은 복합 값 타입 컬렉션의 경우, 이러한 컬럼 명의 명시가 불가능**하다.
  * 이 경우에는 복합 값 타입 내부에 포함된 컬럼 명 규칙을 따르거나, @AttributeOverride 어노테이션을 활용할 수 있다.
```
@Entity
public class Member {
  // ...생략
  @ElementCollection
  @CollectionTable(
    name = "FAVORITE_FOOD",
    joinColumns = @JoinColumn(name = "MEMBER_ID")
  )
  @Column(name = "FOOD_NAME")
  private Set<String> favoriteFoods = new HashSet<>();
  // ...생략 
}
```

### 값 타입 컬렉션의 활용
```
> 값 타입 컬렉션은 영속성 전이와 고아 객체 제거 기능을 필수적으로 가지는 것으로 이해할 수 있다.
```
* **값 타입 컬렉션 역시 자신만의 독립된 생명 주기를 갖지 않으며, 자신을 소유한 엔티티에 의해 생명 주기가 관리**된다.
  * 이는 **엔티티에 일반적으로 작성되는 필드인 `private String name;` 등과 값 타입 컬렉션 필드가 별 다를 바 없으며, 동일하게 취급됨을 의미**한다.
* **값 타입 컬렉션의 경우, 종속된 엔티티가 영속화되는 시점에 자동으로 함께 INSERT** 된다.
  * 상술한 이유와 마찬가지이며, 값 타입 컬렉션 역시 다른 기본 값 타입과 마찬가지로 엔티티가 추가하거나 수정함에 따라 영속화된다.
* 값 타입 컬렉션을 포함하는 엔티티를 조회하는 경우, JPA는 기본적으로 해당 엔티티에 대해서 조회하는 SQL 만을 생성하여 요청한다.
  * 즉, **값 타입 컬렉션은 기본적으로 지연 로딩이 적용**된다.
  * 이는 @ElementCollection에 적용 가능한 속성인 fetch가 기본적으로 LAZY로 설정되어 있기 때문이며, 당연히 지연 로딩을 적용하는 것이 바람직하다.
* **값 타입을 수정하는 경우, 값 타입의 필드 하나하나에 세터를 추가하는 것보다는 값 타입 자체를 갈아 치워 불변성을 유지하는 것이 바람직**하다.
  * 앞서 다룬 바와 같이, **값 타입은 불변 객체로서 기능해야 하며 개 별 필드를 수정하지 못하도록 막는 것이 사이드 이펙트를 줄일 수 있는 방법**이다.
  * 값 타입의 세터를 사용하는 방식은 프로젝트가 작을 때는 정상 동작하지만, 프로젝트가 성숙할수록 해결이 어려운 오류 발생 가능성이 높아진다.
* 값 타입 컬렉션의 경우, 다른 값 타입과 마찬가지로 자신의 생명 주기를 소유 엔티티에 맡긴다.
* 예를 들어 **기본 값 타입 컬렉션을 수정하는 경우, remove 메소드를 활용하여 우선 기존 요소를 제거한 후에 수정 대상 요소를 추가하는 방식을 선택**한다.
  * 기본 값의 경우 이미 불변 객체이므로 이러한 방식을 선택할 수 밖에 없다.
  * 이러한 동작은 JPA에 의해 기존 row를 우선 제거하고 새로이 수정된 row를 추가하는 방식으로 동작한다.
  * 이렇듯 **컬렉션의 내용만 변경하더라도 JPA 변경 사항 감지 기능의 대상이 되어 자동으로 수정 사항이 데이터베이스에 반영**된다.
* 반면, **복합 값 타입 컬렉션의 경우 복합 값 타입을 수정하는 경우와 마찬가지로 기존 복합 값 타입을 제거한 후 새로운 복합 값 타입을 추가**해야 한다.
  * 이 때, **컬렉션은 기본적으로 동일한 요소를 검색하는 데에 equals 메소드를 사용하므로 반드시 복합 값 타입의 equals 메소드를 재정의**해두어야 한다.
  * 모든 컬렉션이 이러한 방식으로 동작하지는 않지만, 대부분의 컬렉션이 이 방식으로 동작하므로 equals 메소드의 재정의는 중요하다.
* 즉, 복합 값 타입의 수정은 다음과 같은 코드로 작성해볼 수 있다.
```
List<Address> found = member.getAddresses();
found.remove(new Address("old", "street", "1"); // Address 클래스에는 equals 메소드가 재정의되어 있으므로, 기존 값은 제거된다.
found.add(new Address("new", "street", "1");
```
* 그러나 이러한 코드는 member 엔티티와 연관된 모든 복합 값 테이블의 모든 row를 제거한 후에 다시 모두 추가하는 방식으로 동작한다.

### 값 타입 컬렉션과 제약사항
```
> 값 타입 컬렉션은 사용을 지양해야 한다.
```
* 값 타입은 엔티티와 달리 식별자가 존재하지 않으므로, 변경 시 추적이 매우 어렵다.
* 때문에 **JPA는 값 타입 컬렉션에 변경 사항이 발생한 경우, 우선 소유자 엔티티와 연관된 모든 데이터를 제거**한다.
  * **그 후에 현재 값 타입 컬렉션에 맞는 데이터를 다시 영속화**한다.
  * **값 타입 컬렉션을 이렇듯 비효율적인 동작 방식을 기본 동작으로 갖기 때문에 사용을 지양하는 것이 바람직**하다.
* **값 타입 컬렉션을 매핑하는 테이블은 모든 컬럼을 묶어서 기본 키를 구성해야 하며, 이로 인해 NOT NULL과 UNIQUE 제약 조건**을 갖는다.
  * 명확한 이유가 있다기보단, FK와 복합 값 타입에 포함되는 필드 정보만을 갖는 테이블에서 적절한 PK를 선정하는 기준이 모든 컬럼을 묶는 것 말고는 없다.

### 값 타입 컬렉션의 대안
* 값 타입 컬렉션은 상술한 바와 같이 복잡하고, 너무 많은 제약을 갖는 문제점이 존재하므로 다른 방식으로 접근하는 것이 더 좋은 결과를 낳을 수 있다.
* 예를 들어, **실무에서 자주 사용되는 방법으로는 상황에 따라 값 타입 컬렉션 대신 일대 다 관계를 적용하는 것을 고려**할 수 있다.
  * **일대 다 연관 관계로 풀어내기 위해서는 우선 매핑을 위한 엔티티를 정의하며, 엔티티 내부에서 값 타입을 컬렉션 없이 사용**할 수 있다.
  * 즉, `List<Address> addresses` 보다는 AddressEntity 와 같은 별도의 엔티티를 추가하여 값 타입을 엔티티로 승격시킬 수 있다.
* 이 때, **영속성 전이와 고아 객체 제거 기능을 적용하여 해당 엔티티를 마치 값 타입 컬렉션처럼 활용하는 것이 바람직**하다.

### 값 타입 컬렉션은 절대로 사용하지 말아야 할까?
* **값 타입 컬렉션은 아주 간단한 요구사항을 구현하는 경우에 고려**할 수 있다.
* 즉, 추적할 필요도 없을 뿐더러 값이 수정되더라도 UPDATE 쿼리를 적용할 필요 없을 정도로 영향이 미미할 때 사용할 수 있다.
  * 거꾸로 말하자면, 이러한 경우 외에는 값 타입 컬렉션의 사용을 지양하는 것이 바람직하다.

### 엔티티 타입과 값 타입의 비교
* 엔티티 타입은 식별자를 가지며, 개별 데이터를 구분할 수 있다.
  * 반면, 값 타입은 식별자가 없으므로 개별 데이터를 구분할 수 없다.
* 엔티티 타입은 생명 주기를 관리해주어야 한다.
  * 반면, 값 타입은 엔티티에 의존적으로 생명 주기가 관리되어야 한다.
* 엔티티 타입은 여러 요구 사항에서 공유하여 사용할 수 있다.
  * 반면, 값 타입은 기본적으로 공유하지 않는 것이 안전하다.
  * 어쩔 수 없이 공유해야만 하는 경우에는 복사해서 사용하는 것이 난해한 버그로부터 안전하며, 공유되더라도 수정할 수 없도록 반드시 불변 객체로 만들어야 한다.

### 엔티티 타입과 값 타입의 결론
* **값 타입은 정말로 값 타입임이 확신되는 경우에만 사용하는 것이 바람직하며, 절대로 엔티티와 값 타입을 혼동하여 엔티티를 값 타입으로 정의하지 않아야 한다**.
  * 예를 들어, **식별자가 필요하고 지속적으로 값을 변경하거나 수정해야하는 경우에는 값 타입이 아닌 엔티티로 정의하는 것이 바람직**하다.
  * 실무에서는 값 타입을 임의로 정의하여 사용할 일이 생각만큼 자주 발생하지는 않는다.

### 값 타입 매핑하기
* **값 타입은 반드시 여러 클래스에서 중복되는 값을 대상으로 추출할 필요는 없으며, 코드의 가독성을 높여줄 수 있다면 하나의 클래스에서도 추출**할 수 있다.
* 값 타입에 equals 메소드를 재정의하는 경우, IntelliJ의 도움을 받는다면 `Use getters during code generation` 옵션을 사용하는 것이 바람직하다.
  * 그렇지 않는 경우에는 필드에 직접 접근하게 되며, 이는 프록시 객체에서 정상 동작하지 않는다.
  * 이렇듯 **JPA에서는 항상 프록시 객체인 경우를 고려하여 메소드를 통해 필드에 접근하도록 코드를 구현하는 것이 바람직**하다.
* 값 타입을 적절히 사용하는 경우, 값 타입 자체에 의미 있는 메소드를 구현하여 값 타입을 사용하는 엔티티 내부적으로 코드를 재사용할 수 있다.
* 또한, 값 타입이 갖는 필드들에게 길이 제약 조건 등을 정의할 때도 공통으로 관리되는 값 타입 클래스에서 한 번에 적용할 수 있다.
  * 즉, **값 타입을 사용하면 JPA를 활용하는 애플리케이션의 가독성괴 유지보수성을 높이는 데에 도움을 받을 수 있다**.
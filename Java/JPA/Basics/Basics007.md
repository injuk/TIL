# Basics
## 2022-07-22 Fri

### 프록시를 왜 사용해야 할까? 
* 예를 들어 회원과 팀 엔티티가 다대 일 연관 관계를 맺는 경우, 비즈니스 로직은 다음과 같이 구분될 수 있다.
  1. 회원을 사용할 때 팀 엔티티를 함께 사용하는 경우
  2. 또는 회원을 사용할 때 팀 엔티티는 사용하지 않는 경우
* 두 번째 경우, 회원 엔티티를 다루는 애플리케이션 로직을 위해 반드시 팀 엔티티를 함께 JOIN하는 것은 과할 수 있다.
  * 이는 **최적화되지 않은 경우에 해당하며, 따라서 어떤 경우에 팀을 가져오고 가져오지 않을지 결정할 수 있어야** 한다.
  * **JPA에서는 이를 지연 로딩과 프록시 개념을 통해 해결**하고자 하였다.

### em.getReference 메소드
* **JPA에서는 em.find 이외에도 em.getReference라는 별도의 메소드를 제공**한다.
  * em.find 메소드는 데이터베이스에 영속화된 실제 엔티티 객체를 조회한다.
  * 반면, **em.getReference 메소드는 데이터베이스의 조회를 미루는 가짜 엔티티 객체인 프록시 객체를 조회**한다.
* **em.getReference 메소드를 활용할 경우, 데이터베이스에 실제 쿼리 요청을 수행하지 않음에도 마치 객체를 조회하는 것처럼 동작**할 수 있다.
  * **em.getReference 메소드로 반환된 프록시 객체의 SELECT 쿼리는 엔티티 조회 시점이 아닌, 프록시 객체의 필드에 최초로 접근하는 시점에 요청**된다.
* **em.getReference 메소드를 통해 반환되는 객체는 개발자가 실제로 작성한 엔티티 클래스가 아닌, JPA가 내부적으로 자동 생성하는 프록시 클래스**이다.
* **em.getReference 메소드를 통해 반환되는 객체의 필드 중 `Entity target`은 반환 시점에 우선 null로 초기화**된다.
  * Entity 타입은 개발자가 작성한 엔티티 클래스일 수 있으며, 예를 들어 Member 타입일 수 있다.

### 프록시란?
* 프록시 클래스는 실제 클래스를 상속 받아서 생성되며, 실제 클래스와 같은 API를 갖는다.
  * **JPA의 프록시 클래스 역시 여러 프록시 라이브러리를 활용하여 내부적으로 생성**된다.
  * 때문에 이론적으로는 클라이언트 코드에서 실제 클래스의 객체와 프록시 클래스의 객체를 구분하지 않고 사용할 수 있어야 한다.
* 특정한 엔티티의 프록시 객체는 실제 객체의 참조를 `Entity target` 필드에 보관한다.
  * 이 때, **프록시 객체를 호출하면 프록시 객체는 실제 객체의 메소드를 호출하는 식으로 요청을 포워딩**한다.
  * 그러나 em.getReference 메소드를 최초로 호출한 시점에 반환된 프록시 객체의 target은 null로 초기화되어 있으므로, 해당 필드를 초기화할 필요가 있다.

### 프록시 객체의 초기화 과정
* em.getReference 메소드로 반환받은 프록시 객체를 통해 실제 엔티티의 API를 호출하는 과정은 다음과 같다.
  1. 클라이언트 코드로부터 em.getReference 메소드를 호출한다.
  2. JPA는 실제 엔티티를 상속받는 프록시 객체를 반환하며, 이 시점에서 데이터베이스에 대해 실제로 SELECT 쿼리를 요청하지는 않는다.
  3. 클라이언트 코드로부터 엔티티가 제공하는 임의의 API를 호출한다.
  4. **JPA는 프록시 객체의 target 필드가 초기화되어 있지 않음을 확인하고, 영속성 컨텍스트에 target 필드의 초기화를 요청**한다.
  5. 영속성 컨텍스트는 요청을 수신한 후, 데이터베이스에 영속화된 데이터를 조회한다.
     * 이 시점에서 데이터베이스에 실제 SELECT 쿼리가 요청된다.
  6. 영속성 컨텍스트는 조회한 데이터를 토대로 실제 엔티티 객체를 생성한다.
  7. **영속성 컨텍스트는 프록시 객체의 target 필드를 통해 영속성 컨텍스트가 생성한 엔티티 객체의 참조를 연결하며, 클라이언트가 호출한 API를 포워딩**한다.
* **이를 통해 실제 엔티티에 대한 참조가 프록시 객체의 target 필드에 캐싱되므로, 이후의 요청에 대해서는 데이터베이스를 반드시 조회할 필요는 없어진다**.
  * 즉, 실제 엔티티 객체를 통해 한 번 초기화된 프록시 객체를 다시 초기화할 필요는 없다.
* 이러한 프록시 객체의 동작 원리는 JPA의 표준 스펙에 정의되어 있지 않은 개념이며, 하이버네이트 또는 프록시 라이브러리 등이 임의로 구현하는 동작이다.

### 프록시 객체의 특징
* **프록시 객체는 처음 사용하는 시점에 최초 1회만 초기화하며, 이 과정을 통해 프록시 객체가 실제 엔티티로 변경되는 것은 아니다**.
  * 대신 프록시 객체가 초기화된 후, 실제 엔티티에 대한 참조를 갖게 되므로 접근이 가능해진다.
* 프록시 객체는 원본 엔티티 객체를 상속받는 새로운 객체이므로, 타입 확인 시에는 주의를 기울여야 한다.
  * 예를 들어, **== 비교는 실패하므로 대신 instanceof 를 사용**하도록 한다.
  * 나아가 **JPA를 사용하는 경우, 엔티티의 비교에서는 가능한 한 == 비교보다는 instanceof 메소드를 사용하는 것이 바람직**하다.
  * 이렇듯 **프록시 객체를 활용하는 경우, 언제든지 애플리케이션 로직에 실제 엔티티 객체가 아닌 프록시 객체가 전달될 수도 있다는 점을 고려**해야 한다.
* **영속성 컨텍스트에 대상 엔티티가 이미 존재하는 경우에는 getReference 메소드를 다시 호출하더라도 실제 엔티티가 반환**된다.
* **영속성 컨텍스트가 관리하지 않는 준영속 상태의 경우, 프록시를 초기화하려는 시도는 예외를 발생**시킨다.
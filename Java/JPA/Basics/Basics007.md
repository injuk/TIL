# Basics
## 2022-07-22 Fri

### 프록시를 왜 사용해야 할까? 
* 예를 들어 회원과 팀 엔티티가 다대 일 연관 관계를 맺는 경우, 비즈니스 로직은 다음과 같이 구분될 수 있다.
  1. 회원을 사용할 때 팀 엔티티를 함께 사용하는 경우
  2. 또는 회원을 사용할 때 팀 엔티티는 사용하지 않는 경우
* 두 번째 경우, 회원 엔티티를 다루는 애플리케이션 로직을 위해 반드시 팀 엔티티를 함께 JOIN하는 것은 과할 수 있다.
  * 이는 **최적화되지 않은 경우에 해당하며, 따라서 어떤 경우에 팀을 가져오고 가져오지 않을지 결정할 수 있어야** 한다.
  * **JPA에서는 이를 지연 로딩과 프록시 개념을 통해 해결**하고자 하였다.

### em.getReference 메소드
* **JPA에서는 em.find 이외에도 em.getReference라는 별도의 메소드를 제공**한다.
  * em.find 메소드는 데이터베이스에 영속화된 실제 엔티티 객체를 조회한다.
  * 반면, **em.getReference 메소드는 데이터베이스의 조회를 미루는 가짜 엔티티 객체인 프록시 객체를 조회**한다.
* **em.getReference 메소드를 활용할 경우, 데이터베이스에 실제 쿼리 요청을 수행하지 않음에도 마치 객체를 조회하는 것처럼 동작**할 수 있다.
  * **em.getReference 메소드로 반환된 프록시 객체의 SELECT 쿼리는 엔티티 조회 시점이 아닌, 프록시 객체의 필드에 최초로 접근하는 시점에 요청**된다.
* **em.getReference 메소드를 통해 반환되는 객체는 개발자가 실제로 작성한 엔티티 클래스가 아닌, JPA가 내부적으로 자동 생성하는 프록시 클래스**이다.
* **em.getReference 메소드를 통해 반환되는 객체의 필드 중 `Entity target`은 반환 시점에 우선 null로 초기화**된다.
  * Entity 타입은 개발자가 작성한 엔티티 클래스일 수 있으며, 예를 들어 Member 타입일 수 있다.

### 프록시란?
* 프록시 클래스는 실제 클래스를 상속 받아서 생성되며, 실제 클래스와 같은 API를 갖는다.
  * **JPA의 프록시 클래스 역시 여러 프록시 라이브러리를 활용하여 내부적으로 생성**된다.
  * 때문에 이론적으로는 클라이언트 코드에서 실제 클래스의 객체와 프록시 클래스의 객체를 구분하지 않고 사용할 수 있어야 한다.
* 특정한 엔티티의 프록시 객체는 실제 객체의 참조를 `Entity target` 필드에 보관한다.
  * 이 때, **프록시 객체를 호출하면 프록시 객체는 실제 객체의 메소드를 호출하는 식으로 요청을 포워딩**한다.
  * 그러나 em.getReference 메소드를 최초로 호출한 시점에 반환된 프록시 객체의 target은 null로 초기화되어 있으므로, 해당 필드를 초기화할 필요가 있다.

### 프록시 객체의 초기화 과정
* em.getReference 메소드로 반환받은 프록시 객체를 통해 실제 엔티티의 API를 호출하는 과정은 다음과 같다.
  1. 클라이언트 코드로부터 em.getReference 메소드를 호출한다.
  2. JPA는 실제 엔티티를 상속받는 프록시 객체를 반환하며, 이 시점에서 데이터베이스에 대해 실제로 SELECT 쿼리를 요청하지는 않는다.
  3. 클라이언트 코드로부터 엔티티가 제공하는 임의의 API를 호출한다.
  4. **JPA는 프록시 객체의 target 필드가 초기화되어 있지 않음을 확인하고, 영속성 컨텍스트에 target 필드의 초기화를 요청**한다.
  5. 영속성 컨텍스트는 요청을 수신한 후, 데이터베이스에 영속화된 데이터를 조회한다.
     * 이 시점에서 데이터베이스에 실제 SELECT 쿼리가 요청된다.
  6. 영속성 컨텍스트는 조회한 데이터를 토대로 실제 엔티티 객체를 생성한다.
  7. **영속성 컨텍스트는 프록시 객체의 target 필드를 통해 영속성 컨텍스트가 생성한 엔티티 객체의 참조를 연결하며, 클라이언트가 호출한 API를 포워딩**한다.
* **이를 통해 실제 엔티티에 대한 참조가 프록시 객체의 target 필드에 캐싱되므로, 이후의 요청에 대해서는 데이터베이스를 반드시 조회할 필요는 없어진다**.
  * 즉, 실제 엔티티 객체를 통해 한 번 초기화된 프록시 객체를 다시 초기화할 필요는 없다.
* 이러한 프록시 객체의 동작 원리는 JPA의 표준 스펙에 정의되어 있지 않은 개념이며, 하이버네이트 또는 프록시 라이브러리 등이 임의로 구현하는 동작이다.

### 프록시 객체의 특징
* **프록시 객체는 처음 사용하는 시점에 최초 1회만 초기화하며, 이 과정을 통해 프록시 객체가 실제 엔티티로 변경되는 것은 아니다**.
  * 대신 프록시 객체가 초기화된 후, 실제 엔티티에 대한 참조를 갖게 되므로 접근이 가능해진다.
* 프록시 객체는 원본 엔티티 객체를 상속받는 새로운 객체이므로, 타입 확인 시에는 주의를 기울여야 한다.
  * 예를 들어, **== 비교는 실패하므로 대신 instanceof 를 사용**하도록 한다.
  * 나아가 **JPA를 사용하는 경우, 엔티티의 비교에서는 가능한 한 == 비교보다는 instanceof 메소드를 사용하는 것이 바람직**하다.
  * 이렇듯 **프록시 객체를 활용하는 경우, 언제든지 애플리케이션 로직에 실제 엔티티 객체가 아닌 프록시 객체가 전달될 수도 있다는 점을 고려**해야 한다.
* **영속성 컨텍스트에 대상 엔티티가 이미 존재하는 경우에는 getReference 메소드를 다시 호출하더라도 실제 엔티티가 반환**된다.
  * 때문에 아래의 코드는 모두 Member.class가 출력되며, 이는 프록시 객체를 반환하는 getReference 역시 동일하다.
  * **영속성 컨텍스트에 원본 엔티티가 관리되고 있는 경우, 프록시를 만드는 것은 단점이 더 크므로 JPA는 성능 최적화를 위해 1차 캐시의 원본을 반환**한다.
  * 무엇보다도, **JPA는 반드시 같은 트랜잭션 안에서 동일한 식별자를 갖는 엔티티 간의 동일성을 보장해야 하기 떄문이기도**하다.
  * 같은 이유에서 동일한 식별자에 대해 em.getReference를 여러 번 호출하더라도 동일성을 보장하기 위해 항상 같은 프록시 객체가 반환된다. 
```
Member m1 = em.find(Member.class, 1L);
System.out.println(m1.getClass());
Member m2 = em.getReference(Member.class, 1L);
System.out.println(m2.getClass());
```
* 이렇듯 JPA가 같은 트랜잭션 안에서 동일한 식별자를 사용하는 엔티티에 대해 동일성을 보장한다는 점은 매우 중요하며, 다음과 같은 코드 역시 true가 출력된다.
  * m1은 getReference에 의해 프록시 객체가 반환된다.
  * **m2는 find를 사용하므로 실제 엔티티 객체가 반환되어야 할 것 같지만, 한 번 프록시를 통해 조회한 엔티티는 동일성 보장을 위해 프록시를 반환**한다.
  * 즉, 이는 상술한 특징의 역도 성립한다는 점을 의미한다.
```
// m1과 m2에 대한 getClass() 호출은 모두 프록시 클래스를 반환한다.
Member m1 = em.getReference(Member.class, 1L);
Member m2 = em.find(Member.class, 1L);
System.out.println(m1 == m2);
```
* **영속성 컨텍스트가 관리하지 않는 준영속 상태의 경우, 프록시를 초기화하려는 시도는 예외를 발생**시킨다.
  * 예를 들어 em.detach, em.close, em.clear 등의 메소드 호출을 통해 영속성 컨텍스트와의 연결성을 단절시키는 경우에 해당한다.
  * **이러한 상황에서 프록시 객체는 영속성 컨텍스트의 도움을 받을 수 없으므로, 메소드 호출 등 원본 엔티티의 API에 접근하려는 시도는 예외가 발생**한다.
  * **하이버네이트의 경우 `LazyInitializationException` 예외가 발생하며, 이는 실무에서도 굉장히 자주 마주치는 상황 중 하나**이기도 하다.
  * 예를 들어, 주로 영속성 컨텍스트와 트랜잭션의 생명 주기를 맞추도록 구현하므로 트랜잭션 종료 후에 영속성 컨텍스트에 접근하려는 시도는 실패한다.
* 상술한 이유에서 **JPA를 통해 프록시를 활용하는 경우, 반환된 객체가 프록시 클래스이건 엔티티 클래스이건 상관 없이 동작하도록 구현하는 것이 이상적**이다.

### 프록시의 상태 확인하기
* `PersistenceUnitUtil.isLoaded(Object entity)` 메소드를 통해 프록시 객체의 초기화 여부를 확인할 수 있다.
  * 이 떄, PersistenceUnitUtil 객체는 `emf.getPersistenceUnitUtil()` 메소드를 호출하여 얻을 수 있다. 
* `entity.getClass().getName()` 메소드를 통해 프록시 객체의 클래스를 확인할 수 있다.
* `org.hibernate.Hibernate.initializa(entity)` 메소드를 통해 프록시를 강제로 초기화할 수 있다.
  * **프록시 객체에 대해 강제 초기화를 수행할 경우, 그 시점에 실제 데이터베이스에 대한 SELECT 쿼리가 요청**된다. 
  * JPA의 표준 스펙에는 프록시 객체의 강제 초기화와 관련된 기능이 없으며, 이는 하이버네이트가 구현한 독자적인 기능이다.
  * 이렇듯 JPA의 표준에는 강제 초기화 기능이 존재하지 않으므로, 원칙적으로는 원본 엔티티가 제공하는 API를 명시적으로 호출하는 방식을 사용해야 한다.
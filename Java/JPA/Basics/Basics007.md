# Basics
## 2022-07-22 Fri

### 프록시를 왜 사용해야 할까? 
* 예를 들어 회원과 팀 엔티티가 다대 일 연관 관계를 맺는 경우, 비즈니스 로직은 다음과 같이 구분될 수 있다.
  1. 회원을 사용할 때 팀 엔티티를 함께 사용하는 경우
  2. 또는 회원을 사용할 때 팀 엔티티는 사용하지 않는 경우
* 두 번째 경우, 회원 엔티티를 다루는 애플리케이션 로직을 위해 반드시 팀 엔티티를 함께 JOIN하는 것은 과할 수 있다.
  * 이는 **최적화되지 않은 경우에 해당하며, 따라서 어떤 경우에 팀을 가져오고 가져오지 않을지 결정할 수 있어야** 한다.
  * **JPA에서는 이를 지연 로딩과 프록시 개념을 통해 해결**하고자 하였다.

### em.getReference 메소드
* **JPA에서는 em.find 이외에도 em.getReference라는 별도의 메소드를 제공**한다.
  * em.find 메소드는 데이터베이스에 영속화된 실제 엔티티 객체를 조회한다.
  * 반면, **em.getReference 메소드는 데이터베이스의 조회를 미루는 가짜 엔티티 객체인 프록시 객체를 조회**한다.
* **em.getReference 메소드를 활용할 경우, 데이터베이스에 실제 쿼리 요청을 수행하지 않음에도 마치 객체를 조회하는 것처럼 동작**할 수 있다.
  * **em.getReference 메소드로 반환된 프록시 객체의 SELECT 쿼리는 엔티티 조회 시점이 아닌, 프록시 객체의 필드에 최초로 접근하는 시점에 요청**된다.
* **em.getReference 메소드를 통해 반환되는 객체는 개발자가 실제로 작성한 엔티티 클래스가 아닌, JPA가 내부적으로 자동 생성하는 프록시 클래스**이다.
* **em.getReference 메소드를 통해 반환되는 객체의 필드 중 `Entity target`은 반환 시점에 우선 null로 초기화**된다.
  * Entity 타입은 개발자가 작성한 엔티티 클래스일 수 있으며, 예를 들어 Member 타입일 수 있다.

### 프록시란?
* 프록시 클래스는 실제 클래스를 상속 받아서 생성되며, 실제 클래스와 같은 API를 갖는다.
  * **JPA의 프록시 클래스 역시 여러 프록시 라이브러리를 활용하여 내부적으로 생성**된다.
  * 때문에 이론적으로는 클라이언트 코드에서 실제 클래스의 객체와 프록시 클래스의 객체를 구분하지 않고 사용할 수 있어야 한다.
* 특정한 엔티티의 프록시 객체는 실제 객체의 참조를 `Entity target` 필드에 보관한다.
  * 이 때, **프록시 객체를 호출하면 프록시 객체는 실제 객체의 메소드를 호출하는 식으로 요청을 포워딩**한다.
  * 그러나 em.getReference 메소드를 최초로 호출한 시점에 반환된 프록시 객체의 target은 null로 초기화되어 있으므로, 해당 필드를 초기화할 필요가 있다.

### 프록시 객체의 초기화 과정
* em.getReference 메소드로 반환받은 프록시 객체를 통해 실제 엔티티의 API를 호출하는 과정은 다음과 같다.
  1. 클라이언트 코드로부터 em.getReference 메소드를 호출한다.
  2. JPA는 실제 엔티티를 상속받는 프록시 객체를 반환하며, 이 시점에서 데이터베이스에 대해 실제로 SELECT 쿼리를 요청하지는 않는다.
  3. 클라이언트 코드로부터 엔티티가 제공하는 임의의 API를 호출한다.
  4. **JPA는 프록시 객체의 target 필드가 초기화되어 있지 않음을 확인하고, 영속성 컨텍스트에 target 필드의 초기화를 요청**한다.
  5. 영속성 컨텍스트는 요청을 수신한 후, 데이터베이스에 영속화된 데이터를 조회한다.
     * 이 시점에서 데이터베이스에 실제 SELECT 쿼리가 요청된다.
  6. 영속성 컨텍스트는 조회한 데이터를 토대로 실제 엔티티 객체를 생성한다.
  7. **영속성 컨텍스트는 프록시 객체의 target 필드를 통해 영속성 컨텍스트가 생성한 엔티티 객체의 참조를 연결하며, 클라이언트가 호출한 API를 포워딩**한다.
* **이를 통해 실제 엔티티에 대한 참조가 프록시 객체의 target 필드에 캐싱되므로, 이후의 요청에 대해서는 데이터베이스를 반드시 조회할 필요는 없어진다**.
  * 즉, 실제 엔티티 객체를 통해 한 번 초기화된 프록시 객체를 다시 초기화할 필요는 없다.
* 이러한 프록시 객체의 동작 원리는 JPA의 표준 스펙에 정의되어 있지 않은 개념이며, 하이버네이트 또는 프록시 라이브러리 등이 임의로 구현하는 동작이다.

### 프록시 객체의 특징
* **프록시 객체는 처음 사용하는 시점에 최초 1회만 초기화하며, 이 과정을 통해 프록시 객체가 실제 엔티티로 변경되는 것은 아니다**.
  * 대신 프록시 객체가 초기화된 후, 실제 엔티티에 대한 참조를 갖게 되므로 접근이 가능해진다.
* 프록시 객체는 원본 엔티티 객체를 상속받는 새로운 객체이므로, 타입 확인 시에는 주의를 기울여야 한다.
  * 예를 들어, **== 비교는 실패하므로 대신 instanceof 를 사용**하도록 한다.
  * 나아가 **JPA를 사용하는 경우, 엔티티의 비교에서는 가능한 한 == 비교보다는 instanceof 메소드를 사용하는 것이 바람직**하다.
  * 이렇듯 **프록시 객체를 활용하는 경우, 언제든지 애플리케이션 로직에 실제 엔티티 객체가 아닌 프록시 객체가 전달될 수도 있다는 점을 고려**해야 한다.
* **영속성 컨텍스트에 대상 엔티티가 이미 존재하는 경우에는 getReference 메소드를 다시 호출하더라도 실제 엔티티가 반환**된다.
  * 때문에 아래의 코드는 모두 Member.class가 출력되며, 이는 프록시 객체를 반환하는 getReference 역시 동일하다.
  * **영속성 컨텍스트에 원본 엔티티가 관리되고 있는 경우, 프록시를 만드는 것은 단점이 더 크므로 JPA는 성능 최적화를 위해 1차 캐시의 원본을 반환**한다.
  * 무엇보다도, **JPA는 반드시 같은 트랜잭션 안에서 동일한 식별자를 갖는 엔티티 간의 동일성을 보장해야 하기 떄문이기도**하다.
  * 같은 이유에서 동일한 식별자에 대해 em.getReference를 여러 번 호출하더라도 동일성을 보장하기 위해 항상 같은 프록시 객체가 반환된다. 
```
Member m1 = em.find(Member.class, 1L);
System.out.println(m1.getClass());
Member m2 = em.getReference(Member.class, 1L);
System.out.println(m2.getClass());
```
* 이렇듯 JPA가 같은 트랜잭션 안에서 동일한 식별자를 사용하는 엔티티에 대해 동일성을 보장한다는 점은 매우 중요하며, 다음과 같은 코드 역시 true가 출력된다.
  * m1은 getReference에 의해 프록시 객체가 반환된다.
  * **m2는 find를 사용하므로 실제 엔티티 객체가 반환되어야 할 것 같지만, 한 번 프록시를 통해 조회한 엔티티는 동일성 보장을 위해 프록시를 반환**한다.
  * 즉, 이는 상술한 특징의 역도 성립한다는 점을 의미한다.
```
// m1과 m2에 대한 getClass() 호출은 모두 프록시 클래스를 반환한다.
Member m1 = em.getReference(Member.class, 1L);
Member m2 = em.find(Member.class, 1L);
System.out.println(m1 == m2);
```
* **영속성 컨텍스트가 관리하지 않는 준영속 상태의 경우, 프록시를 초기화하려는 시도는 예외를 발생**시킨다.
  * 예를 들어 em.detach, em.close, em.clear 등의 메소드 호출을 통해 영속성 컨텍스트와의 연결성을 단절시키는 경우에 해당한다.
  * **이러한 상황에서 프록시 객체는 영속성 컨텍스트의 도움을 받을 수 없으므로, 메소드 호출 등 원본 엔티티의 API에 접근하려는 시도는 예외가 발생**한다.
  * **하이버네이트의 경우 `LazyInitializationException` 예외가 발생하며, 이는 실무에서도 굉장히 자주 마주치는 상황 중 하나**이기도 하다.
  * 예를 들어, 주로 영속성 컨텍스트와 트랜잭션의 생명 주기를 맞추도록 구현하므로 트랜잭션 종료 후에 영속성 컨텍스트에 접근하려는 시도는 실패한다.
* 상술한 이유에서 **JPA를 통해 프록시를 활용하는 경우, 반환된 객체가 프록시 클래스이건 엔티티 클래스이건 상관 없이 동작하도록 구현하는 것이 이상적**이다.

### 프록시의 상태 확인하기
* `PersistenceUnitUtil.isLoaded(Object entity)` 메소드를 통해 프록시 객체의 초기화 여부를 확인할 수 있다.
  * 이 떄, PersistenceUnitUtil 객체는 `emf.getPersistenceUnitUtil()` 메소드를 호출하여 얻을 수 있다. 
* `entity.getClass().getName()` 메소드를 통해 프록시 객체의 클래스를 확인할 수 있다.
* `org.hibernate.Hibernate.initializa(entity)` 메소드를 통해 프록시를 강제로 초기화할 수 있다.
  * **프록시 객체에 대해 강제 초기화를 수행할 경우, 그 시점에 실제 데이터베이스에 대한 SELECT 쿼리가 요청**된다. 
  * JPA의 표준 스펙에는 프록시 객체의 강제 초기화와 관련된 기능이 없으며, 이는 하이버네이트가 구현한 독자적인 기능이다.
  * 이렇듯 JPA의 표준에는 강제 초기화 기능이 존재하지 않으므로, 원칙적으로는 원본 엔티티가 제공하는 API를 명시적으로 호출하는 방식을 사용해야 한다.

### getReference 메소드는 실제로 자주 사용될까?
* 정작 실무에서는 em.getReference 메소드를 거의 사용하지 않는다.
* 그러나 em.getReference 메소드로 대표되는 프록시 메커니즘을 이해한 후에야 JPA가 제공하는 즉시 로딩과 지연 로딩 개념을 적절히 활용할 수 있게 된다.

## 2022-07-23 Sat
### @Lazy 어노테이션을 활용한 지연 로딩
```
> 지연 로딩으로 설정된 필드는 엔티티 조회시 프록시 객체 형태로 조회된다.
```
* 상술한 회원과 팀의 관계에서, 회원 정보만을 사용하는 애플리케이션 로직이라면 굳이 팀 정보를 함께 조회할 필요는 없다.
* 이 경우, **`@ManyToOne(fetch = FetchType.LAZY)` 형태의 어노테이션을 통해 지연 로딩을 적용**할 수 있다.
  * 해당 어노테이션은 정보를 필요할 때 조회하고자 하는 엔티티 필드에 명시한다.
* **`fetch = FetchType.LAZY`를 명시한 경우, 해당 어노테이션이 명시된 엔티티의 필드는 프록시 객체로 조회**된다.
  * 실제로 getClass 메소드를 통해 정보를 확인하면 프록시 객체 형태로 출력되는 것을 확인할 수 있다.
* 이렇듯 **지연 로딩이 적용된 필드는 앞서 다루었던 프록시와 동일한 방식으로 동작하여 해당 필드에 최초로 접근하는 시점에 데이터베이스에 쿼리를 요청**한다.
  * 이는 회원과 팀의 관계를 예로 들어, 회원 엔티티가 갖는 팀 필드에 최초 접근하는 경우가 아닌 팀 엔티티가 갖는 임의의 필드에 최초 접근하는 시점을 의미한다.
* **비즈니스 로직 상 연관 관계를 맺는 엔티티가 상대 엔티티에 접근하는 빈도가 높지 않다면 지연 로딩을 적용하는 것이 바람직**하다.

### @Eager 어노테이션을 활용한 즉시 로딩
* 반면, 비즈니스 로직 상 항상 회원과 팀 엔티티 모두를 함께 사용하는 경우라면 지연 로딩은 불필요하게 쿼리를 늘리므로 성능 상 단점이 존재한다.
* **이 경우, 해당 필드에 `@ManyToOne(fetch = FetchType.EAGER)`와 같은 형태의 어노테이션을 명시하여 두 엔티티를 동시에 즉시 로딩**할 수 있다.
  * 이 경우, 즉시 로딩이므로 프록시 객체를 사용할 필요가 없으므로 getClass 메소드를 통해 조회할 경우 실제 엔티티 클래스가 출력되는 것을 확인할 수 있다.
* 또한, 하이버네이트 등 대부분의 JPA 구현체는 즉시 로딩시 가능한 한 JOIN을 적용하여 SQL 요청 한 번으로 필요한 데이터를 조회한다.

### 프록시와 지연 로딩 - 주의사항
* 다음과 같은 이유에서, **실무에서는 가능한 한 지연 로딩만 사용하는 것이 바람직**하다.
  1. 즉시 로딩을 사용하는 경우, 예상치 못한 SQL 생성될 가능성이 높다.
  2. 즉시 로딩은 JPQL에서 N + 1 문제를 일으킬 수 있다.
* 특히 **@ManyToOne, @OneToOne 어노테이션은 기본적으로 즉시 로딩이 적용되므로, fetch 속성을 활용하여 지연 로딩을 설정**해주어야 한다.
  * 반면, @OneToMany와 @ManyToMany는 기본적으로 지연 로딩이 적용된다.

### 주의사항 해설하기
* 데이터베이스에서 JOIN 쿼리를 한 두개 작성한다고 해서 성능이 크게 떨어지지는 않지만, JOIN 대상 테이블이 늘어날수록 성능은 크게 떨어진다.
  * 때문에 EAGER 옵션을 적용하는 경우, 연관 관계가 설정된 모든 엔티티에 대해 JOIN하므로 성능이 크게 떨어질 가능성이 있다. 
  * 물론 아주 **작은 프로젝트라면 상관이 없으나, 프로젝트 규모가 커져 엔티티들의 관계가 복잡하게 얽힐수록 지연 로딩 설정은 선택이 아닌 필수**가 된다.
* 또한 N + 1 문제란, JPA가 JPQL로 작성된 내용을 SQL로 그대로 번역하기 때문에 발생하는 문제를 말한다.
  * 예를 들어 `select m from Member m`과 같은 쿼리는 내부적으로 우선 SQL로 번역되며, 그대로 번역될 경우 Team 엔티티에 대한 정보를 가져올 수 없다.
  * JPA는 Member 엔티티를 조회한 후 연관 관계 설정과 EAGER 옵션을 발견하므로, 그제서야 Team 엔티티를 조회하는 쿼리를 한 번 더 요청하게 된다.
  * **정말 큰 문제는 JPQL 결과 회원이 10개일 경우, 10개 모두에 대해 연결된 Team 엔티티에 대한 조회 쿼리를 하나씩 생성한다는 점**이다.
  * 결과적으로 **N + 1이란, 최초로 요청되는 `select * from Member` 쿼리에 더해 결과 N개 만큼의 추가 쿼리가 발생한다는 의미**를 갖는다.
  * 반면, **find 메소드의 경우 식별자를 명시하여 동작하므로 JPA에 의한 내부 최적화에 의해 자동으로 JOIN 쿼리가 생성되는 점에서 차이**가 있다.
* 물론 LAZY 설정에서도 결과마다 팀 엔티티에 접근하는 경우 같은 문제가 발생하지만, 이는 JPQL에서 제공되는 페치 조인을 활용하여 많은 부분을 극복할 수 있다.
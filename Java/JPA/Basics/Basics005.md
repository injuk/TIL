# Basics
## 2022-07-19 Tue

### 연관 관계 매핑 시 주의사항
* 연관 관계를 매핑하는 경우, 크게 다음과 같은 항목을 주의해야 한다.
  1. 다중성
  2. 단방향과 양방향
  3. 연관 관계의 주인

### 다중성
* 다중성이란, 매핑되는 두 엔티티 간의 비율을 의미하며 다음과 같이 구분된다.
  1. @ManyToOne
  2. @OneToMany
  3. @OneToOne
  4. @ManyToMany
* **JPA가 제공하는 모든 어노테이션은 실제 데이터베이스와 매핑하기 위한 기능이므로, 다중성 어노테이션 역시 같은 용도로 사용**된다.
  * 때문에 다중성 역시 데이터베이스 관점에서 고려되어야 하며, 어떤 다중성을 선택할지 확신되지 않는 경우에는 두 엔티티의 관계를 뒤집어 생각해본다.
  * 다중성은 대칭을 이루므로, 엔티티의 관계가 1:N이라면 두 엔티티를 바꾸어 생각해보았을 때 N:1 관계가 되어야 한다.
* 이 때, **실무에서는 M:N 관계를 의미하는 @ManyToMany의 사용을 지양하는 것이 바람직**하다.
  * 주로 @ManyToOne이 사용되며, 뒤이어 @OneToMany와 @OneToOne이 사용된다.

### 방향성
* 앞서 다룬 바와 같이, 관계형 데이터베이스의 테이블 구조는 FK만으로도 양방향 모두 JOIN 연산이 가능하다.
  * 즉, 근본적으로 방향성이라는 개념을 둘 필요가 없다.
* 반면 객체는 참조가 존재하는 필드 방향으로만 탐색이 가능하며, 이러한 참조의 존재 여부에 따라 단방향과 양방향 관계가 결정된다.
  * 엄밀히 말하자면 객체는 두 개의 단방향 연관 관계를 통해 양방향 연관 관계를 구성한다.

### 연관 관계의 주인
* 테이블은 FK 하나로 두 테이블이 연관 관계를 맺지만, 객체는 양방향 관계를 위한 참조가 각각 하나씩 존재해야 한다.
* 즉, **객체의 참조는 둘이지만 테이블의 FK는 하나이므로 둘 중 FK를 관리하기 위한 주체가 될 참조를 선정할 필요**가 있다.
  * 이 때, 연관 관계의 주인은 FK를 관리하는 참조를 의미한다.
  * 연관 관계의 주인이 아닌 참조는 FK의 관리에 전혀 영향을 주지 못하며, 오직 읽기 동작만이 가능하다.

### 다대 일 연관 관계
* **다대 일 연관 관계는 JPA에서 가장 자주 사용되며, 그만큼 중요한 연관 관계**이다.
  * 해당 연관 관계의 반대는 일대 다 연관 관계가 된다.
* 데이터베이스 설계 상, 다대 일 관계에서 FK는 항상 다 측의 테이블에 위치하게 된다.
  * 그렇지 못한 경우, 데이터베이스 설계가 잘못 된 것으로 이해할 수 있다.
* **다대 일 연관 관계의 수립 역시 FK가 존재하는 측의 엔티티에 참조를 정의한 후 연관 관계를 매핑하는 것으로 완료**된다.
* **다대 일 단방향 연관 관계를 적절히 수립해둔 경우, 추후 필요에 의해 양방향 연관 관계로 수정하더라도 테이블에는 아무런 영향을 주지 않는다**.
  * 이는 다대 일 단방향 연관 관계를 수립하는 과정에서 FK를 관리할 연관 관계의 주인이 이미 선정되었기 때문이다.
  * **반대 방향 연관 관계를 수립한다고 해도, 해당 연관 관계를 시작하는 엔티티는 연관 관계의 주인이 아니므로 FK에 영향을 줄 수 없다**.
  * 무엇보다, 반대 방향 연관 관계에서는 읽기 동작만이 가능하다.
* **연관 관계의 주인이 아닌 측은 `@OneToMany(mappedBy = "필드명")`과 같은 형태로 상대 편 엔티티의 필드에 의해 연관 관계가 매핑되었음을 명시**한다.
* 이렇듯 다대 일 양방향 연관 관계의 경우, 다음과 같은 조건을 충족하도록 구현되어야 한다.
  1. **FK가 있는 측 엔티티가 연관 관계의 주인**이 된다.
  2. 양 쪽 엔티티가 서로를 참조할 수 있도록 참조용 필드를 제공하여 구현한다.

### 일대 다 연관 관계
* 해당 연관 관계의 경우, 1인 측의 엔티티가 연관 관계의 주인이 되어 FK를 관리하게 된다.
  * 그러나 해당 연관 관계는 실무에서는 권장되지 않는 방식이기도 하다.
* 이는 상술한 시나리오에서, 마치 회원은 팀 정보에 접근할 필요가 없지만 팀은 회원 정보를 알아야하기에 연관 관계의 주인이 되는 경우에 해당한다.
* 그러나 **중요한 것은, 객체 사이의 관계는 이러한 연관 관계를 허용하지만 데이터베이스 상의 FK는 반드시 N 측의 엔티티에 포함되어야 한다는 사실**이다.
  * 이는 사실상 하나의 법칙으로 이해해도 무방하다.
* 결국 **이러한 방식은 마치 팀 객체에 포함된 회원 목록을 수정하지만 실제로는 회원 테이블의 FK가 수정되는 부자연스러운 시나리오를 갖게 된다**.
  * 이렇듯 일대 다 단방향 연관 관계의 경우, 객체와 테이블의 차이로 인해 연관 관계의 주인 엔티티 객체가 반대 편 엔티티의 테이블을 관리하는 구조를 갖게 된다.
* **이러한 방식은 @JoinColumn 어노테이션이 필수적으로 명시되어야 하며, 이를 원치 않을 경우에는 별도의 테이블을 두는 조인 테이블 방식을 사용**해야 한다.
  * 정확히는 @JoinColumn을 명시하지 않는 경우, 자동으로 조인을 위한 중간 테이블이 생성된다.
  * 이렇듯 중간 테이블이 생성되는 방식은 굳이 새로운 테이블을 생성하므로, 장기적인 유지보수성과 성능 상의 단점을 가질 수 밖에 없다.
  * 반면 @JoinColumn 어노테이션을 추가하는 경우를 예를 들어, 아래와 같은 부자연스러운 코드의 작성이 필수적이다.
```
@OneToMany
@JoinColumn(name = "team_id")
private List<Members> members = new ArrayList<>();
```
* **이 경우, 팀 엔티티에 회원을 추가하여 em.persist 등을 통해 데이터를 영속화할 경우 회원 테이블의 FK를 수정하기 위한 UPDATE 쿼리가 요청**된다.

### 일대 다 단방향 연관 관계의 단점
* 추가적인 UPDATE 쿼리 요청으로 인한 성능 상의 단점은 당연히 존재하지만, 이는 크게 체감될 정도의 문제는 되지 않곤 한다.
* 해당 방식이 정말 **문제가 되는 것은 애플리케이션 개발 과정에서 개발자가 예측하기 어려운, 옆 테이블에 대한 UPDATE 쿼리가 요청된다는 점**이다. 
  * 이는 JPA를 처음 사용하는 사람에게도 불편함을 주지만, JPA 숙련자조차 수십 개의 테이블이 상호작용하는 환경 속에서 운영을 어렵게 만드는 요인이 된다.
* 이러한 **단점은 모두 연관 관계의 주인인 엔티티가 관리해야 할 FK가 다른 테이블에 위치하기 때문으로, 이로 인해 불필요한 UPDATE 쿼리가 요청되는 것**이다.
* **가장 이상적인 것은 N:1 연관 관계를 기본으로 채택하되, 필요한 경우에 양방향 연관 관계를 추가하는 전략을 사용하는 것**이다.
  * **이러한 방식은 불필요한 객체 참조가 추가되므로 객체 지향적으로는 아쉬움이 있지만, 대신 전체적인 유지보수성을 끌어올리는 tradeoff에 해당**한다.
* **극단적으로는 처음부터 다대 일 단방향 연관 관계를 사용하는 것이 바람직하며, 다대 일 단방향 / 양방향 연관 관계를 적절히 활용하는 것**이다.
  * 이 경우 많은 문제가 깔끔하게 해결되며, 일대 다 연관 관계에 대해서 알 필요조차 없어진다.

### 일대 다 양방향 연관 관계?
* 이러한 연관 관계는 JPA의 스펙 상으로는 공식적으로 존재하지 않지만, 우회적인 방법을 사용하여 유사한 효과를 얻을 수 있다.
```
@ManyToOne
@JoinColumn(name = "team_id", insertable = "false", updatable = "false")
private Team team;
```
* 상술한 방식은 읽기 전용 필드를 추가하여 마치 양방향 연관 관계가 설정된 것처럼 사용하는 방식이다.
  * 이 때, insertable, updatable 속성을 명시하지 않는 경우 양방향 연관 관계를 설정한 모든 엔티티가 연관 관계의 주인처럼 동작한다.
  * 심지어 이러한 경우 하이버네이트는 오류를 발생시키지도 않으므로 큰 위험성이 수반될 수 있다.
  * 반면, 이렇듯 읽기 전용 필드로 설정하는 방식은 실무 환경이 복잡해짐에 따라 간혹 사용될 수도 있는 방식이다.
* **공식적으로 지원하지 않는 방식인 만큼 당연히 바람직한 접근은 아니며, 필요한 경우에는 다대 일 양방향 연관 관계를 사용**하도록 한다.
  * 즉, 일대 다 단방향 또는 양방향 연관 관계를 억지로 설정하는 것보다는 다대 일 연관 관계를 선택하는 것이 바람직하다.
  * 실무에서 테이블이 많아지고 환경이 복잡해질수록, 단순하고 누구나 이해할 수 있는 직관적인 설계와 매핑은 큰 빛을 발한다.

## 2022-07-20 Wed
### 일대 일 연관 관계
* 일대 일 연관 관계는 당연히 그 반대도 일대 일 연관 관계이며, 주 테이블 또는 대상 테이블 중 FK의 위치를 자유로이 선택할 수 있다.
  * 예를 들어, 주 테이블에 FK가 위치하거나 대상 테이블에 FK가 위치할 수 있다.
  * 이 경우, **FK에 데이터베이스 유니크 제약 조건을 추가**해야 한다.
* 일대 일 단방향 연관 관계를 구현하는 경우, 마치 @ManyToOne과 흡사한 아래와 같은 구조를 갖게 된다.
```
@OneToOne
@JoinColumn(name = "LOCKER_ID")
private Locker locker;
```
* 반면, 반대 측 연관 관계에는 반드시 mappedBy 속성을 명시해야 한다.
```
@OneToOne(mappedBy = "locker")
private Member member;
```
* 반면 **주 테이블이 아닌 대상 테이블에 FK를 두는 단방향 매핑은 불가능하며, JPA 역시 이를 지원하지 않는다**.
  * 일대 일 연관 관계의 경우, 엔티티가 자신의 테이블에 FK를 두어 연관 관계의 주인이 되는 경우만 매핑이 가능하다.

### 일대 일 연관 관계의 주 테이블 방식과 대상 테이블 방식
* 주 테이블에 FK를 두는 방식은 마치 주 객체가 대상 객체의 참조를 갖듯, 주 테이블에 FK를 두고 대상 테이블을 탐색한다.
  * 이는 객체 지향 개발자가 선호하는 방식이며, JPA와 매핑하기도 편리하다.
  * **해당 방식은 주 테이블만 조회해도 대상 테이블에 데이터가 있는지 확인할 수 있으나, 값이 없으면 FK에 null을 허용**하게 된다.
* 대상 테이블에 FK를 두는 방식은 전통적인 데이터베이스 개발자가 선호하는 방식이다.
  * **해당 방식은 주 테이블과 대상 테이블의 관계를 일대 일에서 일대 다로 변경할 때 테이블 구조를 그대로 유지**할 수 있다.
  * 그러나 **프록시 기능의 한계로, 지연 로딩으로 설정하더라도 언제나 즉시 로딩된다는 단점 역시 존재**한다.
  * 또한, **근본적으로 해당 방식은 일대 일 단방향 연관 관계를 매핑할 수 없으므로 불필요하게 일대 일 양방향 관계를 매핑**하게 된다.
* **일반적으로, 실무에서는 주 테이블에 FK를 두는 단방향 연관 관계 설정 방식이 권장**된다.
  * 그러나 이러한 방식은 DBA들이 좋아하지 않는 방식이므로, 충분한 협의 후에 정의를 결정지어야 한다.

### 다대 다 연관 관계
* **다대 다 연관 관계는 JPA가 지원하는 기능이지만, 실무에서는 사용하지 않는 것이 바람직한 연관 관계에 해당**한다.
  * 관계형 데이터베이스는 정규화된 테이블 2개로는 다대 다 관계를 표현할 방법 자체가 없다.
  * 때문에 **이러한 경우에는 중간 연결 용도인 매퍼 테이블을 두어 일대 다 및 다대 일 관계로 풀어낼 필요**가 있다.
* 반면, 두 객체는 각각 상대 타입의 컬렉션을 사용해서 다대 다 관계를 손 쉽게 구현할 수 있다.
  * 객체가 가능한 것을 ORM 차원에서도 기능적으로 지원할 수 있어야 하기 때문에 JPA 역시 다대 다 관계를 지원한다.
  * 이 때, JPA에 의해 구현되는 다대 다 관계는 관계형 데이터베이스의 한계로 인해 일대 다 및 다대 일 관계로 풀기 위한 중간 테이블이 생성된다.
* 다대 다 연관 관계의 구현에는 다음과 같은 기능들이 사용된다.
  1. @ManyToMany
  2. @JoinTable: 연결 테이블을 명시하기 위해 반드시 사용해야 한다.
* 또한, 다대 다 연관 관계 역시 단방향 또는 양방향 매핑이 가능하다.
  * 양방향 연관 관계의 경우, 연관 관계의 주인이 아닌 측은 반드시 mappedBy 속성을 명시해야만 한다.
* @JoinTable 어노테이션은 다음과 같이 작성할 수 있다.
  * 양방향 연관 관계의 경우, 연관 관계의 주인에 다음과 같이 작성한다.
  * 상술한 반와 같이, 연관 관계의 주인이 아닌 경우에는 mappedBy 속성만을 명시해도 무방하다.
```
@ManyToMany
@JoinTable(
  name = "CATEGORY_ITEM",
  joinColumns = @JoinColumn(name = "CATEGORY_ID"),
  inverseJoinColumns = @JoinColumn(name = "ITEM_ID")
)
```

### 다대 다 연관 관계의 한계
* 해당 연관 관계는 매우 편리해보이지만, 실제로는 실무에서 사용하기에는 한계가 명확한 연관 관계에 해당한다.
* 대표적으로, 연결 테이블은 양 테이블의 FK 정보만을 갖고 연결만을 위해 사용되는 일이 많지 않다.
  * 예를 들어, 주문 시간 또는 수량 등의 정보가 함께 저장될 수 있다.
* 그러나 **다대 다 연관 관계는 중간 테이블에 매핑 정보 이외의 정보를 추가할 수 없다**. 
* 또한, 중간 테이블이 사실상 암시적인 존재가 되므로 개발 과정에서 JOIN 등의 예상치 못한 쿼리가 발생할 수 있다.
* 상술한 이유에서, **다대 다 연관 관계는 실무에서 과감히 제거하여 사용하지 않는 것이 바람직**하다.

### 다대 다 연관 관계의 대체제
* **다대 다 연관 관계를 구현하기 위해 JPA에 의해 자동으로 생성되는 연결 테이블을 그대로 사용하기보다, 연결 용도의 엔티티로 승격시켜 사용**한다.
  * 즉, 다대 다 연관 관계를 일대 다 및 다대 일 관계로 수정한 후 중간 연결 엔티티를 둔다.
  * 이 과정에서 @ManyToMany 어노테이션은 @OneToMany와 @ManyToOne의 조합으로 변경된다.
* 이러한 방식을 채택할 경우, 중간 엔티티에 여러 부가 정보를 추가하더라도 전혀 문제가 없어진다.
* 실무에서는 특히 상황이 복잡해지므로 다대 다 연관 관계로 깔끔하게 풀어낼 수 있는 경우가 매우 드물기에, 이러한 방식을 적극적으로 채택할 필요가 있다.
* 이 때 **중간 엔티티 테이블의 PK는 AI 등 의미 없는 값을 적용하는 것이 유연하며, 추후의 변경에 대비하기에도 용이**하다.
  * **기본적으로 이러한 정책을 기반으로 필요한 경우에 추가적인 제약 조건을 정의하는 것이 더 유연한 설계가 될 가능성이 높다**.

## 2022-07-21 Thu
### @JoinColumn
* 해당 어노테이션은 FK를 매핑하기 위한 용도로 사용한다.
  * 이 때, **name 속성을 통해 매핑할 FK의 이름을 명시**할 수 있다.
* FK가 참조하는 대상 테이블의 컬럼 명은 기본적으로 참조하는 테이블의 PK 컬럼 명으로 적용된다.
  * 이를 수정하고 싶은 경우에는 referencedColumnName 속성을 사용할 수 있다.

### @ManyToOne과 @OneToMany의 차이
* @ManyToOne 어노테이션은 기본적으로 mappedBy 속성을 지원하지 않는 반면, @OneToMany는 지원한다.
  * 이는 즉, **1:N 관계에서 N측은 항상 연관 관계의 주인이 되어야 함을 의미**한다.
* 즉, JPA 스펙 상에서는 지원하지 않는 기능이며 이를 우회하기 위해 insertable 과 updatable 속성을 false로 두는 방식을 사용할 수는 있다.
# Java
## 2022-01-06 Thu

### final
* 클래스, 메소드, 멤버 변수, 지역 변수 모두 final을 붙여줄 수 있다.
  * 클래스: 더 이상 확장될 수 없다. 따라서 final class는 부모 클래스가 될 수 없다.
  * 메소드: 부모 클래스의 final 메소드는 자식 클래스가 오버라이딩할 수 없다.
  * 변수: 상수 취급 된다.
* final 변수는 선언과 초기화가 동시에 수행되어야 한다.
  * 그러나 **인스턴스 변수의 경우 생성자를 통해 초기화**되도록 할 수 있다.
    * 이 기능이 불가능하다면, 모든 인스턴스의 final 변수가 같은 값으로 초기화되어야 한다.
  * 이를 활용하면 생성자를 통해 인스턴스 마다 final 변수의 값을 달리 적용해줄 수 있다.

### abstract
* 클래스와 메소드에 abstract를 붙여줄 수 있다.
  * 클래스: 추상 메소드가 존재함을 명시적으로 알 수 있도록 한다.
  * 메소드: 메소드의 선언 부만 작성하며, 구현 부를 작성하지 않은 추상 메소드임을 명시적으로 알린다.
* 추상 클래스는 미완성 메소드(추상 메소드)가 존재하므로, 인스턴스화할 수 없다.

### 접근 제어자
* 접근 제어자는 클래스, 생성자, 메소드, 멤버 변수에 붙여줄 수 있다.
  * 생성자: 인스턴스의 생성을 제한할 수 있다.
    * 일반적으로, 생성자의 접근 제어자는 클래스의 접근 제어자와 같다.
  * 지역 변수에는 사용할 수 없다.
* 접근 제어자는 private, default, protected, public 네 종류가 있다.
  * default: 같은 패키지 내에서만 접근이 가능하다.
  * protected: 같은 패키지, 또는 다른 패키지의 자식 클래스에서만 접근이 가능하다.
* 접근 제어자는 클래스 내부의 데이터를 보호하기 위해 사용된다.
  * 예를 들어 멤버 변수의 값을 외부에서 함부로 변경할 수 없게 하기 위해 적용해볼 수 있다.
* 또한 접근 제어자는 외부에서 알 필요가 없는 내용을 클래스 내부로 감추어 복잡성을 낮추기 위해서도 적용해볼 수 있다.
* 예를 들어, public 메소드를 수정했다면 패키지 외부에서 해당 메소드를 사용하는 곳이 있는지 모두 살펴봐야 한다.
  * 반면 default의 경우 같은 패키지에 위치한 클래스들만 살펴보면 된다.
  * private이라면 같은 클래스 내에서만 확인해보면 된다!
  * 이렇듯 적절한 접근 제어자는 유지보수에도 간접적인 도움을 준다.
* 생성자가 private인 클래스는 자식 클래스가 부모 클래스의 생성자를 호출할 수 없으므로, 상속될 수 없다.
  * 즉, 생성자가 private인 클래스는 더 이상 확장될 수 없다!
  * 이러한 경우 클래스 자체에 final을 붙여 더 이상 확장될 수 없는 클래스임을 명시하는 것이 바람직하다.

### static, final, abstract, 접근 제어자
* static final은 불가능하다.
  * static은 반드시 메소드 바디가 필요하다.
* final abstract class는 불가능하다.
  * final은 확장될 수 없음을 의미하며, abstract는 상속이 필수적임을 의미하기 때문이다.
* private abstract 메소드는 불가능하다.
  * 자식 클래스가 해당 메소드를 재정의할 수 없어지기 때문이다.
* 메소드에 굳이 private final을 같이 붙여줄 필요 없다.
  * private 메소드는 애초에 오버라이딩이 불가능하다.

### 다형성
* Java의 다형성은 한 클래스 참조 변수로 여러 클래스의 인스턴스를 참조할 수 있도록 구현되어 있다.
  * 쉽게 말해, 부모 클래스의 참조 변수로 자식 클래스의 인스턴스를 참조할 수 있다.
```
Parent temp1 = new Child();
Child temp2 = new Child();
// temp1은 Child의 멤버에 접근할 수 없다. 참조 타입에 따라 접근 가능한 멤버가 다르다!
// Child temp3 = new Parent();
// 이건 컴파일 에러가 발생하며, 불가능하다. temp3가 사용 할 수 있는 멤버의 개수가 실제 인스턴스보다 많다.
```
* **참조 변수가 사용할 수 있는 멤버는 언제나 실제 인스턴스의 멤버 개수보다 같거나 적어야** 한다.
  * 클래스는 확장만 가능하므로, 자식의 멤버는 항상 부모보다 많거나 같다.
  * 참조 변수에는 인스턴스의 실제 주소 값이 정수로만 저장될 뿐이며, 참조 타입이 참조 변수로 접근 가능한 멤버의 수를 결정한다.

### 형변환
* 형변환의 경우, 자식 클래스의 인스턴스를 부모 클래스로 자동 형변환할 수 있다.
  * 이는 **자식 타입의 참조 변수가 다룰 수 있는 멤버보다 부모 타입의 참조 변수가 다룰 수 있는 멤버가 항상 같거나 적기 떄문**에 생략이 가능하다!
  * 역의 경우는 명시적 형변환만이 가능하다. 없는 멤버를 자동으로 만들어줄 수는 없으니까.
* 형변환은 참조 변수의 타입을 변경할 뿐, 인스턴스화된 인스턴스에는 영향을 주지 않는다.
  * 즉, 인스턴스를 변환하는 것이 아니다.
  * 단지 **참조 변수의 타입 변경을 통해 참조되는 인스턴스에 접근 가능한 멤버의 범위를 조절**할 뿐이다!

### instanceof
* 참조 변수가 참조하는 실제 인스턴스의 타입을 알아내기 위해 사용되는 연산자이다.
* 참조 변수 명 instanceof 클래스 명 의 형태로 사용한다.
```
// 생략
if(c instanceof Child) {
  // c가 Child로 형변환이 가능한지 확인하며, 가능한 경우에만 true가 반환된다.
  // 생략
}
```
* true가 반환된 경우, 해당 참조 변수는 instanceof 우항의 클래스로 형변환이 가능하다.
  * instanceof 연산의 **결과가 참이면 검사 대상 타입으로 형변환이 가능**하다는 것을 의미한다.
* null을 참조하는 참조 변수에 대한 instanceof는 false를 반환한다.
* 다형성을 구현한 메소드에서, 매개 변수로 부모 클래스의 참조 변수를 받는 경우 메소드 내부에서 인스턴스의 실제 타입을 알기 위해 사용할 수 있다.
* **실제 인스턴스와 인스턴스의 타입이 동일한 경우 외에도, 부모 타입에 대한 instanceof 연산도 true를 반환**한다.
```
class Main {
    public static void main(String[] args) {
        Parent c = new Child();
        
        if(c instanceof Child) {
            System.out.println("This is a child");
        }
        if(c instanceof Parent) {
            System.out.println("This is a parent");
        }
    }
}

class Parent {}
class Child extends Parent {}
/* 실행 결과
This is a child
This is a parent
// c는 Child이기도, Parent이기도 하다.
*/
```

### 인스턴스 멤버와 상속
* 멤버 메소드는 기본적으로 실제 인스턴스의 메소드를 호출한다.
 * 즉, 참조 변수의 타입과 관계 없이 항상 실제 인스턴스의 메소드가 호출된다.
* 반면 멤버 변수는 참조 변수의 타입을 따라간다.
* Parent temp = new Child();로 인스턴스를 생성했을 때, temp.[변수명]은...
 * Child 클래스에도 변수명과 동일한 변수가 있더라도 Parent 클래스의 변수명을 호출한다.
 * Child temp = new Child();라면, Child 클래스의 변수명을 호출한다.
 * 동일한 변수가 없고 부모, 또는 자식 중 하나에만 해당 변수 명을 갖는 멤버 변수가 있는 경우, 그 변수를 호출한다.

### 메소드 매개 변수와 다형성
* 어떤 메소드가 동일한 부모를 상속 받는 여러 자식 클래스를 매개 변수로 받는다고 하자.
* 이 경우, 자식 클래스마다 메소드를 만드는 것보다 공통 부모 클래스를 받아 처리하도록 매개 변수를 작성하는 것이 바람직하다.
 * 이는 자식 클래스가 부모 클래스로 자동 형변환될 수 있는 점에 따른 다형성의 활용이다.

### 객체 배열과 다형성
* 공통 부모로부터 상속 받는 여러 자식 클래스가 존재하는 경우, 부모 클래스 형 객체 배열을 통해 자식 클래스를 한 번에 처리할 수 있다.
```
// ChildA와 ChildB가 Parent를 상속한다고 할 때, 다음과 같이 구현할 수 있다.
Parent[] arr = new Parent[10];
arr[0] = new ChildA();
arr[1] = new ChildB();
```
* 배열과 같이 크기가 정해진 데이터 구조가 싫다면 Vector 클래스를 활용할 수 있다.
 * Vector 클래스는 이름과 달리 Object 배열을 내부적으로 갖고, 배열의 크기를 알아서 관리해주는 데이터 구조 클래스이다.

## 2022-01-07 Fri

### 추상 클래스
* 추상 클래스는 종종 미완성 설계도에 비유되며, 실제로는 아직 완성되지 않은 추상 메소드를 갖는 클래스이다.
* 미완성 설계도로는 제품을 만들 수 없듯, 추상 클래스는 인스턴스화가 불가능하다.
 * 추상 클래스는 이를 상속 받는 자식 클래스의 확장을 통해서만 완성될 수 있다.
* 추상 클래스는 다음과 같이 abstract 키워드를 활용하여 작성한다.
 * 명시된 abstract 키워드를 통해 개발자는 추상 메소드의 존재 유무를 유추할 수 있다.
```
// abstract 키워드를 사용한다.
abstract class Temp {}
```
* 추상 클래스는 추상 메소드를 포함한다는 점 외에는 클래스와 사용 방식이 같다. 생성자도 포함되지만, 단지 인스턴스화만이 불가능하다.
 * 추상 메소드가 하나도 없는 추상 클래스도 작성할 수 있다. 이 역시 인스턴스화는 불가능하다.
```
class Main {
    public static void main(String[] args) {       
        System.out.println(new Temp().toString()); // 에러가 발생한다. 추상 메소드가 없는 추상 클래스도 인스턴스화는 불가능하다.
    }
}
abstract class Temp {}
```
* 추상 클래스는 확장될 자식 클래스보다 한단계 추상화된 클래스이다. 
* 이렇듯 추상화는 기존에 작성한 여러 클래스의 공통 부분을 뽑아 공통의 조상 클래스를 만드는데 사용될 수 있다.
* 참고: 추상 클래스는 인스턴스화할 수 없지만, 다형성을 위해 배열은 만들 수 있다.
```
// temp 메소드는 인스턴스의 실체인 Concrete의 temp 메소드가 호출된다.
class Main {
    public static void main(String[] args) {
        Temp tempArr[] = new Temp[4];
        tempArr[1] = new Concrete();
        tempArr[1].temp(1, 3); // 4가 출력된다.
    }
}

abstract class Temp {
    int x, y;
    abstract void temp(int x, int y);
}

class Concrete extends Temp {
    void temp(int a, int b) {
        System.out.println(a + b);
    }
}
```

### 추상 메소드
* 일반적인 메소드는 메소드 시그니쳐와 메소드 바디로 구성된다.
* 추상 메소드는 abstract 키워드와 함께 메소드 시그니쳐만 존재하고, 메소드 바디를 작성하지 않은 메소드이다.
 * 이러한 추상 메소드의 사용은 자식 클래스를 개발하는 개발자에게 '반드시 이러한 메소드를 구체화하여 사용하라'는 식으로 강요하기 위해 사용될 수 있다.
```
abstract class Temp {
 abstract void print();
 abstract int add(int num1, int num2);
}
class NotTemp extends Temp {
 void print() { // 추상 메소드의 구현
  // 생략
 }
 int add(int num1, int num2) { // 추상 메소드의 구현
  // 생략
 }
}
```
* 이렇듯 미완성 상태의 추상 메소드를 사용하는 이유는 다음과 같다.
 * 추상 클래스를 상속 받는 자식 메소드에서 메소드의 기능이 달라지길 기대하는 경우.
 * 이렇듯 실제 내용은 자식 클래스에서 구현되어야 하는 경우, 자식 클래스가 추상 메소드를 적절히 구현하도록 한다.
* 메소드의 작성에서, 메소드 시그니쳐를 설계하는 것이 메소드 바디의 설계보다 어려운 일이라고 한다.
 * 추상 클래스는 이토록 어려운 메소드의 설계를 우선 마치고, 메소드의 동작은 자식 클래스에서 구현하도록 유도한다.
 * 이는 자식 클래스를 개발하는 개발자가 메소드의 이름, 반환형, 매개 변수만 보고도 어느 정도 메소드의 동작을 유추하여 구현할 수 있기 때문이다.

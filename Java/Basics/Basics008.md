# Java
## 2022-01-06 Thu

### final
* 클래스, 메소드, 멤버 변수, 지역 변수 모두 final을 붙여줄 수 있다.
  * 클래스: 더 이상 확장될 수 없다. 따라서 final class는 부모 클래스가 될 수 없다.
  * 메소드: 부모 클래스의 final 메소드는 자식 클래스가 오버라이딩할 수 없다.
  * 변수: 상수 취급 된다.
* final 변수는 선언과 초기화가 동시에 수행되어야 한다.
  * 그러나 **인스턴스 변수의 경우 생성자를 통해 초기화**되도록 할 수 있다.
    * 이 기능이 불가능하다면, 모든 인스턴스의 final 변수가 같은 값으로 초기화되어야 한다.
  * 이를 활용하면 생성자를 통해 인스턴스 마다 final 변수의 값을 달리 적용해줄 수 있다.

### abstract
* 클래스와 메소드에 abstract를 붙여줄 수 있다.
  * 클래스: 추상 메소드가 존재함을 명시적으로 알 수 있도록 한다.
  * 메소드: 메소드의 선언 부만 작성하며, 구현 부를 작성하지 않은 추상 메소드임을 명시적으로 알린다.
* 추상 클래스는 미완성 메소드(추상 메소드)가 존재하므로, 인스턴스화할 수 없다.

### 접근 제어자
* 접근 제어자는 클래스, 생성자, 메소드, 멤버 변수에 붙여줄 수 있다.
  * 생성자: 인스턴스의 생성을 제한할 수 있다.
    * 일반적으로, 생성자의 접근 제어자는 클래스의 접근 제어자와 같다.
  * 지역 변수에는 사용할 수 없다.
* 접근 제어자는 private, default, protected, public 네 종류가 있다.
  * default: 같은 패키지 내에서만 접근이 가능하다.
  * protected: 같은 패키지, 또는 다른 패키지의 자식 클래스에서만 접근이 가능하다.
* 접근 제어자는 클래스 내부의 데이터를 보호하기 위해 사용된다.
  * 예를 들어 멤버 변수의 값을 외부에서 함부로 변경할 수 없게 하기 위해 적용해볼 수 있다.
* 또한 접근 제어자는 외부에서 알 필요가 없는 내용을 클래스 내부로 감추어 복잡성을 낮추기 위해서도 적용해볼 수 있다.
* 예를 들어, public 메소드를 수정했다면 패키지 외부에서 해당 메소드를 사용하는 곳이 있는지 모두 살펴봐야 한다.
  * 반면 default의 경우 같은 패키지에 위치한 클래스들만 살펴보면 된다.
  * private이라면 같은 클래스 내에서만 확인해보면 된다!
  * 이렇듯 적절한 접근 제어자는 유지보수에도 간접적인 도움을 준다.
* 생성자가 private인 클래스는 자식 클래스가 부모 클래스의 생성자를 호출할 수 없으므로, 상속될 수 없다.
  * 즉, 생성자가 private인 클래스는 더 이상 확장될 수 없다!
  * 이러한 경우 클래스 자체에 final을 붙여 더 이상 확장될 수 없는 클래스임을 명시하는 것이 바람직하다.

### static, final, abstract, 접근 제어자
* static final은 불가능하다.
  * static은 반드시 메소드 바디가 필요하다.
* final abstract class는 불가능하다.
  * final은 확장될 수 없음을 의미하며, abstract는 상속이 필수적임을 의미하기 때문이다.
* private abstract 메소드는 불가능하다.
  * 자식 클래스가 해당 메소드를 재정의할 수 없어지기 때문이다.
* 메소드에 굳이 private final을 같이 붙여줄 필요 없다.
  * private 메소드는 애초에 오버라이딩이 불가능하다.

### 다형성
* Java의 다형성은 한 클래스 참조 변수로 여러 클래스의 인스턴스를 참조할 수 있도록 구현되어 있다.
  * 쉽게 말해, 부모 클래스의 참조 변수로 자식 클래스의 인스턴스를 참조할 수 있다.
```
Parent temp1 = new Child();
Child temp2 = new Child();
// temp1은 Child의 멤버에 접근할 수 없다. 참조 타입에 따라 접근 가능한 멤버가 다르다!
// Child temp3 = new Parent();
// 이건 컴파일 에러가 발생하며, 불가능하다. temp3가 사용 할 수 있는 멤버의 개수가 실제 인스턴스보다 많다.
```
* **참조 변수가 사용할 수 있는 멤버는 언제나 실제 인스턴스의 멤버 개수보다 같거나 적어야** 한다.
  * 클래스는 확장만 가능하므로, 자식의 멤버는 항상 부모보다 많거나 같다.
  * 참조 변수에는 인스턴스의 실제 주소 값이 정수로만 저장될 뿐이며, 참조 타입이 참조 변수로 접근 가능한 멤버의 수를 결정한다.

### 형변환
* 형변환의 경우, 자식 클래스의 인스턴스를 부모 클래스로 자동 형변환할 수 있다.
  * 이는 **자식 타입의 참조 변수가 다룰 수 있는 멤버보다 부모 타입의 참조 변수가 다룰 수 있는 멤버가 항상 같거나 적기 떄문**에 생략이 가능하다!
  * 역의 경우는 명시적 형변환만이 가능하다. 없는 멤버를 자동으로 만들어줄 수는 없으니까.
* 형변환은 참조 변수의 타입을 변경할 뿐, 인스턴스화된 인스턴스에는 영향을 주지 않는다.
  * 즉, 인스턴스를 변환하는 것이 아니다.
  * 단지 **참조 변수의 타입 변경을 통해 참조되는 인스턴스에 접근 가능한 멤버의 범위를 조절**할 뿐이다!

### instanceof
* 참조 변수가 참조하는 실제 인스턴스의 타입을 알아내기 위해 사용되는 연산자이다.
* 참조 변수 명 instanceof 클래스 명 의 형태로 사용한다.
```
// 생략
if(c instanceof Child) {
  // c가 Child로 형변환이 가능한지 확인하며, 가능한 경우에만 true가 반환된다.
  // 생략
}
```
* true가 반환된 경우, 해당 참조 변수는 instanceof 우항의 클래스로 형변환이 가능하다.
  * instanceof 연산의 **결과가 참이면 검사 대상 타입으로 형변환이 가능**하다는 것을 의미한다.
* null을 참조하는 참조 변수에 대한 instanceof는 false를 반환한다.
* 다형성을 구현한 메소드에서, 매개 변수로 부모 클래스의 참조 변수를 받는 경우 메소드 내부에서 인스턴스의 실제 타입을 알기 위해 사용할 수 있다.
* **실제 인스턴스와 인스턴스의 타입이 동일한 경우 외에도, 부모 타입에 대한 instanceof 연산도 true를 반환**한다.
```
class Main {
    public static void main(String[] args) {
        Parent c = new Child();
        
        if(c instanceof Child) {
            System.out.println("This is a child");
        }
        if(c instanceof Parent) {
            System.out.println("This is a parent");
        }
    }
}

class Parent {}
class Child extends Parent {}
/* 실행 결과
This is a child
This is a parent
// c는 Child이기도, Parent이기도 하다.
*/
```

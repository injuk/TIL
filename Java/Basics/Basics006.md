# Java
## 2022-01-05 Wed

### 시스템 > JVM 메모리 할당
* Java App.이 실행되면 JVM은 다음의 과정을 거쳐 필요한 메모리를 할당받는다.
  1. JVM은 시스템으로부터 App.에 필요한 메모리를 할당받는다.
  2. JVM은 할당받은 메모리를 용도에 따라 method area, call stack, heap으로 나누어 관리한다.
  3. JVM이 메인 클래스의 main 메소드를 호출하며 App.이 시작된다.
  4. main 메소드의 마지막 문장이 실행된 후 main 메소드 역시 call stack에서 제거되어 App.이 종료된다.

### JVM의 메모리 구조
* method area
  * App.의 실행 과정에서 어떤 클래스를 사용할 필요가 있으면,
    1. JVM은 해당 클래스(.class)를 읽어들여 클래스 데이터를 저장한다.
    2. 해당 클래스가 갖는 **클래스 변수도 이 영역에서 관리**된다.
  * 즉, 클래스 사용시 할당되고, 클래스의 정보를 저장하고, App. 종료시 반환된다.
* call stack
  * 메소드의 실행에 필요한 메모리 공간을 제공한다.
  * 메소드 호출시, call stack에는 호출된 메소드를 위한 메모리 영역이 할당된다.
  * call stack은 메소드 실행 중 지역변수 및 연산 결과를 중간 저장하기 위해 사용된다.
  * 메소드의 실행이 종료되면 할당되었던 call stack 공간은 반환된다.
  * call stack의 **가장 상위에 위치한 메소드는 현재 실행되는 메소드**이며, 아래의 메소드들은 대기 상태인 메소드이다.
    * 바로 아래에 있는 메소드는 현재 실행 중인 메소드를 호출한 메소드이며, 현재 실행 중인 메소드가 종료될때까지 실행을 대기한다.
    * 반환값이 있는 메소드는 자신을 호출한 메소드에 값을 반환하며 실행이 종료된다.
      * 대기 상태의 메소드는 반환받은 반환값을 통해 메소드 실행을 재개한다.
  * 즉 메소드 호출시 할당되고, 메소드의 중간 결과를 위한 값을 저장하며, 메소드 종료시 반환된다.
  * 참고: stack overflow는 메소드가 정리되지 않고 계속해서 쌓여 call stack의 메모리 한계를 넘었을 때 발생하는 에러이다. 
* heap
  * 클래스의 인스턴스가 생성되는 공간이다.
  * App. 실행 중 생성되는 인스턴스는 모두 이 곳에 생성된다.
  * **인스턴스는 인스턴스 변수를 포함**한다.
  * 즉 인스턴스 생성시 할당되고, 인스턴스 변수를 저장하며, GC에 의해 반환된다.

### 메소드와 매개변수
* Java에서는 메소드 호출 시 인자로 전달한 값을 메소드의 매개변수에 복사한다. 이 때,
  * 기본형: 인자로 전달된 값이 복사된다.
  * 참조형: 인자로 전달된 인스턴스의 주소가 복사된다.
* 따라서, **기본형 변수가 매개변수로 전달된 경우 복사된 값이므로 원본에 영향을 줄 수 없다**.
* 반면 **참조형 변수가 매개변수로 전달된 경우, 인스턴스의 주소가 복사되므로 원본에 영향을 줄 수 있다**!
```
void temp1(int num) {
  num = 3; // 복사된 값이므로, num 변수의 원본에는 영향을 주지 못한다.
}
void temp2(Temp temp) {
  temp.num = 3; // temp의 원본 인스턴스의 인스턴스 변수인 num을 직접 수정한다.
  // 이는 여러 참조형 변수가 하나의 인스턴스를 참조할 수 있는 사실에서 기인한다!
}
```
* 참조형 변수를 반환하는 메소드는 정수인 객체의 주소를 반환하는 것과 같다.
  * 메소드 내부에서 새로 생성된 인스턴스는 메소드 종료 시점에 참조 변수가 제거되므로 GC의 대상이 된다.
  * 그러나 생성한 인스턴스를 가리키는 참조변수를 반환하면, 해당 메소드를 호출한 메소드가 이 값을 받아 자신의 매개변수에 저장할 수 있으므로 인스턴스의 참조가 지워지지 않아 GC 대상이 되지 않는다.

### 재귀 호출
* 메소드가 자기 자신을 다시 호출하는 것을 말한다.
* Java에서 메소드가 다른 메소드를 호출하는 것과, 자기 자신을 호출하는 것에는 차이가 없다.
  * 이는 메소드 호출 자체가 특정 위치의 명령어를 수행하는 것에 그치기 때문이다.
  * 또한 재귀 호출된 메소드는 원본이 아닌 복사된 값으로 동작하므로, 호출한 메소드와 독립적인 동작이 가능하다.
* 그러나 재귀 호출은 무한 반복 상태에 빠지기 쉬우므로, 재귀 호출의 탈출 조건을 반드시 명시해주어야 한다.

### 클래스 메소드, 인스턴스 메소드
* 클래스 변수, 인스턴스 변수와 마찬가지로 static이 붙은 경우를 클래스 메소드라고 한다.
* 클래스는 데이터와 함수의 집합이므로, 같은 클래스 내부의 메소드와 변수는 밀접한 관계가 있어야 한다.
  * 인스턴스 메소드는 인스턴스 변수와 관련된 작업을 하는 메소드이다.
    * 즉, 인스턴스 변수를 필요로 하는 경우가 많다.
  * 반면 인스턴스 변수나 인스턴스 메소드를 활용하지 않는 메소드를 클래스 메소드로 정의하여 사용하는 것이 일반적이다.
* **클래스 메소드는 인스턴스 변수를 사용할 수 없다**.
  * 클래스 메소드는 인스턴스 생성 없이 사용할 수 있으나, 인스턴스 변수는 인스턴스 생성이 전제되어야 접근이 가능하기 때문이다.
* 메소드 중, 인스턴스 변수나 인스턴스 메소드를 사용하지 않는 메소드는 클래스 메소드화(static)하는 것을 고려한다.
  * 메소드 호출 시간이 짧아지므로, 최종적으로 성능이 향상된다.
* 클래스 메소드, 클래스 변수는 클래스가 method area에 적재되는 시점에 자동적으로 생성된다.

### 클래스 멤버와 인스턴스 멤버간의 호출
* 인스턴스 멤버는 인스턴스 멤버와 클래스 멤버를 호출할 수 있다.
  * **같은 클래스 내에 존재하는 멤버는 별도의 인스턴스 생성 없이 서로를 호출할 수 있다**.
  * 인스턴스 멤버가 인스턴스 멤버를 호출한다는 것은, 이미 클래스의 인스턴스화가 완료됨을 의미하기 때문이다.
  * 또한 인스턴스 멤버의 클래스 멤버 호출은 클래스 멤버가 항상 먼제 method area에 준비되어 있으므로 가능하다.
* 클래스 멤버는 클래스 멤버만을 호출할 수 있다.
  * 인스턴스 멤버는 인스턴스가 생성되어야만 호출할 수 있기 때문이다.
  * 즉, 클래스 멤버가 인스턴스 멤버를 호출하는 시점에 인스턴스가 존재하지 않을 수도 있기 때문이다.
* 만약 클래스 멤버로 인스턴스 멤버를 호출하고 싶다면, 클래스 멤버를 인스턴스 멤버로 작성해야하는 것은 아닌지 한 번 더 체크한다.

### 오버로딩
* 같은 메소드 이름이지만 매개 변수의 정보(개수 또는 타입)가 다른 경우, 추가로 동명의 메소드를 작성할 수 있는 것을 말한다.
  1. 메소드의 이름이 같고,
  2. 매개변수의 개수 또는 타입이 다른 경우에 한해
  * 메소드 오버로딩이라고 한다. 위 조건에 위배되는 경우 동명의 메소드는 컴파일 에러를 발생시킨다.
* 오버로딩된 메소드들은 매개 변수에 의해서만 구별될 수 있으며, 반환 타입은 오버로딩에는 영향을 주지 못한다.
  * 매개변수의 개수와 타입이 같은 경우, 반환 형이 달라도 컴파일 에러가 발생한다.
  * 이는 즉 메소드에 매개변수가 포함되어 호출되었을 때, 어떤 메소드를 호출해야하는지 명시적인 구분이 가능해야 함을 뜻한다.
    * 반환형은 메소드 호출 이후에 사용되므로 오버로딩에 영향을 주지 못한다.
* 오버로딩을 통해 네임 스페이스 문제를 일부 해결하며, 메소드의 기능을 쉽게 예측할 수 있게 된다.

### 가변 인자
* JDK 1.5부터 추가된 기능이며, 메소드의 매개 변수의 개수를 가변적으로 설정할 수 있도록 한다.
* [자료형]... [변수명] 의 형식으로 정의한다.
  * 이 때, 가변 인자는 반드시 메소드의 마지막 매개 변수여야만 한다.
  * 가변 인자는 **내부적으로는 매개 변수의 배열을 사용**한다.
* 아래의 메소드는 하나의 메소드로 대체될 수 있다.
  * 이렇게 대체된 메소드는 인자가 없어도 되고, **배열을 받을 수도 있는 등** 유연한 사용이 가능해진다.
  * 그러나 메소드 호출시마다 배열이 호출되므로, 꼭 필요할 때만 가변 인자를 사용한다.
```
int sum(int a, int b){};
int sum(int a, int b, int c){};
// int sum(int... nums){};
```
* 가변 인자 메소드는 오버로딩시 컴파일 에러가 발생하는 경우가 많으므로, 되도록 가변 인자 메소드는 오버로딩 하지 않는 것이 좋다.
```
int sum(int first, int... nums){};
// int sum(int... nums){}; // 주석 해제시 에러 발생! 메소드 sum을 구분할 수 없기 때문이다.
```

### 생성자
* 인스턴스 생성시 호출되는 **'인스턴스 초기화용' 메소드**이다.
* 생성자는 다른 메소드와 달리 다음과 같은 조건이 존재한다.
  1. 생성자의 이름은 반드시 클래스의 이름과 같아야 한다.
  2. 생성자는 반환형과 반환값이 없다.
* 생성자 또한 오버로딩이 가능하므로, 하나의 클래스에 여러 생성자가 존재할 수 있다.
* **new 연산자가 인스턴스를 생성하지, 생성자 자체가 인스턴스를 생성하지는 않는다**!
  * **생성자는 인스턴스 변수의 초기화에 사용되는 특별한 메소드**에 불과하다.

### 인스턴스화 과정
```
Temp temp = new Temp();
```
1. new 연산자에 의해 heap에 Temp 클래스의 인스턴스가 생성된다.
2. 생성자 Temp()가 호출되고, 수행되며 인스턴스 변수를 초기화한다.
3. new 연산자의 결과로 생성된 Temp 인스턴스의 주소가 참조 변수인 temp에 저장된다.
* 인스턴스 생성을 위해서는 반드시 클래스 내에 정의된 생성자 중 적절한 것을 호출하여 인스턴스 변수를 초기화하여야 한다.

### 기본 생성자
* 모든 클래스에는 반드시 최소 하나의 생성자가 정의되어 있어야 한다.
* 클래스의 소스 파일(.java)에 아무런 생성자를 정의하지 않은 경우, 컴파일러는 컴파일 시점에 다음과 같은 기본 생성자를 자동으로 추가한다.
  * 자동으로 추가되는 기본 생성자는 아무 매개 변수도, 메소드 바디도 없다.
  * 별도의 인스턴스 초기화 작업이 필요하지 않은 경우, 컴파일러가 추가하는 기본 생성자를 사용해도 무방하다.
```
// 클래스명() {}
Temp() { }
```
* 클래스 내에 **사용자가 추가한 생성자가 하나라도 있으면 컴파일러는 기본 생성자를 추가하지 않는다**.
* 클래스를 작성할 때에는 생성자를 다양하게 오버로딩하여 제공하는 것이 바람직하다.

### this(), this
* this(): 같은 클래스에 위치한 다른 생성자를 호출하기 위해 사용되는 예약어이다.
* this: 인스턴스 자기 자신을 가리키는 참조 변수이며, 인스턴스의 주소가 저장되어 있다.
  * 이렇듯 this()와 this는 각자 '생성자'와 '참조 변수'로, 전혀 연관이 없다!!!
* 생성자는 다음의 조건이 만족된 경우에 한해 서로를 호출할 수 있다.
  1. 생성자의 이름으로 클래스명 대신 this 키워드를 사용한다.
     * 이는 this()와 같은 형식으로 생성자를 호출하라는 의미이다.
     * Temp()와 같이, 생성자의 이름을 바로 호출할 수 없다.
  2. 한 생성자에서 다른 생성자를 호출할 때에는 '**반드시 첫 줄에서만 호출이 가능**'하다.
     * 이는 이미 초기화한 멤버 변수를 새로운 생성자가 덮어 쓰는 것을 방지하기 위함이다.
* **this 키워드는 참조 변수로서 인스턴스 자기 자신**을 가리킨다.
  * **모든 인스턴스 메소드에는 자신이 관련된 인스턴스를 가리키는 참조 변수 this가 지역 변수로 숨겨져 있다**!
* 인스턴스 외부에서 참조 변수를 통해 인스턴스의 멤버에 접근하듯이 this 키워드를 통해 인스턴스의 멤버에 접근이 가능하다.
  * 이 때, this 키워드는 인스턴스의 멤버만이 사용할 수 있다.
  * **클래스 멤버는 인스턴스가 생성되지 않았을 수 있으므로 this 키워드를 사용할 수 없다**.
* 일반적으로 인스턴스 메소드는 인스턴스 자기 자신과 관련된 작업을 수행하므로 this가 필요하다.
* 반면, 클래스 메소드는 인스턴스와 관련 없는 작업을 수행하므로 인스턴스 자신에 대한 정보가 필요 없어야 한다.

### 초기화 블록
* 초기화 블록은 클래스 초기화 블록과 인스턴스 초기화 블록으로 나뉜다.
  * 클래스 초기화 블록: static { } 형태이며, 쿨래스 변수의 복잡한 초기화에 사용한다.
    * 클래스의 로딩 시점에 최초 1회만 호출되어 실행된다.
  * 인스턴스 초기화 블록: { } 형태이며, 인스턴스 변수의 복잡한 초기화에 사용한다.
    * 인스턴스 생성시마다 호출된다.
* 클래스 초기화 블록은 클래스 변수가 클래스 로딩 시점에 메모리에 적재된 후에 실행되며, 클래스 변수들을 초기화한다.
* 인스턴스 초기화 블록은 생성자보다 먼저 호출되므로, 생성자마다 중복되는 로직을 작성하기에 적합하다.
* 초기화 블록은 여러 생성자에 존재하는 중복 코드의 제거에 적절하다.
  * 초기화 블록은 인스턴스의 복잡한 초기화 과정에 생성자 대신 사용할 수 있다.
```
class Main {
    public static void main(String[] args) {
        Temp temp = new Temp();
    }
}

class Temp {
    { System.out.println("init!!!"); }
    
    Temp() {
        System.out.println("construct!!!");
    }
}
/* 실행 결과
init!!!
construct!!!
*/
```
* 다음의 의미를 통해 생성자와 구분하면 좋다.
  * 매개 변수를 토대로 인스턴스 마다 달리 초기화를 적용: 생성자
  * 모든 생성자에서 공통으로 수행되어야 하는 동작: 초기화 블록

### 멤버 변수의 초기화 시기와 순서
* App. 실행 도중 클래스에 대한 정보가 요구될 때 클래스가 메모리에 로딩된다.
  * JVM마다 방식이 다르다고 함. 클래스가 필요한 시점에 메모리에 로딩되는 경우도 있고, App. 실행 시점에 필요한 모든 클래스를 로딩하는 것도 있다고 한다.
* 클래스에 대한 정보가 요구되는 시점의 예시는 다음과 같다.
  1. 클래스 멤버를 사용할 때
  2. 인스턴스를 생성해야할 때
* 그러나 해당 클래스가 이미 로딩되어 있다면 다시 로딩하지 않는다.
  * 당연히 클래스 초기화 과정도 다시 수행하지 않는다.
* 클래스 변수의 초기화 순서는 다음과 같다.
```
// 클래스가 처음 메모리에 로딩될 때 1회만 호출되어 실행.
// 때문에 클래스 변수는 항상 인스턴스 변수보다 먼저 생성되고 초기화된다.
메모리에 로딩되며 method area에 클래스 변수의 메모리 공간 생성 > 자료형의 기본값 > 명시적 초기화 > 클래스 초기화 블록
```
* 인스턴스 변수의 초기화 순서는 다음과 같다.
```
// 인스턴스가 생성될 때마다 아래의 과정을 실행.
인스턴스가 생성되며 인스턴스 변수의 공간이 heap에 생성 > 자료형의 기본값 > 명시적 초기화 > 인스턴스 초기화 블록 > 생성자
```
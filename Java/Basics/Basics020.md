# Java
## 2022-01-17 Sun

### 스트림 
* 스트림은 아래와 같은 문제를 해결하기 위해 고안되었다.
    1. for문이나 Iterator를 사용하는 방식의 가독성이 떨어진다.
    2. 재사용성이 떨어진다.
    3. 원본의 타입마다 다른 방식으로 처리해야 한다.
        * 컬렉션 프레임워크는 표준화되어 있지만, 같은 기능의 메소드들이 중복해서 정의되어 있는 경우가 있다.
* 스트림은 상술한 문제점을 다음과 같이 해소하고자 하였다.
    1. 데이터 원본(데이터 소스)을 추상화한다.
        * 덕분에 데이터 원본의 타입이 무엇이건 간에 같은 방식으로 다룰 수 있으며, 코드의 재사용성이 높아진다. 
    2. 데이터를 다루기 위해 자주 사용될 법한 메소드들을 정의해두었다.
* **스트림의 등장으로 인해 배열, 컬렉션, 파일 데이터 등 모두 같은 방식으로 다룰 수 있게 된다**.
```
class Main {
  public static void main(String[] args) {
    String[] strings = { "eee", "aaa", "ccc", "ddd" };

    Arrays.sort(strings);
    for(String string : strings) {
      System.out.println(string); // 기존 방식
    }

    Arrays.stream(strings) // stream을 사용한 방식
        .sorted()
        .forEach(System.out::println);
  }
}
```
* 위 방식은 for문을 활용한 방식과 동일한 작업을 수행하는 스트림 예시이다.
    * 스트림을 사용한 경우가 더 간결하고, 직관적인 것처럼 보인다.

### 스트림의 특징
* **스트림은 데이터 원본을 수정하지 않는다**.
    * 데이터 원본으로부터 데이터를 읽기만 하고, 원본을 수정하지 않는다.
    * 필요한 경우엔 결과를 다시 원하는 데이터 형태로 반환할 수 있다.
* **스트림은 일회용**이다.
    * 요소를 모두 읽고 나면 재사용이 불가능한 Iterator처럼, 스트림도 한 번 사용하면 닫히므로 재사용할 수 없다.
    * 재사용이 필요한 경우라면 스트림을 다시 생성해야 한다.
* **스트림의 작업은 내부 반복으로 처리**된다.
    * 위 예제에서, 배열의 모든 요소에 대해 수행되는 작업은 코드 블록 상에 노출되어 있다.
    * 반면 스트림의 forEach는 모든 요소에 대해 수행될 실제 작업이 메소드 내부에 숨겨진다.
        * 이러한 특징은 스트림의 작업이 내부 반복으로 처리됨을 의미한다.
        * forEach의 경우, 수행할 작업은 람다식(Consumer)으로 작성하여 매개 변수로 넘겨준다.

### 스트림의 연산
* 스트림의 연산은 **스트림 생성 > 중간 연산 > 최종 연산**의 순서로 진행된다.
* 스트림의 연산은 데이터 소스를 다루는 작업을 말한다.
* 스트림의 연산은 **중간 연산**과 **최종 연산**으로 구분된다.
   1. 중간 연산: **연산의 결과를 스트림으로 반환**하므로, 중간 연산을 연속적으로 연결(**chaining**)할 수 있다.
      * 중간 연산의 결과로 반환되는 스트림은 모두 다른 스트림이다.
      * 예시: distict, filter, sorted, map, flatMap, 등
   2. 최종 연산: 스트림의 **요소를 소모하며 연산을 수행**하므로, **단 한 번만 연산이 가능**하다.
      * 예시: forEach, count, max, min, reduce, collect, 등 
* **지연된 연산**: 스트림에서는 **최종 연산이 수행되기 전까지 중간 연산이 실행되지 않는다**.
    * 중간 연산의 명시는 해당 스트림에서 어떤 작업을 수행해야하는지 명시하는 것이다.
    * 실제 실행은 최종 연산이 수행되는 시점으로, 이 때 중간 연산을 거쳐 최종 연산에서 요소들이 소모된다.
* 기본형 스트림: Stream<Integer>와 같은 경우는 데이터 원본의 요소가 기본형인 경우, 불필요한 오토박싱 & 언박싱이 반복된다.
    * IntStream, LongStream과 같은 기본형 스트림은 데이터 원본의 요소를 기본형으로 다루도록 하며, 성능 상 이점이 있다.
    * 기본형을 다루는 데이터 원본에 대한 작업은 기본형 스트림을 사용하는 것이 바람직하다.

## 스트림의 생성
* 스트림 작업을 위해서는 반드시 스트림이 생성되어 있어야 한다.
* 스트림 생성시에는 스트림의 대상이 되는 데이터 원본이 필요하며, 배열 / 컬렉션 프레임워크 / 임의의 수가 원본이 될 수 있다.
### 컬렉션 프레임워크에서의 스트림 생성
    * Collection 인터페이스에 stream 메소드가 정의되어 있으므로, Collection의 자식인 List와 Set을 구현한 클래스 모두 해당 메소드를 사용한다.
    * **stream 메소드는 해당 컬렉션을 데이터 원본으로 하는 새로운 스트림을 반환**한다.
### 배열에서의 스트림 생성
    * 배열의 스트림은 Stream 클래스와 Arrays 클래스 각각에 정의된 두 가지 방법으로 생성할 수 있다.
    1. Stream.of: 가변 인자 또는 배열 인스턴스를 매개 변수로 받아 새로운 스트림을 생성한다.
        * 가변 인자 예시: Stream.of(1, 2, 3);
    2. Arrays.stream: 배열 인스턴스를 매개 변수로 받아 새로운 스트림을 생성한다.
### 특정 범위의 정수 스트림 생성
    * 기본형 스트림인 IntStream과 LongStream 등은 다음과 같이 임의의 범위에서 연속된 정수를 새로운 스트림으로 반환하는 메소드를 갖는다. 
    1. range(시작, 끝): 끝 값을 포함하지 않는 연속된 정수 스트림을 반환한다.
        * IntStream.range(1, 3); // 1, 2
    2. rangeClosed(시작, 끝): 끝 값을 포함하는 연속된 정수 스트림을 반환한다.
        * IntStream.rangeClosed(1, 3) // 1, 2, 3
### 난수 스트림 생성
* Random 클래스에는 기본형 스트림을 생성하는 ints, longs, doubles 메소드가 포함된다.
    * 세 메소드는 long 타입 매개 변수를 받아 유한 길이의 스트림을 생성한다.
    * 반면 매개 변수를 지정하지 않은 경우, 세 메소드 모두 해당 타입의 난수로 이루어진 무한한 길이의 스트림을 반환한다.
        * 이 경우에는 스트림의 개수를 지정하는 중간 연산인 limit(개수)를 통해 무한 스트림을 유한한 길이의 스트림으로 바꾸어 연산해주어야 한다.
    * 지정된 범위의 난수 스트림을 발생시키려면 위 세 메소드의 매개 변수를 (시작, 끝)으로 작성한다.
        * 이러한 방식은 range 메소드처럼 끝 값을 스트림 범위에 포함시키지 않는다.
### 람다식을 활용한 스트림 생성
* Stream의 iterate와 generate는 람다식을 매개 변수로 받아, 람다식의 연산 결과를 요소로 하는 무한 길이의 스트림을 생성한다.
    1. iterate(시작값, UnaryOperator): 시작 값으로 시작하여 람다식에 의한 연산 결과를 갖는 무한 길이의 스트림을 생성한다.
    2. generate(Supplier): 이전 결과를 이용해서 다음 요소를 계산하지 않는 연산 결과를 갖는 무한 길이의 스트림을 생성한다.
        * Supplier를 매개 변수로 받으므로, 매개 변수 없이 어떠한 값을 만들어내는 람다식을 활용하여야 한다.
* 위 두 메소드를 활용하여 생성한 스트림은 기본형 스트림일 수 없다.
### 파일 목록을 기반으로 하는 스트림 생성
* Files.list(Path dir): 지정된 dir 디렉토리에 위치한 파일의 목록을 원본으로 하는 스트림을 생성하여 반환한다.
### 빈 스트림 생성
* 아무런 요소를 갖지 않는 빈 스트림을 생성할 수 있다.
    * 스트림의 **연산 수행 결과가 없는 경우, null 보다는 비어 있는 스트림을 반환하는 것이 바람직**하다.
* Stream.empty(): 빈 스트림을 생성하여 반환한다. count 등의 최종 연산으로 확인할 경우 스트림의 길이는 0이 반환된다.
### 두 스트림을 연결하여 새로운 스트림 생성
* Stream의 static 메소드인 concat을 통해 두 스트림을 하나의 스트림으로 연결할 수 있다.
* **연결 대상 스트림은 같은 타입을 다루는 스트림이어야** 한다.
```
class Main {
  public static void main(String[] args) {
    String[] strings = { "eee", "aaa", "ccc", "ddd" };

    Stream<String> stream1 = Arrays.stream(strings);
    Stream<String> stream2 = Stream.of(strings);

    Stream.concat(stream1, stream2).sorted().forEach(System.out::println); // aaa, ccc, ddd, eee가 두 번씩 출력된다.
  }
}
```
  

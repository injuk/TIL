# Java
## 2022-01-03 Mon

### 기본형 - 논리형
* boolean
  * 기본값: false
  * 1bit로 충분하나, Java의 데이터 최소 단위가 byte이므로 1byte를 사용한다.
### 기본형 - 문자형
* char
  * 변수에 하나의 문자를 저장한다.
  * 이 때, 실제로 저장되는 값은 문자의 유니코드인 정수이다.
  * 때문에 char a = 'A'와 char a = 65는 동일하게 처리된다.
  * 유니코드를 활용한 저장도 가능하다.
    * char hexChar = '\uAC00';
  * char 타입은 short 타입과 마찬가지로 2byte를 사용하지만, 유니코드에 음수가 존재하지 않으므로 표현 범위가 더 넓다.
  * char와 short 모두 65를 저장한 경우 저장 데이터는 같지만, println 등의 메소드를 사용할 경우 데이터 타입에 따라 다르게 출력된다.
    * 예를 들어, char 65는 'A'로 출력되지만 short 65는 65 그대로 출력된다.
    * 이는 65에 대응되는 유니코드 값을 찾아 출력하기 때문이다.
  * **Java에서는 문자열 셋으로 UTF-16을 사용한다.** 
### 기본형 - 정수형
  * 정수형은 byte, short, int, long의 네 종류이며, 각 자료형이 표현할 수 있는 범위가 다르다.
  * 이 때, 기본 자료형은 int로 적용된다.
  * 모든 정수형은 부호 있는 정수이므로, 첫 비트를 부호 비트로 사용한다.
    * 이 때, 양수는 0을 포함하는 절반의 값이며, 음수는 나머지 절반의 값이다.
    * 따라서 정수형 변수에서 표현 가능한 값의 범위는 다음과 같다.
```
n bit 정수의 표현 범위: -2^(n-1) ~ 2^(n-1) - 1
// 이 때, 양수 범위의 - 1은 0이 포함되기 때문이다.
// n은 자료형에서 사용하는 byte 크기가 된다. 예를 들어, long의 경우 8 byte를 사용하므로 n은 8이 된다.
```

### 어떤 정수형을 사용할 것인가?
* 왠만해선 byte, short보다 int를 사용하자.
  * 메모리 절약보다 좁은 값의 범위로 인한 오류가 발생하는 상황이 더 많다.
  * 또한 JVM은 피연산자를 4byte 단위로 저장하므로, 더 작은 byte나 short은 4byte로 변환하는 과정이 포함된다.
  * 따라서, 오히려 int를 사용하는 것이 더 효율적이다.
* 왠만해서는 int를 사용하되, int의 범위인 -20억 ~ 20억 을 넘는 범위의 수를 다룰 경우에 long을 사용하자.
  * short, byte는 성능보다 저장공간 절약이 우선시될 때 고려한다.
  * long의 범위도 넘어야한다면 실수형 또는 BigInteger 클래스를 고려해볼 수 있다.

### 오버플로우란?
* 변수의 자료형이 표현할 수 있는 값의 범위를 넘어서 예상치 못한 결과를 얻게되는 경우를 말한다.
  * 예를 들어, 정수형 변수의 최대값에 1을 더하면 최소값이 되고, 최소값에 1을 빼면 최대값이 된다.
```
class Main {
    public static void main(String[] args) {
        int min = -2_147_483_648;
        int max = 2_147_483_647;
        System.out.println("min: " + min);
        System.out.println("min-1: " + (min - 1));
        System.out.println("");
        System.out.println("max: " + max);
        System.out.println("max+1: " + (max + 1));
    }
}

/* 실행 결과
min: -2147483648
min-1: 2147483647

max: 2147483647
max+1: -2147483648
*/
```
* 오버플로우는 발생할 수 있으며, 발생해도 에러가 발생하지 않으므로 연산을 수행하기에 충분한 자료형을 선택하자.
* 부호 있는 정수와 부호 없는 정수는 표현범위의 차이로 인해 오버플로우 발생 시점이 다르다.
  * 부호 있는 정수: 부호 비트가 0에서 1이 될 때
  * 부호 없는 정수: 2진수로 0000이 될 때 발생

### 기본형 - 실수형
* float과 double 두가지가 있으며, 실수를 저장하기 위해 사용한다.
  * 기본 타입은 double로 적용된다.
* 실수형에서는 얼마나 정밀하게 값을 표현할 수 있는지도 중요하다.
* double의 정밀도가 float보다 높으며, float보다 double을 권장하는 이유 또한 높은 정밀도를 활용하기 위해서이다.
* 실수형은 정수형과는 표현 형식이 다르다.
  * 예를 들어, 실수형은 2의 보수법을 사용하지 않는다.
```
// 실수형의 표현 형식
+- M X 2^E
// 부호는 1bit, M과 E는 float / double의 종류에 따라 다르다.
```

### 형변환
* 서로 다른 자료형간의 연산이 필요한 경우, 연산에 앞서 자료형을 일치시키는 과정이 필요하다.
* 이렇듯 변수의 자료형을 다른 자료형으로 변환하는 작업을 형변환이라고 한다.
* Java의 명시적 형변환은 **형변환 연산자인 ()을 사용**한다.
* 기본형의 경우, boolean을 제외한 나머지 자료형들은 서로 형변환이 가능하다.
* 기본형과 참조형 간의 형변환은 불가능하다!
* 정수형의 형변환
  * long > int와 같이 큰 타입을 작은 타입으로 변환되는 경우, 값의 크기 차이만큼 손실이 발생할 수 있다.
  * 반면 작은 타입의 값을 큰 타입으로 변환하는 경우에는 값이 손실되지 않는다.
    * 큰 타입의 값으로 변환하는 과정에서 발생하는 빈 자리는 변환하는 값이 양수인 경우 0으로, 음수인 경우 1로 채워준다.

### 자동 형변환
* 형변환은 편의상의 이유로 생략될 수 있다.
  * 이렇게 생략된 형변환은 코드 상에서만 누락된 것으로, 컴파일러가 생략된 형변환을 직접 추가하는 식으로 동작하게 된다.
* 컴파일러는 표현 범위가 작은 타입을 큰 타입으로 형변환하는 식으로 자동 형변환을 수행한다.
  * 이는 범위가 작은 타입이 큰 타입으로 형변환 되는 경우에 값 손실이 없기 때문에 그렇다.
```
// 오른쪽으로 흐르는 형변환은 자동 형변환이 적용된다.
// 왼쪽으로 흐르는 형변환은 반드시 형변환 연산자를 활용한 명시적 형변환이 필요하다.
byte > short > int > long > float > double
       char > 
```
* float은 long보다 저장 범위가 작지만, 더 많은 값을 표현할 수 있으므로 자동 형변환이 가능하다.
* char와 short은 표현 가능한 범위가 다르므로 자동 형변환이 불가능하다.
  * char는 short과 달리 양수만 표현 가능하기 때문에 그렇다.

### 연산자
* 모든 연산자는 연산 결과를 반환한다. 이는 대입 연산자인 = 도 예외가 아니며, 대입 연산자는 대입된 결과를 반환한다.
```
// 아래의 a = 100 연산은 100을 반환한다.
class Main {
    public static void main(String[] args) {
        int a = 0;
        System.out.println(a = 100);
    }
}
/* 실행 결과
100
*/
```
* AND 연산자 및 OR 연산자의 경우, 좌항의 조건에 따라 우측 피연산자를 아예 평가하지 않을 수 있다.
  * 예를 들어 AND의 경우, 좌항이 거짓인 경우 결과는 항상 거짓이므로 우측의 피연산자는 실행조차하지 않는다.
  * OR의 경우, 좌항이 참인 경우 결과는 항상 참이므로 우측의 피연산자는 실행조차 하지 않는다.
  * 만약 우측의 연산자에 ++또는 --연산자가 포함되어 있더라도 위 두 경우에 한 해 이 값은 평가되지 않는다. 즉, 원본 값을 유지한다!
```
// 아래 if 문의 조건식은 좌항이 참이므로 항상 true가 반환되고, 따라서 ++b가 실행되지 않아 b는 0을 유지한다.
class Main {
    public static void main(String[] args) {
        int a = 1, b = 0;
        if(a == 1 || ++b == 2) {
            int c = 3;
        }
            
        System.out.println(a);
        System.out.println(b);
    }
}
/* 실행 결과
1
0
*/
```
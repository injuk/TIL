# Java
## 2022-01-04 Tue

### 제어문 - 조건문
* 블럭 내부의 문장이 하나인 경우 괄호는 생략이 가능하지만, 생략하지 않는 것이 권장된다.
  * 이는 if-else 문 모두에 해당된다.
* 중첩 if문에서, 블럭을 명시하지 않은 경우 else 문은 가장 가까운 if문에 속한 것으로 간주된다.
* switch 문에서, 조건식과 case 문은 정수와 문자열을 허용한다.
  * case문의 경우 변수, 실수는 불가하다. 반면 상수는 가능하다!

### 제어문 - 반복문
* for문의 초기화, 조건식, 증감식은 모두 생략하여 for(;;)의 형태로 쓸 수 있다.
* JDK 1.5부터 향상된 for문을 통해 배열과 컬렉션의 값에 접근할 수 있다.
```
for([type] [var_name] : [collection]) {
  // code
}

int arr[] = { 1, 2, 3, 4 };
for(int element : arr) {
  // 원하는 동작을 실행
}
```
* 반복문에는 이름을 붙일 수 있다.
  * 이름 : 반복문의 형식이며, break와 continue 역시 break 이름; 또는 continue 이름;을 활용할 수 있다.
  * 이는 중첩 반복문에서 가장 가까운 반복문에 대해 동작하는 break와 continue를 특정 반복문에 대응시킬 수 있다.
  * 예를 들어, 이중 반복문에서 안쪽 반복문에 있는 break는 안쪽 반복문만을 탈출하지만, 반복문의 이름을 활용하여 바로 바깥쪽 반복문을 탈출시킬 수 있다.
```
Name1 : for(;;) {
  if(bool) break Name1;
}
```

### 배열
* 배열은 다음과 같은 형식으로 선언한다.
```
int[] arr = new int[10];
```
* int[] arr
  * 배열 선언, 생성된 배열을 다루기 위한 배열 참조변수 arr를 위한 공간이 생성된다.
* new int[10] 
  * 배열 생성, 실제 배열이 생성되며 값을 저장할 수 있다.
  * 이를 통해 메모리에 int형 10개의 공간이 생성되고, int의 기본값인 0으로 초기화된다.
  * 대괄호 안의 **배열 길이는 0이 될 수 있다**!
* =
  * 대입연산자에 의해 int[10]의 주소가 arr 변수에 저장된다.
* 배열의 각 요소는 인덱스를 통해 접근하지만, **변수를 사용하여 인덱스의 범위를 벗어난 접근은 컴파일러가 걸러주지 못한다**.
  * 변수의 값은 실행시에 대입되기 때문이다!
  * 때문에 이 경우에는 컴파일에 성공하지만 런타임 에러가 발생한다.
* 배열의 초기화
  * 다음과 같은 형식으로 배열의 선언과 초기화를 동시에 수행할 수 있다. 이 때, 중괄호를 비워주면 길이가 0인 배열을 생성한다.
```
// 중괄호 안의 개수에 따라 배열의 길이가 결정되므로, 배열의 길이를 별도로 명시하지 않아도 좋다.
int[] temp1 = new int[]{ 1, 2, 3 };
// 더 쉽게할 수 있다!
// 아래의 방식은 선언부와 배열 생성을 별도로 진행하는 경우에는 적용할 수 없다.
int[] temp2 = { 1, 2, 3 };
```
* 배열은 참조 변수를 통해서만 접근이 가능하다. 때문에 참조 변수의 참조가 다른 배열로 변경된 경우, 기존 배열은 JVM에 의한 쓰레기 처리의 대상이 되어 메모리에서 제거된다.

### 배열의 길이
* JVM은 모든 배열의 길이를 별도로 관리한다. .length를 통해 배열 길이에 접근할 수 있다.
* 한 번 생성된 배열의 길이는 변경할 수 없으므로, .length의 결과는 상수이다.

### 참조형 배열
* 배열의 각 항목에 실제 객체가 아닌 객체의 주소가 저장된다.

### 문자열 배열
* 문자열은 본래 char형 문자 배열과 같은 의미이다.
* 그러나 Java의 경우 문자열 처리에 char 배열보다는 여러 메소드가 추가된 String 클래스를 활용한다.
  * 즉, Java에서는 char 배열에 관련 기능을 묶은 String 클래스가 정의되어 있다.
  * 객체지향 이전에는 C와 같이 데이터와 기능을 따로 다루었지만, Java의 경우 데이터와 관련 기능을 하나의 클래스로 묶어 다룬다.
* **String 객체는 내용을 변경할 수 없다**. 새로운 문자열을 기존 변수에 할당할 경우 새로운 문자열 객체가 생성된다.
  * 변경 가능한 문자열을 다룰 경우 StringBuffer를 사용해야 한다.
* 문자열 내용 비교에는 == 연산자를 사용할 수 없다. 문자열은 내부적으로 객체 주소를 저장하므로, 해당 연산자로는 같은 객체인지를 체크하게 된다.
  * 대신 String 클래스의 equals 메소드를 활용한다.
* main 메소드의 매개변수인 Stringp[] args의 경우, 입력된 매개 변수가 없을 때 JVM은 null이 아닌 길이가 0인 배열을 생성하여 args에 전달한다.

### 다차원 배열
* 2차원 배열의 경우 다음과 같은 형식으로 선언한다.
```
int[][] arr;
int[] arr[];
int arr[][];
// 선언과 초기화를 동시에 하는 경우는 다음과 같다. 이 때, new int[][]는 생략할 수 있다.
int arr[][] = new int[][]{ { 1, 2, 3 }, { 4, 5, 6 } };
```
* 다차원 배열의 경우, 두번째 대괄호 내부의 값을 생략하여 가변 크기의 배열을 만들어줄 수 있다.
```
// 아래의 배열은 3개의 배열 요소에 들어갈 배열의 크기를 지정하지 않았으므로, 각 배열에서 참조할 배열의 크기가 자유롭다.
int[][] arr = new int[3][];
arr[0] = new int[3];
arr[1] = new int[5];
arr[2] = new int[2];

// 생성과 초기화를 동시에하는 경우는 다음과 같다.
int[][] arr = { { 1, 2, 3 }, { 1, 2, 3, 4, 5 }, { 1, 2 } };
```
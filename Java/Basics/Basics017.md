# Java
## 2022-01-13 Thu

### 어노테이션
* 어노테이션은 **App.의 소스코드 안에 다른 App.을 위한 정보를 미리 약속된 형식으로 포함시킨 것**이다.
  * 어노테이션은 **마치 주석처럼 App.에 영향을 미치지 않으면서도 다른 App.에 유용한 정보를 제공**할 수 있다.
* 예를 들어, @Test 어노테이션은 테스트 App.에게 해당 메소드를 테스트해야한다는 사실만을 알린다.
  * 실제 App.의 동작에는 영향을 전혀 주지 않는다. 주석과도 같이, 마치 존재하지 않는 것처럼 처리된다.
  * 당연히, 어노테이션은 다른 특정한 App.에 정의된 종류 및 형식으로 작성해야만 의미가 있다.
* 어노테이션은 JDK에서 기본 제공하는 종류와 다른 App.에서 제공하는 종류가 있다.
* JDK에서 제공하는 어노테이션은 대부분 컴파일러를 위해 유용한 정보를 제공하는 역할을 한다.
  * 또한 새로운 어노테이션을 정의하기 위해 사용하는 메타 어노테이션 또한 JDK 차원에서 제공된다.

### 표준 어노테이션
* @Override 어노테이션은 메소드 앞에 붙이는 것으로 조상의 메소드를 오버라이딩하는 메소드라는 사실을 컴파일러에게 알린다.
  * 붙이지 않아도 메소드 오버라이딩은 정상적으로 동작한다.
* 만약 @Override를 붙이지 않고 자식 클래스에서 메소드를 재정의하는 경우, 오타 등에 의해 잘못된 메소드 시그니쳐를 작성하더라도 에러는 발생하지 않는다.
* 반면 @Override를 붙인 경우, 컴파일러는 해당 메소드 시그니쳐와 같은 내용을 부모 클래스에서 찾게 된다.
  * 따라서 메소드 시그니쳐를 잘 못 작성한 경우, @Override가 없으면 자식 클래스에 메소드를 추가할 뿐이지만 어노테이션을 붙인 경우에는 에러가 발생한다.
* 위의 상황은 아래에서 확인할 수 있다. 부모 클래스의 hello를 재정의하려다 오타가 발생했으며, 자연스레 main에서는 부모 클래스의 메소드가 호출된다.
  * 주석 처리된 @Override의 주석을 해제할 경우, 해당 메소드가 부모 클래스에 정의되어 있지 않다는 에러가 발생한다.
  * 컴파일러에 의해 에러가 발생하므로, 개발자는 더 신속하게 문제에 대처할 수 있게 된다.
```
public class InheritanceTest {
    public static void main(String[] args) {
        Parent temp = new Child();
        temp.hello();
    }
}

class Parent {
    public void hello() {
        System.out.println("Parent method");
    }
}

class Child extends Parent {
//    @Override
    public void hell() {
        System.out.println("Hell oooo");
    }
}
```
* @Deprecated 어노테이션은 JDK 버전 업그레이드 등으로 인해 상위 호환이 추가된 메소드의 사용 중단을 권장한다.
* 신규 JDK에서 기존 메소드보다 더 향상된 메소드가 추가되었다고 기존 메소드를 삭제하면, 기존 메소드를 사용하던 개발자들은 피해를 볼 수 있다.
* 따라서 하위 호환성 유지를 위해 메소드를 남겨두지만, 더 이상 사용하지 않을 것을 권장하기 위해 메소드에 붙이는 어노테이션이다.
  * 사용 중단 권고 메시지가 출력되더라도 강제성이 없으므로, App.의 실행에는 문제가 없다.
* @FunctionalInterface 어노테이션은 추상 메소드가 하나만 존재해야하는 제약을 갖는 함수형 인터페이스의 선언에 사용한다.
  * 해당 어노테이션이 붙은 인터페이스는 함수형 인터페이스가 올바르게 선언되었는지 확인하고, 잘못된 경우에 한해 에러를 발생시킨다.

### 메타 어노테이션
* 어노테이션을 위한 어노테이션이다.
* 어노테이션을 정의할 때, 어노테이션의 적용 대상이나 유지 기간 등을 지정하는 데에 사용한다.
* 메타 어노테이션의 종류는 다음과 같다.
  1. @Target: 어노테이션의 적용 대상을 지정한다. 
    * 예를 들어, @Target({ METHOD, CONSTRUCTOR })는 메소드와 생성자에 붙일 수 있는 어노테이션을 말한다.
    * TYPE은 클래스, 인터페이스, enums 등에 어노테이션을 붙일 수 있게 한다.
  2. @Retention: 어노테이션이 유지되는 기간을 설정한다.
    * SOURCE: .java에만 존재하며, 컴파일 후 .class에는 존재하지 않는다.
      * 컴파일러가 사용하는 어노테이션이 이에 해당한다.
      * 우리가 직접 컴파일러를 제작할 것이 아니라면 작성할 필요가 없다.
    * CLASS: .class에 존재하며, 런타임에서는 존재하지 않으므로 사용이 불가능하다.
      * CLASS는 @Retention(RetentionPolicy.CLASS)와 같은 형식으로 default로 적용되는 유지 기간이다.
      * .class가 JVM에 로딩될 때 이 유지 기간이 적용된 어노테이션은 무시된다.
    * RUNTIME: .class에 존재하며, 런타임에서도 존재하므로 사용이 가능하다.
  3. @Documented: 어노테이션 정보가 javadoc으로 작성한 문서에 포함되도록 한다.
  4. @Inherited: 어노테이션이 자식 클래스에 상속되도록 한다.
    * 해당 어노테이션을 부모 클래스에 붙이면, 자식 클래스도 이 어노테이션이 붙은 것처럼 인식된다. 
  5. @Repeatable: 해당 어노테이션이 붙은 어노테이션은 여러 번 붙일 수 있다.
    * 일반적인 어노테이션과 달리, 같은 이름의 어노테이션을 하나의 대상에 여럿 적용할 수 있게 된다.
    * 이러한 어노테이션들을 하나로 묶어서 다룰 수 있는 어노테이션도 추가로 정의되어야 한다.

### 어노테이션 정의
* @를 붙이는 점을 제외하면 인터페이스의 정의 방식과 같다.
  * default 키워드를 통해 기본값을 지정할 수 있다. 
```
public @interface MyFirstAnnotation {
    String hello();
    int number() default 100;
}
```
* **어노테이션의 요소는 반환값은 있으나 매개 변수가 없는 추상 메소드의 형태**를 갖는다.
  * 인터페이스와 달리, **상속을 통해 구현하지 않아도** 좋다.
* 그러나 어노테이션을 적용할 때, 어노테이션에 포함된 요소의 값을 지정해주어야 한다.
  * default를 지정한 값은 어노테이션에 요소의 값을 작성하지 않을 경우, 기본 값이 적용된다.
```
@MyFirstAnnotation(hello = "world") // 어노테이션 사용시 작성한 메소드인 hello 요소에 대응되는 값을 적어주어야 한다.
public enum MyEnum {
    ONE,
    TWO,
    THREE,
}
```
* 어노테이션의 요소가 value라는 이름을 갖는 하나의 요소뿐인 경우, 어노테이션 적용 시 요소의 이름을 생략하고 값만 적어줄 수 있다.
```
// MyFirstAnnotation.java
public @interface MyFirstAnnotation {
    String value();
}

// MyEnum.java
@MyFirstAnnotation("world") // 요소의 이름을 생략하였다.
public enum MyEnum {
    ONE,
    TWO,
    THREE,
}
```
* 반면 요소는 하나도 지정하지 않을 수도 있다.
  * 이렇듯 요소가 하나도 정의되지 않은 어노테이션을 '마커 어노테이션'이라고 한다.

### 어노테이션 요소 작성 규칙
* 요소의 타입은 기본형, String, enums, 어노테이션, Class만 허용된다.
* 요소에는 매개 변수가 포함될 수 없다.
* 각 요소는 예외를 던질 수 없다.
* 요소는 <T>와 같은 타입 매개 변수로 정의할 수 없다.

### 참고사항
* 모든 클래스 파일은 클래스로더에 의해 메모리에 적재된다.
* 이 때, 적재 시점에 **클래스의 정보가 담긴 인스턴스를 생성하며, 이를 클래스 객체**라고 한다.
* **클래스 객체를 참조할 때는 [클래스명].class의 형식을 사용**해야만 한다.
* **클래스 객체는 해당 클래스의 모든 정보를 갖고, 어노테이션의 정보도 여기에 포함**된다.
  * 클래스 객체의 getAnnotation() 메소드를 활용하여 어노테이션 정보를 받아올 수 있다.
    * getAnnotation()에 매개 변수를 포함하는 경우, 해당 어노테이션에 대한 정보를 반환한다.
    * getAnnotation()에 매개 변수를 포함하지 않는 경우, 해당 클래스의 모든 어노테이션 정보를 배열로 가져올 수 있다.

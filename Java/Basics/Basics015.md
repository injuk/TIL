# Java
## 2022-01-11 Tue

### 제네릭
* 제네릭은,
    1. 다양한 타입의 인스턴스를 다루는 메소드나,
    2. 다양한 타입의 인스턴스를 다루는 컬렉션 클래스에,
* 컴파일 시 타입체크를 해주는 기능이다.
  * 쉽게 말해, 어떤 클래스나 메소드가 다룰 타입을 미리 명시하는 것으로 번거로운 형변환을 줄여준다.
  * 덕분에 타입체크와 형변환 코드를 생략할 수 있어 코드가 간결해진다.
* 인스턴스의 타입을 컴파일 시점에 체크하므로 인스턴스의 타입 안정성을 높이고, 형변환의 번거로움이 줄어든다.
    1. 타입 안정성을 높인다: 원하지 않은 타입의 인스턴스가 저장되는 것을 막는다.
    2. 형변환의 번거로움이 줄어든다: 인스턴스를 꺼내올 때 다른 타입으로 잘못 형변환되는 상황을 줄여준다.
* ArrayList와 같은 컬렉션 클래스는 다양한 타입의 인스턴스를 담을 수 있지만, 일반적으로는 하나의 타입만을 다룬다.
  * 이 때, 꺼낼 때마다 인스턴스의 타입을 체크하는 것은 불편하다.
  * 또한, 꺼낼 때마다 형변환을 해주는 것도 불편하다.
  * 심지어 원치 않는 타입의 인스턴스가 저장되는 것을 막을 방법이 없다.
  * 제네릭은 이러한 문제점을 해결해준다!

### 클래스의 제네릭
* 클래스에 선언하는 제네릭은 다음과 같다.
```
class Temp<T> {
    T temp;
    void setTemp(T temp) {
        this.temp = temp;
    } 
}
```
* 이 때, <T>는 타입 변수라고 하며, Type의 머릿 글자를 따온 것으로 이해할 수 있다.
  * T가 아닌 다른 글자를 사용하여도 무방하다.
  * 오히려 항상 T를 고집하는 것보다는 시멘틱을 고려한 문자 선정이 바람직하다.
* 타입 변수가 여럿인 경우, <K, V>와 같이 쉼표로 구분한다.
* 타입 변수는 작성한 글자에 관계 없이 **임의의 참조형 타입**을 의미한다.
* JDK 1.5에서 제네릭이 출시되기 전에는 다양한 타입을 다루는 클래스는 모두 Object 타입을 사용하였다.
  * 그러나 **이러한 방식은 번거로이 형변환 작업을 해주어야 하는 문제점**이 있다.
  * 제네릭을 사용할 경우, 타입 변수를 지정하는 것으로 원하는 참조형 타입을 사용할 수 있다.
* 제네릭 클래스인 Temp 클래스의 객체를 생성하는 경우, 다음과 같이 Temp에서 사용할 실제 타입을 명시해준다.
```
Temp<Integer> temp = new Temp<Integer>();
temp.setTemp(1); // 오토 박싱
```
* JDK 1.5 이전에 작성된 코드와의 호환성 유지를 위해, 제네릭 클래스여도 타입 변수를 생략한 인스턴스 생성이 허용된다.
  * **이 경우, 타입 변수 T는 Object로 간주**된다.
```
Temp temp = new Temp();
temp.setTemp(1);
```
* 제네릭 클래스의 인스턴스를 생성할 때, 인스턴스 별로 다른 타입을 지정할 수 있다. 애초에 제네릭은 인스턴스 별로 다르게 동작시키기 위해 고안되었다.
* 그러나 모든 인스턴스에 대해 동일하게 동작해야하는 static 멤버에는 타입 변수를 적용할 수 없다.
  * **타입 변수는 인스턴스 변수로 간주**된다!
  * static 멤버는 타입 변수에 지정된 타입과 관계 없이 동일해야 하기 떄문이다.
* 제네릭 타입의 배열은 생성할 수 없다.
  * new 연산자는 컴파일 시점에 타입 변수의 값을 정확히 알아야 한다.
  * 그러나 컴파일 시점에 타입 변수의 값을 정확히 알 수 없는 경우가 있으므로, new를 통한 생성이 필요한 배열에는 제네릭 타입을 적용할 수 없다.
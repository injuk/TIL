# Java
## 2022-01-10 Mon

### Collections Framework
* Java의 데이터들이 모인 데이터 그룹을 다루고 표현하기 위한 단일화된 구조이다.
  * 이 때, **컬렉션은 다수의 데이터를 저장하는 클래스**, 또는 데이터의 모음인 데이터 그룹을 의미한다.
* 컬렉션 프레임워크는 JDK 1.2에서 출시되었으며, **다양한 컬렉션을 단일화된 구조로 처리할 수 있도록 지원**한다.
  * JDK 1.2 이전까지는 Vector, Hashtable, Properties와 같은 컬렉션 클래스를 각자 다른 방식으로 처리해왔다.
* 컬렉션 프레임워크는 **데이터 그룹을 크게 3가지 종류로 나눌 수 있다는 전제 하에 각각의 종류에 맞는 3개의 인터페이스를 정의**한다.
  1. List: 순서가 있는 데이터의 집합이며, 데이터가 중복될 수 있다.
    * ArrayList, LinkedList, ...
  2. Set: 순서가 없는 데이터의 집합이며, 데이터가 중복될 수 없다.
    * HashSet, TreeSet, ...
  3. Map: K-V 구조로 이루어진 데이터의 집합이며, 순서가 없다.
    * 키는 중복될 수 없지만 값은 중복될 수 있다.
    * HashMap, TreeMap, ...
* 이 중 List와 Set은 다시 공통되는 부분을 부모 인터페이스인 Collection에 정의하고 있다.
* **모든 컬렉션 클래스는 List, Set, Map 중 하나를 구현하고 있으며, 구현한 인터페이스의 이름이 클래스의 이름에 포함**된다.
* JDK 1.5에 추가된 Iterable은 인터페이스들의 공통적인 메소드인 Iterator()를 정의하며, Collection이 이를 상속 받도록 부모 인터페이스로서 구현되어 있다.
* App. 개발 시에는 각각의 컬렉션의 특징을 파악하고, 적절한 컬렉션 클래스의 사용을 결정하는 것이 바람직하다.
* Vector, HashTable, Properties와 같은 클래스들은 JDK 1.2 이전부터 존재하던 클래스이므로 되도록이면 사용을 지양하자.
  * 기존 컬렉션 클래스들 역시 설계가 변경되어 컬렉션 프레임워크와 호환이 가능하다고 한다.

### Collection, List, Set, Map interface
* Collection 인터페이스는 List와 Set의 조상이다.
  * 컬렉션 클래스에 저장된 데이터를 읽고, 추가하고, 삭제하는 등 컬렉션을 다루기 위한 가장 기본적인 메소드들이 정의된다.
  * 반환형이 boolean인 메소드들은 모두 작업 성공 여부를 반환한다.
  * iterator()는 컬렉션의 Iterator를 반환하는 메소드이다.
* List 인터페이스는 중복을 허용하며, 저장 순서를 유지하는 컬렉션을 구현할 때 사용한다.
* Set 인터페이스는 중복을 허용하지 않고, 저장 순서가 유지되지 않는 컬렉션을 구현할 때 사용한다.
* Map 인터페이스는 키 값 쌍으로 저장되는 컬렉션 클래스를 구현할 때 사용한다.
  * Map에 저장된 특정한 data를 찾기 위해 사용되는 키는 중복될 수 없는 반면, 값은 중복될 수 있다.

## TIL에서는 클래스와 관련된 메소드의 설명을 모두 적지 않았다.
### ArrayList
* 컬렉션 프레임워크에서 가장 많이 사용되는 컬렉션 클래스이다.
* List 인터페이스를 구현하므로, 데이터의 저장 순서가 유지되고 중복이 허용된다.
* Object 배열을 통해 데이터를 순차적으로 저장하며, 배열에 더 이상 저장할 공간이 없으면 더 큰 배열을 생성해서 기존의 내용을 옮기는 식으로 동작한다.
  * 당연히, 내용을 옮기는 과정은 많은 시간이 소요된다.
* ArrayList와 같이 배열을 이용한 자료구조는 데이터를 읽고 저장하는데는 효율이 좋지만, capacity를 변경하는 경우에는 새로운 배열을 생성한 후 데이터를 복사하므로 효율이 떨어진다.
  * 읽기 연산을 예로 들어, **배열의 경우 시작 주소와 배열을 구성하는 요소의 크기, 인덱스를 통한 간단한 연산으로 특정 인덱스가 가리키는 메모리 주소에 바로 접근**할 수 있다.

### LinkedList
* 배열은 가장 기본적인 자료구조로, 간단하며 사용이 쉽다. 또한, 데이터에 접근하는 시간이 가장 빠르다.
* 반면 크기를 변경할 수 없고, 배열 중간의 데이터를 추가하거나 삭제하는데에 시간이 오래 걸린다.
  * 즉, 읽기는 빠르지만 쓰기, 제거는 조건부로 오래 걸린다.
  * 또한 배열을 옮기는 과정에서 불필요한 메모리가 낭비될 수 있다.
* Linked List는 이러한 단점을 해결하기 위해 설계되었다.
  1. 데이터를 연속적으로 배치하여 다루는 배열과 달리, 불규칙적인 위치의 데이터를 연결한 형태를 취한다.
  2. 데이터 추가 / 제거시 참조만 변경하므로, 배열처럼 데이터를 생성하고 옮기는 과정이 필요하지 않다.
* 자료 구조로서의 Linked List는 다음 요소에 대한 접근이 쉽지만, 이전 요소에 대한 접근이 어렵다.
  * 이를 보완하여 이전 요소에 대한 참조 변수를 포함하도록 한 것이 Double Linked List이다.
  * List 인터페이스를 구현한 **LinkedList는 실제로는 Double Linked List로 구현되어 있다**.
* LinkedList 클래스 역시 List 인터페이스를 구현하므로, ArrayList와 내부 구현 방식만 다를 뿐 사용법은 대동소이하다.
  * 즉, LinkedList 클래스의 인스턴스를 다루기 위해 사용하는 메소드의 종류와 기능이 유사하다.

### ArrayList vs LinkedList
* 데이터를 순차적으로 추가 / 제거하는 경우, ArrayList가 빠르다.
* 중간의 데이터를 임의로 추가 / 제거하는 경우, LinkedList가 빠르다.
  * **데이터의 개수가 많지 않다면, 두 클래스는 큰 차이가 나지 않는다**.
* 읽기 연산의 경우,
  1. ArrayList: 내부적으로 연속적으로 위치한 배열을 사용하므로 빠르다.
  2. LinkedList: 불연속적으로 위치한 각 요소들의 연결성을 추적하는 과정이 필요하므로, 상대적으로 느리다.
    * 이러한 단점은 데이터의 개수가 많아질수록 부각된다. 
* 두 클래스의 장단점을 이해하고, 상황에 따라 적절한 클래스를 사용하려는 고민이 필요하다.
  * 데이터의 **개수가 잘 변하지 않는다면, ArrayList**가 적절하다.
  * 데이터의 **변경이 잦은 경우라면, LinkedList**가 좋은 선택이 될 수 있다.
* 또는 두 클래스를 조합해서 사용해볼 수도 있다. 대부분의 컬렉션 클래스들은 서로 변환이 가능하도록 Collection 클래스를 인자로 받는 생성자가 존재한다!

### 이터레이터
* 컬렉션 프레임워크는 컬렉션에 저장된 요소들을 읽어오는 방법을 표준화하였다.
* Iterator는 컬렉션에 저장된 요소에 접근하기 위해 정의된 인터페이스이다.
* Collection 인터페이스는 Iterator 인스턴스를 반환하는 iterator 메소드를 정의하고 있다.
  * ListIterator는 Iterator의 기능을 향상시킨 것이다.
* List와 Set은 Collection의 자식이므로 iterator가 각 컬렉션의 성질에 맞게 구현되어 있다.
* iterator()를 호출하는 것으로 Iterator 인스턴스를 반환받을 수 있고, 반복문을 통해 컬렉션 클래스의 요소를 읽어올 수 있다.
* List 인터페이스를 구현하는 컬렉션 클래스들은 저장 순서가 유지되므로 Iterator를 통한 요소 접근의 순서가 같다.
* 반면 Set 인터페이스를 구현하는 컬렉션 클래스들은 순서가 유지되지 않으므로, 요소 접근의 순서와 저장 순서가 달라질 수 있다.
* 이 때, 이터레이터에서 주로 사용하는 메소드는 다음과 같다.
 1. hasNext(): 다음으로 읽어들일 요소가 있는지 확인하며, 여부를 boolean으로 반환한다.
 2. next(): 다음 요소들 읽어 반환한다. 
  * next 메소드 호출 전에 hasNext를 호출하여 확인을 먼저 해두는 것이 바람직하다.
 3. remove(): next()로 읽어온 요소를 삭제한다.
  * Iterator의 remove 메소드는 단독으로 쓰일 수 없다. 특정 위치의 요소를 삭제하는 것이 아니라 한 번 읽어온 요소를 삭제하는 것이기 때문이다.
  * 때문에 **반드시 next를 호출한 다음에 remove를 호출**해야 한다!
* **이터레이터는 컬렉션의 마지막 요소에 다다르면 더 이상 사용할 수 없다**.
* **이터레이터는 컬렉션의 요소를 읽어오는 방법을 하나의 표준화된 방식으로 제공하는 데에 의의**가 있다.
  * 객체지향은 이렇듯 공통 인터페이스를 정의하여 표준을 따르도록 유도함으로써 코드의 일관성을 유지하고, 재사용성을 극대화한다.
* **Map 인터페이스를 구현하는 컬렉션 클래스는 K-V 쌍을 사용하므로 iterator 메소드를 직접 호출할 수 없다**.
  * 대신 keySet() 또는 entrySet()을 통해 우선 Set의 형태로 반환한 후, iterator를 통해 요소에 접근할 수 있다.

### List list = new ArrayList() vs ArrayList list = new ArrayList()
* List에 없고 ArrayList에만 있는 메소드를 사용하는 것이 아니라면, List나 Collection 타입의 참조변수를 선언하는 것이 좋다.
* 추후 코드의 변경으로 인해 ArrayList가 아닌 다른 Collection 클래스를 사용한다면, 선언문만 바꾸어주면 이후의 코드를 검토할 필요가 없다.
  * 참조 변수의 타입이 **List(또는 Collection)에만 있는 메소드를 사용했을 것이 확실하기 때문**이다.
* 반면 후자의 방식으로 선언했다면, ArrayList만의 메소드를 사용했을 수도 있으므로 혹시 모를 상황에 대비하기 위해 이후의 코드도 검토해주어야 한다.

### Enumeration, ListIterator
* Enumeration은 컬렉션 프레임워크 이전에 사용하던 것이므로, 코드 호환성 유지 문제가 아닌 경우라면 Iterator를 사용하자.
* ListIterator는 Iterator를 상속받아 양방향 조회를 가능하도록 정의되었다.
  * ListIterator이므로, List 인터페이스를 구현한 컬렉션(ArrayList, LinkedList, 등)에서만 사용할 수 있다.
* ListIterator는 Iterator에 앞방향 조회 기능이 추가된다.
 1. hasPrevious(): 읽어 올 이전 요소가 있는지 여부를 boolean으로 반환한다.
 2. previous(): 이전 요소를 읽어온다.
  * Iterator의 next()와 같이, previous를 호출하기 전에 hasPrevious를 호출해주는 것이 바람직하다.
* 마지막 요소에 다다르면 더 이상 사용할 수 없는 Iterator와 달리, ListIterator는 요소간의 이동이 자유롭다.
* 참고: 인터페이스를 구현할 때 선택적이 기능인 경우
  * 선택적 기능은 반드시 구현하지 않아도 되는 기능을 말하는 용어이다.
  * 그러나 인터페이스를 구현하는 클래스는 모든 메소드 바디를 작성해야 하는 문제가 있다.
  * 이 때, 상속받은 추상 메소드의 본문을 다음과 같이 작성하는 것으로 메소드 호출자에게 명시적으로 지원되지 않는 메소드임을 알리는 것이 좋다.
    * 이는 사용자가 직접 API 문서를 열어 확인해야 하는 경우를 방지하기 위해 명시적으로 예외를 발생시키는 것이다.
```
public void remove() {
    throw new UnsupportedOperationException();
}
```

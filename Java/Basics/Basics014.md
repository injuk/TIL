# Java
## 2022-01-10 Mon

### Collections Framework
* Java의 데이터들이 모인 데이터 그룹을 다루고 표현하기 위한 단일화된 구조이다.
  * 이 때, **컬렉션은 다수의 데이터를 저장하는 클래스**, 또는 데이터의 모음인 데이터 그룹을 의미한다.
* 컬렉션 프레임워크는 JDK 1.2에서 출시되었으며, **다양한 컬렉션을 단일화된 구조로 처리할 수 있도록 지원**한다.
  * JDK 1.2 이전까지는 Vector, Hashtable, Properties와 같은 컬렉션 클래스를 각자 다른 방식으로 처리해왔다.
* 컬렉션 프레임워크는 **데이터 그룹을 크게 3가지 종류로 나눌 수 있다는 전제 하에 각각의 종류에 맞는 3개의 인터페이스를 정의**한다.
  1. List: 순서가 있는 데이터의 집합이며, 데이터가 중복될 수 있다.
    * ArrayList, LinkedList, ...
  2. Set: 순서가 없는 데이터의 집합이며, 데이터가 중복될 수 없다.
    * HashSet, TreeSet, ...
  3. Map: K-V 구조로 이루어진 데이터의 집합이며, 순서가 없다.
    * 키는 중복될 수 없지만 값은 중복될 수 있다.
    * HashMap, TreeMap, ...
* 이 중 List와 Set은 다시 공통되는 부분을 부모 인터페이스인 Collection에 정의하고 있다.
* **모든 컬렉션 클래스는 List, Set, Map 중 하나를 구현하고 있으며, 구현한 인터페이스의 이름이 클래스의 이름에 포함**된다.
* JDK 1.5에 추가된 Iterable은 인터페이스들의 공통적인 메소드인 Iterator()를 정의하며, Collection이 이를 상속 받도록 부모 인터페이스로서 구현되어 있다.
* App. 개발 시에는 각각의 컬렉션의 특징을 파악하고, 적절한 컬렉션 클래스의 사용을 결정하는 것이 바람직하다.
* Vector, HashTable, Properties와 같은 클래스들은 JDK 1.2 이전부터 존재하던 클래스이므로 되도록이면 사용을 지양하자.
  * 기존 컬렉션 클래스들 역시 설계가 변경되어 컬렉션 프레임워크와 호환이 가능하다고 한다.

### Collection, List, Set, Map interface
* Collection 인터페이스는 List와 Set의 조상이다.
  * 컬렉션 클래스에 저장된 데이터를 읽고, 추가하고, 삭제하는 등 컬렉션을 다루기 위한 가장 기본적인 메소드들이 정의된다.
  * 반환형이 boolean인 메소드들은 모두 작업 성공 여부를 반환한다.
  * iterator()는 컬렉션의 Iterator를 반환하는 메소드이다.
* List 인터페이스는 중복을 허용하며, 저장 순서를 유지하는 컬렉션을 구현할 때 사용한다.
* Set 인터페이스는 중복을 허용하지 않고, 저장 순서가 유지되지 않는 컬렉션을 구현할 때 사용한다.
* Map 인터페이스는 키 값 쌍으로 저장되는 컬렉션 클래스를 구현할 때 사용한다.
  * Map에 저장된 특정한 data를 찾기 위해 사용되는 키는 중복될 수 없는 반면, 값은 중복될 수 있다.

## TIL에서는 클래스와 관련된 메소드의 설명을 모두 적지 않았다.
### ArrayList
* 컬렉션 프레임워크에서 가장 많이 사용되는 컬렉션 클래스이다.
* List 인터페이스를 구현하므로, 데이터의 저장 순서가 유지되고 중복이 허용된다.
* Object 배열을 통해 데이터를 순차적으로 저장하며, 배열에 더 이상 저장할 공간이 없으면 더 큰 배열을 생성해서 기존의 내용을 옮기는 식으로 동작한다.
  * 당연히, 내용을 옮기는 과정은 많은 시간이 소요된다.
* ArrayList와 같이 배열을 이용한 자료구조는 데이터를 읽고 저장하는데는 효율이 좋지만, capacity를 변경하는 경우에는 새로운 배열을 생성한 후 데이터를 복사하므로 효율이 떨어진다.
  * 읽기 연산을 예로 들어, **배열의 경우 시작 주소와 배열을 구성하는 요소의 크기, 인덱스를 통한 간단한 연산으로 특정 인덱스가 가리키는 메모리 주소에 바로 접근**할 수 있다.

### LinkedList
* 배열은 가장 기본적인 자료구조로, 간단하며 사용이 쉽다. 또한, 데이터에 접근하는 시간이 가장 빠르다.
* 반면 크기를 변경할 수 없고, 배열 중간의 데이터를 추가하거나 삭제하는데에 시간이 오래 걸린다.
  * 즉, 읽기는 빠르지만 쓰기, 제거는 조건부로 오래 걸린다.
  * 또한 배열을 옮기는 과정에서 불필요한 메모리가 낭비될 수 있다.
* Linked List는 이러한 단점을 해결하기 위해 설계되었다.
  1. 데이터를 연속적으로 배치하여 다루는 배열과 달리, 불규칙적인 위치의 데이터를 연결한 형태를 취한다.
  2. 데이터 추가 / 제거시 참조만 변경하므로, 배열처럼 데이터를 생성하고 옮기는 과정이 필요하지 않다.
* 자료 구조로서의 Linked List는 다음 요소에 대한 접근이 쉽지만, 이전 요소에 대한 접근이 어렵다.
  * 이를 보완하여 이전 요소에 대한 참조 변수를 포함하도록 한 것이 Double Linked List이다.
  * List 인터페이스를 구현한 **LinkedList는 실제로는 Double Linked List로 구현되어 있다**.
* LinkedList 클래스 역시 List 인터페이스를 구현하므로, ArrayList와 내부 구현 방식만 다를 뿐 사용법은 대동소이하다.
  * 즉, LinkedList 클래스의 인스턴스를 다루기 위해 사용하는 메소드의 종류와 기능이 유사하다.

### ArrayList vs LinkedList
* 데이터를 순차적으로 추가 / 제거하는 경우, ArrayList가 빠르다.
* 중간의 데이터를 임의로 추가 / 제거하는 경우, LinkedList가 빠르다.
  * **데이터의 개수가 많지 않다면, 두 클래스는 큰 차이가 나지 않는다**.
* 읽기 연산의 경우,
  1. ArrayList: 내부적으로 연속적으로 위치한 배열을 사용하므로 빠르다.
  2. LinkedList: 불연속적으로 위치한 각 요소들의 연결성을 추적하는 과정이 필요하므로, 상대적으로 느리다.
    * 이러한 단점은 데이터의 개수가 많아질수록 부각된다. 
* 두 클래스의 장단점을 이해하고, 상황에 따라 적절한 클래스를 사용하려는 고민이 필요하다.
  * 데이터의 **개수가 잘 변하지 않는다면, ArrayList**가 적절하다.
  * 데이터의 **변경이 잦은 경우라면, LinkedList**가 좋은 선택이 될 수 있다.
* 또는 두 클래스를 조합해서 사용해볼 수도 있다. 대부분의 컬렉션 클래스들은 서로 변환이 가능하도록 Collection 클래스를 인자로 받는 생성자가 존재한다!

### 이터레이터
* 컬렉션 프레임워크는 컬렉션에 저장된 요소들을 읽어오는 방법을 표준화하였다.
* Iterator는 컬렉션에 저장된 요소에 접근하기 위해 정의된 인터페이스이다.
* Collection 인터페이스는 Iterator 인스턴스를 반환하는 iterator 메소드를 정의하고 있다.
  * ListIterator는 Iterator의 기능을 향상시킨 것이다.
* List와 Set은 Collection의 자식이므로 iterator가 각 컬렉션의 성질에 맞게 구현되어 있다.
* iterator()를 호출하는 것으로 Iterator 인스턴스를 반환받을 수 있고, 반복문을 통해 컬렉션 클래스의 요소를 읽어올 수 있다.
* List 인터페이스를 구현하는 컬렉션 클래스들은 저장 순서가 유지되므로 Iterator를 통한 요소 접근의 순서가 같다.
* 반면 Set 인터페이스를 구현하는 컬렉션 클래스들은 순서가 유지되지 않으므로, 요소 접근의 순서와 저장 순서가 달라질 수 있다.
* 이 때, 이터레이터에서 주로 사용하는 메소드는 다음과 같다.
 1. hasNext(): 다음으로 읽어들일 요소가 있는지 확인하며, 여부를 boolean으로 반환한다.
 2. next(): 다음 요소들 읽어 반환한다. 
  * next 메소드 호출 전에 hasNext를 호출하여 확인을 먼저 해두는 것이 바람직하다.
 3. remove(): next()로 읽어온 요소를 삭제한다.
  * Iterator의 remove 메소드는 단독으로 쓰일 수 없다. 특정 위치의 요소를 삭제하는 것이 아니라 한 번 읽어온 요소를 삭제하는 것이기 때문이다.
  * 때문에 **반드시 next를 호출한 다음에 remove를 호출**해야 한다!
* **이터레이터는 컬렉션의 마지막 요소에 다다르면 더 이상 사용할 수 없다**.
* **이터레이터는 컬렉션의 요소를 읽어오는 방법을 하나의 표준화된 방식으로 제공하는 데에 의의**가 있다.
  * 객체지향은 이렇듯 공통 인터페이스를 정의하여 표준을 따르도록 유도함으로써 코드의 일관성을 유지하고, 재사용성을 극대화한다.
* **Map 인터페이스를 구현하는 컬렉션 클래스는 K-V 쌍을 사용하므로 iterator 메소드를 직접 호출할 수 없다**.
  * 대신 keySet() 또는 entrySet()을 통해 우선 Set의 형태로 반환한 후, iterator를 통해 요소에 접근할 수 있다.

### List list = new ArrayList() vs ArrayList list = new ArrayList()
* List에 없고 ArrayList에만 있는 메소드를 사용하는 것이 아니라면, List나 Collection 타입의 참조변수를 선언하는 것이 좋다.
* 추후 코드의 변경으로 인해 ArrayList가 아닌 다른 Collection 클래스를 사용한다면, 선언문만 바꾸어주면 이후의 코드를 검토할 필요가 없다.
  * 참조 변수의 타입이 **List(또는 Collection)에만 있는 메소드를 사용했을 것이 확실하기 때문**이다.
* 반면 후자의 방식으로 선언했다면, ArrayList만의 메소드를 사용했을 수도 있으므로 혹시 모를 상황에 대비하기 위해 이후의 코드도 검토해주어야 한다.

### Enumeration, ListIterator
* Enumeration은 컬렉션 프레임워크 이전에 사용하던 것이므로, 코드 호환성 유지 문제가 아닌 경우라면 Iterator를 사용하자.
* ListIterator는 Iterator를 상속받아 양방향 조회를 가능하도록 정의되었다.
  * ListIterator이므로, List 인터페이스를 구현한 컬렉션(ArrayList, LinkedList, 등)에서만 사용할 수 있다.
* ListIterator는 Iterator에 앞방향 조회 기능이 추가된다.
 1. hasPrevious(): 읽어 올 이전 요소가 있는지 여부를 boolean으로 반환한다.
 2. previous(): 이전 요소를 읽어온다.
  * Iterator의 next()와 같이, previous를 호출하기 전에 hasPrevious를 호출해주는 것이 바람직하다.
* 마지막 요소에 다다르면 더 이상 사용할 수 없는 Iterator와 달리, ListIterator는 요소간의 이동이 자유롭다.
* 참고: 인터페이스를 구현할 때 선택적이 기능인 경우
  * 선택적 기능은 반드시 구현하지 않아도 되는 기능을 말하는 용어이다.
  * 그러나 인터페이스를 구현하는 클래스는 모든 메소드 바디를 작성해야 하는 문제가 있다.
  * 이 때, 상속받은 추상 메소드의 본문을 다음과 같이 작성하는 것으로 메소드 호출자에게 명시적으로 지원되지 않는 메소드임을 알리는 것이 좋다.
    * 이는 사용자가 직접 API 문서를 열어 확인해야 하는 경우를 방지하기 위해 명시적으로 예외를 발생시키는 것이다.
```
public void remove() {
    throw new UnsupportedOperationException();
}
```

### Comparable, Comparator
* 둘 모두 인터페이스이며, 컬렉션 정렬에 필요한 메소드를 정의하고 있다.
* Comparable을 구현하는 클래스는 **같은 클래스끼리 비교할 수 있는 클래스**이다. 
  * 따라서 이를 구현한 클래스는 정렬이 가능한 클래스임을 뜻한다.
* Comparable은 int를 반환하는 compareTo를 구현하는 것으로 기본적인 비교 및 정렬에 활용할 수 있다.
  * 이 때, 같으면 0 / 값이 더 작으면 음수 / 크면 양수를 반환하도록 구현되어야 한다.
* Comparator는 int를 반환하는 compare 메소드를 구현하는 것으로 새로운 비교 및 정렬 방법을 정의할 수 있다.
* Comparable과 Comparator의 차이는 다음과 같다.
  * Comparable: 기본적인 정렬 기준을 정의한다.
  * Comparator: 기본 정렬 기준 이외에 다른 기준을 적용하고 싶을 때 사용한다.

### HashSet
* Set 인터페이스를 구현하는 가장 대표적인 컬렉션이다.
* Set 인터페이스는 중복을 허용하지 않고 순서가 없으며, 이는 HashSet 또한 마찬가지이다.
  * 만약 중복된 값을 add 또는 addAll로 추가하는 경우, 결과로 false가 반환된다.
  * 순서를 보장하는 Set을 사용하고 싶다면 LinkedHashSet 클래스를 사용해야 한다.
* 개발자가 추가한 클래스의 경우, hashCode와 equals 메소드를 적절히 오버라이딩해야 Set의 중복 방지 효과를 누릴 수 있다.
  * **hashCode의 경우 Object 클래스로부터 상속받은 hashCode를 적절히 활용하더라도 무방하지만, 가능하면 JDK 1.8에 추가된 static 메소드인 Objects.hash()를 사용**하자.
* hashCode를 재정의하는 경우, 반드시 다음의 조건을 충족해야 한다.
  1. 동일한 인스턴스에 대해 여러번 hashCode를 호출해도 항상 같은 int가 반환되어야 한다.
  2. equals 메소드의 결과가 true인 두 객체는 항상 hashCode 값이 같아야 한다.
    * equals가 true이고 hashCode도 같아야 하므로, 새로운 클래스의 equals를 오버라이드하는 경우라면 hashCode도 함께 수정하는 것이 바람직하다.
  3. equals 메소드의 결과가 false인 두 객체는 hashCode 값이 같을 수 있지만, 되도록 다른 값을 반환해야 한다.
    * Hashtable, HashMap 등은 hashCode의 결과가 중복되는 경우가 많을수록 성능이 떨어진다고 한다. 

### TreeSet
* 내부적으로 이진 검색 트리를 개선시킨 Red Black Tree로 구현되어 있다.
* Set 인터페이스를 구현하므로, 중복된 데이터를 허용하지 않고 저장 순서를 유지하지 않는다.
* 그러나 추가되는 요소들은 항상 다음과 같이 정렬된다.
  1. 내부적으로 트리 형태의 노드를 갖고, 처음 삽입된 값을 루트로 삼는다.
  2. 이후에 추가된 값은 점점 깊은 depth로 내려가며 값을 비교하고, 값이 작은 경우 왼쪽 / 큰 경우 오른쪽으로 배치한다.
  3. 이렇듯 항상 값이 정렬되어 저장되므로, 별도의 정렬 메소드를 호출하지 않아도 좋다.
* TreeSet에 인스턴스를 저장하는 경우, 정렬을 위해 해당 인스턴스의 클래스가 Comparable을 구현하거나 별도의 Comparator를 제공해주어야 한다.
* TreeSet은 **정렬된 상태를 유지하므로 단일 값 검색 또는 범위 검색이 매우 빠르다**.
  * 다루는 데이터가 엄청나게 많아지더라도 검색 효율이 매우 좋은 구조를 갖는 클래스이다.
* 반면 데이터 추가시 저장 위치를 찾는 과정이 필요하고, 데이터 제거시 Tree의 일부를 재구성하므로 삽입 / 제거 효율은 LinkedList보다 떨어진다.
* Tree의 값 중 기준값보다 작거나 큰 값을 찾기 위한 다음의 메소드가 제공된다.
  1. headSet: 인자로 넘겨준 값보다 작은 값들을 반환한다. 내부적으로는 해당 기준 값의 왼 편에 위치한 값들이 된다.
  2. tailSet: 인자로 넘겨준 값보다 큰 값들을 반환한다. 내부적으로는 해당 기준 값의 왼 편에 위치하지 않은 값들이 된다.

### HashMap
* HashMap은 기존의 Hashtable을 대체하며, Map을 구현하는 클래스이므로 K-V 쌍으로 데이터 엔트리를 저장한다.
  * 데이터의 순서는 저장 순서와 같지 않으며, 순서를 보장하고 싶은 경우 LinkedHashMap을 고려할 수 있다.
* 내부적으로는 해싱 기법을 사용하므로, 데이터의 검색 효율이 뛰어난 컬렉션 클래스이다.
* **HashMap은 키와 값을 모두 Object 타입으로 저장**한다.
  * 따라서 키는 객체일 수 있지만, 일반적으로 String을 사용하곤 한다.
  * 값 역시 Object 타입으로 저장되므로, 값이 또 다른 HashMap이 될 수 있다.
* 키는 컬렉션 내부에서 반드시 유일한 값이어야 한다.
  * 키는 HashMap 내부에서 관리되는 값을 찾기 위해 사용되므로 유일하며, 따라서 HashMap에서 키로 검색한 결과는 항상 하나여야 한다.
  * 중복된 키로 put 메소드를 호출한 경우, 해당 키와 매핑된 값은 나중에 저장된 값으로 덮어 씌워진다.
  * 키로 null을 허용한다.
* 값은 컬렉션 내부에서 중복을 허용한다.
  * 값으로 null을 허용한다.
* 컬렉션 요소 순회시 **Iterator가 포함되지 않으므로, Set을 반환하는 entrySet / keySet 또는 Collection을 반환하는 values 메소드를 적절히 활용**하여야 한다.

### TreeMap
* 이진 검색 트리의 형태로 K-V 쌍으로 이루어진 데이터를 저장한다.
  * 당연히 검색과 정렬 효율이 좋다.
* HashMap과 비교할 경우, 검색 성능은 대부분 HashMap이 앞선다.
  * 따라서 범위 검색이나 정렬이 필요한 경우가 아니라면 HashMap을 더 우선적으로 고려하는 것이 좋다.

### Properties
* HashMap의 구버전인 Hashtable을 상속받아 구현된 클래스이다.
* K-V 쌍을 Object가 아닌 String: String 형태로 저장하는 단순화된 클래스이다.
* 주로 App.의 환경 설정과 관련된 속성 저장에 사용된다.
* Hashtable을 구현하므로 Properties 클래스 역시 데이터의 저장 순서를 유지하지 않는다.

### Collections
* 배열과 관련된 메소드를 제공하는 Arrays 클래스처럼, 컬렉션과 관련된 메소드는 Collections 클래스가 제공한다.
  * Collection은 인터페이스이고, Collections는 클래스임을 혼동하지 말자.

### ArrayList, LinkedList, HashMap
* 컬렉션 클래스에서 빈번하게 사용되는 클래스들이다.
* ArrayList: 배열 기반이며, 데이터의 추가 / 제거가 아쉽다. 반면 순차적인 추가 / 제거가 가장 빠르고, 임의의 요소에 대한 접근이 빠르다.
* LinkedList: 연결 기반이며, 데이터의 추가 / 제거가 유리하다. 반면 임의의 요소에 대한 접근이 상대적으로 느리다.
* HashMap: 내부적으로 배열과 연결을 결합한 형태를 띈다. 추가, 제거, 검색 모두 전반적으로 뛰어나며, 특히 검색 성능은 가장 뛰어나다.

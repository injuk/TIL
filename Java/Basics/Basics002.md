# Java
## 2022-01-02 Sun

### 변수
* 변수란 값을 저장할 수 있는 메모리상의 공간이다.
  * 타입: 메모리상에 할당할 공간을 결정한다.
  * 변수명: 메모리상에 할당된 공간을 재사용하기 위해 메모리 공간에 붙인 이름이다.
  * 값: 변수에 값을 할당한다.
    * 메모리는 여러 프로그램이 공유하는 자원이므로, 다른 프로그램에서 사용한 값이 잔재될 수 있음
    * 이러한 값이 쓰레기 값으로, C와 같은 언어의 경우 이를 초기화해주는 과정이 필수적
```
[타입] [변수명] = [값];
```

### 식별자
* 변수 이름 등, 프로그래밍에서 사용되는 이름을 모두 식별자라고 한다.
* 명명규칙: 
  * 길이에 제한이 없다.
  * 숫자로 시작할 수 없다.
  * 특문은 _와 $만이 허용된다.
* 권장규칙(coding convention):
  * 클래스 이름은 PascalCase를 따른다.
  * 클래스 이외에 여러 단어로 구성된 식별자는 camelCase를 따른다.
  * 상수의 이름은 모두 대문자로 하되, snake_case를 따른다.
  * 변수의 이름을 가능한 한 짧게 한다.
  * 그러나 변수의 용도를 알기 쉽게 하기 변수의 이름이 길어질 수 있다.

### 자료형(data type)
* 변수에 저장될 값의 종류에 따라 값이 저장될 공간의 크기와 저장 형식을 정의한 것이다.
  * 문자형: char
  * 정수형: byte, short, int, long
  * 실수형: float, double
* 크게 기본형과 참조형으로 나뉜다.
  * 기본형: **실제 값**을 저장한다.
    * 위 자료형 7종에 boolean 형을 더한 8종이 해당한다.
  * 참조형: 어떤 **값이 저장되어 있는 주소**를 값으로 저장한다.
    * 기본형 8종을 제외한 나머지 타입은 모두 객체가 존재하는 메모리 주소를 저장한다.
```
메모리 주소: 메모리에서, 1byte 단위로 구분되어 각 지점에 할당된 값을 말한다.
```
* 참조형 변수(참조 변수)는 null 또는 객체의 실제 주소 값을 할당받는다.
  * 따라서, 객체 생성에 사용하는 new 지시자의 결과는 생성된 객체의 주소 값이다.
  * 참조형 변수의 크기는 JVM에 따라 다음과 같다.
    * 32bit: 4byte 정수
    * 64bit: 8byte 정수

### 기본형
* char: 문자를 내부적으로 유니코드로 표현된 정수로 저장한다.
  * 때문에 boolean을 제외한 7가지 기본형은 서로 연산 및 변환이 자유롭다.
* 기본형 변수의 타입별 크기는 알아두는 것이 좋다.
  * 1byte: boolean, byte
  * 2byte: char, short
  * 4byte: int, float
  * 8byte: long, double
* 특히, 정수형의 경우 값의 범위도 알아두면 좋다.
``` 
// n은 기본형 변수의 타입별 크기
범위: -2^(n-1) ~ 2^(n-1) -1
```
* 실수형은 정수형과 저장 방식이 달라 더 넓은 범위를 처리할 수 있으나, 오차가 발생할 수 있다는 단점이 있다.
  * 실수형의 오차 범위는 정밀도가 높을수록 적게 발생한다.
  * float보다 double이 정밀도가 높으므로, 다른 이유가 없다면 되도록 double을 사용하자.

### 상수
```
final int MIN_VALUE = 0;
```
* 대문자 snake_case로 작성한다.
* 상수는 값을 저장할 수 있는 공간을 가리킨다는 점에서 변수와 같지만, 값을 변경할 수 없다.
  * 따라서 변수 선언시 초기화 과정이 누락된 경우 에러가 발생한다.
* 상수는 리터럴 값에 의미있는 이름을 붙임으로써 가독성과 유지보수성을 향상시킨다.

### literal
* 그 자체로 값을 의미한다.
  * 수학에서, 1이라는 값은 그 자체를 의미하는 상수이다.
  * 반면 프로그래밍에서의 상수는 '값을 더 이상 변경하지 않는 저장공간'으로 정의한다.
  * 따라서 기존의 상수 개념을 가리키기 위해 리터럴이라는 용어가 사용되곤 한다.
* 리터럴 역시 특정 문자를 통해 타입을 명시할 수 있다.
```
10 // 10진수 int, 10
010 // 8진수 int, 8
0b10 // 2진수 int, 2
0x10 // 16진수 int, 16

1 // int 타입 리터럴, 정수형의 기본 자료형은 int
1l // long 타입 리터럴, l 대신 L도 가능하지만 1과 혼동되므로 L을 권장
3.14 // double 타입 리터럴, 실수형의 기본 자료형은 double
3.14f // float 타입 리터럴, f 대신 F도 가능
3.14d // double 타입 리터럴, d 대신 D도 가능
```
* 상술했듯, 실수형의 기본 자료형은 double이므로 float a = 3.14;는 에러가 발생한다.
  * 이는 접미사가 붙지 않은 3.14는 실수형 리터럴이 맞지만, 실수형 기본 자료형이 double이므로 float에 double을 할당하려는 것으로 인식되기 때문이다.
  * float은 저장 범위가 double보다 작으므로 에러가 발생한다. 역은 에러 없이 수행된다.
```
Main.java:4: error: incompatible types: possible lossy conversion from double to float
        float a = 3.14;
```
* 결국 리터럴 접미사는 long, double, float에만 붙지만, double은 생략 가능하므로 L과 F만 잘 사용하면 된다!
* 수에 소수점, e, f, d, p가 포함된 경우 실수형 리터럴로 취급된다.
  * eN: 10의 N제곱, e3 = 1000
  * pN: 2의 N제곱, p3 = 8 (p는 잘 사용되지 않는다.)
* 리터럴의 타입이 일치하지 않더라도, 저장 범위가 넓은 타입에 좁은 타입의 값을 저장하는 것은 허용된다.
  * 자동 형 변환에 대한 설명인 듯 하다...
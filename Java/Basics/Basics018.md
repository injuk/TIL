# Java
## 2022-01-13 Thu

### 쓰레드
* 프로그램을 실행하면 OS로부터 실행에 필요한 메모리를 할당받아 프로세스가 된다.
* **프로세스는 프로그램 실행에 필요한 데이터와 메모리, 쓰레드로 구성**된다.
  * 모든 프로세스는 최소한 하나 이상의 쓰레드가 존재한다.
  * 이 때, 둘 이상의 쓰레드를 갖는 프로세스를 멀티 쓰레드 프로세스라고 한다.
* 쓰레드는 각각 개별 메모리를 필요로 하므로, 프로세스에 할당된 메모리를 쓰레드들이 나눠 갖게 된다.
  * 쓰레드가 각각의 메모리를 갖는 것은 **쓰레드마다 호출 스택을 가져야 하기 때문**이다.

### 멀티태스킹과 멀티쓰레딩
* 멀티태스킹은 동시에 여러 개의 프로세스가 실행되는 것이다.
* 멀티쓰레딩은 하나의 프로세스 내에서 여러 쓰레드가 동시에 작업을 실행하는 것이다.
  * 실제로는 CPU의 코어는 각각 한 번에 하나의 작업만을 수행한다.
  * 따라서 임의의 시간에 실행되는 작업의 수는 CPU의 코어 수와 같다.
* 코어의 수보다 실행되어야 하는 쓰레드의 수가 많으므로, **코어는 여러 작업을 빠르게 번갈아가며 수행**한다.
  * 작업들을 매우 빠른 시간 동안 번갈아 실행하므로, 사람이 보기엔 동시에 실행되는 것처럼 보인다.
* 싱글 코어 CPU에서는 하나의 코어가 번갈아가며 작업을 실행하므로, 쓰레드 간 작업 시간이 겹치지 않는다.
* **반면 멀티 코어 CPU에서는 동시에 코어의 개수만큼 쓰레드가 실행될 수 있으므로 쓰레드 간 작업 시간이 겹칠 수 있다**.
  * 이 때, 쓰레드들이 공통된 자원을 사용해야 하는 경우라면 경쟁이 발생한다.

### 쓰레드의 구현
* 쓰레드를 구현하는 방법은 두 가지가 있다.
  1. Thread 클래스를 상속받거나,
  2. Runnable 인터페이스를 구현한다.
* Thread 클래스를 상속받는 경우, 다른 클래스를 상속받을 수 없으므로 아쉬운 점이 있다.
* Runnable 인터페이스를 구현하는 것은 재사용성과 코드 일관성 유지 측면에서 장점이 있다.
  * 멀티쓰레드 App. 개발에는 주로 Runnable 인터페이스를 구현하는 방식을 사용한다.

### Runnable
* Runnable은 run 메소드 하나만 정의되어 있는 인터페이스이다.
```
class MyFirstThread implements Runnable {
    @Override
    public void run() {
    }
}
```
* **Runnable 인터페이스의 구현은 추상 메소드인 run의 메소드 바디를 정의하는 것이 전부**이다.
* run의 메소드 바디에는 **쓰레드를 통해 수행하고자 하는 작업 내용을 정의**한다.
* Runnable 인터페이스를 구현한 경우, 이를 인스턴스화한 후 Thread 클래스의 생성자에 매개 변수로서 전달해야 사용이 가능하다.
```
public class ThreadTester {
    public static void main(String[] args) {
        Thread thread1 = new Thread(new MyFirstThread()); // 생성자에 Runnable 전달.
        Thread thread2 = new Thread(new MyFirstThread());
        thread1.start();
        thread2.start();
        for(int i = 0; i < 1000; i++)
            System.out.println(Thread.currentThread().getName());
    }
}

class MyFirstThread implements Runnable {
    @Override
    public void run() {
        for(int i = 0; i < 1000; i++)
            System.out.println(Thread.currentThread().getName());
    }
}
```
* 이러한 방식은 Thread의 static 메소드인 currentThread(), getName() 메소드를 통해 현재 실행 중인 쓰레드에 접근이 가능하다.
  * 쓰레드의 이름은 기본적으로 Thread-[번호] 형식이나, 쓰레드 생성자나 setName 메소드를 통해 재정의가 가능하다.
* **쓰레드를 생성한다고 즉시 실행되지는 않는다**.
* start 메소드를 호출하면 **쓰레드가 실행 대기상태로 진입하고, 자기 차례가 될 때 실행**된다.
  * 실행 **대기 중인 쓰레드가 없다면 즉시 실행 상태**가 된다.
  * 쓰레드의 실행 순서는 OS의 스케쥴러가 정의한 스케쥴에 따른다.
* 한 번 **실행이 종료된 쓰레드는 다시 실행할 수 없다**.
  * 즉, 하나의 쓰레드는 한 번만 start가 호출될 수 있다.
* 쓰레드가 실행하는 작업을 한 번 더 하고 싶다면, 새로운 쓰레드를 생성하고 start를 호출해주어야 한다.

## 2022-01-14 Fri
### start 메소드
* start 메소드를 호출할 경우 **새로운 쓰레드를 생성하고, 이를 위한 호출 스택을 생성한 후에 run 메소드를 호출**한다.
  * 결과 **쓰레드를 위해 생성된 호출 스택에 run 메소드가 가장 먼저** 올라가게 된다.
  * 이후에는 OS의 스케줄러가 결정하는 순서에 따라 생성되어 있는 호출 스택이 번갈아가며 실행된다.
    * 스케줄러는 쓰레드의 우선순위를 고려하여 실행순서와 실행시간을 결정한다.
    * 각 쓰레드는 스케줄러의 스케줄에 따라 자신의 순서에, 정해진 시간만큼만 작업을 수행한다.
    * 시간 내에 작업을 마무리하지 못한 쓰레드는 대기 상태가 되어 자신의 다음 차례를 기다린다.
    * JVM의 쓰레드 스케줄러가 쓰레드의 작업 시간을 결정하듯, 프로세스의 실행 시간 또한 OS의 스케줄러에 의해 결정되므로 일정하지 않을 수 있다.
* 쓰레드를 생성하고 실행할 때마다 새로운 호출 스택이 생성되고, 쓰레드 종료시 사용되었던 호출 스택은 반환된다.
  * 쓰레드 종료는 쓰레드 생성시 함께 만들어져 할당된 호출 스택의 run() 메소드가 종료되는 것으로 스택 내부가 비워지고 호출 스택이 사라진다.
  * 이는 **Java App.의 종료 방식과 유사하다. Java App.은 호출 스택 최 하단에 main 메소드가 대기하며, main 종료시 호출 스택이 사라지며 App.이 종료**된다.
* 멀티쓰레드 방식의 App.은 호출 스택의 최상위 메소드도 대기 상태일 수 있다.
  * 호출 스택의 최 상위에서 메소드가 실행되는 도중 다른 쓰레드로 전환된 경우, 실행되던 메소드는 대기 상태가 된다.
* **한 쓰레드가 예외 발생으로 인해 종료되어도 다른 쓰레드에는 영향을 주지 않는다**.

### main 쓰레드
* main 메소드를 실행하는 것도 호출 스택을 갖는 쓰레드이며, main 쓰레드라고 부른다.
```
public class ThreadTester {
    public static void main(String[] args) {
        System.out.println(Thread.currentThread().getName()); // main이 출력된다.
    }
}
```
* Java App.이 실행되면 main 쓰레드를 생성하고, 해당 쓰레드가 main 메소드를 호출하며 App.이 동작하도록 한다.
* 멀티쓰레드 방식의 App.에서, main 메소드가 종료되었더라도 다른 쓰레드의 작업이 남아 있다면 App.은 종료되지 않는다.
  * 실행 중인 쓰레드가 없을 때 비로소 App.은 종료될 수 있다.

### 싱글쓰레드 vs 멀티쓰레드
* 멀티쓰레드 방식의 App.은 싱글쓰레드 App.과 비교했을 때, 쓰레드간의 context switching에 의해 더 오랜 시간이 소모될 수 있다.
* 각 쓰레드가 공통의 자원을 사용하는 App.이라면 경쟁 상태가 발생할 수 있다.
* 각 **쓰레드가 겹치는 자원을 사용하지 않는 App.이라면, 싱글쓰레드 App.보다 멀티쓰레드 App.이 더 효율적**이다.
  * 예를 들어, 메인쓰레드에서 사용자의 입력을 받는 경우라면 입력이 완료되기까지 다른 작업을 수행할 수 없다.
  * 반면 멀티쓰레드 방식이라면 입력 대기 시간 동안 다른 작업을 수행할 수 있다.

### 쓰레드 우선 순위
* 쓰레드는 priority라는 멤버 변수를 갖고, 우선 순위가 높을 수록 쓰레드가 더 많은 실행시간을 얻게 된다.
* 쓰레드의 작업 중요도에 따라 우선 순위를 달리 적용하여 특정 쓰레드의 작업 시간을 더 많이 할당해줄 수 있다.
  * 일반적으로 시각적인 기능이나 사용자 경험이 중요한 경우, 우선 순위를 다른 쓰레드보다 높게 줄 수 있다.
  * 결과 상대적으로 **더 많은 실행시간이 배정된 쓰레드(우선 순위가 더 높은 쓰레드)의 작업이 다른 쓰레드의 작업보다 우선적으로 종료**된다.
* 우선 순위의 범위는 1 - 10으로, **숫자가 클 수록 우선 순위가 높다**.
* 쓰레드의 우선 순위는 쓰레드를 생성한 쓰레드로부터 상속받는다.
  * 예를 들어, main 쓰레드의 우선 순위는 5이므로 main 쓰레드가 생성한 쓰레드도 이를 상속 받은 5의 우선 순위를 갖는다.
* **start 메소드를 통한 명시적 쓰레드 실행 이전에만 우선 순위를 변경할 수 있다**.
* **멀티코어 CPU의 경우, 쓰레드 우선 순위의 의미가 없다**.
  * 이는 OS의 스케줄러에 따라 결과가 유의미하게 달라질 수도 있다고 한다.
* **쓰레드 우선 순위보다는 작업 자체에 우선 순위를 두는 것을 지향하자**.

### 쓰레드 그룹
* 서로 관련된 쓰레드를 그룹화해서 다루기 위한 개념이다.
* 쓰레드 그룹에 다른 쓰레드 그룹을 포함시킬 수 있다.
* 모든 쓰레드는 반드시 쓰레드 그룹에 포함되어 있어야 한다.
  * 일반적으로 쓰레드 생성자를 통해 쓰레드 그룹을 지정하나, 이를 **생략한 쓰레드는 자신을 생성한 쓰레드와 같은 그룹에 속**하게 된다.
* Java App. 실행시 JVM은 main과 system이라는 쓰레드 그룹을 생성한다.
  1. main: main 메소드를 수행하는 main 쓰레드가 속하는 그룹이다.
  2. system: GC를 수행하는 Finalizer가 속하는 그룹이다.
* **명시적으로 생성된 모든 쓰레드 그룹은 main 쓰레드 그룹의 하위 쓰레드 그룹**이다.

### 데몬 쓰레드
* 데몬 쓰레드가 아닌 다른 쓰레드의 작업을 돕는 보조 역할을 수행하는 쓰레드이다.
* 데몬 쓰레드가 아닌 모든 쓰레드가 종료되면 데몬 쓰레드는 존재 의미가 없으므로 강제적으로 종료된다.
* 일반적으로 GC, 자동 저장 등의 기능에 활용된다.
* 데몬 쓰레드는 start 메소드 호출 전에 setDaemon(true) 메소드를 호출하여 데몬 쓰레드화할 수 있다.
  * 데몬 쓰레드가 생성한 쓰레드는 자동적으로 데몬 쓰레드가 된다.
* Java App. 실행시 JVM은 GC, 이벤트처리, 그래픽처리와 같이 App.에 필수적인 보조 작업을 수행하는 데몬 쓰레드들을 자동으로 생성한다.
  * 이들은 당연히 main 또는 system 쓰레드 그룹에 속한다.

### 쓰레드의 상태
* 쓰레드는 생성 후 큐에 저장되어 자신의 차례를 기다리고, 주어진 실행 시간이 다 된 경우 다시 큐의 마지막으로 돌아가 자신의 차례를 기다린다.
* 이러한 전제 하에 쓰레드는 다음의 상태를 가질 수 있다.
  * NEW: 생성되었지만 start()가 호출되지 않음
  * RUNNABLE: 실행 중이거나, 실행이 가능함
  * BLOCKED: 동기화 블럭에 의해 일시 중지된 상태
  * WAITING: 쓰레드의 작업이 아직 종료되지 않았지만 실행이 가능하지 않은 일시 중지 상태
  * TIMED_WAITING: 정해진 시간 만큼 일시 중지된 상태
    * 위 세 개의 상태는 일시 중지 상태이며, 일시 중지 시간이 다 되거나 interrupt / notify 메소드가 호출되면 다시 큐의 마지막으로 들어간다.
    * interrupt 메소드는 해당 쓰레드를 깨워 다시 큐에 되돌리기 위해 InterruptedException을 발생시킨다.
  * TERMINATED: 쓰레드의 작업이 종료된 상태
  * 위 상태값들은 Thread의 getState()를 통해 확인할 수 있다.
* 일시 중지 상태인 쓰레드를 깨우기 위해 interrupt를 사용한다면, InterruptedException에 대비하여 try - catch를 활용한 예외 처리가 필수적이다.

### sleep 메소드
* 메소드에 지정된 시간만큼 쓰레드를 일시 중지 상태로 만든다.
* **해당 메소드는 항상 현재 실행 중인 쓰레드에 대해 적용**된다.
  * 때문에 Thread t1 = new Thread; t1.sleep(1000); 을 하여도 sleep은 해당 문장을 실행한 main 쓰레드에 적용된다.
  * 이러한 이유로 인해 sleep은 클래스 메소드로 선언되어 있으며, Thread.sleep(1000);과 같이 실행해주어야 한다.
  * yield 메소드 역시 같은 이유에서 클래스 메소드로 선언되어 있다.

### interrupt 메소드
* 진행 중인 쓰레드의 작업을 중도 취소하고 싶은 경우에 사용할 수 있다.
  * 그러나 이는 취소 '요청'이지 '강제 취소'가 아니다. 쓰레드를 강제로 종료시키지는 않는다!
* interrupt 메소드는 해당 쓰레드의 멤버 변수인 interrupted 값을 true로 변경시킨다.
* interrupted 변수의 값은 다음의 메소드를 통해 확인할 수 있다.
  * isInterrupted: 쓰레드의 현재 interrupted 상태를 반환한다.
  * interrupted: 쓰레드의 interruped 상태를 반환하고, 값을 false로 변경한다.
* 쓰레드가 sleep, wait, join 메소드에 의해 WAITING 상태에 있을 경우, interrupt 호출 시 InterruptedException이 발생하고 sleep, wait, join으로부터 벗어나게 된다.
  * 결과 쓰레드의 상태는 WAITING에서 RUNNABLE이 된다
  * **이 때, interrupted의 값은 자동으로 false로 변경**된다.

### join 메소드
* 쓰레드가 하던 작업을 잠시 멈추고, 다른 쓰레드가 지정된 시간 동안 작업을 수행하도록 한다.
  * 자신의 작업에 다른 쓰레드를 참여시키므로 [쓰레드].join()이라는 시멘틱이 적용되었다.
  * 메소드에 시간을 지정하지 않으면 해당 쓰레드의 작업이 종료될 때까지 기다린다.
* join 역시 interrupt에 의해 대기 상태를 더 빠르게 벗어날 수 있다.
  * 이 경우, InterruptedException에 대비하여 join이 호출되는 부분은 try - catch를 통한 예외 처리가 적용되어 있어야 한다.
* join은 sleep이나 yield와 달리 참조 변수가 가리키는 특정 쓰레드에 대해 동작한다.
* join은 특정 쓰레드의 작업이 종료되기 전에 다른 쓰레드의 작업이 먼저 진행되어야할 때 활용해볼 수 있다.

## 2022-01-15 Sat
### 임계 영역, lock, 동기화
* 여러 쓰레드가 같은 프로세스의 자원을 공유하며 작업하므로, 같은 객체에 접근하는 경우 쓰레드 간의 작업에 영향을 줄 수 있다.
  * 때문에 한 쓰레드가 특정한 작업을 끝내기 전까지 다른 쓰레드가 방해하지 못하도록 하는 조치가 필요하다.
  * 임계 영역: 공유 자원에 접근할 수 있는 코드를 임계 영역으로 지정한다.
  * lock: 공유되는 데이터가 갖는 lock을 획득한 쓰레드만이 임계 영역의 코드를 진행할 수 있다.
* 상술한 방식으로 **한 쓰레드가 진행 중인 작업에 다른 쓰레드가 영향을 줄 수 없도록 하는 것이 쓰레드의 동기화**이다.
* Java에서는 synchronized 키워드를 활용한 동기화를 지원한다.

### synchronized 키워드
* synchronized는 아래와 같이 메소드 또는 특정 영역에 대해 지정할 수 있다.
```
public synchronized void hello() {
  // 임계 영역으로 취급
}
또는
synchronized(특정 객체) {
  // 임계 영역으로 취급
}
```
* 메소드에 synchronized 키워드를 붙인 경우, 쓰레드는 해당 메소드를 호출한 시점에 lock을 얻어 진행한다.
  * 또한 메소드가 종료될 때 lock을 반환한다.
  * synchronized 메소드의 **lock을 획득하지 못한 쓰레드가 synchronized 메소드를 호출한 경우, lock을 획득할 때까지 실행 대기** 상태에 머무른다.
* 코드 일부를 synchronized 설정한 경우, 코드 블록이 시작되기 전에 특정한 객체를 명시한다.
  * 쓰레드는 synchronized 블록에 진입하면서 명시된 객체에 대해 lock을 얻고, 블록 종료시 반환한다.
  * 모든 객체는 lock을 하나씩 갖고 있으며, 해당 객체의 lock을 갖는 쓰레드만이 임계 영역의 작업을 진행할 수 있다.
* synchronized는 메소드나 코드 블록 방식 모두 자동으로 lock의 획득과 반환을 처리해준다.
* 임계 영역을 멀티쓰레드 App.의 성능에 큰 영향을 주므로, **가능하면 synchronized 메소드보다 synchronized 블록을 사용하는 것이 바람직**하다.
* synchronized 키워드를 활용한 동기화는 임계 영역의 코드를 **한 번에 하나의 쓰레드만 실행할 수 있도록 보장**만 해준다.
* 때문에 임계 영역의 실행이 오래 걸려 쓰레드가 lock을 반환하지 않고 있는 경우, lock을 대기하는 쓰레드가 많다면 성능에 영향을 준다.

### wait, notify, notifyAll 메소드
* synchronized 방식의 단점에 의해 쓰레드가 임계 영역에서 필요 이상 lock을 점유하지 않도록 할 수 있어야 한다.
* wait, notify, notifyAll 메소드는 이를 위해 고안되었다.
  * **synchronized 블록 내에서만 사용**할 수 있다.
  * 동기화된 임계 영역의 코드를 수행하다 작업을 더 이상 진행하지 못하는 경우에는 우선 lock을 반환하도록 한다.
  * 두 메소드는 Object 클래스에 정의되어 있으므로, 모든 클래스에서 사용할 수 있다.
* wait: 쓰레드가 더 이상 작업을 진행할 수 있는 상황이 아니라면, 일단 lock을 반환하고 객체의 waiting pool에 들어간다.
  * 매개 변수에 대기 시간을 지정한 경우, 일정 시간 이후 notify가 호출된 것 같은 효과가 있다.
* notify: 작업을 다시 진행할 수 있는 상황이 되었다면 notify를 호출하여 다시 쓰레드가 lock을 얻을 수 있도록 한다.
  * 그러나 이 방식은 **오래 대기한 쓰레드가 우선 lock을 얻는다는 보장이 없다**.
* notifyAll: 특정 객체의 waiting pool에서 대기 중인 모든 쓰레드에게 작업을 재개할 수 있다는 사실을 알린다.
  * 그래도 lock을 얻는 것은 대기 중이던 쓰레드 중 하나이므로, 나머지 쓰레드는 다시 waiting pool에서 대기한다.
* **객체의 waiting pool은 객체마다 존재**한다.
  * wait가 호출되면 객체의 waiting pool에 쓰레드가 진입한다.
  * notify가 호출되면 waiting pool의 쓰레드 중 임의의 쓰레드만 알림을 받는다.
  * notifyAll이 호출된다면 waiting pool의 **모든 쓰레드가 알림을 받지만, 그래도 lock을 얻을 수 있는 쓰레드는 하나**이다.
    * lock을 얻은 쓰레드 하나를 제외하고는 다시 waiting pool에서 실행을 대기해야 한다.
* notify를 활용한 방식의 **단점은 특정한 객체의 waiting pool에서 원하는 쓰레드만 알림을 받게 할 수 없다**는 것이다.
  * starvation(기아): 운이 나빠 이러한 단점이 계속된다면 특정 쓰레드는 알림을 계속해서 받지 못할 수도 있다. 
* 기아 상태를 막으려면 waiting pool에서 대기하는 모든 쓰레드가 알림을 받도록 notifyAll을 사용해주는 수 밖에 없다.
  * 기아 상태를 막기 위해 notifyAll을 사용하면, 이번에는 불필요하게 모든 쓰레드가 알림을 받는다는 단점이 있다.
  * race condition(경쟁 상태): notifyAll을 호출하면 객체의 waiting pool에서 대기하던 모든 쓰레드가 lock을 얻기 위해 경쟁하게 된다.
* **race condition을 방지하려면 waiting pool에서 대기하는 쓰레드를 구분해서 알림하는 것이 필요**하다.

### Lock, Condtion
* synchronize 외에 동기화를 위해 사용할 수 있는 방식이며, JDK 1.5에서 추가된 방식이다.
* ReentrantLock: 가장 일반적인 lock이며, 배타적 lock이므로 lock이 있어야만 임계 영역을 수행할 수 있다.
* 자동적으로 lock을 관리하는 synchronize 방식과 달리 lock, unlock 메소드를 활용하여 수동으로 lock을 관리해야만 한다.
```
synchronize void hello() { // 임계 영역 }
// 위와 아래는 유사하다.
lock.lock();
// 임계 영역
lock.unlock();
```
* synchronize 방식은 synchronize 블록에서 예외가 발생할 경우 자동으로 lock을 반환한다.
* 반면 **위 방식은 lock이 임계 영역에서 발생한 예외 또는 return 문에 의해 자동으로 반환되지 않는다**. 
  * 때문에 finally 블록에서 unlock되도록 구현하는 것이 일반적이다.
* lock 메소드는 lock을 획득할 때까지 쓰레드를 블록시킨다.
* 반면 tryLock 메소드를 사용하면 일정 시간 동안 lock을 얻지 못하면 어떻게 할 것인지 개발자가 지정할 수 있다.
  * tryLock은 생성자에 시간을 입력하면 지정된 시간 동안만 lock을 얻으려고 대기한다.
  * tryLock 메소드는 lock을 획득한 경우 true를 반환하고, 획득하지 못한 경우 false를 반환한다.
* Condition은 이미 생성된 Lock으로부터 newCondition 메소드를 호출하여 생성한다.
  * 생성된 Condition은 기존 방식의 waiting pool에서 함께 대기하던 쓰레드를 구분하여 관리할 수 있다.
  * 쓰레드들을 Condition을 통해 분리하고, 기존의 wait / notify 대신 Condition의 메소드인 await / signal을 활용한다.
* 기존에는 wait를 통해 객체에 접근하는 쓰레드를 일괄적으로 대기시켰다면, 이제는 Condition 클래스의 메소드를 활용하여 대기할 쓰레드를 명확히 구분할 수 있다.
* 이러한 방식을 통해 어떤 쓰레드가 알림을 받을지 결정할 수 없는 notify와, 모든 쓰레드가 알림을 받던 notifyAll의 문제를 개선할 수 있다.
  * 즉, 기아와 경쟁 상태의 문제가 상당 부분 개선된다.

### volatile
* 멀티 코어 프로세서의 코어는 성능 향상을 위해 메모리에서 읽어온 값을 우선 캐시에 저장하고, 캐시의 값을 읽어 동작한다.
  * 때문에 같은 값을 읽어올 때는 캐시에서 우선 확인하고, 갱신되지 않은 값을 읽어올 가능성이 있다.
* volatile은 **변수의 값을 읽어올 때 캐시가 아닌 메모리의 값을 직접 읽어오도록 명시하는 키워드**이다.
* 변수에 volatile 키워드를 붙이는 대신 synchronized 블록을 적절히 사용해도 좋다.
  * 이는 쓰레드가 synchronized 블록에 들어갈 때, 나올 때 캐시와 메모리가 동기화되기 때문이다.
* 4 byte 단위로 데이터를 처리하는 JVM은 int 또는 int보다 크기가 작은 데이터를 한 번에 읽고 쓸 수 있다.
* 그러나 4 byte를 넘는 long, double 변수는 하나의 명령어로 값을 읽고 쓸 수 없다.
  * 때문에 값을 읽거나 쓰는 도중에 다른 쓰레드가 끼어들 여지가 있다.
* volatile 키워드는 이러한 데이터의 읽고 쓰는 동작을 원자화하는데 사용할 수도 있다.
  * volatile로 선언된 long, double 변수는 읽고 쓰는 과정에서 다른 쓰레드가 끼어들 수 없다.
* synchronized 블록이 여러 명령줄을 원자화한다면, volatile은 변수의 읽고 쓰기 작업을 원자화한다.
  * 그러나 volatile은 동기화와는 관계가 없다.
  * 따라서 **변수의 읽고 쓰기를 원자화하기 위해 synchronized를 사용할 수는 있지만, 임계 영역의 동기화에 volatile을 사용할 수는 없다**.

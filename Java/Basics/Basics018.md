# Java
## 2022-01-13 Thu

### 쓰레드
* 프로그램을 실행하면 OS로부터 실행에 필요한 메모리를 할당받아 프로세스가 된다.
* **프로세스는 프로그램 실행에 필요한 데이터와 메모리, 쓰레드로 구성**된다.
  * 모든 프로세스는 최소한 하나 이상의 쓰레드가 존재한다.
  * 이 때, 둘 이상의 쓰레드를 갖는 프로세스를 멀티 쓰레드 프로세스라고 한다.
* 쓰레드는 각각 개별 메모리를 필요로 하므로, 프로세스에 할당된 메모리를 쓰레드들이 나눠 갖게 된다.
  * 쓰레드가 각각의 메모리를 갖는 것은 **쓰레드마다 호출 스택을 가져야 하기 때문**이다.

### 멀티태스킹과 멀티쓰레딩
* 멀티태스킹은 동시에 여러 개의 프로세스가 실행되는 것이다.
* 멀티쓰레딩은 하나의 프로세스 내에서 여러 쓰레드가 동시에 작업을 실행하는 것이다.
  * 실제로는 CPU의 코어는 각각 한 번에 하나의 작업만을 수행한다.
  * 따라서 임의의 시간에 실행되는 작업의 수는 CPU의 코어 수와 같다.
* 코어의 수보다 실행되어야 하는 쓰레드의 수가 많으므로, **코어는 여러 작업을 빠르게 번갈아가며 수행**한다.
  * 작업들을 매우 빠른 시간 동안 번갈아 실행하므로, 사람이 보기엔 동시에 실행되는 것처럼 보인다.

### 쓰레드의 구현
* 쓰레드를 구현하는 방법은 두 가지가 있다.
  1. Thread 클래스를 상속받거나,
  2. Runnable 인터페이스를 구현한다.
* Thread 클래스를 상속받는 경우, 다른 클래스를 상속받을 수 없으므로 아쉬운 점이 있다.
* Runnable 인터페이스를 구현하는 것은 재사용성과 코드 일관성 유지 측면에서 장점이 있다.
  * 멀티쓰레드 App. 개발에는 주로 Runnable 인터페이스를 구현하는 방식을 사용한다.

### Runnable
* Runnable은 run 메소드 하나만 정의되어 있는 인터페이스이다.
```
class MyFirstThread implements Runnable {
    @Override
    public void run() {
    }
}
```
* **Runnable 인터페이스의 구현은 추상 메소드인 run의 메소드 바디를 정의하는 것이 전부**이다.
* run의 메소드 바디에는 **쓰레드를 통해 수행하고자 하는 작업 내용을 정의**한다.
* Runnable 인터페이스를 구현한 경우, 이를 인스턴스화한 후 Thread 클래스의 생성자에 매개 변수로서 전달해야 사용이 가능하다.
```
public class ThreadTester {
    public static void main(String[] args) {
        Thread thread = new Thread(new MyFirstThread()); // 생성자에 Runnable 전달.
        thread.start();
    }
}

class MyFirstThread implements Runnable {
    @Override
    public void run() {
        for(int i = 0; i < 1000; i++)
            System.out.println(Thread.currentThread().getName());
    }
}
```
* 이러한 방식은 Thread의 static 메소드인 currentThread(), getName() 메소드를 통해 현재 실행 중인 쓰레드에 접근이 가능하다.
  * 쓰레드의 이름은 기본적으로 Thread-[번호] 형식이나, 쓰레드 생성자나 setName 메소드를 통해 재정의가 가능하다.
* **쓰레드를 생성한다고 즉시 실행되지는 않는다**.
* start 메소드를 호출하면 **쓰레드가 실행 대기상태로 진입하고, 자기 차례가 될 때 실행**된다.
  * 실행 **대기 중인 쓰레드가 없다면 즉시 실행 상태**가 된다.
  * 쓰레드의 실행 순서는 OS의 스케쥴러가 정의한 스케쥴에 따른다.
* 한 번 **실행이 종료된 쓰레드는 다시 실행할 수 없다**.
  * 즉, 하나의 쓰레드는 한 번만 start가 호출될 수 있다.
* 쓰레드가 실행하는 작업을 한 번 더 하고 싶다면, 새로운 쓰레드를 생성하고 start를 호출해주어야 한다.

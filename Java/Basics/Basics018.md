# Java
## 2022-01-13 Thu

### 쓰레드
* 프로그램을 실행하면 OS로부터 실행에 필요한 메모리를 할당받아 프로세스가 된다.
* **프로세스는 프로그램 실행에 필요한 데이터와 메모리, 쓰레드로 구성**된다.
  * 모든 프로세스는 최소한 하나 이상의 쓰레드가 존재한다.
  * 이 때, 둘 이상의 쓰레드를 갖는 프로세스를 멀티 쓰레드 프로세스라고 한다.
* 쓰레드는 각각 개별 메모리를 필요로 하므로, 프로세스에 할당된 메모리를 쓰레드들이 나눠 갖게 된다.
  * 쓰레드가 각각의 메모리를 갖는 것은 **쓰레드마다 호출 스택을 가져야 하기 때문**이다.

### 멀티태스킹과 멀티쓰레딩
* 멀티태스킹은 동시에 여러 개의 프로세스가 실행되는 것이다.
* 멀티쓰레딩은 하나의 프로세스 내에서 여러 쓰레드가 동시에 작업을 실행하는 것이다.
  * 실제로는 CPU의 코어는 각각 한 번에 하나의 작업만을 수행한다.
  * 따라서 임의의 시간에 실행되는 작업의 수는 CPU의 코어 수와 같다.
* 코어의 수보다 실행되어야 하는 쓰레드의 수가 많으므로, **코어는 여러 작업을 빠르게 번갈아가며 수행**한다.
  * 작업들을 매우 빠른 시간 동안 번갈아 실행하므로, 사람이 보기엔 동시에 실행되는 것처럼 보인다.
* 싱글 코어 CPU에서는 하나의 코어가 번갈아가며 작업을 실행하므로, 쓰레드 간 작업 시간이 겹치지 않는다.
* **반면 멀티 코어 CPU에서는 동시에 코어의 개수만큼 쓰레드가 실행될 수 있으므로 쓰레드 간 작업 시간이 겹칠 수 있다**.
  * 이 때, 쓰레드들이 공통된 자원을 사용해야 하는 경우라면 경쟁이 발생한다.

### 쓰레드의 구현
* 쓰레드를 구현하는 방법은 두 가지가 있다.
  1. Thread 클래스를 상속받거나,
  2. Runnable 인터페이스를 구현한다.
* Thread 클래스를 상속받는 경우, 다른 클래스를 상속받을 수 없으므로 아쉬운 점이 있다.
* Runnable 인터페이스를 구현하는 것은 재사용성과 코드 일관성 유지 측면에서 장점이 있다.
  * 멀티쓰레드 App. 개발에는 주로 Runnable 인터페이스를 구현하는 방식을 사용한다.

### Runnable
* Runnable은 run 메소드 하나만 정의되어 있는 인터페이스이다.
```
class MyFirstThread implements Runnable {
    @Override
    public void run() {
    }
}
```
* **Runnable 인터페이스의 구현은 추상 메소드인 run의 메소드 바디를 정의하는 것이 전부**이다.
* run의 메소드 바디에는 **쓰레드를 통해 수행하고자 하는 작업 내용을 정의**한다.
* Runnable 인터페이스를 구현한 경우, 이를 인스턴스화한 후 Thread 클래스의 생성자에 매개 변수로서 전달해야 사용이 가능하다.
```
public class ThreadTester {
    public static void main(String[] args) {
        Thread thread1 = new Thread(new MyFirstThread()); // 생성자에 Runnable 전달.
        Thread thread2 = new Thread(new MyFirstThread());
        thread1.start();
        thread2.start();
        for(int i = 0; i < 1000; i++)
            System.out.println(Thread.currentThread().getName());
    }
}

class MyFirstThread implements Runnable {
    @Override
    public void run() {
        for(int i = 0; i < 1000; i++)
            System.out.println(Thread.currentThread().getName());
    }
}
```
* 이러한 방식은 Thread의 static 메소드인 currentThread(), getName() 메소드를 통해 현재 실행 중인 쓰레드에 접근이 가능하다.
  * 쓰레드의 이름은 기본적으로 Thread-[번호] 형식이나, 쓰레드 생성자나 setName 메소드를 통해 재정의가 가능하다.
* **쓰레드를 생성한다고 즉시 실행되지는 않는다**.
* start 메소드를 호출하면 **쓰레드가 실행 대기상태로 진입하고, 자기 차례가 될 때 실행**된다.
  * 실행 **대기 중인 쓰레드가 없다면 즉시 실행 상태**가 된다.
  * 쓰레드의 실행 순서는 OS의 스케쥴러가 정의한 스케쥴에 따른다.
* 한 번 **실행이 종료된 쓰레드는 다시 실행할 수 없다**.
  * 즉, 하나의 쓰레드는 한 번만 start가 호출될 수 있다.
* 쓰레드가 실행하는 작업을 한 번 더 하고 싶다면, 새로운 쓰레드를 생성하고 start를 호출해주어야 한다.

## 2022-01-14 Fri
### start 메소드
* start 메소드를 호출할 경우 **새로운 쓰레드를 생성하고, 이를 위한 호출 스택을 생성한 후에 run 메소드를 호출**한다.
  * 결과 **쓰레드를 위해 생성된 호출 스택에 run 메소드가 가장 먼저** 올라가게 된다.
  * 이후에는 OS의 스케줄러가 결정하는 순서에 따라 생성되어 있는 호출 스택이 번갈아가며 실행된다.
    * 스케줄러는 쓰레드의 우선순위를 고려하여 실행순서와 실행시간을 결정한다.
    * 각 쓰레드는 스케줄러의 스케줄에 따라 자신의 순서에, 정해진 시간만큼만 작업을 수행한다.
    * 시간 내에 작업을 마무리하지 못한 쓰레드는 대기 상태가 되어 자신의 다음 차례를 기다린다.
    * JVM의 쓰레드 스케줄러가 쓰레드의 작업 시간을 결정하듯, 프로세스의 실행 시간 또한 OS의 스케줄러에 의해 결정되므로 일정하지 않을 수 있다.
* 쓰레드를 생성하고 실행할 때마다 새로운 호출 스택이 생성되고, 쓰레드 종료시 사용되었던 호출 스택은 반환된다.
  * 쓰레드 종료는 쓰레드 생성시 함께 만들어져 할당된 호출 스택의 run() 메소드가 종료되는 것으로 스택 내부가 비워지고 호출 스택이 사라진다.
  * 이는 **Java App.의 종료 방식과 유사하다. Java App.은 호출 스택 최 하단에 main 메소드가 대기하며, main 종료시 호출 스택이 사라지며 App.이 종료**된다.
* 멀티쓰레드 방식의 App.은 호출 스택의 최상위 메소드도 대기 상태일 수 있다.
  * 호출 스택의 최 상위에서 메소드가 실행되는 도중 다른 쓰레드로 전환된 경우, 실행되던 메소드는 대기 상태가 된다.
* **한 쓰레드가 예외 발생으로 인해 종료되어도 다른 쓰레드에는 영향을 주지 않는다**.

### main 쓰레드
* main 메소드를 실행하는 것도 호출 스택을 갖는 쓰레드이며, main 쓰레드라고 부른다.
```
public class ThreadTester {
    public static void main(String[] args) {
        System.out.println(Thread.currentThread().getName()); // main이 출력된다.
    }
}
```
* Java App.이 실행되면 main 쓰레드를 생성하고, 해당 쓰레드가 main 메소드를 호출하며 App.이 동작하도록 한다.
* 멀티쓰레드 방식의 App.에서, main 메소드가 종료되었더라도 다른 쓰레드의 작업이 남아 있다면 App.은 종료되지 않는다.
  * 실행 중인 쓰레드가 없을 때 비로소 App.은 종료될 수 있다.

### 싱글쓰레드 vs 멀티쓰레드
* 멀티쓰레드 방식의 App.은 싱글쓰레드 App.과 비교했을 때, 쓰레드간의 context switching에 의해 더 오랜 시간이 소모될 수 있다.
* 각 쓰레드가 공통의 자원을 사용하는 App.이라면 경쟁 상태가 발생할 수 있다.
* 각 **쓰레드가 겹치는 자원을 사용하지 않는 App.이라면, 싱글쓰레드 App.보다 멀티쓰레드 App.이 더 효율적**이다.
  * 예를 들어, 메인쓰레드에서 사용자의 입력을 받는 경우라면 입력이 완료되기까지 다른 작업을 수행할 수 없다.
  * 반면 멀티쓰레드 방식이라면 입력 대기 시간 동안 다른 작업을 수행할 수 있다.

### 쓰레드 우선 순위
* 쓰레드는 priority라는 멤버 변수를 갖고, 우선 순위가 높을 수록 쓰레드가 더 많은 실행시간을 얻게 된다.
* 쓰레드의 작업 중요도에 따라 우선 순위를 달리 적용하여 특정 쓰레드의 작업 시간을 더 많이 할당해줄 수 있다.
  * 일반적으로 시각적인 기능이나 사용자 경험이 중요한 경우, 우선 순위를 다른 쓰레드보다 높게 줄 수 있다.
  * 결과 상대적으로 **더 많은 실행시간이 배정된 쓰레드(우선 순위가 더 높은 쓰레드)의 작업이 다른 쓰레드의 작업보다 우선적으로 종료**된다.
* 우선 순위의 범위는 1 - 10으로, **숫자가 클 수록 우선 순위가 높다**.
* 쓰레드의 우선 순위는 쓰레드를 생성한 쓰레드로부터 상속받는다.
  * 예를 들어, main 쓰레드의 우선 순위는 5이므로 main 쓰레드가 생성한 쓰레드도 이를 상속 받은 5의 우선 순위를 갖는다.
* **start 메소드를 통한 명시적 쓰레드 실행 이전에만 우선 순위를 변경할 수 있다**.
* **멀티코어 CPU의 경우, 쓰레드 우선 순위의 의미가 없다**.
  * 이는 OS의 스케줄러에 따라 결과가 유의미하게 달라질 수도 있다고 한다.
* **쓰레드 우선 순위보다는 작업 자체에 우선 순위를 두는 것을 지향하자**.

### 쓰레드 그룹
* 서로 관련된 쓰레드를 그룹화해서 다루기 위한 개념이다.
* 쓰레드 그룹에 다른 쓰레드 그룹을 포함시킬 수 있다.
* 모든 쓰레드는 반드시 쓰레드 그룹에 포함되어 있어야 한다.
  * 일반적으로 쓰레드 생성자를 통해 쓰레드 그룹을 지정하나, 이를 **생략한 쓰레드는 자신을 생성한 쓰레드와 같은 그룹에 속**하게 된다.
* Java App. 실행시 JVM은 main과 system이라는 쓰레드 그룹을 생성한다.
  1. main: main 메소드를 수행하는 main 쓰레드가 속하는 그룹이다.
  2. system: GC를 수행하는 Finalizer가 속하는 그룹이다.
* **명시적으로 생성된 모든 쓰레드 그룹은 main 쓰레드 그룹의 하위 쓰레드 그룹**이다.

### 데몬 쓰레드
* 데몬 쓰레드가 아닌 다른 쓰레드의 작업을 돕는 보조 역할을 수행하는 쓰레드이다.
* 데몬 쓰레드가 아닌 모든 쓰레드가 종료되면 데몬 쓰레드는 존재 의미가 없으므로 강제적으로 종료된다.
* 일반적으로 GC, 자동 저장 등의 기능에 활용된다.
* 데몬 쓰레드는 start 메소드 호출 전에 setDaemon(true) 메소드를 호출하여 데몬 쓰레드화할 수 있다.
  * 데몬 쓰레드가 생성한 쓰레드는 자동적으로 데몬 쓰레드가 된다.
* Java App. 실행시 JVM은 GC, 이벤트처리, 그래픽처리와 같이 App.에 필수적인 보조 작업을 수행하는 데몬 쓰레드들을 자동으로 생성한다.
  * 이들은 당연히 main 또는 system 쓰레드 그룹에 속한다.

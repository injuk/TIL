# Java
## 2022-01-04 Tue

### 객체지향의 시작 
* 실제 세계는 객체로 이루어지며, 모든 것은 객체 간의 상호작용을 통해 이루어진다.
  * 객체지향에서는 어떤 개념이나 논리 등, 실체가 없는 것도 객체로 간주한다.
* 객체지향은 실제 객체의 속성과 기능을 분석하여 변수와 메소드에 대응시킨다.
* 객체지향은 코드 간에 서로 관계를 맺어주며, 결과...
  * 코드 재사용성을 높인다.
  * 코드의 유지보수성을 높인다.
  * 코드의 신뢰성을 높인다.
* 객체지향을 적절히 활용할 경우 코드의 재사용성과 유지보수성은 높아진다.

### 클래스, 객체
* 객체를 정의해둔 템플릿의 역할을 하며, 객체의 생성에 관여한다.
* 프로그래밍에서 객체는 메모리에 생성된 실체를 뜻한다.
* 클래스로부터 만들어진 객체를 해당 클래스의 인스턴스라고도 한다.
* 객체는 속성과 기능을 갖는 집합이다. 이렇듯 객체에 포함된 속성과 기능은 '멤버'라고 한다.
* 클래스로부터 인스턴스를 생성하는 과정은 다음과 같다.
```
// 클래스의 인스턴스를 참조할 참조변수의 공간을 생성한다.
TempClass temp;
// 클래스의 인스턴스를 실제로 생성하고, 생성된 인스턴스의 주소를 temp 참조 변수에 저장한다.
temp = new TempClass();
```
* 인스턴스 생성시 멤버 변수의 값을 설정하지 않은 경우, 객체의 멤버 변수는 각 자료형의 기본값으로 초기화된다.
* 생성된 인스턴스를 다루기 위해서는 인스턴스를 참조하는 참조 변수가 반드시 필요하다.
  * 참조 변수가 인스턴스를 참조하는 것을 temp가 TempClass 인스턴스를 '참조하고 있다'라고 표현한다.
  * **인스턴스는 오직 참조 변수를 통해서만 다룰 수 있다는 점을 기억하자.**
    * 이 때, 참조 변수의 타입은 인스턴스의 타입과 같아야 한다.
* 만약 temp2 = temp1과 같이 기존 참조 변수가 가리키던 인스턴스를 버려둔 채 다른 인스턴스를 가리킬 경우, temp2가 원래 참조하고 있던 인스턴스는 더 이상 사용할 수 없게 된다.
  * 인스턴스는 오로지 참조 변수를 통해서만 다룰 수 있기 때문이다.
  * 이렇게 인스턴스 자신을 참조하는 **변수가 더 이상 없는 경우, 인스턴스는 더 이상 사용할 수 없는 쓰레기로 판정되어 JVM에 의해 쓰레기 처리**된다.
  * 쓰레기 처리된 인스턴스는 자동적으로 메모리에서 제거된다.
* 참조 변수는 하나의 주소 값만을 저장할 수 있으므로, 여러 참조 변수가 하나의 인스턴스를 가리키는 것은 가능하다.
* 반면 하나의 참조 변수로 여러 인스턴스를 가리킬 수는 없다.

## 2022-01-05 Wed
### 클래스의 또 다른 정의 - 데이터와 처리 방법의 결합
* 클래스는 데이터와, 이를 처리할 수 있는 함수(메소드)의 결합이다.
  * 이를 통해 클래스 내부의 데이터와 함수가 유기적으로 연결된다.
* 프로그래밍에서 데이터 처리를 위한 데이터 저장 형태는 다음과 같이 발전해왔다.
```
변수 > 배열 > 구조체 > 클래스
```
* 구조체는 여러 데이터를 종류에 관계 없이 하나의 집합으로 저장한다는 점에서 배열과 차이가 있다.
* 클래스 이전에, 함수는 마치 데이터와 관계가 없는것처럼 다루어져왔으나, 사실 함수는 데이터를 처리하기 위해 정의되므로 밀접한 관계가 있을 수 있다.
  * 따라서 객체지향에서는 서로 밀접한 관계가 있는 데이터와 함수를 하나의 클래스에 정의하여 함께 다룰 수 있도록 유도한다.

### 클래스의 또 다른 정의 - 사용자정의 타입
* 대부분의 프로그래밍 언어는 언어 자체적으로 지원되는 자료형 외에 사용자 정의 타입을 추가하는 방안을 제공한다.
* Java와 같은 객체지향에서는 기본형 8종에 더불어 클래스가 곧 사용자정의 타입 역할을 수행한다.

### 변수의 종류
* 참고: **참조 변수의 선언** / 또는 **객체의 생성**과 같이 **클래스의 정보가 필요할 때 클래스는 메모리에 적재(= 로딩)** 된다.
* 변수는 **선언된 위치**에 따라 다음과 같이 나뉜다.
  * 멤버 변수: 클래스 내부에 포함된 변수이며, 클래스 영역에서 선언된 변수이다. 다음의 두 종류로 나뉜다.
    * 클래스 변수: static이 붙은 변수이다.
      * **클래스가 메모리에 적재될 때(= 클래스 로딩 시점) 생성**된다.
      * 클래스 변수는 모든 인스턴스가 공통된 저장 공간을 공유한다. 따라서 인스턴스들이 공통된 값을 유지해야할 때 적절하다.
      * 인스턴스가 생성되지 않더라도 접근이 가능하다.
      * public으로 선언된 클래스 변수는 프로그램 전체에서 접근이 가능한 전역 변수처럼 사용될 수 있다.
    * 인스턴스 변수: static이 붙지 않은, 일반적인 변수이다.
      * **인스턴스가 생성되는 시점에 생성**된다.
      * 인스턴스 변수는 생성된 인스턴스마다 독립된 저장 공간을 갖게 되므로, 인스턴스 각자의 영역에 생성된다.
      * 인스턴스가 생성되지 않은 경우 참조가 불가능하다.
  * 지역 변수: 메소드 내부(메소드 영역)에서 선언된 변수이며, 멤버 변수 이외의 변수이다. 
    * 메소드 내부의 코드 블록이 진행될 때, **변수 선언문이 호출되는 시점에 생성**된다.
    * 메소드 내부에서만 접근이 가능하며, 메소드 종료시 제거되어 사용할 수 없게된다.

### 메소드
* 특정한 작업을 수행하는 코드를 하나의 기능화한 개념이며, 다른 프로그래밍 언어의 함수에 대응된다.
* 메소드는 블랙박스로 사용되는 것이 이상적이다. 메소드를 사용할 때, 어떤 입력에 어떤 출력이 나오는지만 알아도 문제가 없어야 한다.
* 메소드의 선언부는 **반환형**, **메소드 이름**, **매개 변수 정보**로 구성된다.
  * 메소드의 선언부, 즉 **메소드 시그니처는 후에 변경사항이 발생하지 않도록 신중하게 작성**해야 한다!
* 매개변수는 함수의 입력 값을 묘사하며, 메소드 내부에서 선언된 지역 변수이다.
  * 메소드 호출시, 매개변수에 전달할 인자는 자료형이 완전 일치하거나 / 최소한 자동 형변환이 가능한 형태여야 한다.
* 반환형은 메소드의 결과인 출력 값을 묘사한다. 
  * 반환형이 void가 아닌 경우, 메소드 바디에 반드시 return 문이 포함되어야 한다.
  * 반환 값을 메소드 밖의 변수에 저장할 때, 변수와 반환형은 자료형이 완전 일치하거나 / 최소한 자동 형변환이 가능한 형태여야 한다.
* 메소드의 반환형이 void가 아닌 경우에도 **메소드의 반환 값을 반드시 변수에 저장할 필요는 없다**. sum이라는 메소드가 정의되어 있다고 가정할 때, 아래의 경우는 에러를 발생시키지 않는다.
```
int result = sum(1, 2);
sum(3, 4); // 반드시 반환된 값을 저장할 필요는 없다.
```
* 메소드 A의 내부에서 메소드 B를 호출하는 경우, 메소드 B의 호출 시점에 메소드 A의 실행은 멈춘다. 메소드 B를 우선 실행한 후, 실행이 완료되면 메소드 A의 실행이 멈춘 시점부터 동작이 재개된다.
* 메소드 호출시 매개변수에 전달된 값은 반드시 유효한 값인지 체크해야 한다. 메소드를 작성할 때, **안일하게 메소드 호출자를 믿는 방식은 큰 화**를 부를 수 있다!

### 메소드의 return문
* 현재 실행 중인 메소드를 종료하고, 해당 메소드를 호출한 메소드로 돌아간다.
* 메소드는 반환값의 유무에 관계 없이 하나의 return 문을 포함해야 한다.
  * **반환형이 void인 메소드의 경우 return 문을 생략할 수 있지만, 컴파일 시점에 메소드의 마지막에 return;이 자동으로 추가**된다.
  * 반환형이 void가 아닌 경우, return 문이 누락된다면 컴파일 에러가 발생한다.
* 간단한 메소드의 경우, return문에 삼항 연산자를 사용할 수 있다.
```
int compare(int x, int y) {
  return x >= y ? x : y; // 삼항 연산자를 통해 큰 값을 반환한다.
}
```

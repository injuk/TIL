# Java
## 2022-01-09 Sun

### Object 클래스
* 멤버 변수 없이 11개의 메소드를 포함하며, 모든 클래스의 최고 조상이므로 Java의 모든 클래스는 Object의 메소드를 모두 사용할 수 있다.
* [Object].equals([Other Object]): 각 인스턴스의 주소값을 비교하므로, 같은 인스턴스인 경우에만 true가 반환된다.
  * 이는 각 인스턴스에 포함된 값이 아닌, 인스턴스(즉, 두 참조 변수에 저장된 값)의 동일성 여부만을 비교한다.
* 만약 각 인스턴스가 갖는 값을 비교하고 싶다면 equals를 오버라이딩하여 값을 비교하도록 작성해야만 한다.
  * String의 equals 메소드 또한 이렇게 재정의 되어 있다.

### 얕은 복사, 깊은 복사
* 얕은 복사: 복사시 원본과 복제본이 같은 객체를 공유한다. 때문에 복제본의 수정은 원본에도 영향을 미친다.
  * Object의 clone은 얕은 복사이다. 복사하려는 인스턴스가 참조 변수를 갖는 경우 주소값까지 그대로 복사하므로, 원본과 복제본이 같은 인스턴스를 참조하게 된다.
* 깊은 복사: 복사시 원본과 복제본이 다른 객체를 참조한다. 때문에 복제본의 수정은 원본에는 영향을 미치지 않는다.

### Class 인스턴스
* 이름이 Class인, 클래스의 인스턴스이다.
* Class 인스턴스는 클래스의 모든 정보를 담고, 클래스마다 1개만 존재한다.
  * Class에 정의된 멤버의 이름이나 개수 등, 정말 Class의 모든 정보를 포함한다.
* Class 파일이 ClassLoader에 의해 메모리에 적재될 떄 자동으로 생성된다.
  * ClassLoader는 실행 시에 필요한 Class를 동적으로 메모리에 로드한다.
  * 예를 들어, 임의의 Class 접근 시 해당 Class가 이미 메모리에 생성되었는지 확인하고, 없으면 classpath의 경로에 따라 Class 파일을 찾는다.
    * 이 때, Class 파일을 찾지 못했다면 ClassNotFoundException이 발생한다.
    * 찾는데에 성공했다면 해당 Class 파일을 읽어들여 Class 인스턴스로 반환한다.
* 결국 .class 파일을 읽어 Class라는 이름의 클래스의 형식에 맞춰 인스턴스화된 것이 Class 인스턴스이다.
* 그리고, 이렇게 .class 파일을 메모리에 로드하여 객체화하는 작업은 ClassLoader가 수행한다.

### String 클래스
* 다른 프로그래밍 언어에서는 char 배열로 문자열을 다루는 것과 달리, Java에서는 문자열을 위한 String 클래스를 제공한다.
* **String 클래스는 변경 불가능**한 클래스이다.
  * 한 번 인스턴스화된 String 인스턴스가 갖는 문자열은 읽기만 가능하고 변경이 불가능하다.
* 예를 들어, 문자열을 더하는 연산을 수행하는 경우 기존 문자열에 값이 덧붙는 것이 아닌, 두 문자열을 합친 새로운 String 인스턴스가 생성되고 참조가 변경되는 식으로 동작한다.
  * 때문에 무의미한 문자열 더하기 연산은 불필요한 인스턴스를 찍어내므로 지양되어야 한다.
* 만약 문자열을 다루는 작업이 많이 필요하다면 String보다는 StringBuffer 클래스를 사용하는 것이 좋다.
  * StringBuffer 클래스의 문자열은 변경이 가능하다.
* 문자열을 만드는 방식은 두가지가 있다.
  1. 문자열 리터럴을 사용하는 방법
  2. new String("문자열") 생성자를 사용하는 방법
* **문자열 리터럴 방식은 동일한 문자열이 이미 존재한다면, 이를 재사용**한다.
  * 문자열 리터럴은 컴파일 시 클래스 파일에 저장된다.
  * 이 때, 같은 클래스 내의 같은 내용의 문자열 리터럴은 한 번만 저장된다.
    * 문자열 리터럴 역시 String의 인스턴스이고, 생성 후 값의 변경이 불가능하므로 하나의 인스턴스를 공유하면 되기 떄문이다.
* **.class 파일에는 .java에 포함된 모든 리터럴이 있다**. 
  * 이 **.class 파일이 ClassLoader에 의해 메모리에 적재될 때, 모든 리터럴은 JVM의 상수 저장소(Constant pool)에 저장**된다.
  * 이것이 문자열 리터럴이 클래스가 메모리에 적재될 때 자동으로 미리 생성된다는 말이 의미이다.
* **String 생성자를 사용하는 경우, new 연산자에 의해 새로운 인스턴스의 메모리 할당이 발생하므로 항상 새로운 String 인스턴스가 생성**된다.
  * 때문에 String 생성자로 생성된 인스턴스들은 비교 연산자(==)로 비교했을 때 false가 나온다.

### String > 기본형, 기본형 > String
* int를 예로 들어, Integer.valueOf([문자열]) 및 String.valueOf([정수])를 사용한다.
  * Integer.valueOf();는 래퍼 클래스인 Integer를 반환한다.
    * 기본형을 반환받고 싶다면 Integer.parseInt();를 사용하자.
  * 메소드 이름의 일관성 유지를 위해 valueOf가 나중에 추가되었다.
* 문자열을 기본형으로 변경하는 경우, 공백에 의해 예외가 발생할 수 있으므로 trim()을 적절히 활용하는 것이 좋다.
  * 그러나 모든 특수 문자가 금지되는 것은 아니다. 예를 들어, 부호를 의미하는 '+'나 부동 소수점 자료형의 온점(.)을 허용한다.

### StringBuffer
* 지정된 문자열을 변경할 수 없는 String과 달리, SB는 변경이 가능하다.
* 내부적으로 문자열 편집을 위한 char 배열인 버퍼를 갖고 있으며, SB 생성시 생성자를 통해 버퍼의 길이를 지정할 수 있다.
  * 버퍼의 길이가 충분하지 않은 경우, 새로운 char 배열을 생성하고 기존 배열의 내용을 복사하는 작업이 추가로 필요하므로 성능 이슈가 발생할 수 있다.
* SB는 생성자에 아무 것도 작성하지 않은 경우, 버퍼의 크기를 16으로 설정한다.
  * 16은 문자열의 길이이다. 즉, 기본 생성자를 통해 생성된 SB 인스턴스는 16자의 문자를 저장할 수 있는 버퍼를 제공한다.
  * 문자열을 생성자에 전달한 경우, 해당 문자열 길이보다 16이 큰 char 배열을 버퍼로 설정한다.
* SB의 equals 메소드는 오버라이딩 되어 있지 않아, 인스턴스의 주소를 비교하는 비교 연산자(==)와 동일한 결과가 반환된다.
  * 때문에 SB 문자열의 내용을 비교하고 싶다면, SB.toString()을 호출한 후 해당 결과를 토대로 String 클래스의 오버라이딩된 메소드인 equals를 활용해야 한다.
  * 이는 SB의 toString은 오버라이딩되어 문자열을 반환하도록 작성되었기 때문이다.
* SB는 쓰레드 동기화에 대한 성능 이슈가 있다.
  * 이로 인해 쓰레드 동기화 기능을 뺀 StringBuilder 클래스가 새로 추가되었다고 함. 기능은 SB와 똑같다.
  * 그러나 SB 자체도 충분히 성능 최적화가 되어 있으므로, 멀티 쓰레드 작업이 필요한 경우가 아니라면 StringBuffer를 사용해도 무방하다.

### Wrapper class
* Java는 성능 향상을 위해 8가지 기본형을 제공한다.
* 이러한 기본형 변수(원시 타입)을 여러 이유에서 객체로 다루고자 하는 경우, 각 기본형을 객체로 변환할 필요가 있다.
* 8가지 기본형에 대응되는 8가지의 클래스가 Wrapper 클래스이다. char와 int를 제외한 모든 기본형은 머릿 글자만 대문자로 바꾼 래퍼 클래스가 존재한다.
  * char는 Character, int는 Interger를 래퍼 클래스로 사용한다.
* 각 래퍼 클래스는 자신과 대응되는 기본형 변수를 멤버 변수로 갖고, 적절한 생성자를 통해 생성할 수 있다.
* 래퍼 클래스 생성자는 자신과 대응되는 기본형 변수 또는 적절한 형태의 문자열을 인자로 전달 받을 수 있다.
* 래퍼 클래스들은 모두 equals 메소드가 오버라이딩되어 있으므로, 인스턴스의 주소값이 아닌 객체의 값을 비교한다.
  * 그러나 비교연산자(==)는 사용할 수 없다. 이는 주소값을 비교하므로 false를 반환한다!

### 오토박싱, 언박싱
* JDK 1.5 전에는 기본형과 래퍼 클래스 간의 연산이 불가능했다.
* 그러나 오토박싱과 언박싱이 지원되는 현재는 컴파일 시점에 변환 코드가 자동으로 추가되므로 기본형과 래퍼 클래스 간의 연산이 가능하다.
* 이때, 기본형이 래퍼 클래스의 객체로 변경되는 것을 오토박싱 / 반대의 경우를 언박싱이라고 한다.

### java.util.Objects
* Object를 보조하는 클래스이며, Math 클래스처럼 모든 메소드가 static으로 정의된다.
  * 따라서 모든 메소드를 Objects.[메소드명] 형태로 호출한다.
* Objects.equals의 경우 [참조변수].equals와 달리 Null 체크가 필요 없다.
  * Object 클래스의 equals는 [참조변수]가 null이 아니어야 하므로, 항상 [참조변수] != null을 별도로 체크해야 한다.
  * 반면 Objects.equals의 경우 null을 체크할 필요가 없다. 
    * 매개 변수가 모두 null인 경우에는 true를 반환한다.(확인 필요!)
* requireNonNull: 해당 인스턴스가 null이 아니어야 하는 경우에 사용한다. null인 경우 NullPointerException을 발생시킨다.
  * 첫 인자로 인스턴스를 받고, 두번째 인자로 NullPointerException에서 사용할 예외 메시지를 받는다.
* isNull, nonNull: 인스턴스의 null 체크에 사용하며, 반환값이 서로 반대이다.
* toString: 내부적으로 null 체크를 한다는 점 외에 [참조변수].toString()과 다르지 않다.
  * Objects.toString([참조변수], String)은 [참조변수]가 null인 경우에 사용할 기본값 역할을 두번째 매개변수로 전달할 수 있다.

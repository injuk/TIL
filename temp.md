## Kotlin Deep-Dive
### 제네릭 클래스와 타입 파라미터
* 고전적인 상속을 활용할 경우, 부모 - 자식 관계와 리스코프 치환 원칙을 활용하여 유연하게 사용될 수 있는 클래스를 설계할 수 있다.
  * 그러나 **이러한 방식은 무분별한 타입 캐스팅 등을 통해 런타임 시점에 에러를 발생시킬 가능성을 갖는다**.
  * 이러한 타입 캐스팅의 경우, `as?`와 같은 안전한 타입 캐스팅 연산자와 엘비스 연산자를 조합하여 안정성을 높일 수 있으나 이 역시 명확한 한계를 갖는다.
* **예외로부터 자유롭기 위해 클래스에 제네릭을 적용할 수 있으며, 이 경우 클래스에는 임의의 타입을 의미하는 타입 파라미터를 명시**하게 된다. 
  * 이 경우, 제네릭 클래스는 `class Something<T>{}`와 같이 대문자로 표현된 타입 파라미터를 갖게 된다.
* 이렇듯 제네릭을 사용할 경우, 불필요한 타입 캐스팅을 명시하지 않아도 되며 많은 예외 상황을 컴파일 시점에 검증할 수 있게 된다.

### 변성이란?
```
> 변성은 어떠한 관계도 없는 두 제네릭 클래스 간에 어떠한 관계를 맺어주는 것을 의미한다.
```
* 코틀린의 경우, 기본적으로 임의의 클래스 간에 정의된 상속 관게는 제네릭 클래스에 적용되지 않는 무공변 상태를 갖는다. 
* 그러나 **제네릭 클래스에 대해, 타입 인자로 전달된 클래스들의 상속 관계를 제네릭 클래스에도 적용하는 식으로 관계를 주고 싶을 수 있다**.
  * 예를 들어, `MyGeneric<String>`과 `MyGeneric<Any>` 간에 어떠한 관계를 주고 싶을 수 있다.
* **변성이란 이러한 경우에 사용되며, 타입 인자로 전달된 클래스 간의 상속 관계를 유지하는 공변과 이를 뒤집는 반공변으로 구분**해볼 수 있다.

### 공변이란?
* **공변은 변성의 일종으로, 타입 인자로 전달된 임의의 클래스 간의 상속 관계를 제네릭 클래스에서도 유지**한다.
  * 즉, 공변적인 `MyGeneric<out T>`의 경우 `MyGeneric<String>`은 `MyGeneric<Any>`의 자식처럼 취급될 수 있다.
  * 또한, 이렇듯 코틀린은 `out`이나 `in`과 같은 `variance annotation`을 활용하여 제네릭 클래스의 변성을 명시하게 된다.
* **코틀린의 공변 지시자인 `out`이 주는 또 다른 효과로, 공변적인 제네릭 클래스는 오직 데이터를 조회할 수 있는 생산자의 역할을 담당**하게 된다.
  * 이는 **공변적인 제네릭 클래스가 데이터를 소비할 수 있는 경우에 타입 안정성이 깨져 런타임 예외의 발생 가능성이 내재되기 때문**이다.
  * 바꿔 말해, 비즈니스 로직 상 임의의 제네릭 클래스가 항상 생산자의 역할만 수행하는 것이 보장되는 경우 해당 클래스를 공변적으로 정의해도 무방하다.

### 반공변이란?
* 타입 인자로 전달된 임의의 두 클래스 간의 상속 관계를 제네릭 클래스에서도 유지하는 공변과 달리, 반공변은 상속 관계를 뒤집는 특성을 갖는다.
  * 즉, 반공변적인 `MyGeneric<in T>`의 경우 `MyGeneric<String>`은 `MyGeneric<Any>`의 부모처럼 취급될 수 있다.
* 나아가 **공변적인 제네릭 클래스가 항상 생산자의 역할만 수행할 수 있는 것과 반대로, 반공변적인 제네릭 클래스는 항상 소비자의 역할만을 수행**할 수 있다.
  * 이 역시도 반공변적인 클래스가 생산자의 역할을 수행했을 때 타입 안정성을 깨트릴 가능성이 내포되기 때문이다.

## DDD Start!
### 도메인이란?
```
> 예를 들어 온라인 서점을 예로 들었을 때, 이는 개발자의 관점에서 구현해야할 소프트웨어의 대상이 된다.
> 이 경우, 온라인 서점 자체가 소프트웨어로 해결하고자 하는 문제의 영역인 도메인이 된다.
```
* **도메인은 소프트웨어로 해결하고자 하는 문제의 영역을 지칭하며, 각 도메인은 다시 여러 개의 하위 도메인으로 나뉘어질 수 있다**.
* 반면, **각 도메인을 분류하는 명확한 기준은 없으며 하위 도메인의 구성 여부는 상황에 따라** 달라질 수 있다.
* 실세계에는 각각의 도메인에 대응되는 도메인 전문가가 있으며, 개발자는 이들의 요구 사항을 분석하고 소프트웨어를 설계하게 된다.
  * 소통 과정에서 정보는 손실되기 마련이므로, 개발자는 도메인 전문가와 직접 소통할수록 양질의 제품을 만들어낼 가능성이 높아진다.
  * 이 때, 이러한 **소통은 도메인 전문가로부터 시작되는 단방향이 아니며 개발자는 요구 사항을 분석하여 그들이 정말로 원하는 것을 찾아낼 책임**이 있다.
* 각 **도메인 계층은 도메인의 핵심 규칙을 코드로써 구현하며, 각 도메인은 연관된 주요한 업무 규칙을 도메인 모델 내에서 구현**해야 한다.
  * 이를 통해 핵심 규칙 코드는 도메인 모델에만 위치하며, 규칙이 변경될 때 다른 코드에 영향을 최소화하면서 기능을 수정할 수 있게 된다. 

### 도메인 모델이란?
```
> 도메인 모델이란, 임의의 도메인을 개념적으로 표현한 것을 의미한다.
```
* 도메인 모델은 임의의 도메인 자체를 이해하기 위한 개념적인 모델로 클래스 다이어그램이나 상태 다이어그램, 나아가 어떠한 형태로든 작성이 가능하다.
* 상술한 바와 같이 각 도메인은 여러 하위 도메인으로 분류될 수 있으므로, 도메인 별로 동일한 용어가 완전히 다른 의미를 가질 수 있다.
  * 이로 인해 여러 하위 도메인을 하나의 다이어그램에 모델링하는 것은 지양하는 것이 바람직하며, 각 하위 도메인은 별도의 도메인 모델을 가져야 한다.

### 개념 모델 정의하기
* 개념 모델은 해결하고자 하는 문제를 분석한 결과물로, 트랜잭션 관리나 DB 등의 물리적인 기술을 고려하지 않는다.
  * 때문에 개념 모델을 소프트웨어에 그대로 적용할 수는 없으며, 개념 모델은 구현 가능한 형태의 구현 모델로 전환하는 과정을 거치게 된다.
* **개념 모델을 정의하는 과정에서 완벽한 도메인 모델을 목표로할 수 있으나, 이는 실제로는 불가능**하다.
  * 소프트웨어 개발 주기 동안 관계자들은 해당 도메인을 더욱 이해하게 되며, 프로젝트 초기의 지식이 시간에 따라 다른 의미로 해석될 수도 있다.
  * 즉, **도메인 모델에 대한 지식이 쌓일수록 기존 모델을 보완하고 변경하는 것은 자연스러운 일이므로 처음부터 완벽한 개념 모델을 정의할 필요는 없다**.

### 도메인 모델 정의하기
```
> 아무리 뛰어난 개발자라도 도메인에 대한 이해 없이는 코드를 작성할 수 없다!
```
* **도메인을 모델링할 때 기본이 되는 작업은 도메인 모델을 구성하는 핵심적인 요소와 규칙, 기능을 찾아내는 것**이다.
  * 이는 주로 요구 사항에서 출발하므로, 도메인 모델링에 앞서 해당 도메인에 대한 요구 사항을 정리할 필요가 있다.

### 엔티티란?
```
> 엔티티와 밸류의 차이를 제대로 이해하는 것은 도메인을 올바르게 설계하고 구현하기 위해 필수적이다.
```
* **엔티티는 식별자를 가지며, 동일한 식별자를 갖는 엔티티는 같은 것으로 취급**할 수 있다.
  * 즉, 엔티티를 구현하는 클래스는 식별자를 활용하여 `equals()`와 `hashCode()` 메소드를 구현할 수 있다.

### 밸류 타입이란?
* **밸류 타입은 개념적으로 완전한 하나의 도메인 개념을 표현하기 위해 사용하며, 단순한 원시 타입에도 도메인적인 개념을 부여하기 위해 사용**될 수 있다.
* 일반적으로, **밸류 객체의 데이터를 변경하는 경우 기존 데이터를 변경하는 대신 새로운 밸류 객체를 생성하는 방식을 사용**한다.
  * 이렇듯 **데이터에 대한 변경 기능을 제공하지 않는 밸류 타입은 기본적으로 불변**하다.
* 식별자를 비교하는 엔티티와 달리, 두 밸류 객체를 비교하는 경우 각 밸류 타입이 갖는 모든 프로퍼티를 비교하는 방식을 취하게 된다.

### 코드에 도메인 규칙을 드러내기
* 예를 들어 임의의 도메인에 대한 상태가 `SUBMITTED`, `IN_PROGRESS` 및 `COMPLETED`의 세 개가 존재한다고 가정하자.
* 이를 단순히 '셋'에 집중하여 `STATUS1`, `STATUS2`와 같은 식으로 정의할 경우 코드 상에서는 도메인 규칙이 전혀 드러나지 않게 된다.
  * 대신 단순한 문자열에 대한 검증만을 나타내는 것처럼 보이게 된다.
* **되도록이면 코드 상에서 도메인 규칙을 잘 드러내도록 구현하는 것이 바람직하며, 이러한 습관은 코드의 가독성과 유지보수성을 큭게 향상시킬 수 있도록 한다**.
  * 이를 위해 개발자와 도메인 전문가 및 업무 유관련자 모두 동일한 의미를 갖는 언어 집합을 사용하는 유비쿼터스 언어를 지향할 수 있다.
* 이렇듯 도메인에 맞는 단어를 찾는 것은 굉장히 중요하며, 이를 코드 뿐만 아니라 도메인 모델과 문서 등에도 적용하는 것으로 업무 상의 모호함을 제거할 수 있다. 

### 아키텍쳐의 영역 구분
```
> 표현과 응용, 도메인과 인프라스트럭쳐는 아키텍쳐 설계에 적용되는 전형적인 네 유형의 영역이다.
```
* 표현 영역은 사용자의 요청을 받아 응용 영역에 전달하고, 결과를 받아 사용자에게 표현하는 역할을 담당한다.
* 응용 영역은 시스템이 사용자에게 제공할 기능을 구현한다.
  * 다만, 이 과정에서 기능을 위해 도메인 영역을 활용하며 도메인 로직을 작성하지는 않는다.
  * 즉, **응용 영역의 서비스는 로직을 직접 처리하기보다는 도메인 모델에 위임**한다.
* **도메인 영역은 도메인 모델을 구현하며, 실제 문제를 해결하기 위한 도메인의 핵심 로직을 처리**한다.
* 인프라스트럭쳐 영역은 관계형 DB나 메일 발송 등의 실제 구현 기술에 대한 처리를 담당한다.
* 일반적인 아키텍쳐는 표현 영역과 응용 영역이 도메인 영역을 사용하고, 도메인 영역이 인프라스트럭쳐 영역을 사용한다.
  * 이 과정에서 표현 영역이 최상위 계층으로 표현될 수 있으며, 상위 계층은 하위 계층에 단방향으로 의존한다.

### 의존성 종속 문제
```
> 특정 영역이 다른 영역에 의존한다는 것은 즉 해당 영역에 종속되는 것과 같다.
```
* 상술한 논리에 의해 도메인 영역은 상세한 기술인 인프라스트럭쳐 영역에 의존하며, 이로 인해 비즈니스 규칙이 특정 기술에 종속되는 현상이 발생한다.
* 이 경우, 소프트웨어는 테스트와 변경 가능성이 크게 떨어져 장기적인 유지보수성이 떨어지는 부작용을 낳는다.

### DIP를 활용한 의존성 종속의 해결
* 이를 해결하기 위해서는 인프라스트럭쳐 영역의 기능을 인터페이스로 추출하는 방법을 도입할 수 있다.
  * 이 경우, 저수준의 세부 기술과 관련된 기능은 추상화된 인터페이스로서 고수준 모듈에 편입될 수 있다.
  * 이제 인프라스트럭쳐 영역에서는 해당 인터페이스를 구현하는 구체 클래스를 정의하게 된다.
  * 즉, 더 이상 고수준의 영역이 저수준 영역에 의존하지 않으며 이는 DIP를 적용했기 때문이다.
* 그러나 **DIP는 단순히 인터페이스를 추출하는 개념이 아니며, 하위 기능은 반드시 고수준 모듈의 관점에서 추출**되어야 한다.
  * 즉, 하위 기능을 추상화하는 인터페이스는 저수준 모듈이 아닌 고수준 모듈에 위치해야 한다.
* 또한, 이러한 방식은 응용 계층과 인프라스트럭쳐 영역에도 적용할 수 있으며 이 경우에도 추상화된 인터페이스는 응용 계층의 관점에서 추출되어 포함되어야 한다.
* 반면, **DIP는 반드시 적용해야되는 제 1 규칙은 아니며 필요에 따라서는 구현 기술에 의존하는 코드를 도메인에 포함하는 것이 효과적인 경우도** 있다.
  * 즉, **무조건적으로 DIP를 적용하기보다는 DIP의 이점을 고려하는 것이 바람직**하다.

### 도메인 영역을 구성하는 요소들
* 도메인 영역에서는 도메인의 핵심 모델을 구현하므로, 각 도메인의 개념을 표현하기 위한 핵심 로직을 구현한다.
* 이 때, 도메인 영역은 크게 다음과 같은 요소로 구현된다.
  1. 엔티티: 식별자를 갖는 객체이며, 자신만의 수명주기를 갖는다. 도메인 모델의 데이터를 포함하며 이와 관련된 기능을 제공한다.
  2. 밸류: 식별자를 갖지 않는 객체이며, 개념적으로 하나인 값을 표현하기 위해 사용된다.
  3. 애그리거트: 서로 관련이 있는 엔티티와 밸류를 개념적으로 하나로 묶는 단위를 의미한다.
  4. 리포지토리: 도메인 모델의 영속성을 처리한다.
  5. 도메인 서비스: 임의의 엔티티에 속하지 않는 도메인 로직을 제공하며, 이러한 도메인 로직은 일반적으로 여러 엔티티와 밸류를 필요로 한다.

### 도메인 모델로서의 엔티티와 DB 엔티티
```
> 두 엔티티는 같은 용어로 인해 같은 개념으로 혼동되기 쉬우나, 두 개념은 같지 않다.
```
* **도메인 모델의 엔티티는 데이터와 도메인의 기능을 함께 제공**하지만, DB 엔티티는 데이터만을 제공한다.
  * 즉, 도메인 모델의 엔티티는 단순한 데이터 구조에서 벗어나 도메인의 기능 구현을 함께 캡슐화한 단위이다.
* 또한, 도메인 모델의 엔티티는 둘 이상의 데이터가 개념적으로 하나의 의미를 갖는 경우 이를 밸류 타입으로 표현할 수 있다.

### 애그리거트란?
* 도메인과 도메인 모델은 함께 커지는 경향이 있으므로, 성장 과정에서 수많은 엔티티와 밸류가 출현하여 모델의 복잡성이 높아진다.
  * **이러한 현상이 심화될 경우, 개발자는 도메인 전체가 아닌 개별 엔티티와 밸류에만 초점**을 맞추게 된다.
* **애그리거트는 관련된 객체를 하나로 모으는 캡슐화된 단위**로서 개발자가 도메인 모델 전체를 이해하는데 큰 도움을 준다.
  * 이를 통해 개별 객체가 아닌, 애그리거트 단위로 도메인 모델을 이해하고 구현할 수 있다.
* **애그리거트는 자신에게 포함된 객체들을 관리하는 루트 엔티티를 포함**한다.
  * 이 때, 루트 엔티티는 함께 포함된 다른 엔티티와 밸류 객체들을 활용하여 애그리거트가 구현해야 할 기능을 제공한다.
  * 때문에 **해당 애그리거트를 활용하는 코드는 루트 엔티티가 제공하는 기능을 실행하고, 이를 통해 간접적으로 해당 애그리거트의 다른 객체들과 상호작용**한다.

### 리포지토리란?
```
> 엔티티와 밸류 타입이 요구사항으로부터 도출되는 도메인 모델이라면, 리포지토리는 구현을 위한 도메인 모델이다.
```
* **리포지토리는 애그리거트 단위로 도메인 객체를 저장하고 조회하는 기능을 정의**한다.
* 도메인 모델을 사용하는 코드는 우선 리포지토리를 활용하여 도메인 객체를 조회하고, 필요한 기능을 실행하게 된다.

### 인프라스트럭쳐에 의도적으로 의존하기
```
> 구현의 편리함은 DIP가 주는 유연성과 유지보수성만큼이나 중요한 가치에 해당한다.
```
* DIP의 장점을 헤치지 않는 범위에서는 인프라스트럭쳐 영역의 구현 기술에 대해 의존해도 무방하다.
* DIP에 집착하여 세부적인 구현 기술에 전혀 의존하지 않는 코드를 작성할 경우, 복잡한 설정으로 인해 개발 시간만 과도하게 늘어날 수 있다.

### 애그리거트란? II
* 애그리거트는 복잡한 도메인 모델을 이해하는 데에 도움을 줄 뿐만 아니라, 일관성을 관리하는 기준으로서도 기능할 수 있다.
  * **애그리거트는 복잡한 도메인을 단순한 구조로 바꾸고, 복잡도가 낮아진만큼 유지보수성을 크게 높여**줄 수 있다.
* **애그리거트는 연관된 모델을 하나로 모은 집합이므로, 하나의 애그리거트에 포함된 객체는 유사하거나 동일한 수명 주기를 갖는다**.
* **애그리거트는 일종의 경계를 갖고, 하나의 애그리거트에 속한 객체는 다른 애그리거트에 속하지 않는다**.
  * 나아가 각각의 애그리거트는 자기 자신만을 관리할 뿐, 다른 애그리거트를 관리하지는 않는다.
  * 이러한 경계를 설정할 때의 일반적인 기준은 도메인 규칙과 요구사항으로, 동일한 규칙에 따라 함께 생성되는 구성 요소는 같은 애그리거트에 속할 가능성이 높다.
* 쉽게 범하는 실수 중 하나는 A가 B를 가질 때 둘을 동일한 애그리거트로 취급하는 것으로, 이러한 요구사항은 동일한 애그리거트를 보장할 수는 없다.
  * 예를 들어 상품은 리뷰를 갖지만, 두 엔티티는 함께 생성되지도 않고 함께 변경되지도 않는다.
* **도메인 규칙을 잘 이해할수록 애그리거트의 크기는 줄어들며, 대부분의 경우 하나의 애그리거트는 단일 엔티티 객체만으로도 충분히 구성 가능**하다.
* 일반적으로 **하나의 트랜잭션에서는 하나의 애그리거트만을 수정해야 하며, 둘 이상의 애그리거트를 수정한다는 것은 곧 애그리거트 간의 결합을 의미**할 수 있다.
  * 즉, 임의의 애그리거트가 기능을 처리하는 과정에서 다른 애그리거트의 상태를 변경할 가능성이 있으므로 이러한 방식은 지양해야 한다.
  * 이렇듯 **하나의 트랜잭션에서 둘 이상의 애그리거트를 수정할 필요가 있는 경우, 응용 계층의 서비스에서 이러한 로직을 처리하는 것이 바람직**하다.

### 애그리거트 루트란?
```
> 애그리거트 루트의 핵심적인 역할은 애그리거트의 일관성이 깨지지 않도록 보장하는 데에 있다.
```
* **애그리거트의 모든 객체에 대해 일관된 상태를 보장하기 위해서는 애그리거트 전체를 관리할 주체가 필요하며, 이러한 책임은 애그리거트 루트 엔티티**에 있다.
  * 애그리거트 루트는 애그리거트의 대표 엔티티이며, 애그리거트에 속하는 모든 객체는 애그리거트 루트 엔티티에 직접적 또는 간접적으로 속한다.
* **애그리거트 루트는 일관성을 보장하기 위해 해당 애그리거트가 제공할 도메인 기능을 구현**해야 한다.
  * 예를 들어 **임의의 애그리거트가 제공해야하는 기능이 있을 경우, 애그리거트 루트는 이러한 기능을 구현하는 메소드를 제공**한다.
  * 또한, 애그리거트의 일관성을 지키기 위해서는 밸류 타입을 불변으로 하고 불필요한 세터를 정의하지 않는 것이 권장된다.

### 리포지토리와 애그리거트
```
> 하나의 트랜잭션에서는 하나의 애그리거트만 변경되는 것이 이상적이다.
```
* 애그리거트는 개념적으로 완전한 하나의 도메인 모델을 표현하므로, 객체의 영속성을 처리하는 리포지토리는 애그리거트 단위로 존재한다.
  * 즉, 새로운 애그리거트가 정의될 경우 이를 영속화하기 위한 기능과 조회하기 위한 기능은 필수적이다.
* **애그리거트는 개념적으로 연관된 데이터의 집합이므로, 리포지토리는 애그리거트 전체를 하나의 단위로 삼아 동작**해야 한다.
  * 예를 들어, 애그리거트와 연관된 테이블이 셋이라면 이를 저장할 때 모든 테이블에 대해 데이터를 저장해야 한다.
  * 같은 이유에서 애그리거트를 조회하는 메소드는 완전한 애그리거트를 제공할 수 있어야 한다.

### 애그리거트 간의 참조
```
> 객체지향 프로그래밍 언어에서, 하나의 객체가 다른 객체를 참조하듯 애그리거트도 다른 애그리거트를 참조할 수 있다.
```
* **애그리거트의 관리 주체는 애그리거트 루트이므로, 애그리거트가 다른 애그리거트를 참조하는 경우에는 해당 애그리거트의 루트를 참조**하게 된다.
* **애그리거트 간의 참조는 필드를 활용하여 쉽게 구현할 수 있으나, 이러한 방식은 안정성을 떨어트리고 확장을 어렵게 만들기 쉽다**.
  * 예를 들어, 필드 참조 방식은 JPA 만으로도 쉽게 구현할 수 있으나 이는 연관된 모든 애그리거트가 JPA를 사용할 것을 전제하므로 확장성이 떨어진다.
* 때문에 **애그리거트 간의 참조는 대상 애그리거트의 식별자를 활용하는 방식이 유용하며, 이는 애그리거트 간의 물리적인 연결을 제거하는 간접 참조에 해당**한다.
  * 이러한 방식은 모든 조회 로직을 응용 계층에 위임하므로 **애그리거트가 다른 애그리거트를 직접 참조하지 않아 상태 변경이 불가능**하다.
* 반면, 애그리거트 간의 식별자 참조는 객체 A가 객체 B를 참조하는 상황에서 목록 조회시 N+1 조회 문제를 유발시킬 수 있다.
  * 예를 들어, 객체 A의 목록을 조회할 때 응용 계층에서는 객체 A마다 참조된 객체 B를 조회하게 된다.
  * 이러한 **문제를 해결하기 위해서는 데이터 조회를 위한 전용 DAO를 정의하고, 적절한 메소드를 정의하여 조인 쿼리를 활용하도록 유도**할 수 있다.

### 팩토리로서의 애그리거트
```
> 어떤 애그리거트가 갖는 상태 등의 데이터를 기반으로 다른 애그리거트를 생성하는 경우, 해당 애그리거트에 팩토리 메소드를 정의해볼 수 있다.
```
* 임의의 애그리거트 A가 애그리거트 B의 상태에 의존적으로 관리될 수 있는 경우, 이러한 로직을 응용 서비스에서 처리하는 실수를 범하기 쉽다.
  * 그러나 이는 **중요한 도메인 규칙이 응용 서비스에 노출되는 것으로, 생성과 관련된 논리적인 하나의 기능을 응용 계층에서 구현**하게 된다. 
* 대신 애그리거트 B에 애그리거트 A를 생성하는 팩토리 역할을 할당할 수 있으며, 이 경우 애그리거트 B는 자신의 상태를 기반으로 A 객체를 생성할 수 있다.
  * 결과적으로 응용 계층은 애그리거트 B를 조회한 후, 애그리거트 A에 대한 객체 생성을 위임한 후 자신은 애그리거트 A의 영속화에만 신경쓸 수 있게 된다.
  * 이러한 방식은 중요한 도메인 로직을 애그리거트 안에 할당하며, 규칙의 변경이 발생하더라도 응용 서비스에는 이러한 변경 사항을 전파하지 않는 장점이 있다.
* 반면, **애그리거트 B가 애그리거트 A를 생성하는 로직이 지나치게 복잡해지는 경우 이러한 생성 책임을 별도의 팩토리 클래스에 위임**할 수도 있다.
  * 이 경우 애그리거트 B는 애그리거트 A에 대한 생성 메소드를 제공하지만 내부적으로는 생성 책임을 팩토리 클래스에 위임한다.
  * 이를 통해 **단일 책임 원칙을 준수할 수 있으면서도 애그리거트 B의 상태에 의존한다는 도메인 규칙은 여전히 한 곳에 위치**하게 된다.

### 표현 영역의 책임
```
> 일반적인 애플리케이션의 경우, 사용자로부터 시작된 요청이 표현 영역과 응용 영역을 거쳐 도메인 영역으로 전달되는 흐름을 갖는다.
```
* **표현 영역은 HTTP 등의 방식을 활용하여 사용자의 요청을 해석하고, 요청에 맞는 기능을 처리하는 응용 서비스를 호출**한다.
* 사용자로부터 표현 영역에 전달된 데이터는 응용 영역이 요구하는 데이터 형태와는 일치하지 않으므로, 표현 영역은 요청을 응용 서비스의 요구 형식으로 매핑한다.
  * 바꿔 말해, 응용 서비스의 반환 값 역시 사용자가 기대하는 결과와 일치하지 않으므로 표현 영역은 이러한 매핑 역할까지 담당하게 된다.
* **이러한 구조로 인해 응용 영역은 사용자가 웹 브라우저를 사용하는지, 혹은 REST API를 사용하는지 등 세부적인 기술에 의존하지 않을 수 있게 된다**.

### 응용 영역의 책임
```
> 소프트웨어의 핵심인 도메인 영역을 잘 정의하지 못한다면 좋은 애플리케이션을 만들 수 없다.
> 그러나 잘 정의된 도메인 영역이 있다고 하더라도, 사용자와 도메인을 연결홰주는 매게체로서 응용 영역과 표현 영역은 필수적이다.
```
* 응용 영역의 책임은 크게 다음과 같이 분류할 수 있다.
  1. 일종의 파사드로서 사용자의 요청을 받아들이는 **표현 영역과, 중요한 도메인 로직을 처리하는 도메인 영역을 연결**
  2. 사용자의 요청을 처리하는 과정에서의 **트랜잭션 처리**
  3. 사용자의 요청을 처리하는 과정과 연관된 **이벤트 처리**
* 응용 영역의 서비스는 사용자가 실제로 원하는 기능을 제공하는 주체이며, 기능을 실행하기 위해 필수적입 입력을 받아 요청 처리 결과를 출력한다.
  * 때문에 **대부분의 응용 서비스 로직은 사용자의 요청을 처리하기 위한 도메인 객체를 리포지토리로부터 조회하는 것으로 시작**한다.
* **응용 서비스는 주로 도메인 객체 간의 흐름을 제어하므로, 사용자의 요청을 검증하고 각 도메인 객체가 제공하는 메소드만을 호출하는 단순한 형태**를 갖는다.
  * 또한, 사용자에게 노출할 데이터를 반환할 수도 있으나 이 경우에는 애그리거트 자체가 아닌 필요한 데이터만을 취합하는 전용 DTO를 반환하는 것이 권장된다. 
* 바꿔 말해, **응용 서비스가 필요 이상으로 복잡한 것처럼 보인다면 이는 응용 서비스가 도메인 로직의 일부를 구현하고 있다는 신호**일 수 있다.
  * 도메인 로직을 응용 서비스에서 구현하는 이러한 방식은 코드가 불필요하게 중복되어 코드의 유지보수성을 크게 떨어트릴 수 있다.
* **트랜잭션은 응용 서비스의 또 다른 주요한 역할 중 하나이며, 응용 서비스는 도메인의 상태 변경을 반드시 트랜잭션 아래에서 처리**해야 한다.

### 응용 서비스의 크기
* 응용 서비스는 단지 흐름만을 제어하므로 구현이 어렵지 않으나, 도메인이 커질 때를 대비하여 다음과 같은 두 구현 방식을 고민하게 된다.
  1. 하나의 응용 서비스에 연관된 모든 도메인 기능을 구현
  2. 또는 도메인 기능 별로 응용 서비스를 따로 구현
* 단일 클래스를 활용할 경우 클래스의 개수가 적고 동일한 클래스 내부의 공통 로직을 쉽게 추출할 수 있다.
  * 반면, 공통 로직이 상황에 따라 미묘하게 다른 동작을 해야하는 경우 불필요한 플래그가 추가되기 쉽다.
  * 또한, 하나의 클래스에 억지로 모든 기능을 구현하게 되므로 장기적으로는 코드의 품질이 낮아지기 쉽다.
* 구분되는 기능 별로 클래스를 구현할 경우 단일 클래스 방식과 비교하여 코드의 품질은 일정 수준으로 유지된다.
  * 반면, 도메인이 커질수록 관리해야할 클래스 너무 많아지는 단점 역시 존재한다.
  * 또한, 공통되는 로직이 여러 클래스에 불필요하게 중복될 수 있으나 이는 공통 로직을 처리하는 헬퍼 클래스를 추출하는 것으로 해결할 수 있다.

### 응용 서비스의 인터페이스
* 일반적으로 **인터페이스는 구현 클래스가 여럿인 경우에 고려되며, 런타임에 구체 클래스를 교체해야하는 경우에 매우 유용**하다.
* 그러나 **일반적인 응용 서비스는 런타임에 교체되지도 않고, 이를 구현하는 구체 클래스가 둘 이상인 경우는 매우 드물다**.
  * 즉, 응용 서비스에 대한 인터페이스 추출은 불필요한 클래스를 늘리고 전체 구조의 복잡성을 높이는 원인이 된다.
* 때문에 **응용 서비스의 인터페이스가 명확하게 필요하기 전까지는 인터페이스를 추출하지 않는 것이 바람직**하다. 

### 도메인 서비스란?
```
> 응용 서비스가 응용 로직을 다루는 것과 마찬가지로, 도메인 서비스는 도메인 로직을 다루기 위해 정의된다. 
```
* **도메인 규칙과 관련된 코드를 도메인 영역에 작성하는 경우, 종종 하나의 애그리거트 내에서 모든 기능을 구현할 수 없는 경우가 발생**할 수 있다.
  * 이를 해결하기 위해 하나의 애그리거트에 모든 책임을 할당할 수도 있으나, 이는 전체적인 유지보수성을 크게 떨어트리는 결과로 이어지기 쉽다.
  * 그렇다고 해서 응용 서비스에 로직을 구현하는 것 역시 장기적으로는 동일한 결과를 낳게 된다.
* **도메인 서비스는 이러한 문제를 해소하기 위해 도입할 수 있으며, 도메인 서비스는 임의의 도메인 기능만을 구현하기 위한 서비스의 역할을 담당**한다.
* **도메인 서비스는 도메인 영역에 위치하는 도메인 로직을 표현**하기 위해 사용되며, 주로 다음과 같은 상황에 고려해볼 수 있다.
  1. **여러 애그리거트에 걸쳐 처리되어야 하는 도메인 로직**
  2. 또는 **외부 시스템을 사용하여 처리되어야 하는 도메인 로직**
* 이 때, **애플리케이션의 패키지 구조 상 도메인 서비스 역시 애그리거트와 같은 패키지에 위치**하게 된다.
* 반면, **도메인 서비스에서 처리하는 로직이 하나의 형태로 고정되지 않는 경우 이를 인터페이스로 추출하는 것을 고려**해볼 수 있다.
  * 이 경우, 도메인 서비스의 구현이 임의의 기술이나 외부 시스템에 의존하는 경우 인터페이스를 구현하는 구체 클래스는 인프라스트럭쳐 영역에 정의되어야 한다. 

### 여러 애그리거트를 아우르는 로직을 위한 도메인 서비스
* **도메인 서비스는 애그리거트나 밸류 타입과 같은 구성 요소와 달리, 상태 없이 오직 로직만을 처리**하는 특징을 갖는다.
* 이 때, **도메인 서비스를 사용하는 주체는 애그리거트이거나 응용 서비스**일 수 있다.
  * 예를 들어, 응용 서비스를 통해 애그리거트 객체에 도메인 서비스를 인자로 전달하여 도메인 기능을 처리할 경우 주체는 애그리거트가 된다.
  * 중요한 것은 **도메인 서비스는 도메인과 관련된 데이터 집합으로서의 애그리거트와 연관이 없으므로 의존성을 주입하는 것 방식은 바람직하지 않다는 점**이다.
* 반면, **애그리거트의 메소드를 호출할 때 도메인 서비스를 넘기는 방식과 달리 도메인 서비스의 메소드의 인자로 필요한 애그리거트를 전달할 수도 있다**.
* 또한, **도메인 서비스에는 도메인 로직만 작성해야 하며 응용 서비스와 같은 트랜잭션 처리 책임을 할당하지 않아야** 한다.

### 외부 시스템과 연동을 위한 도메인 서비스
* **임의의 도메인 로직을 처리하기 위해 외부 시스템의 기능을 사용할 필요가 있는 경우, 연동 책임 역시도 도메인 서비스에서 할당**할 수 있다.
  * 이 때, **외부 시스템과의 통신을 처리하는 기능은 도메인 서비스의 관점에서 인터페이스로 추출**될 수 있다. 
  * 물론, 해당 인터페이스를 구현하는 클래스는 인프라스트럭쳐 영역에 위치하게 된다.

### 기능을 서비스에 할당하는 기준
* 임의의 기능을 처리할 책임이 도메인 서비스에 있을지, 또는 응용 서비스에 있을지 결정하기 어려운 상황이 발생할 수 있다.
* 이 경우, **해당 기능이 어떠한 애그리거트의 상태와 밀접한 연관이 있는지의 여부가 기준이 되어줄 수 있다**.
  * 예를 들어, **애그리거트를 변경하거나 상태를 기반으로 결과를 연산하지만 임의의 애그리거트에 할당되기엔 애매한 로직은 도메인 서비스에 정의**해볼 수 있다.

### 애그리거트에 속한 엔티티
* 애그리거트에서 루트 엔티티를 제외한 나머지 구성요소는 대부분 밸류 타입이다.
* 때문에 루트 엔티티 이외의 엔티티가 존재하는 경우, 밸류 타입을 엔티티로 오인한 것은 아닌가 확인할 필요가 있다.
  * 반면, **밸류 타입이 아닌 엔티티가 확실한 경우 해당 엔티티가 별도의 애그리거트로 추출되어야 하는 것은 아닌지 확인이 필요**하다.
* **밸류 타입과 엔티티를 구분하는 가장 쉬운 방법은 고유 식별자의 존재 여부이나, 이러한 식별자는 테이블 상의 PK와 동일한 것은 아님에 주의**해야 한다.
  * 즉, 별도 테이블에 저장되고 테이블에 PK가 존재한다고 해서 항상 엔티티가 되는 것이 아니다.
  * 많은 경우에 밸류 타입은 별도의 테이블로 저장하기 위해 PK를 부여할 뿐, 엔티티와 1대 1 연관되는 엔티티로 취급되지 않는다.

### 도메인 모델 경계의 필요성
```
> 각 도메인 모델은 어떠한 컨텍스트 아래에서 완전한 의미를 갖기에, 의미를 명확히 하기 위해 다른 컨텍스트와 구분되는 경계를 정의할 필요가 있다.
```
* 도메인은 여러 하위 도메인으로 구분되는 경우가 잦으므로, 단일 도메인 모델로 하나의 도메인을 완벽히 표현하는 것은 어렵다.
  * 또한, 단일 모델로 엮어내는 것은 어려울뿐더러 성공한다 하더라도 하위 도메인에 맞지 않는 결과물이 만들어지기 쉽다.
  * 이러한 **작업의 난이도를 높이는 요인 중 하나는 하위 도메인마다 같은 용어라도 의미가 다르거나, 같은 대상을 지칭하는 용어가 다를 수 있기 때문**이다.
* 하위 도메인마다 사용하는 용어가 다를 수 있기에 올바른 도메인 모델을 위해서는 하위 도메인마다 개별적인 모델을 정의할 필요가 있다.
  * 또한, 이 과정에서 정의된 **각 모델은 명시적으로 구분되는 경계를 가져 서로 섞이지 않도록 주의를 기울여야 한다**.
* 상술한 바와 같이 **모델은 어떠한 컨텍스트 하에서 완전한 의미를 가지며, 이렇듯 모델의 의미를 나누는 경계를 갖는 컨텍스트를 바운디드 컨텍스트라고**한다. 

### 바운디드 컨텍스트란?
```
> 바운디드 컨텍스트는 모델의 경계를 정의하며, 하나의 바운디드 컨텍스트는 논리적인 하나의 모델을 갖는다.
```
* 각각의 **바운디드 컨텍스트를 구분하는 기준 중 대표적인 것은 용어**이다.
  * 예를 들어, 컨텍스트 A와 컨텍스트 B가 서로 다른 용어를 사용한다면 이러한 용어를 기준으로 컨텍스트를 분리할 수 있다.
* **바운디드 컨텍스트는 사용자에게 실제 기능을 제공할 수 있는 물리적인 시스템이며, 도메인 모델은 바운디드 컨텍스트 안에서 도메인의 형태로 구현**된다.
* 바운디드 컨텍스트의 이상적인 형태는 하위 도메인과 일대일 관계를 갖는 것이나, 개발 팀의 규모나 정책에 따라서는 그렇지 못한 경우도 있을 수 있다.
  * 이렇듯 하나의 물리적인 바운디드 컨텍스트에 여러 하위 도메인이 개발되는 경우, 패키지 구조를 적절하게 정의하여 논리적인 바운디드 컨텍스트를 분할할 수 있다.
* **바운디드 컨텍스트는 도메인 모델을 구분하는 경계이므로, 구현하는 하위 도메인에 걸맞는 모델만을 포함**하게 된다.
  * 때문에 **같은 이름의 도메인 모델을 정의하는 같은 이름의 클래스이더라도 바운디드 컨텍스트에 따라 다른 형태를 가질 수 있다**.

### 바운디드 컨텍스트의 구현
```
> 바운디드 컨텍스트는 임의의 도메인 기능을 제공하기 위해 필요한 모든 요소를 포함한다. 
```
* **바운디드 컨텍스트는 도메인 모델만을 포함하지 않으며, 도메인 기능을 제공하기 위한 표현 영역과 응용 영역 서비스 및 인프라스트럭쳐 영역을 모두 포함**한다.
  * 나아가 도메인 모델의 형태가 변경될 때마다 이러한 변경 사항은 테이블 스키마에도 반영되므로, 구체적인 DB 테이블 역시 바운디드 컨텍스트에 포함된다.
* 시스템이 동작하기 위해 외부 바운디드 컨텍스트와 통합될 필요가 있는 경우, 도메인 서비스를 활용한 통신 기능을 구현해볼 수 있다.
* **마이크로서비스 아키텍쳐는 바운디드 컨텍스트와 잘 융합될 수 있으며, 모델의 경계를 형성하는 바운디드 컨텍스트 별로 별도의 서비스를 구현**할 수 있다.
  * 바운디드 컨텍스트 별로 프로젝트를 생성하는 MSA를 따를 경우, 코드 수준에서 모델이 분리되므로 이상적인 바운디드 컨텍스트를 정의할 수 있게 된다.

### 바운디드 컨텍스트 간의 관계
```
> 바운디드 컨텍스트들은 서로 어떠한 방식으로든 연결될 수 있으며, REST API를 활용하는 방식이 대표적이다.
```
* REST API를 기반으로 **연결된 두 바운디드 컨텍스트를 예로 들어, 각 컨텍스트는 API를 제공하는 업스트림과 이를 사용하는 다운스트림으로 구분**할 수 있다.
  * 이 때, 업스트림 컴포넌트는 다운스트림 컴포넌트가 사용할 수 있도록 통신 방식을 정의하고 이를 공개하게 된다.
* **업스트림 컴포넌트의 서비스는 업스트림 바운디드 컨텍스트의 도메인 모델을 따르므로, 다운스트림 컴포넌트는 이에 의존하지 않도록 주의**를 기울여야 한다.
  * 대부분의 경우 업스트림 바운디드 컨텍스트와 통신하는 다운스트림 바운디드 컨텍스트의 인프라스트럭쳐 영역 클래스가 모델 변환을 담당하게 된다.

### 컨텍스트 맵 정의하기
* 애그리거트의 경우와 마찬가지로, 바운디드 컨텍스트 역시 도메인이 커질수록 개별 모델에 매몰되면 전체를 조망하기 어려울 수 있다.
* 컨텍스트 맵은 나무보다 숲을 볼 수 있도록 하는 지도 역할을 담당하며, 바운디드 컨텍스트 간의 관계를 표현한다.
  * 이 때, 컨텍스트 맵은 바운디드 컨텍스트 간의 경계와 관계성을 명확하게 드러내는 것이 바람직하다.
* 컨텍스트 맵은 시스템의 전체 구조를 표현하며...?

## Spring Advanced
### @Before 어드바이스란?
* `@Before` 어드바이스는 조인 포인트의 실행 전에 수행되며, `@Around` 어드바이스와 달리 작업 흐름을 변경할 수는 없다.
* 예를 들어, `@Around` 어드바이스는 `ProceedingJoinPoint.proceed()` 메소드를 통해 다음 대상을 호출한다.
  * 바꿔 말해 이를 호출하지 않을 경우, 다음 대상 자체가 호출되지 않아 의도한 동작을 처리할 수 없게 된다.
* 반면, **`@Before` 어드바이스는 `ProceedingJoinPoint.proceed()` 메소드 자체를 사용하지 않으며 메소드 종료시 자동으로 다음 대상을 호출**한다.
  * 물론, 처리 과정에서 예외가 발생할 경우 다음 코드는 호출되지 않는다.

### @AfterReturning 어드바이스란?
* `@AfterReturning` 어드바이스는 메소드 실행이 정상적으로 처리되어 성공적으로 반환된 경우에만 수행된다.
* 이 때, 해당 어드바이스는 `@AfterReturning` 어노테이션에 다음과 같은 두 인자를 받아 동작한다.
  * `value`: 포인트컷 메소드 정보를 명시한다.
  * `returning`: 어드바이스 메소드의 매개변수 이름으로, 해당 인자에 명시된 매개변수에 해당하는 타입의 값을 반환하는 메소드를 대상으로만 실행한다.
* 다시 말해, `@AfterReturning` 어드바이스는 `returning`에 명시된 인자 이름인 `result`의 타입인 `Object`를 반환하는 메소드에 대해서만 수행된다.
  * 이 때, **`Object`와 같이 임의의 클래스에 대한 공통 부모 역할을 할 수 있는 타입인 경우 그 자식 타입을 반환하는 모든 메소드에 대해 적용**된다.
* 또한, `@Around` 어드바이스와 달리 반환되는 객체를 변경할 수는 없기에 반환되는 객체를 변경하고자 하는 경우에는 `@Around` 어드바이스를 사용해야 한다.
  * 반면, **반환되는 객체의 상태를 변경하는 등의 조작은 가능**하다.

### @AfterThrowing 어드바이스란?
* `@AfterThrowing` 어드바이스는 메소드 실행 도중 예외가 발생하여 종료되는 경우에만 수행된다.
* 이 때, 해당 어드바이스는 `@AfterThrowing` 어노테이션에 다음과 같은 두 인자를 받아 동작한다.
  * `value`: 포인트컷 메소드 정보를 명시한다.
  * `throwing`: 어드바이스 메소드의 매개변수 이름으로, 해당 인자에 명시된 매개변수에 해당하는 타입의 예외에 부합하는 예외를 대상으로만 실행한다.
* **`throwing`의 경우, `@AfterReturning`의 경우와 마찬가지로 부모 타입의 예외를 명시한 경우 모든 자식 타입의 예외에 대해 적용**될 수 있다.

### @After 어드바이스란?
* `@After` 어드바이스는 마치 `try-catch` 문의 `finally` 절처럼 메소드 실행이 종료된 경우에 수행된다.
  * 즉, 메소드의 정상 실행 및 예외 발생 케이스 모두를 처리할 수 있다.
* 이러한 이유에서, **대부분의 경우 `finally` 절과 마찬가지로 리소스 또는 유사한 개념을 해제하는 용도로 사용**되곤 한다.
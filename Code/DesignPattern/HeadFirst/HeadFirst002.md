# HeadFirst
## 2022-10-20 Thu

### 변화에 대응할 준비하기
* **옵저버 패턴 역시 앞서 다루었던 다음의 원칙을 벗어나지 않은 상태에서 유연성을 보장할 수 있어야** 한다.
  1. 변화할 수 있는 부분을 캡슐화해야 한다.
  2. 구현보다는 추상에 의존해야 한다.

### 옵저버 패턴의 이해
```
> 옵저버 패턴은 무엇인가 중요한 이벤트가 발생했을 때 객체에게 이를 알려줄 수 있도록 한다.
```
* 옵저버 패턴을 이해하기에 앞서, 우선 신문 구독 흐름을 상기해보는 것으로 패턴의 이해를 도울 수 있다.
  1. 신문사가 사업을 시작하고, 신문을 만들어내기 시작한다.
  2. 독자는 임의의 신문사에 구독 신청을 할 수 있다.
  3. **독자가 임의의 신문사에 구독을 신청한 경우, 신문사가 새로운 신문을 발행할 때마다 이를 배달**받을 수 있다.
  4. **신문을 더 이상 구독하지 않고자하는 경우, 구독을 해지**할 수 있다.
  5. **신문사의 독자는 꾸준히 증가하거나 감소**할 수 있다.
* 이 때, 신문사와 독자의 관계는 옵저버 패턴과 매우 유사하며 각각 다음과 같은 역할을 수행한다.
  1. 신문사: 옵저버 패턴에서 주제에 대응된다.
  2. 독자: 옵저버 패턴에서 옵저버 자체에 대응된다. 
* 이러한 배경 지식 하에 옵저버 패턴을 개괄적으로 표현하면 다음과 같다.
  1. 주제는 주제 객체로 대표되며, 주제 객체는 중요한 데이터를 관리할 책임을 갖는다.
  2. 옵저버 객체들은 주제 객체를 구독하는 것으로 주제 객체에 등록된다.
  3. **주제 객체는 자신이 관리하는 주제 데이터가 변경되었을 때 어떠한 방법으로든 간에 등록된 옵저버들에게 이를 알릴 책임**을 갖는다.
  4. **옵저버 객체는 주제 객체가 관리하는 주제 데이터가 변경되었을 때 갱신된 내용을 전달받아 적절하게 행동**할 수 있다.
     * 반면, 주제 객체에 등록되지 않은 객체는 옵저버 객체가 아니므로 데이터의 변경에 대해 어떠한 알림도 받을 필요가 없다.

### 옵저버 패턴의 정의
```
> 옵저버 패턴은 한 객체의 상태가 변경되면 해당 객체에 의존하는 다른 옵저버 객체들이 연락을 받아 내용을 갱신하는 식으로 1:N 의존성을 정의한다.
```
* 상술했듯, **옵저버 패턴은 마치 신문 구독 서비스와 같은 구조를 가지며 일련의 객체 사이에서 1:N 관계를 정의**한다.
  * 이로 인해 모든 옵저버 객체는 주제 객체에 의존하며, 주제 객체의 상태가 변경되면 모든 옵저버 객체는 정보를 전달받는다.
* 이러한 **옵저버 패턴은 여러 방법으로 구현할 수 있으나, 일반적으로는 주제 인터페이스와 옵저버 인터페이스가 포함되는 클래스 디자인으로 구현**된다.

## 2022-10-21 Fri
### 옵저버 패턴의 구조
* **옵저버 패턴을 구성하는 경우, 주제 클래스와 독자를 나타내는 옵저버 클래스는 반드시 각각 인터페이스로 구성**되어야 한다.
  * 예를 들어, 주제와 독자를 나타내는 구체 클래스는 반드시 각각 Subject 인터페이스와 Observer 인터페이스를 구현한다.
* 주제 인터페이스의 경우, 다음과 같은 메소드를 필요로 한다.
  1. register: 옵저버 객체가 호출하여 독자로 등록한다.
  2. remove: 옵저버 객체가 호출하여 등록을 해지한다.
  3. notify: 주제 인터페이스를 구현하는 구체 클래스의 상태가 변경되었을 때, 자신에게 등록된 모든 옵저버 객체에게 이 사실을 알리기 위해 호출한다.
* **반면, 옵저버 인터페이스는 주제 구체 클래스의 상태가 변경되었을 때 notify 메소드에서 호출 할 update 메소드만을 가져도 충분**하다.

### 옵저버 패턴과 1:N 관계
* **옵저버 패턴에서는 주제 객체가 상태를 저장하고 제어하므로, 상태를 갖는 객체는 하나만 존재**할 수 있다.
* 반면, 옵저버 객체는 상태를 주제 객체로부터 전달 받아 사용하지만 반드시 자신의 멤버로 소유할 필요는 없다.
  * **옵저버 객체의 이러한 성질로 인해 옵저버 객체는 여럿이 존재할 수 있으며, 주제 객체에 의존적인 1:N 관계를 수립**하게 된다.
  * 이렇듯 의존성을 적절히 설정할 경우, 여러 객체가 동일한 데이터를 각자 관리하는 것보다 훨씬 깔끔한 객체지향 디자인을 만들 수 있다.

### 애플리케이션에 유연성을 부여하기
```
> 딱딱한 물체보다 느슨한 물체가 덜 깨지듯, 애플리케이션 역시 객체가 서로 느슨하게 결합된다면 객체가 깨질 가능성은 낮아진다.
> 즉, 애플리케이션을 구성하는 객체들이 서로와 느슨하게 결합된다면 애플리케이션의 유연성은 높아질 수 있다.
```
* **객체가 다른 객체의 세부 구현까지 알고 있는 것은 단단한 결합에 해당하며, 객체가 심하게 의존하고 있다는 말로 표현**할 수 있다.
  * 이러한 **객체는 단단하게 결합되어 변화에 대응하기 어려울 수 있으므로, 객체들은 최대한 서로에게 의존하지 않도록 느슨하게 결합되는 것이 바람직**하다.
* **그러나 이 말이 곧 객체가 다른 객체에게 `절대로` 의존하지 않아야 한다는 의미는 아니다**.
  * **모든 생물은 서로에게 의존하듯, 모든 객체 역시 다른 객체에게 의존**한다.
  * 때문에 모든 **객체는 서로에게 의존하되, 서로의 세세한 구현 사항까지 알 필요 없이 느슨하게 결합되는 것이 이상적**이다.

### 느슨한 결합
```
> 느슨한 결합이란, 객체들이 서로 상호작용할 수 있지만 서로에 대해 너무 깊이 알지는 않는 관계를 의미한다.
```
* **느슨한 결합을 활용할 경우 애플리케이션의 유연성은 높아지며, 옵저버 패턴 역시 느슨한 결합의 예시 중 하나**이다.
* 예를 들어, 옵저버 패턴은 다음과 같은 이유에서 느슨한 결합으로 구성될 수 있다.
  1. 주제는 옵저버가 구현하는 인터페이스만을 알게 되며, 주제는 옵저버 인터페이스 목록에만 의존하므로 새로운 옵저버를 추가하기도 쉽다.
  2. 옵저버 인터페이스만 구현한다면 구체 옵저버 클래스는 어떠한 형태라도 등록할 수 있다.
  3. 주제와 옵저버는 서로 단단하게 결합되지 않으므로, 모두 독립적으로 재사용할 수 있다.
  4. **주제와 옵저버는 느슨하게 결합되므로, 인터페이스만 정상적으로 구현한다면 서로에게 영향을 주지 않는다**.

### 네 번째 디자인 원칙 - 느슨한 결합
```
> 상호작용하는 객체 간에는 가능한 한 느슨한 결합을 적용해야 한다.
```
* **느슨하게 결합되는 디자인을 적용한 경우, 애플리케이션이 성숙함에 따라 변화가 필요하더라도 무난하게 처리할 수 있는 유연한 객체지향 시스템이 구축**된다.
  * 이는 **서로 의존하는 객체들이 느슨하게 결합되어 상호 의존성 자체가 최소화되기 때문**이다.

## 2022-10-22 Sat
### 옵저버 패턴의 정의
* **옵저버 패턴은 하나의 객체 상태가 변경된 경우에 해당 객체에 의존하는 모든 다른 객체에게 이를 알리고, 자동으로 내용이 갱신되도록 1:N 의존성을 정의**한다.
* 또한, 상술했던 주제 인터페이스와 옵저버 인터페이스의 정의에 따라 Java로 인터페이스를 작성할 경우 다음과 같을 수 있다.
  * 이 중, Observer 인터페이스의 메소드인 update의 시그니쳐는 주제 객체가 관리하는 상태의 종류 및 개수에 따라 변경될 수 있다. 
```
// 주제 인터페이스
public interface Subject {
    void register(Observer observer);
    void remove(Observer observer);
    void notify();
}

// 옵저버 인터페이스
public interface Observer {
    void update(int data);
}
```
* 이에 따라 구체 주제 클래스를 정의하는 경우, 다음과 같은 코드를 작성할 수 있다.
```
public class ConcreteSubject implements Subject {
    private List<Observer> observers;
    int data;
    
    public ConcreteSubject() {
        this.observers = ArrayList<Observer>();
    }
    
    public void register(Observer observer) {
        observers.add(observer);    
    }
    
    public void remove(Observer observer) {
        observers.remove(observer);
    }
    
    // 모든 옵저버 객체는 update 메소드를 구현할 것이므로, 단순히 for 문 순회로도 호출이 가능하다.
    public void notify() {
        for(Observer observer : observers) {
            observers.update(data);
        }
    }
    
    // 무언가 발생하면 이를 자신이 관리하는 상태에 반영한 후, 모든 옵저버 객체에게 알린다.
    public void assertSomeEventOccurerd(int data) {
        this.data = data;
        notify();
    }
}
```
* 반면, 구체 옵저버 클래스를 정의하는 경우 다음과 같을 수 있다.
  * **이 때, 옵저버 클래스는 생성자로 주제 인스턴스를 전달받아 그 참조를 자신의 멤버로 저장할 수 있다**.
  * 이 경우, 해당 참조 변수는 추후에 옵저버 클래스가 주제 인스턴스로부터 등록을 해제할 경우에 유용하게 사용할 수 있다.
```
public class ConcreteObserver implements Observer {
    private int data;
    private Subject subject;
    
    // 옵저버 객체는 생성자로 주제 인스턴스를 전달받아 자신이 그 참조를 가질 수 있다.
    // 해당 참조를 활용하여 생성자 차원에서 옵저버 객체를 등록하는 작업까지 수행한다.
    public ConcreteObserver(Subject subject) {
        this.subject = subject;
        subject.register(this);
    }
    
    // 주제 객체로부터 update 메소드가 호출되면 이를 자신의 상태에 반영한 후, 무언가를 수행한다.
    public void update(int data) {
        this.data = data;
        doSomething(); // 이렇듯 값이 변경되었을 때 '무언가'를 호출하는 것은 최선의 방법은 아니며, 다른 패턴을 적용할 수 있다.
    }
    
    public void doSomething() {
        System.out.println("data: ", + this.data);
    }
}
```

### 주제와 옵저버를 다른 방식으로 개선하기
* 상술한 주제 클래스는 다음과 같은 문제점이 발생할 수 있다.
  1. 옵저버 클래스가 필요한 시점이 아닌, 주제 클래스가 적절하다고 판단한 시점에만 데이터 변경 사항을 전달한다.
  2. **각 옵저버 클래스는 자신에게 정말 필요한 데이터 뿐만이 아니라 필요 없는 정보까지도 전달받아야 한다**.
  3. **주제 객체가 관리하는 새로운 데이터가 추가되는 경우, 주제 클래스 뿐만 아니라 모든 옵저버 클래스까지도 수정이 필요**해진다.
* 이러한 특징을 개선하기 위해, 옵저버 클래스가 필요한 시점에 주제 클래스로부터 데이터를 가져갈 수 있도록 접근자 메소드를 추가하는 것을 고려할 수 있다.
  * 반면, **이 방법을 채택하는 경우에는 항상 주제 클래스와 옵저버 클래스가 너무 단단하게 결합되지는 않는지 경계할 필요**가 있다.

### 라이브러리 속 옵저버 패턴
* 옵저버 패턴은 흔하게 사용되는 디자인 패턴 중 하나로, 이미 수 많은 라이브러리와 프레임워크에서 사용하고 있다.
  * 예를 들어 Java의 GUI 툴킷인 스윙과 JS의 이벤트 등이 있다.
  * 이렇듯 **디자인 패턴을 이해하면 이를 사용하는 라이브러리의 설계 원리와 동기를 쉽고 빠르게 이해**할 수 있다.

### 풀 방식과 푸시 방식
* 옵저버가 주제 객체로부터 필요할 때 데이터를 가져오는 방식은 임의의 시점에 데이터 변경 알림을 받는 것보다 더 유연할 수 있다.
* 또한, 기존 방식은 **주제 객체가 관리하는 데이터의 종류가 많다면 하나의 데이터만 변경되더라도 모든 옵저버가 전체 데이터를 다시 수신 받아 업데이트**한다.
  * 이러한 문제는 여러 종류의 옵저버가 정의되는 경우, 어떤 옵저버는 자신이 전혀 사용하지 않는 데이터에 대한 알림을 받아야할 수도 있다.
* 사실 **푸시 방식과 풀 방식의 옵저버는 단순히 구현 방법의 차이에 불과하지만, 일반적인 경우에는 풀 방식이 더 좋다**.
  * 이는 **시간이 지나 애플리케이션이 점점 복잡해질 수 밖에 없는 반면, 푸시 방식에 비해 풀 방식의 옵저버가 더 확장성이 높기 때문**이다.
  * 심지어 푸시 방식의 객체를 풀 방식으로 변경하는 것은 단지 접근자 메소드를 추가하는 것에 불과하므로, 수정이 어렵지도 않다.

### 풀 방식으로 변경하기
* 푸시 방식의 경우, 주제 객체에 포함되는 데이터는 옵저버 객체의 update 메소드의 인자로 전달된다.
* 이를 **풀 방식으로 변경하는 경우, 옵저버 객체의 update 메소드의 매개 변수를 모두 제거한 후 주제 객체에 데이터 별 접근자를 추가할 필요**가 있다.
  * 이를 통해 각 옵저버 객체는 update 메소드를 재정의하는 과정에서 자신이 필요한 데이터만을 주제 객체로부터 조회할 수 있다.
```
// 옵저버 인터페이스의 update 메소드 시그니쳐가 변경된다.
public interface Observer {
    void update();
}

public class PullSubject implements Subject {
    // ... 생략
    // 옵저버 객체 update 메소드 호출부를 변경된 Observer 인터페이스 내용에 맞추어 수정한다.
    public void notify() {
        for(Observer observer : observers) {
            observers.update();
        }
    }
}

public class PullObserver implements Observer {
    private int data;
    private Subject subject;
    
    public PullObserver(Subject subject) {
        this.subject = subject;
        subject.register(this);
    }
    
    // 옵저버 인터페이스의 update 메소드 시그니쳐가 변경됨에 따라 이를 반영하며, 재정의하는 과정에서 필요한 데이터를 주제 객체로부터 조회한다. 
    public void update() {
        this.data = subject.getData();
        doSomething();
    }
    
    public void doSomething() {
        System.out.println("data: ", + this.data);
    }
}
```

### 옵저버 패턴 - 결론
```
> 옵저버 패턴은 하나의 객체 상태가 변경되었을 때, 이에 의존하는 다른 객체들에게 변경을 알리고 이를 자동으로 갱신하는 1:N 의존성을 정의한다.
> 옵저버 패턴은 자주 사용되는 패턴 중 하나이며, 여러 프레임워크와 라이브러리에서도 쉽게 발견할 수 있다.
```
* 바꿔 말해, **옵저버 패턴은 임의의 객체 상태를 느슨하게 결합되는 다른 객체에게 전달하는 패턴으로 표현**할 수도 있다.
  * 상술했듯, **느슨하게 결합되는 디자인은 훨씬 유연하므로 변화에 쉽게 대응**할 수 있다.
* 옵저버 패턴은 객체들 사이에 1:N 관계를 정의하기 위해 사용한다.
  * 이 때, 1에 해당하는 주제 객체는 동일한 인터페이스를 사용하는 옵저버 객체의 메소드를 호출하여 연락한다.
  * 또한, **주제는 옵저버 객체들이 옵저버 인터페이스를 구현하는 것을 제외하면 옵저버의 상세한 내용을 알지 못하므로 느슨하게 결합**된다.
* **주제와 옵저버는 푸시 방식 또는 풀 방식을 사용할 수 있으나, 일반적으로는 옵저버 객체가 데이터를 가져오는 풀 방식이 더 옳은 것으로 여겨진다**.
* 옵저버 패턴은 여러 주제와 메시지 유형을 갖는 복잡한 패턴인 출판 - 구독 패턴과 동일하지 않지만, 많은 공통점을 갖는 친척과도 같다. 
* **주제는 옵저버를 잘 알지 못하는 반면, 옵저버는 주제에 의존적**이다.
* **주제 객체가 옵저버에게 알리는 경우, 알림은 순서에 의존적이지 않도록 구현**되어야 한다.
  * 즉, 어떤 옵저버 객체가 먼저 알림을 받아도 애플리케이션 로직에는 전혀 상관이 없어야 한다.
* **주제 객체는 상속이 아닌 구성을 활용하여 옵저버 객체들의 참조를 관리하며, 일반적으로 이렇듯 실행 중에 구성이 이루어지는 방식이 더 유연**하기도 하다.
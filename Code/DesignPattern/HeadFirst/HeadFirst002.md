# HeadFirst
## 2022-10-20 Thu

### 변화에 대응할 준비하기
* **옵저버 패턴 역시 앞서 다루었던 다음의 원칙을 벗어나지 않은 상태에서 유연성을 보장할 수 있어야** 한다.
  1. 변화할 수 있는 부분을 캡슐화해야 한다.
  2. 구현보다는 추상에 의존해야 한다.

### 옵저버 패턴의 이해
```
> 옵저버 패턴은 무엇인가 중요한 이벤트가 발생했을 때 객체에게 이를 알려줄 수 있도록 한다.
```
* 옵저버 패턴을 이해하기에 앞서, 우선 신문 구독 흐름을 상기해보는 것으로 패턴의 이해를 도울 수 있다.
  1. 신문사가 사업을 시작하고, 신문을 만들어내기 시작한다.
  2. 독자는 임의의 신문사에 구독 신청을 할 수 있다.
  3. **독자가 임의의 신문사에 구독을 신청한 경우, 신문사가 새로운 신문을 발행할 때마다 이를 배달**받을 수 있다.
  4. **신문을 더 이상 구독하지 않고자하는 경우, 구독을 해지**할 수 있다.
  5. **신문사의 독자는 꾸준히 증가하거나 감소**할 수 있다.
* 이 때, 신문사와 독자의 관계는 옵저버 패턴과 매우 유사하며 각각 다음과 같은 역할을 수행한다.
  1. 신문사: 옵저버 패턴에서 주제에 대응된다.
  2. 독자: 옵저버 패턴에서 옵저버 자체에 대응된다. 
* 이러한 배경 지식 하에 옵저버 패턴을 개괄적으로 표현하면 다음과 같다.
  1. 주제는 주제 객체로 대표되며, 주제 객체는 중요한 데이터를 관리할 책임을 갖는다.
  2. 옵저버 객체들은 주제 객체를 구독하는 것으로 주제 객체에 등록된다.
  3. **주제 객체는 자신이 관리하는 주제 데이터가 변경되었을 때 어떠한 방법으로든 간에 등록된 옵저버들에게 이를 알릴 책임**을 갖는다.
  4. **옵저버 객체는 주제 객체가 관리하는 주제 데이터가 변경되었을 때 갱신된 내용을 전달받아 적절하게 행동**할 수 있다.
     * 반면, 주제 객체에 등록되지 않은 객체는 옵저버 객체가 아니므로 데이터의 변경에 대해 어떠한 알림도 받을 필요가 없다.

### 옵저버 패턴의 정의
```
> 옵저버 패턴은 한 객체의 상태가 변경되면 해당 객체에 의존하는 다른 옵저버 객체들이 연락을 받아 내용을 갱신하는 식으로 1:N 의존성을 정의한다.
```
* 상술했듯, **옵저버 패턴은 마치 신문 구독 서비스와 같은 구조를 가지며 일련의 객체 사이에서 1:N 관계를 정의**한다.
  * 이로 인해 모든 옵저버 객체는 주제 객체에 의존하며, 주제 객체의 상태가 변경되면 모든 옵저버 객체는 정보를 전달받는다.
* 이러한 **옵저버 패턴은 여러 방법으로 구현할 수 있으나, 일반적으로는 주제 인터페이스와 옵저버 인터페이스가 포함되는 클래스 디자인으로 구현**된다.

## 2022-10-21 Fri
### 옵저버 패턴의 구조
* **옵저버 패턴을 구성하는 경우, 주제 클래스와 독자를 나타내는 옵저버 클래스는 반드시 각각 인터페이스로 구성**되어야 한다.
  * 예를 들어, 주제와 독자를 나타내는 구체 클래스는 반드시 각각 Subject 인터페이스와 Observer 인터페이스를 구현한다.
* 주제 인터페이스의 경우, 다음과 같은 메소드를 필요로 한다.
  1. register: 옵저버 객체가 호출하여 독자로 등록한다.
  2. remove: 옵저버 객체가 호출하여 등록을 해지한다.
  3. notify: 주제 인터페이스를 구현하는 구체 클래스의 상태가 변경되었을 때, 자신에게 등록된 모든 옵저버 객체에게 이 사실을 알리기 위해 호출한다.
* **반면, 옵저버 인터페이스는 주제 구체 클래스의 상태가 변경되었을 때 notify 메소드에서 호출 할 update 메소드만을 가져도 충분**하다.

### 옵저버 패턴과 1:N 관계
* **옵저버 패턴에서는 주제 객체가 상태를 저장하고 제어하므로, 상태를 갖는 객체는 하나만 존재**할 수 있다.
* 반면, 옵저버 객체는 상태를 주제 객체로부터 전달 받아 사용하지만 반드시 자신의 멤버로 소유할 필요는 없다.
  * **옵저버 객체의 이러한 성질로 인해 옵저버 객체는 여럿이 존재할 수 있으며, 주제 객체에 의존적인 1:N 관계를 수립**하게 된다.
  * 이렇듯 의존성을 적절히 설정할 경우, 여러 객체가 동일한 데이터를 각자 관리하는 것보다 훨씬 깔끔한 객체지향 디자인을 만들 수 있다.

### 애플리케이션에 유연성을 부여하기
```
> 딱딱한 물체보다 느슨한 물체가 덜 깨지듯, 애플리케이션 역시 객체가 서로 느슨하게 결합된다면 객체가 깨질 가능성은 낮아진다.
> 즉, 애플리케이션을 구성하는 객체들이 서로와 느슨하게 결합된다면 애플리케이션의 유연성은 높아질 수 있다.
```
* **객체가 다른 객체의 세부 구현까지 알고 있는 것은 단단한 결합에 해당하며, 객체가 심하게 의존하고 있다는 말로 표현**할 수 있다.
  * 이러한 **객체는 단단하게 결합되어 변화에 대응하기 어려울 수 있으므로, 객체들은 최대한 서로에게 의존하지 않도록 느슨하게 결합되는 것이 바람직**하다.
* **그러나 이 말이 곧 객체가 다른 객체에게 `절대로` 의존하지 않아야 한다는 의미는 아니다**.
  * **모든 생물은 서로에게 의존하듯, 모든 객체 역시 다른 객체에게 의존**한다.
  * 때문에 모든 **객체는 서로에게 의존하되, 서로의 세세한 구현 사항까지 알 필요 없이 느슨하게 결합되는 것이 이상적**이다.

### 느슨한 결합
```
> 느슨한 결합이란, 객체들이 서로 상호작용할 수 있지만 서로에 대해 너무 깊이 알지는 않는 관계를 의미한다.
```
* **느슨한 결합을 활용할 경우 애플리케이션의 유연성은 높아지며, 옵저버 패턴 역시 느슨한 결합의 예시 중 하나**이다.
* 예를 들어, 옵저버 패턴은 다음과 같은 이유에서 느슨한 결합으로 구성될 수 있다.
  1. 주제는 옵저버가 구현하는 인터페이스만을 알게 되며, 주제는 옵저버 인터페이스 목록에만 의존하므로 새로운 옵저버를 추가하기도 쉽다.
  2. 옵저버 인터페이스만 구현한다면 구체 옵저버 클래스는 어떠한 형태라도 등록할 수 있다.
  3. 주제와 옵저버는 서로 단단하게 결합되지 않으므로, 모두 독립적으로 재사용할 수 있다.
  4. **주제와 옵저버는 느슨하게 결합되므로, 인터페이스만 정상적으로 구현한다면 서로에게 영향을 주지 않는다**.

### 네 번째 디자인 원칙 - 느슨한 결합
```
> 상호작용하는 객체 간에는 가능한 한 느슨한 결합을 적용해야 한다.
```
* **느슨하게 결합되는 디자인을 적용한 경우, 애플리케이션이 성숙함에 따라 변화가 필요하더라도 무난하게 처리할 수 있는 유연한 객체지향 시스템이 구축**된다.
  * 이는 **서로 의존하는 객체들이 느슨하게 결합되어 상호 의존성 자체가 최소화되기 때문**이다.

### 옵저버 패턴의 정의
* **옵저버 패턴은 하나의 객체 상태가 변경된 경우에 해당 객체에 의존하는 모든 다른 객체에게 연락이 가고, 자동으로 내용이 갱신되는 1:N 의존성을 정의**한다.
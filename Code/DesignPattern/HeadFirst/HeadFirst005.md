# HeadFirst
## 2022-10-31 Mon

### 하나만 있더라도 문제가 없는 객체
* 일반적으로 단 하나만 존재하더라도 애플리케이션의 동작에 영향을 주지 않는 객체는 많다.
  * 예를 들어, 스레드 풀이나 캐시 및 로거 객체가 이에 해당한다.
  * **이러한 객체는 둘 이상이 존재할 경우 오히려 애플리케이션의 자원을 불필요하게 사용하거나, 일관성을 깨트리는 심각한 문제를 불러 일으킬 수 있다**.

### 전역 변수와 싱글톤 패턴
* 전역 변수에 객체를 대입하는 경우, 객체는 애플리케이션의 시작부터 끝까지 항상 존재하게 된다.
  * 반면 해당 객체의 생성 비용이 매우 큰 경우, 애플리케이션을 사용하는 동안 전역 변수를 단 한 번도 사용하지 않는 경우에는 큰 손해가 될 수 있다.
* **싱글톤은 임의의 클래스에 인스턴스가 하나만 생성되도록 보장하는 패턴이며, 다른 디자인 패턴과 마찬가지로 오랜 기간 많은 개발자들에 의해 검증**되어 왔다.
  * **싱글톤 패턴은 객체를 실제로 사용하는 경우에만 생성하므로, 적절히 사용할 경우 전역 변수를 사용할 때의 이점은 그대로 유지하면서 단점은 배제**할 수 있다.
* 이렇듯 싱글톤 패턴은 개념이 매우 간단한 반면, 실제로 이를 구현하는 것은 쉽지 않은 경우가 많다.

### 고전적인 싱글톤 패턴
* private 접근 제어자를 갖는 생성자와 정적 메소드를 혼용할 경우, 손쉽게 다음과 같은 싱글톤 클래스를 작성할 수 있다.
```java
class MyFirstSingleton {
    // 클래스의 싱글톤 인스턴스를 저장하기 위한 정적 변수에 해당한다.
    private static MyFirstSingleton instance;
    
    // 생성자를 private으로 선언했으므로, 클래스의 인스턴스는 해당 클래스 내에서만 생성할 수 있다.
    private MyFirstSingleton(){}
    
    // 해당 메소드를 통해 클래스의 인스턴스를 반환하며, 최초 요청 시점에만 인스턴스를 생성한다.
    public static MyFirstSingleton getInstance() {
        if(instance == null) {
            instance = new MyFirstSingleton();
        }
        return instance;
    }
    
    // 싱글톤 클래스 역시 인스턴스이므로, 필요하다면 다른 멤버를 가질 수 있다.
}
```
* 핵심은 getInstance 메소드의 if 분기이며, instance의 null 여부를 기반으로 인스턴스를 필요할 때에만 생성하여 반환한다.
  * 반대로 말하자면 **인스턴스가 아직 필요하지 않은 시점에는 인스턴스를 생성하지 않고, 최초로 필요한 시점에만 생성**하게 된다.
  * 이 때, **이러한 방식의 인스턴스화는 `게으른 인스턴스 생성(layze instantiation)`이라고도 지칭**할 수 있다.

## 2022-11-01 Tue
### 싱글톤 패턴의 요약
* 싱글톤은 인스턴스가 항상 하나만 유지되도록 보장하는 디자인 패턴이다.
  * 특히, 무거운 객체의 유일성은 애플리케이션 전체적으로 동일한 자원을 사용할 수 있도록하는 장점이 있다.
  * 때문에 싱글톤은 커넥션 풀 또는 스레드 풀을 관리하기 위해서 사용되곤 하며, 둘 이상의 인스턴스로 인한 예상치 못한 문제를 미연에 방지한다.
* **일반적으로 싱글톤을 보장하는 클래스는 private 접근 제어자가 부여된 인스턴스를 사용**한다.
  * 때문에 new 연산자를 통해 인스턴스를 직접 생성하는 대신 getInstance와 같은 정적 메소드를 통해 인스턴스를 반환받는다.

### 싱글톤 패턴의 정의
```
> 싱글톤 패턴은 클래스의 인스턴스를 단 하나만 생성한 후, 해당 인스턴스로의 접근하는 애플리케이션 전역적인 방법을 제공한다.
```
* 싱글톤 패턴을 적용하는 경우, 클래스 자체가 유일한 인스턴스를 관리하도록 구현한다.
  * 또한 다른 어떠한 클래스에서도 해당 클래스의 인스턴스를 더 이상 만들 수 없고, 반드시 클래스 자신을 통하도록 해야 한다.
* **싱글톤 패턴을 적용한 클래스는 애플리케이션 전역에서 해당 클래스의 인스턴스에 접근할 수 있는 방법을 제공하도록 구현**한다.
  * 즉, 언제든지 인스턴스가 필요한 클라이언트에는 클래스에 인스턴스를 요청하고 이를 반환받을 수 있어야 한다.
  * 이 때, 인스턴스의 초기화 자체에 **자원을 많이 필요로 하는 인스턴스는 지연 생성 방식으로 구현하는 것이 바람직**하다.

### 고전적 싱글톤 패턴과 멀티스레드
* **고전적인 싱글톤 패턴을 사용하는 객체를 멀티스레드로 접근하는 경우, 인스턴스의 유일성이 깨질 가능성이 존재**한다.
  * 예를 들어 다음과 같은 코드에서, getInstance의 if 분기에서 컨텍스트 스위칭이 발생한 경우 인스턴스는 스레드 개수만큼 생성될 수 있다.
```java
class MyFirstSingleton {
    private static MyFirstSingleton instance;
    
    private MyFirstSingleton(){}
    
    public static MyFirstSingleton getInstance() {
        if(instance == null) {
            // 이 시점에서 컨텍스트 스위칭이 발생할 수 있다.
            instance = new MyFirstSingleton();
        }
        return instance;
    }
}
```
* 이를 가장 빠르게 해결하기 위한 방법은 `synchronized` 키워드를 사용하는 방식이며, 수정된 코드는 다음과 같다.
  * **해당 키워드를 사용할 경우, 하나의 스레드가 getInstance 메소드의 실행을 마치기 전까지 다른 스레드는 대기**해야 한다.
  * 즉, 이로 인해 둘 이상의 스레드가 메소드를 동시에 실행하는 일은 발생하지 않게 된다.
```java
class MyFirstSingleton {
    private static MyFirstSingleton instance;
    
    private MyFirstSingleton(){}
    
    public static synchronized MyFirstSingleton getInstance() {
        if(instance == null) {
            instance = new MyFirstSingleton();
        }
        return instance;
    }
}
```
* 그러나 상술한 코드는 다음과 같은 문제점이 존재한다.
  1. `synchronized` 키워드를 활용하는 동기화는 멀티스레드 애플리케이션의 성능을 직접적으로 저하시킨다.
  2. **getInstance 메소드가 최초로 호출되어 인스턴스가 생성되는 시점을 제외하면 매소드의 동기화는 전혀 필요하지 않다**. 
# HeadFirst
## 2022-10-31 Mon

### 하나만 있더라도 문제가 없는 객체
* 일반적으로 단 하나만 존재하더라도 애플리케이션의 동작에 영향을 주지 않는 객체는 많다.
  * 예를 들어, 스레드 풀이나 캐시 및 로거 객체가 이에 해당한다.
  * **이러한 객체는 둘 이상이 존재할 경우 오히려 애플리케이션의 자원을 불필요하게 사용하거나, 일관성을 깨트리는 심각한 문제를 불러 일으킬 수 있다**.

### 전역 변수와 싱글톤 패턴
* 전역 변수에 객체를 대입하는 경우, 객체는 애플리케이션의 시작부터 끝까지 항상 존재하게 된다.
  * 반면 해당 객체의 생성 비용이 매우 큰 경우, 애플리케이션을 사용하는 동안 전역 변수를 단 한 번도 사용하지 않는 경우에는 큰 손해가 될 수 있다.
* **싱글톤은 임의의 클래스에 인스턴스가 하나만 생성되도록 보장하는 패턴이며, 다른 디자인 패턴과 마찬가지로 오랜 기간 많은 개발자들에 의해 검증**되어 왔다.
  * **싱글톤 패턴은 객체를 실제로 사용하는 경우에만 생성하므로, 적절히 사용할 경우 전역 변수를 사용할 때의 이점은 그대로 유지하면서 단점은 배제**할 수 있다.
* 이렇듯 싱글톤 패턴은 개념이 매우 간단한 반면, 실제로 이를 구현하는 것은 쉽지 않은 경우가 많다.

### 고전적인 싱글톤 패턴
* private 접근 제어자를 갖는 생성자와 정적 메소드를 혼용할 경우, 손쉽게 다음과 같은 싱글톤 클래스를 작성할 수 있다.
```java
class MyFirstSingleton {
    // 클래스의 싱글톤 인스턴스를 저장하기 위한 정적 변수에 해당한다.
    private static MyFirstSingleton instance;
    
    // 생성자를 private으로 선언했으므로, 클래스의 인스턴스는 해당 클래스 내에서만 생성할 수 있다.
    private MyFirstSingleton(){}
    
    // 해당 메소드를 통해 클래스의 인스턴스를 반환하며, 최초 요청 시점에만 인스턴스를 생성한다.
    public static MyFirstSingleton getInstance() {
        if(instance == null) {
            instance = new MyFirstSingleton();
        }
        return instance;
    }
    
    // 싱글톤 클래스 역시 인스턴스이므로, 필요하다면 다른 멤버를 가질 수 있다.
}
```
* 핵심은 getInstance 메소드의 if 분기이며, instance의 null 여부를 기반으로 인스턴스를 필요할 때에만 생성하여 반환한다.
  * 반대로 말하자면 **인스턴스가 아직 필요하지 않은 시점에는 인스턴스를 생성하지 않고, 최초로 필요한 시점에만 생성**하게 된다.
  * 이 때, **이러한 방식의 인스턴스화는 `게으른 인스턴스 생성(layze instantiation)`이라고도 지칭**할 수 있다.

## 2022-11-01 Tue
### 싱글톤 패턴의 요약
* 싱글톤은 인스턴스가 항상 하나만 유지되도록 보장하는 디자인 패턴이다.
  * 특히, 무거운 객체의 유일성은 애플리케이션 전체적으로 동일한 자원을 사용할 수 있도록하는 장점이 있다.
  * 때문에 싱글톤은 커넥션 풀 또는 스레드 풀을 관리하기 위해서 사용되곤 하며, 둘 이상의 인스턴스로 인한 예상치 못한 문제를 미연에 방지한다.
* **일반적으로 싱글톤을 보장하는 클래스는 private 접근 제어자가 부여된 인스턴스를 사용**한다.
  * 때문에 new 연산자를 통해 인스턴스를 직접 생성하는 대신 getInstance와 같은 정적 메소드를 통해 인스턴스를 반환받는다.

### 싱글톤 패턴의 정의
```
> 싱글톤 패턴은 클래스의 인스턴스를 단 하나만 생성한 후, 해당 인스턴스로의 접근하는 애플리케이션 전역적인 방법을 제공한다.
```
* 싱글톤 패턴을 적용하는 경우, 클래스 자체가 유일한 인스턴스를 관리하도록 구현한다.
  * 또한 다른 어떠한 클래스에서도 해당 클래스의 인스턴스를 더 이상 만들 수 없고, 반드시 클래스 자신을 통하도록 해야 한다.
* **싱글톤 패턴을 적용한 클래스는 애플리케이션 전역에서 해당 클래스의 인스턴스에 접근할 수 있는 방법을 제공하도록 구현**한다.
  * 즉, 언제든지 인스턴스가 필요한 클라이언트에는 클래스에 인스턴스를 요청하고 이를 반환받을 수 있어야 한다.
  * 이 때, 인스턴스의 초기화 자체에 **자원을 많이 필요로 하는 인스턴스는 지연 생성 방식으로 구현하는 것이 바람직**하다.

### 고전적 싱글톤 패턴의 잠정적인 단점
* **고전적인 싱글톤 패턴을 사용하는 객체를 멀티스레드로 접근하는 경우, 인스턴스의 유일성이 깨질 가능성이 존재**한다.
  * 예를 들어 다음과 같은 코드에서, getInstance의 if 분기에서 컨텍스트 스위칭이 발생한 경우 인스턴스는 스레드 개수만큼 생성될 수 있다.
```java
class MyFirstSingleton {
    private static MyFirstSingleton instance;
    
    private MyFirstSingleton(){}
    
    public static MyFirstSingleton getInstance() {
        if(instance == null) {
            // 이 시점에서 컨텍스트 스위칭이 발생할 수 있다.
            instance = new MyFirstSingleton();
        }
        return instance;
    }
}
```
* 이를 가장 빠르게 해결하기 위한 방법은 `synchronized` 키워드를 사용하는 방식이며, 수정된 코드는 다음과 같다.
  * **해당 키워드를 사용할 경우, 하나의 스레드가 getInstance 메소드의 실행을 마치기 전까지 다른 스레드는 대기**해야 한다.
  * 즉, 이로 인해 둘 이상의 스레드가 메소드를 동시에 실행하는 일은 발생하지 않게 된다.
```java
class MyFirstSingleton {
    private static MyFirstSingleton instance;
    
    private MyFirstSingleton(){}
    
    public static synchronized MyFirstSingleton getInstance() {
        if(instance == null) {
            instance = new MyFirstSingleton();
        }
        return instance;
    }
}
```
* 그러나 상술한 코드는 다음과 같은 문제점이 존재한다.
  1. `synchronized` 키워드를 활용하는 동기화는 멀티스레드 애플리케이션의 성능을 직접적으로 저하시킨다.
  2. **getInstance 메소드가 최초로 호출되어 인스턴스가 생성되는 시점을 제외하면 매소드의 동기화는 전혀 필요하지 않다**. 

## 2022-11-02 Wed
### 멀티스레드 문제의 해결
* 대부분의 Java 애플리케이션에서 싱글톤 객체를 지원하기 위해서는 멀티스레드 환경에서도 애플리케이션이 동작하는 것을 보장해야 한다.
* 그러나 상술한 `synchronized` 동기화 방식은 최악의 경우 동기화하지 않는 때보다 100배 정도의 성능 저하를 보일 수 있으므로, 다음과 같은 방식을 고려한다.
  1. getInstance 메소드의 속도가 그다지 중요하지 않은 경우, 메소드를 동기화한 상태로 둔다.
  2. 또는 인스턴스가 필요할 때 생성하지 않고 처음부터 생성해둔다.
  3. 또는 **인스턴스가 생성되어있지 않는 경우에만 동기화하는 Double Checked Locking 기법을 적용**한다.
* 이 때, 세 번째 방식인 DCL 코드는 다음과 같이 작성하여 getInstance 메소드의 성능을 끌어올릴 수 있다.
  * 이 경우, **인스턴스가 생성되어 있지 않는 경우에만 최초 1회 동기화한 후 더 이상 동기화하지 않는다**.
  * 그러나 해당 방식은 volatile 키워드와 관련된 문제로 인해 Java 5 이후에만 적용이 가능하다는 단점 역시 존재한다.
```java
class MyFirstSingleton {
    private volatile static MyFirstSingleton instance;
    
    private MyFirstSingleton(){}
    
    public static MyFirstSingleton getInstance() {
        // 인스턴스가 존재하지 않는 경우에만 동기화 블록을 사용한다.
        if(instance == null) {
            // 이러한 DCL 방식을 통해 인스턴스의 최초 생성 시점에만 동기화할 수 있게 된다.
            synchronized (MyFirstSingleton.class) {
                if(instance == null) {
                    instance = new MyFirstSingleton();
                }
            }
        }
        return instance;
    }
}
```

### 싱글톤 패턴 주의사항
* **싱글톤 패턴은 느슨하게 결합해야한다는 원칙을 위배하기 쉬우며, 때문에 수정 사항을 반영하기에 취약**할 수 있다.
* 싱글톤 패턴은 리플렉션이나 직렬화 및 역직렬화시 문제를 일으킬 수 있으므로, 이러한 기법을 사용하는 경우에는 반드시 숙고하는 것이 바람직하다.
* **싱글톤 패턴은이 적용된 클래스는 둘 이상의 책임을 지지만, 그 패턴 자체가 많은 개발자들에게 익숙하여 간과**되곤 한다.
* **싱글톤 패턴은 애플리케이션의 특이한 상황에서 제한적으로 사용되는 패턴이므로, 이를 애플리케이션에 여러 번 적용했다면 디자인을 다시 고민**해봐야 한다.
* 싱글톤 패턴은 클래스 로더가 여럿인 경우 정상적으로 동작하지 않을 가능성이 높으며, 그 결과 여러 인스턴스가 생성될 수 있다.

### enum 활용하기
* **상술했던 동기화 문제와 리플렉션 및 직렬화, 또는 역직렬화 문제는 enum을 활용하는 것으로 간단히 해결이 가능**하다.
  * 때문에 **싱글톤 패턴의 적용이 필요하다면 상술한 방식으로 직접 코드를 구현하기보다는 enum을 활용하는 것이 더 좋은 접근 방법**일 수 있다.
```java
public class MainApplication {
    public static void main(String[] args) {
        MyFirstSingleton singleton = MyFirstSingleton.INSTANCE;
        // 싱글톤 객체 사용하기
    }
}

enum MyFirstSingleton {
  INSTANCE;
}
```

### 싱글톤 패턴 - 결론
```
> 애플리케이션에서 특정한 클래스의 인스턴스가 단 하나만 존재해야하는 경우, 해당 클래스에 싱글톤 패턴을 적용할 수 있다.
> 싱글톤 패턴은 일견 간단해보이지만, 실제로 구현하는 경우에는 여러 가지로 신경써야할 부분이 많을 수 있다.
```
* **싱글톤 패턴을 적용한 클래스는 인스턴스가 1개만 존재하는 것이 보장되며, 애플리케이션의 어느 위치에서나 해당 인스턴스에 접근**할 수 있게 된다.
* **Java의 경우, 싱글톤 패턴은 private 접근 제어자를 할당한 생성자와 정적 메소드 및 정적 변수를 활용하여 작성**할 수 있다.
* 멀티스레드 애플리케이션의 경우 속도와 자원 등의 비용을 고려하여 여러 싱글톤 패턴의 구현 중에서 가장 적절한 것을 선택할 수 있어야 한다.
  * 또한, **기본적으로 모든 애플리케이션은 멀티스레드를 사용할 수 있다고 가정하는 것이 바람직**하다.
* **싱글톤 패턴을 enum을 활용하여 구현하는 것으로 발생 가능한 여러 문제를 해결**할 수 있다.
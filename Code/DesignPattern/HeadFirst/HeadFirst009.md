# HeadFirst
## 2022-11-19 Sat

### 반복자 패턴 - 반복을 캡슐화하기
```
> 컬렉션은 객체를 모아둔 것일 뿐이며, 어떤 자료 구조를 사용하든 결국 컬렉션은 객체의 집합으로서 기능한다.
```
* 애플리케이션을 개발하는 과정에서 ArrayList나 배열 등 사용 방법이 다른 여러 형태의 자료 구조를 사용할 수 있다.
  * 이 경우, 각 자료 구조의 사용 방법이 다르므로 코드가 필요 이상으로 장황해지기 쉽다.
  * **객체 지향 애플리케이션에서 변하기 쉬운 부분은 반드시 캡슐화를 고려해야 하며, 이 경우 변하는 부분은 컬렉션을 사용하는 방법**이 된다.
* **이러한 경우에는 디자인 패턴의 일종인 반복자 패턴을 적용할 수 있으며, Java의 경우 반복자 패턴은 Iterator 인터페이스에 의존**한다.
  * 이 때, Iterator 인터페이스는 반복 대상이 아직 남아 있는지 확인하는 hasNext()와 다음 객체를 반환하는 next() 메소드를 갖는다.
* 이러한 **Iterator 인터페이스를 적절히 활용할 경우, 배열이나 컬렉션 API 등 모든 종류의 객체 컬렉션에 반복자를 구현할 수 있다**.

### 반복자 패턴 적용하기
* 임의의 컬렉션을 사용하는 클래스에 반복자를 추가하고자하는 경우, 우선 다음과 같은 두 메소드를 갖는 Iterator 인터페이스를 구현해야 한다.
  1. hasNext: 반복 작업을 추가로 수행할 항목이 남아 있는지 boolean 형태로 반환한다.
  2. next: 실제로 컬렉션의 다음 항목을 반환한다.
* 이러한 **이러한 인터페이스를 활용하여 반복자 패턴을 적용한 구체 반복자는 자신이 사용하는 컬렉션의 종류에 맞추어 상술한 두 메소드를 반드시 구현**해야 한다.
  * 이 때, 반복자 패턴을 적용한 클래스의 경우 createIterator 등 Iterator 인터페이스를 반환할 수 있는 별도의 메소드를 두는 것이 일반적이다.
  * 물론, 상술한 내용은 java.util.Iterator를 사용하지 않는 경우에만 유효하다.
* 이렇게 작성한 **반복자를 사용할 경우, 여러 컬렉션을 관리하기 위해 필연적으로 중복될 수 밖에 없던 코드를 상당 수 줄여나갈 수 있게 된다**.
  * 이는 전적으로 **반복자를 통해 똑같은 인터페이스로 여러 종류의 컬렉션을 순회할 수 있기 때문**이다.
  * 나아가 이미 서로 다른 컬렉션을 사용하고 있던 클래스들도 단지 Iterator를 구현하는 적절한 반복자 클래스와, 이를 반환하는 메소드만 추가하게 된다.

### 반복자 패턴의 이점
```
> 반복자를 정의할 경우, 내부적으로 관리되는 모든 요소에 대한 접근 방법을 외부로 노출시키지 않은 상태에서도 모든 객체를 순회할 수 있다.
> 또한, 반복자를 구현하는 코드는 컬렉션 외부로 추출되므로 결과적으로 변하기 쉬운 반복 작업이 캡슐화되게 된다.
```
* 반복자 패턴을 적용하지 않는 경우, 다음과 같은 단점이 존재할 수 있다.
  1. **서로 다른 컬렉션을 사용하는 클래스들은 자료 구조에 대한 관리 방법을 캡슐화할 수 없고, 내부의 세부 정보인 자료 구조가 외부로 노출**된다.
  2. **이러한 컬렉션들을 다루는 클래스는 세부적인 구체 컬렉션 클래스에 강하게 결합되므로, 컬렉션마다 별도의 반복문을 작성**해야 한다.
  3. **즉, 각각의 컬렉션이 유사한 인터페이스를 가졌음에도 반드시 서로 다른 구체 클래스에 의존**하게 된다.
* 반면, 반복자 패턴을 적용할 경우 다음과 같은 이점을 얻을 수 있게 된다.
  1. **각각의 자료 구조에 대한 관리 방법은 캡슐화되며, 이를 사용하는 클래스는 추상적인 인터페이스인 Iterator에만 의존**한다.
  2. 때문에 **내부적으로 사용되는 자료 구조는 외부로 드러나지 않으며, 다형성을 활용하여 반복자를 구현하는 모든 클래스를 하나의 반복문으로 처리**할 수 있다.

## 2022-11-20 Sun
### java.util.Iterator 주의사항
```
> Iterator 인터페이스의 remove 메소드는 필수적으로 재정의해야하는 항목은 아니다.
```
* **java.util.Iterator가 제공하는 remove 기능을 제공하고 싶지 않은 경우, `UnsupportedOperationException`을 활용**할 수 있다.
  * 이는 인터페이스에 정의된 메소드이므로 이를 정의하지 않을 수는 없지만, 대신 적절한 예외를 던져 클라이언트에게 이를 알리도록 하는 방식에 해당한다. 
  * Iterator의 문서에도 remove 메소드가 해당 예외를 던질 수 있음을 강조하며, 올바른 클라이언트 코드는 항상 해당 예외를 확인하는 식으로 동작해야 한다.
* remove 메소드의 경우 동일한 컬렉션에 대해 여러 반복자가 접근하는 경우를 대비하지 않으므로, 멀티스레드 환경의 경우 매우 신중하게 작업하는 것이 바람직하다.

### 반복자 패턴의 정의
```
> 반복자 패턴은 집합체에서 사용되는 컬렉션의 구현 방법을 외부로 노출하지 않으면서도 집합체 내의 모든 요소에 접근하는 방법을 제공한다.
> 이 경우, 컬렉션의 각 요소에 접근하는 기능을 집합체 자체가 아닌 반복자 객체가 책임지므로 집합체 인터페이스와 구현은 간단해진다.
```
* **반복자 패턴을 적용할 경우, 집합체 내에서 어떠한 방식으로 작업을 처리하는지 전혀 알지 못하는 상태에서도 모든 요소를 순회**할 수 있다.
* 또한, **디자인에 반복자를 적용할 경우 컬렉션의 각 요소에 접근하는 방법이 통일되므로 모든 집합체를 순회할 수 있는 다형적인 코드를 작성**할 수 있다.
* **반복자 패턴을 적용하면 각 요소에 대한 접근 책임이 컬렉션 객체가 아닌 반복자 객체로 옮겨지게 된다**.
  * **때문에 집합체 객체는 컬렉션의 관리에만 집중할 수 있으며, 인터페이스와 구현이 간단**해지게 된다.

### 반복자 패턴의 구조
* 반복자 패턴은 크게 다음과 같은 객체로 구성된다.
  1. Aggregate: 인터페이스이며, **클라이언트와 객체 컬렉션의 세부 구현을 분리하며, 반복자를 반환하는 메소드를 제시**한다.
  2. ConcreteAggregate: **객체 컬렉션을 포함하며, 해당 컬렉션에 대한 Iterator를 반환하는 Aggregate 인터페이스의 메소드를 재정의**한다.
  3. Iterator: 인터페이스이며, **모든 반복자가 구현해야하는 요소 접근 메소드를 제시**한다.
  4. ConcreteIterator: 컬렉션의 각 요소에 접근하는 과정에서 현재의 탐색 위치를 관리한다.
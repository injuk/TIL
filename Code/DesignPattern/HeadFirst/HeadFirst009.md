# HeadFirst
## 2022-11-19 Sat

### 반복자 패턴 - 반복을 캡슐화하기
```
> 컬렉션은 객체를 모아둔 것일 뿐이며, 어떤 자료 구조를 사용하든 결국 컬렉션은 객체의 집합으로서 기능한다.
```
* 애플리케이션을 개발하는 과정에서 ArrayList나 배열 등 사용 방법이 다른 여러 형태의 자료 구조를 사용할 수 있다.
  * 이 경우, 각 자료 구조의 사용 방법이 다르므로 코드가 필요 이상으로 장황해지기 쉽다.
  * **객체 지향 애플리케이션에서 변하기 쉬운 부분은 반드시 캡슐화를 고려해야 하며, 이 경우 변하는 부분은 컬렉션을 사용하는 방법**이 된다.
* **이러한 경우에는 디자인 패턴의 일종인 반복자 패턴을 적용할 수 있으며, Java의 경우 반복자 패턴은 Iterator 인터페이스에 의존**한다.
  * 이 때, Iterator 인터페이스는 반복 대상이 아직 남아 있는지 확인하는 hasNext()와 다음 객체를 반환하는 next() 메소드를 갖는다.
* 이러한 **Iterator 인터페이스를 적절히 활용할 경우, 배열이나 컬렉션 API 등 모든 종류의 객체 컬렉션에 반복자를 구현할 수 있다**.

### 반복자 패턴 적용하기
* 임의의 컬렉션을 사용하는 클래스에 반복자를 추가하고자하는 경우, 우선 다음과 같은 두 메소드를 갖는 Iterator 인터페이스를 구현해야 한다.
  1. hasNext: 반복 작업을 추가로 수행할 항목이 남아 있는지 boolean 형태로 반환한다.
  2. next: 실제로 컬렉션의 다음 항목을 반환한다.
* 이러한 **이러한 인터페이스를 활용하여 반복자 패턴을 적용한 구체 반복자는 자신이 사용하는 컬렉션의 종류에 맞추어 상술한 두 메소드를 반드시 구현**해야 한다.
  * 이 때, 반복자 패턴을 적용한 클래스의 경우 createIterator 등 Iterator 인터페이스를 반환할 수 있는 별도의 메소드를 두는 것이 일반적이다.
  * 물론, 상술한 내용은 java.util.Iterator를 사용하지 않는 경우에만 유효하다.
* 이렇게 작성한 **반복자를 사용할 경우, 여러 컬렉션을 관리하기 위해 필연적으로 중복될 수 밖에 없던 코드를 상당 수 줄여나갈 수 있게 된다**.
  * 이는 전적으로 **반복자를 통해 똑같은 인터페이스로 여러 종류의 컬렉션을 순회할 수 있기 때문**이다.
  * 나아가 이미 서로 다른 컬렉션을 사용하고 있던 클래스들도 단지 Iterator를 구현하는 적절한 반복자 클래스와, 이를 반환하는 메소드만 추가하게 된다.

### 반복자 패턴의 이점
```
> 반복자를 정의할 경우, 내부적으로 관리되는 모든 요소에 대한 접근 방법을 외부로 노출시키지 않은 상태에서도 모든 객체를 순회할 수 있다.
> 또한, 반복자를 구현하는 코드는 컬렉션 외부로 추출되므로 결과적으로 변하기 쉬운 반복 작업이 캡슐화되게 된다.
```
* 반복자 패턴을 적용하지 않는 경우, 다음과 같은 단점이 존재할 수 있다.
  1. **서로 다른 컬렉션을 사용하는 클래스들은 자료 구조에 대한 관리 방법을 캡슐화할 수 없고, 내부의 세부 정보인 자료 구조가 외부로 노출**된다.
  2. **이러한 컬렉션들을 다루는 클래스는 세부적인 구체 컬렉션 클래스에 강하게 결합되므로, 컬렉션마다 별도의 반복문을 작성**해야 한다.
  3. **즉, 각각의 컬렉션이 유사한 인터페이스를 가졌음에도 반드시 서로 다른 구체 클래스에 의존**하게 된다.
* 반면, 반복자 패턴을 적용할 경우 다음과 같은 이점을 얻을 수 있게 된다.
  1. **각각의 자료 구조에 대한 관리 방법은 캡슐화되며, 이를 사용하는 클래스는 추상적인 인터페이스인 Iterator에만 의존**한다.
  2. 때문에 **내부적으로 사용되는 자료 구조는 외부로 드러나지 않으며, 다형성을 활용하여 반복자를 구현하는 모든 클래스를 하나의 반복문으로 처리**할 수 있다.
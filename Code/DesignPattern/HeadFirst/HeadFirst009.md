# HeadFirst
## 2022-11-19 Sat

### 반복자 패턴 - 반복을 캡슐화하기
```
> 컬렉션은 객체를 모아둔 것일 뿐이며, 어떤 자료 구조를 사용하든 결국 컬렉션은 객체의 집합으로서 기능한다.
```
* 애플리케이션을 개발하는 과정에서 ArrayList나 배열 등 사용 방법이 다른 여러 형태의 자료 구조를 사용할 수 있다.
  * 이 경우, 각 자료 구조의 사용 방법이 다르므로 코드가 필요 이상으로 장황해지기 쉽다.
  * **객체 지향 애플리케이션에서 변하기 쉬운 부분은 반드시 캡슐화를 고려해야 하며, 이 경우 변하는 부분은 컬렉션을 사용하는 방법**이 된다.
* **이러한 경우에는 디자인 패턴의 일종인 반복자 패턴을 적용할 수 있으며, Java의 경우 반복자 패턴은 Iterator 인터페이스에 의존**한다.
  * 이 때, Iterator 인터페이스는 반복 대상이 아직 남아 있는지 확인하는 hasNext()와 다음 객체를 반환하는 next() 메소드를 갖는다.
* 이러한 **Iterator 인터페이스를 적절히 활용할 경우, 배열이나 컬렉션 API 등 모든 종류의 객체 컬렉션에 반복자를 구현할 수 있다**.

### 반복자 패턴 적용하기
* 임의의 컬렉션을 사용하는 클래스에 반복자를 추가하고자하는 경우, 우선 다음과 같은 두 메소드를 갖는 Iterator 인터페이스를 구현해야 한다.
  1. hasNext: 반복 작업을 추가로 수행할 항목이 남아 있는지 boolean 형태로 반환한다.
  2. next: 실제로 컬렉션의 다음 항목을 반환한다.
* 이러한 **이러한 인터페이스를 활용하여 반복자 패턴을 적용한 구체 반복자는 자신이 사용하는 컬렉션의 종류에 맞추어 상술한 두 메소드를 반드시 구현**해야 한다.
  * 이 때, 반복자 패턴을 적용한 클래스의 경우 createIterator 등 Iterator 인터페이스를 반환할 수 있는 별도의 메소드를 두는 것이 일반적이다.
  * 물론, 상술한 내용은 java.util.Iterator를 사용하지 않는 경우에만 유효하다.
* 이렇게 작성한 **반복자를 사용할 경우, 여러 컬렉션을 관리하기 위해 필연적으로 중복될 수 밖에 없던 코드를 상당 수 줄여나갈 수 있게 된다**.
  * 이는 전적으로 **반복자를 통해 똑같은 인터페이스로 여러 종류의 컬렉션을 순회할 수 있기 때문**이다.
  * 나아가 이미 서로 다른 컬렉션을 사용하고 있던 클래스들도 단지 Iterator를 구현하는 적절한 반복자 클래스와, 이를 반환하는 메소드만 추가하게 된다.

### 반복자 패턴의 이점
```
> 반복자를 정의할 경우, 내부적으로 관리되는 모든 요소에 대한 접근 방법을 외부로 노출시키지 않은 상태에서도 모든 객체를 순회할 수 있다.
> 또한, 반복자를 구현하는 코드는 컬렉션 외부로 추출되므로 결과적으로 변하기 쉬운 반복 작업이 캡슐화되게 된다.
```
* 반복자 패턴을 적용하지 않는 경우, 다음과 같은 단점이 존재할 수 있다.
  1. **서로 다른 컬렉션을 사용하는 클래스들은 자료 구조에 대한 관리 방법을 캡슐화할 수 없고, 내부의 세부 정보인 자료 구조가 외부로 노출**된다.
  2. **이러한 컬렉션들을 다루는 클래스는 세부적인 구체 컬렉션 클래스에 강하게 결합되므로, 컬렉션마다 별도의 반복문을 작성**해야 한다.
  3. **즉, 각각의 컬렉션이 유사한 인터페이스를 가졌음에도 반드시 서로 다른 구체 클래스에 의존**하게 된다.
* 반면, 반복자 패턴을 적용할 경우 다음과 같은 이점을 얻을 수 있게 된다.
  1. **각각의 자료 구조에 대한 관리 방법은 캡슐화되며, 이를 사용하는 클래스는 추상적인 인터페이스인 Iterator에만 의존**한다.
  2. 때문에 **내부적으로 사용되는 자료 구조는 외부로 드러나지 않으며, 다형성을 활용하여 반복자를 구현하는 모든 클래스를 하나의 반복문으로 처리**할 수 있다.

## 2022-11-20 Sun
### java.util.Iterator 주의사항
```
> Iterator 인터페이스의 remove 메소드는 필수적으로 재정의해야하는 항목은 아니다.
```
* **java.util.Iterator가 제공하는 remove 기능을 제공하고 싶지 않은 경우, `UnsupportedOperationException`을 활용**할 수 있다.
  * 이는 인터페이스에 정의된 메소드이므로 이를 정의하지 않을 수는 없지만, 대신 적절한 예외를 던져 클라이언트에게 이를 알리도록 하는 방식에 해당한다. 
  * Iterator의 문서에도 remove 메소드가 해당 예외를 던질 수 있음을 강조하며, 올바른 클라이언트 코드는 항상 해당 예외를 확인하는 식으로 동작해야 한다.
* remove 메소드의 경우 동일한 컬렉션에 대해 여러 반복자가 접근하는 경우를 대비하지 않으므로, 멀티스레드 환경의 경우 매우 신중하게 작업하는 것이 바람직하다.

### 반복자 패턴의 정의
```
> 반복자 패턴은 집합체에서 사용되는 컬렉션의 구현 방법을 외부로 노출하지 않으면서도 집합체 내의 모든 요소에 접근하는 방법을 제공한다.
> 이 경우, 컬렉션의 각 요소에 접근하는 기능을 집합체 자체가 아닌 반복자 객체가 책임지므로 집합체 인터페이스와 구현은 간단해진다.
```
* **반복자 패턴을 적용할 경우, 집합체 내에서 어떠한 방식으로 작업을 처리하는지 전혀 알지 못하는 상태에서도 모든 요소를 순회**할 수 있다.
* 또한, **디자인에 반복자를 적용할 경우 컬렉션의 각 요소에 접근하는 방법이 통일되므로 모든 집합체를 순회할 수 있는 다형적인 코드를 작성**할 수 있다.
* **반복자 패턴을 적용하면 각 요소에 대한 접근 책임이 컬렉션 객체가 아닌 반복자 객체로 옮겨지게 된다**.
  * **때문에 집합체 객체는 컬렉션의 관리에만 집중할 수 있으며, 인터페이스와 구현이 간단**해지게 된다.

### 반복자 패턴의 구조
* 반복자 패턴은 크게 다음과 같은 객체로 구성된다.
  1. Aggregate: 인터페이스이며, **클라이언트와 객체 컬렉션의 세부 구현을 분리하며, 반복자를 반환하는 메소드를 제시**한다.
  2. ConcreteAggregate: **객체 컬렉션을 포함하며, 해당 컬렉션에 대한 Iterator를 반환하는 Aggregate 인터페이스의 메소드를 재정의**한다.
  3. Iterator: 인터페이스이며, **모든 반복자가 구현해야하는 요소 접근 메소드를 제시**한다.
  4. ConcreteIterator: 컬렉션의 각 요소에 접근하는 과정에서 현재의 탐색 위치를 관리한다.

### 여덟 번째 디자인 원칙 - 단일 책임 원칙
```
> 클래스가 담당하는 모든 역할은 각각의 이유에서 코드의 변화를 유발할 수 있으며, 이는 또한 각각 서로 다른 버그의 원인으로 이어질 수 있다.
> 때문에 임의의 클래스가 수정되어야하는 이유는 하나뿐이어야 하는 것이 바람직하며, 이를 위해 클래스는 하나의 역할만을 담당해야 한다.
```
* 애플리케이션을 개발하는 과정에서 임의의 클래스가 여러 기능을 구현할 수 있으며, 이에 따라 메소드 수 역시 늘어날 수 있다.
* 그러나 이렇듯 **많은 기능, 즉 많은 책임을 갖는 클래스는 다음과 같은 이유에서 나쁘다**고 볼 수 있다.
  1. 클래스가 담당하는 기능만큼 변경의 이유가 생길 수 있다.
  2. 수정은 모든 버그의 시작으로, 코드를 변경한다는 것은 그 자체로 새로운 버그의 발생 가능성이 된다.
  3. 즉, **많은 기능을 담당하는 클래스는 그만큼 여러가지 이유에서 수정이 필요할 수 있으며 이는 모두 버그의 원인이 될 수 있다**.
* **단일 책임 원칙은 이러한 변경과 관련된 디자인 원칙이며, 하나의 역할을 하나의 클래스에서만 담당할 것을 강조**한다.
  * 이는 일견 **쉽게 준수할 수 있을 것으로 보이나, 뇌는 너무나 훌륭한 나머지 둘 이상의 역할을 하나로 묶어 인식하는 경우가 많아 실제로는 준수하기 어렵다**.
* 단일 책임 원칙을 준수하기 위해서는 항상 디자인을 여러 번 살펴보고, 애플리케이션이 성숙해짐에 따라 클래스의 역할이 둘 이상이 되지는 않았는지 확인해야 한다.

### 응집도란?
```
> 응집도란, 하나의 클래스 또는 모듈이 특정한 목적이나 역할을 얼마나 일관되게 지원하는지를 나타내는 척도에 해당한다.
```
* **임의의 모듈이나 클래스의 응집도가 높다는 것은 서로 연관된 기능이 묶여 있다는 것이므로, 응집도가 낮다면 서로 관계 없는 기능들이 묶이게 된다**.
* **응집도는 단일 책임 원칙과 밀접한 연관이 있으며, 해당 원칙을 잘 준수하는 클래스는 응집도가 높아 관리하기가 쉽다**.

### 반복자 패턴의 주의사항
* 반복자 패턴은 내부 반복자와 외부 반복자로 나누어 생각할 수 있으며, 각각 다음과 같은 특징을 갖는다.
  1. 외부 반복자: 클라이언트가 next 메소드를 호출하여 반복 작업을 제어한다.
  2. 내부 반복자: 클라이언트가 각 원소에 대해 어떤 작업을 처리할지 반복자에게 알려주며, 때문에 외부 반복자에 비해 상대적으로 유연성이 떨어진다.
* **반복자는 일반적으로 특별한 순서를 정하지 않으며, 접근 순서는 사용되는 컬렉션의 특성과 관계**가 있다.
  * 때문에 **컬렉션 문서에 별도로 언급이 되어 있지 않은 경우, 반복자에서는 순서를 가정하지 않아야 한다**.
* 반복자는 Iterator를 매개변수로 받는 메소드를 정의하는 것으로 다형적으로 사용할 수 있으며, 이 경우 구체적인 컬렉션의 구현 방식을 신경쓰지 않을 수 있다.
* Java를 사용하는 경우 일반적인 컬렉션은 모두 java.util.Iterator 인터페이스를 사용할 수 있다.
  * 반면, 반복자 인터페이스에 새로운 기능을 추가하고자 하는 경우에는 Iterator 인터페이스를 확장할 수 있다.
* Enumeration 인터페이스는 Iterator와 유사한 용도로 사용되지만, 최근에는 Iterator를 지원하는 클래스가 더 많아 Enumeration은 잘 사용되지 않는다.
  * 이 때, **두 인터페이스 간의 변환 또는 혼용이 필요한 경우에는 어댑터 패턴을 적용**할 수 있다.

## 2022-11-21 Mon
### Iterable 인터페이스 
* **모든 컬렉션은 Iterable 인터페이스를 구현하며, 해당 인터페이스는 Iterator 인터페이스를 구현하는 반복자를 반환하는 iterator() 메소드를 제공**한다.
  * **ArrayList 등 모든 컬렉션 클래스는 Iterable을 확장하는 Collection 인터페이스를 구현하므로 Iterable**이다.
* **해당 인터페이스는 컬렉션에 있는 각각의 항목을 대상으로 반복 작업을 수행하기 위한 forEach 메소드 역시 포함**한다.
  * 또한, Iterable 인터페이스는 컬렉션을 대상으로 하는 반복 작업에서 더 발전된 기능을 제공하는 spliterator 메소드도 함께 제공한다.
* 이 밖에도 Java의 경우 Iterable의 forEach 메소드를 통해 향상된 for문과 같은 문법적인 기능을 함께 제공한다.
  * 반면, **forEach 메소드는 람다식과 함께 `names.forEach(name -> System.out.println(name));`과 같은 형태로 직접 호출할 수도 있다**.

### 향상된 for문
* 임의의 ArrayList를 Iterator로 순회하는 경우, 다음과 같이 코드를 작성하게 된다.
  * 이렇듯 반복자는 hasNext와 next 메소드를 필수적으로 사용하게 된다.
```java
public class Main {
  public static void main(String[] args) {
    List<String> names = new ArrayList();
    Iterator iterator = names.iterator();
    while(iterator.hasNext())
        System.out.println(iterator.next());
  }
}
```
* 그러나 ArrayList 역시 Iterable을 확장하는 Collection API이므로, Iterable이기에 다음과 같이 향상된 for문을 적용할 수 있다.
  * 이 경우, hasNext 또는 next 메소드를 사용할 필요가 없으므로 코드를 간단하게 작성할 수 있다.
```java
public class Main {
  public static void main(String[] args) {
    List<String> names = new ArrayList();
    for(String name: names)
      System.out.println(iterator.next());
  }
}
```

### HashMap과 반복자
* HashMap 역시 Iterator를 지원하는 Java 컬렉션이지만, List 인터페이스를 상속 받는 자료 구조들과는 방식이 다르다.
  * 이는 HashMap이 List와 달리 키-값 형태로 데이터를 저장하는 자료 구조이기 때문이다.
* **HashMap의 경우, 값을 대상으로 하는 반복자를 `items.values().iterator();` 형태로 활용**할 수 있다.
* 이렇듯 반복자를 사용할 경우, 반복자는 반복 작업을 수행하는 객체 그룹 종류만을 대상으로 하므로 클라이언트가 컬렉션의 세부 사항과 분리될 수 있다.

### 반복자와 컬렉션 프레임워크
* **Java는 여러 객체를 저장하고 활용하는 다양한 컬렉션 클래스를 제공하지만, 대부분 Iterator 객체를 반환받을 수 있는 방법을 제공**한다.
  * 이는 Collection 인터페이스가 Iterable 인터페이스를 구현하기 때문이다.
* Collection 프레임워크는 그저 클래스와 인터페이스를 모아둔 것에 불과하며, 각 인터페이스에는 객체로 구성된 그룹을 조작할 수 있는 유용한 메소드가 포함된다.
* **컬렉션과 반복자를 활용할 경우, 모든 컬렉션 객체로부터 자신을 대상으로 하는 구체 반복자를 반환할 수 있다는 장점을 활용**할 수 있다.
  * **예를 들어 iterator 메소드를 호출하는 것으로 구체 반복자 인스턴스가 반환**된다.
  * **이 과정에서 내부적으로 사용되는 구체 클래스에 신경쓰지 않을 수 있으며, 클라이언트는 단지 추상적인 Iterator 인터페이스에만 의존**할 수 있다. 

## 2022-11-22 Tue
### 컴포지트 패턴의 정의
```
> 컴포지트 패턴은 객체를 트리 형태의 객체 구조로 구성하는 것으로 부분과 전체 계층 구조를 표현한다.
> 컴포지트 패턴을 사용할 경우, 클라이언트에서는 개별 객체와 여러 객체로 구성된 복합 객체를 같은 방법으로 다룰 수 있게 된다.
> 즉, 이러한 복합 구조를 사용하면서도 복합 객체와 개별 객체를 구분할 필요가 없어지게 되어 동일한 작업을 적용할 수 있다.
```
* **리스트 또는 리스트에 포함되는 서브리스트 등의 요구사항을 표현하기 위해서는 우선 트리 구조를 고려**할 수 있다.
  * 이를 통해 하나의 리스트를 대상으로만 반복 작업을 수행하거나, 전체 리스트 항목들을 대상으로 반복 작업을 수행하는 등 유연성을 가질 수 있게 된다.
* 이를 응용한 것이 컴포지트 패턴에 해당하며, 이를 통해 부분 전체 계층 구조를 생성할 수 있다.
  * 이 때, **부분 전체 계층 구조란 부분들이 계층적인 구조를 이루지만 모든 부분을 묶어 전체로 다룰 수 있는 구조를 의미**한다.
  * **리스트와 서브리스트로 구성되는 구조에서는 해당 패턴을 도입하여 개별 객체는 물론 복합 객체에도 같은 방식으로 작업을 적용할 수 있다**.
* 이렇듯 **리스트, 서브리스트, 서브서브리스트로 구성되는 트리 구조가 존재하는 경우 각각의 리스트는 모두 복합 객체로서 취급**될 수 있다.
  * 즉, 결국에는 개별 객체 역시 단지 서브리스트를 포함하지 않는 리스트로 취급될 수 있다.
* **컴포지트 패턴을 적용한 디자인의 경우 간단한 코드만으로도 트리의 부분 또는 전체를 출력하는 등의 동일한 작업을 쉽게, 반복적으로 적용할 수 있다**.
  * 컴포지트 패턴을 사용할 경우, 단일 노드로 구성된 간단한 트리는 물론 매우 복잡한 트리도 쉽게 구성이 가능하다.
  * 또한, **트리가 아무리 복잡해지더라도 전체 구조를 하나로 묶어서 작업을 적용하거나 부분을 대상으로 작업을 적용할 수 있다**.

### 컴포지트 패턴의 구조
* 컴포지트 패턴의 클래스 다이어그램은 크게 다음과 같은 요소로 구성된다.
  1. Client: Component의 인터페이스를 사용하여 복합 객체 내의 객체들을 조작한다.
  2. Component: **복합 객체 내에 포함되는 복합 노드 및 리프 노드의 메소드를 포함하여, 모든 객체의 인터페이스를 정의**한다.
  3. Composite: 자식이 있는 구성 요소의 행동을 정의하며, 자식 구성 요소를 저장하는 역할을 수행한다.
  4. Leaf: 자식이 없는 노드에 해당한다.
* 이 때, Composite는 Leaf 노드와 관련된 기능 역시 구현하되 복합 객체에게 해당 기능이 별 의미가 없는 경우에는 예외를 던지는 식으로 구현한다.
* 또한, Leaf는 자식 구성 요소를 관리하기 위한 메소드를 당장은 사용할 일이 없더라도 상속받아야 한다.
* 이렇듯 **컴포지트 패턴은 복합 객체(composite)로서 구성 요소(component)들을 포함**한다.
  * 또한, **구성 요소는 다시 복합 객체(composite)와 단일 객체(leaf)로 나뉘어지는 재귀적 구조**를 갖게 된다.
  * 결국 **컴포지트 패턴을 적용한 디자인에서 모든 복합 객체는 자식을 포함하며, 이 때 자식은 또 다른 복합 객체이거나 리프 노드일 수 있다**.
  * 데이터를 이러한 방식으로 조직화할 경우, 복합 객체를 따라 가지가 확장되어 나가다가 끝에는 리프 노드로 완결되는 트리 구조가 완성된다.

### 컴포지트 패턴과 반복자 패턴의 관계
* **반복자 패턴과 컴포지트 패턴이 특별히 함께 사용되어야만 하는 이유가 있는 것은 아니므로, 두 패턴 사이의 자연스러운 전환이 가능한 것은 아니다**.
  * 그러나 때로는 두 패턴을 적절히 조합하는 것으로 주어진 문제를 쉽게 해결할 수 있는 경우가 발생할 수 있다.
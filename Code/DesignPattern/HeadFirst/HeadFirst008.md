# HeadFirst
## 2022-11-10 Thu

### 알고리즘의 캡슐화
* 다른 디자인 패턴이 객체 생성이나 메소드 호출, 또는 복잡한 인터페이스를 캡슐화하듯 알고리즘을 캡슐화할 수도 있다.
  * 예를 들어, **서브클래스에서 필요할 때마다 알고리즘을 가져다 사용할 수 있도록 캡슐화**할 수 있다.

### 템플릿 메소드 패턴의 필요성
* 예를 들어 다음과 같은 두 클래스가 존재한다고 가정한다.
```java
class TempA {
    public void doSomething() {
        preProcess();
        doTaskA();
        postProcess();
        doTaskB();
    }
    // 아래 메소드들은 본문이 구현되어 있다고 가정한다.
    public void preProcess() {}
    public void doTaskA() {}
    public void postProcess() {}
    public void doTaskB() {}
}

class TempB {
  public void doSomething() {
    preProcess();
    doTaskC();
    postProcess();
    doTaskD();
  }
  // 아래 메소드들은 본문이 구현되어 있다고 가정한다.
  public void preProcess() {}
  public void doTaskC() {}
  public void postProcess() {}
  public void doTaskD() {}
}
```
* 이 경우, 전체적으로 유사한 동작을 수행하지만 세세한 부분이 다르므로 공통되는 코드를 추상화하여 다음과 같이 수정할 수 있다.
```java
class TempBase {
    abstract void doSomething();
    // 아래 메소드들은 본문이 구현되어 있다고 가정한다.
    public void preProcess() {}
    public void postProcess() {}
}
class TempA extends TempBase {
    @Override public void doSomething() {
        preProcess();
        doTaskA();
        postProcess();
        doTaskB();
    }
    // 아래 메소드들은 본문이 구현되어 있다고 가정한다.
    public void doTaskA() {}
    public void doTaskB() {}
}

class TempB extends TempBase {
  @Override public void doSomething() {
    preProcess();
    doTaskC();
    postProcess();
    doTaskD();
  }
  // 아래 메소드들은 본문이 구현되어 있다고 가정한다.
  public void doTaskC() {}
  public void doTaskD() {}
}
```
* 그러나 상술한 방식의 코드는 다음과 같은 아쉬운 점이 존재한다.
  1. 여전히 `doSomething()` 메소드가 중복된다.
  2. `doSomething()` 메소드가 호출하는 일련의 흐름이 사실상 유사하다.

### 템플릿 메소드 패턴 적용하기
* 상술한 코드에서, doTaskA - doTaskC와 doTaskB - doTaskD가 크게 다르지 않은 경우에는 다음과 같이 인터페이스를 추상 클래스로 바꿀 수 있다.
```java
abstract class TempBase {
    // 전체적인 작업의 흐름이 같으므로, 서브클래스가 함부로 오버라이드할 수 없도록 final로 정의한다.
    final void doSomething() {
        preProcess();
        doFirstTask();
        postProcess();
        doLastTask();
    }
    
    // 서브클래스에서 변경될 수 있는 메소드이므로 추상 메소드로 정의한다.
    abstract void doFirstTask();
    abstract void doLastTask();

    // 서브클래스에서 변경이 없는 메소드는 구체 메소드로 정의하며, 아래 메소드들은 본문이 구현되어 있다고 가정한다.
    public void preProcess(){}
    public void postProcess(){}
} 
```
* 이제 **TempA와 TempB 클래스는 추상 클래스인 TempBase를 확장하며, doFirstTask와 doLastTask를 적절하게 오버라이드**할 수 있다.
  * 이러한 수정은 **여러 클래스의 전체적인 행동 양식은 같지만, 사소한 차이가 있는 경우에 일련의 과정을 일반화한 것에 해당**한다.
  * 이러한 방법은 **일련의 과정을 구성하는 메소드 중 서브클래스마다 세부적인 동작 양식이 달라지는 경우, 해당 메소드를 구현하여 유연성**을 둘 수 있다.
* **이러한 방식을 선택할 경우, 전체적인 작업 과정과 일부 메소드의 구현은 서브클래스가 추상 부모 클래스에 의존**하게 된다.
  * 반면, 일부 메소드는 서브클래스가 부모 클래스에 의존하는 대신 직접 구현하여 처리하게 된다.
* 이러한 디자인 패턴을 템플릿 메소드 패턴이라고 하며, 각 메소드는 다음과 같은 역할을 수행한다.
  1. **doSomething 메소드는 템플릿 메소드로서, 어떠한 알고리즘의 전체적인 흐름을 의미하는 틀 역할을 수행**한다.
  2. **템플릿 메소드 내에서 알고리즘의 각 단계는 추상 클래스에 정의된 여러 메소드로 표현**된다.
  3. **템플릿 메소드를 구성하는 일부 메소드는 추상 클래스에서 구현되는 반면, 필요한 경우 abstract 키워드를 명시하여 서브클래스에서 처리**될 수도 있다.
* 이렇듯 **템플릿 메소드는 알고리즘의 각 단계를 정의하며, 서브클래스에서 알고리즘의 일부를 직접 구현할 수 있도록 유도**한다.

## 2022-11-11 Fri
### 템플릿 메소드 패턴이란?
```
> 템플릿 메소드는 일련의 알고리즘을 관리한다.
> 또한, 알고리즘을 수행하는 과정에서 상황에 따라 임의의 단계는 서브클래스에서 처리하도록 할 수도 있다.
```
* **템플릿 메소드에 정의된 알고리즘은 일반적으로 다른 누구도 변경할 수 없으며, 단지 일부 단계 또는 전체 단계를 서브클래스가 변경**할 수 있다.
* 템플릿 메소드를 사용할 경우, 다음과 같은 장점을 누릴 수 있다.
  1. 추상 부모 클래스가 전체적인 알고리즘을 독점하며, 이를 관리한다.
  2. 추상 부모 클래스 덕분에 서브클래스에서는 코드를 재사용할 수 있다.
  3. 전체적인 알고리즘이 추상 부모 클래스 한 곳에 집중되므로, 일반적으로 수정 범위가 적고 일부 구현만을 서브클래스에 의존하게 된다.

### 템플릿 메소드 패턴의 정의
```
> 템플릿 메소드 패턴은 알고리즘의 템플릿을 정의하므로 전체적인 알고리즘의 구조를 유지하며, 일부 단계를 서브클래스에서 재정의할 수 있도록 한다.
```
* 간단히 말해, 템플릿 메소드는 어디까지나 알고리즘의 템플릿을 제공한다.
  * 이러한 **템플릿 역시 메소드에 지나지 않으며, 일련의 단계로 알고리즘을 정의**한다.
  * **템플릿 메소드에서 표현되는 여러 단계 중 하나 이상의 단계는 추상 메소드로 정의되며, 이러한 추상 메소드는 서브클래스에서 구현**될 수 있다.
* **템플릿 메소드 패턴을 적절히 활용할 경우, 서브클래스가 구현의 일부분을 처리하면서도 전체적인 알고리즘의 구조는 변경하지 않을 수 있다**.
* **템플릿 메소드는 추상 부모 클래스에 포함되며, 알고리즘을 구성하는 각 단계의 세부적인 구현으로부터 분리**된다.
  * 또한, 추상 부모 클래스에 정의되는 추상 메소드들은 알고리즘의 각 단계를 의미하며 템플릿 메소드에서 호출된다.
  * 이러한 추상 메소드들은 구체 클래스에서 정의하며, 템플릿 메소드는 이렇게 구현된 메소드를 호출하여 일련의 작업을 처리하게 된다.
* **추상 부모 클래스를 확장하는 서브클래스는 여럿이 존재할 수 있지만, 반드시 템플릿 메소드가 제시하는 모든 단계를 제공할 수 있도록 정의**되어야 한다.

### 템플릿 메소드의 구성
* 템플릿 메소드를 포함하는 클래스는 추상 클래스로 선언되므로, 실제 연산을 구현하는 서브클래스를 별도로 정의해야 한다.
* **템플릿 메소드는 서브클래스에서 알고리즘의 각 단계를 수정할 수 없도록 final로 정의**된다.
* **템플릿 메소드는 각각의 단계를 순차적인 메소드 호출로 정의하며, 각 메소드는 알고리즘을 구성하는 여러 단계를 의미**한다.
  * 또한, 이러한 단계 중 일부는 추상 메소드로 정의하여 반드시 서브클래스에서 확장하도록 강제할 수 있다.
* 반면, 추상 클래스 내에는 구체 메소드로 정의되는 다음과 같은 단계 역시 존재할 수 있다. 
  1. final 메소드: 알고리즘을 구성하는 단계 중 서브클래스에서 재정의할 필요가 없는 경우, 추상 부모 클래스에서 메소드를 구현한 후 final 키워드를 명시한다.
  2. hook 메소드: **알고리즘의 여러 단계 중 선택적으로 수행될 수 있는 단계는 기본적으로 아무 것도 수행하지 않는 구체 메소드로 표현**할 수 있다.
* 이 때, **final 구체 메소드는 재정의할 수 없는 반면 hook 메소드는 서브클래스에서 선택적으로 재정의할 수 있다는 점에서 차이**가 있다.

### hook 메소드란?
```
> hook 메소드는 추상 부모 클래스에서 정의되지만, 기본적인 내용만을 구현하거나 아무 내용도 없는 메소드를 의미한다.
> 즉, hook 메소드는 서브클래스에서 필요할 때에만 재정의할 수 있는 메소드이다.
```
* hook 메소드를 적절히 활용하는 경우, 서브클래스가 다양한 위치로부터 알고리즘에 끼어들 수 있도록 유연성을 둘 수 있다.
  * 물론, **서브클래스는 hook 메소드를 재정의하지 않고 무시한 채 넘어가도 무방하며 이 경우에는 추상 부모 클래스에서 기본으로 제공하는 코드가 실행**된다.

## 2022-11-17 Thu
### hook 메소드의 필요성
* 애플리케이션을 제작하는 과정에서, hook 메소드를 사용할 경우 상황에 따른 알고리즘의 진행 방식을 쉽게 변경할 수 있다.
  * 이로 인해 **템플릿 메소드 패턴을 사용하는 과정에서는 후크가 필요한 경우가 반드시 발생하기 마련**이다.
* 추상 메소드와 hook 메소드 중 어떤 것을 도입할지 고민하는 경우, 다음과 같은 지침을 따를 수 있다.
  1. **서브클래스가 알고리즘의 특정 단계를 반드시 제공해야 하는 경우, 추상 메소드를 사용**한다.
  2. **알고리즘의 특정한 단계가 선택적으로 적용되어도 무방한 경우, 단지 필요에 따라서만 구현할 수 있도록 hook 메소드를 사용**한다.
* 상술했듯, **hook 메소드는 알고리즘에서 필수적이지는 않은 단게를 서브클래스에서 구현하고 싶은 경우에 사용**할 수 있다.
  * 즉, 앞으로 발생할 사건이나 이미 막 발생한 사건에 서브클래스가 반응할 수 있도록 기회를 제공하는 용도로 사용될 수 있다.
  * 이렇듯 **hook 메소드는 서브클래스가 추상 클래스에서 진행되는 작업을 처리할지 말지 결정하도록 만드는 용도로 사용되는 것이 일반적**이다.
* 반면, **서브클래스에서는 추상 부모 클래스에 정의된 알고리즘의 임의의 단계를 의미하는 모든 추상 메소드를 반드시 구현**해야 한다.
  * 다시 말해 템플릿 메소드에 있는 알고리즘 단계 중 정의되지 않은 부분을 모두 구현해야 한다.
* **템플릿 메소드 패턴을 적용하는 추상 부모 클래스의 경우, 알고리즘의 각 단게를 의미하는 추상 메소드가 너무 많아지면 오히려 좋지 않을 수 있다**.
  * 때문에 **템플릿 메소드를 작성하는 과정에서는 알고리즘의 단계를 너무 잘게 쪼개거나, 너무 크게 나누어 유연성을 떨어트리지 않도록 주의**해야 한다.
  * 또한, 템플릿 메소드를 구성하는 알고리즘의 모든 단계는 항상 필수는 아니므로 이러한 부분을 hook 메소드로 구현하여 서브클래스의 부담을 줄일 수 있다.

### 일곱 번째 디자인 원칙 - 할리우드 원칙
```
> 저희가 연락드리기 전까지는 연락하지 마세요!
```
* **시스템을 구성하는 저수준 구성 요소와 고수준 구성 요소 간의 의존성이 복잡하게 꼬여 있는 경우, 시스템 디자인을 이해하는 것은 쉽지 않다**.
* 반면, 할리우드 원칙은 다음과 같은 방식으로 이러한 상황을 해결한다.
  1. 저수준 구성 요소는 시스템에 접근할 수 있다.
  2. 그러나 **저수준 구성 요소가 언제 어떠한 방식으로 사용될지는 고수준 구성 요소가 결정**한다.
* 즉, **할리우드 원칙을 준수하는 시스템에서의 고수준 구성 요소는 저수준 구성 요소가 필요한 시점과 그 용도를 결정**한다.
  * 이 때, **저수준 구성 요소는 작업에 참여할 수는 있으나 절대로 먼저 고수준 구성 요소를 직접 호출할 수는 없다**. 
* 상술한 **할리우드 원칙을 준수할 경우, 구성 요소 간의 의존성이 복잡하게 얽히는 의존성 부패를 사전에 방지**할 수 있다.
# HeadFirst
## 2022-10-25 Tue

### new 연산자 살펴보기
```
> 특정한 구현을 바탕으로 코드를 작성하지 않는 것이 바람직하지만, new 연산자를 사용하는 것은 곧 임의의 구현에 의존하는 것과 같다.
> 객체의 인스턴스를 생성하는 작업이 항상 new 연산자와 함께 공개되어야 하는 것은 아니며, 이는 오히려 단단한 결합에 의한 문제를 발생시킬 수 있다. 
```
* **new 연산자를 사용하면 구체 클래스의 인스턴스가 생성되며, 이는 당연하게도 인터페이스가 아닌 구현에 의존하는 코드**를 만들게 된다.
  * 앞서 다루었듯 **구체 클래스에 의존하는 코드는 코드의 수정 가능성이 높고, 유연성을 떨어트리기 쉽다**.
* 즉, `Animal animal = new Bird();`라는 코드는 다음과 같은 의미를 갖는다.
  1. 변수 타입을 Animal 인터페이스로 선언하여 다형성으로 인한 코드의 유현성을 꾀한다.
  2. **그럼에도 `new Bird();`라는 코드에 의해 구체 클래스인 Bird에 의존**하게 된다.
* 나아가 Animal 인터페이스를 구현하는 클래스가 여럿인 경우, 객체 생성을 위해 if - else if - else 분기를 사용하는 코드를 작성할 수도 있다.
  * 이 때 인스턴스 타입은 if 분기의 조건에 따라 결정되므로, 코드에 수정이 필요한 경우 항상 코드를 다시 확인해야하는 아쉬움이 있다.
  * 때문에 **이러한 유형의 코드는 수정 사항을 반영하기 어렵고, 더불어 휴먼 에러의 발생 가능성 또한 높다**.

### 다형성 돌아보기
```
> 인터페이스에 맞춘 코딩은 애플리케이션에서 발생할 여러 변경 사항에 대응할 수 있게 한다.
```
* new 연산자는 Java의 기초 중의 기초이며, 애플리케이션 개발에서 단 한 번도 사용하지 않는 것은 불가능하다.
  * **이는 즉 new 연산자 자체에는 문제가 없음을 시사하며, 실제로 주의하여 다루어야할 문제는 애플리케이션에 가해질 변화에 해당**한다.
* **인터페이스를 기반으로 작성된 코드는 어떠한 클래스든 인터페이스만 구현하면 사용이 가능하므로, 여러 변화에 대응이 가능한 유연성을 부여**한다.
  * 또한, 이러한 유용한 특징을 다형성이라고 지칭할 수 있다. 
* 반면, **구체 클래스를 많이 사용할수록 새로운 구체 클래스가 추가될 때마다 반드시 기존 코드를 수정해야 하므로 없었던 문제가 발생**시키기 쉽다.
  * **이는 즉 변경에 닫혀 있는 코드를 의미하므로, 기능을 확장하기 위해서는 변경을 캡슐화하여 확장에 열린 구조를 만들 수 있어야 한다**.

### 팩토리 패턴이 필요한 코드
* 예를 들어, 임의의 타입 정보에 따라 다른 인스턴스를 생성해야할 수 있다.
  * 이 경우 **각 인스턴스는 동일한 인터페이스를 구현하지만, 수 많은 if - else if - else 분기로 new 연산자로 각각 다른 인스턴스를 생성**한다.
* 또한, **이렇듯 if - else if - else 분기로 객체를 생성하는 코드는 변경에 닫혀 있지 않을 가능성이 높다**.
  * 때문에 객체의 종류가 추가되거나 줄어드는 등 변경이 발생한 경우, 반드시 해당 소스 코드를 수정해야만 한다.
* **이러한 코드에서는 인스턴스를 생성할 구체 클래스를 선택하는 부분이 변경 가능성이 높으며, 후속 코드는 다형성을 활용하므로 변경 가능성이 높지 않다**.
* 즉, **이 경우에 객체 생성과 관련된 코드는 변경 가능성이 높아 캡슐화되어야 하므로 별도의 객체에 책임을 할당하는 것이 바람직**하다. 
  * 이 경우, 해당 객체는 오로지 객체를 만드는 일에만 집중하게 되어 기존 코드는 해당 객체의 클라이언트 코드가 된다.
  * 이 때, **이렇듯 객체 생성만을 전담하여 처리하는 객체를 팩토리 객체라고 지칭**한다.
  * 이로 인해 기존 코드에서는 더 이상 객체 생성에 대해 고민할 필요가 없으며, 팩토리로부터 인스턴스를 반환받아 다형성을 활용하여 유연하게 동작할 수 있다.
  * 상술한 예시에서, if - else if - else 분기를 갖던 기존 코드를 새로 정의한 팩토리 객체로 그대로 옮기기만 하면 가장 간단한 팩토리를 정의할 수 있다.
* **객체 생성 코드를 캡슐화한 팩토리 패턴은 일견 코드의 위치만 다른 객체로 넘긴 것처럼 보이지만, 여러 클라이언트가 객체를 생성하는 경우 큰 이점**이 있다.
  * 예를 들어, 해당 객체를 생성하는 클라이언트 코드가 매우 많은 경우 변경 사항을 반영하기 위해 여기 저기에 퍼진 객체 생성 코드를 수정할 필요가 없다.
* 이렇듯 **간단한 팩토리 객체를 도입하는 경우, 기존 클라이언트 코드는 생성자로 팩토리 객체를 외부로부터 전달 받아 자신의 멤버 변수로 저장**할 수 있다.
  * 이 때, 기존의 if - else if - else 분기를 사용하던 코드 대신 팩토리로부터 객체를 생성하여 다형성을 활용하도록 코드를 수정할 수 있다.
  * 이 경우, 코드는 더 이상 new 연산자를 사용하지 않으므로 구체 클래스의 인스턴스에 의존하지 않게 된다.

### 팩토리 패턴과 정적 팩토리 메소드
* 정적 팩토리 메소드는 간단한 팩토리를 static 메소드로 정의하는 기법이며, 이는 객체 생성을 위해 굳이 new 연산자를 사용하지 않아도 되도록 하는 이점이 있다.
  * 그러나 **정적 팩토리 메소드는 static 메소드이므로, 서브클래스를 정의할 때 객체 생성 메소드의 행동을 변경할 수 없다는 단점이 존재**한다.

## 2022-10-26 Wed
### 간단한 팩토리
```
> 간단한 팩토리라는 용어는 디자인 패턴이라기보다는 프로그래밍에서 자주 사용되는 관용구에 가깝다.
```
* 간단한 팩토리에서 생성하는 인스턴스가 다음의 조건을 만족할 때, 간단한 팩토리로서 클라이언트에게 인스턴스를 반환할 수 있다.
  1. 팩토리에서 생성하는 모든 인스턴스는 같은 인터페이스를 구현한다.
  2. 팩토리에서 생성하는 인스턴스는 팩토리에 정의된 구상 클래스로부터 생성된다.
* 즉, **간단한 팩토리는 동일한 인터페이스를 구현하는 구상 클래스에 대한 정보를 애플리케이션에서 유일하게 직접 참조**한다.

### 다양한 팩토리 정의하기
* 애플리케이션 요구사항에 따라 팩토리가 다양한 종류로 정의되지만, 클라이언트 코드가 팩토리로부터 얻은 인스턴스를 사용하는 방식은 같을 수 있다.
  * 이 경우, **중복으로 인한 휴먼 에러를 방지하기 위해 인스턴스 생성부터 클라이언트 코드에서 작업하는 내용까지 모두 하나의 프레임워크로 만들 필요**가 있다.
  * 또한, **간단한 팩토리를 제거하고 새로운 팩토리를 정의하는 이 과정에서 유연성을 잃지 않기 위한 새로운 방법이 필요**하다.
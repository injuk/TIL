# HeadFirst
## 2022-10-25 Tue

### new 연산자 살펴보기
```
> 특정한 구현을 바탕으로 코드를 작성하지 않는 것이 바람직하지만, new 연산자를 사용하는 것은 곧 임의의 구현에 의존하는 것과 같다.
> 객체의 인스턴스를 생성하는 작업이 항상 new 연산자와 함께 공개되어야 하는 것은 아니며, 이는 오히려 단단한 결합에 의한 문제를 발생시킬 수 있다. 
```
* **new 연산자를 사용하면 구체 클래스의 인스턴스가 생성되며, 이는 당연하게도 인터페이스가 아닌 구현에 의존하는 코드**를 만들게 된다.
  * 앞서 다루었듯 **구체 클래스에 의존하는 코드는 코드의 수정 가능성이 높고, 유연성을 떨어트리기 쉽다**.
* 즉, `Animal animal = new Bird();`라는 코드는 다음과 같은 의미를 갖는다.
  1. 변수 타입을 Animal 인터페이스로 선언하여 다형성으로 인한 코드의 유현성을 꾀한다.
  2. **그럼에도 `new Bird();`라는 코드에 의해 구체 클래스인 Bird에 의존**하게 된다.
* 나아가 Animal 인터페이스를 구현하는 클래스가 여럿인 경우, 객체 생성을 위해 if - else if - else 분기를 사용하는 코드를 작성할 수도 있다.
  * 이 때 인스턴스 타입은 if 분기의 조건에 따라 결정되므로, 코드에 수정이 필요한 경우 항상 코드를 다시 확인해야하는 아쉬움이 있다.
  * 때문에 **이러한 유형의 코드는 수정 사항을 반영하기 어렵고, 더불어 휴먼 에러의 발생 가능성 또한 높다**.

### 다형성 돌아보기
```
> 인터페이스에 맞춘 코딩은 애플리케이션에서 발생할 여러 변경 사항에 대응할 수 있게 한다.
```
* new 연산자는 Java의 기초 중의 기초이며, 애플리케이션 개발에서 단 한 번도 사용하지 않는 것은 불가능하다.
  * **이는 즉 new 연산자 자체에는 문제가 없음을 시사하며, 실제로 주의하여 다루어야할 문제는 애플리케이션에 가해질 변화에 해당**한다.
* **인터페이스를 기반으로 작성된 코드는 어떠한 클래스든 인터페이스만 구현하면 사용이 가능하므로, 여러 변화에 대응이 가능한 유연성을 부여**한다.
  * 또한, 이러한 유용한 특징을 다형성이라고 지칭할 수 있다. 
* 반면, **구체 클래스를 많이 사용할수록 새로운 구체 클래스가 추가될 때마다 반드시 기존 코드를 수정해야 하므로 없었던 문제가 발생**시키기 쉽다.
  * **이는 즉 변경에 닫혀 있는 코드를 의미하므로, 기능을 확장하기 위해서는 변경을 캡슐화하여 확장에 열린 구조를 만들 수 있어야 한다**.

### 팩토리 패턴이 필요한 코드
* 예를 들어, 임의의 타입 정보에 따라 다른 인스턴스를 생성해야할 수 있다.
  * 이 경우 **각 인스턴스는 동일한 인터페이스를 구현하지만, 수 많은 if - else if - else 분기로 new 연산자로 각각 다른 인스턴스를 생성**한다.
* 또한, **이렇듯 if - else if - else 분기로 객체를 생성하는 코드는 변경에 닫혀 있지 않을 가능성이 높다**.
  * 때문에 객체의 종류가 추가되거나 줄어드는 등 변경이 발생한 경우, 반드시 해당 소스 코드를 수정해야만 한다.
* **이러한 코드에서는 인스턴스를 생성할 구체 클래스를 선택하는 부분이 변경 가능성이 높으며, 후속 코드는 다형성을 활용하므로 변경 가능성이 높지 않다**.
* 즉, **이 경우에 객체 생성과 관련된 코드는 변경 가능성이 높아 캡슐화되어야 하므로 별도의 객체에 책임을 할당하는 것이 바람직**하다. 
  * 이 경우, 해당 객체는 오로지 객체를 만드는 일에만 집중하게 되어 기존 코드는 해당 객체의 클라이언트 코드가 된다.
  * 이 때, **이렇듯 객체 생성만을 전담하여 처리하는 객체를 팩토리 객체라고 지칭**한다.
  * 이로 인해 기존 코드에서는 더 이상 객체 생성에 대해 고민할 필요가 없으며, 팩토리로부터 인스턴스를 반환받아 다형성을 활용하여 유연하게 동작할 수 있다.
  * 상술한 예시에서, if - else if - else 분기를 갖던 기존 코드를 새로 정의한 팩토리 객체로 그대로 옮기기만 하면 가장 간단한 팩토리를 정의할 수 있다.
* **객체 생성 코드를 캡슐화한 팩토리 패턴은 일견 코드의 위치만 다른 객체로 넘긴 것처럼 보이지만, 여러 클라이언트가 객체를 생성하는 경우 큰 이점**이 있다.
  * 예를 들어, 해당 객체를 생성하는 클라이언트 코드가 매우 많은 경우 변경 사항을 반영하기 위해 여기 저기에 퍼진 객체 생성 코드를 수정할 필요가 없다.
* 이렇듯 **간단한 팩토리 객체를 도입하는 경우, 기존 클라이언트 코드는 생성자로 팩토리 객체를 외부로부터 전달 받아 자신의 멤버 변수로 저장**할 수 있다.
  * 이 때, 기존의 if - else if - else 분기를 사용하던 코드 대신 팩토리로부터 객체를 생성하여 다형성을 활용하도록 코드를 수정할 수 있다.
  * 이 경우, 코드는 더 이상 new 연산자를 사용하지 않으므로 구체 클래스의 인스턴스에 의존하지 않게 된다.

### 팩토리 패턴과 정적 팩토리 메소드
* 정적 팩토리 메소드는 간단한 팩토리를 static 메소드로 정의하는 기법이며, 이는 객체 생성을 위해 굳이 new 연산자를 사용하지 않아도 되도록 하는 이점이 있다.
  * 그러나 **정적 팩토리 메소드는 static 메소드이므로, 서브클래스를 정의할 때 객체 생성 메소드의 행동을 변경할 수 없다는 단점이 존재**한다.

## 2022-10-26 Wed
### 간단한 팩토리
```
> 간단한 팩토리라는 용어는 디자인 패턴이라기보다는 프로그래밍에서 자주 사용되는 관용구에 가깝다.
```
* 간단한 팩토리에서 생성하는 인스턴스가 다음의 조건을 만족할 때, 간단한 팩토리로서 클라이언트에게 인스턴스를 반환할 수 있다.
  1. 팩토리에서 생성하는 모든 인스턴스는 같은 인터페이스를 구현한다.
  2. 팩토리에서 생성하는 인스턴스는 팩토리에 정의된 구상 클래스로부터 생성된다.
* 즉, **간단한 팩토리는 동일한 인터페이스를 구현하는 구상 클래스에 대한 정보를 애플리케이션에서 유일하게 직접 참조**한다.

### 다양한 팩토리 정의하기
* 애플리케이션 요구사항에 따라 팩토리가 다양한 종류로 정의되지만, 클라이언트 코드가 팩토리로부터 얻은 인스턴스를 사용하는 방식은 같을 수 있다.
  * 이 경우, **중복으로 인한 휴먼 에러를 방지하기 위해 인스턴스 생성부터 클라이언트 코드에서 작업하는 내용까지 모두 하나의 프레임워크로 만들 필요**가 있다.
  * 또한, **간단한 팩토리를 제거하고 새로운 팩토리를 정의하는 이 과정에서 유연성을 잃지 않기 위한 팩토리 메소드와 같은 새로운 방법이 필요**하다.

### 팩토리 메소드 적용하기
* 팩토리로부터 반환받은 인스턴스의 구체 클래스는 동적으로 결정되지만, 작업 자체는 동일한 경우에는 팩토리 메소드를 활용할 수 있다.
  * 이 경우, 상술한 간단한 팩토리에서 별도의 팩토리 객체로 추출했던 로직을 다시 원본 객체로 되돌린다.
  * 대신, **원본 클래스를 추상 클래스로 변경한 후 추상 팩토리 메소드를 하나 정의한 후에 팩토리를 사용하던 객체 생성 코드를 추상 메소드 호출로 변경**한다.
  * 이 경우, **팩토리 메소드의 구현은 해당 추상 클래스를 확장하는 서브클래스에서 결정**하게 된다.
* **이러한 방식은 각 팩토리로부터 생성한 인스턴스의 종류가 유동적으로 변경될 수 있으나, 해당 인스턴스가 동일한 인터페이스를 구현하는 경우에 적절**하다.
* 즉, 원본 클래스는 이제 다음과 같은 두 메소드를 통해 프레임워크의 형태를 띄게 되며, 프레임워크의 역할에 충실하면서도 여러 구체 인스턴스에 대응할 수 있다.
  1. 추상 팩토리 메소드로서, 해당 클래스를 확장하는 서브클래스에서 인스턴스를 생성하는 방법을 반드시 구현해야 한다.
  2. 인스턴스를 생성하여 해당 인스턴스의 메시지를 호출하던 메소드의 경우, 자신의 추상 메소드를 호출하여 인스턴스를 생성한 후 작업을 요청한다.
* **해당 방식에서, 이제 구체 클래스의 인스턴스를 만드는 작업은 하나의 팩토리 객체가 전부 처리하는 대신 일련의 서브클래스에서 처리하는 방식으로 변경**된다.
  * 즉, 이제 구체적인 객체의 타입은 추상 클래스를 확장하는 서브클래스에서 결정되며 원본 추상 클래스는 구체적인 객체의 타입을 전혀 알 수 없다.
  * **대신 객체의 생성은 팩토리 메소드가 처리하며, 원본 추상 클래스에서는 팩토리 메소드가 반환하는 객체가 특정 인터페이스를 구현한다는 사실에 집중**한다.

### 팩토리 메소드의 특징 I
* **팩토리 메소드는 객체 생성에 대한 구체적인 내용을 서브클래스에 캡슐화하며, 슈퍼클래스의 클라이언트 코드와 서브클래스의 객체 생성 코드를 분리**할 수 있다.
* 팩토리 메소드는 일반적으로 `abstract Animal createAnimal(String type);`와 같은 형식으로 정의된다.
  * 이는 **팩토리 메소드를 추상 메소드로 선언하여, 서브클래스에서 객체의 생성을 책임지도록 하기 위함**이다.
  * 또한, 팩토리 메소드는 `String type`과 같은 매개변수를 통해 실제로 생성될 객체의 종류를 선택하기 위한 정보를 간접적으로 제공할 수 있다.
* **팩토리 메소드는 임의의 객체를 알아서 선택하여 반환하며, 일반적으로 해당 객체를 사용하는 클라이언트 코드는 슈퍼클래스에 정의된 메소드에 위치**한다.
  * 이 경우, **팩토리 메소드는 슈퍼클래스의 메소드에 위치한 클라이언트 코드가 객체의 구체적인 타입을 전혀 알 수 없도록 캡슐화하는 역할을 수행**한다.

### 팩토리 메소드를 사용하는 프레임워크 방식의 장점
```
> 해당 방식의 경우, 팩토리로부터 반환받은 인스턴스에 실제 작업을 요청하는 메소드는 런타임에서 어떤 타입의 인스턴스가 작업을 처리할지 전혀 알 수 없다.
> 대신, 해당 메소드는 팩토리 메소드로부터 임의 타입의 인스턴스가 반환된다는 사실과 해당 인스턴스에 어떤 작업을 요청할 수 있다는 사실만을 알게 된다.
> 이로 인해 팩토리 메소드를 갖는 클래스와 팩토리 메소드가 반환하는 인스턴스의 클래스는 완전히 분리되어 유연성을 보장할 수 있게 된다.
```
* 이제 추상 클래스로 변경된 원본 클래스는 추상 팩토리 메소드로부터 반환받은 인스턴스에 메시지를 요청하기 위한 메소드만이 정의된다. 
  * 때문에 **해당 클래스는 서브클래스가 정의되기 전까지는 실제로 어떤 서브클래스가 어떤 인스턴스를 생성하여 해당 메소드를 실행할지 알 수가 없게 된다**.
  * 즉, **런타임에서 어떤 구체 클래스가 상술한 메소드를 실제로 처리할지 알 방법이 없으므로 원본 클래스와 팩토리에서 사용하는 클래스는 완전히 분리**된다.
* 이는 **결국 실제로 작업을 처리할 객체는 구현될 서브클래스의 종류에 따라 결정되는 셈**이 된다.
  * 또한, 생성된 인스턴스에 작업을 요청하는 메소드 입장에서는 서브클래스의 종류를 알 수 없으므로 마치 인스턴스의 타입을 서브클래스가 결정하는 것처럼 보인다.

## 2022-10-27 Thu
### 팩토리 메소드의 특징 II
* **모든 팩토리 패턴은 객체 생성을 캡슐화하며, 특히 팩토리 메소드 패턴은 서브클래스에서 어떤 구체 클래스를 만들지 결정하는 것으로 객체 생성을 캡슐화**한다.
* 이 때, 팩토리 메소드 패턴은 크게 다음과 같은 구성 요소로 분류할 수 있다.
  1. 추상 생산자 클래스: **추후에 서브클래스에서 제품을 생산하기 위해 구현하는 추상 팩토리 메소드를 정의**한다.
  2. 추상 제품 클래스: **팩토리 패턴의 주 목적은 인스턴스를 생성하는 것이며, 이 때 각 인스턴스는 제품 클래스를 확장하거나 구현**한다.
* 이 때, 추상 생산자 클래스에는 추상 제품 클래스에 의존하는 클라이언트 코드가 존재할 수도 있다.
  * 그러나 **구체 제품을 반환하는 팩토리 메소드는 항상 추상 생산자 클래스의 서브클래스에서 정의되므로, 어떤 구체 제품 클래스가 만들어질지는 알 수 없다**.
* **추상 생산자 클래스를 확장하는 구체 생산자 클래스는 추상 생산자 클래스에서 추상 메소드로 정의된 팩토리 메소드를 자신만의 방식으로 구현**한다.
* 또한 **모든 팩토리는 제품을 생산하므로, 구체 제품 클래스는 추상 팩토리 메소드가 생성하는 추상 제품 클래스를 확장하거나 구현**한다.
* 이 때, **구체 생산자 클래스 별로 많은 구체 제품 클래스를 생성할 수 있으므로 각 생산자 및 생산자에 대응되는 제품은 병렬 계층 구조로 볼 수 있다**.
* **병렬 클래스 계층 구조에서, 생산자와 제품은 모두 추상 클래스로 시작하며 각 클래스를 확장하는 구체 클래스들을 갖는 동일한 구조를 보인다**.
  * 이렇듯 두 클래스 모두 구체적인 구현은 구체 클래스가 책임지는 구조를 가지며, 이 때 생산자 클래스의 팩토리 메소드는 구체 제품을 만드는 방식을 캡슐화한다.
  * 다시 말해 **팩토리 메소드는 구체 제품 클래스를 생산하는 방법 자체를 캡슐화하는 데에 있어 가장 핵심적인 역할을 수행**한다.

### 팩토리 메소드 패턴이란?
```
> 팩토리 메소드 패턴에서는 객체 생성을 위해 필요한 인터페이스를 따로 만들어 둔다.
> 이후, 어떤 구체 클래스의 인스턴스를 생성할지는 해당 인터페이스를 구현하는 서브클래스에서 결정한다.
> 이렇듯 팩토리 메소드 패턴을 사용하는 경우, 어떤 구체 클래스의 인스턴스를 생성할지 결정하는 것은 서브클래스가 된다.
```
* **팩토리 메소드 패턴을 통해 구체 클래스를 생성하는 작업을 캡슐화**할 수 있다.
* 팩토리 메소드 패턴에서, 생산자 클래스는 다음과 같은 특징을 갖는다.
  1. 팩토리 메소드에 의해 생산된 구체 제품 클래스로 필요한 작업을 처리하는 별도의 메소드를 갖는다.
  2. 그러나 **팩토리 메소드는 추상 메소드로 정의되며, 이를 구현하고 구체 제품 인스턴스를 생산하는 작업은 오로지 서브클래스에서만 가능**하다.
* 즉, 팩토리 메소드 패턴에서는 어떤 구체 클래스의 인스턴스를 생산할지 서브클래스가 결정한다.
  * 이 때, **결정이라는 표현의 핵심적인 의미는 `생산자 클래스가 실제 생산될 제품을 전혀 알 수 없는 상태로 정의되는 것`에 있다**.
  * 때문에 실제로는 코드 상에서 사용할 서브클래스인 구체 생산자 클래스에 따라 생산되는 구체 제품 클래스가 결정된다.
* 반면, **서브클래스로부터 생산되는 모든 구체 제품 클래스는 반드시 모두 같은 인터페이스를 구현**해야 한다.
  * 이러한 **특징을 반드시 준수해야만 구체 제품 인스턴스를 사용하는 클래스에서 구체 클래스가 아닌 인터페이스에 의존할 수 있게 된다**.
* 이로 인해 구체 제품 클래스는 구체 생산자 클래스에 의해 생성되며, 실제로 구체 제품 클래스와 결합되는 클래스 역시 구체 생산자 클래스 뿐이 된다.

### 팩토리 메소드 패턴의 특징 III
* **팩토리 메소드 패턴은 구체 생산자 클래스가 단 하나 뿐인 경우에도 객체의 생성과 사용을 분리할 수 있으므로 충분히 유용**하다.
* 팩토리 메소드와, 이를 포함하는 생산자 클래스는 간단한 구체 제품 클래스를 사용하는 경우에 한해 추상으로 선언하지 않아도 무방하다.
  * 예를 들어, 간단한 구체 제품 클래스를 생성하는 경우에는 생산자 클래스의 서브클래스를 사용하지 않고 직접 생성할 수 있다.
* 팩토리 메소드 패턴에서, 구체 생산자 클래스는 때로는 하나의 구체 제품 클래스만 반환하는 형태로 구현될 수도 있다.
  * 즉, 구체 생산자 클래스가 반드시 여러 구체 제품 클래스를 다루어야하는 것은 아니다.
* **팩토리 메소드가 매개 변수를 통해 구체 제품 클래스를 여럿 생성하는 경우, 오타로 인한 런타임 오류가 발생할 가능성에 주의**해야 한다. 
  * 이러한 형식 안정성을 더 보장하기 위한 기법으로는 매개변수용 객체를 정의하거나, 정적 상수 또는 enum을 활용하는 방법을 고려할 수 있다.

### 간단한 팩토리와 팩토리 메소드 패턴의 비교
```
> 간단한 팩토리와 팩토리 메소드 패턴은 비슷하지만, 구체 제품 객체를 생성하기 위해 다른 방법을 사용한다.
```
* 간단한 팩토리의 경우, 다음과 같은 특징을 갖는다.
  1. 팩토리는 클라이언트 클래스의 멤버 변수로 포함되는 별도의 객체이다.
  2. 기본적으로 간단한 팩토리는 일회용 객체에 해당한다.
  3. **간단한 팩토리는 객체 생성을 캡슐화할 수 있으나, 구체 제품 클래스를 마음대로 변경할 수 없으므로 유연하지 않다**.
* 반면 팩토리 메소드 패턴의 경우, 다음과 같이 간단한 팩토리에 대비되는 특징을 갖는다.
  1. 팩토리는 추상 생산자 클래스에 인터페이스로 정의되며, 이를 서브클래스인 구체 생산자 클래스에서 확장한다.
  2. 팩토리 메소드 패턴은 재사용성이 높은 프레임워크에 해당한다.
  3. **팩토리 메소드 패턴은 생성될 구체 제품 클래스를 서브클래스에서 결정하므로 유연성이 높다**.

### 팩토리 메소드 패턴의 장점
```
> new 연산자를 활용한 구체 클래스의 인스턴스화는 기본적으로 변하기 쉬우며, 이를 코드 상에 흩어놓을수록 코드의 유연성과 유지보수성은 떨어진다.
```
* **변할 수 있는 부분은 반드시 캡슐화되어야 하는 반면, new 연산자를 사용하여 구체 클래스의 객체를 생성하는 코드 역시 변하기 쉬운 축**에 속한다.
  * 때문에 팩토리 패턴을 사용할 경우, 이렇듯 변하기 쉬운 인스턴스 생성 코드를 쉽게 캡슐화할 수 있다.
* 팩토리 패턴을 적용할 경우, 크게 다음과 같은 이점을 누릴 수 있다.
  1. 객체 생성 코드를 전부 하나의 객체 또는 메소드에 모아 중복을 제거할 수 있다.
  2. 객체 생성 코드가 여러 곳에 흩어지지 않고 코드의 한 지점에 집중되므로, 유지보수성이 높아진다.
  3. **팩토리를 통해 구체 클래스의 인스턴스를 생성할 경우, 인터페이스를 바탕으로 개발이 가능하므로 유연성과 확장성이 높은 애플리케이션을 개발**할 수 있다.
* **팩토리 패턴이 코드 상에서 new 연산자를 완전 제거하는 것은 아니며, Java의 예로 들어 new 연산자 없이 애플리케이션을 개발하는 것은 불가능에 가깝다**.
  * **팩토리 패턴은 대신 변화하기 쉬운 객체 생성 코드를 코드의 한 지점에 모아 체계적으로 관리하는 데에 의의가 있으며, 유연성과 유지보수성을 높인다**.

## 2022-10-28 Fri
### 객체의 의존성
* **new 연산자 등을 활용하여 구체 클래스의 인스턴스를 직접 생성하는 클라이언트 코드는 해당 구체 클래스에 강하게 결합되고, 의존**하게 된다.
* 때문에 팩토리를 사용하지 않고 자신이 사용할 모든 구체 클래스를 직접 생성하는 클라이언트 코드는 모든 구체 클래스에 직접적으로 의존하게 된다.
  * 이 경우, 각 구체 제품 클래스가 변경되면 클라이언트 클래스까지 함께 변경되어야할 가능성이 존재한다.
  * **이를 의존한다는 단어로 표현할 수 있으며, 또한 새로운 구체 제품 클래스가 추가되면 클라이언트 클래스는 더욱 많은 구체 클래스에 의존**하게 된다.

### 여섯 번째 디자인 원칙 - 의존성 역전
```
> 객체는 구체 클래스처럼 구체적인 것에 의존하지 않는 대신, 추상 클래스 또는 인터페이스와 같이 추상적인 것에 의존해야 한다.
> 또한, 의존성 역전 원칙은 고수준 모듈과 저수준 모듈 모두에 적용될 수 있다.
```
* 구체 클래스에 대한 의존성은 애플리케이션의 유연성을 떨어트리므로, 구체 클래스에 대한 의존성은 줄일수록 좋다고 볼 수 있다.
* 애플리케이션의 구성 요소는 크게 다음과 같이 분류해볼 수 있다.
  1. 고수준 구성 요소: 저수준 구성 요소에 의해 정의되는 행동을 포함하는 요소이다.
  2. 저수준 구성 요소: 고수준 구성 요소의 세부적인 행동을 의미하는 요소이다.
* 이 때, **의존성 역전 원칙은 또한 고수준 구성 요소가 저수준 구성 요소에 의존하는 대신 항상 추상에 의존해야 함을 강조**한다.

### 의존성 역전 원칙과 팩토리 패턴
* 팩토리 패턴을 전혀 사용하지 않고 클라이언트 코드에서 모든 구체 제품 클래스를 생성하는 경우, 생산자는 저수준 구성 요소인 구체 제품 클래스에 의존한다.
  * **이러한 의존성은 클라이언트 코드에서 new 연산자 등을 활용하여 구체 클래스의 객체를 직접 생성하기 때문**이다.
  * 이 경우에는 제품 클래스들의 공통 동작을 추상 제품 클래스로 추출한다고 해도 얻을 수 있는 이점이 크지 않다.
* 이러한 코드에 의존성 역전 원칙을 준수하기 위해 팩토리 메소드 패턴을 적용할 경우, 코드는 다음과 같은 특징을 갖게 된다.
  1. **추상 생산자 클래스는 추상 제품 클래스에만 의존하며, 런타임에서 어떤 구체 클래스가 반환될지 알 수도 없고 알 필요도 없다**.
  2. **구체 생산자 클래스에서 구현된 팩토리 메소드에서 생성하는 모든 구체 제품 클래스 역시 추상 제품 클래스에 의존**한다.
* 즉, **팩토리 메소드 패턴을 적용함으로써 고수준 구성 요소인 생산자 클래스와 저수준 구성 요소인 제품 클래스 모두 추상화에 의존**하게 된다.
  * 이 때, 의존 대상인 추상은 추상 제품 클래스가 된다.
  * 물론 **팩토리 메소드 패턴이 의존성 역전 원칙을 준수하는 유일한 원칙은 아니지만, 적합한 방법 중 하나임은 명확**하다.
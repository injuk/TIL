# HeadFirst
## 2022-10-25 Tue

### new 연산자 살펴보기
```
> 특정한 구현을 바탕으로 코드를 작성하지 않는 것이 바람직하지만, new 연산자를 사용하는 것은 곧 임의의 구현에 의존하는 것과 같다.
> 객체의 인스턴스를 생성하는 작업이 항상 new 연산자와 함께 공개되어야 하는 것은 아니며, 이는 오히려 단단한 결합에 의한 문제를 발생시킬 수 있다. 
```
* **new 연산자를 사용하면 구체 클래스의 인스턴스가 생성되며, 이는 당연하게도 인터페이스가 아닌 구현에 의존하는 코드**를 만들게 된다.
  * 앞서 다루었듯 **구체 클래스에 의존하는 코드는 코드의 수정 가능성이 높고, 유연성을 떨어트리기 쉽다**.
* 즉, `Animal animal = new Bird();`라는 코드는 다음과 같은 의미를 갖는다.
  1. 변수 타입을 Animal 인터페이스로 선언하여 다형성으로 인한 코드의 유현성을 꾀한다.
  2. **그럼에도 `new Bird();`라는 코드에 의해 구체 클래스인 Bird에 의존**하게 된다.
* 나아가 Animal 인터페이스를 구현하는 클래스가 여럿인 경우, 객체 생성을 위해 if - else if - else 분기를 사용하는 코드를 작성할 수도 있다.
  * 이 때 인스턴스 타입은 if 분기의 조건에 따라 결정되므로, 코드에 수정이 필요한 경우 항상 코드를 다시 확인해야하는 아쉬움이 있다.
  * 때문에 **이러한 유형의 코드는 수정 사항을 반영하기 어렵고, 더불어 휴먼 에러의 발생 가능성 또한 높다**.

### 다형성 돌아보기
```
> 인터페이스에 맞춘 코딩은 애플리케이션에서 발생할 여러 변경 사항에 대응할 수 있게 한다.
```
* new 연산자는 Java의 기초 중의 기초이며, 애플리케이션 개발에서 단 한 번도 사용하지 않는 것은 불가능하다.
  * **이는 즉 new 연산자 자체에는 문제가 없음을 시사하며, 실제로 주의하여 다루어야할 문제는 애플리케이션에 가해질 변화에 해당**한다.
* **인터페이스를 기반으로 작성된 코드는 어떠한 클래스든 인터페이스만 구현하면 사용이 가능하므로, 여러 변화에 대응이 가능한 유연성을 부여**한다.
  * 또한, 이러한 유용한 특징을 다형성이라고 지칭할 수 있다. 
* 반면, **구체 클래스를 많이 사용할수록 새로운 구체 클래스가 추가될 때마다 반드시 기존 코드를 수정해야 하므로 없었던 문제가 발생**시키기 쉽다.
  * **이는 즉 변경에 닫혀 있는 코드를 의미하므로, 기능을 확장하기 위해서는 변경을 캡슐화하여 확장에 열린 구조를 만들 수 있어야 한다**.

### 팩토리 패턴이 필요한 코드
* 예를 들어, 임의의 타입 정보에 따라 다른 인스턴스를 생성해야할 수 있다.
  * 이 경우 **각 인스턴스는 동일한 인터페이스를 구현하지만, 수 많은 if - else if - else 분기로 new 연산자로 각각 다른 인스턴스를 생성**한다.
* 또한, **이렇듯 if - else if - else 분기로 객체를 생성하는 코드는 변경에 닫혀 있지 않을 가능성이 높다**.
  * 때문에 객체의 종류가 추가되거나 줄어드는 등 변경이 발생한 경우, 반드시 해당 소스 코드를 수정해야만 한다.
* **이러한 코드에서는 인스턴스를 생성할 구체 클래스를 선택하는 부분이 변경 가능성이 높으며, 후속 코드는 다형성을 활용하므로 변경 가능성이 높지 않다**.
* 즉, **이 경우에 객체 생성과 관련된 코드는 변경 가능성이 높아 캡슐화되어야 하므로 별도의 객체에 책임을 할당하는 것이 바람직**하다. 
  * 이 경우, 해당 객체는 오로지 객체를 만드는 일에만 집중하게 되어 기존 코드는 해당 객체의 클라이언트 코드가 된다.
  * 이 때, **이렇듯 객체 생성만을 전담하여 처리하는 객체를 팩토리 객체라고 지칭**한다.
  * 이로 인해 기존 코드에서는 더 이상 객체 생성에 대해 고민할 필요가 없으며, 팩토리로부터 인스턴스를 반환받아 다형성을 활용하여 유연하게 동작할 수 있다.
  * 상술한 예시에서, if - else if - else 분기를 갖던 기존 코드를 새로 정의한 팩토리 객체로 그대로 옮기기만 하면 가장 간단한 팩토리를 정의할 수 있다.
* **객체 생성 코드를 캡슐화한 팩토리 패턴은 일견 코드의 위치만 다른 객체로 넘긴 것처럼 보이지만, 여러 클라이언트가 객체를 생성하는 경우 큰 이점**이 있다.
  * 예를 들어, 해당 객체를 생성하는 클라이언트 코드가 매우 많은 경우 변경 사항을 반영하기 위해 여기 저기에 퍼진 객체 생성 코드를 수정할 필요가 없다.
* 이렇듯 **간단한 팩토리 객체를 도입하는 경우, 기존 클라이언트 코드는 생성자로 팩토리 객체를 외부로부터 전달 받아 자신의 멤버 변수로 저장**할 수 있다.
  * 이 때, 기존의 if - else if - else 분기를 사용하던 코드 대신 팩토리로부터 객체를 생성하여 다형성을 활용하도록 코드를 수정할 수 있다.
  * 이 경우, 코드는 더 이상 new 연산자를 사용하지 않으므로 구체 클래스의 인스턴스에 의존하지 않게 된다.

### 팩토리 패턴과 정적 팩토리 메소드
* 정적 팩토리 메소드는 간단한 팩토리를 static 메소드로 정의하는 기법이며, 이는 객체 생성을 위해 굳이 new 연산자를 사용하지 않아도 되도록 하는 이점이 있다.
  * 그러나 **정적 팩토리 메소드는 static 메소드이므로, 서브클래스를 정의할 때 객체 생성 메소드의 행동을 변경할 수 없다는 단점이 존재**한다.

## 2022-10-26 Wed
### 간단한 팩토리
```
> 간단한 팩토리라는 용어는 디자인 패턴이라기보다는 프로그래밍에서 자주 사용되는 관용구에 가깝다.
```
* 간단한 팩토리에서 생성하는 인스턴스가 다음의 조건을 만족할 때, 간단한 팩토리로서 클라이언트에게 인스턴스를 반환할 수 있다.
  1. 팩토리에서 생성하는 모든 인스턴스는 같은 인터페이스를 구현한다.
  2. 팩토리에서 생성하는 인스턴스는 팩토리에 정의된 구상 클래스로부터 생성된다.
* 즉, **간단한 팩토리는 동일한 인터페이스를 구현하는 구상 클래스에 대한 정보를 애플리케이션에서 유일하게 직접 참조**한다.

### 다양한 팩토리 정의하기
* 애플리케이션 요구사항에 따라 팩토리가 다양한 종류로 정의되지만, 클라이언트 코드가 팩토리로부터 얻은 인스턴스를 사용하는 방식은 같을 수 있다.
  * 이 경우, **중복으로 인한 휴먼 에러를 방지하기 위해 인스턴스 생성부터 클라이언트 코드에서 작업하는 내용까지 모두 하나의 프레임워크로 만들 필요**가 있다.
  * 또한, **간단한 팩토리를 제거하고 새로운 팩토리를 정의하는 이 과정에서 유연성을 잃지 않기 위한 팩토리 메소드와 같은 새로운 방법이 필요**하다.

### 팩토리 메소드 적용하기
* 팩토리로부터 반환받은 인스턴스의 구체 클래스는 동적으로 결정되지만, 작업 자체는 동일한 경우에는 팩토리 메소드를 활용할 수 있다.
  * 이 경우, 상술한 간단한 팩토리에서 별도의 팩토리 객체로 추출했던 로직을 다시 원본 객체로 되돌린다.
  * 대신, **원본 클래스를 추상 클래스로 변경한 후 추상 팩토리 메소드를 하나 정의한 후에 팩토리를 사용하던 객체 생성 코드를 추상 메소드 호출로 변경**한다.
  * 이 경우, **팩토리 메소드의 구현은 해당 추상 클래스를 확장하는 서브클래스에서 결정**하게 된다.
* **이러한 방식은 각 팩토리로부터 생성한 인스턴스의 종류가 유동적으로 변경될 수 있으나, 해당 인스턴스가 동일한 인터페이스를 구현하는 경우에 적절**하다.
* 즉, 원본 클래스는 이제 다음과 같은 두 메소드를 통해 프레임워크의 형태를 띄게 되며, 프레임워크의 역할에 충실하면서도 여러 구체 인스턴스에 대응할 수 있다.
  1. 추상 팩토리 메소드로서, 해당 클래스를 확장하는 서브클래스에서 인스턴스를 생성하는 방법을 반드시 구현해야 한다.
  2. 인스턴스를 생성하여 해당 인스턴스의 메시지를 호출하던 메소드의 경우, 자신의 추상 메소드를 호출하여 인스턴스를 생성한 후 작업을 요청한다.
* **해당 방식에서, 이제 구체 클래스의 인스턴스를 만드는 작업은 하나의 팩토리 객체가 전부 처리하는 대신 일련의 서브클래스에서 처리하는 방식으로 변경**된다.
  * 즉, 이제 구체적인 객체의 타입은 추상 클래스를 확장하는 서브클래스에서 결정되며 원본 추상 클래스는 구체적인 객체의 타입을 전혀 알 수 없다.
  * **대신 객체의 생성은 팩토리 메소드가 처리하며, 원본 추상 클래스에서는 팩토리 메소드가 반환하는 객체가 특정 인터페이스를 구현한다는 사실에 집중**한다.

### 팩토리 메소드의 특징
* **팩토리 메소드는 객체 생성에 대한 구체적인 내용을 서브클래스에 캡슐화하며, 슈퍼클래스의 클라이언트 코드와 서브클래스의 객체 생성 코드를 분리**할 수 있다.
* 팩토리 메소드는 일반적으로 `abstract Animal createAnimal(String type);`와 같은 형식으로 정의된다.
  * 이는 **팩토리 메소드를 추상 메소드로 선언하여, 서브클래스에서 객체의 생성을 책임지도록 하기 위함**이다.
  * 또한, 팩토리 메소드는 `String type`과 같은 매개변수를 통해 실제로 생성될 객체의 종류를 선택하기 위한 정보를 간접적으로 제공할 수 있다.
* **팩토리 메소드는 임의의 객체를 알아서 선택하여 반환하며, 일반적으로 해당 객체를 사용하는 클라이언트 코드는 슈퍼클래스에 정의된 메소드에 위치**한다.
  * 이 경우, **팩토리 메소드는 슈퍼클래스의 메소드에 위치한 클라이언트 코드가 객체의 구체적인 타입을 전혀 알 수 없도록 캡슐화하는 역할을 수행**한다.

### 팩토리 메소드를 사용하는 프레임워크 방식의 장점
```
> 해당 방식의 경우, 팩토리로부터 반환받은 인스턴스에 실제 작업을 요청하는 메소드는 런타임에서 어떤 타입의 인스턴스가 작업을 처리할지 전혀 알 수 없다.
> 대신, 해당 메소드는 팩토리 메소드로부터 임의 타입의 인스턴스가 반환된다는 사실과 해당 인스턴스에 어떤 작업을 요청할 수 있다는 사실만을 알게 된다.
> 이로 인해 팩토리 메소드를 갖는 클래스와 팩토리 메소드가 반환하는 인스턴스의 클래스는 완전히 분리되어 유연성을 보장할 수 있게 된다.
```
* 이제 추상 클래스로 변경된 원본 클래스는 추상 팩토리 메소드로부터 반환받은 인스턴스에 메시지를 요청하기 위한 메소드만이 정의된다. 
  * 때문에 **해당 클래스는 서브클래스가 정의되기 전까지는 실제로 어떤 서브클래스가 어떤 인스턴스를 생성하여 해당 메소드를 실행할지 알 수가 없게 된다**.
  * 즉, **런타임에서 어떤 구체 클래스가 상술한 메소드를 실제로 처리할지 알 방법이 없으므로 원본 클래스와 팩토리에서 사용하는 클래스는 완전히 분리**된다.
* 이는 **결국 실제로 작업을 처리할 객체는 구현될 서브클래스의 종류에 따라 결정되는 셈**이 된다.
  * 또한, 생성된 인스턴스에 작업을 요청하는 메소드 입장에서는 서브클래스의 종류를 알 수 없으므로 마치 인스턴스의 타입을 서브클래스가 결정하는 것처럼 보인다.
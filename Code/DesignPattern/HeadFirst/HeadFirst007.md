# HeadFirst
## 2022-11-06 Sun

### 어댑터는 왜 사용하는가?
```
> 이미 존재하는 인터페이스를 새로운 인터페이스로 감싸 인터페이스의 형태를 변경시킬 수 있다.
> 이러한 방식은 임의의 인터페이스를 사용하는 디자인에 기존의 인터페이스를 구현하는 클래스를 적응시키기 위해 사용할 수 있다.
```
* **실세계의 어댑터는 임의의 인터페이스를 다른 곳에서 필요로 하는 형태로 변경하는 역할을 수행**한다.
  * 예를 들어, 한국식 콘센트와 미국식 콘센트는 그 형태가 다르므로 중간에 다른 어댑터를 사용하여 두 인터페이스를 호환시킨다.
* **객체지향 세계에서의 어댑터 역시 유사한 역할을 수행하며, 임의의 인터페이스를 클라이언트가 요구하는 형태로 적응시키는 역할을 수행**한다.

### 객체지향 어댑터란?
* 임의의 애플리케이션을 개발하는 조직과 협업하는 다른 조직이 제공하는 클래스를 사용할 때, 인터페이스가 완전히 다른 경우가 발생할 수 있다.
  * 이 때, **애플리케이션 개발 조직과 협업 조직 모두가 자신의 클래스를 변경하지 못하는 경우에는 두 사이를 적응시키는 클래스를 정의**할 수 있다.
  * 이 경우, **어댑터는 기존 애플리케이션에서 사용하는 인터페이스를 구현하여 협업 조직이 제공하는 클래스에 요청을 포워딩하는 식으로 구현**된다.
* 이렇듯 어댑터는 기존 코드의 수정 없이 클라이언트로부터 요청을 받아 협업 조직의 클래스와 호환될 수 있는 형태의 요청으로 변환하는 중개인 역할을 수행한다.

### 간단한 어댑터 클래스
* 예를 들어 다음과 같은 새 인터페이스와 비둘기 구현체가 있다고 가정한다.
```java
public interface Bird {
    void fly();
    void sing();
}
class Pigeon implements Bird {
    @Override 
    public void fly() {
        System.out.println("pigeon flying");
    }
    @Override
    public void sing() {
        System.out.println("pigeon singing");
    }
}
```
* 이제 모종의 이유에 의해 임의의 클라이언트 코드에서 다음과 같은 자동차 인터페이스와 구현체를 동물 인터페이스와 함께 사용해야할 수도 있다.
```java
public interface Car {
    void move();
    void noise();
}
class Ambulance implements Car {
    @Override
    public void move() {
        System.out.println("ambulance moving");    
    }
    @Override
    public void noise() {
        System.out.println("ambulance noise");
    }
}
```
* 이 경우, 자동차 인터페이스를 새 인터페이스에 적응시키기 위해 다음과 같은 간단한 어댑터를 작성해볼 수 있다.
  * 이러한 **어댑터는 구성과 위임 방식으로 작성되며, 어댑터 클래스는 적절한 추상 자동차를 생성자로 전달 받아 멤버 변수로 참조**한다.
  * **인터페이스의 적응 과정에서 필요하다면 멤버 변수로 참조하는 적응 대상을 활용하여 구현하는 각 메소드를 여러 번 호출하는 등 적절히 수정할 수도 있다**.
```java
public class Adapter implements Bird {
    private Car car;
    
    public Adapter(Car car) {
        this.car = car;
    }
    
    @Override
    public void fly() {
        car.move();
    }
    
    @Override
    public void sing() {
        car.noise();
    }
}
```
* 이렇듯 **어댑터 패턴을 적용할 경우, 적응 대상 객체를 적응할 객체의 인터페이스를 활용하여 한 번 감싸는 것으로 마치 다른 객체처럼 보이도록 만들 수 있다**.
  * 이렇게 **작성된 어댑터 객체는 적응 대상 객체의 인터페이스를 구현하므로, 해당 인터페이스를 통한 다형성을 활용할 수도 있다**.

### 어댑터 패턴이란?
* **어댑터 패턴은 크게 어댑터를 사용하는 클라이언트와 어댑터, 어댑티로 구성**된다.
  1. 클라이언트는 어댑터가 갖는 타겟 인터페이스에 맞게 구현되며, 타겟 인터페이스의 메소드를 호출한다.
  2. **어댑터는 타겟 인터페이스를 구현하며, 어댑티 인스턴스를 멤버 변수로 참조하여 클라이언트의 요청을 포워딩**한다.
  3. 어댑티는 클라이언트의 요청을 실제로 처리하는 인스턴스이며, 어댑터로부터 요청을 포워딩받아 응답한다.
* 상술한 이유에서, 클라이언트 객체는 어댑터 객체의 타겟 인터페이스 메소드를 호출하여 요청을 전달한다.
  * 어댑터는 해당 요청을 받아 적절히 변환하여 자신이 멤버 변수로 참조하는 어댑티 인터페이스로 포워딩한다.
* **클라이언트 객체는 이러한 과정을 거쳐 호출 결과를 반환받지만, 자신에게 응답하는 객체가 어댑터라는 사실을 알 수는 없다**.
  * 즉, 클라이언트와 어댑티는 어댑터로 하여금 분리되어 서로를 전혀 알지 못한다.

### 어댑터 패턴의 주의사항
* 큰 타겟 인터페이스를 구현하는 어댑터는 일견 해야할 일이 너무 많아보일 수는 있으나, 그럼에도 필요한 경우에는 모든 변경 사항을 캡슐화하는 것이 바람직하다.
* 어댑터 패턴은 일반적으로는 하나의 인터페이스를 다른 인터페이스로 변환하는 용도로 사용되나, 둘 이상의 어댑티를 포함하는 경우도 존재할 수 수 있다.
* 레거시 시스템에서 일부는 어댑터를 사용하고, 일부는 어댑터를 사용하지 않는 인터페이스를 사용하는 경우에는 유지보수성이 떨어질 가능성이 있다.
  * 그러나 **이 경우에는 어댑터를 사용하지 않기보다는 타겟 인터페이스와 어댑터를 사용하지 않는 인터페이스르 모두 구현하는 다중 어댑터를 작성**할 수 있다.
  * 즉, 다중 어댑터의 경우에는 기존 인터페이스와 새로운 인터페이스 양 쪽의 역할을 모두 수행할 수 있게 된다.

## 2022-11-07 Mon
### 어댑터 패턴의 정의
```
> 어댑터 패턴은 인터페이스가 호환되지 않아 사용할 수 없던 클래스를 함께 사용하기 위해 특정한 클래스 인터페이스를 큺라이언트가 요구하는 인터페이스로 변환한다.
```
* **어댑터 패턴을 적절히 활용할 경우, 호환되지 않는 인터페이스를 사용하는 클라이언트를 그대로 활용**할 수 있다.
  * 이는 어댑터를 통해 인터페이스의 형태를 변환한 효과를 누릴 수 있기 때문이다.
* **이를 통해 클라이언트와 구현된 인터페이스를 분리할 수 있으며, 변경은 어댑터에 캡슐화되므로 인터페이스가 변경되더라도 클라이언트를 수정할 필요가 없다**.
* 어댑터 패턴에서, 각 구성 요소는 다음과 같은 특징을 갖는다.
  1. 클라이언트: 타겟 인터페이스만을 인식할 수 있다.
  2. 어댑터: **타겟 인터페이스를 구현하며, 어댑티를 멤버 변수로 참조하는 식으로 구성**된다.
  3. 어댑티: 모든 요청을 어댑터로부터 위임 받아 실제 작업을 처리한다.
* 또한 어댑터 패턴은 다음과 같은 객체 지향 원칙을 준수하므로, 필요한 경우 서로 다른 어댑티로 변환시키는 여러 어댑터를 사용할 수도 있다.
  1. **객체 구성을 사용**하므로, 어댑티의 모든 서브클래스에 대해 어댑터를 적용할 수 있다.
  2. **클라이언트 코드를 특정한 구현이 아닌 추상적인 인터페이스에 연결하므로, 타겟 인터페이스만 유지하면 추후 다른 구현을 추가할 수도 있다**.

### 어댑터 패턴의 종류
* 어댑터 패턴은 크게 객체 어댑터와 클래스 어댑터로 분류되며, 상술한 내용은 객체 어댑터에 대한 설명에 해당한다.
  * 반면, 클래스 어댑터의 경우 다중 상속을 언어 차원에서 지원해야 한다.
* **클래스 어댑터는 타겟 인터페이스와 어댑티를 모두 서브클래스로 만들어 사용하는 반면, 객체 어댑터는 구성 기법을 통해 어댑티에게 요청을 포워딩**한다.
  * 즉, **클래스 어댑터의 경우 어댑터는 어댑티와 타겟 클래스를 모두 상속받는 서브클래스 형태로 구현되어야 하므로 구성이 아닌 상속 기법을 사용**한다.

### 클래스 어댑터 패턴과 객체 어댑터 패턴의 흐름
* 클래스 어댑터 패턴의 경우, 다음과 같은 흐름으로 동작한다.
  1. 클라이언트는 타겟 인터페이스를 구현한 클래스에 메시지를 요청한다고 생각한다.
  2. 실제로 **요청을 수신하는 클래스는 타겟 클래스를 확장하는 어댑터지만, 어댑터는 어댑티도 다중 상속하므로 요청에 대해 어댑티가 반응할 수 있도록 한다**.
  3. 어댑티는 어댑터가 메시지 요청을 가로채어 어댑티의 메소드 호출로 변환한 요청을 받아 작업을 처리한 후, 적절한 결과를 반환한다.
* 반면, 객체 어댑터 패턴의 경우 다음과 같은 흐름으로 동작한다.
  1. 클라이언트는 타겟 인터페이스를 구현한 클래스에 메시지를 요청한다고 생각한다.
  2. **요청을 수신하는 어댑터는 타겟 인터페이스를 구현하지만, 내부적으로 어댑티를 참조하여 요청을 어댑티에 대한 메소드 호출로 변환**한다.
  3. 어댑티는 어댑터에 의해 변환된 클라이언트의 요청을 수신하며, 이를 처리한 후에 적절한 결과를 반환한다.

### Enumeration을 Iterator에 적응시키기
* 오래된 Java에서 사용하던 Enumeration은 컬렉션의 각 항목에 대한 관리 방법을 신경쓰지 않고도 모든 요소를 접근할 수 있도록 한다.
  * 반면, 최근에는 컬렉션의 항목에 접근하는 것 뿐만 아니라 제거할 수도 있도록 하는 Iterator 인터페이스가 사용된다.
  * 때문에 때로는 Enumeration을 사용하는 코드를 다뤄야할 수도 있으나, 가급적 새로운 코드에는 Iterator를 적용하는 것이 바람직하다.
* **실무에서는 두 인터페이스의 차이점을 확인하고, 어댑터 패턴을 도입하여 클라이언트 코드 상에서는 Iterator 인터페이스만을 사용하도록 구현**할 수 있다.
  * 이 경우, **어댑터는 타겟 인터페이스인 Iterator를 구현하고 내부적인 동작은 Enumeration 구현체에 포워딩하는 식으로 정의**될 수 있다.
* 그러나 **Enumeration은 Iterator가 제공하는 remove 메소드를 제공하지 않으므로, 이에 대해서는 런타임 예외를 던지는 식으로 구현**할 수 있다.
  * 이렇듯 **메소드가 일대 일로 대응되지 않는 경우에는 어댑터 패턴을 완벽하게 적용할 수 없을 수도 있다**.
  * 때문에 클라이언트는 예외 발생 가능성을 염두에 두어야 하며, 어댑터 패턴이 적용된 객체에 대한 문서를 잘 작성해두는 것이 바람직하다.

### 데코레이터 패턴과 어댑터 패턴의 차이
* 두 패턴은 일견 비슷한 것처럼 보이지만, 다음과 같은 차이를 갖는다.
  * **데코레이터 패턴은 인터페이스를 장식하여 기존의 코드를 수정하지 않고도 클래스에 새로운 행동을 추가할 수 있도록 한다**.
  * 반면, **어댑터 패턴은 감싸고 있는 인터페이스에 대한 요청을 변환하여 전달**한다.
* 이렇듯 **데코레이터는 새로운 책임과 행동을 디자인에 추가시키지만, 어댑터는 여러 클래스의 인터페이스를 클라이언트가 원하는 형태에 맞게 변환**한다.
  * **단적으로 데코레이터는 객체의 행동과 책임을 확장하지만, 어댑터는 두 인터페이스 사이에 위치하여 요청을 변환하는 역할을 수행**한다.

## 2022-11-08 Tue
### 파사드 패턴 시작하기
* 상술한 바와 같이, 어댑터 패턴은 호환성이 없는 인터페이스를 올바른 인터페이스로 감싸 구현하게 된다.
  * 즉, **어떤 클래스의 인터페이스를 클라이언트가 원하는 인터페이스로 변환하기 위해 사용하는 패턴**이 된다.
* 반면, **복잡한 인터페이스를 단순화하기 위해서도 인터페이스를 변경할 수도 있으며 이러한 패턴을 파사드 패턴이라고 지칭**한다.
  * **파사드는 외관이라는 의미를 가지며, 해당 패턴을 통해 하나 이상의 인터페이스를 깔끔한 하나의 인터페이스로 덮어버릴 수 있다**.
* 파사드 패턴은 데코레이터와 어댑터와 비교하였을 때 다음과 같은 차이점이 존재한다.
  1. 데코레이터 패턴: **인터페이스를 변경하지 않은 채 새로운 기능, 즉 책임만을 추가**한다.
  2. 어댑터 패턴: **하나의 인터페이스를 클라이언트가 요구하는 또다른 인터페이스로 변환**한다.
  3. 파사드 패턴: **하나 이상의 복잡한 인터페이스를 단순하게 변환**한다.

### 파사드 패턴의 작동 원리
* **파사드 패턴은 사용하기 쉬운 인터페이스를 제공하는 파사드 클래스를 직접 구현하는 것으로 복잡한 시스템을 편리하게 사용할 수 있도록 한다**.
  * 물론, 복잡한 기존 인터페이스에 직접 접근하고자 하는 경우에는 기존 인터페이스를 그대로 사용해도 무방하다.
  * 그러나 **간단하고 편리한 사용성이 필요한 경우, 파사드 패턴의 적용을 고려**할 수 있다.
* 파사드 클래스는 여러 복잡한 인터페이스 구성 요소를 각각의 서브시스템으로 간주하며, 내부적으로는 서브시스템의 메소드 호출을 통해 필요한 작업을 처리한다.
  * 이를 통해 **클라이언트 코드는 각각의 서브시스템이 아닌 파사드 클래스에 있는 메소드를 호출하는 것으로 원하는 복잡한 작업을 처리**할 수 있다.
  * 또한, 상술했듯 파사드 클래스를 적용하더라도 여전히 서브시스템에 직접 접근할 수 있다.

## 2022-11-09 Wed
### 파사드 패턴 주의사항
* 파사드 패턴이 적용된 클래스는 서브시스템 클래스 자체를 캡슐화하는 것은 아니다.
  * 때문에 클라이언트에서 필요한 경우, 파사드 클래스가 제공하는 편리한 인터페이스 이외에도 서브시스템을 구성하는 모든 인터페이스를 자유로이 사용할 수 있다.
* **특정한 서브시스템에 대해 만들 수 있는 파사드의 개수에는 제한이 없다**.
* **파사드 패턴을 적용할 경우 더 간단한 인터페이스를 제공할 수 있지만, 중요한 것은 클라이언트의 구현과 서브시스템을 분리할 수 있다는 사실**이다.
  * 이로 인해 파사드 클래스가 단순화하는 인터페이스가 수정되더라도 파사드를 사용하는 클라이언트의 코드는 수정할 필요가 없다. 
* **어댑터 패턴과 파사드는 감싸는 클래스의 개수로 구분되는 것이 아니며, 중요한 것은 다음과 같은 용도의 차이**에 있다.
  1. **어댑터 패턴은 인터페이스를 변경하여 클라이언트에서 필요로 하는 인터페이스로 적응시키기 위해 사용**된다.
  2. **파사드 패턴은 임의의 복잡한 서브시스템에 대한 간단한 인터페이스를 제공하기 위해 사용**된다.
* 즉, 파사드와 어댑터 모두 여러 개의 클래스를 감싸는 식으로 구현될 수 있다.

### 파사드 클래스의 구현
* **파사드 패턴이 적용되는 파사드 클래스는 서브시스템에 있는 모든 구성 요소에 접근할 수 있도록 구성 기법을 활용하여 멤버 변수로 참조**한다.
  * 때문에 파사드 클래스의 생성자에서는 서브시스템을 구성하는 구성 요소 별 레퍼런스가 전달되며, 파사드 클래스는 이러한 레퍼런스들을 멤버 변수에 저장한다.
* 파사드 패턴 없이는 복잡한 순서대로 실행해야했던 서브시스템의 메소드 호출은 파사드 클래스에서 외부로 노출하는 메소드로 캡슐화된다.
  * 이 때, **내부적으로 각각의 작업은 서브시스템에 포함되는 구성 요소에게 위임**된다. 

### 파사드 패턴의 정의
```
> 파사드 패턴은 서브시스템에 존재하는 일련의 인터페이스를 통합 인터페이스로 묶어주는 역할을 수행한다.
> 이 과정에서 고수준의 인터페이스가 정의되므로 서브시스템을 더욱 편리하게 사용할 수 있다.
```
* 이렇듯 **파사드 패턴을 적용하기 위해서는 임의의 서브시스템에 속한 일련의 복잡한 클래스를 단순화하여 통합하는 클래스를 작성**해야 한다.
* **파사드 패턴은 다른 디자인 패턴들과 비교했을 때 상당히 단순한 편이지만, 클라이언트와 서브시스템을 분리하는데에 큰 도움**을 줄 수 있다.
* **파사드 패턴의 핵심은 단순화된 인터페이스를 토대로 서브시스템을 더 편리하게 사용할 수 있다는 점**에 있다.

### 최소 지식 원칙
```
> 최소 지식 원칙은 애플리케이션을 디자인하는 과정에서 어떠한 객체든 그 객체와 상호작용하는 클래스의 개수와 상호작용 방식에 주의를 기울여야 함을 시사한다. 
```
* **최소 지식 원칙을 적절히 준수한 경우, 여러 클래스가 강하게 결합되어 애플리케이션의 일부에 대한 변경 사항이 전파되는 것을 미연에 방지**할 수 있다.
  * 반면, **최소 지식 원칙을 준수하지 못하는 경우에는 여러 클래스가 서로 복잡하게 의존하며 유지보수성과 가독성이 크게 떨어질 수 있다**.  
* **최소 지식 원칙을 준수하기 위해서는 객체 사이의 상호작용은 직접 연결된 객체 간에서만 허용되는 것이 바람직**하다.

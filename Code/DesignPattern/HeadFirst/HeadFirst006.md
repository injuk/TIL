# HeadFirst
## 2022-11-02 Wed

### 커맨드 패턴의 필요성
```
> 때로는 작업을 요청하는 측과 작업을 처리하는 측을 분리하여 캡슐화해야할 수 있다.
> 이 때, 중간 계층인 커맨드 객체를 두는 것으로 두 객체를 손쉽게 분리할 수 있다.
```
* 예를 들어 **작업을 요청했을 때 처리될 수 있는 작업의 종류는 매우 많으나, 작업 간의 공통된 인터페이스를 추출하기는 어려운 경우가 있을 수 있다**.
  * 이 경우, 엎친 데 덮친 격으로 작업의 종류가 추후에 추가되는 것을 고려한다면 문제는 더욱 복잡해진다.
* 변화를 캡슐화하기 위해서는 두 요청자와 처리자 사이에 위치하여 각 객체를 분리하는 역할을 수행할 무언가가 필요하며, 커맨드 객체는 이를 적절히 수행할 수 있다.

### 커맨드 패턴의 구성 요소
```
> 커맨드 패턴은 크게 클라이언트 객체로부터 시작하여 리시버와 커맨드, 인보커 객체로 구성된다.
```
* **커맨드 패턴을 시작하는 클라이언트 객체는 커맨드 객체를 생성**한다.
* **커맨드 객체는 리시버의 정보를 포함하며, 행동을 캡슐화하는 유일한 메소드인 execute**를 갖는다.
  * 이 때, 해당 메소드는 리시버 객체가 갖는 임의의 행동을 처리하는 식으로 동작한다.
* **인보커 객체에는 클라이언트 객체가 setCommand 메소드를 호출하여 커맨드 객체를 설정하며, 설정된 커맨드 객체를 적시까지 보관하는 역할을 맡는다**.
  * **인보커 객체는 필요한 시점에 자신이 참조하는 커맨드 객체의 execute 메소드를 호출하며, 이로 인해 리시버 객체에 저장된 메소드가 호출**된다.

### 인보커의 로딩
* 인보커는 기본적으로 클라이언트에서 생성한 커맨드 객체를 저장하기 위한 setCommand 메소드를 제공한다.
  * 해당 메소드를 통해 **저장된 커맨드 객체는 추후 적절한 시점에 클라이언트가 명령 실행을 요청했을 때 커맨드 객체의 명령을 실행**한다.
* 이렇듯 일회성 작업 뿐만 아니라 인보커 객체는 커맨드 객체를 한 번 로딩한 후에는 다음과 같이 동작하도록 구현될 수도 있다.
  1. 작업을 처리한 후에 커맨드 객체의 참조를 제거한다.
  2. 또는 저장해둔 커맨드 객체를 통해 명령을 여러 차례 실행한다.
# HeadFirst
## 2022-10-17 Mon

### 누군가는 이미 우리의 문제를 해결해두었다.
```
> 패턴을 잘 사용하려면 패턴을 기억해둔 후, 애플리케이션에 어떻게 적용할지 파악해야 한다.
> 디자인 패턴이란, 코드가 아닌 경험을 재사용하는 것과 같다.
```

### 소프트웨어 개발 불변의 진리
* **어떤 언어를 사용하여 무엇을 만들든지 애플리케이션은 반드시 시간이 지남에 따라 변화하고 성장**해야 한다.
  * 이는 아무리 디자인을 잘한 애플리케이션이라도 마찬가지이며, 그렇지 않은 애플리케이션은 죽어버릴 수 밖에 없다.

### 상속과 인터페이스의 한계
* 매우 다양한 객체가 다음과 같은 특징을 갖는다고 가정한다.
  1. 모든 객체가 공통된 동작을 갖는 메소드를 포함하므로, 이를 하나의 부모 클래스로 추출했다.
  2. 반면, 모든 객체는 시그니쳐가 같지만 각자 다르게 동작하는 메소드도 포함한다.
  3. 어떤 객체는 1.이나 2.의 메소드에서 아무런 동작을 하지 않는다.
* 이 경우, 유지보수성을 높이기 위해서 상속 또는 인터페이스를 고려할 수 있으나 각각 다음과 같은 문제를 갖는다.
  1. **상속은 서브클래스마다 객체의 행동이 바뀔 수 있는 데도 모든 서브클래스에서 하나의 행동만 사용**하도록 한다.
  2. **인터페이스는 구현된 코드가 없으므로, 코드를 재사용할 수가 없어 행동을 수정할 때마다 버그 발생 가능성**이 높아진다.

### 첫 번째 디자인 원칙 - 변화하는 부분을 찾아 분리하기
* 상술한 시나리오에 완벽히 들어맞는 디자인 원칙은 `애플리케이션에서 달라질 수 있는 부분을 찾아 달라지지 않을 부분과 분리하는 것`이다.
  * **해당 디자인 원칙은 여러 원칙 중 첫 번째이며, 코드에 새로운 요구 사항이 생길 때마다 바뀔 가능성이 있는 부분은 분리**해내야 한다.
  * 이렇듯 **바뀌는 부분을 따로 추출하여 캡슐화하는 것으로 애플리케이션은 유연해지며, 바뀌지 않는 부분에 영향을 주지 않은 채로 수정 또는 확장이 가능**하다.
* **해당 원칙은 매우 간단하지만, 모든 디자인 패턴의 기반을 이루는 원칙**이기도 하다.
  * 이렇듯 **모든 패턴은 애플리케이션의 일부를 다른 부분과 독립적으로 변화시킬 수 있는 방법을 제공**한다.

## 2022-10-18 Tue
### 바뀌는 부분과 그렇지 않을 부분을 분리하기
* 상술한 시나리오에서, 1.의 메소드들이 자주 달라지거나 바뀌지 않는다고 가정한다면 굳이 부모 클래스를 제거할 필요는 없으므로 그대로 둔다.
  * 대신 **2.와 같이 객체마다 다르게 동작하는(즉, 변화하기 쉬운) 메소드는 별도의 행동을 의미하는 객체 집합으로 추출**한다.
  * 이렇게 추출된 각각의 행동은 다양한 메소드 구현을 포함할 수 있어야 한다.
* 이 때, 각 행동을 구현하는 클래스 집합은 반드시 다음과 같은 조건을 만족해야 한다.
  1. **상술한 문제는 유연성이 부족한 데에서 기인하였으므로, 행동 클래스 집합은 최대한 유연해야** 한다.
  2. **원래 객체들에게 행동을 할당할 수 있어야 하며, 이를 동작으로 변경시킬 수도 있어야** 한다.

### 두 번째 디자인 원칙 - 구현보다는 추상에 맞추어 개발하기
* **해당 디자인 원칙에 맞추어 상술한 행동 클래스 집합은 인터페이스로 표현하되, 구체적인 행동은 인터페이스를 구현하는 방식으로 개발하는 것이 바람직**하다.
  * 이 경우, 각 행동 집합을 의미하는 인터페이스는 원본 클래스가 아닌 인터페이스를 구현하는 행동 클래스에서 정의한다.
* **이러한 디자인 원칙을 준수할 경우, 부모 클래스 또는 서브 클래스에서 구현하는 방식과 달리 원본 클래스가 상세한 구현에 의존할 필요가 없다**.
  * 때문에 원본 코드를 반드시 수정해야 했던 기존 방식과 달리 행동을 변경할 여지가 생기므로, 구조는 더 유연해진다.
  * 즉, **더 이상 부모 클래스와 서브 클래스들은 구체적인 행동의 구현에 의존하지 않는다**.

### 인터페이스의 중의성
```
> 인터페이스에 맞춘 프로그래밍은 곧 상위 형식에 맞추어 프로그래밍하는 것을 의미한다.
```
* Java를 예로 들어, 인터페이스는 일반적으로 다음과 같은 중의적인 의미로 사용된다.
  1. Java의 문법의 일종인 interface
  2. 또는 `인터페이스`라는 개념 자체
* 때문에 **인터페이스에 맞추어 개발하는 것은 곧 반드시 Java의 interface를 사용해야한다는 것을 의미하지는 않는다**.
  * **핵심은 런타임에 사용될 객체가 임의의 상세한 구현 코드에 의존하지 않도록 상위 형식인 supertype에 맞추어 개발을 진행하여 다형성을 활용하는 것**이다.
* 이는 Java를 예로 들어, 다음과 같은 코드에서 위 방식보다는 아래의 방식을 권장한다는 의미로 이해할 수 있다.
```
// Animal을 확장한 구체 클래스인 Bird를 사용하므로, 코드는 상세한 구현에 의존하게 된다.
Bird bird = new Bird();
bird.fly();

// 다형성을 활용하여 유연성을 더했으나, 인스턴스는 실제로 Bird임을 알고는 있기에 역시 구체 클래스에 의존하게 된다.
Animal animal = new Bird();
animal.move();

// 가장 좋은 방법으로, animal이 Animal이고 move라는 메시지를 수신할 수 있다는 사실에만 집중하되 구체 클래스에는 관심을 갖지 않는다.
Animal animal = getAnimal();
animal.move();
```
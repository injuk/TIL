# HeadFirst
## 2022-11-26 Sat

### 원격 프록시란?
```
> 원격 프록시는 원격지에 위치한 객체를 로컬 환경에서 대변하는 역할을 수행한다.
```
* **로컬 대변자 객체는 다른 JVM 힙 메모리 공간에서 상주하는 원격 객체에 대해 메소드 호출을 전달하는 역할을 수행하며, 이를 원격 프록시라고 지칭**한다.
  * 이러한 프록시는 원격 객체를 활용하는 클라이언트 코드 입장에서는 실제 원격 객체처럼 보여지지만, 실제로는 요청을 포워딩할 뿐이다.
* 즉, 클라이언트 객체는 원격 객체의 메소드를 호출하는 것처럼 행동하지만 실제로는 로컬 힙 메모리에 포함된 프록시 객체의 메소드를 호출한다.
  * 이 과정에서 네트워크 IO와 같은 저수준 작업은 프록시 객체가 직접 처리한다.

## 2022-11-27 Sun
### 프록시 패턴이란?
```
> 프록시 패턴은 원격 객체 또는 생성이 어려운 객체, 나아가 보안이 중요한 객체 등 특정한 객체로의 접근을 제어하는 프록시 객체를 제공한다. 
```
* 프록시 패턴은 여러 방식이 있으며, 주로 접근을 제어하는 방법을 다르게 제공하여 크게 다음과 같이 분류할 수 있다.
  1. 원격 프록시를 사용하여 원격 객체로의 접근을 제어하는 방식
  2. 가상 프록시를 사용하여 생성하기 힘든 자원으로의 접근을 제어하는 방식
  3. 보호 프록시를 사용하여 접근 권한이 필요한 자원으로의 접근을 제어하는 방식

### 프록시 패턴의 구성 요소
* 프록시 패턴의 다이어그램은 크게 다음과 같은 요소로 구성된다.
  1. Subject: **RealSubject와 Proxy가 공통으로 구현하는 인터페이스**이다.
  2. RealSubject: 실제 작업을 수행하는 객체이며, Subject 인터페이스를 구현한다.
  3. Proxy: **RealSubject 객체를 참조하는 멤버 변수를 가지며, RealSubject 객체로의 접근을 제어**한다.
* 이렇듯 **RealSubject와 Proxy는 공통의 인터페이스인 Subject를 구현하므로, 클라이언트 코드 입장에서는 서로가 호환**될 수 있다.
  * 즉, RealSubject 객체가 필요한 위치라면 어디에든 Proxy 객체를 배치할 수 있다.
* **클라이언트는 Proxy를 통해 RealSubject와 정보를 주고 받으며, 경우에 따라 Proxy가 RealSubject의 생성 또는 제거까지도 책임질 수 있다**.
  * 이렇듯 Proxy는 클라이언트의 RealSubject 객체에 대한 접근을 제어할 수 있다.
  * 때문에 **어떠한 방식으로든 RealSubject 객체로의 접근을 통제해야하는 경우에는 접근을 제어하는 Proxy 객체를 도입**할 수 있다.
  * 예를 들어, **RealSubject가 원격 시스템에 위치하거나 객체를 생성하는 데에 비용이 너무 많이 드는 경우에 프록시 패턴을 고려**할 수 있다.

### 원격 프록시와 가상 프록시
```
> 프록시 패턴은 다양한 형태로 사용되지만, 어떠한 형태를 따르든지 기본 프록시 디자인을 따른다.
```
* 원격 프록시와 가상 프록시는 각각 프록시 패턴의 대표적인 형태이며, 다음과 같은 차이점을 갖는다.
  1. 원격 프록시는 다른 JVM에서 동작하는 객체를 대리하는 로컬 힙의 객체이다.
  2. **가상 프록시는 생성하는 데에 많은 비용이 드는 객체를 대리하며, 정말로 큰 객체가 필요하기 전까지는 객체의 생성을 미루는 기능을 제공**한다.
* 이 때, 가상 프록시는 실제 객체가 생성되기 전이나 생성되는 도중에 해당 객체를 대신하여 요청에 응답할 수도 있으나 객체가 생성된 경우에는 바로 포워딩한다.
  * 가상 프록시의 예를 들어, 사진 게시판에서 네트워크 IO를 통해 이미지 로드가 완료되기 전까지 스켈레톤을 보여주는 예시를 들 수 있다.
  * 이 경우 가상 프록시는 이미지 로딩이 완료되기 전까지 스켈레톤 또는 안내 메시지를 노출하며, 로딩이 완료된 후에는 이미지 객체에게 작업을 포워딩하게 된다.

### 프록시 패턴과 주의사항
* **프록시 패턴에는 많은 변종이 존재하지만, 모두 클라이언트로부터의 실제 객체에 대한 접근을 중간에 가로채어 제어한다는 공통점이 존재**한다.
* 프록시 패턴은 종종 데코레이터 패턴과 어댑터 패턴과 혼동되곤 하지만, 다음과 같이 용도로 구분할 수 있다.
  1. 데코레이터 패턴은 클래스에 새로운 행동을 추가하기 위해 사용된다.
  2. 프록시 패턴은 임의의 클래스에 대한 접근을 제어하기 위해 사용된다.
  3. 어댑터 패턴은 다른 객체의 인터페이스를 변경해주기 위해 사용된다.
* 특히 데코레이터 패턴과 프록시 패턴은 혼동되기 쉬우며, 프록시 패턴은 Subject를 대리하여 보호해야 할 객체를 감싸는 것이 핵심이다.
  * 때문에 **프록시 패턴은 존재하지 않는 객체를 생성하거나 대변하는 반면, 데코레이터 패턴은 존재하는 객체의 행동을 추가한다는 점에서 차이**가 있다. 
* **클라이언트에서 실제 객체가 아닌 프록시를 사용하도록 강제할 필요가 있는 경우, 객체의 인스턴스를 생성하여 반환하는 코드를 팩토리 메소드로 만들 수 있다**.

## 2022-11-28 Mon
### Java와 동적 프록시 
* `java.lang.reflect` 패키지에는 프록시 기능이 내장되어 있으며, 이를 통해 다음과 같은 프록시 클래스를 작성할 수 있다.
  1. 즉석에서 하나 이상의 인터페이스를 구현한다.
  2. 지정한 클래스에 메소드 호출을 전달하는 프록시 기능을 부여한다.
* **이러한 프록시 클래스는 런타임에서 생성되며, 이를 Java 언어 차원에서 제공하는 동적 프록시라고 지칭**한다.
* 또한, 동적 프록시의 클래스 다이어그램은 크게 다음과 같은 요소로 구성되며 Proxy가 두 개의 클래스로 구성된다는 점에서 프록시 패턴과는 차이가 있다.
  1. Subject, RealSubject: 프록시 패턴의 구성 요소와 같은 기능을 수행한다.
  2. Proxy: **RealSubject를 대리하는 점은 기존 프록시 패턴과 같으나, Java 언어 차원에서 런타임에 생성하게 되는 차이가 존재**한다.
  3. InvocationHandler: **프록시에 호출되는 모든 메소드에 대해 응답하며, Proxy가 호출될 경우 항상 InvocationHandler가 실제 작업을 처리**한다.
* **동적 프록시의 경우, Proxy가 런타임에서 생성되므로 Proxy가 무슨 일을 수행할지 알려줄 별도의 방법이 필요**하게 된다.
  * **InvocationHandler는 이를 위해 사용되며, 해당 핸들러로부터 RealSubject 객체에 있는 메소드로의 접근을 제어**하게 된다.
  * 또한, 이 경우에도 Java 언어 차원에서 런타임에 생성되는 Proxy는 Subject 인터페이스를 구현하게 된다.
* 동적 프록시를 활용할 경우, 필요에 따라 접근을 제어하는 식으로 RealSubject 객체를 보호하는 보호 프록시를 쉽게 구현할 수 있다.

### 보호 프록시란?
```
> 보호 프록시란, 접근 권한을 바탕으로 객체로부터의 요청과 접근을 제어하는 프록시를 지칭한다.
```
* **보호 프록시를 적절히 구현할 경우, 임의의 객체로부터 RealSubject에 대한 접근을 시도할 경우 권한 별로 호출되는 메소드들을 제어**할 수 있다.

### 동적 프록시와 주의사항
* **동적 프록시는 클래스가 런타임에서 생성되기 때문에 동적이라는 표현을 사용하며, 실제로도 코드가 실행되기 전까지는 프록시 클래스가 존재하지 않는다**.
* InvocationHandler 자체는 프록시가 아니며, 단지 메소드 호출을 처리하는 클래스에 지나지 않는다.
  * 반면, **실제 프록시는 Proxy.newProxyInstance와 같은 정적 메소드에 의해 런타임에서 동적으로 생성**된다.
* Proxy.isProxyClass 정적 메소드를 통해 동적 프록시 클래스를 판별할 수 있다.

### 여러 종류의 프록시
* 프록시 패턴은 매우 다양한 변종을 제공하며, 크게 다음과 같은 종류를 생각해볼 수 있다.
  1. 방화벽 프록시: 일련의 네트워크 자원으로 향하는 접근을 제어한다.
  2. 스마트 레퍼런스 프록시: Subject가 참조될 때마다 레퍼런스의 개수를 체크하는 등의 추가적인 행동을 제공한다.
  3. 캐싱 프록시: 비용이 많이 드는 작업의 결과를 임시로 저장하도록 지원하며, 여러 클라이언트가 결과를 공유하게 만들 수도 있다.
  4. 동기화 프록시: 여러 스레드로부터 Subject에 접근하는 상황에서 보다 안전하게 작업을 처리할 수 있도록 한다.
  5. 복잡도 숨김 프록시: 복잡한 클래스의 집합에 대한 접근을 제어하여 복잡도를 숨기며, 대체 인터페이스만을 제공하는 파사드 패턴과는 차이가 있다.
  6. 지연 복사 프록시: 클라이언트에서 정말로 필요한 시점까지 객체가 복사되는 것을 지연하여 객체 복사를 제어한다.

### 프록시 패턴 - 결론
```
> 프록시 패턴은 특정한 객체로의 접근을 제어하는 대리 객체를 제공한다.
```
* **프록시 패턴을 적절히 사용할 경우, 객체의 대리자를 내세워 클라이언트의 접근을 제어**할 수 있다.
* 프록시 패턴의 예시는 크게 다음과 같으며, 이 밖에도 많은 변종이 존재한다.
  1. 원격 프록시: 클라이언트와 원격 객체 사이의 데이터 전달을 관리한다.
  2. 가상 프록시: 인스턴스화에 많은 비용이 드는 객체에 대한 접근을 제어한다.
  3. 보호 프록시: 호출자의 권한에 따라 호출 가능한 메소드를 제어한다.
* **프록시 패턴의 구조는 데코레이터 패턴과 유사하지만, 그 용도에서 차이가 존재**한다.
  * 예를 들어 **프록시 패턴은 접근 자체를 제어하기 위해 사용되는 반면, 데코레이터 패턴은 객체에 새로운 행동을 추가하기 위해 사용**된다.
* Java의 내장 프록시 지원 기능을 사용할 경우, 동적 프록시 클래스를 생성하여 원하는 핸들러가 호출을 처리하도록 구현할 수 있다.
* 또한, **프록시 패턴 역시 다른 Wrapper를 사용할 때와 마찬가지로 디자인에 포함되는 클래스와 객체의 수가 늘어날 수 있다**.
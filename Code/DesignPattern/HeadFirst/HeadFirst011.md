# HeadFirst
## 2022-11-26 Sat

### 원격 프록시란?
```
> 원격 프록시는 원격지에 위치한 객체를 로컬 환경에서 대변하는 역할을 수행한다.
```
* **로컬 대변자 객체는 다른 JVM 힙 메모리 공간에서 상주하는 원격 객체에 대해 메소드 호출을 전달하는 역할을 수행하며, 이를 원격 프록시라고 지칭**한다.
  * 이러한 프록시는 원격 객체를 활용하는 클라이언트 코드 입장에서는 실제 원격 객체처럼 보여지지만, 실제로는 요청을 포워딩할 뿐이다.
* 즉, 클라이언트 객체는 원격 객체의 메소드를 호출하는 것처럼 행동하지만 실제로는 로컬 힙 메모리에 포함된 프록시 객체의 메소드를 호출한다.
  * 이 과정에서 네트워크 IO와 같은 저수준 작업은 프록시 객체가 직접 처리한다.

## 2022-11-27 Sun
### 프록시 패턴이란?
```
> 프록시 패턴은 원격 객체 또는 생성이 어려운 객체, 나아가 보안이 중요한 객체 등 특정한 객체로의 접근을 제어하는 프록시 객체를 제공한다. 
```
* 프록시 패턴은 여러 방식이 있으며, 주로 접근을 제어하는 방법을 다르게 제공하여 크게 다음과 같이 분류할 수 있다.
  1. 원격 프록시를 사용하여 원격 객체로의 접근을 제어하는 방식
  2. 가상 프록시를 사용하여 생성하기 힘든 자원으로의 접근을 제어하는 방식
  3. 보호 프록시를 사용하여 접근 권한이 필요한 자원으로의 접근을 제어하는 방식

### 프록시 패턴의 구성 요소
* 프록시 패턴의 다이어그램은 크게 다음과 같은 요소로 구성된다.
  1. Subject: **RealSubject와 Proxy가 공통으로 구현하는 인터페이스**이다.
  2. RealSubject: 실제 작업을 수행하는 객체이며, Subject 인터페이스를 구현한다.
  3. Proxy: **RealSubject 객체를 참조하는 멤버 변수를 가지며, RealSubject 객체로의 접근을 제어**한다.
* 이렇듯 **RealSubject와 Proxy는 공통의 인터페이스인 Subject를 구현하므로, 클라이언트 코드 입장에서는 서로가 호환**될 수 있다.
  * 즉, RealSubject 객체가 필요한 위치라면 어디에든 Proxy 객체를 배치할 수 있다.
* **클라이언트는 Proxy를 통해 RealSubject와 정보를 주고 받으며, 경우에 따라 Proxy가 RealSubject의 생성 또는 제거까지도 책임질 수 있다**.
  * 이렇듯 Proxy는 클라이언트의 RealSubject 객체에 대한 접근을 제어할 수 있다.
  * 때문에 **어떠한 방식으로든 RealSubject 객체로의 접근을 통제해야하는 경우에는 접근을 제어하는 Proxy 객체를 도입**할 수 있다.
  * 예를 들어, **RealSubject가 원격 시스템에 위치하거나 객체를 생성하는 데에 비용이 너무 많이 드는 경우에 프록시 패턴을 고려**할 수 있다.

### 원격 프록시와 가상 프록시
```
> 프록시 패턴은 다양한 형태로 사용되지만, 어떠한 형태를 따르든지 기본 프록시 디자인을 따른다.
```
* 원격 프록시와 가상 프록시는 각각 프록시 패턴의 대표적인 형태이며, 다음과 같은 차이점을 갖는다.
  1. 원격 프록시는 다른 JVM에서 동작하는 객체를 대리하는 로컬 힙의 객체이다.
  2. **가상 프록시는 생성하는 데에 많은 비용이 드는 객체를 대리하며, 정말로 큰 객체가 필요하기 전까지는 객체의 생성을 미루는 기능을 제공**한다.
* 이 때, 가상 프록시는 실제 객체가 생성되기 전이나 생성되는 도중에 해당 객체를 대신하여 요청에 응답할 수도 있으나 객체가 생성된 경우에는 바로 포워딩한다.
  * 가상 프록시의 예를 들어, 사진 게시판에서 네트워크 IO를 통해 이미지 로드가 완료되기 전까지 스켈레톤을 보여주는 예시를 들 수 있다.
  * 이 경우 가상 프록시는 이미지 로딩이 완료되기 전까지 스켈레톤 또는 안내 메시지를 노출하며, 로딩이 완료된 후에는 이미지 객체에게 작업을 포워딩하게 된다.

### 프록시 패턴과 주의사항
* **프록시 패턴에는 많은 변종이 존재하지만, 모두 클라이언트로부터의 실제 객체에 대한 접근을 중간에 가로채어 제어한다는 공통점이 존재**한다.
* 프록시 패턴은 종종 데코레이터 패턴과 어댑터 패턴과 혼동되곤 하지만, 다음과 같이 용도로 구분할 수 있다.
  1. 데코레이터 패턴은 클래스에 새로운 행동을 추가하기 위해 사용된다.
  2. 프록시 패턴은 임의의 클래스에 대한 접근을 제어하기 위해 사용된다.
  3. 어댑터 패턴은 다른 객체의 인터페이스를 변경해주기 위해 사용된다.
* 특히 데코레이터 패턴과 프록시 패턴은 혼동되기 쉬우며, 프록시 패턴은 Subject를 대리하여 보호해야 할 객체를 감싸는 것이 핵심이다.
  * 때문에 **프록시 패턴은 존재하지 않는 객체를 생성하거나 대변하는 반면, 데코레이터 패턴은 존재하는 객체의 행동을 추가한다는 점에서 차이**가 있다. 
* **클라이언트에서 실제 객체가 아닌 프록시를 사용하도록 강제할 필요가 있는 경우, 객체의 인스턴스를 생성하여 반환하는 코드를 팩토리 메소드로 만들 수 있다**.
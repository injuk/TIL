# HeadFirst
## 2022-11-23 Wed

### 상태 다이어그램
* 상태 다이어그램은 크게 상태와 전환으로 구분하여 분석할 수 있다.
  1. 상태: 애플리케이션이 현재 처한, 또는 설정된 상태를 의미한다.
  2. 전환: 임의의 상태에서 다른 상태로 전환하기 위해서는 어떠한 행동을 취해야 하며, 이러한 행동을 통해 상태가 전환된다.
* **상태를 기반으로 작성된 애플리케이션은 사용자의 행동에 관계 없이 항상 현재 상태를 확인한 후, 상태에 맞는 적절한 행동**을 취해야 한다.

### 간단한 상태 기계의 구현
* 상태 다이어그램을 기반으로 작성된 코드를 상태 기계로 지칭할 수 있으며, 상태 기계는 다음과 같은 흐름으로 구현할 수 있다.
  1. 우선 가능한 상태를 따로 분류한 후, 초기 상태를 결정한다.
  2. 각각의 상태를 의미하는 정적 클래스 변수를 정의한 후, 상태 별로 대응되는 유일한 값을 정의한다.
  3. 상태 기계의 현재 상태를 저장하기 위한 멤버 변수를 정의한 후, 초기 상태를 설정한다.
  4. **상태 기계에서 상태를 전환하기 위해 가능한 모든 행동을 따로 분류한 후, 각각의 행동을 상태 기계의 인터페이스로 취급**한다.
  5. **분류된 상태 각각을 의미하는 메소드를 정의하되, 메소드마다 현재 상태에 따라 분기할 수 있도록 if - else 문을 작성**한다.
* 이 때, **5.의 과정에서는 적절한 상태를 의미하는 분기에서 현재 발생한 행동에 의해 상태 기계의 상태를 전환시킬 수도 있다**.
* 간단한 상태 기계는 상술한 형태로 구현되며, 기본적으로는 현재 상태를 저장하는 인스턴스 변수와 각각의 행동을 의미하는 메소드 별 분기를 작성하여 구현된다.

## 2022-11-24 Thu
### 상태 패턴으로 개선하기
* 상술한 코드는 다음과 같은 단점이 존재한다.
  1. 상태를 추가할 때마다 모든 행동 메소드에 분기가 추가된다.
  2. 때문에 OCP를 준수하지 않고, 변경되는 부분은 캡슐화되지도 않는다.
* **이는 상태 객체들을 정의하여 별도 코드에 작성하고, 임의의 행동이 발생할 때마다 현재 상태 객체에서 필요한 작업을 처리하게 하는 것으로 개선**할 수 있다.
  * 예를 들어, 모든 행동에 관련된 메소드를 포함하는 상태 인터페이스를 정의한다.
  * 그 이후 **기계의 모든 상태를 대상으로 상태 클래스를 구현하며, 기계가 임의의 상태에 처했을 때 해당 상태 클래스가 모든 작업을 책임**지도록 한다.
  * **이를 통해 모든 조건문을 제거하고, 대신 구성 기법을 활용하여 포함하게 된 상태 클래스에 모든 작업을 위임**할 수 있다.
* 이렇듯 **상태 패턴은 각각의 상태 별 행동을 개별 클래스에 정의하여 국지화하므로 코드의 가독성과 유지보수성은 크게 향상**된다.
  * 이는 각 상태의 행동을 개별 클래스에 캡슐화하고, 불필요한 if - else 분기를 제거할 수 있기 때문이다.
  * 또한, 각 상태는 변경에는 닫혀 있고 확장에는 열리게 되므로 OCP 역시 준수할 수 있게 된다.
  * 나아가 **상태 패턴을 적용한 클래스의 코드 베이스와 클래스 구조는 복잡한 if - else 분기를 사용하는 기존 방식보다 더 이해하기 쉬운 경우가 많다**.

### State 인터페이스
* 상태 패턴의 경우, 각각의 상태를 의미하는 클래스들이 공통으로 구현할 State 인터페이스를 우선 정의하게 된다.
  * 이 때, **State 인터페이스는 현재 요구 사항에서 발생할 수 있는 모든 행동들을 대표하는 각각의 메소드를 정의**한다.
  * 즉, **각각의 행동은 상태 인터페이스에 정의된 메소드들에 직접적으로 대응**된다.
* 각각의 **구체 상태 클래스는 State 인터페이스를 구현하며, 상태 기계의 상태를 적절한 메소드에서 변환할 수 있도록 상태 기계의 참조를 생성자로 전달**받는다. 
  * 이렇듯 구체 상태 클래스의 메소드들은 상태에 맞는 적절한 동작을 구현해야 하며, 상황에 따라서는 상태 기계의 상태를 전이시킬 수 있어야 한다.
* 이렇듯 **State 인터페이스와 이를 구현하는 구체 상태 클래스들을 통해 요구 사항에 포함되는 모든 상태는 캡슐화**될 수 있다.
* 이렇게 작성된 코드는 간단한 상태 기계와 유사하지만, 모든 행동 메소드에 존재했던 if - else 분기 코드가 각각의 구체 상태 클래스로 분산된다는 차이가 있다.

### 상태 기계 클래스 개선하기
* 정적 클래스 변수로 각 상태를 표시하던 기존의 상태 기계는 대신 멤버 변수로서 각 구체 상태 인스턴스를 참조하도록 수정된다.
  * 정적 변수를 사용하던 기존 방식 대신 멤버 변수와 구성 방식을 사용하도록 수정되는 것이며, 각각의 구체 상태 객체를 초기화하는 코드는 생성자에서 처리한다.
  * **상태 기계 역시 행동 별 적절한 메소드를 정의해야 하며, 내부적인 구현은 현재 상태를 의미하는 구체 상태 인스턴스에 위임하는 식으로 구현**한다.
  * 또한 현재 상태를 의미하는 멤버 변수에 대한 설정자를 반드시 구체 상태 클래스에서도 사용할 수 있도록 구현한다.
* 상태 기계는 현재 상태를 의미하는 변수와 모든 가용 상태를 의미하는 N개의 멤버 변수를 갖게 되므로, State 인터페이스를 참조하는 변수를 N+1개 갖게 된다.
  * 즉, **현재 상태를 의미하는 State 형 변수는 항상 다른 구체 상태 인스턴스를 의미하는 멤버 변수 중 하나를 참조**하게 된다.
  * 이 때, 각각의 구체 상태 클래스에서 적절한 행동이 발생했을 경우 상태 기계의 현재 상태 설정자를 통해 상태를 전환하게 된다.
  * 때문에 새로운 구체 상태 인스턴스가 아닌 상태 기계에 구성된 상태 인스턴스로 전환이 가능하도록, 상태 기계는 모든 가용 상태에 대한 접근자를 제공해야 한다.

## 2022-11-25 Fri
### 상태 패턴 정의하기
```
> 상태 패턴을 적용할 경우, 객체의 내부 상태 정보가 변경됨에 따라 마치 객체 자체가 바뀐 것처럼 행동을 변경할 수 있다.
```
* **상태 패턴에서는 각각의 상태와 이에 대응되는 행동을 별도의 클래스로 캡슐화**하게 된다.
  * 이후에는 **상태 기계의 행동이 내부적으로 현재 상태를 나타내는 객체에게 위임되므로, 내부 상태가 변경될 때마다 상태 기계의 행동 역시 변경**될 수 있다.
* 또한 클라이언트 관점에서, 현재 사용하는 상태 기계의 행동이 상태에 따라 완전히 변경되므로 마치 다른 클래스의 객체를 사용하는 것 같은 효과를 얻을 수 있다.
  * 그러나 **이는 실제로 객체 자체가 변경되는 것이 아닌, 구성에 의해 참조되는 상태 객체가 변경되기 때문에 얻을 수 있는 결과**에 해당한다.

### 상태 패턴의 구성 요소
* 상태 패턴의 클래스 다이어그램은 다음과 같은 구성 요소로 표현될 수 있다.
  1. Context: **상태 기계의 역할을 수행하며, 내부적으로 여러 상태 객체를 참조하여 클라이언트의 요청을 적절히 위임**한다.
  2. State: **모든 구체 상태 클래스의 공통 인터페이스를 정의하며, 구체 상태 객체를 때에 따라 바꾸어가며 사용할 수 있는 근간**이 된다.
  3. ConcreteState: **구체 상태 클래스는 State 인터페이스를 구현하며, Context로부터 전달되는 요청을 적절한 방법으로 처리**한다.

### 상태 패턴과 전략 패턴의 차이
* **기본적으로 두 패턴의 클래스 다이어그램은 사실상 동일하지만, 그 용도는 다르게 사용**된다.
* 상태 패턴의 경우 각 상태 객체에 행동이 캡슐화되어 상황에 맞는 객체에 행동을 위임하므로, Context가 참조하는 객체를 변경하는 것으로 행동을 바꿀 수 있다.
  * 이 때, **객체 내부의 상태에 따라 현재 상태를 나타내는 객체가 변경되며 행동 역시 자연스레 변경되므로, 클라이언트는 상태 객체를 알 필요가 없다**.
  * 때문에 **Context 객체 내부에 존재하는 여러 if - else 분기를 사용하는 대신에 상태 패턴의 적용을 고려**할 수 있다. 
* 반면, **전략 패턴의 경우 클라이언트가 Context 객체에서 사용될 전략 객체를 명시적으로 지정**한다.
  * 이렇듯 **전략 패턴은 주로 런타임에서 사용할 전략 객체를 변경하기 위한 유연성을 제공하기 위해 사용**된다.
  * 이렇듯 **전략 패턴은 상속 대신에 구성을 통해 유연성을 극대화하기 위해 사용되며, 행동을 의미하는 객체를 유연하게 바꿀 방법을 제공**한다.

### 상태 패턴과 주의사항
* 반드시 구체 상태 클래스에서 상태 전이를 결정하는 것은 아니며, 때에 따라서는 Context가 이를 담당하게 만들 수 있다.
  * 또한, 상태 전이를 구체 상태 클래스가 담당하는 경우에는 상태 클래스 간에 의존성이 발생하게 된다. 
  * **일반적으로는 상태 흐름이 고정되어 있는 경우 Context에서 상태 전이를 담당하며, 동적으로 결정되는 경우 구체 상태 객체가 결정하는 것이 바람직**하다.
  * 상태 전이 코드를 어디에 작성하느냐에 따라 애플리케이션이 성숙해가는 과정에서 어떤 클래스가 변경에 닫혀있게 될지 결정된다.
* **클라이언트가 각각의 상태 객체와 직접 상호 작용하는 일은 절대 없으며, 상태를 관리하는 작업은 전적으로 Context 객체에서 수행**되어야 한다.
  * **각각의 상태 객체는 단지 Context의 내부 상태와 행동을 표현하기 위해 사용되며, 클라이언트는 Context의 상태를 직접 변경하지 않아야 한다**.
* 애플리케이션에 상태 패턴이 적용된 곳이 많은 경우, 여러 Context에서 상태 객체들을 공유할 수도 있다.
  * 이는 일반적으로는 각각의 상태 객체를 정적 인스턴스 변수에 할당하여 공유하는 방식을 택하게 된다.
  * 이 경우, 정적 인스턴스 변수로 공유된 상태 객체에서 Context의 멤버에 접근해야 한다면 Context 객체의 참조를 전달할 수 있도록 정의해야 한다.
* 상태 패턴을 적용할 경우 각 상태의 행동을 개별 상태 클래스에 캡슐화하므로, 클래스 개수가 크게 늘어날 수 있다.
  * 그러나 **이는 유연성을 위해 기꺼이 감수할만한 비용에 해당하며, 일반적으로는 클래스를 추가하여 유연한 디자인을 얻는 것이 더 좋다**.
  * 또한 대부분의 경우, 실제 클래스 개수보다는 클라이언트에게 노출되는 클래스의 개수가 더 중요하다.
  * 무엇보다 상태 패턴을 적용하지 않는 경우, Context 객체에는 복잡한 조건문이 필연적으로 작성되므로 가독성과 유지보수성은 떨어질 수 밖에 없다.
  * 반면 **상태 패턴과 객체를 사용하는 경우, 각각의 상태와 이에 대응되는 행동을 명시적으로 표현할 수 있으므로 가독성과 유지보수성을 모두 얻을 수 있다**.
* 각 구체 상태 객체가 공유할만한 메소드가 존재하는 경우, State는 인터페이스 대신 추상 클래스로 구현될 수 있다.
  * 또한, **추상 클래스를 사용하여 구현된 State 클래스에는 구체 상태 클래스를 수정하지 않고서도 새로운 코드를 작성할 수 있는 이점이 존재**한다.
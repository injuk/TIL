# HeadFirst
## 2022-10-23 Sun

### 상속과 클래스 폭발
* 예를 들어 커피 전문점의 애플리케이션이 다음과 같은 상속 구조를 활용한다고 가정한다.
  1. 모든 음료의 부모 역할을 하는 추상 클래스인 Beverage를 정의한다.
  2. Beverage 클래스에는 가격을 구하는 추상 메소드인 cost()를 정의한다.
  3. 모든 커피는 Beverage를 상속받아 cost()를 재정의한다.
* 그러나 이 경우, 커피에 샷을 추가하거나 크림을 얻는 등의 변화를 가할 경우 이에 대응할 수 있도록 모든 종류의 커피 클래스를 정의해야 한다.
  * 즉, **상속을 남용하면 말 그대로 클래스의 개수가 폭발하게 되는 상황이 발생**할 수 있다.
* 이러한 클래스 폭발 현상은 앞서 다루었던 디자인 원칙 중 다음의 두 가지를 어긴 전형적인 상황에 해당한다.
  1. 변화가 가능한 부분을 캡슐화하여 분리한다.
  2. 상속보다는 구성을 사용한다.

### 기존 방식을 개선하기?
* 기존의 클래스 폭발 현상을 개선하기 위해, Beverage에 각 첨가물의 유무를 의미하는 bool 변수를 둘 수 있다.
  * 이 때, 각 첨가물의 유무를 의미하는 bool 변수에 대해서는 접근자와 제어자 역시 추가되어야 한다. 
  * 또한, cost 메소드가 첨가물 별 bool 변수에 따라 첨가물의 가격을 구할 수 있도록 일반 메소드로 구체화한다.
* 이제 Beverage를 상속하는 커피 클래스의 개수를 줄이되, 각 커피 클래스의 cost()가 `커피 가격 + super.cost()`의 형태로 계산되도록 수정할 수 있다.
* 그러나 이러한 방식 역시 다음과 같은 이유에서 애플리케이션은 유연하지 않고, 변경에 취약함을 알 수 있다.
  1. 첨가물 별 가격이 변경되는 경우 기존 코드를 반드시 수정해야 한다.
  2. 첨가물이 추가되는 경우, 기존 클래스를 수정해야 한다.
  3. **일부 첨가물이 포함되지 않아야하는 음료 클래스 역시 첨가물 별 접근자와 제어자를 반드시 상속**받게 된다.

### 상속의 대안 - 구성 활용하기
* **객체 지향 프로그래밍에서 상속은 분명 강력한 기능이나, 상속의 적용이 반드시 유연한 디자인으로 이어지지는 않는다**.
  * **상속은 코드의 재사용에 초점을 맞추는 경우가 많으나, 재사용성은 오히려 구성과 위임을 통해 행동을 상속하는 방식으로 구현하는 것이 바람직**하다.
* 나아가 상속과 구성은 다음과 같은 차이점을 갖는다.
  1. **상속은 서브클래스의 행동을 컴파일 시점에 결정하므로, 변경할 수 없으면서도 모든 서브클래스가 같은 행동을 상속받도록 강요**한다.
  2. 반면, **구성을 활용한 객체의 확장은 런타임에서 동적으로 행동을 변경할 수 있도록 하는 유연성을 제공**한다.
* 이렇듯 **구성을 활용한 확장은 심지어 객체의 설계 초기에 상상하지 못했던 동작까지도 기존 클래스를 수정하지 않고 추가**할 수 있다.
  * 또한 **구성은 기능 수정시 새로운 행동 클래스를 추가하므로, 기존 코드를 전혀 수정하지 않아 휴먼에러 또는 사이드 이펙트를 미연에 방지**할 수 있다.
* **이상적인 객체는 OCP 원칙을 준수하며, 변경에는 폐쇄적이지만 확장에는 열려 있어야**한다. 

### 다섯 번째 디자인 원칙 - Open Closed Principle
```
> 클래스는 확장에는 열려 있어야 하지만, 변경에는 닫혀 있어야 한다.
> 그러나 코드에서 확장될 부분을 선택할 때에는 신중해져야 한다.
> 예를 들어, 항상 OCP를 적용하려 하는 것은 쓸데 없는 시간 낭비가 되어 필요 이상으로 복잡한 코드를 만들 가능성이 높다.
```
* 우리의 **목표는 기존 코드를 수정하지 않으면서도 확장을 통해 새로운 행동을 추가하는 것으로, 이로 인해 환경에 잘 적응하는 유연한 디자인**을 얻을 수 있다.
  * 때문에 OCP는 매우 중요한 디자인 원칙 중 하나이기도 하다.
* **확장에는 열려 있지만 변경에는 닫혀 있어야 한다는 말이 일견 모순처럼 보여질 수 있으나, 이를 가능케하는 객체 지향 기법은 많다**.
  * 나아가 객체 지향 디자인을 배우다 보면 행동을 확장할 수 있는 방법이 더욱 많다는 점을 자연스럽게 이해할 수 있다.
* 반면, **애플리케이션의 모든 부분에서 OCP를 준수할 수 있는 것은 아니며 일반적으로는 그렇게 해야할 여유와 이유도 없다**.
  * 예를 들어, OCP를 준수하기 위해서 때로는 새로운 단계의 추상화가 필요할 수 있으나 이는 오랜 시간을 들여 코드를 복잡하게 만들 수 밖에 없다.
  * 때문에 **설계 단계에서는 가장 바뀔 가능성이 높은 부분을 중점적으로 고려하고, 이에 OCP를 적용하는 것이 가장 바람직**하다.
* 애플리케이션에서 OCP를 적용할 부분을 찾아내는 작업은 충분한 객체 지향 디자인 경험과 현재 분야의 도메인 지식이 있는 경우에는 쉽게 가능하다.
  * 또한, 여러가지 디자인을 이해한다면 변경될 부분 중에서도 중요한 부분을 골라내는 안목을 기를 수 있다.

### 데코레이터 패턴이란?
* 상술한 시나리오에서 상속을 고집하는 두 방법은 다음과 크게 같은 문제를 갖는다.
  1. 필요 이상으로 많은 클래스를 정의하는 클래스 폭발로 이어질 수 있다. 
  2. 또는 일부 클래스에 전혀 필요하지 않는 기능이 추가되어야할 수도 있다.
* 이렇듯 **모든 것을 상속과 서브클래스로 해결하는 대신, 첨가물을 장식물 개념으로 생각하여 음료를 decorate 하는 방식을 고려**할 수 있다.
* 예를 들어, 모카와 휘핑 크림을 추가하는 다크 로스트 커피는 다음과 같은 흐름으로 가격을 계산해볼 수 있다.
  1. DarkRoast 객체를 생성한다.
  2. Mocha 객체로 장식한다.
  3. Whip 객체로 장식한다.
  4. 이후에 **cost()를 호출하여 가격을 계산하되, 각 커피와 첨가물의 가격은 해당 객체에 위임**한다.
* **이는 각 첨가물을 마치 래퍼 객체처럼 생각하는 것으로, 커피 객체를 첨가물 객체로 장식하는 방법과 적절히 위임하는 방법을 필수적으로 고려**해야 한다.
* 예를 들어, DarkRoast 객체는 여전히 Beverage를 상속받아 가격을 계산하는 cost 메소드를 갖는다.
  * 반면 Mocha나 Whip 객체는 데코레이터이며, 각 객체의 형식은 객체가 장식하는 또 다른 객체인 Beverage와 같은 형식을 갖는다.
  * **이렇듯 데코레이터가 자신이 장식하는 객체와 같은 형식을 갖는다는 사실은 반영이라는 표현으로 지칭**할 수도 있다.
* 각 데코레이터 객체의 형식은 장식 대상 객체의 형식을 반영하므로, 이 경우에는 첨가물인 데코레이터 객체 자체도 Beverage 객체로 간주할 수 있다.
  * 이는 **모든 첨가물 객체가 Beverage 객체를 상속하는 서브클래스이므로, 다형성에 의해 가능**하다.
  * 때문에 이렇게 데코레이터로 장식된 원본 객체는 여전히 Beverage 객체이므로, cost 메소드 호출은 여전히 가능하다.
* **가장 바깥에 위치한 데코레이터에서 cost()를 호출했다면, 해당 객체는 자신이 감싸는 객체에 계산을 위임한 후 그 결과에 자신의 값을 추가하여 반환**한다.

### 데코레이터 패턴 요약하기
* **데코레이터 객체의 부모 클래스는 자신이 장식하는 객체의 부모 클래스**이다.
  * 즉, 데코레이터는 자신이 감싸는 객체와 같은 부모 클래스를 갖기에 장식 대상 객체의 위치에 데코레이터 객체를 넣더라도 상관이 없다.
* **하나의 객체는 여러 데코레이터 객체로 감쌀 수 있으며, 런타임에서 얼마든지 필요한 데코레이터를 적용**할 수 있다.
* **데코레이터 객체는 자신이 장식하는 객체에게 행동을 위임할 수 있으며, 그 외의 추가 작업까지 수행할 수도 있다**.
# HeadFirst
## 2022-10-23 Sun

### 상속과 클래스 폭발
* 예를 들어 커피 전문점의 애플리케이션이 다음과 같은 상속 구조를 활용한다고 가정한다.
  1. 모든 음료의 부모 역할을 하는 추상 클래스인 Beverage를 정의한다.
  2. Beverage 클래스에는 가격을 구하는 추상 메소드인 cost()를 정의한다.
  3. 모든 커피는 Beverage를 상속받아 cost()를 재정의한다.
* 그러나 이 경우, 커피에 샷을 추가하거나 크림을 얻는 등의 변화를 가할 경우 이에 대응할 수 있도록 모든 종류의 커피 클래스를 정의해야 한다.
  * 즉, **상속을 남용하면 말 그대로 클래스의 개수가 폭발하게 되는 상황이 발생**할 수 있다.
* 이러한 클래스 폭발 현상은 앞서 다루었던 디자인 원칙 중 다음의 두 가지를 어긴 전형적인 상황에 해당한다.
  1. 변화가 가능한 부분을 캡슐화하여 분리한다.
  2. 상속보다는 구성을 사용한다.

### 기존 방식을 개선하기?
* 기존의 클래스 폭발 현상을 개선하기 위해, Beverage에 각 첨가물의 유무를 의미하는 bool 변수를 둘 수 있다.
  * 이 때, 각 첨가물의 유무를 의미하는 bool 변수에 대해서는 접근자와 제어자 역시 추가되어야 한다. 
  * 또한, cost 메소드가 첨가물 별 bool 변수에 따라 첨가물의 가격을 구할 수 있도록 일반 메소드로 구체화한다.
* 이제 Beverage를 상속하는 커피 클래스의 개수를 줄이되, 각 커피 클래스의 cost()가 `커피 가격 + super.cost()`의 형태로 계산되도록 수정할 수 있다.
* 그러나 이러한 방식 역시 다음과 같은 이유에서 애플리케이션은 유연하지 않고, 변경에 취약함을 알 수 있다.
  1. 첨가물 별 가격이 변경되는 경우 기존 코드를 반드시 수정해야 한다.
  2. 첨가물이 추가되는 경우, 기존 클래스를 수정해야 한다.
  3. **일부 첨가물이 포함되지 않아야하는 음료 클래스 역시 첨가물 별 접근자와 제어자를 반드시 상속**받게 된다.

### 상속의 대안 - 구성 활용하기
* **객체 지향 프로그래밍에서 상속은 분명 강력한 기능이나, 상속의 적용이 반드시 유연한 디자인으로 이어지지는 않는다**.
  * **상속은 코드의 재사용에 초점을 맞추는 경우가 많으나, 재사용성은 오히려 구성과 위임을 통해 행동을 상속하는 방식으로 구현하는 것이 바람직**하다.
* 나아가 상속과 구성은 다음과 같은 차이점을 갖는다.
  1. **상속은 서브클래스의 행동을 컴파일 시점에 결정하므로, 변경할 수 없으면서도 모든 서브클래스가 같은 행동을 상속받도록 강요**한다.
  2. 반면, **구성을 활용한 객체의 확장은 런타임에서 동적으로 행동을 변경할 수 있도록 하는 유연성을 제공**한다.
* 이렇듯 **구성을 활용한 확장은 심지어 객체의 설계 초기에 상상하지 못했던 동작까지도 기존 클래스를 수정하지 않고 추가**할 수 있다.
  * 또한 **구성은 기능 수정시 새로운 행동 클래스를 추가하므로, 기존 코드를 전혀 수정하지 않아 휴먼에러 또는 사이드 이펙트를 미연에 방지**할 수 있다.
* **이상적인 객체는 OCP 원칙을 준수하며, 변경에는 폐쇄적이지만 확장에는 열려 있어야**한다. 
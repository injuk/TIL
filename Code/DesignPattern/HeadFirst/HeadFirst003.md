# HeadFirst
## 2022-10-23 Sun

### 상속과 클래스 폭발
* 예를 들어 커피 전문점의 애플리케이션이 다음과 같은 상속 구조를 활용한다고 가정한다.
  1. 모든 음료의 부모 역할을 하는 추상 클래스인 Beverage를 정의한다.
  2. Beverage 클래스에는 가격을 구하는 추상 메소드인 cost()를 정의한다.
  3. 모든 커피는 Beverage를 상속받아 cost()를 재정의한다.
* 그러나 이 경우, 커피에 샷을 추가하거나 크림을 얻는 등의 변화를 가할 경우 이에 대응할 수 있도록 모든 종류의 커피 클래스를 정의해야 한다.
  * 즉, **상속을 남용하면 말 그대로 클래스의 개수가 폭발하게 되는 상황이 발생**할 수 있다.
* 이러한 클래스 폭발 현상은 앞서 다루었던 디자인 원칙 중 다음의 두 가지를 어긴 전형적인 상황에 해당한다.
  1. 변화가 가능한 부분을 캡슐화하여 분리한다.
  2. 상속보다는 구성을 사용한다.

### 기존 방식을 개선하기?
* 기존의 클래스 폭발 현상을 개선하기 위해, Beverage에 각 첨가물의 유무를 의미하는 bool 변수를 둘 수 있다.
  * 이 때, 각 첨가물의 유무를 의미하는 bool 변수에 대해서는 접근자와 제어자 역시 추가되어야 한다. 
  * 또한, cost 메소드가 첨가물 별 bool 변수에 따라 첨가물의 가격을 구할 수 있도록 일반 메소드로 구체화한다.
* 이제 Beverage를 상속하는 커피 클래스의 개수를 줄이되, 각 커피 클래스의 cost()가 `커피 가격 + super.cost()`의 형태로 계산되도록 수정할 수 있다.
* 그러나 이러한 방식 역시 다음과 같은 이유에서 애플리케이션은 유연하지 않고, 변경에 취약함을 알 수 있다.
  1. 첨가물 별 가격이 변경되는 경우 기존 코드를 반드시 수정해야 한다.
  2. 첨가물이 추가되는 경우, 기존 클래스를 수정해야 한다.
  3. **일부 첨가물이 포함되지 않아야하는 음료 클래스 역시 첨가물 별 접근자와 제어자를 반드시 상속**받게 된다.

### 상속의 대안 - 구성 활용하기
* **객체 지향 프로그래밍에서 상속은 분명 강력한 기능이나, 상속의 적용이 반드시 유연한 디자인으로 이어지지는 않는다**.
  * **상속은 코드의 재사용에 초점을 맞추는 경우가 많으나, 재사용성은 오히려 구성과 위임을 통해 행동을 상속하는 방식으로 구현하는 것이 바람직**하다.
* 나아가 상속과 구성은 다음과 같은 차이점을 갖는다.
  1. **상속은 서브클래스의 행동을 컴파일 시점에 결정하므로, 변경할 수 없으면서도 모든 서브클래스가 같은 행동을 상속받도록 강요**한다.
  2. 반면, **구성을 활용한 객체의 확장은 런타임에서 동적으로 행동을 변경할 수 있도록 하는 유연성을 제공**한다.
* 이렇듯 **구성을 활용한 확장은 심지어 객체의 설계 초기에 상상하지 못했던 동작까지도 기존 클래스를 수정하지 않고 추가**할 수 있다.
  * 또한 **구성은 기능 수정시 새로운 행동 클래스를 추가하므로, 기존 코드를 전혀 수정하지 않아 휴먼에러 또는 사이드 이펙트를 미연에 방지**할 수 있다.
* **이상적인 객체는 OCP 원칙을 준수하며, 변경에는 폐쇄적이지만 확장에는 열려 있어야**한다. 

### 다섯 번째 디자인 원칙 - Open Closed Principle
```
> 클래스는 확장에는 열려 있어야 하지만, 변경에는 닫혀 있어야 한다.
> 그러나 코드에서 확장될 부분을 선택할 때에는 신중해져야 한다.
> 예를 들어, 항상 OCP를 적용하려 하는 것은 쓸데 없는 시간 낭비가 되어 필요 이상으로 복잡한 코드를 만들 가능성이 높다.
```
* 우리의 **목표는 기존 코드를 수정하지 않으면서도 확장을 통해 새로운 행동을 추가하는 것으로, 이로 인해 환경에 잘 적응하는 유연한 디자인**을 얻을 수 있다.
  * 때문에 OCP는 매우 중요한 디자인 원칙 중 하나이기도 하다.
* **확장에는 열려 있지만 변경에는 닫혀 있어야 한다는 말이 일견 모순처럼 보여질 수 있으나, 이를 가능케하는 객체 지향 기법은 많다**.
  * 나아가 객체 지향 디자인을 배우다 보면 행동을 확장할 수 있는 방법이 더욱 많다는 점을 자연스럽게 이해할 수 있다.
* 반면, **애플리케이션의 모든 부분에서 OCP를 준수할 수 있는 것은 아니며 일반적으로는 그렇게 해야할 여유와 이유도 없다**.
  * 예를 들어, OCP를 준수하기 위해서 때로는 새로운 단계의 추상화가 필요할 수 있으나 이는 오랜 시간을 들여 코드를 복잡하게 만들 수 밖에 없다.
  * 때문에 **설계 단계에서는 가장 바뀔 가능성이 높은 부분을 중점적으로 고려하고, 이에 OCP를 적용하는 것이 가장 바람직**하다.
* 애플리케이션에서 OCP를 적용할 부분을 찾아내는 작업은 충분한 객체 지향 디자인 경험과 현재 분야의 도메인 지식이 있는 경우에는 쉽게 가능하다.
  * 또한, 여러가지 디자인을 이해한다면 변경될 부분 중에서도 중요한 부분을 골라내는 안목을 기를 수 있다.

### 데코레이터 패턴이란?
* 상술한 시나리오에서 상속을 고집하는 두 방법은 다음과 크게 같은 문제를 갖는다.
  1. 필요 이상으로 많은 클래스를 정의하는 클래스 폭발로 이어질 수 있다. 
  2. 또는 일부 클래스에 전혀 필요하지 않는 기능이 추가되어야할 수도 있다.
* 이렇듯 **모든 것을 상속과 서브클래스로 해결하는 대신, 첨가물을 장식물 개념으로 생각하여 음료를 decorate 하는 방식을 고려**할 수 있다.
* 예를 들어, 모카와 휘핑 크림을 추가하는 다크 로스트 커피는 다음과 같은 흐름으로 가격을 계산해볼 수 있다.
  1. DarkRoast 객체를 생성한다.
  2. Mocha 객체로 장식한다.
  3. Whip 객체로 장식한다.
  4. 이후에 **cost()를 호출하여 가격을 계산하되, 각 커피와 첨가물의 가격은 해당 객체에 위임**한다.
* **이는 각 첨가물을 마치 래퍼 객체처럼 생각하는 것으로, 커피 객체를 첨가물 객체로 장식하는 방법과 적절히 위임하는 방법을 필수적으로 고려**해야 한다.
* 예를 들어, DarkRoast 객체는 여전히 Beverage를 상속받아 가격을 계산하는 cost 메소드를 갖는다.
  * 반면 Mocha나 Whip 객체는 데코레이터이며, 각 객체의 형식은 객체가 장식하는 또 다른 객체인 Beverage와 같은 형식을 갖는다.
  * **이렇듯 데코레이터가 자신이 장식하는 객체와 같은 형식을 갖는다는 사실은 반영이라는 표현으로 지칭**할 수도 있다.
* 각 데코레이터 객체의 형식은 장식 대상 객체의 형식을 반영하므로, 이 경우에는 첨가물인 데코레이터 객체 자체도 Beverage 객체로 간주할 수 있다.
  * 이는 **모든 첨가물 객체가 Beverage 객체를 상속하는 서브클래스이므로, 다형성에 의해 가능**하다.
  * 때문에 이렇게 데코레이터로 장식된 원본 객체는 여전히 Beverage 객체이므로, cost 메소드 호출은 여전히 가능하다.
* **가장 바깥에 위치한 데코레이터에서 cost()를 호출했다면, 해당 객체는 자신이 감싸는 객체에 계산을 위임한 후 그 결과에 자신의 값을 추가하여 반환**한다.

### 데코레이터 패턴 요약하기
* **데코레이터 객체의 부모 클래스는 자신이 장식하는 객체의 부모 클래스**이다.
  * 즉, 데코레이터는 자신이 감싸는 객체와 같은 부모 클래스를 갖기에 장식 대상 객체의 위치에 데코레이터 객체를 넣더라도 상관이 없다.
* **하나의 객체는 여러 데코레이터 객체로 감쌀 수 있으며, 런타임에서 얼마든지 필요한 데코레이터를 적용**할 수 있다.
* **데코레이터 객체는 자신이 장식하는 객체에게 행동을 위임할 수 있으며, 그 외의 추가 작업까지 수행할 수도 있다**.

## 2022-10-24 Mon
### 데코레이터 패턴의 정의
* **데코레이터 패턴은 객체에 별도의 요소를 동적으로 추가할 수 있으며, 이를 통해 서브클래스 방식보다 훨씬 유연한 기능 확장이 가능**하다.
* 또한, 데코레이터는 다음과 같은 특징을 갖는다.
  1. 데코레이터는 구성 요소의 레퍼런스를 포함한 멤버 변수를 갖는다. 
  2. **데코레이터는 자신이 장식하는 구성 요소와 같은 인터페이스 또는 추상 클래스를 구현**한다.
  3. 데코레이터에 새 메소드를 추가할 수도 있으나, 일반적으로는 장식되는 구성 요소의 메소드를 호출하기 전 또는 후에 별도의 작업을 처리하는 식으로 구성된다.

### 데코레이터에서의 추상 클래스와 인터페이스
* **데코레이터 패턴은 데코레이터가 자신이 감싸는 객체의 형식과 같아야하므로, 추상 클래스 또는 인터페이스를 활용**할 수 있다.
* 일반적으로는 인터페이스를 사용하는 것이 바람직하나, 추상 클래스를 써도 무방한 상황이라면 추상 클래스로 작업을 진행해도 문제될 것은 없다.

### 데코레이터 객체 구현하기
* **데코레이터는 추상 클래스 또는 인터페이스로 구현하되, 장식 대상 클래스를 대체할 수 있도록 공통 조상을 갖도록 정의**한다.
  * 상술한 예시에서, 커피 또는 첨가물 클래스는 모두 Beverage 클래스를 확장해야 한다.
* 이 때, 모든 데코레이터의 공통 코드를 모아 추상 데코레이터를 작성할 수 있다.
  * 이 경우에는 **추상 데코레이터만이 장식 대상 클래스와 동일한 부모 클래스를 확장하고, 구상 데코레이터는 추상 데코레이터를 확장**하게 된다.
  * Beverage와 첨가물을 예로 들어, 커피와 추상 데코레이터는 Beverage를 상속하고 모든 첨가물은 Beverage를 확장하는 추상 데코레이터를 상속받는다.
* 또한, **추상 데코레이터는 반드시 자신이 장식할 객체의 부모 클래스를 멤버 변수**로 가져야 한다.
  * 이 경우, 추상 데코레이터는 `Beverage beverage;` 형태의 멤버 변수를 초기화한다.
  * 또한 **추상 데코레이터 클래스는 생성자를 갖지 않으므로, `beverage` 변수의 초기화는 구상 데코레이터의 생성자에서 진행**할 수 있다.

### 데코레이터 패턴의 주의 사항
* 상술한 예시에서, 커피와 같은 **구상 구성 요소의 작업이 주가 되는 경우에는 데코레이터 패턴이 적절하지 않다**. 
  * 때문에 구상 구성 요소를 중심으로 동작하는 코드를 작성해야하는 경우, 데코레이터 패턴의 적용을 재고해야 한다.
  * 반면, **첨가물과 같은 추상 구성 요소로 동작하는 코드에는 데코레이터 패턴을 적용하는 것이 바람직**하다.
* 데코레이터 패턴을 적용하는 경우, 관리해야 할 객체가 늘어나므로 코딩 시 휴먼 에러가 발생할 가능성이 높아질 수 있다.
  * 때문에 팩토리 또는 빌더와 같은 또 다른 디자인 패턴을 데코레이터 패턴과 혼용하여 사용하므로, 실무에서는 이러한 휴먼 에러가 오히려 잘 발생하지 않는다.
* 데코레이터는 자신이 감싸는 객체에 대해 알아야 하는 경우에는 적절하지 않다.
  * **데코레이터는 장식하는 객체에 행동을 추가하는 용도로 정의되므로, 여러 단계의 데코레이터 대상을 파고들어 분석하는 코드는 해당 패턴의 의도에 어긋난다**.

### java.io 패키지와 데코레이터
* java.io 패키지에는 수많은 클래스가 존재하지만, 이는 데코레이터 패턴을 바탕으로 작성된 결과에 해당한다.
  * 패키지에는 추상 구성 요소인 InputStream을 기반으로 여러 구상 구성 요소와 FileInputStream과 같은 추상 데코레이터, 구상 데코레이터가 존재한다.
  * 또한, 이러한 특징을 이용하여 추상 데코레이터인 FileInputStream을 확장하는 자신만의 구상 데코레이터를 정의하여 사용할 수도 있다. 
* 이렇듯 데코레이터 패턴을 사용하면 잡다한 클래스가 너무 많아지는 단점이 있을 수 있으나, 데코레이터의 동작 원리를 이해하면 원하는 행동을 쉽게 구현할 수 있다.
  * 물론 **데코레이터 패턴의 장점을 활용하기 위해서는 각 클래스가 어떤 식으로 정의되어 어떻게 동작하는지 이해하는 과정이 전제**되어야 한다.

### 데코레이터 패턴의 단점
* 데코레이터 패턴은 디자인에 유연성을 부여하고, OCP를 충실히 준수할 수 있는 장점이 존재하지만 다음과 같은 단점 역시 존재한다.
  1. 자잘한 클래스가 너무 많이 추가되어 일견 이해하기 어려운 디자인이 만들어질 수 있다.
  2. 특정 형식에 의존하는 코드를 데코레이터에 성급히 적용할 경우, 정상적으로 동작하지 않을 수 있다.
  3. 데코레이터 패턴을 도입한 코드는 구성 요소를 초기화하기 위한 코드가 필요 이상으로 장황해질 수 있다.
* 첫 번째 단점의 경우, java.io의 예시와 같이 자잘한 클래스가 모두 추상 구성 요소의 래퍼 클래스임을 명확히 인지하는 것이 중요하다.
* 두 번째 단점의 경우, **클라이언트는 항상 데코레이터를 사용한다는 사실을 알지 못해도 문제가 없는 코드를 작성하는 것이 중요**하다.
  * 즉, 임의의 형식에 단단하게 결합되는 코드에는 데코레이터를 적용하지 않는 것이 바람직하다.
* 세 번째의 경우 **데코레이터를 적용한 코드는 구성 요소 인스턴스만 초기화하는 것으로 끝나지 않으므로, 팩토리 패턴 또는 빌더 패턴과의 혼용을 고려**해야 한다.

### 데코레이터 패턴 - 결론
```
> 데코레이터 패턴은 객체에 추가적인 요소를 동적으로 더할 수 있게 한다.
> 데코레이터 패턴을 적용할 경우, 상속과 서브클래스를 활용할 때보다 훨씬 유연한 기능 확장이 가능하다.
```
* 코드의 수정 없이 행동을 확장하는 상황을 반드시 고려할 수 있어야 하므로, 디자인 측면에서 상속을 활용한 확장은 그다지 좋은 선택이 아니다.
  * 상속 대신 구성과 위임을 활용하여 런타임에서 새로운 행동을 추가할 수 있으며, 데코레이터 패턴을 이러한 특징을 적극적으로 활용한다.
* 데코레이터 패턴은 구상 구성 요소를 감싸는 데코레이터를 통해 행동을 확장한다.
  * 이 때, **데코레이터 클래스의 형식은 반드시 해당 클래스가 감싸는 클래스 형식을 반영**해야 한다.
  * 즉, **상속 또는 인터페이스의 구현을 활용하여 자신이 감싸는 클래스와 같은 형식을 가질 수 있어야 한다**.
  * **결과로 작성된 데코레이터는 자신이 감싸는 구성 요소의 메소드를 호출한 결과에 새로운 기능을 더하여 행동을 확장**한다.
* **구성 요소의 클라이언트 코드는 데코레이터의 존재를 알 수 없어야 한다**.
  * 때문에 **클라이언트 코드 자체가 구성 요소의 구체적인 형식에 의존적인 경우는 예외**가 된다.
* **데코레이터는 OCP를 준수하는 대표적인 패턴이며, 시스템을 디자인하는 경우에는 항상 닫힌 부분과 새로 확장되는 부분을 명확히 구분하는 것이 바람직**하다.
* 반면, **데코레이터 패턴을 사용하면 자잘한 객체가 많이 추가되어 코드가 필요 이상으로 복잡해질 가능성이 존재**한다.
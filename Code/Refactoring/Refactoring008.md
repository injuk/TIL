# Refactoring
## 2022-04-21 Thu

## 데이터 조직화
* 데이터 구조는 프로그램에서 중요한 역할을 수행하는 중요한 요소이다.
* 하나의 값이 여러 목적으로 사용된다면 혼란스러울 수 있으며, 다픈 프로그램 요소와 마찬가지로 명명도 중요하다.
  * 또는, 변수 자체를 완전히 없애버리는 것이 나을 때도 있다.

### 변수 쪼개기
* 변수는 다양한 용도로 사용되며, 게 중에는 변수에 값을 여러 번 대입해야만 하는 경우도 존재한다.
  * 예를 들어, 고전적인 for 반복문의 i와 같은 수집 변수가 그렇다.
* 그 외에도 **변수는 긴 코드의 결과를 저장했다가 추후에 참조하려는 목적으로도 사용되며, 이러한 변수는 반드시 값을 한 번만 대입**해야 한다.
* 반면, 대입이 두 번 이상 이루어지는 변수는 여러 역할을 수행한다는 신호이므로 반드시 쪼개야 한다.
  * 이 **규칙에 예외는 없으며, 언제나 역할 하나에 변수 하나를 유지**해야 한다.
  * 너무 많은 용도로 사용되는 변수는 가독성을 크게 떨어트리고, 개발자를 혼란스럽게 한다.

### 변수 쪼개기 - 절차
1. 변수를 선언한 곳과 값을 처음 대입하는 곳에서 변수의 이름을 바꾸어 준다.
   * 해당 변수는 수집 변수가 아니어야 한다.
   * 이 때, 가능하다면 불변 변수로 선언한다.
2. 변수에 두 번째로 값을 대입하는 곳까지의 모든 참조를 새로운 변수의 이름으로 변경한다.
3. 두번째 대입문에서 변수를 원래의 이름으로 다시 선언한 후, 테스트를 진행한다.
4. 이 과정을 반복하되, 매 반복마다 변수를 새로운 이름으로 선언한다.
   * 또한, 다음 번 대입문과 마주칠 때까지 참조하는 모든 변수는 새로운 변수의 이름으로 변경한다.
5. 상술한 과정을 마지막 대입문까지 반복하여 진행한다.

### 필드의 이름 변경하기
* 무엇이든지 이름은 중요하지만, 프로그램 곳곳에서 사용되는 레코드 구조체의 필드 이름들은 특히 더 중요하다.
* 데이터 구조는 프로그램에서 무슨 일이 발생하는지 이해하는 열쇠이므로, 프로그램을 이해하는 데에 큰 기여를 해줄 수 있다.
* 데이터 구조가 중요한 만큼 반드시 깔끔하게 관리해야 한다.
  * 데이터 구조 역시 다른 프로그램 요소와 마찬가지로 개발을 진행함에 따라 데이터를 더욱 잘 이해하게 된다.
  * 따라서, 깊어진 이해를 바탕으로 반드시 프로그램에 반영해주어야 한다.
* 리팩토링을 적용하는 과정에서 레코드의 필드 이름을 바꾸고 싶을 수 있으며, 이는 게터와 세터에서도 마찬가지이다.
  * **게터와 세터는 클래스를 사용하는 클라이언트 입장에서 필드와 다를 바가 없다**.
  * 때문에 게터와 세터의 이름 변경 역시 레코드 구조체의 필드 이름 변경과 같은 정도로 중요하다.
* **데이터 구조 자체를 불변으로 만들 수 있는 언어도 있으며, 이러한 언어에서는 캡슐화 대신 데이터 구조의 값을 복제하여 새로운 이름을 명명**한다.
* 가변 데이터 구조를 사용하는 경우, 데이터를 복제하는 행위는 재앙으로 이어질 수 있다.
  * 불변 데이터 구조가 널리 사용되게 된 직접적인 이유 역시 이 재앙을 피하기 위해서이다.

### 필드의 이름 변경하기 - 절차
1. 레코드의 유효 범위가 제한적인 경우, 필드에 접근하는 모든 코드를 수정한 후에 테스트를 진행한다.
   * 여기에 해당된다면 이후의 단계는 건너뛰도록 한다.
2. 레코드가 캡슐화되지 않은 경우, 우선 캡슐화한다.
3. 캡슐화된 객체 내부의 private 필드 이름을 변경하고, 이에 맞게 내부 메소드들을 수정한다.
4. 테스트를 진행한다.
5. 생성자의 매개변수 중 필드와 이름이 겹치는 항목이 존재한다면 함수 선언 바꾸기로 변경한다.
6. 접근자들의 이름도 바꾸어준다.

### 파생 변수를 질의 함수로 변경하기
* 가변 데이터는 소프트웨어에 문제를 일으키는 가장 큰 골치덩어리에 속한다.
  * 가변 데이터는 서로 다른 두 코드를 괴상하게 결합하기도 하며, 이로 인해 원인을 찾기 어려운 문제가 발생할 수 있다.
* 그렇다고 **가변 데이터를 완전히 배제하는 것은 현실적으로 불가능하므로, 가변 데이터의 유효 범위를 가능한 한 좁혀야 한다**.
* 좋은 방법 중 하나로, 값을 쉽게 계산할 수 있는 변수들은 모두 제거할 수 있다.
  * 이러한 경우, 계산 과정을 보여주는 코드 자체가 데이터의 의미를 더욱 분명히 드러내는 경우가 잦다.
  * 또는, 변경된 값을 깜빡하고 결과 변수에 반영하지 않는 실수도 막아준다.
* 반면, 피연산자 데이터가 불변이라면 계산 결과도 일정하므로 역시 불변화할 수 있다.
  * 때문에 새로운 데이터 구조를 생성하는 변형 연산을 계산 코드로 대체할 수 있더라도 건드리지 않고 그대로 두는 것이 좋을 수 있다.
* 변형 연산은 크게 다음과 같이 분류된다.
  1. 데이터 구조를 감싸고, 데이터에 기초하여 계산 결과를 속성으로 제공하는 객체.
  2. 데이터 구조를 감싸고 다른 데이터 구조로 변환하여 반환하는 함수.
  * 원본 데이터가 가변이고, 파생 데이터 구조의 수명을 관리해야 하는 상황에서는 객체를 사용하는 방식이 확실히 유리하다.
* 그러나 소스 테이터가 불변이거나, 파생 데이터를 잠시 사용하고 버릴 것이라면 어느 방식을 사용하더라도 무방하다.

### 파생 변수를 질의 함수로 변경하기 - 절차
1. 변수의 값이 변경되는 모든 지점을 찾아낸 후, 변수 쪼개기를 활용하여 각 갱신 지점에서 변수를 분리한다.
2. 해당 변수의 값을 계산해주는 함수를 만든다.
3. 해방 변수가 사용되는 모든 곳에 어서션을 추가하고, 함수의 계산 결과가 변수의 값과 똑같은지 확인한다.
   * 필요한 경우, 변수 캡슐화하기를 우선 적용하여 어서션이 들어갈 장소를 마련한다.
4. 테스트를 진행한다.
5. 변수를 읽는 코드를 모두 함수 호출로 대체한 후, 다시 테스트를 진행한다.
6. 변수를 읽어들이는 코드는 모두 함수 호출로 대체한다.
7. 테스트를 진행한다.
8. 변수를 선언하고 갱신하는 코드를 죽은 코드 제거하기 기법으로 제거한다.

## 2022-04-22 Fri
### 참조를 값으로 바꾸기
* 객체를 다른 객체에 중첩하면 내부 객체를 참조 또는 값으로 취급할 수 있다.
  * 둘 사이에는 내부 객체의 속성을 갱신하는 방식에서 큰 차이가 있다.
* 참조로 다루는 경우에는 내부 객체는 그대로 둔 체 객체의 속성만 갱신할 수 있지만, 값으로 다루는 경우에는 새로운 속성을 담는 객체로 통채로 대체할 수 있다.
* 필드를 값으로 다루는 경우, 내부 객체의 클래스를 수정하여 값 객체로 만들 수 있다.
* **값 객체는 불변이므로 자유롭게 활용하기 쉽고, 값을 복제하여 이곳 저곳에서 활용하더라도 서로 간의 참조를 관리할 필요가 없다**.
  * 때문에 값 객체는 분산 시스템, 동시성 시스템에서 특히 유용하다.
* **값으로 취급하고자 하는 객체는 세터를 제거하여 불변으로 만들고 동치성 비교 메소드를 적절히 재정의하는 것으로 진짜 '값'으로 취급할 수 있다**.
* 반면 **값 객체의 이러한 특성으로 인해 리팩토링을 적용할 수 없는 상황도 발생할 수 있다**.
  * 예를 들어, 특정 객체를 여러 객체가 공유하고 변경 상황을 객체 전체가 알 수 있어야 하는 경우 공유 객체는 참조로 다루어져야 한다.

### 참조를 값으로 바꾸기 - 절차
1. 후보 클래스가 불변인지, 또는 불변이 될 수 있는지 확인한다.
2. 각각의 세터를 하나씩 제거해간다.
3. 값 객체의 필드들을 활용하는 동치성 비교 메소드를 정의한다.
   * 대부분의 언어는 이러한 상황에 사용할 수 있도록 오버라이딩 가능한 동치성 비교 메소드를 제공한다.
   * 동치성 비교 메소드를 오버라이드하는 경우, 일반적으로 해시코드 생성 메소드도 함께 오버라이드하는 것이 바람직하다.

### 값을 참조로 바꾸기
* 하나의 데이터 구조 안에 논리적으로 같은 제 3의 데이터 구조를 참조하는 레코드가 여럿일 수 있다.
* 이 때, 해당 객체는 값 또는 참조로 다룰 수 있다.
  1. 값으로 다루는 경우, 데이터 구조는 각각의 레코드마다 복사된다.
  2. 참조로 다루는 경우, 여러 레코드는 하나의 데이터 구조를 참조한다.
* 해당 **데이터 구조를 갱신할 일이 없다면 어떤 방식을 활용해도 무방**하다.
  * 값으로 다루는 경우, 많은 복사본으로 인해 메모리 부족이 발생할 수도 있으나 이는 드물게 발생하는 일이다.
* 반면 **논리적으로 같은 데이터를 물리적으로 복사하여 사용하는 경우 가장 문제되는 상황은 데이터를 갱신해야할 때 발생**한다.
  * 값으로 다루는 경우, 모든 복제본을 찾아 갱신해야 하며 하나라도 누락하는 경우 일관성은 깨지게 된다.
  * 이런 경우, 갱신된 내용을 전체에 반영하기 위해 복제된 데이터들을 모두 참조로 바꾸는 것이 바람직하다.
* 값을 참조로 바꾸면 엔티티 당 객체가 하나만 존재하게 되므로, 일반적으로 이러한 객체들을 모아두고 클라이언트들의 접근을 관리해주는 일종의 저장소가 필요하다.
  * 예를 들어 각 엔티티를 표현하는 객체를 단 한 번만 생성하고, 객체가 필요한 곳은 모두 해당 저장소로부터 얻어 사용하게 된다.

### 값을 참조로 바꾸기 - 절차
1. 같은 부류에 속하는 객체들을 보관할 저장소를 정의한다.
   * 이 때, 이러한 역할을 수행하는 저장소가 이미 있다면 해당 단계를 생략한다.
2. 생성자에서 이러한 부류의 객체들 중 특정한 객체를 정확히 찾아내는 방법이 있는지 확인한다.
   * 또는 목록을 미리 만들어 저장소 객체에 저장해두고, 정보를 읽어들일 때 연결하는 방법도 고려할 수 있다.
3. 호스트 객체의 생성자들을 수정하여 필요한 객체를 해당 저장소에서 찾도록 한다.
   * 이 때, 하나를 수정할 때마다 테스트를 진행한다.

### 매직 리터럴 바꾸기
* 매직 리터럴이란 소스 코드의 여러 곳에 등장하는 일반적인 리터럴 값을 말하며, 예를 들어 중력 상수 9.80665가 있다.
* 이러한 매직 리터럴은 코드를 읽는 사람이 값의 의미를 모른다면 숫자 자체로는 의미를 명확히 알려주지 못한다.
* 대부분의 경우 코드 자체가 뜻을 분명하게 드러내는 것이 좋으므로, 다음과 같은 방식을 고려한다.
  1. 상수를 정의하고 숫자 대신 상수를 사용한다.
  2. 상수가 특별한 비교 로직에 사용될 가능성이 높은 경우, 적절한 이름을 가진 함수 호출로 변경한다.
* 반면, 상수를 과용하는 것은 값을 그대로 쓰는 것과 다를 바 없는 경우가 양산되므로 적절하지 못하다.
  * 또는 리터럴이 함수 하나에서만 사용되고, 함수가 자체적인 맥락 정보를 충분히 제공할 수 있다면 상수로 바꾸어 얻는 이득이 적을 수 있다.

### 매직 리터럴 바꾸기 - 절차
1. 상수를 선언하고 매직 리터럴을 대입한다.
2. 해당 리터럴이 사용되던 지점을 모두 확인한다.
3. 모든 지점 각각에서 리터럴이 새로운 상수와 같은 의미로 사용되었는지 확인한다.
   * 이 때, 같은 의미라면 상수로 대체한 후 테스트를 진행한다.
   * 가능하다면 상수의 값을 변경하고, 관련된 테스트가 모두 바뀐 값에 맞는 결과를 내는지 확인하는 것으로 간단히 테스트를 진행할 수 있다.
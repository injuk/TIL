# Refactoring
## 2022-04-21 Thu

## 데이터 조직화
* 데이터 구조는 프로그램에서 중요한 역할을 수행하는 중요한 요소이다.
* 하나의 값이 여러 목적으로 사용된다면 혼란스러울 수 있으며, 다픈 프로그램 요소와 마찬가지로 명명도 중요하다.
  * 또는, 변수 자체를 완전히 없애버리는 것이 나을 때도 있다.

### 변수 쪼개기
* 변수는 다양한 용도로 사용되며, 걔 중에는 변수에 값을 여러 번 대입해야만 하는 경우도 존재한다.
  * 예를 들어, 고전적인 for 반복문의 i와 같은 수집 변수가 그렇다.
* 그 외에도 **변수는 긴 코드의 결과를 저장했다가 추후에 참조하려는 목적으로도 사용되며, 이러한 변수는 반드시 값을 한 번만 대입**해야 한다.
* 반면, 대입이 두 번 이상 이루어지는 변수는 여러 역할을 수행한다는 신호이므로 반드시 쪼개야 한다.
  * 이 **규칙에 예외는 없으며, 언제나 역할 하나에 변수 하나를 유지**해야 한다.
  * 너무 많은 용도로 사용되는 변수는 가독성을 크게 떨어트리고, 개발자를 혼란스럽게 한다.

### 변수 쪼개기 - 절차
1. 변수를 선언한 곳과 값을 처음 대입하는 곳에서 변수의 이름을 바꾸어 준다.
   * 해당 변수는 수집 변수가 아니어야 한다.
   * 이 때, 가능하다면 불변 변수로 선언한다.
2. 변수에 두 번째로 값을 대입하는 곳까지의 모든 참조를 새로운 변수의 이름으로 변경한다.
3. 두번째 대입문에서 변수를 원래의 이름으로 다시 선언한 후, 테스트를 진행한다.
4. 이 과정을 반복하되, 매 반복마다 변수를 새로운 이름으로 선언한다.
   * 또한, 다음 번 대입문과 마주칠 때까지 참조하는 모든 변수는 새로운 변수의 이름으로 변경한다.
5. 상술한 과정을 마지막 대입문까지 반복하여 진행한다.

### 필드의 이름 변경하기
* 무엇이든지 이름은 중요하지만, 프로그램 곳곳에서 사용되는 레코드 구조체의 필드 이름들은 특히 더 중요하다.
* 데이터 구조는 프로그램에서 무슨 일이 발생하는지 이해하는 열쇠이므로, 프로그램을 이해하는 데에 큰 기여를 해줄 수 있다.
* 데이터 구조가 중요한 만큼 반드시 깔끔하게 관리해야 한다.
  * 데이터 구조 역시 다른 프로그램 요소와 마찬가지로 개발을 진행함에 따라 데이터를 더욱 잘 이해하게 된다.
  * 따라서, 깊어진 이해를 바탕으로 반드시 프로그램에 반영해주어야 한다.
* 리팩토링을 적용하는 과정에서 레코드의 필드 이름을 바꾸고 싶을 수 있으며, 이는 게터와 세터에서도 마찬가지이다.
  * **게터와 세터는 클래스를 사용하는 클라이언트 입장에서 필드와 다를 바가 없다**.
  * 때문에 게터와 세터의 이름 변경 역시 레코드 구조체의 필드 이름 변경과 같은 정도로 중요하다.
* **데이터 구조 자체를 불변으로 만들 수 있는 언어도 있으며, 이러한 언어에서는 캡슐화 대신 데이터 구조의 값을 복제하여 새로운 이름을 명명**한다.
* 가변 데이터 구조를 사용하는 경우, 데이터를 복제하는 행위는 재앙으로 이어질 수 있다.
  * 불변 데이터 구조가 널리 사용되게 된 직접적인 이유 역시 이 재앙을 피하기 위해서이다.

### 필드의 이름 변경하기 - 절차
1. 레코드의 유효 범위가 제한적인 경우, 필드에 접근하는 모든 코드를 수정한 후에 테스트를 진행한다.
   * 여기에 해당된다면 이후의 단계는 건너뛰도록 한다.
2. 레코드가 캡슐화되지 않은 경우, 우선 캡슐화한다.
3. 캡슐화된 객체 내부의 private 필드 이름을 변경하고, 이에 맞게 내부 메소드들을 수정한다.
4. 테스트를 진행한다.
5. 생성자의 매개변수 중 필드와 이름이 겹치는 항목이 존재한다면 함수 선언 바꾸기로 변경한다.
6. 접근자들의 이름도 바꾸어준다.

### 파생 변수를 질의 함수로 변경하기
* 가변 데이터는 소프트웨어에 문제를 일으키는 가장 큰 골치덩어리에 속한다.
  * 가변 데이터는 서로 다른 두 코드를 괴상하게 결합하기도 하며, 이로 인해 원인을 찾기 어려운 문제가 발생할 수 있다.
* 그렇다고 **가변 데이터를 완전히 배제하는 것은 현실적으로 불가능하므로, 가변 데이터의 유효 범위를 가능한 한 좁혀야 한다**.
* 좋은 방법 중 하나로, 값을 쉽게 계산할 수 있는 변수들은 모두 제거할 수 있다.
  * 이러한 경우, 계산 과정을 보여주는 코드 자체가 데이터의 의미를 더욱 분명히 드러내는 경우가 잦다.
  * 또는, 변경된 값을 깜빡하고 결과 변수에 반영하지 않는 실수도 막아준다.
* 반면, 피연산자 데이터가 불변이라면 계산 결과도 일정하므로 역시 불변화할 수 있다.
  * 때문에 새로운 데이터 구조를 생성하는 변형 연산을 계산 코드로 대체할 수 있더라도 건드리지 않고 그대로 두는 것이 좋을 수 있다.
* 변형 연산은 크게 다음과 같이 분류된다.
  1. 데이터 구조를 감싸고, 데이터에 기초하여 계산 결과를 속성으로 제공하는 객체.
  2. 데이터 구조를 감싸고 다른 데이터 구조로 변환하여 반환하는 함수.
  * 원본 데이터가 가변이고, 파생 데이터 구조의 수명을 관리해야 하는 상황에서는 객체를 사용하는 방식이 확실히 유리하다.
* 그러나 소스 테이터가 불변이거나, 파생 데이터를 잠시 사용하고 버릴 것이라면 어느 방식을 사용하더라도 무방하다.

### 파생 변수를 질의 함수로 변경하기 - 절차
1. 변수의 값이 변경되는 모든 지점을 찾아낸 후, 변수 쪼개기를 활용하여 각 갱신 지점에서 변수를 분리한다.
2. 해당 변수의 값을 계산해주는 함수를 만든다.
3. 해방 변수가 사용되는 모든 곳에 어서션을 추가하고, 함수의 계산 결과가 변수의 값과 똑같은지 확인한다.
   * 필요한 경우, 변수 캡슐화하기를 우선 적용하여 어서션이 들어갈 장소를 마련한다.
4. 테스트를 진행한다.
5. 변수를 읽는 코드를 모두 함수 호출로 대체한 후, 다시 테스트를 진행한다.
6. 변수를 읽어들이는 코드는 모두 함수 호출로 대체한다.
7. 테스트를 진행한다.
8. 변수를 선언하고 갱신하는 코드를 죽은 코드 제거하기 기법으로 제거한다.
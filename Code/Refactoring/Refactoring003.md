# Refactoring
## 2022-04-13 Wed

## 코드 스멜
* 적용 방법을 아는 것과 적시에 적용할 줄 아는 것은 다르므로, 리팩토링을 언제 시작하고 언제 그만할지를 판단하는 일은 리팩토링의 원리 못지 않게 중요하다.
* 리팩토링할 시점을 결정하는 데에는 냄새라는 표현을 사용할 수 있다.
  * **리팩토링이 필요한 코드들에서는 일정한 패턴이 드러나며, 이러한 패턴을 냄새라고 표현**하였다.

### 이상한 이름
* **코드는 단순하고 명료하게 작성해야 하며, 코드를 명료하게 만드는 가장 중요한 요소 중 하나는 이름**이다.
  * 함수, 모듈, 변수, 클래스 등은 이름만 보고도 무엇을 하고 어떻게 사용해야하는지 명확하게 알 수 있도록 숙고하여 명명해야 한다.
  * 코드에서 명명된 이름이 끼치는 영향은 어마어마하므로, 자주 사용되는 리팩토링 기법 역시 이름의 변경과 관련이 있다.
* 혼란스러운 이름을 적절히 정리하는 과정에서 코드는 훨씬 간결해질 수 있다.
```
> 이름을 바꾸는 것은 단순히 명명하는 연습이 아니며, 적절한 이름이 떠오르지 않는다는 것은 설계에 근본적인 문제가 숨어 있음을 암시하는 경우가 많다.
```

### 중복된 코드
* 똑같은 코드 구조가 여러 곳에서 반복된다면 하나로 통합하는 것이 바람직하다.
* 코드가 중복되면 각각을 확인할 때마다 서로의 차이점을 확인해야하는 부담이 있으며, 그 중 하나를 수정하는 경우 전체 코드를 확인해야 하는 문제가 있다.

### 너무 긴 함수
* **오랜 기간 잘 활용되는 프로그램들은 모두 짧은 함수로 구성된다는 공통점**이 있다.
* 코드를 이해하고, 공유하고, 선택하기 쉬워진다는 장점은 모두 짧게 구성된 함수에서 비롯된다.
* 프로그래밍의 초창기에는 서브루틴을 호출하는 비용이 컸기에 짧은 함수를 꺼렸으나, 최근의 언어는 프로세스 내부에서의 함수 호출 비용을 사실상 없애버렸다.
* 그러나 짧은 함수는 여전히 프로그램을 왔다갔다 하며 코드를 파악해야한다는 단점이 존재한다.
  * **이를 극복하는 가장 확실한 방법은 좋은 이름을 작성하는 것이며, 적절히 명명된 함수는 본문 코드를 볼 필요조차 없어진다**.
  * 또한, 이를 위해서라도 함수는 훨씬 더 적극적으로 쪼개져야만 한다!
* 주석을 달아야만 할 부분도 모두 함수로 만드는 것이 바람직하다.
  * 함수 본문에는 주석으로 설명하려던 코드를 작성한다.
  * **함수의 이름은 반드시 동작 방식이 아닌 의도가 담기도록 명명**한다.
* 함수를 추출하는 과정에서의 **핵심은 함수의 길이가 아닌 함수의 목적 또는 의도와 구현 코드의 괴리가 얼마나 큰가**이다.
  * 즉, **무엇을 하는지를 코드가 적절히 설명하지 못할수록 함수화하는 것이 바람직**하다.
* 함수가 매개변수와 임시 변수를 너무 많이 사용한다면 함수 추출 작업에 방해가 될 수 있으므로, 적절한 기법을 통해 임시 변수와 매개변수의 수를 줄이도록 한다.
* **추출하기에 적절한 코드 덩어리를 선택하는 좋은 방법 중 하나는 주석을 참고하는 것**이다.
  * 이는 주석이 코드만으로 목적을 이해하기 어려운 부분에 달려 있는 경우가 많기 때문이다.
  * 주석이 설명하는 코드는 함수 본문으로 빼내고, 함수의 이름은 주석을 토대로 명명한다.
  * **비록 코드가 단 한 줄 뿐이더라도 주석을 통해 설명할 필요가 있다면 함수로 추출하는 것이 바람직**하다.

### 너무 긴 매개변수 목록
* 매개변수 목록이 너무 길어지면 그 자체로 이해하기 어려워지는 경우가 많다.
* **클래스는 매개변수 목록을 줄이는 효과적인 방법이기도 하며, 특히 여러 함수가 특정한 매개변수의 값을 공통으로 사용할 때 유용**하다.
  * 이 경우, 여러 함수를 하나의 클래스로 묶고 공통의 값을 클래스의 필드로 정의하도록 한다.

### 전역 데이터
* **전역 데이터는 전역 변수 뿐만 아니라 클래스 변수와 싱글톤을 포함하는 용어**이다.
* **전역 데이터는 개발자가 겪을 수 있는 코드 냄새 중 가장 지독한 악취**이다.
* 전역 데이터는 코드 어느 곳에서나 수정할 수 있는데에 반해, 값을 누가 수정했는지 찾아낼 메커니즘이 없다는 문제점이 있다.
  * 최악의 경우, 버그는 끊임없이 발견되는데 원인을 찾기는 굉장히 어려울 수 있다.
* **전역 데이터는 아주 조금만 존재하더라도 캡슐화하는 것이 좋으며, 그래야만 소프트웨어가 진화하는 데에 수반되는 변화에 대처**할 수 있다.

### 가변 데이터
* 값을 다른 곳에서 설정할 수 있는 가변 데이터 역시 고약한 악취에 속한다.
* 코드의 다른 곳에서 사용된다는 사실을 인식하지 못한 채 가변 데이터의 값을 수정한다면 프로그램은 오작동하기 쉽다.
  * 특히, 이러한 문제가 아주 드문 조건에서만 발생한다면 원인을 알아내기는 더욱 어려워진다.
* 변수의 유효 범위가 몇 줄에 불과하다면 가변 데이터라도 큰 문제가 없지만, 유효범위가 넓다면 변수를 수정하는 코드들의 유효범위를 제한할 필요가 있다.

### 뒤엉킨 변경
* 소프트웨어의 구조는 변경하기 쉬운 형태로 조직되어야하며, 코드를 수정할 때에는 시스템에서 딱 한 군데만 수정하는 것이 이상적이다.
* 그러나 **단일 책임 원칙이 제대로 지켜지지 않은 경우, 임의의 기능 하나를 수정하기 위해 코드의 이곳 저곳을 수정해야할 수도 있다**.

### 산탄총 수술
* 산탄총 수술은 하나의 맥락에 맞는 코드가 모듈의 이곳 저곳에 흩어진 상태이다.
* 이러한 코드 냄새는 코드를 수정할 때마다 자잘하게 수정해야하는 클래스가 여기저기에 퍼져있을 때에 풍긴다.
* 이 경우, 함께 변경되는 대상을 모두 한 모듈에 묶어두는 식으로 대응할 수 있다.
* 뒤엉킨 변경은 맥락에 맞지 않는 코드가 하나의 모듈에 섞여 들어가 단일 책임 원칙을 위배한다는 점에서 차이가 있다.
  * 때문에 **뒤엉킨 변경은 코드를 컨텍스트 별로 분리해야 하며, 산탄총 수술은 컨텍스트에 맞는 코드를 한 곳으로 모으는 식으로 대응**해야 한다.

### 기능의 편애
* 프로그램을 모듈화하는 과정에서 코드를 여러 영역으로 나누고, 같은 영역 안에서의 응집도는 높이되 영역 간의 결합도는 낮추는 데에 주력해야 한다.
* 그러나 어떤 함수가 자신이 속한 모듈의 함수나 데이터보다 다른 모듈의 함수나 데이터와 상호작용하는 일이 더 많다면, 이는 기능 편애에 해당하는 코드 냄새이다.
* 이러한 함수는 데이터와 가까이 있고 싶어하므로 원하는 위치로 옮겨주는 식으로 리팩토링할 수 있다.
  * 함수를 옮길 위치가 명확하지 않은 경우, 가장 많은 데이터를 포함하는 모듈로 옮기도록 한다.
  * 또는 옮기려는 함수를 여러 조각으로 쪼갠 후에 각각 어울리는 모듈로 옮기는 방식을 선택할 수도 있다.

### 데이터 뭉치
* 데이터들은 서로 어울리길 좋아하며 뭉치려고 하는 특징이 있다.
* 이렇게 **몰려다니는 데이터 뭉치는 클래스라는 별도의 보금자리를 마련해주는 것이 좋다**.
* **값들이 데이터 뭉치인지 확인하려면 값 중 하나를 임의로 삭제해보고, 나머지 데이터만으로 의미를 가질 수 있는지를 확인**할 수 있다.
  * 의미가 없다면 해당 데이터 뭉치는 클래스로 환생하는 것이 바람직하다.
* **데이터 뭉치를 클래스로 만드는데에 성공했다면, 해당 클래스로 옮기면 좋을 동작들을 살펴보는 것이 바람직**하다.
  * 이러한 연계 과정은 상당한 중복을 없애며, 향후 개발을 가속하는 유용한 클래스를 탄생시킬 수도 있다.
  * 이렇듯 클래스를 이용하면 코드 냄새 대신 좋은 향기를 뿌릴 기회가 생긴다.

### 강박적인 기본형 사용
* 대부분의 프로그래밍 언어는 정수, 부동소수점, 문자열 등의 다양한 기본형을 제공한다.
* **개발자들 중에는 요구사항에 적절한 타입을 새로 정의하는 것보다 기본형에 집착하는 사람이 많으며, 이는 분명한 코드 냄세에 해당**한다.
* 이러한 현상은 특히 문자열에서 두드러지며, 자료형을 항상 문자열로 표현하는 것보다는 적절한 클래스를 작성하는 것이 바람직하다.

### 반복적인 switch
* switch case와 길게 나열된 if else 등, 똑같은 조건부 로직이 여러 곳에서 반복 등장하는 코드는 코드 냄세에 해당한다.
* 중복된 switch 문은 조건 절을 하나 추가할 때마다 모든 switch 문을 수정해야 하므로 문제가 될 수 있다.
  * **이를 극복하기 위해 코드를 최신 스타일로 바꾸어주는 다형성을 활용**해볼 수 있다.

### 반복문
* **무분별하게 사용되는 반복문은 filter나 map 등의 파이브파링 연산을 적용하도록 수정하는 것이 바람직**하다.
* 파이프라인 연산을 통해 코드에서 각 원소들이 어떻게 처리되는지 쉽게 파악할 수 있다.

### 성의 없는 요소
* 요소란 프로그래밍 언어 차원에서 지원하는 메소드, 클래스, 인터페이스 등의 구조이다.
* 개발자는 코드의 구조를 잡기 위해 프로그램 요소를 사용하는 것을 선호하지만, 굳이 구조를 활용하지 않아도 무방한 경우도 존재한다.
  * 예를 들어, 본문 코드를 그대로 쓰는 것과 다를 바 없는 함수나 메소드가 하나 뿐인 클래스 등이 이에 포함된다.
* 이러한 프로그램 요소는 적절한 리팩토링 기법을 활용하여 제거하는 것이 바람직하다.

### 추측성 일반화
* 나중에 사용할지도 모른다는 추측으로 당장은 필요 없는 모든 종류의 후킹 포인트와 특이 케이스 처리 로직을 작성해둔 코드는 코드 냄새에 해당한다.
  * 예를 들어, 당장은 호출 지점이 하나 뿐이지만 미래를 위해 매개 변수 처리한 함수가 이에 포함된다.
  * 그 결과는 언제나 이해하거나 관리하기 어려운 코드만이 남는다.
* **당장 걸리적거리는 코드는 눈 앞에서 제거하되, 나중에 필요해진 시점에 추가하는 것이 바람직**하다.

### 임시 필드
* 간혹 특정한 상황에서만 값이 설정되는 필드를 갖는 클래스가 있다.
* 그러나 객체를 사용하는 클라이언트 입장에서, 모든 필드가 채워져 있으리라 기대하는 것이 일반적이다.
* 때문에 임시 필드를 갖도록 작성된 코드는 이해를 어렵게 하는 코드 냄새에 해당하므로, 필드가 적절한 위치를 찾도록 리팩토링해야 한다.

### 메시지 체이닝
* 메시지 체인은 클라이언트가 임의의 객체를 통해 다른 객체를 얻어낸 뒤, 얻은 객체에서 또 다른 객체를 요청하는 식의 코드를 말한다.
  * 즉, a.b().c().d();와 같이 다른 객체를 요청하는 작업이 연쇄적으로 이어지는 코드이다.
* 이러한 코드는 클라이언트가 객체 내비게이션 구조에 종속되었음을 의미하므로, 메시지 체인의 다양한 연결점에 리팩토링을 적용하여 문제를 해결할 수 있다.

### 중개자
* 객체의 대표적인 기능 중 하나로 외부로부터 내부 구현을 숨기는 캡슐화가 있으며, 캡슐화하는 과정에서는 위임이 자주 활용된다.
* 그러나 클래스가 제공하는 메소드 중 위임이 너무 많아진다면 코드 냄새가 될 수 있다.
  * 이러한 경우, 실제로 일을 하는 객체와 직접 소통할 수 있도록 리팩토링을 적용할 수 있다.

### 내부자 거래
* 개발자는 모듈 사이의 결합도를 낮추고 싶어하며, 모듈 간의 통신이 많아질수록 결합도를 우려한다.
  * 결합도는 애플리케이션의 기능을 위해 어느 정도 생길 수 밖에 없지만, 그 양은 최소화하고 모두 투명하게 처리해야 한다.
* 은밀히 데이터를 주고받는 모듈이 있다면 리팩토링을 통해 둘을 떼어놓은 후 사적으로 처리되는 부분을 줄이도록 한다.
* 여러 모듈이 같은 관심사를 공유하는 경우, 공통 부분을 처리하는 제 3의 모듈을 작성하거나 다른 모듈이 중간자 역할을 하도록 수정한다.

### 거대한 클래스
* 하나의 클래스가 너무 많은 일을 수행하다보면 필드의 수가 늘어나기 쉽고, 필드의 수가 많은 클래스에는 중복된 코드가 생기기 쉽다.
  * 이 경우, 클래스를 추출하여 필드들의 일부를 따로 묶는 식으로 클래스를 분리할 수 있다.
* 필드가 너무 많은 클래스와 마찬가지로 코드량이 너무 많은 클래스도 중복 코드와 혼동을 일으킬 여지가 크다.
  * 이러한 문제의 가장 간단한 해결책은 클래스 안에서 자체적으로 중복을 제거하는 것이다.
  * 또한, 클라이언트들이 거대한 클래스를 어떻게 사용하는지 패턴을 파악하여 클래스를 여러 기능 그룹으로 묶고, 각 기능 그룹을 별도의 클래스로 추출할 수 있다.

### 서로 다른 인터페이스의 대안 클래스들
* 클래스를 사용하는 과정에서의 큰 장점은 필요에 따라 언제든지 다른 클래스로 교체할 수 있다는 사실이다.
  * 단, 이를 위해서는 교체 대상 인터페이스가 같아야 한다.
* 필요한 경우, 메소드 시그니쳐를 일치시키는 리팩토링을 적용할 수 있다.

### 데이터 클래스
* 데이터 클래스란 데이터 필드와 게터, 세터 등의 접근자로만 구성된 클래스이다.
* 이러한 데이터 클래스는 데이터 저장 용도로만 사용되므로, 다른 클래스가 너무 깊이까지 관여하는 경우가 많다.
  * 이러한 클래스의 public 필드는 캡슐화하여 숨기고, 변경하면 안되는 필드의 세터를 제거하는 것이 바람직하다.
* 다른 클래스에서 데이터 클래스의 게터나 세터를 사용하는 메소드를 찾아 데이터 클래스로 옮길수 있는지를 고민할 수도 있다.
  * 통채로 옮기지 못하는 경우, 옮길 수 있는 부분만 별도의 메소드로 뽑아내어 옮길 수도 있다.
* 또한, 데이터 클래스는 필요한 동작이 엉뚱한 곳에 정의되어 있다는 신호일 수도 있다.
  * 이러한 경우, 클라이언트 코드를 데이터 클래스에 옮기는 것만으로도 크게 개선될 수 있다.
* 반면 **불변 필드는 굳이 캡슐화할 필요가 없으며, 불변 데이터로부터 나오는 정보는 게터 없이 필드 자체를 공개해도 무방**하다.

### 상속 포기
* 서브클래스는 부모로부터 메소드나 데이터를 물려받지만, 때로는 이를 원치 않는 경우가 생길 수 있다.
  * 예를 들어, 부모의 멤버 중 일부만 상속받고 싶은 경우를 말한다.
  * 이 경우, 예전에는 같은 계층에 새로운 서브클래스를 추가하여 공유하고 싶지 않은 부모의 멤버를 모두 새로운 서브클래스에 넘겨 해결하곤 했다.
* 항상 상술한 방식을 적용할 필요는 없으며, 일반적으로 일부 동작을 재활용하기 위한 목적으로 사용된 상속을 활용할 수도 있다.
  * 솔직히 **코드 냄새에 해당하지만, 참을만한 경우가 많으며 실무 관점에서는 유용한 방식이기도 하다**.
* 반면 **상속을 포기했을 때 혼란과 문제가 생긴다면, 상술한 새로운 서브클래스를 추가하는 방식을 통해 문제를 해결하도록 한다**.
* 상속 포기 냄새는 서브클래스가 부모의 동작은 필요로 하지만 인터페이스는 따르고 싶지 않은 경우에 특히 심한 악취를 뿜는다.
  * 구현을 따르지 않을 수는 있지만 인터페이스를 따르지 않는 것은 말이 되지 않으므로, 차라리 적절한 리팩토링으로 상속 메커니즘에서 벗어나도록 수정할 수 있다.

### 주석
* 주석은 절대 사용하지 말아야 하는 것은 아니며, 악취보다는 향기를 입히는 방식이다.
  * 그러나 탈취제처럼 사용된 주석은 코드 냄새에 해당한다.
* **주석이 많으면 온갖 악취를 풍기는 코드가 나오기 쉬우며, 또한 장황한 주석이 잘 못 짜여진 코드의 탓인 경우도 많다**.
* **주석을 남겨야겠다는 생각이 들면 우선 주석이 필요 없어질 정도로 코드를 리팩토링**하도록 한다.
* 반면 **무엇을 해야할지 모를 때라거나, 현재의 진행 상황 또는 확실하지 않은 부분 및 코드를 이렇게 작성한 이유 등은 주석을 다는 것이 바람직**하다.
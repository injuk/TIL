# Refactoring
## 2022-04-13 Wed

## 코드 스멜
* 적용 방법을 아는 것과 적시에 적용할 줄 아는 것은 다르므로, 리팩토링을 언제 시작하고 언제 그만할지를 판단하는 일은 리팩토링의 원리 못지 않게 중요하다.
* 리팩토링할 시점을 결정하는 데에는 냄새라는 표현을 사용할 수 있다.
  * **리팩토링이 필요한 코드들에서는 일정한 패턴이 드러나며, 이러한 패턴을 냄새라고 표현**하였다.

### 이상한 이름
* **코드는 단순하고 명료하게 작성해야 하며, 코드를 명료하게 만드는 가장 중요한 요소 중 하나는 이름**이다.
  * 함수, 모듈, 변수, 클래스 등은 이름만 보고도 무엇을 하고 어떻게 사용해야하는지 명확하게 알 수 있도록 숙고하여 명명해야 한다.
  * 코드에서 명명된 이름이 끼치는 영향은 어마어마하므로, 자주 사용되는 리팩토링 기법 역시 이름의 변경과 관련이 있다.
* 혼란스러운 이름을 적절히 정리하는 과정에서 코드는 훨씬 간결해질 수 있다.
```
> 이름을 바꾸는 것은 단순히 명명하는 연습이 아니며, 적절한 이름이 떠오르지 않는다는 것은 설계에 근본적인 문제가 숨어 있음을 암시하는 경우가 많다.
```

### 중복된 코드
* 똑같은 코드 구조가 여러 곳에서 반복된다면 하나로 통합하는 것이 바람직하다.
* 코드가 중복되면 각각을 확인할 때마다 서로의 차이점을 확인해야하는 부담이 있으며, 그 중 하나를 수정하는 경우 전체 코드를 확인해야 하는 문제가 있다.

### 너무 긴 함수
* **오랜 기간 잘 활용되는 프로그램들은 모두 짧은 함수로 구성된다는 공통점**이 있다.
* 코드를 이해하고, 공유하고, 선택하기 쉬워진다는 장점은 모두 짧게 구성된 함수에서 비롯된다.
* 프로그래밍의 초창기에는 서브루틴을 호출하는 비용이 컸기에 짧은 함수를 꺼렸으나, 최근의 언어는 프로세스 내부에서의 함수 호출 비용을 사실상 없애버렸다.
* 그러나 짧은 함수는 여전히 프로그램을 왔다갔다 하며 코드를 파악해야한다는 단점이 존재한다.
  * **이를 극복하는 가장 확실한 방법은 좋은 이름을 작성하는 것이며, 적절히 명명된 함수는 본문 코드를 볼 필요조차 없어진다**.
  * 또한, 이를 위해서라도 함수는 훨씬 더 적극적으로 쪼개져야만 한다!
* 주석을 달아야만 할 부분도 모두 함수로 만드는 것이 바람직하다.
  * 함수 본문에는 주석으로 설명하려던 코드를 작성한다.
  * **함수의 이름은 반드시 동작 방식이 아닌 의도가 담기도록 명명**한다.
* 함수를 추출하는 과정에서의 **핵심은 함수의 길이가 아닌 함수의 목적 또는 의도와 구현 코드의 괴리가 얼마나 큰가**이다.
  * 즉, **무엇을 하는지를 코드가 적절히 설명하지 못할수록 함수화하는 것이 바람직**하다.
* 함수가 매개변수와 임시 변수를 너무 많이 사용한다면 함수 추출 작업에 방해가 될 수 있으므로, 적절한 기법을 통해 임시 변수와 매개변수의 수를 줄이도록 한다.
* **추출하기에 적절한 코드 덩어리를 선택하는 좋은 방법 중 하나는 주석을 참고하는 것**이다.
  * 이는 주석이 코드만으로 목적을 이해하기 어려운 부분에 달려 있는 경우가 많기 때문이다.
  * 주석이 설명하는 코드는 함수 본문으로 빼내고, 함수의 이름은 주석을 토대로 명명한다.
  * **비록 코드가 단 한 줄 뿐이더라도 주석을 통해 설명할 필요가 있다면 함수로 추출하는 것이 바람직**하다.

### 너무 긴 매개변수 목록
* 매개변수 목록이 너무 길어지면 그 자체로 이해하기 어려워지는 경우가 많다.
* **클래스는 매개변수 목록을 줄이는 효과적인 방법이기도 하며, 특히 여러 함수가 특정한 매개변수의 값을 공통으로 사용할 때 유용**하다.
  * 이 경우, 여러 함수를 하나의 클래스로 묶고 공통의 값을 클래스의 필드로 정의하도록 한다.

### 전역 데이터
* **전역 데이터는 전역 변수 뿐만 아니라 클래스 변수와 싱글톤을 포함하는 용어**이다.
* **전역 데이터는 개발자가 겪을 수 있는 코드 냄새 중 가장 지독한 악취**이다.
* 전역 데이터는 코드 어느 곳에서나 수정할 수 있는데에 반해, 값을 누가 수정했는지 찾아낼 메커니즘이 없다는 문제점이 있다.
  * 최악의 경우, 버그는 끊임없이 발견되는데 원인을 찾기는 굉장히 어려울 수 있다.
* **전역 데이터는 아주 조금만 존재하더라도 캡슐화하는 것이 좋으며, 그래야만 소프트웨어가 진화하는 데에 수반되는 변화에 대처**할 수 있다.

### 가변 데이터
* 값을 다른 곳에서 설정할 수 있는 가변 데이터 역시 고약한 악취에 속한다.
* 코드의 다른 곳에서 사용된다는 사실을 인식하지 못한 채 가변 데이터의 값을 수정한다면 프로그램은 오작동하기 쉽다.
  * 특히, 이러한 문제가 아주 드문 조건에서만 발생한다면 원인을 알아내기는 더욱 어려워진다.
* 변수의 유효 범위가 몇 줄에 불과하다면 가변 데이터라도 큰 문제가 없지만, 유효범위가 넓다면 변수를 수정하는 코드들의 유효범위를 제한할 필요가 있다.

### 뒤엉킨 변경
* 소프트웨어의 구조는 변경하기 쉬운 형태로 조직되어야하며, 코드를 수정할 때에는 시스템에서 딱 한 군데만 수정하는 것이 이상적이다.
* 그러나 **단일 책임 원칙이 제대로 지켜지지 않은 경우, 임의의 기능 하나를 수정하기 위해 코드의 이곳 저곳을 수정해야할 수도 있다**.

### 산탄총 수술
* 산탄총 수술은 하나의 맥락에 맞는 코드가 모듈의 이곳 저곳에 흩어진 상태이다.
* 이러한 코드 냄새는 코드를 수정할 때마다 자잘하게 수정해야하는 클래스가 여기저기에 퍼져있을 때에 풍긴다.
* 이 경우, 함께 변경되는 대상을 모두 한 모듈에 묶어두는 식으로 대응할 수 있다.
* 뒤엉킨 변경은 맥락에 맞지 않는 코드가 하나의 모듈에 섞여 들어가 단일 책임 원칙을 위배한다는 점에서 차이가 있다.
  * 때문에 **뒤엉킨 변경은 코드를 컨텍스트 별로 분리해야 하며, 산탄총 수술은 컨텍스트에 맞는 코드를 한 곳으로 모으는 식으로 대응**해야 한다.

### 기능의 편애
* 프로그램을 모듈화하는 과정에서 코드를 여러 영역으로 나누고, 같은 영역 안에서의 응집도는 높이되 영역 간의 결합도는 낮추는 데에 주력해야 한다.
* 그러나 어떤 함수가 자신이 속한 모듈의 함수나 데이터보다 다른 모듈의 함수나 데이터와 상호작용하는 일이 더 많다면, 이는 기능 편애에 해당하는 코드 냄새이다.
* 이러한 함수는 데이터와 가까이 있고 싶어하므로 원하는 위치로 옮겨주는 식으로 리팩토링할 수 있다.
  * 함수를 옮길 위치가 명확하지 않은 경우, 가장 많은 데이터를 포함하는 모듈로 옮기도록 한다.
  * 또는 옮기려는 함수를 여러 조각으로 쪼갠 후에 각각 어울리는 모듈로 옮기는 방식을 선택할 수도 있다.

### 데이터 뭉치
* 데이터들은 서로 어울리길 좋아하며 뭉치려고 하는 특징이 있다.
* 이렇게 **몰려다니는 데이터 뭉치는 클래스라는 별도의 보금자리를 마련해주는 것이 좋다**.
* **값들이 데이터 뭉치인지 확인하려면 값 중 하나를 임의로 삭제해보고, 나머지 데이터만으로 의미를 가질 수 있는지를 확인**할 수 있다.
  * 의미가 없다면 해당 데이터 뭉치는 클래스로 환생하는 것이 바람직하다.
* **데이터 뭉치를 클래스로 만드는데에 성공했다면, 해당 클래스로 옮기면 좋을 동작들을 살펴보는 것이 바람직**하다.
  * 이러한 연계 과정은 상당한 중복을 없애며, 향후 개발을 가속하는 유용한 클래스를 탄생시킬 수도 있다.
  * 이렇듯 클래스를 이용하면 코드 냄새 대신 좋은 향기를 뿌릴 기회가 생긴다.
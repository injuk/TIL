# Refactoring
## 2022-04-17 Sun

## 캡슐화하기
* 모듈을 분리하는 가장 중요한 기준은 일반적으로 시스템에서 각 모듈이 자신을 제외한 다른 부분에 드러내지 않아야하는 내용을 얼마나 잘 숨기느냐에 있다.
* **클래스는 본래 정보를 숨기는 용도로 설계되었으며, 내부 정보 뿐만 아니라 클래스 간의 연결 관계를 숨기는 데에도 유용**하다.
* 가장 큰 캡슐화 단위는 클래스와 모듈이지만, 함수도 구현을 캡슐화할 수 있다.

### 레코드 캡슐화하기
* 대부분의 프로그래밍 언어는 데이터 레코드를 표현하는 구조를 제공한다.
  * 레코드는 여러 데이터를 직관적으로 묶을 수 있으므로 각각을 따로 취급할 때보다 훨씬 의미 있는 단위를 적용할 수 있다.
  * 그러나 단순한 레코드에는 계산해서 얻을 수 있는 값과 그렇지 못한 값을 명확히 구분해서 저장해야하는 식의 단점도 존재한다.
* **가변 데이터를 저장하는 용도로 레코드 대신 객체를 사용하면 어떻게 저장했는지를 숨긴 상태에서 각각의 값을 메소드로 제공할 수 있다**.
  * 사용자는 무엇이 저장된 값이고 무엇이 계산된 값인지 알 필요조차 없어질 수 있다.
* 레코드 구조는 필드의 이름을 노출하는 형태와, 개발자가 원하는 이름을 사용할 수 있는 형태로 구분할 수 있다.
* 해당 방식은 입력 데이터 레코드와의 연결을 끊어줄 수 있다는 이점을 얻을 수 있다.
  * 특히, 해당 레코드를 참조하여 캡슐화를 깨트릴 우려가 있는 코드가 많은 경우에 적절하다.

### 레코드 캡슐화하기 - 절차
1. 레코드를 담는 변수를 캡슐화한다.
   * 레코드를 캡슐화하는 함수의 이름은 검색하기 쉽도록 명명한다.
   * **레코드를 캡슐화하는 목적은 변수 자체는 물론, 변수의 내용을 조작하는 방식까지 통제하기 위함**이다.
2. 레코드를 감싸는 단순한 클래스로 변수의 내용을 교체한다.
3. 해당 클래스에 원본 레코드를 반환하는 접근자를 정의한 후, 변수를 캡슐화하는 함수들이 해당 접근자를 사용하도록 코드를 수정한다.
4. 테스트를 진행한다.
5. 원본 레코드 대신 새로 정의한 클래스 타입의 객체를 반환하는 함수를 새로 정의한다.
6. 레코드를 반환하는 예전 함수를 사용하는 코드를 해당 함수를 사용하도록 변경한다.
7. 이후 필드에 접근할 때에는 접근자를 사용하되, 적절한 접근자가 없다면 추가한다.
   * 한 부분을 변경할 때마다 테스트를 진행한다.
   * 중첩된 구조처럼 복잡한 레코드의 경우, 먼저 데이터를 갱신하는 클라이언트들에 주의할 필요가 있다.
   * 클라이언트가 데이터를 읽기만 하는 경우, 데이터의 복제본이나 읽기 전용 프록시를 반환할지 고려할 수 있다.
8. 클래스에서 원본 데이터를 반환하는 접근자와, 검색하기 쉬운 이름을 명명한 1.의 원본 레코드 반환 함수를 제거한 후 테스트를 진행한다.
9. 레코드의 필드도 데이터 구조인 중첩 구조인 경우, 레코드 캡슐화하기와 컬렉션 캡슐화하기를 재귀적으로 적용할 수 있다.

## 2022-04-18 Mon
### 컬렉션 캡슐화하기
* 가변 데이터는 일반적으로 모두 캡슐화하는 편이지만, 컬렉션을 다룰 때는 이를 적용하지 않는 경우가 많다.
* 예를 들어, **게터가 컬렉션 자체를 반환한다면 컬렉션을 감싸는 클래스가 눈치 채지 못하는 사이에 컬렉션의 내용이 변경될 수 있다**.
* 이러한 문제를 방지하기 위해 컬렉션 변경자 메소드를 정의하는 방법을 적용할 수 있다.
  * 예를 들어, 컬렉션에 데이터를 추가하거나 제거하기 위한 add(), remove() 메소드를 정의한다.
* 또한, **게터가 원본 컬렉션을 반환하지 않도록 만들어 클라이언트의 실수에 대비**할 수도 있다.
  * 즉, **컬렉션의 요소를 추가하는 것은 앞서 정의한 add(), remove() 메소드를 사용하되 컬렉션 자체에 대한 게터를 지양해야한다는 의미**이다.
  * 이는 **필드를 참조하는 과정만 캡슐화하고 필드에 포함된 내용은 캡슐화하지 않은 문제를 미연에 방지**한다.
  1. 절대 컬렉션 값을 반환하지 않으며, 컬렉션과 관련된 메소드는 모두 래핑 클래스에 정의된 메소드를 통하도록 구현한다.
     * 이러한 방식은 부가적인 코드들이 너무 늘어나고, 컬렉션 연산들을 조합할 수 없다는 단점이 수반된다.
  2. 컬렉션을 읽기 전용으로 제공한다.
     * 이러한 방식은 읽기 전용 프록시를 반환하는 것으로 읽기 연산은 허용하되, 쓰기 연산에서 에러를 던지도록 구현한다.
  3. 게터를 제공하되, 원본이 아닌 복제본을 반환한다.
     * 가장 자주 사용되는 방식이지만, 원본 컬렉션이 크다면 성능 문제가 발생할 수 있다.
* **프록시 방식에서는 원본 데이터를 수정하는 과정이 명시되지만, 복제본 방식은 그렇지 못하다는 차이점**이 있다.
  * 때문에 반환된 컬렉션을 수정하면 원본도 수정되리라 기대한 개발자를 당황하게 만들 수도 있다.
* **중요한 것은 코드에 일관성을 주는 것이며, 어떠한 방식을 사용하건 간에 하나만 고르게 적용하는 것이 이상적**이다.
```
> 컬렉션에 대해서는 어느 정도 강박을 갖고 불필요한 복제본을 만드는 것이, 예상치 못한 수정에서 기인한 오류를 디버깅하는 것보다는 낫다.
> 컬렉션의 관리를 책임지는 클래스라면 항상 복제본을 제공해야 한다.
> 컬렉션을 변경할 가능성이 있는 작업을 진행하는 경우, 습관적으로 복제본을 생성하는 것이 좋을 수 있다. 
```

### 컬렉션 캡슐화하기 - 절차
1. 아직 컬렉션을 캡슐화하지 않았다면 변수 캡슐화하기를 적용한다.
2. 컬렉션에 원소를 추가 또는 제거하는 함수를 추가한다.
   * 이 때, 컬렉션 참조를 통채로 변경하는 세터는 반드시 제거한다.
   * **세터를 제거할 수 없는 경우, 인수로 받은 컬렉션을 복제하여 저장**한다.
3. 정적 검사를 수행한다.
4. 컬렉션을 참조하는 모든 지점을 찾고, 컬렉션 변경자 메소드를 사용하는 코드를 2.에서 추가한 메소드를 사용하도록 수정한다.
   * 이 때, 하나를 수정할 때마다 테스트를 진행한다.
5. 컬렉션의 게터를 수정하여 원본 내용을 수정할 수 없는 읽기 전용 프록시나 복제본을 반환하게 한다.
6. 테스트를 진행한다.

### 기본형을 객체로 바꾸기
* 개발 초기에는 단순한 정보를 숫자나 문자열 같은 간단한 데이터 항목으로 표현하곤 한다.
  * 그러나 시간이 지나고 프로젝트가 성숙함에 따라, 간단했던 정보들은 더 이상 간단하지 않게 변화하곤 한다.
  * 때문에 금새 중복 코드가 늘어나고, 사용하기 위해 필요한 노력도 함께 늘어나게 된다.
* **단순한 값의 출력 이상의 기능이 필요해지는 순간 데이터를 표현하는 전용 클래스를 정의하는 것이 이상적**이다.
  * 이러한 클래스는 처음에는 단순한 데이터의 래퍼에 지나지 않아 효과가 미미할 수 있다.
  * 그러나 **추후에 특별한 동작이 필요해지는 경우 클래스에 동작을 추가하기만 하면 되므로 점점 유용해지며, 클라이언트 코드를 더 의미 있게 작성**할 수 있다.
  * 해당 리팩토링 기법은 여러 리팩토링 중에서도 가장 유용한 종류에 속한다.

### 기본형을 객체로 바꾸기 - 절차
1. 아직 컬렉션을 캡슐화하지 않았다면 변수 캡슐화하기를 적용한다.
2. 단순한 값 클래스를 정의하되, 생성자는 기존 값을 인수로 받아 저장한다.
3. 값을 반환하는 게터를 추가한 후, 정적 검사를 수행한다.
4. 값 클래스의 인스턴스를 새로 만들어서 필드에 저장할 수 있도록 1.에서 캡슐화된 세터를 수정한다.
   * 세터가 이미 존재한다면, 필드의 타입을 적절하게 변경한다.
5. 새로 만든 클래스의 게터를 호출한 결과를 반환하도록 1.에서 캡슐화된 게터를 수정한다.
6. 테스트를 진행한다.
7. 함수의 이름을 변경하는 것으로 원본 접근자의 동작을 더 명시적으로 드러낼 수 있는지 검토한다.
   * 예를 들어, 참조를 값으로 바꾸거나 값을 참조로 바꾸는 것으로 새로 만든 객체의 역할이 더 잘 드러나는지 검토한다.

### 임시 변수를 질의 함수로 변경하기
* 함수 안에서 어떤 코드의 결과값을 다시 참조할 목적으로 임시 변수를 사용할 수 있다.
  * 이를 통해 값을 계산하는 코드가 반복되는 것을 줄이고, 변수의 이름을 통해 값의 의미를 설명할 수 있다.
* 그러나 한 걸음 나아가, 변수 대신 함수를 만들어 사용하는 편이 좋을 때가 많다.
* 임시 변수 대신 함수를 작성하는 경우, 비슷한 계산을 수행하는 다른 함수에서도 사용할 수 있으므로 코드의 중복이 줄어든다.
  * **클래스는 추출할 메소드들의 공유 컨텍스트를 제공할 수 있으므로, 해당 리팩토링 기법은 클래스 내부에서 적용할 때 효과가 가장 크다**.
  * 반면, 최상위 함수로 추출하는 경우 매개변수가 너무 많아지기에 함수를 사용하는 장점은 줄어든다.
* 임시 변수를 질의 함수로 모두 변경한다고 항상 좋아지는 것은 아니다.
  * **변수는 값을 한 번만 계산하고, 그 뒤로는 읽기만 할 때 가장 좋다**.
  * 때문에 스냅샷 용도로 사용되는 변수에는 해당 리팩토링 기법을 적용하지 말아야 한다.

### 임시 변수를 질의 함수로 변경하기 - 절차
1. 변수가 사용되기 전에 값이 확실히 결정되는지, 또는 변수를 사용할 때마다 계산 로직이 매 번 다른 결과를 반환하는지 확인한다.
2. 읽기 전용으로 만들 수 있는 변수는 읽기 전용으로 만들어준다.
3. 테스트를 진행한다.
4. 변수를 대입하는 문장인 우변을 함수로 추출한다.
   * 이 때, 변수와 함수가 같은 이름을 가질 수 없다면 함수 이름은 임시로 명명한다.
   * 또한, 추출한 함수가 부수 효과를 일으키는지 확인한다.
   * 부수 효과가 존재하는 함수라면, 질의 함수와 변경 함수를 분리하는 리팩토링 기법을 적용한다.
5. 테스트를 진행한다.
6. 변수를 인라인하여 임시 변수를 제거한다.

### 클래스 추출하기
* 클래스는 반드시 명확하게 추상화하고, 소수의 주어진 역할만을 처리해야 한다.
  * 그러나 실무에서는 몇 가지 연산을 추가하고, 데이터를 보강해나가는 과정에서 클래스가 비대해지곤 한다.
* **기존 클래스를 굳이 쪼갤 필요 없다고 성급히 판단하여 새로운 역할을 덧씌운 경우, 역할은 갈수록 늘어나 클래스가 굉장히 복잡해질 수 있다**.
* 메소드와 데이터가 너무 많은 클래스는 이해하기 어려울 수 있으므로, 잘 살펴보고 적절히 분리해야 한다.
  * 특히 **일부 데이터와 메소드를 따로 묶어낼 수 있다면 가능한 한 빠르게 분리하라는 신호**이다.
* 함께 변경되는 일이 많거나, 서로 의존하는 데이터들도 분리해야 한다.
* 작은 일부의 기능만을 위해 서브클래스를 정의하거나, 확장해야 할 기능에 따라 서브클래스를 작성하는 방식이 달라지는 경우에도 클래스를 나누어야 한다.

### 클래스 추출하기 - 절차
1. 클래스의 역할을 분리할 방법을 결정한다.
2. 분리될 역할을 담당할 클래스를 새로 정의한다.
   * 이 때, 원래 클래스에 남은 역활과 클래스의 이름이 어우러지지 않는다면 적절히 변경해야 한다.
3. 기존 클래스의 생성자에서 새로운 클래스의 인스턴스를 생성하여 필드에 저장해둔다.
4. 분리될 역할에 필요한 필드들은 새로운 클래스로 옮기되, 하나를 옮길 때마다 테스트를 진행한다.
5. 메소드 역시 새로운 클래스로 옮기고, 특히 다른 메소드를 호출하기보다 호출 당하는 일이 많은 저수준 메소드부터 옮겨 나간다.
   * 역시 하나씩 옮길 때마다 테스트를 진행한다.
6. 양쪽 클래스의 인터페이스를 살펴보면서 불필요한 메소드를 제거하고, 이름도 새로운 환경에 맞추어 바꾼다.
7. 새로운 클래스를 외부로 노출할지 결정한다.
   * 노출하기로 마음 먹은 경우, 새로운 클래스에 참조를 값으로 바꾸는 리팩토링 기법을 적용할지 고민해야 한다.

### 클래스를 인라인하기
* 해당 리팩토링 기법은 클래스 추출하기의 반대 버전에 해당하는 리팩토링 기법이다.
* **더 이상 제 역할을 못하여 그대로 둘 필요가 없는 클래스는 인라인하는 것이 바람직**하다.
  * 이러한 경우는 역할을 옮기는 리팩토링 기법을 적용한 후에 특정한 클래스에 남은 역할이 거의 없는 경우에 자주 생긴다.
  * 이런 때에는 남은 역할이 거의 없는 클래스를 가장 많이 사용하는 클래스로 흡수시킨다.
* 클래스의 기능을 지금과는 다르게 배분하고 싶은 경우에도 클래스를 인라인할 수 있다.
  * 때에 따라 단일 컨텍스트에 포함된 요소들을 다른 쪽으로 하나씩 옮길 수도 있고, 인라인 리팩토링을 적용하여 합친 후에 추출하여 분리하는 것이 쉬울 수도 있다.

### 클래스를 인라인하기 - 절차
1. 소스 클래스의 public 메소드에 대응하는 메소드들을 타깃 클래스에 생성한다.
   * 해당 메소드들은 단순히 작업을 소스 클래스로 위임한다.
2. 소스 클래스의 메소드를 사용하는 코드를 모두 타깃 클래스의 위임 메소드를 사용하도록 변경한다.
   * 이 때, 하나씩 바꿀 때마다 테스트를 진행한다.
3. 소스 클래스의 메소드와 필드를 모두 타깃 클래스로 옮겨준다.
   * 이 때, 하나씩 바꿀 때마다 테스트를 진행한다.
4. 소스 클래스를 삭제하고 마무리한다.
# Refactoring
## 2022-04-17 Sun

## 캡슐화하기
* 모듈을 분리하는 가장 중요한 기준은 일반적으로 시스템에서 각 모듈이 자신을 제외한 다른 부분에 드러내지 않아야하는 내용을 얼마나 잘 숨기느냐에 있다.
* **클래스는 본래 정보를 숨기는 용도로 설계되었으며, 내부 정보 뿐만 아니라 클래스 간의 연결 관계를 숨기는 데에도 유용**하다.
* 가장 큰 캡슐화 단위는 클래스와 모듈이지만, 함수도 구현을 캡슐화할 수 있다.

### 레코드 캡슐화하기
* 대부분의 프로그래밍 언어는 데이터 레코드를 표현하는 구조를 제공한다.
  * 레코드는 여러 데이터를 직관적으로 묶을 수 있으므로 각각을 따로 취급할 때보다 훨씬 의미 있는 단위를 적용할 수 있다.
  * 그러나 단순한 레코드에는 계산해서 얻을 수 있는 값과 그렇지 못한 값을 명확히 구분해서 저장해야하는 식의 단점도 존재한다.
* **가변 데이터를 저장하는 용도로 레코드 대신 객체를 사용하면 어떻게 저장했는지를 숨긴 상태에서 각각의 값을 메소드로 제공할 수 있다**.
  * 사용자는 무엇이 저장된 값이고 무엇이 계산된 값인지 알 필요조차 없어질 수 있다.
* 레코드 구조는 필드의 이름을 노출하는 형태와, 개발자가 원하는 이름을 사용할 수 있는 형태로 구분할 수 있다.
* 해당 방식은 입력 데이터 레코드와의 연결을 끊어줄 수 있다는 이점을 얻을 수 있다.
  * 특히, 해당 레코드를 참조하여 캡슐화를 깨트릴 우려가 있는 코드가 많은 경우에 적절하다.

### 레코드 캡슐화하기 - 절차
1. 레코드를 담는 변수를 캡슐화한다.
   * 레코드를 캡슐화하는 함수의 이름은 검색하기 쉽도록 명명한다.
   * **레코드를 캡슐화하는 목적은 변수 자체는 물론, 변수의 내용을 조작하는 방식까지 통제하기 위함**이다.
2. 레코드를 감싸는 단순한 클래스로 변수의 내용을 교체한다.
3. 해당 클래스에 원본 레코드를 반환하는 접근자를 정의한 후, 변수를 캡슐화하는 함수들이 해당 접근자를 사용하도록 코드를 수정한다.
4. 테스트를 진행한다.
5. 원본 레코드 대신 새로 정의한 클래스 타입의 객체를 반환하는 함수를 새로 정의한다.
6. 레코드를 반환하는 예전 함수를 사용하는 코드를 해당 함수를 사용하도록 변경한다.
7. 이후 필드에 접근할 때에는 접근자를 사용하되, 적절한 접근자가 없다면 추가한다.
   * 한 부분을 변경할 때마다 테스트를 진행한다.
   * 중첩된 구조처럼 복잡한 레코드의 경우, 먼저 데이터를 갱신하는 클라이언트들에 주의할 필요가 있다.
   * 클라이언트가 데이터를 읽기만 하는 경우, 데이터의 복제본이나 읽기 전용 프록시를 반환할지 고려할 수 있다.
8. 클래스에서 원본 데이터를 반환하는 접근자와, 검색하기 쉬운 이름을 명명한 1.의 원본 레코드 반환 함수를 제거한 후 테스트를 진행한다.
9. 레코드의 필드도 데이터 구조인 중첩 구조인 경우, 레코드 캡슐화하기와 컬렉션 캡슐화하기를 재귀적으로 적용할 수 있다.
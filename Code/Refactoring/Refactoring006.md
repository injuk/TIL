# Refactoring
## 2022-04-17 Sun

## 캡슐화하기
* 모듈을 분리하는 가장 중요한 기준은 일반적으로 시스템에서 각 모듈이 자신을 제외한 다른 부분에 드러내지 않아야하는 내용을 얼마나 잘 숨기느냐에 있다.
* **클래스는 본래 정보를 숨기는 용도로 설계되었으며, 내부 정보 뿐만 아니라 클래스 간의 연결 관계를 숨기는 데에도 유용**하다.
* 가장 큰 캡슐화 단위는 클래스와 모듈이지만, 함수도 구현을 캡슐화할 수 있다.

### 레코드 캡슐화하기
* 대부분의 프로그래밍 언어는 데이터 레코드를 표현하는 구조를 제공한다.
  * 레코드는 여러 데이터를 직관적으로 묶을 수 있으므로 각각을 따로 취급할 때보다 훨씬 의미 있는 단위를 적용할 수 있다.
  * 그러나 단순한 레코드에는 계산해서 얻을 수 있는 값과 그렇지 못한 값을 명확히 구분해서 저장해야하는 식의 단점도 존재한다.
* **가변 데이터를 저장하는 용도로 레코드 대신 객체를 사용하면 어떻게 저장했는지를 숨긴 상태에서 각각의 값을 메소드로 제공할 수 있다**.
  * 사용자는 무엇이 저장된 값이고 무엇이 계산된 값인지 알 필요조차 없어질 수 있다.
* 레코드 구조는 필드의 이름을 노출하는 형태와, 개발자가 원하는 이름을 사용할 수 있는 형태로 구분할 수 있다.
* 해당 방식은 입력 데이터 레코드와의 연결을 끊어줄 수 있다는 이점을 얻을 수 있다.
  * 특히, 해당 레코드를 참조하여 캡슐화를 깨트릴 우려가 있는 코드가 많은 경우에 적절하다.

### 레코드 캡슐화하기 - 절차
1. 레코드를 담는 변수를 캡슐화한다.
   * 레코드를 캡슐화하는 함수의 이름은 검색하기 쉽도록 명명한다.
   * **레코드를 캡슐화하는 목적은 변수 자체는 물론, 변수의 내용을 조작하는 방식까지 통제하기 위함**이다.
2. 레코드를 감싸는 단순한 클래스로 변수의 내용을 교체한다.
3. 해당 클래스에 원본 레코드를 반환하는 접근자를 정의한 후, 변수를 캡슐화하는 함수들이 해당 접근자를 사용하도록 코드를 수정한다.
4. 테스트를 진행한다.
5. 원본 레코드 대신 새로 정의한 클래스 타입의 객체를 반환하는 함수를 새로 정의한다.
6. 레코드를 반환하는 예전 함수를 사용하는 코드를 해당 함수를 사용하도록 변경한다.
7. 이후 필드에 접근할 때에는 접근자를 사용하되, 적절한 접근자가 없다면 추가한다.
   * 한 부분을 변경할 때마다 테스트를 진행한다.
   * 중첩된 구조처럼 복잡한 레코드의 경우, 먼저 데이터를 갱신하는 클라이언트들에 주의할 필요가 있다.
   * 클라이언트가 데이터를 읽기만 하는 경우, 데이터의 복제본이나 읽기 전용 프록시를 반환할지 고려할 수 있다.
8. 클래스에서 원본 데이터를 반환하는 접근자와, 검색하기 쉬운 이름을 명명한 1.의 원본 레코드 반환 함수를 제거한 후 테스트를 진행한다.
9. 레코드의 필드도 데이터 구조인 중첩 구조인 경우, 레코드 캡슐화하기와 컬렉션 캡슐화하기를 재귀적으로 적용할 수 있다.

## 2022-04-18 Mon
### 컬렉션 캡슐화하기
* 가변 데이터는 일반적으로 모두 캡슐화하는 편이지만, 컬렉션을 다룰 때는 이를 적용하지 않는 경우가 많다.
* 예를 들어, **게터가 컬렉션 자체를 반환한다면 컬렉션을 감싸는 클래스가 눈치 채지 못하는 사이에 컬렉션의 내용이 변경될 수 있다**.
* 이러한 문제를 방지하기 위해 컬렉션 변경자 메소드를 정의하는 방법을 적용할 수 있다.
  * 예를 들어, 컬렉션에 데이터를 추가하거나 제거하기 위한 add(), remove() 메소드를 정의한다.
* 또한, **게터가 원본 컬렉션을 반환하지 않도록 만들어 클라이언트의 실수에 대비**할 수도 있다.
  * 즉, **컬렉션의 요소를 추가하는 것은 앞서 정의한 add(), remove() 메소드를 사용하되 컬렉션 자체에 대한 게터를 지양해야한다는 의미**이다.
  * 이는 **필드를 참조하는 과정만 캡슐화하고 필드에 포함된 내용은 캡슐화하지 않은 문제를 미연에 방지**한다.
  1. 절대 컬렉션 값을 반환하지 않으며, 컬렉션과 관련된 메소드는 모두 래핑 클래스에 정의된 메소드를 통하도록 구현한다.
     * 이러한 방식은 부가적인 코드들이 너무 늘어나고, 컬렉션 연산들을 조합할 수 없다는 단점이 수반된다.
  2. 컬렉션을 읽기 전용으로 제공한다.
     * 이러한 방식은 읽기 전용 프록시를 반환하는 것으로 읽기 연산은 허용하되, 쓰기 연산에서 에러를 던지도록 구현한다.
  3. 게터를 제공하되, 원본이 아닌 복제본을 반환한다.
     * 가장 자주 사용되는 방식이지만, 원본 컬렉션이 크다면 성능 문제가 발생할 수 있다.
* **프록시 방식에서는 원본 데이터를 수정하는 과정이 명시되지만, 복제본 방식은 그렇지 못하다는 차이점**이 있다.
  * 때문에 반환된 컬렉션을 수정하면 원본도 수정되리라 기대한 개발자를 당황하게 만들 수도 있다.
* **중요한 것은 코드에 일관성을 주는 것이며, 어떠한 방식을 사용하건 간에 하나만 고르게 적용하는 것이 이상적**이다.
```
> 컬렉션에 대해서는 어느 정도 강박을 갖고 불필요한 복제본을 만드는 것이, 예상치 못한 수정에서 기인한 오류를 디버깅하는 것보다는 낫다.
> 컬렉션의 관리를 책임지는 클래스라면 항상 복제본을 제공해야 한다.
> 컬렉션을 변경할 가능성이 있는 작업을 진행하는 경우, 습관적으로 복제본을 생성하는 것이 좋을 수 있다. 
```

### 컬렉션 캡슐화하기 - 절차
1. 아직 컬렉션을 캡슐화하지 않았다면 변수 캡슐화하기를 적용한다.
2. 컬렉션에 원소를 추가 또는 제거하는 함수를 추가한다.
   * 이 때, 컬렉션 참조를 통채로 변경하는 세터는 반드시 제거한다.
   * **세터를 제거할 수 없는 경우, 인수로 받은 컬렉션을 복제하여 저장**한다.
3. 정적 검사를 수행한다.
4. 컬렉션을 참조하는 모든 지점을 찾고, 컬렉션 변경자 메소드를 사용하는 코드를 2.에서 추가한 메소드를 사용하도록 수정한다.
   * 이 때, 하나를 수정할 때마다 테스트를 진행한다.
5. 컬렉션의 게터를 수정하여 원본 내용을 수정할 수 없는 읽기 전용 프록시나 복제본을 반환하게 한다.
6. 테스트를 진행한다.

### 기본형을 객체로 바꾸기
* 개발 초기에는 단순한 정보를 숫자나 문자열 같은 간단한 데이터 항목으로 표현하곤 한다.
  * 그러나 시간이 지나고 프로젝트가 성숙함에 따라, 간단했던 정보들은 더 이상 간단하지 않게 변화하곤 한다.
  * 때문에 금새 중복 코드가 늘어나고, 사용하기 위해 필요한 노력도 함께 늘어나게 된다.
* **단순한 값의 출력 이상의 기능이 필요해지는 순간 데이터를 표현하는 전용 클래스를 정의하는 것이 이상적**이다.
  * 이러한 클래스는 처음에는 단순한 데이터의 래퍼에 지나지 않아 효과가 미미할 수 있다.
  * 그러나 **추후에 특별한 동작이 필요해지는 경우 클래스에 동작을 추가하기만 하면 되므로 점점 유용해지며, 클라이언트 코드를 더 의미 있게 작성**할 수 있다.
  * 해당 리팩토링 기법은 여러 리팩토링 중에서도 가장 유용한 종류에 속한다.

### 기본형을 객체로 바꾸기 - 절차
1. 아직 컬렉션을 캡슐화하지 않았다면 변수 캡슐화하기를 적용한다.
2. 단순한 값 클래스를 정의하되, 생성자는 기존 값을 인수로 받아 저장한다.
3. 값을 반환하는 게터를 추가한 후, 정적 검사를 수행한다.
4. 값 클래스의 인스턴스를 새로 만들어서 필드에 저장할 수 있도록 1.에서 캡슐화된 세터를 수정한다.
   * 세터가 이미 존재한다면, 필드의 타입을 적절하게 변경한다.
5. 새로 만든 클래스의 게터를 호출한 결과를 반환하도록 1.에서 캡슐화된 게터를 수정한다.
6. 테스트를 진행한다.
7. 함수의 이름을 변경하는 것으로 원본 접근자의 동작을 더 명시적으로 드러낼 수 있는지 검토한다.
   * 예를 들어, 참조를 값으로 바꾸거나 값을 참조로 바꾸는 것으로 새로 만든 객체의 역할이 더 잘 드러나는지 검토한다.
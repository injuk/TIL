# Refactoring
## 2022-04-25 Mon

## 상속 다루기
### 메소드 올리기
* 코드가 중복되었다는 사실은 한쪽의 변경사항이 다른 쪽 코드에 반영되지 않을 수 있는 위험을 수반하므로, 중복 코드의 제거는 언제나 중요하다.
* 서브클래스들 사이의 유사한 메소드에서, 본문 코드가 항상 같은 경우는 많지 않으므로 차이점에 집중하는 방법이 효과가 좋다.
* 반면, 해당 리팩토링을 적용하기 가장 복잡한 상황은 메소드의 본문에서 참조하는 필드들이 서브클래스에만 있는 경우이다.
  * 이 경우, 우선 필드를 슈퍼클래스로 옮기는 방식을 선행할 수 있다.
* 두 메소드의 흐름은 유사하지만 세부 내용이 다른 경우, 템플릿 메소드 패턴의 적용을 고려할 수 있다.

### 메소드 올리기 - 절차
1. 동일하게 동작하는 메소드인지 면밀하게 확인한다.
   * 실질적으로 하는 일이 같지만 내부 코드가 다른 경우, 우선 본문의 내용이 같아질 때까지 리팩토링을 수행한다.
2. 메소드 내부에서 호출하는 다른 메소드와 참조하는 필드들을 슈퍼클래스에서도 호출하고 참조할 수 있는지 확인한다.
3. 메소드 시그니쳐가 다른 경우, 함수 선언 바꾸기로 슈퍼클래스에서 사용하고자하는 형태로 통일한다.
4. 슈퍼클래스에 새로운 메소드를 정의하고, 대상 메소드의 코드를 복사한 후에 정적 검사를 수행한다.
5. 서브클래스 중 하나의 메소드를 제거한 후 테스트를 진행한다.
6. 모든 서브클래스의 메소드가 없어질 때까지 다른 서브클래스의 메소드를 하나씩 제거해나간다.

### 필드 올리기
* 서브클래스들이 독립적으로 개발되었거나, 뒤늦게 하나의 계층구조로 리팩토링된 경우라면 일부 기능이 중복된 경우가 있을 수 있다.
  * 예를 들어, 필드가 중복될 수 있다.
* 중복된 필드들은 일반적으로 이름이 유사하지만, 항상 그렇지는 않으므로 우선 필드들이 어떻게 사용되는지 분석할 필요가 있다.
* 분석한 결과 필드들이 유사한 방식으로 사용되는 경우가 맞다면, 이들을 슈퍼클래스로 끌어올릴 수 있다.
* **해당 리팩토링 기법을 통해 중복된 데이터의 선언을 없앨 수 있고, 해당 필드를 사용하는 동작 역시 슈퍼클래스로 옮길 수 있게 된다**.

### 필드 올리기 - 절차
1. 후보 필드들을 사용하는 곳 모두가 해당 필드들을 똑같은 방식으로 사용하고 있는지 신중히 확인한다.
2. 필드들의 이름이 서로 다른 경우, 동일한 이름으로 바꾸어준다.
3. 슈퍼클래스에서 새로운 필드를 생성하되, 서브클래스에서 해당 필드에 접근할 수 있도록 제한한다.
   * Java의 예를 들면 protected 제한자를 적용할 수 있다.
4. 서브클래스의 필드들을 제거한 후, 테스트를 진행한다.

### 생성자 본문 올리기
* 생성자는 일반적인 메소드에 비해 다루기가 까다로운 편에 속한다.
  * 생성자는 할 수 있는 일과 호출 순서에 제약이 있기 때문이다.
* 해당 리팩토링 기법을 적용할 수 없거나 어려운 경우, 생성자를 팩토리 메소드로 바꾸는 리팩토링 기법을 고려할 수 있다.

### 생성자 본문 올리기 - 절차
1. 슈퍼클래스에 생성자가 없다면 새로 정의한 후, 서브클래스의 생성자에서 해당 생성자를 호출하는지 확인한다.
2. 문장을 슬라이드하여 공통된 문장을 모두 super() 호출 직후로 옮겨준다.
3. 공통 코드를 슈퍼클래스에 추가하고, 서브클래스에서 제거한다.
4. 생성자 매개변수 중, 공통 코드에서 참조하는 값은 모두 super() 로 넘겨준 후 테스트를 진행한다.
5. 생성자의 시작 부분으로 옮길 수 없는 공통 코드는 우선 함수로 추출한 후 메소드를 슈퍼클래스로 옮기도록 한다.

### 메소드 내리기
* 특정 서브클래스와 관련된 메소드는 슈퍼클래스에서 제거하고 해당 서브클래스에 추가하는 것이 바람직하다.
* 그러나 해당 리팩토링 기법은 기능을 제공하는 슈퍼클래스가 정확히 무엇인지 클라이언트 코드가 알고 있을 때에만 적용이 가능하다.
  * **그렇지 못한 경우, 서브클래스에 따라 달리 동작하는 슈퍼클래스의 조건부 로직을 다형성으로 변경**해야 한다.

### 메소드 내리기 - 절차
1. 대상 메소드를 모든 서브클래스에 복사한 후, 슈퍼클래스에서 해당 메소드는 제거하고 테스트를 진행한다.
2. 해당 메소드를 사용하지 않는 모든 서브클래스에서 메소드를 제거한 후, 테스트를 진행한다.

### 필드 내리기
* 특정 서브클래스에서만 사용되는 필드는 해당 서브클래스로 옮겨주는 것이 바람직하다.

### 필드 내리기 - 절차
1. 대상 필드를 모든 서브클래스에 정의한 후, 슈퍼클래스에서 해당 필드를 제거하고 테스트를 진행한다.
2. 해당 필드를 사용하지 않는 모든 서브클래스에서 필드를 제거한 후, 테스트를 진행한다.

### 타입 코드는 서브클래스로 바꾸기
* 시스템에서는 비슷한 대상을 임의의 특성에 따라 구분해야할 때가 있다.
* 이러한 일을 다루기 위해 타입 코드 필드를 적용할 수 있으며, 이는 언어에 따라 열거형, 심볼, 문자열 등으로 표현할 수 있다.
* **타입 코드만으로 대부분 요구사항을 충족할 수 있으나, 때로는 서브클래스를 도입해야할 필요**가 있다.
* 서브클래스를 도입하는 경우, 다음과 같은 측면에서의 이점이 있다.
  1. 조건에 따라 다르게 동작하는 다형성을 제공하므로, 조건부 로직을 다형성으로 수정할 수 있다.
  2. 특정한 타입에서만 의미가 있는 값을 사용하는 필드나 메소드를 서브클래스에 정의할 수 있다.
     * 이는 타입 코드를 사용하는 경우에도 검증 코드로 구현할 수 있으나, 서브클래스 방식이 관계를 좀 더 명확히 드러낸다.
* **해당 리팩토링 기법은 대상 클래스에 직접 적용할지, 타입 코드 자체에 적용할지 고려**해야 한다.
  * 직원 유형을 예로 들어, 전자는 직원의 유형별 하위 타입을 정의하는 반면 후자는 유형 자체를 클래스로 추출한다.
  * 대부분의 경우 대상 클래스를 직접 서브클래스로 만드는 것이 간단하지만, 모든 상황에 적용 가능한 방법은 아니다.
  * 예를 들어, 대상 클래스에 이미 서브클래스가 존재하거나 타입 코드를 동적으로 변경하고 싶은 경우가 이에 해당한다.

### 타입 코드는 서브클래스로 바꾸기 - 절차
1. 타입 코드 필드를 자가 캡슐화한다.
2. 타입 코드 값 하나를 선택하여 해당 값에 해당하는 서브클래스를 정의한다.
3. 타입 코드 게터를 오버라이드하여 해당 타입 코드의 리터럴 값을 반환하도록 정의한다.
4. 매개변수로 받은 타입 코드와 2.에서 정의한 서브클래스를 매핑하는 선택 로직을 정의한다.
   * 직접 상속인 경우 생성자를 팩토리 메소드로 바꾸기 기법을 적용하고, 선택 로직을 팩토리에 정의한다.
   * 간접 상속인 경우, 선택 로직을 생성자에 두도록 구현한다.
5. 테스트를 진행한다.
6. 타입 코드 값 각각에 대해 서브클래스 생성과 선택 로직의 추가를 반복하되, 하나의 클래스가 완성될 때마다 테스트를 진행한다.
7. 타입 코드 필드를 제거한 후 테스트를 진행한다.
8. 타입 코드 접근자를 이용하는 메소드 모두에 메소드 내리기와 조건부 로직을 다형성으로 바꾸기 기법을 적용한다.

### 서브클래스 제거하기
* 서브클래싱은 원래 데이터 구조와는 다른 종류를 만들거나, 종류에 따라 동작을 달리할 수 있는 유용한 메커니즘이다.
  * 즉, 서브클래스는 다름을 프로그래밍하는 좋은 수단이다.
* 반면 더 이상 사용되지 않는 서브클래스는 개발자의 시간을 빼앗을 수 있으므로, 서브클래스를 슈퍼클래스의 필드로 대체하여 제거하는 것이 바람직하다.
* 해당 기법은 여러 서브클래스에 대해 적용되는 경우가 많으므로, 우선 팩토리 메소드를 추가하고 타입 검사 코드를 옮기는 캡슐화 단계를 우선 실행하도록 한다.
  * 그 후에야 개별 서브클래스를 슈퍼클래스로 하나씩 흡수시킬 수 있다.

## 2022-04-26 Tue
### 서브클래스 제거하기 - 절차
1. 서브클래스의 생성자는 팩토리 메소드로 바꾸어준다.
   * 생성자를 사용하는 측에서 데이터 필드를 이용하여 어떤 서브클래스를 생성할지 결정한다.
   * 그 결정 로직을 슈퍼클래스의 팩토리 메소드에 정의한다.
2. 서브클래스의 타입을 검사하는 코드가 있는 경우, 그 검사 코드에 함수 추출하기 및 함수 옮기기 기법을 차례로 적용하여 슈퍼클래스로 옮겨준다.
   * 이 때, 하나를 변경할 때마다 테스트를 진행한다.
3. 서브클래스의 타입을 나타내는 필드를 슈퍼클래스에 정의한다.
4. 서브클래스를 참조하는 메소드가 방금 만든 타입 필드를 이용하도록 수정한다.
5. 서브클래스를 제거한 후, 테스트를 진행한다.

### 슈퍼클래스 추출하기
* 비슷한 일을 수행하는 두 클래스가 보이는 경우, 상속 메커니즘을 통해 비슷한 부분을 공통의 슈퍼클래스로 추출할 수 있다.
  * 공통된 부분이 데이터라면 필드 올리기를 적용하고, 동작이라면 메소드 올리기를 적용한다.
* 상속 구조는 현실의 분류 체계에 기초하여 구현에 들어가기 전에 부모 자식 관계를 신중히 설계해야한다는 의견이 많다.
* 반면, 경험적으로 상속은 프로그램이 성장함에 따라 깨우칠 수 있으며, 슈퍼클래스로 끌어올리고 싶은 공통 요소를 찾았을 때 수행하는 경우가 잦다.
* 해당 리팩토링 기법의 대안으로는 클래스 추출하기가 있으며, 선택 기준은 중복 동작을 상속과 위임 중 무엇으로 해결할 것인지에 따라 나뉜다.
  * 우선은 상대적으로 간단한 슈퍼클래스 추출하기 기법을 적용하고, 필요한 경우에 위임으로 어렵지 않게 바꾸는 방법이 이상적이다. 

### 슈퍼클래스 추출하기 - 절차
1. 빈 슈퍼클래스를 정의하고, 기존 클래스들이 새로운 클래스를 상속하도록 한 후에 테스트를 진행한다.
   * 필요한 경우, 생성자에 함수 선언 바꾸기 리팩토링 기법을 적용할 수 있다.
2. 생성자 본문 올리기, 메소드 올리기, 필드 올리기 기법을 차례로 적용하여 공통 요소를 슈퍼클래스로 옮겨준다.
3. 서브클래스에 남은 메소드들을 검토한다.
   * 공통된 부분이 남은 경우, 함수로 추출한 후에 메소드 올리기를 적용할 수 있다.
4. 기존 클래스들을 사용하는 코드를 검토하여 슈퍼클래스의 인터페이스를 사용하도록 할지 고려한다.

### 계층 합치기
* 클래스의 계층구조를 리팩토링하는 과정에서, 기능들은 자주 위로 올려지거나 아래로 내려온다.
* 이 과정에서 계층 구조는 진화하며, 어떤 부모 자식은 너무 비슷해져서 더는 독립될 필요가 없는 경우가 발생할 수 있다.
  * 이 때, 두 클래스 구조를 하나로 합쳐주는 것이 바람직하다.

### 계층 합치기 - 절차
1. 두 클래스 중 제거할 클래스를 선택한다.
   * 미래의 수정사항을 고려하여 더 적합한 이름의 클래스를 남기되, 둘 다 적합하지 않다면 임의로 하나를 선택한다.
2. 필드 올리기, 메소드 올리기, 또는 필드 내리기, 메소드 내리기 기법을 적용하여 모든 요소를 하나의 클래스로 옮겨준다.
3. 제거할 클래스를 참조하던 모든 코드가 남겨질 클래스를 참조하도록 수정한 후, 빈 클래스를 제거하고 테스트를 진행한다.

### 서브클래스를 위임으로 바꾸기
* 컨텍스트에 따라 동작이 달라지는 객체들을 상속으로 표현하는 것이 자연스럽다.
  * 예를 들어, 공통 데이터와 동작을 슈퍼클래스에 두고 서브클래스는 문맥에 맞게 기능을 추가하거나 오버라이드한다.
* 그러나 상속에는 다음과 같은 단점이 존재한다.
  1. 다중 상속이 안되는 경우가 많으므로, 한 번만 쓸 수 있는 카드이다.
  2. 상속은 클래스 간의 관계를 너무 긴밀하게 결합한다.
* **위임은 상술한 문제점을 모두 해결해줄 수 있으며, 특히 객체 사이의 일반적인 관계를 표현하므로 상속보다 결합도가 훨씬 약하다**.
* 상속보다는 컴포지션을 사용하라는 원칙은 상속을 절대 사용하지 말라는 의미로 받아들이지 말아야 한다.
  * **우선은 상속으로 접근하되, 철저히 리팩토링한다면 문제가 발생하더라도 언제든지 위임으로 수정할 수 있으므로 둘을 함께 사용하는 것이 이상적**이다.
  * 즉, **해당 리팩토링 기법은 상속이나 컴포지션 중 하나만 고집하기보다는 적절히 혼용하는 것을 권장**한다.
* 디자인 패턴의 관점에서, 해당 리팩토링 기법은 상태 패턴 또는 전략 패턴으로 서브클래스를 대체하는 방식에 해당한다.
  * 구조적으로 두 디자인 패턴은 모두 호스트 위임 방식으로 계층구조를 분리한다.
* 해당 리팩토링은 위임으로 인해 분배 로직과 양방향 참조가 더해지는 등의 복잡도가 생기므로, 그 자체만으로는 코드를 개선한 것이 느껴지지 않을 수 있다.
* 그러나 **서브클래스에서는 불가능했던 유형 간 동적인 수정이 가능하며, 다른 목적으로 상속을 사용할 수 있다는 점에서 여전히 가치가 있다**.  

### 서브클래스를 위임으로 바꾸기 - 절차
1. 생성자를 호출하는 곳이 많은 경우, 생성자를 미리 팩토리 메소드로 변경해둔다.
2. 위임으로 활용할 빈 클래스를 만들어준다.
   * 해당 클래스의 생성자는 서브클래스에 특화된 모든 데이터를 받아야 한다.
   * 또한, 일반적으로는 슈퍼클래스를 가리키는 역참조도 필요하다.
3. 위임을 저장할 필드를 슈퍼클래스에 추가한다.
4. 서브클래스 생성 코드를 수정하여 위임 인스턴스를 생성하고, 위임 필드에 대입하여 초기화한다.
   * 해당 작업은 팩토리 메소드가 수행한다.
   * 또는, 생성자가 정확한 위임 인스턴스를 생성할 수 있는 것이 확실한 경우에 한해 생성자에서 수행한다.
5. 서브클래스의 메소드 중 위임 클래스로 이동할 것을 고른다.
6. 함수 옮기기 기법을 적용하여 위임 클래스로 메소드를 옮기되, 기존 메소드에서 위임하는 코드는 지우지 않아야 한다.
   * 해당 메소드가 사용하는 원소 중 위임으로 옮겨야 하는 것이 있다면 함께 옮겨준다.
   * 슈퍼클래스에 유지해야할 원소를 참조하는 경우, 슈퍼클래스를 참조하는 필드를 위임에 추가한다.
7. 서브클래스의 외부에도 기존 메소드를 호출하는 코드가 있는 경우, 서브클래스의 위임 코드를 슈퍼클래스로 옮겨준다.
   * 이 경우, 위임이 존재하는지 검사하는 보호 코드로 감싸야 한다.
   * 호출하는 외부 코드가 없는 경우, 기존 메소드는 죽은 코드이므로 제거할 수 있다.
   * 서브클래스가 둘 이상이고, 서브클래스들 사이에서 중복이 발생하기 시작했다면 슈퍼클래스를 추출한다.
   * 이를 통해 기본 동작이 위임 슈퍼클래스로 옮겨진 경우, 슈퍼클래스의 위임 메소드들에는 보호 코드가 필요 없다.
8. 테스트를 진행한다.
9. 서브클래스의 모든 메소드가 옮겨질 때까지 5. ~ 8.의 과정을 반복한다.
10. 서브클래스들의 생성자를 호출하는 코드를 찾아 슈퍼클래스의 생성자를 사용하도록 수정한다.
11. 테스트를 진행한 후, 서브클래스를 삭제한다.

### 슈퍼클래스를 위임으로 바꾸기
* 상속은 기존 기능을 재활용하는 강력하고 손쉬운 수단이지만, 혼란과 복잡성을 키우는 방식으로 사용되기 쉽다.
* 슈퍼클래스의 기능들이 서브클래스에는 어울리지 않는 경우, 해당 기능은 상속을 통해 이용하면 안 된다는 신호로 받아들일 수 있다.
* 제대로 된 상속은 다음과 같은 특징을 갖는다.
  1. 서브클래스가 슈퍼클래스의 모든 기능을 사용한다.
  2. 서브클래스의 인스턴스는 슈퍼클래스의 인스턴스로도 취급할 수 있어야 한다.
* **이러한 특징을 간과한 모델링 실수는 자주 발견할 수 있으며, 이는 위임을 사용하여 객체를 분리하는 것으로 쉽게 해결**할 수 있다.
  * 위임을 사용하는 것으로 기능 일부만 빌려오는, 서로 별개인 개념이라는 사실이 명확해진다.
* 반면 서브클래스 방식의 모델링이 합리적일 때라도 슈퍼클래스를 위임으로 바꿀 수 있다.
  * 슈퍼클래스와 서브클래스 관계는 강하게 결합된 관계이므로, 슈퍼클래스를 수정하면 서브클래스가 망가지기 쉽기 때문이다.
* 위임 역시 단점은 존재하며, 예를 들어 위임의 기능을 활용하기 위한 호스트의 함수는 모두 전달 함수로 작성하는 지루한 작업을 필요로 한다.
* 상속은 절대 사용하지 말아야할 기능이 아니며, 의미상 적합한 조건에서 사용한다면 간단하고 효과적인 메커니즘에 해당한다.
  * 예를 들어, 상위 타입의 모든 메소드는 하위 타입의 메소드에도 적용되어야 한다.
  * 또한, 하위 타입의 모든 인스턴스는 상위 타입의 인스턴스이기도 해야 한다.
* **시간이 지나 상황이 바뀌어 상속이 더 이상 최선의 방법이 아닐지언정, 언제든지 해당 리팩토링 기법을 통해 슈퍼클래스는 위임으로 변경할 수 있다**.
  * 따라서 **왠만해서는 상속을 먼저 적용하되, 추후에 문제가 발생한 경우에 슈퍼클래스를 위임으로 바꾸는 것이 바람직**하다.

### 슈퍼클래스를 위임으로 바꾸기 - 절차
1. 슈퍼클래스 객체를 참조하는 필드를 서브클래스에 정의한다.
   * 해당 리팩토링 기법을 적용하면 슈퍼클래스가 위임 객체가 될 것이므로, 추가한 이 필드는 위임 참조라고 부를 수 있다.
2. 위임 참조를 새로운 슈퍼클래스 인스턴스로 초기화한다.
3. 슈퍼클래스의 동작 각각에 대응하는 전달 함수를 서브클래스에 정의하되, 위임 참조로 전달한다.
   * 관련된 함수끼리 그룹화하여 진행하되, 그룹을 하나 만들 때마다 테스트를 진행한다.
   * 대부분은 전달 함수 각각을 테스트할 수 있지만, 게터와 세터 쌍과 같이 그룹으로 옮긴 후에야 테스트할 수 있는 것도 있다.
4. 슈퍼클래스의 동작 모두가 전달 함수로 오버라이드된 것이 확인되었다면, 상속 관계를 끊도록 한다.
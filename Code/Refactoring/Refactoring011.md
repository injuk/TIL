# Refactoring
## 2022-04-25 Mon

## 상속 다루기
### 메소드 올리기
* 코드가 중복되었다는 사실은 한쪽의 변경사항이 다른 쪽 코드에 반영되지 않을 수 있는 위험을 수반하므로, 중복 코드의 제거는 언제나 중요하다.
* 서브클래스들 사이의 유사한 메소드에서, 본문 코드가 항상 같은 경우는 많지 않으므로 차이점에 집중하는 방법이 효과가 좋다.
* 반면, 해당 리팩토링을 적용하기 가장 복잡한 상황은 메소드의 본문에서 참조하는 필드들이 서브클래스에만 있는 경우이다.
  * 이 경우, 우선 필드를 슈퍼클래스로 옮기는 방식을 선행할 수 있다.
* 두 메소드의 흐름은 유사하지만 세부 내용이 다른 경우, 템플릿 메소드 패턴의 적용을 고려할 수 있다.

### 메소드 올리기 - 절차
1. 동일하게 동작하는 메소드인지 면밀하게 확인한다.
   * 실질적으로 하는 일이 같지만 내부 코드가 다른 경우, 우선 본문의 내용이 같아질 때까지 리팩토링을 수행한다.
2. 메소드 내부에서 호출하는 다른 메소드와 참조하는 필드들을 슈퍼클래스에서도 호출하고 참조할 수 있는지 확인한다.
3. 메소드 시그니쳐가 다른 경우, 함수 선언 바꾸기로 슈퍼클래스에서 사용하고자하는 형태로 통일한다.
4. 슈퍼클래스에 새로운 메소드를 정의하고, 대상 메소드의 코드를 복사한 후에 정적 검사를 수행한다.
5. 서브클래스 중 하나의 메소드를 제거한 후 테스트를 진행한다.
6. 모든 서브클래스의 메소드가 없어질 때까지 다른 서브클래스의 메소드를 하나씩 제거해나간다.

### 필드 올리기
* 서브클래스들이 독립적으로 개발되었거나, 뒤늦게 하나의 계층구조로 리팩토링된 경우라면 일부 기능이 중복된 경우가 있을 수 있다.
  * 예를 들어, 필드가 중복될 수 있다.
* 중복된 필드들은 일반적으로 이름이 유사하지만, 항상 그렇지는 않으므로 우선 필드들이 어떻게 사용되는지 분석할 필요가 있다.
* 분석한 결과 필드들이 유사한 방식으로 사용되는 경우가 맞다면, 이들을 슈퍼클래스로 끌어올릴 수 있다.
* **해당 리팩토링 기법을 통해 중복된 데이터의 선언을 없앨 수 있고, 해당 필드를 사용하는 동작 역시 슈퍼클래스로 옮길 수 있게 된다**.

### 필드 올리기 - 절차
1. 후보 필드들을 사용하는 곳 모두가 해당 필드들을 똑같은 방식으로 사용하고 있는지 신중히 확인한다.
2. 필드들의 이름이 서로 다른 경우, 동일한 이름으로 바꾸어준다.
3. 슈퍼클래스에서 새로운 필드를 생성하되, 서브클래스에서 해당 필드에 접근할 수 있도록 제한한다.
   * Java의 예를 들면 protected 제한자를 적용할 수 있다.
4. 서브클래스의 필드들을 제거한 후, 테스트를 진행한다.

### 생성자 본문 올리기
* 생성자는 일반적인 메소드에 비해 다루기가 까다로운 편에 속한다.
  * 생성자는 할 수 있는 일과 호출 순서에 제약이 있기 때문이다.
* 해당 리팩토링 기법을 적용할 수 없거나 어려운 경우, 생성자를 팩토리 메소드로 바꾸는 리팩토링 기법을 고려할 수 있다.

### 생성자 본문 올리기 - 절차
1. 슈퍼클래스에 생성자가 없다면 새로 정의한 후, 서브클래스의 생성자에서 해당 생성자를 호출하는지 확인한다.
2. 문장을 슬라이드하여 공통된 문장을 모두 super() 호출 직후로 옮겨준다.
3. 공통 코드를 슈퍼클래스에 추가하고, 서브클래스에서 제거한다.
4. 생성자 매개변수 중, 공통 코드에서 참조하는 값은 모두 super() 로 넘겨준 후 테스트를 진행한다.
5. 생성자의 시작 부분으로 옮길 수 없는 공통 코드는 우선 함수로 추출한 후 메소드를 슈퍼클래스로 옮기도록 한다.

### 메소드 내리기
* 특정 서브클래스와 관련된 메소드는 슈퍼클래스에서 제거하고 해당 서브클래스에 추가하는 것이 바람직하다.
* 그러나 해당 리팩토링 기법은 기능을 제공하는 슈퍼클래스가 정확히 무엇인지 클라이언트 코드가 알고 있을 때에만 적용이 가능하다.
  * **그렇지 못한 경우, 서브클래스에 따라 달리 동작하는 슈퍼클래스의 조건부 로직을 다형성으로 변경**해야 한다.

### 메소드 내리기 - 절차
1. 대상 메소드를 모든 서브클래스에 복사한 후, 슈퍼클래스에서 해당 메소드는 제거하고 테스트를 진행한다.
2. 해당 메소드를 사용하지 않는 모든 서브클래스에서 메소드를 제거한 후, 테스트를 진행한다.

### 필드 내리기
* 특정 서브클래스에서만 사용되는 필드는 해당 서브클래스로 옮겨주는 것이 바람직하다.

### 필드 내리기 - 절차
1. 대상 필드를 모든 서브클래스에 정의한 후, 슈퍼클래스에서 해당 필드를 제거하고 테스트를 진행한다.
2. 해당 필드를 사용하지 않는 모든 서브클래스에서 필드를 제거한 후, 테스트를 진행한다.

### 타입 코드는 서브클래스로 바꾸기
* 시스템에서는 비슷한 대상을 임의의 특성에 따라 구분해야할 때가 있다.
* 이러한 일을 다루기 위해 타입 코드 필드를 적용할 수 있으며, 이는 언어에 따라 열거형, 심볼, 문자열 등으로 표현할 수 있다.
* **타입 코드만으로 대부분 요구사항을 충족할 수 있으나, 때로는 서브클래스를 도입해야할 필요**가 있다.
* 서브클래스를 도입하는 경우, 다음과 같은 측면에서의 이점이 있다.
  1. 조건에 따라 다르게 동작하는 다형성을 제공하므로, 조건부 로직을 다형성으로 수정할 수 있다.
  2. 특정한 타입에서만 의미가 있는 값을 사용하는 필드나 메소드를 서브클래스에 정의할 수 있다.
     * 이는 타입 코드를 사용하는 경우에도 검증 코드로 구현할 수 있으나, 서브클래스 방식이 관계를 좀 더 명확히 드러낸다.
* **해당 리팩토링 기법은 대상 클래스에 직접 적용할지, 타입 코드 자체에 적용할지 고려**해야 한다.
  * 직원 유형을 예로 들어, 전자는 직원의 유형별 하위 타입을 정의하는 반면 후자는 유형 자체를 클래스로 추출한다.
  * 대부분의 경우 대상 클래스를 직접 서브클래스로 만드는 것이 간단하지만, 모든 상황에 적용 가능한 방법은 아니다.
  * 예를 들어, 대상 클래스에 이미 서브클래스가 존재하거나 타입 코드를 동적으로 변경하고 싶은 경우가 이에 해당한다.

### 타입 코드는 서브클래스로 바꾸기 - 절차
1. 타입 코드 필드를 자가 캡슐화한다.
2. 타입 코드 값 하나를 선택하여 해당 값에 해당하는 서브클래스를 정의한다.
3. 타입 코드 게터를 오버라이드하여 해당 타입 코드의 리터럴 값을 반환하도록 정의한다.
4. 매개변수로 받은 타입 코드와 2.에서 정의한 서브클래스를 매핑하는 선택 로직을 정의한다.
   * 직접 상속인 경우 생성자를 팩토리 메소드로 바꾸기 기법을 적용하고, 선택 로직을 팩토리에 정의한다.
   * 간접 상속인 경우, 선택 로직을 생성자에 두도록 구현한다.
5. 테스트를 진행한다.
6. 타입 코드 값 각각에 대해 서브클래스 생성과 선택 로직의 추가를 반복하되, 하나의 클래스가 완성될 때마다 테스트를 진행한다.
7. 타입 코드 필드를 제거한 후 테스트를 진행한다.
8. 타입 코드 접근자를 이용하는 메소드 모두에 메소드 내리기와 조건부 로직을 다형성으로 바꾸기 기법을 적용한다.
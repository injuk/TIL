# Refactoring
## 2022-04-12 Tue

## 리팩토링 원칙
### 리팩토링의 정의
* 리팩토링은 일반적으로 코드를 정리하는 작업 전반을 가리키기 위해 두루뭉술하게 사용되는 용어이지만, 다음과 같이 명사와 동사로 명확히 정의내릴 수 있다.
  1. 명사: 소프트웨어의 겉보기 동작은 유지한 채, **코드를 이해하고 수정하기 쉽도록 내부 구조를 변경하는 '기법'**.
  2. 동사: 소프트웨어의 겉보기 동작은 유지한 채, **여러 리팩토링 기법을 적용하여 소프트웨어를 재구성**하는 것.
* 상술한 정의에 따를 경우, 리팩토링의 의미는 다음과 같이 구체적으로 정의할 수 있다.
```
> 리팩토링은 특정한 방식에 따라 코드를 정리하는 과정이다.
```
* **리팩토링은 동작을 보존하는 작은 단계들을 거쳐 코드를 수정하며, 이러한 단계들을 순차적으로 연결하여 큰 변화를 이끌어내는 일**이다.
  * 개별 리팩토링은 아주 작은 단계일 수도 있고, 작은 단계 여럿이 합쳐진 모습일 수도 있다.
* 중요한 것은 **리팩토링 과정에서 코드는 항상 정상 동작하므로, 전체 리팩토링 작업이 끝나지 않았더라도 언제든지 멈출 수 있어야 한다**.
  * 때문에 **리팩토링 과정에서 코드가 깨지는 일은 근본적으로 발생할 수 없으며, 이는 리팩토링이라고 부를 수 없는 무언가를 수행한 것**과 같다.
  * 코드베이스를 정리하거나 구조를 변경하는 작업 전반은 재구성으로 분류할 수 있으며, 리팩토링은 재구성의 특수한 하나의 형태로 볼 수 있다.
* 단계를 작게 나누는 리팩토링은 비효울적이라고 오인되기 쉽지만, 각 단계들은 체계적으로 구성되고 디버깅에 시간을 쓰지 않으므로 전체적으로는 오히려 더 빠르다.
* **리팩토링에서의 겉보기 동작이 유지된다는 의미는 리팩토링 전과 이후의 코드는 사용자 관점에서 똑같이 동작해야 한다는 의미**를 갖는다.

### 리팩토링과 성능 최적화
* 리팩토링과 성능 최적화는 모두 코드를 변경하되 프로그램의 기능은 유지하는 공통점이 있다.
* 그러나 각 기법의 목적은 다음과 같은 차이를 갖는다.
  1. 리팩토링: 코드를 이해하고 수정하기 쉽게 만드는 데에 목적이 있으므로, **성능은 좋아지거나 나빠질 수 있다**.
  2. 성능 최적화: 오로지 속도 개선에만 신경쓰므로, **목표 성능에 도달하기까지 코드의 가독성은 더 나빠질 수도 있다**.

### 리팩토링과 기능 추가
* 소프트웨어 개발 과정에서의 목적이 신규 기능의 추가인지, 리팩토링인지를 명확히 구분하여 작업해야 한다.
  * 이를 두 개의 모자에 비유할 수 있다.
  * 리팩토링 모자를 쓰고 있는 동안은 신규 기능의 추가를 하지 않고, 기능 추가 모자를 쓰는 동안은 리팩토링에 신경쓰지 않는다.
* **신규 기능을 추가할 때에는 기존 코드를 절대로 건드리지 않고 새로운 기능을 추가하기만 해야 한다**.
  * 이 과정에서의 진척도는 테스트를 추가해서 통과하는지 확인하는 방식으로 측정한다.
* **리팩토링 시에는 신규 기능을 절대로 추가하지 않으며, 부득이한 경우가 아니라면 테스트 케이스도 추가하지 않고 코드의 재구성에만 전념**한다.
```
> 소프트웨어 개발 시에는 항상 내가 현재 초점을 맞추는 작업의 종류가 무엇인지와, 이에 따른 미묘한 작업 방식의 차이를 분명히 인식해야 한다.
```

### 왜 리팩토링을 해야하는가?
* 리팩토링이 소프트웨어가 갖는 모든 문제점을 해결해주지는 못할지언정, **코드를 건강한 상태로 유지하는 데에는 큰 도움을 줄 수 있는 것은 분명**하다.
* 리팩토링을 통해 다음과 같은 이점을 얻을 수 있다.
  1. 소프트웨어 설계가 좋아질 수 있다.
  2. 소프트웨어를 이해하기 쉬워질 수 있다.
  3. 버그를 쉽게 찾을 수 있다.
  4. 개발 속도를 높일 수 있다.

### 리팩토링을 통해 소프트웨어의 설계가 좋아질 수 있다.
* 아키텍쳐를 충분히 이해하지 못한 상태에서 단기적인 목표를 위해 코드를 수정하다 보면 기반 구조는 무너지기 쉽다.
  * 이 경우 코드만 봐서는 설계를 파악하기 어려워지며, 설계를 파악하기 어려워질수록 설계를 유지하기 어려워진다.
  * 결과 설계가 무너지는 속도는 점차 가속된다.
* 반면 규칙적인 리팩토링 습관은 코드의 구조를 지탱해줄 수 있다.
* **바람직한 설계의 핵심은 중복 코드를 제거하여 모든 코드가 언제나 고유한 일을 수행함을 보장하는 것**이다.
  * **긴 코드가 차지하는 프로그램의 용량이 속도에 영향을 주는 경우는 거의 없지만, 코드의 길이가 줄면 수정하는 데에 드는 노력이 크게 줄어**든다.
  * 반면 코드가 길수록 버그 없이 코드를 수정하기 어려워지므로, 중복 코드는 제거되어야 한다.

### 리팩토링을 통해 소프트웨어를 이해하기 쉬워진다.
* 프로그래밍은 내가 원하는 바를 소스 코드로 정확히 표현하는 일이지만, 소스 코드는 컴퓨터만 사용하는 것이 아니다.
  * 내가 작성한 코드는 몇 달 내로 다른 누군가가 다시 읽고 이해해야하는 경우가 많다.
* **프로그래밍에서 가장 중요한 것은 컴퓨터가 아닌 사람이지만, 이는 간과되기 쉬운 사실**이기도 하다.
  * 코드를 컴파일하기 위해 다소의 시간이 더 들더라도 누가 뭐라고 할 일은 없다.
  * 반면, 개발자가 코드를 이해하는 데에 드는 시간으로 인해 기능의 수정이 너무 오래 걸리는 경우는 이야기가 달라진다.
* 프로그램을 동작시키는 데에만 신경쓰다 보면 추후 코드를 읽게 될 개발자를 배려하지 못하는 경우가 많다.
  * 사실, 추후에 코드를 읽게 될 개발자는 다른 누군가가 아닌 나 자신일 확률이 높다.
* **리팩토링은 코드가 더 잘 읽힐 수 있도록 도울 수 있으므로, 이상적이지 않은 구조의 코드가 있다면 시간을 내서 리팩토링할 필요**가 있다.
* **이상적인 것은 기억할 필요가 있는 내용을 모두 코드에 녹여내어 사람이 기억할 필요 없도록 하는 것**이다.

### 리팩토링을 통해 버그를 쉽게 찾을 수 있다.
* 코드를 이해하기 쉽다는 것은 곧 버그를 찾기 쉽다는 것과 같다.
* **리팩토링을 통해 코드가 하는 일을 깊이 파악할 수 있으며, 새로 깨달은 것은 바로 코드에 반영할 수 있다**.
* 프로그램의 구조를 명확히 다듬는 것으로 난무하던 추측이 명확히 드러나며, 이윽고 버그를 지나칠 수 없을 정도에 이를 수 있다.
* **리팩토링은 견고한 코드를 작성하는 데에도 효과적**이다.

### 리팩토링을 통해 프로그래밍 속도를 높일 수 있다.
* **상술한 장점은 모두 리팩토링을 통해 코드 개발 속도를 높일 수 있다는 사실로 귀결**된다.
* 일반적으로 프로젝트 초기에는 진척이 빠르지만, 프로젝트가 성숙함에 따라 신규 기능을 추가할수록 개발 속도는 더뎌진다.
  * 새로운 기능을 추가할수록 기존 코드에 녹여낼 방법을 찾기 어려워지며, 버그의 발생 가능성도 높아진다.
  * 이러한 부담이 신규 기능 개발 속도를 점차 떨어트리며, 종국에는 프로젝트를 처음부터 새로 개발하고 싶은 유혹에 빠지게 한다.
* 반면 **리팩토링을 통해 견고한 설계를 유지한 프로젝트는 초기에는 시간을 더 소모하지만, 새로운 기능을 추가할 지점과 고칠 방법을 쉽게 찾아낼 수 있다**.
  * 모듈화가 잘 되어 있으면 전체 코드베이스 중 일부만 이해하면 되며, 명확한 코드는 버그의 가능성을 줄이고 디버깅을 용이하게 한다.
  * 이렇듯 **내부 품질이 뛰어난 코드베이스는 신규 기능의 추가를 돕는 견고한 토대**가 되어줄 수 있다.

### 설계의 과거와 현재
* 과거에는 코딩 단계에 들어서는 순간부터 코드는 부패하므로, 설계를 잘한다는 것은 곧 코딩을 시작하기 전에 완벽히 설계를 마치는 것을 의미했다.
* 그러나 **리팩토링을 도입하면 언제든지 기존 코드의 설계를 개선할 수 있으므로, 프로그램의 요구사항이 변경되더라도 설계를 지속해서 개선**할 수 있다.
* 처음부터 완벽한 설계를 얻어내는 것은 매우 어려운 일이므로, 빠른 개발이라는 목표를 달성하려면 리팩토링이 반드시 필요하다.

### 준비를 위한 리팩토링하기
* 리팩토링하기 가장 좋은 시점은 코드베이스에 새로운 기능을 추가하기 직전이다.
  * 따라서, 이 시점에서 자신의 코드를 살펴보면서 구조를 바꾸었을 때 신규 작업을 수행하기 쉬워질만한 부분을 찾아낸다.
* 버그를 잡을 때에도 마찬가지이며, 오류를 일으키는 코드가 여러 곳에 복제되어 퍼져 있다면 한 곳으로 합치는 편이 작업하기에 더 편하다.
* 이러한 준비를 위한 리팩토링으로 상황을 사전에 개선해두면 버그가 수정된 상태가 오래 지속될 가능성을 높이며, 같은 곳에서 다른 버그가 발생할 가능성을 줄인다.

### 이해를 위한 리팩토링하기
* **코드를 수정하려면 우선 해당 코드가 하는 일을 이해해야 하므로, 코드를 파악할 때마다 해당 코드의 의도가 명확히 드러나도록 리팩토링할 수 있는지 고민**한다.
  * **사람은 파악한 모든 것을 기억할 수는 없지만, 리팩토링을 통해 이해한 것을 코드에 옮겨 담을 수는 있다**.
* 이해를 위한 리팩토링을 통해 어떤 역할을 수행하는지 이해된 변수와 함수를 적절한 이름으로 변경하고, 긴 함수를 작게 나누도록 하는 과정을 거치도록 한다.
* **이해를 위한 리팩토링을 통해 코드는 깔끔하게 정리되고, 나아가 이전에는 보이지 않았던 설게가 눈에 들어오기 시작할 수도 있다**.
```
> 코드를 분석하면서 리팩토링을 수행하는 경우, 그렇지 않았다면 도달하지 못했을 깊은 수준의 이해에 다다를 수 있다.
```

### 쓰레기 줍기 리팩토링
* 코드를 파악하는 과정에서 비효율적으로 처리되는 로직을 발견할 수도 있다.
  * 쓸데없이 복잡하거나, 거의 유사한 함수 여럿으로 처리되는 로직이 대표적인 예시이다.
* 이 경우, **간단히 수정할 수 있는 것은 즉시 고치되 시간이 걸리는 일은 메모를 남기고 나중에 처리하는 쓰레기 줍기 리팩토링을 적용**할 수 있다.
* 물론 당장은 더 급한 일이 있을 수는 있으나, 보이스카웃 규칙이 제안하듯 항상 처음보다 깔끔하게 정리하고 떠나는 습관을 들이는 것이 바람직하다.
  * 리팩토링의 장점은 작게 나뉜 작업 단계가 전체 코드를 깨트리지 않는다는 사실이며, 심지어 오랜 기간에 걸쳐 리팩토링하더라도 코드가 깨지지 않을 수도 있다.
  * 이를 이용하여 코드를 확인할 때마다 조금씩 개선하면 언젠가는 결국 문제가 해결될 수 있다.

### 계획된 리팩토링, 상시 리팩토링
* 상술한 리팩토링 기법은 모두 기회가 될 때에만 진행하도록 한다.
* **리팩토링은 별도의 일정을 잡고 수행해야 하는 프로그래밍과 별개의 작업이 아니며, 대부분의 리팩토링을 가른 작업을 수행하는 중에 처리**해야 한다.
  * 즉, **기능을 추가하거나 디버깅을 하는 과정에서 리팩토링도 함께 진행할 수 있도록 프로그래밍 과정에 자연스럽게 녹아들어야 한다**.
* 보기 싫은 코드 뿐만 아니라 잘 작성된 코드 역시 계속된 리팩토링을 거쳐야 한다.
  * 어제는 적합했던 리팩토링 기준이 오늘에는 맞지 않을 수 있으므로 변경해야할 수 있으며, 이 때 코드가 이미 깔끔하다면 리팩토링의 난이도는 낮아진다.
* 반면 계획된 리팩토링이 항상 나쁜 것은 아니며, 그동안 리팩토링을 수행하지 않았다면 별개의 일정을 잡아 코드베이스를 개선할 필요가 있다.
* 이렇게 투자한 리팩토링 효과는 두고두고 누릴 수도 있으나, 이러한 **계획된 리팩토링은 최소한으로 줄여야 한다**.
```
> 리팩토링 작업의 대부분은 드러나지 않게, 기회가 될 때마다 수행하는 것이 바람직하다.
```

### 오래 걸리는 리팩토링
* 리팩토링은 길어도 몇 시간 안에는 끝나지만, 팀 전체가 달려들어도 몇 주는 걸리는 대규모 리팩토링도 존재할 수 있다.
* 그럼에도 불구하고 **팀 전체가 리팩토링에 매달리는 것보다는 문제를 몇 주에 걸쳐 조금씩 해결해나가는 편이 효과적인 경우가 많다**.
  * 이는 리팩토링이 코드를 깨트리지 않는다는 장점을 활용하는 것이다.
  * 이러한 장점을 활용하면 누구든지 리팩토링해야 할 코드와 관련된 작업을 수행할 때마다 원하는 방향으로 조금씩 개선할 수 있다.

### 코드 리뷰를 통한 리팩토링
* 리팩토링은 다른 개발자의 코드를 리뷰하는 데에도 도움될 수 있다.
  * 리팩토링 전에 코드를 읽고, 이해한 뒤에 몇 가지 개선 사항을 제시한다.
  * 개선사항을 즉시 구현할 수 있다면 리팩토링하고, 이 과정을 몇 번 반복하는 과정에서 실제로 리팩토링하지 않고는 떠올릴 수 없는 아이디어가 떠오르기도 한다.
* 리팩토링은 코드 리뷰의 결과를 더 구체적으로 도출하는 데에도 도움될 수 있다.
  * 코드의 개선안을 제안하는데서 그치지 않고, 더 나아가 상당수를 즉시 구현해볼 수 있으므로 큰 성취감을 얻을 수 있다.
* 코드 리뷰에 리팩토링을 접목하는 구체적인 방식은 리뷰의 성격에 따라 다르다.
  * 풀 리퀘스트 방식은 코드 작성자가 참석하지 않으므로 효과적이지 못하다.
  * 반면 **작성자와 리뷰어가 함께 앉아 리팩토링을 진행할 수 있는 페어 프로그래밍 방식에서는 큰 도움**이 될 수 있다.

### 관리자와 리팩토링
* 관리자가 소프트웨어 기술에 정통하다면 리팩토링의 필요성을 쉽게 설득할 수 있으므로, 팀의 리팩토링이 과도할 수는 있을지언정 부족해질 일은 거의 없다.
* **기술을 모르는 대부분의 관리자와 고객은 코드베이스의 건강 상태가 생산성에 미치는 영향을 모르므로, 차라리 리팩토링한다는 사실을 알리지 않는 것이 좋다**.
  * 소프트웨어 개발자는 프로이며, 효과적인 소프트웨어를 최대한 빠르게 만들어내야 한다.
  * 새로운 기능을 추가하거나 버그를 수정하는 모든 상황에서 리팩토링부터 진행하는 것이 언제나 빠른 결과를 산출하므로, 차라리 말하지 말고 리팩토링하도록 한다.

### 리팩토링을 하지 말아야 하는 경우
* 굳이 수정할 필요가 없는 코드라면 지저분하더라도 리팩토링하지 않는다.
  * 외부 API를 다루듯이 호출해서 사용하는 코드라면 지저분해도 무방하다.
  * 이렇듯 **리팩토링은 내부 동작을 이해해야할 시점에 진행해야 효과를 볼 수 있다**. 
* **리팩토링을 진행하는 것보다 새로 작성하는 것이 쉬울 때에도 리팩토링하지 않는다**.
  * 그러나 이는 리팩토링을 해보기 전에는 어느 쪽이 더 쉬운지 알 수 없는 경우가 많으므로, 많은 경험이 뒷받침되어야 한다.

### 리팩토링 시 고려해야할 문제들
* 리팩토링은 적극적으로 도입해야 할 기법이지만, 리팩토링이 수반하는 문제도 엄연히 존재하므로 이런 문제가 언제 발생하고 어떻게 대처하는지 또한 숙지해야 한다.

### 리팩토링의 궁극적인 목적은 개발 속도를 높이는 데에 있다
* 그러나 여전히 리팩토링으로 인해 개발 속도가 늦어진다고 생각하는 사람이 많다.
* 리팩토링의 궁극적인 목적은 개발 속도를 높이고 비용을 낮추는 데에 있으므로, 대부분의 팀은 리팩토링을 더 자주 하도록 노력해야 한다.
* 가장 위험한 오류는 리팩토링을 미적 기준 또는 프로그래머의 도덕적인 자세로 정당화하는 것이다.
  * **리팩토링의 본질이자 리팩토링을 이끄는 동력은 오로지 경제적인 이유에 있으며, 도덕 또는 미적인 관점은 이에 포함되지 않는다**.

### 너무 세분화된 코드 소유권은 리팩토링에 방해가 된다
* 일반적으로 코드의 소유권을 팀에 두어 팀원이라면 누구나 코드를 수정할 수 있도록 하는 방식이 이상적이다.
* 코드 소유권을 느슨하게 적용하는 방식은 여러 팀으로 구성된 조직에도 적용할 수 있다.

### 기능 브랜치 방식의 주의점
* 일반적으로 사용되는 팀 단위의 작업 방식은 팀원마다 코드베이스의 브랜치를 하나씩 따서 작업하고, 어느 정도 쌓이면 마스터에 통합하여 공유하는 것이다.
  * 머지는 마스터 브랜치의 내용을 개인 브랜치로 가져와 업데이트하므로, 마스터 브랜치는 그대로이다.
  * 통합은 마스터 브랜치의 내용을 개인 브랜치로 가져온 후 작업 결과를 다시 마스터에 올리므로, 마스터 브랜치도  변경된다.
* 이러한 기능 브랜치 방식은 독립 브랜치로 작업하는 기간이 길어질수록 작업 결과를 마스터로 통합하기 어려운 단점이 있다.
  * 최신 버전 관리 시스템은 복잡한 변경 사항을 텍스트 수준에서 머지하는 데에는 뛰어나지만, 그 속에 담긴 코드의 의미를 파악할 수 없다.
* 이렇듯 **머지가 복잡해지는 문제는 기능 별 브랜치의 독립적인 개발 기간이 길어질수록 기하급수적으로 높아진다**.
* **해당 문제점은 최소 하루에 한 번은 마스터와 통합하는 지속적인 통합(CI)를 적용하여 해결**할 수 있다.
  * CI는 단순히 머지 복잡도를 줄일 수 있어서 선호되기도 하지만, 무엇보다 리팩토링과 궁합이 잘 맞는 장점이 있다.
* 이는 기능 별 브랜치의 사용을 지양해야한다는 의미가 아니며, 오히려 브랜치를 자주 통합할 수 있다면 문제의 발생 가능성으 ㄹ크게 줄일 수 있다.
```
> CI를 완벽히 적용할 수는 없더라도 마스터와의 통합 주기는 최대한 짧게 잡는 것이 바람직하다.
```

### 테스팅을 위한 자가 테스트 코드 마련하기
* 리팩토링의 핵심은 겉보기 동작이 유지된다는 것이며, 이는 다양한 측면을 검사하는 테스트 스위트를 기반으로 얻어지는 특징이다.
  * 즉, 리팩토링을 위해서는 자가 테스트 코드를 반드시 마련해야 한다.
* **자가 테스트 코드는 리팩토링을 지원할 뿐만 아니라, 새로운 기능을 훨씬 안전하게 추가할 수 있도록 한다**.
* 또한, 리팩토링 과정에서 버그가 발생하기 쉽다는 불안감을 해소할 수 있다.
* 가능하다면 자가 테스트 코드를 마련하는 것이 바람직하다.
  * 이는 **자가 테스트 코드가 반드시 필요하다기보다는 마련해두면 유용하게 사용할 수 있기 때문**이다.

### 레거시 코드의 개선
* 레거시 시스템을 파악할 때에도 리팩토링은 큰 도움이 된다.
  * 그러나 **대규모 레거시 시스템을 테스트 코드 없이 리팩토링하기에는 어려우며, 이를 해결하기 위해 테스트를 보강**해야 한다.
* 그러나 이는 상당히 어려운 작업이며, 난감한 상황에서 빠져나오기 위한 더 쉬운 방법도 존재하지 않는다.
  * **때문에 처음부터 자가 테스트 코드를 작성하는 것이 중요**하다.
* 테스트를 갖추었더라도 레거시 코드를 리팩토링하는 것은 어려운 작업이며, 서로 관련된 부분끼리 나누어 하나씩 공략해나가는 식으로 리팩토링을 수행한다.

### 데이터베이스 리팩토링
* 데이터베이스와 관련된 리팩토링은 커다란 변경들을 쉽게 조합하고 다룰 수 있는 데이터 마이그레이션 스크립트를 작성하고, 이를 활용하여 통합한다.
  * 예를 들어, 접근 코드와 데이터베이스 스키마에 대한 구조적 변경을 해당 스크립트로 처리하도록 통합한다.
* 다른 리팩토링과 마찬가지로 이 기법 역시 전체 변경 과정을 작고 독립된 단계들로 나누는 것이 핵심이다.
* 반면, 데이터베이스 리팩토링은 프로덕션 환경에 여러 단계로 나누어 릴리즈하는 것이 일반적으로 좋다는 점에서는 다른 리팩토링과는 다르다.

## 2022-04-13 Wed
### 리팩토링과 YAGNI
* 리팩토링은 수 년 간 운영되던 소프트웨어더라도 아키텍쳐를 대폭 변경할 수 있도록 지원한다.
* 즉, 리팩토링이 아키텍쳐에 미치는 실질적인 효과는 요구사항 변화에 자연스럽게 대응할 수 있도록 코드베이스를 잘 설계해준다는 점에 있다.
  * 코딩 전에 아키텍쳐를 확정지을 수 있으려면 모든 요구사항이 사전에 파악되어야 하는데, 이는 실질적으로 불가능에 가깝다.
  * 실제로는 소프트웨어를 사용해보고 업무에 미치는 영향을 확인하고 나서야 원하는 바를 얻게 되는 경우가 흔하다.
* 요구사항 변화에 대응할 수 있도록 하는 방법 중 하나는 유연성 메커니즘을 코드에 심어두는 것이다.
  * 예를 들어 함수에 설정하는 매개변수는 여러 상황에서 함수를 재사용할 수 있도록 하기 위한 유연성 메커니즘이다.
* 그러나 유연성을 위해 모든 상황을 고려하다보면 오히려 유연성 메커니즘이 변화에 대응하는 능력을 떨어트릴 수도 있다.
* 리팩토링을 활용하면 이를 다르게 접근할 수 있으며, 앞으로 있을 변경에 대비한 유연성을 추측하기보다는 현재까지 파악된 요구사항만을 해결하는 데에 집중한다.
  * 이 과정에서, 요구사항을 더 잘 이해하게 되면 아키텍쳐를 그에 맞추어 리팩토링한다.
* **리팩토링을 미루면 일이 훨씬 힘들어진다는 확신이 들 때에만 유연성 메커니즘을 미리 추가하도록 한다**.
  * 함수를 예로 들어 항상 같은 값을 넘기는 시점에는 굳이 매개변수화하지 않고, 요구사항이 변경되어 유연성이 필요할 때에 도입한다.
* 이러한 방식의 설계는 간결한 설계, 또는 YAGNI에 해당한다.
* **YAGNI는 아키텍쳐를 고려하지 않아야한다는 원칙이 아니며, 오히려 아키텍쳐와 설계를 개발 프로세스에 녹이는 또 다른 방식**이다.
  * 이러한 방식은 리팩토링의 지원 없이는 효과를 볼 수 없다.

### 리팩토링과 애자일 소프트웨어 방법론
* 리팩토링은 익스트림 프로그래밍에 도입되며 퍼지기 시작한 개념이다.
  * XP의 두드러진 특징은 지속적인 통합과 자가 테스트 코드, 리팩토링 등 개성이 강하면서 서로 의존하는 기법들을 하나로 묶은 프로세스라는 점에 있다.
  * 이 때, 자가 테스트 코드와 리팩토링은 테스트 주도 개발이라는 용어로 묶어서 사용할 수 있다.
* XP는 최초의 애자일 소프트웨어 방법론 중 하나로 등장하였으며, 현재에는 대다수의 프로젝트에서 애자일을 적용하여 주류로 자리잡았다.
  * 그러나 **애자일을 제대로 적용하려면 리팩토링에 대한 팀의 역량과 열정이 뒷받침되어 프로세스 전반에 리팩토링이 자연스럽게 수행되도록 해야 한다**.
* 리팩토링의 근간이 되는 토대는 크게 다음과 같다.
  1. 자가 테스트 코드: 테스트는 리팩토링을 지원하는 굉장히 중요한 토대이다.
  2. 지속적인 통합: **팀으로 개발하며 리팩토링을 수행한다면, 각 팀원은 다른 사람의 작업을 방해하지 않으면서도 언제든지 리팩토링할 수 있어야 한다**.
     * 지속적인 통합을 통해 팀원 각자의 리팩토링 결과를 빠르게 공유할 수 있다.
     * 자가 테스트 코드는 지속적인 통합의 핵심 요소이기도 하다.
* **이러한 특징으로 인해 자가 테스트 코드와 지속적인 통합, 리팩토링은 서로 강력한 시너지를 발휘**한다.
* 또한 상술한 세 가지 실천법을 적용한다면 YAGNI 설계 방식으로 개발을 진행할 수도 있다.
  * 난무하는 추측으로 인해 추가된 수많은 유연성 메커니즘을 갖춘 시스템보다는 단순한 시스템의 변경이 훨씬 쉽다.
  * 따라서, **세 가지 실천법을 잘 조화시킨다면 요구사항 변화에 재빠르게 대응하고 안정적인 선순환 구조를 코드베이스에 적용**할 수 있다.

### 리팩토링이 성능에 미치는 영향
* 실제로도 리팩토링 과정에서 이해를 쉽게 만들기 위해 속도가 느려지는 방향으로 수정되는 경우는 많다.
* **리팩토링을 통해 소프트웨어가 느려질 수도 있는 것은 분명한 사실이지만, 이와 동시에 성능을 튜닝하기에는 더 쉬워진다**.
  * **소프트웨어를 빠르게 만드는 비법은 우선 튜닝하기 쉽게 만들고 나서 원하는 성능이 나오도록 튜닝하는 것**이다.
* 성능을 엄격하게 유지하는 방법은 크게 다음과 같다.
  1. 시간 예산 분배: 가장 엄격한 방식이며, 각 컴포넌트에 할당된 자원을 초과할 수 없도록 제한한다.
     * 하드 리얼 타임 시스템에서는 적합하지만, 그 외의 대부분의 용도에는 적합하지 않은 방식이다.
  2. 끊임없이 신경쓰기: 성능을 개선하기 위해 끊임없이 코드를 수정하는 방식이다.
     * 이 과정에서 프로그램은 수정이 어려운 형태로 변해갈 뿐더러, 실제로 속도가 빨라지는 경우도 많지 않다.
  3. 성능 최적화가 필요할 때까지는 신경쓰지 말기: 의도적으로 성능 최적화를 시도하기 전까지는 성능에 신경쓰지 말고 코드를 다루기 쉽도록 작성한다.
* 이 중 **세 번째 방식은 대부분의 프로그램이 전체 코드 중 극히 일부에서 대부분의 시간을 소비한다는 점에서 착안**한다.
  * 때문에 **코드 전체를 고르게 최적화하는 것은 대부분의 작업이 효과가 없는 시간 낭비**와도 같다.
* 일반적으로 세 번째 방식으로 작업하되, 성능 최적화 단계가 되면 다음과 같은 절차에 따라 프로그램을 최적화한다.
  1. 프로파일러로 프로그램을 분석하여 시간과 공간을 많이 소모하는 지점을 찾아낸다.
  2. 이후 해당 부분을 개선하며, 최적화를 위한 수정도 리팩토링과 마찬가지로 수정 - 컴파일 - 테스트를 거치도록 한다.
  3. 프로파일러를 다시 실행하여 효과를 검증하고, 성능이 개선되지 않았다면 수정 내용을 되돌린다.
  4. 만족하는 성능이 나올 때까지 최적화를 계속한다.
* 프로그램을 잘 리팩토링해두었다면 최적화에 다음과 같은 면에서 도움을 얻을 수 있다.
  1. 기능 추가가 빠르게 끝나므로 성능에 집중할 시간을 더 벌 수 있다.
  2. 프로파일러가 지적해주는 코드의 범위가 더 세밀해질 수 있도록 코드가 정리되어 있으므로, 성능을 더 세밀하게 분석할 수 있다.
* 코드가 깔끔하게 정돈되어 있다면 개선안들이 더 잘 떠오르며, 어떤 튜닝이 효과가 좋을지 판단하기도 쉽다.
  * 이렇듯 **리팩토링은 좋은 성능을 갖춘 소프트웨어를 작성하는 데에 기여**한다.
```
> 단기적으로는 리팩토링 단계에서 성능이 느려질 수도 있다.
> 그러나 장기적으로는 최적화 단계에서 코드의 튜닝이 훨씬 쉬워지므로, 결국에는 더 빠른 소프트웨어를 얻을 수 있다.
```
# Refactoring
## 2022-04-22 Fri

## 조건부 로직의 간소화
* 조건부 로직은 프로그램을 강하게 만들지만, 프로그램을 복잡하게 만드는 주요 원흉이다.
* 다음과 같은 특정한 리팩토링 기법들을 통해 조건부 로직을 이해하기 쉽게 변경할 수 있다.

### 조건문 분해하기
* 복잡한 조건부 로직은 프로그램을 읽기 어렵게 만드는 가장 흔한 원흉이다.
* 다양한 조건과 그에 따른 코드의 분기를 작성하면 순식간에 함수가 길어질 수 있다.
  * **긴 함수는 그 자체로 읽기 어렵지만, 조건문은 그보다 더 어려움을 가중**시킨다.
* **복잡한 조건을 검사하고 결과에 따른 동작을 분기하는 코드는 무엇이 일어나는지는 이야기하지만, 왜 일어나는지 설명하지 않는다**.
* 거대한 코드 블록이 주어지면 코드를 부위별로 분해하고, 해체된 덩어리에 적절한 이름의 함수 호출을 수행한다.
  * 이를 통해 **전체적인 의도는 더 확실히 드러날 수 있다**.
  * 이렇듯 **조건문은 해당 조건이 무엇인지 강조하고, 무엇을 분기하는지, 무엇을 리팩토링하는지 정확히 명시하는 것이 이상적**이다.

### 조건문 분해하기 - 절차
1. 조건식과 조건식에 딸린 조건절 각각은 함수로 처리한다.

### 조건식의 통합
* 비교하는 조건은 다르지만 비교 결과로 수행하는 동작은 같은 코드들을 종종 발견할 수 있다.
  * **어차피 같은 일을 수행할 것이라면, and와 or 연산자를 활용하여 여러 비교 로직을 하나로 통합하는 것이 바람직**하다.
  * 반면, 각 비교 로직이 정말로 다른 일을 수행한다면 해당 리팩토링을 적용하지 말아야 한다.
* 조건부 코드의 통합은 다음과 같은 이유에서 중요하다.
  1. 여러 조각으로 나뉜 조각을 하나의 조건으로 통합하는 것으로 개발자의 업무가 더 명확해진다.
  2. 해당 리팩토링은 함수 추출하기까지 이어질 가능성이 높다!
* **함수 추출하기는 무엇을 하는지만 기술하는 코드를 왜 하는지 말해주는 코드로 바꿔주는 효과적인 도구**이다.
* 두 경우 모두가 복잡한 경우라면 and 연산자와 or 연산자를 적절히 섞어 결합해도 무방하다.
  * 이렇듯 **복잡한 상황은 대체로 코드가 복잡하므로, 함수 추출하기를 적절히 활용하여 전체의 가독성을 높일 수 있다**.

### 조건식의 통합 - 절차
1. 해당 조건식 모두에 부수효과가 있는지 확인한다.
   * 부수효과가 있는 조건식들은 우선 질의 함수와 변경 함수 분리하기를 적용하도록 한다.
2. 조건문 두 개를 택하며 두 조건문의 조건식을 논리 연산자로 결합하낟.
   * 이 때, 순차적으로 이루어지는 조건문은 or 연산자를, 중첩된 요청 조건은 and 연산자를 활용한다.
3. 테스트를 진행한다.
4. 조건이 하나만 남을 때까지 2. ~ 3.의 과정을 반복한다.
5. 하나로 합쳐진 조건을 함수로 추출할지 결정한다,

### 중첩 조건문을 보호 구문으로 바꾸기
* 조건문은 주로 두 형태로 사용되며, 참인 경로와 거짓인 경로 둘 모두가 정상으로 취급하거나 그렇지 않은 경우가 있다.
* 두 형태는 의도하는 바가 다르므로, 의도는 코드에도 드러나야 한다.
  * 두 경로 모두 정상적인 동작이라면 if else 구문을 사용한다.
  * 하나만 정상인 경우, 비정상 조건을 if에서 검사한 더움 조건이 참인 경우에 한해 빠져나온다.
* 중첩 조건문을 보호 구문으로 바꾸는 리팩토링의 핵심은 의도를 부각하는 것이다.
  * **보호 구문은 해당 함수의 핵심이 아니므로 무언가 잘못된 경우, 조치를 취한 후 던져 함수에서 빠져나와야 함을 의미**한다.
* 함수의 진입점과 반환점은 원칙적으로 하나여야 하지만, 페어 프로그래밍 과정을 통해 이를 더 자세히 배울 수 있다.
  * 코드에서는 명확함이 핵심이므로, 사실은 반환점이 반드시 하나로 고정된다는 점은 유용하지 못하다.

### 중첩 조건문을 보호 구문으로 바꾸기 - 절차
1. 교체해야할 조건 중 가장 바깥 것을 선택하여 보호 구문으로 변경하고, 테스트를 진행한다.
2. 1.의 과정을 필요한 만큼 반복한다.
3. 모든 보호 구문이 같은 결과를 반환하는 경우, 보호 구문들의 조건식을 통합한다.

## 2022-04-23 Sat
### 조건부 로직을 다형성으로 바꾸기
* 복잡한 조건부 로직은 프로그래밍에서 해석을 어렵게하고 가독성을 떨어트리는 난해한 대상 중 하나이다.
  * 때문에 **언제나 복잡한 조건부 로직은 직관적으로 구조화할 수 있을지 고민하는 것이 바람직**하다.
  * **종종 더 높은 수준의 개념을 도입하여 이러한 조건들을 분리할 수 있으며, 특히 클래스와 다형성을 활용하여 확실하게 분리**할 수 있다.
* 다형성으로 조건부 로직을 해결하는 일반적인 예시는 다음과 같다.
  1. 타입을 여럿 만들고 각 타입이 자신만의 방식으로 조건부 로직을 처리하는 경우.
  2. 기본 동작을 위한 case 문과 변형 동작으로 구성된 나머지 분기 로직으로 구성된 경우.
* 전자의 경우, 타입을 기준으로 분기하는 switch 문이 포함된 함수가 대표적인 예시이다.
  * 이는 **분기 별로 클래스를 만들어 공통 switch 로직의 중복을 제거**할 수 있다.
* 후자의 경우, 기본 동작은 가장 일반적이거나 직관적인 동작이다.
  * **우선 기본 동작을 처리하는 슈퍼클래스를 정의하고, 변형 동작은 각각의 서브클래스에서 구현**할 수 있다.
* 다형성은 객체지향 프로그래밍의 핵심이지만, 다른 유용한 개념들과 마찬가지로 남용하기 쉽다.
* **모든 조건부 로직에 다형성을 도입하기보다는 간단한 조건문은 if, switch 등의 기본 로직을 사용하되 복잡한 로직을 다형성으로 처리하는 것이 바람직**하다.
  * 특히 다형성은 복잡한 조건부 로직을 개선할 수 있는 강력한 도구가 되어준다.

### 조건부 로직을 다형성으로 바꾸기
1. 다형적 동작을 표현하는 클래스들이 없는 경우, 새로 작성한다.
   * 이 때, 가능하다면 적절한 인스턴스를 알아서 생성하여 반환하는 팩토리 메소드를 함께 정의한다.
2. 호출하는 코드에서 팩토리 메소드를 사용하도록 구현한다.
3. 조건부 로직을 슈퍼클래스로 옮겨준다.
   * 이 때, 조건부 로직이 메소드로 분리되어 있지 않다면 우선 추출한다.
4. 서브클래스 중 하나를 선택하고, 슈퍼클래스의 조건부 로직 메소드를 오버라이드한다.
   * 오버라이드된 메소드에는 조건부 문장 중 선택된 서브클래스에 해당하는 조건절을 복사하여 수정한다.
5. 같은 방식으로 모든 조건절을 대응되는 서브클래스의 메소드로 오버라이드하여 구현한다.
6. 슈퍼클래스 메소드에는 기본 동작만을 남긴다.
   * 슈퍼 클래스가 추상 클래스여야 하는 경우, 메소드를 추상으로 선언하거나 서브클래스에서 처리해야함을 알리는 예외를 던지도록 구현한다.

### 특이 케이스 추가하기
* 데이터 구조에서 특정 값을 확인한 후 같은 동작을 수행하는 코드가 곳곳에서 등장할 수 있으며, 이는 흔히 볼 수 있는 중복 코드의 유형이다.
  * 이렇듯 코드에서 특정 값에 대해 똑같이 반응하는 코드가 여럿인 경우, 흩어진 반응들을 하나로 모으는 것이 효율적이다.
* 특이 케이스는 특수한 경우의 공통 동작을 요소 하나에 모아서 사용하는 패턴으로, 특이 케이스를 확인하는 코드 대부분을 단순한 함수 호출로 바꿀 수 있다.
* 특이 케이스는 다음과 같은 여러 형태로 표현이 가능하다.
  1. 특이 케이스 객체에서 단순히 데이터를 읽기만 하는 경우, 반환할 값을 담는 리터럴 객체 형태로 준비한다.
  2. 그 이상의 어떤 동작을 수행해야하는 경우, 필요한 메소드를 담는 객체를 생성한다.
* 널은 특이 케이스로 처리해야하 나는 대표적인 예시이며, 널 이외의 다른 특이 케이스에도 해당 기법을 적용할 수 있다.

### 특이 케이스 추가하기 - 절차
* 리팩토링 대상이 될 속성을 담는 데이터 구조 또는 클래스를 컨테이너라고 할 때, 컨테이너를 사용하는 코드에서 해당 속성이 특이 케이스인지 검사한다.
  * 즉, 이러한 대상이 가질 수 있는 값 중 특별하게 처리해야하는 값을 특이 케이스로 대체해야 한다.
1. 컨테이너에 특이 케이스인지 검사하는 속성을 추가하고, false를 반환하도록 구현한다.
2. 특이 케이스 객체를 만들되, 해당 객체는 특이 케이스인지 검사하는 속성만 포함하도록 한다.
   * 해당 속성은 true를 반환하도록 구현한다.
3. 클라이언트에서 특이 케이스를 검사하는 코드를 함수로 추출한 후, 모든 클라이언트가 값을 직접 비교하는 대신 해당 함수를 사용하도록 수정한다.
4. 코드에 새로운 특이 케이스 대상을 추가하며, 함수의 반환 값으로 받거나 변환 함수를 적용한다.
5. 특이 케이스를 검사하는 함수 본문을 수정하여 특이 케이스 객체의 속성을 사용하도록 한다.
6. 테스트를 진행한다.
7. 여러 함수를 클래스로 묶거나 여러 함수를 변환 함수로 묶는 리팩토링 기법을 적용하여 특이 케이스를 처리하는 공통 동작을 새로운 요소로 옮겨준다.
   * 일반적으로 특이 케이스 클래스는 간단한 요청에 항상 같은 값을 반환하므로, 해당 특이 케이스의 리터럴 레코드를 만들어 활용할 수도 있다.
8. 아직까지 특이 케이스 검사 함수를 사용하는 곳이 남아 있다면 검사 함수를 인라인한다.

### 어서션 추가하기
* 코드를 작성하다 보면 특정한 조건이 반드시 참인 경우에만 동작하는 코드 영역이 있을 수 있다.
* 그러나 이러한 가정이 항상 명시적으로 작성되어 있지는 않은 경우가 많으므로, 개발자는 알고리즘을 보고 추론하여 알아내야하는 경우가 있다.
  * 주석이라도 작성되어 있다면 상황이 조금 낫다.
* 이러한 **조건을 명시하는 가장 좋은 방법은 어서션을 이용하여 코드 자체에 삽입해두는 것**이다.
  * 어서션은 항상 참이라고 가정하는 조건부 문장이며, 어서션을 실패한다는 것은 개발자의 잘 못을 의미한다.
* **어서션 실패는 시스템의 다른 부분에서는 절대 검사하지 않아야 하며, 어서션의 유무가 프로그램의 기능 정상 동작에 영향을 주지 않도록 작성되어야 한다**.
* **어서션은 프로그램이 어떤 상태임을 가정하고 실행되어야 하는지 다른 개발자에게 알려주는 좋은 소통 도구**이다.
* 반면, 좋은 테스트 코드가 존재한다면 어서션의 디버깅 용도로서의 효용은 줄어들 수 있다.
  * 즉, 단위 테스트를 꾸준히 추가하여 사각을 좁혀가는 것이 어서션보다 좋은 결과를 얻는 경우가 많다.
  * 그러나 소통 관점에서는 어서션 역시 여전히 매력을 갖는다.
* 어서션의 남발은 다른 프로그래밍 요소와 마찬가지로 위험하다.
  * 예를 들어, 참이라고 생각하는 가정 모두에 어서션을 달 필요는 없다.
  * 오히려 반드시 참이어야 하는 것만 검사하는 것이 이상적이다.
* 어서션은 개발자가 일으킬만한 오류를 대비해서만 사용해야 한다.
  * 예를 들어, **데이터를 외부로부터 읽어온다면 해당 값의 검사는 어서션의 대상인 가정이 아니라, 예외로 대응해야 하는 프로그램 로직의 일부로 다뤄야 한다**.
* **어서션은 버그의 추적을 돕는 최후의 수단으로 사용하거나, 절대 실패하지 않으리라 판단되는 곳에만 명시하는 것이 바람직**하다.

### 어서션 추가하기 - 절차
1. 참이라고 가정하는 조건을 확인했다면, 해당 조건을 명시하는 어서션을 추가한다.

### 제어 플래그는 탈출문으로 바꾸기
* 제어 플래그란 코드의 동작을 변경하기 위해 사용되는 변수이며, 어딘가에서 값을 계산하여 제어 플래그에 설정하면 다른 조건문이 이를 검사하는 형태로 사용된다.
* 그러나 제어 플래그는 흔히 발견할 수 있는 코드 냄새에 해당한다.
  * **제어 플래그 방식의 코드는 리팩토링을 통해 충분히 간소화할 수 있음에도 복잡하게 작성된 코드에서 흔히 발생**한다.
* 제어 플래그의 주된 서식지는 반복문의 내부이며, break 나 continue의 활용에 익숙하지 않은 사람이 주로 심어두곤 한다.
  * 또는 **return 문을 하나로 유지하고자 하는 사람의 의도일 수도 있으나, 함수의 역할이 완료되었다면 return 을 통해 명시하는 것이 더 좋다**.

### 제어 플래그는 탈출문으로 바꾸기 - 절차
1. 제어 플래그를 사용하는 코드는 함수로 추출할지 고려한다.
2. 제어 플래그를 갱신하는 코드 각각을 적절한 제어문으로 변경하되, 바꿀 때마다 테스트를 진행한다.
   * 제어문은 주로 return, break, continue 등이 사용된다.
3. 모두 수정을 완료한 후에 제어 플래그를 제거한다.
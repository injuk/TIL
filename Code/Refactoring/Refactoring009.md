# Refactoring
## 2022-04-22 Fri

## 조건부 로직의 간소화
* 조건부 로직은 프로그램을 강하게 만들지만, 프로그램을 복잡하게 만드는 주요 원흉이다.
* 다음과 같은 특정한 리팩토링 기법들을 통해 조건부 로직을 이해하기 쉽게 변경할 수 있다.

### 조건문 분해하기
* 복잡한 조건부 로직은 프로그램을 읽기 어렵게 만드는 가장 흔한 원흉이다.
* 다양한 조건과 그에 따른 코드의 분기를 작성하면 순식간에 함수가 길어질 수 있다.
  * **긴 함수는 그 자체로 읽기 어렵지만, 조건문은 그보다 더 어려움을 가중**시킨다.
* **복잡한 조건을 검사하고 결과에 따른 동작을 분기하는 코드는 무엇이 일어나는지는 이야기하지만, 왜 일어나는지 설명하지 않는다**.
* 거대한 코드 블록이 주어지면 코드를 부위별로 분해하고, 해체된 덩어리에 적절한 이름의 함수 호출을 수행한다.
  * 이를 통해 **전체적인 의도는 더 확실히 드러날 수 있다**.
  * 이렇듯 **조건문은 해당 조건이 무엇인지 강조하고, 무엇을 분기하는지, 무엇을 리팩토링하는지 정확히 명시하는 것이 이상적**이다.

### 조건문 분해하기 - 절차
1. 조건식과 조건식에 딸린 조건절 각각은 함수로 처리한다.

### 조건식의 통합
* 비교하는 조건은 다르지만 비교 결과로 수행하는 동작은 같은 코드들을 종종 발견할 수 있다.
  * **어차피 같은 일을 수행할 것이라면, and와 or 연산자를 활용하여 여러 비교 로직을 하나로 통합하는 것이 바람직**하다.
  * 반면, 각 비교 로직이 정말로 다른 일을 수행한다면 해당 리팩토링을 적용하지 말아야 한다.
* 조건부 코드의 통합은 다음과 같은 이유에서 중요하다.
  1. 여러 조각으로 나뉜 조각을 하나의 조건으로 통합하는 것으로 개발자의 업무가 더 명확해진다.
  2. 해당 리팩토링은 함수 추출하기까지 이어질 가능성이 높다!
* **함수 추출하기는 무엇을 하는지만 기술하는 코드를 왜 하는지 말해주는 코드로 바꿔주는 효과적인 도구**이다.
* 두 경우 모두가 복잡한 경우라면 and 연산자와 or 연산자를 적절히 섞어 결합해도 무방하다.
  * 이렇듯 **복잡한 상황은 대체로 코드가 복잡하므로, 함수 추출하기를 적절히 활용하여 전체의 가독성을 높일 수 있다**.

### 조건식의 통합 - 절차
1. 해당 조건식 모두에 부수효과가 있는지 확인한다.
   * 부수효과가 있는 조건식들은 우선 질의 함수와 변경 함수 분리하기를 적용하도록 한다.
2. 조건문 두 개를 택하며 두 조건문의 조건식을 논리 연산자로 결합하낟.
   * 이 때, 순차적으로 이루어지는 조건문은 or 연산자를, 중첩된 요청 조건은 and 연산자를 활용한다.
3. 테스트를 진행한다.
4. 조건이 하나만 남을 때까지 2. ~ 3.의 과정을 반복한다.
5. 하나로 합쳐진 조건을 함수로 추출할지 결정한다,

### 중첩 조건문을 보호 구문으로 바꾸기
* 조건문은 주로 두 형태로 사용되며, 참인 경로와 거짓인 경로 둘 모두가 정상으로 취급하거나 그렇지 않은 경우가 있다.
* 두 형태는 의도하는 바가 다르므로, 의도는 코드에도 드러나야 한다.
  * 두 경로 모두 정상적인 동작이라면 if else 구문을 사용한다.
  * 하나만 정상인 경우, 비정상 조건을 if에서 검사한 더움 조건이 참인 경우에 한해 빠져나온다.
* 중첩 조건문을 보호 구문으로 바꾸는 리팩토링의 핵심은 의도를 부각하는 것이다.
  * **보호 구문은 해당 함수의 핵심이 아니므로 무언가 잘못된 경우, 조치를 취한 후 던져 함수에서 빠져나와야 함을 의미**한다.
* 함수의 진입점과 반환점은 원칙적으로 하나여야 하지만, 페어 프로그래밍 과정을 통해 이를 더 자세히 배울 수 있다.
  * 코드에서는 명확함이 핵심이므로, 사실은 반환점이 반드시 하나로 고정된다는 점은 유용하지 못하다.

### 중첩 조건문을 보호 구문으로 바꾸기 - 절차
1. 교체해야할 조건 중 가장 바깥 것을 선택하여 보호 구문으로 변경하고, 테스트를 진행한다.
2. 1.의 과정을 필요한 만큼 반복한다.
3. 모든 보호 구문이 같은 결과를 반환하는 경우, 보호 구문들의 조건식을 통합한다.
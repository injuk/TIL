# Refactoring
## 2022-04-22 Fri

## 조건부 로직의 간소화
* 조건부 로직은 프로그램을 강하게 만들지만, 프로그램을 복잡하게 만드는 주요 원흉이다.
* 다음과 같은 특정한 리팩토링 기법들을 통해 조건부 로직을 이해하기 쉽게 변경할 수 있다.

### 조건문 분해하기
* 복잡한 조건부 로직은 프로그램을 읽기 어렵게 만드는 가장 흔한 원흉이다.
* 다양한 조건과 그에 따른 코드의 분기를 작성하면 순식간에 함수가 길어질 수 있다.
  * **긴 함수는 그 자체로 읽기 어렵지만, 조건문은 그보다 더 어려움을 가중**시킨다.
* **복잡한 조건을 검사하고 결과에 따른 동작을 분기하는 코드는 무엇이 일어나는지는 이야기하지만, 왜 일어나는지 설명하지 않는다**.
* 거대한 코드 블록이 주어지면 코드를 부위별로 분해하고, 해체된 덩어리에 적절한 이름의 함수 호출을 수행한다.
  * 이를 통해 **전체적인 의도는 더 확실히 드러날 수 있다**.
  * 이렇듯 **조건문은 해당 조건이 무엇인지 강조하고, 무엇을 분기하는지, 무엇을 리팩토링하는지 정확히 명시하는 것이 이상적**이다.

### 조건문 분해하기 - 절차
1. 조건식과 조건식에 딸린 조건절 각각은 함수로 처리한다.

### 조건식의 통합
* 비교하는 조건은 다르지만 비교 결과로 수행하는 동작은 같은 코드들을 종종 발견할 수 있다.
  * **어차피 같은 일을 수행할 것이라면, and와 or 연산자를 활용하여 여러 비교 로직을 하나로 통합하는 것이 바람직**하다.
  * 반면, 각 비교 로직이 정말로 다른 일을 수행한다면 해당 리팩토링을 적용하지 말아야 한다.
* 조건부 코드의 통합은 다음과 같은 이유에서 중요하다.
  1. 여러 조각으로 나뉜 조각을 하나의 조건으로 통합하는 것으로 개발자의 업무가 더 명확해진다.
  2. 해당 리팩토링은 함수 추출하기까지 이어질 가능성이 높다!
* **함수 추출하기는 무엇을 하는지만 기술하는 코드를 왜 하는지 말해주는 코드로 바꿔주는 효과적인 도구**이다.
* 두 경우 모두가 복잡한 경우라면 and 연산자와 or 연산자를 적절히 섞어 결합해도 무방하다.
  * 이렇듯 **복잡한 상황은 대체로 코드가 복잡하므로, 함수 추출하기를 적절히 활용하여 전체의 가독성을 높일 수 있다**.

### 조건식의 통합 - 절차
1. 해당 조건식 모두에 부수효과가 있는지 확인한다.
   * 부수효과가 있는 조건식들은 우선 질의 함수와 변경 함수 분리하기를 적용하도록 한다.
2. 조건문 두 개를 택하며 두 조건문의 조건식을 논리 연산자로 결합하낟.
   * 이 때, 순차적으로 이루어지는 조건문은 or 연산자를, 중첩된 요청 조건은 and 연산자를 활용한다.
3. 테스트를 진행한다.
4. 조건이 하나만 남을 때까지 2. ~ 3.의 과정을 반복한다.
5. 하나로 합쳐진 조건을 함수로 추출할지 결정한다,

### 중첩 조건문을 보호 구문으로 바꾸기
* 조건문은 주로 두 형태로 사용되며, 참인 경로와 거짓인 경로 둘 모두가 정상으로 취급하거나 그렇지 않은 경우가 있다.
* 두 형태는 의도하는 바가 다르므로, 의도는 코드에도 드러나야 한다.
  * 두 경로 모두 정상적인 동작이라면 if else 구문을 사용한다.
  * 하나만 정상인 경우, 비정상 조건을 if에서 검사한 더움 조건이 참인 경우에 한해 빠져나온다.
* 중첩 조건문을 보호 구문으로 바꾸는 리팩토링의 핵심은 의도를 부각하는 것이다.
  * **보호 구문은 해당 함수의 핵심이 아니므로 무언가 잘못된 경우, 조치를 취한 후 던져 함수에서 빠져나와야 함을 의미**한다.
* 함수의 진입점과 반환점은 원칙적으로 하나여야 하지만, 페어 프로그래밍 과정을 통해 이를 더 자세히 배울 수 있다.
  * 코드에서는 명확함이 핵심이므로, 사실은 반환점이 반드시 하나로 고정된다는 점은 유용하지 못하다.

### 중첩 조건문을 보호 구문으로 바꾸기 - 절차
1. 교체해야할 조건 중 가장 바깥 것을 선택하여 보호 구문으로 변경하고, 테스트를 진행한다.
2. 1.의 과정을 필요한 만큼 반복한다.
3. 모든 보호 구문이 같은 결과를 반환하는 경우, 보호 구문들의 조건식을 통합한다.

## 2022-04-23 Sat
### 조건부 로직을 다형성으로 바꾸기
* 복잡한 조건부 로직은 프로그래밍에서 해석을 어렵게하고 가독성을 떨어트리는 난해한 대상 중 하나이다.
  * 때문에 **언제나 복잡한 조건부 로직은 직관적으로 구조화할 수 있을지 고민하는 것이 바람직**하다.
  * **종종 더 높은 수준의 개념을 도입하여 이러한 조건들을 분리할 수 있으며, 특히 클래스와 다형성을 활용하여 확실하게 분리**할 수 있다.
* 다형성으로 조건부 로직을 해결하는 일반적인 예시는 다음과 같다.
  1. 타입을 여럿 만들고 각 타입이 자신만의 방식으로 조건부 로직을 처리하는 경우.
  2. 기본 동작을 위한 case 문과 변형 동작으로 구성된 나머지 분기 로직으로 구성된 경우.
* 전자의 경우, 타입을 기준으로 분기하는 switch 문이 포함된 함수가 대표적인 예시이다.
  * 이는 **분기 별로 클래스를 만들어 공통 switch 로직의 중복을 제거**할 수 있다.
* 후자의 경우, 기본 동작은 가장 일반적이거나 직관적인 동작이다.
  * **우선 기본 동작을 처리하는 슈퍼클래스를 정의하고, 변형 동작은 각각의 서브클래스에서 구현**할 수 있다.
* 다형성은 객체지향 프로그래밍의 핵심이지만, 다른 유용한 개념들과 마찬가지로 남용하기 쉽다.
* **모든 조건부 로직에 다형성을 도입하기보다는 간단한 조건문은 if, switch 등의 기본 로직을 사용하되 복잡한 로직을 다형성으로 처리하는 것이 바람직**하다.
  * 특히 다형성은 복잡한 조건부 로직을 개선할 수 있는 강력한 도구가 되어준다.

### 조건부 로직을 다형성으로 바꾸기
1. 다형적 동작을 표현하는 클래스들이 없는 경우, 새로 작성한다.
   * 이 때, 가능하다면 적절한 인스턴스를 알아서 생성하여 반환하는 팩토리 메소드를 함께 정의한다.
2. 호출하는 코드에서 팩토리 메소드를 사용하도록 구현한다.
3. 조건부 로직을 슈퍼클래스로 옮겨준다.
   * 이 때, 조건부 로직이 메소드로 분리되어 있지 않다면 우선 추출한다.
4. 서브클래스 중 하나를 선택하고, 슈퍼클래스의 조건부 로직 메소드를 오버라이드한다.
   * 오버라이드된 메소드에는 조건부 문장 중 선택된 서브클래스에 해당하는 조건절을 복사하여 수정한다.
5. 같은 방식으로 모든 조건절을 대응되는 서브클래스의 메소드로 오버라이드하여 구현한다.
6. 슈퍼클래스 메소드에는 기본 동작만을 남긴다.
   * 슈퍼 클래스가 추상 클래스여야 하는 경우, 메소드를 추상으로 선언하거나 서브클래스에서 처리해야함을 알리는 예외를 던지도록 구현한다.
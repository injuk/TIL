# Refactoring
## 2022-04-24 Sun

## API 리팩토링
* 모듈과 함수는 소프트웨어를 구성하는 빌딩 블록이며, API는 이러한 블록들을 연결해주는 역할을 수행한다.
  * 반면 API의 가독성과 사용성을 향상시키는 일은 중요한 동시에 어려운 일이다.
  * 때문에 API를 개선하는 방법이 고안될 때마다 이를 적용하여 적절히 리팩토링을 수행해야 한다.
* 좋은 API는 데이터를 갱신하는 함수와 조회하는 함수를 명확히 구분할 수 있어야 한다.
* 클래스는 대표적인 모듈이므로, 객체를 되도록이면 불변으로 유지하는 것이 바람직하다.
* 클라이언트에 새로운 객체를 만들어 반환하는 경우, 생성자 대신 팩토리 메소드를 제공할 수 있다.

### 질의 함수와 변경 함수는 분리하기
* **함수를 작성하는 경우, 가능하다면 외부에서 관찰할 수 있는 겉보기 부수효과가 전혀 없이 값을 반환하는 함수를 추구해야 한다**. 
  * 이러한 함수는 언제나 마음대로 호출해도 문제가 없으며, 테스트도 쉬우므로 사용하기 위해 신경 쓸 것이 적다.
* **겉보기 부수효과가 있는 함수와 없는 함수는 명확히 구분하는 것이 좋으며, 이를 위해 명령 질의 분리 원칙을 활용**할 수 있다.
* **값을 반환하면서 부수효과도 있는 함수를 발견한 경우, 상태를 변경하는 부분과 질의하는 부분을 반드시 분리하도록 해야 한다**.
* 모든 부수효과가 겉보기 동작에 영향을 주지는 않으므로, 함수의 부수효과는 겉보기 부수효과로 제한해야 한다.  
  * 예를 들어 최적화를 위한 캐싱 역시 부수효과를 갖지만, 외부에서는 관찰할 수 없으며 매 호출시 언제나 같은 값을 반환할 수 있다.

### 질의 함수와 변경 함수는 분리하기 - 절차
1. 대상 함수를 복사하여 질의에 충실한 이름으로 명명한다.
   * 이 과정에서 함수 내부를 확인하여 반환값을 찾도록 한다.
   * 어떤 변수의 값을 반환하고 있는 경우, 해당 변수의 이름이 좋은 후보가 되어줄 수 있다.
2. 새로운 질의 함수에서 모든 부수효과를 제거한 후 정적 검사를 수행한다.
3. 기존 함수를 호출하는 지점을 모두 찾아내고, 호출하는 곳에서 반환 값을 사용한다면 질의 함수를 호출하도록 수정한다.
   * 이 때, 기존 함수를 호출하는 코드를 아래 줄에 새로이 추가한다.
   * 하나를 수정할 때마다 테스트를 진행한다.
4. 기존 함수에서 질의와 관련된 코드를 제거한 후 테스트를 진행한다.

### 함수를 매개변수화하기
* 여러 함수의 로직이 매우 비슷하고, 내부에서 사용되는 리터럴만 다르다면 그 값만 매개변수로 받아 처리하는 함수 하나로 합쳐 중복을 제거할 수 있다.
* 이 경우, 매개변수 값만 변경하여 여러 곳에서 활용 가능한 함수로 수정할 수 있다.

### 함수를 매개변수화하기 - 절차
1. 비슷한 함수들 중 하나를 선택하고, 함수 선언 바꾸기 기법을 적용하여 리터럴을 모두 매개변수로 추가한다.
2. 함수를 호출하는 곳 모두에 적절한 리터럴 값을 추가한 후 테스트를 진행한다.
3. 매개변수로 받은 값을 사용하도록 함수의 본문을 수정하되, 하나를 수정할 때마다 테스트를 진행한다.
4. 비슷한 다른 함수를 호출하는 코드를 찾아 매개변수화된 함수를 호출하도록 하나씩 수정한다.
   * 매개변수화된 함수가 대체할 비슷한 함수와 다르게 동작하는 경우, 그 비슷한 함수의 동작도 처리할 수 있도록 본문을 적절히 수정한다.
   * 하나를 수정할 때마다 테스트를 진행한다.

### 플래그 인수 제거하기
* 플래그 인수란, 호출되는 함수가 실행할 로직을 호출하는 쪽에서 선택하기 위해 전달하는 인수이다.
  * **플래그 인수는 함수들의 기능 차이를 잘 드러내지 못하며, 코드를 읽는 이에게 사용 방법과 뜻을 제대로 전달할 수 없다**.
* **플래그 인수를 제공하여 하나의 함수로 통합하는 것보다는 특정한 기능 하나만을 수행할 수 있도록 명시적인 이름을 갖는 함수를 제공하는 것이 바람직**하다.
* 플래그 인수를 제거하면 코드가 깔끔해지는 것은 물론, 프로그래밍 도구에도 도움을 줄 수 있다.
* 반면 함수 하나에서 둘 이상의 플래그 인수를 사용하는 경우, 플래그 인수를 사용해도 무방하다.
  * 플래스 인수를 제거하려면 플래그 인수의 조합만큼 새로운 함수를 정의해야하기 때문이다.
* 그러나 **다른 관점에서 보면, 플래그 인수가 둘 이상인 경우 함수 하나가 너무 많은 일을 처리하고 있다는 신호**이기도 하다.
  * 때문에 같은 로직을 조합할 수 있는 더 간단한 함수를 만들 수 있는 방법을 고민하는 것이 더 바람직하다.
* 플래그 인수 중 함수의 인수로 리터럴을 적용하는 경우는 특히 제거되어야 하며, 데이터를 사용하는 코드는 굳이 제거하지 않아도 무방하다.
  * 예를 들어, badFunc(data, true) 보다는 badFunc(data, isTrue) 와 같은 식으로 작성된 코드를 말한다.
  * 이 경우 badFunc를 반드시 제거하기보다는 전자에 해당하는 함수를 호출하는 지점을 새로 정의한 함수로 수정하고, 후자는 그냥 두는 것이 좋다.
* **함수의 내부 분기 로직이 너무 복잡하여 각 분기에 해당하는 함수를 추출할 수 없는 경우, 대신 래핑 함수를 정의**할 수 있다.
  * 예를 들어, wrappingFuncWithTrue() { badFunc(data, true); }와 wrappingFuncWithFalse() { badFunc(data, false); }를 정의한다.
  * 그 후, 해당 함수를 호출하던 기존 클라이언트 코드는 각각 상술한 리팩토링 절차를 통해 래핑 함수를 호출하도록 수정한다.

### 플래그 인수 제거하기 - 절차
1. 매개변수로 주어질 수 있는 값 각각에 대응하는 명시적인 함수를 정의한다.
   * 이 경우, 주가되는 함수에 깔끔한 조건문이 포함되어 있다면 조건문 분해하기 기법을 적용하여 명시적인 함수를 생성한다.
   * 그렇지 않은 경우, 래핑 함수 형태로 정의한다.
2. 기존 함수를 호출하는 코드를 모두 찾아내거 각 리터럴 값에 대응하는 명시적 함수를 호출하도록 수정한다.
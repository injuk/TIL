# Refactoring
## 2022-04-24 Sun

## API 리팩토링
* 모듈과 함수는 소프트웨어를 구성하는 빌딩 블록이며, API는 이러한 블록들을 연결해주는 역할을 수행한다.
  * 반면 API의 가독성과 사용성을 향상시키는 일은 중요한 동시에 어려운 일이다.
  * 때문에 API를 개선하는 방법이 고안될 때마다 이를 적용하여 적절히 리팩토링을 수행해야 한다.
* 좋은 API는 데이터를 갱신하는 함수와 조회하는 함수를 명확히 구분할 수 있어야 한다.
* 클래스는 대표적인 모듈이므로, 객체를 되도록이면 불변으로 유지하는 것이 바람직하다.
* 클라이언트에 새로운 객체를 만들어 반환하는 경우, 생성자 대신 팩토리 메소드를 제공할 수 있다.

### 질의 함수와 변경 함수는 분리하기
* **함수를 작성하는 경우, 가능하다면 외부에서 관찰할 수 있는 겉보기 부수효과가 전혀 없이 값을 반환하는 함수를 추구해야 한다**. 
  * 이러한 함수는 언제나 마음대로 호출해도 문제가 없으며, 테스트도 쉬우므로 사용하기 위해 신경 쓸 것이 적다.
* **겉보기 부수효과가 있는 함수와 없는 함수는 명확히 구분하는 것이 좋으며, 이를 위해 명령 질의 분리 원칙을 활용**할 수 있다.
* **값을 반환하면서 부수효과도 있는 함수를 발견한 경우, 상태를 변경하는 부분과 질의하는 부분을 반드시 분리하도록 해야 한다**.
* 모든 부수효과가 겉보기 동작에 영향을 주지는 않으므로, 함수의 부수효과는 겉보기 부수효과로 제한해야 한다.  
  * 예를 들어 최적화를 위한 캐싱 역시 부수효과를 갖지만, 외부에서는 관찰할 수 없으며 매 호출시 언제나 같은 값을 반환할 수 있다.

### 질의 함수와 변경 함수는 분리하기 - 절차
1. 대상 함수를 복사하여 질의에 충실한 이름으로 명명한다.
   * 이 과정에서 함수 내부를 확인하여 반환값을 찾도록 한다.
   * 어떤 변수의 값을 반환하고 있는 경우, 해당 변수의 이름이 좋은 후보가 되어줄 수 있다.
2. 새로운 질의 함수에서 모든 부수효과를 제거한 후 정적 검사를 수행한다.
3. 기존 함수를 호출하는 지점을 모두 찾아내고, 호출하는 곳에서 반환 값을 사용한다면 질의 함수를 호출하도록 수정한다.
   * 이 때, 기존 함수를 호출하는 코드를 아래 줄에 새로이 추가한다.
   * 하나를 수정할 때마다 테스트를 진행한다.
4. 기존 함수에서 질의와 관련된 코드를 제거한 후 테스트를 진행한다.

### 함수를 매개변수화하기
* 여러 함수의 로직이 매우 비슷하고, 내부에서 사용되는 리터럴만 다르다면 그 값만 매개변수로 받아 처리하는 함수 하나로 합쳐 중복을 제거할 수 있다.
* 이 경우, 매개변수 값만 변경하여 여러 곳에서 활용 가능한 함수로 수정할 수 있다.

### 함수를 매개변수화하기 - 절차
1. 비슷한 함수들 중 하나를 선택하고, 함수 선언 바꾸기 기법을 적용하여 리터럴을 모두 매개변수로 추가한다.
2. 함수를 호출하는 곳 모두에 적절한 리터럴 값을 추가한 후 테스트를 진행한다.
3. 매개변수로 받은 값을 사용하도록 함수의 본문을 수정하되, 하나를 수정할 때마다 테스트를 진행한다.
4. 비슷한 다른 함수를 호출하는 코드를 찾아 매개변수화된 함수를 호출하도록 하나씩 수정한다.
   * 매개변수화된 함수가 대체할 비슷한 함수와 다르게 동작하는 경우, 그 비슷한 함수의 동작도 처리할 수 있도록 본문을 적절히 수정한다.
   * 하나를 수정할 때마다 테스트를 진행한다.

### 플래그 인수 제거하기
* 플래그 인수란, 호출되는 함수가 실행할 로직을 호출하는 쪽에서 선택하기 위해 전달하는 인수이다.
  * **플래그 인수는 함수들의 기능 차이를 잘 드러내지 못하며, 코드를 읽는 이에게 사용 방법과 뜻을 제대로 전달할 수 없다**.
* **플래그 인수를 제공하여 하나의 함수로 통합하는 것보다는 특정한 기능 하나만을 수행할 수 있도록 명시적인 이름을 갖는 함수를 제공하는 것이 바람직**하다.
* 플래그 인수를 제거하면 코드가 깔끔해지는 것은 물론, 프로그래밍 도구에도 도움을 줄 수 있다.
* 반면 함수 하나에서 둘 이상의 플래그 인수를 사용하는 경우, 플래그 인수를 사용해도 무방하다.
  * 플래스 인수를 제거하려면 플래그 인수의 조합만큼 새로운 함수를 정의해야하기 때문이다.
* 그러나 **다른 관점에서 보면, 플래그 인수가 둘 이상인 경우 함수 하나가 너무 많은 일을 처리하고 있다는 신호**이기도 하다.
  * 때문에 같은 로직을 조합할 수 있는 더 간단한 함수를 만들 수 있는 방법을 고민하는 것이 더 바람직하다.
* 플래그 인수 중 함수의 인수로 리터럴을 적용하는 경우는 특히 제거되어야 하며, 데이터를 사용하는 코드는 굳이 제거하지 않아도 무방하다.
  * 예를 들어, badFunc(data, true) 보다는 badFunc(data, isTrue) 와 같은 식으로 작성된 코드를 말한다.
  * 이 경우 badFunc를 반드시 제거하기보다는 전자에 해당하는 함수를 호출하는 지점을 새로 정의한 함수로 수정하고, 후자는 그냥 두는 것이 좋다.
* **함수의 내부 분기 로직이 너무 복잡하여 각 분기에 해당하는 함수를 추출할 수 없는 경우, 대신 래핑 함수를 정의**할 수 있다.
  * 예를 들어, wrappingFuncWithTrue() { badFunc(data, true); }와 wrappingFuncWithFalse() { badFunc(data, false); }를 정의한다.
  * 그 후, 해당 함수를 호출하던 기존 클라이언트 코드는 각각 상술한 리팩토링 절차를 통해 래핑 함수를 호출하도록 수정한다.

### 플래그 인수 제거하기 - 절차
1. 매개변수로 주어질 수 있는 값 각각에 대응하는 명시적인 함수를 정의한다.
   * 이 경우, 주가되는 함수에 깔끔한 조건문이 포함되어 있다면 조건문 분해하기 기법을 적용하여 명시적인 함수를 생성한다.
   * 그렇지 않은 경우, 래핑 함수 형태로 정의한다.
2. 기존 함수를 호출하는 코드를 모두 찾아내거 각 리터럴 값에 대응하는 명시적 함수를 호출하도록 수정한다.

### 객체를 한 번에 넘기기
* 하나의 레코드에서 한 두개의 값을 가져와 인수로 넘기는 코드는 레코드를 하나의 객체로 넘기고, 함수 본문에서 필요한 값을 꺼내서 사용하도록 수정할 수 있다.
* 객체를 한 번에 넘기는 방식은 다음과 같은 장점을 갖는다.
  1. 함수가 더 많은 데이터를 사용하도록 수정되더라도 변화에 대응하기 쉽다.
  2. 매개변수의 목록이 짧아지므로, 함수를 이해하기 쉽다.
  3. 동일한 레코드를 사용하는 함수들 사이에서 발생할 수 있는 잠재적인 코드 중복 가능성을 줄일 수 있다.
* 그러나 **레코드와 함수가 서로 다른 모듈에 속하는 등, 함수가 레코드 자체에 의존하는 것을 방지해야하는 경우에는 해당 리팩토링을 수행하지 않아야 한다**.
* **임의의 객체로부터 값 몇개를 가져온 후, 그 값 만으로 무언가를 하는 로직은 그 로직을 객체 내부로 넣어주어야 하는 코드 냄새의 일종**으로 볼 수 있다.
* 한 객체가 제공하는 기능 중 항상 같은 일부만을 사용하는 코드가 많은 경우, 해당 기능을 묶어 클래스로 추출하라는 신호일 수 있다.
* 다른 객체의 메소드를 호출하면서 호출하는 객체 자신이 갖는 데이터를 여럿 건네는 경우, 데이터 여럿을 넘기는 대신 this와 같은 자신의 참조를 건넬 수 있다.

### 객체를 한 번에 넘기기 - 절차
1. 매개변수들을 원하는 형태로 받는 빈 함수를 쉽게 기억할 수 있는 이름으로 정의한다.
2. 새로 정의한 함수의 본문에서 원래 함수를 호출하며, 새로운 매개변수와 원래 함수의 매개변수를 매핑한 후 정적 검사를 수행한다.
3. 모든 호출자가 새로운 함수를 사용하도록 수정하되, 하나가 변경될 때마다 테스트를 진행한다.
4. 호출자를 모두 수정한 후, 기존 함수는 인라인한다.
5. 새로운 함수의 이름을 적절히 수정하고, 모든 클라이언트 코드에 반영하도록 한다.

### 매개변수를 질의 함수로 바꾸기
* 매개변수 목록은 함수의 동작에 변화를 줄 수 있는 일차적인 수단이므로, 함수의 변동 요인을 모아둔 곳에 해당한다.
* 때문에 다른 코드와 마찬가지로 매개변수 목록에서도 중복은 피하는 것이 좋고, 짧게 유지할수록 이해하기에는 쉬워진다.
* 호출되는 함수가 스스로도 쉽게 결정할 수 있는 값을 굳이 매개변수로 건네는 것도 일종의 중복에 해당한다.
  * 매개변수로 넘기는 경우 결정 주체는 클라이언트이며, 매개변수로 넘기지 않는 경우 주체는 호출되는 함수이다.
  * **습관적으로 호출하는 클라이언트 코드는 간단히 유지하되, 책임 소재는 호출되는 함수로 옮겨주는 것이 바람직**하다.
* 반면, 매개변수를 제거하는 것으로 의도치 않은 의존성이 호출되는 함수에 생기게 된다면 해당 리팩토링 기법은 적용하지 않아야 한다.
  * 이는 주로 함수 본문에서 외부 함수를 호출해야 하거나, 함수 밖으로 빼내어야 하는 객체에 담긴 데이터를 사용해야하는 경우에 발생한다.
* **해당 리팩토링 기법은 대상 함수가 참조 투명해야한다는 전제를 갖는다**.
  * 참조 투명이란 함수에 같은 값을 건네면 항상 동일한 동작을 수행한다는 의미이다.
  * **참조 투명한 함수는 동작을 예측하거나 테스트가 쉬우므로 특성을 유지하도록 해야 한다**.

### 매개변수를 질의 함수로 바꾸기 - 절차
1. 필요한 경우, 대상 매개변수의 값을 계산하는 코드를 별도의 함수로 추출한다.
2. 함수의 본문에서 대상 매개변수로 향하는 참조를 모두 찾고, 매개변수의 값을 만들어주는 표현식을 참조하도록 수정한다.
   * 이 때, 하나를 수정할 때마다 테스트를 진행한다.
3. 함수 선언 바꾸기 기법을 적용하여 대상 매개변수를 없애준다.

### 질의 함수를 매개변수로 바꾸기
* 코드를 분석하는 과정에서 전역 변수, 또는 제거 대상 원소를 참조하는 등 함수 안에 두기에는 애매한 참조를 발견하는 경우가 잦다.
* 이러한 문제는 해당 참조를 매개변수로 수정하는 것으로 해결할 수 있다.
  * 즉, **참조를 풀어내는 책임을 클라이언트로 옮겨주는 것으로 해결을 시도**한다.
* 이러한 상황은 대부분 코드의 의존 관계를 바꾸려 할 때 발생한다.
  * 예를 들어, 대상 함수가 더 이상 매개변수화하려는 특정한 원소에 의존하기를 원하지 않는 경우에 해당한다.
  * 이 경우, 매우 길고 반복적인 매개변수 목록을 사용하는 방식과 함수 끼리 많은 것을 공유하겨 결합되는 두 극단 사이에서 균형점을 찾아야 한다.
  * 그러나 대부분의 까다로운 결정과 마찬가지로, 이러한 결정 역시 특정 시점에 내린 것이 영원히 옳다고할 수 없다.
  * 따라서 **프로그램을 더욱 잘 이해하게 된 시점에 코드를 더 좋은 쪽으로 개선하기 쉽도록 미리 설계해두는 것이 중요**하다.
* 참조 투명한 함수는 다루기가 쉬운 반면, 참조 투명하지 않은 원소에 접근하는 모든 함수는 참조 투명성을 잃게 된다.
  * 이러한 문제는 해당하는 원소를 매개변수로 바꾸는 것으로 해결이 가능하다.
* 책임이 클라이언트에 옮겨지긴 하지만, 모듈을 참조 투명하게 만들어 얻는 장점은 매우 큰 편에 속한다.
  * 때문에 **모듈을 개발하는 경우 순수 함수를 따로 구분하되, 입출력이나 가변 원소를 다루는 로직 등으로 순수 함수를 감싸는 패턴을 사용할 수 있다**.
* 해당 리팩토링 기법을 통해 프로그램의 일부를 순수 함수로 수정할 수 있으며, 결과적으로 해당 부분을 다루기 쉽도록 만들 수 있다. 
* 반면, **해당 리팩토링 기법은 클라이언트 코드가 어떤 값을 제공할지 결정해야하므로 복잡해진다는 단점**이 있다.
  * 이는 의존성을 모듈 밖으로 미뤄 내어 의존성 처리 책임을 호출자에게 떠넘기기 때문이다.
    * 즉, 결합도를 낮춤으로써 얻어지는 효과에 대한 반대급부가 존재한다.
  * 이 역시 책임 소재를 프로그램의 어느 부분에 두느냐에 따라 결정되는 문제이며, 항상 정답이 있는 항목도 아니다.

### 질의 함수를 매개변수로 바꾸기 - 절차
1. 변수 추출하기 기법을 적용하여 질의 코드를 함수 본문의 나머지 코드와 분리한다.
2. 함수 본문 중, 해당 질의를 호출하지 않는 코드는 별도의 함수로 추출한다.
   * 이 경우, 함수의 이름은 검색하기 쉬운 이름으로 명명한다.
3. 1.에서 만든 변수는 인라인하여 제거한다.
4. 기존의 함수 역시 인라인한 후, 새로운 함수의 이름을 기존 함수의 이름으로 수정한다.

## 2022-04-25 Mon
### 세터 제거하기
* 세터를 제공한다는 것은 필드가 수정될 수도 있음을 의미하며, 객체 생성 후에 수정되지 않길 바라는 필드라면 세터를 제공하지 않아야 한다.
  * 오로지 생성자를 통해서만 객체의 필드를 초기화하는 것으로 각 필드를 불변으로 만들 수 있다.
* 필요하다면 **세터를 제거하여 객체 생성 후에 값이 바뀌지 않는다는 사실을 언어 차원에서는 물론 다른 개발자들에게도 명시적으로 알릴 수 있도록 해야 한다**. 

### 세터 제거하기 - 절차
1. 설정 대상 값을 생성자에서 초기화하지 않는 경우, 이를 생성자가 처리할 수 있도록 수정한다.
2. 생성자 외부에서 세터를 호출하는 곳을 제거하는 대신 새로 정의한 생성자를 사용하도록 한다.
   * 이 때, 하나를 수정할 때마다 테스트를 진행한다.
3. 세터 메소드를 인라인하고, 가능하다면 해당 필드를 불변으로 만든다.
4. 테스트를 진행한다.

### 생성자를 팩토리 메소드로 변경하기
* 객체 지향 언어에서 제공되는 생성자는 객체를 초기화하기 위해 사용하는 특별한 용도의 함수이며, 실제로도 새로운 객체 생성을 위해 생성자를 호출한다.
* 반면 생성자에는 일반 함수에는 없는 다음과 같은 제약 조건도 존재한다.
  1. 반드시 생성자를 정의한 클래스의 인스턴스만 반환할 수 있으며, 서브클래스의 인스턴스나 프록시를 반환할 수는 없다.
  2. 생성자의 이름은 고정되므로, 더 적절한 이름이 떠올랐더라도 사용할 수 없다.
* 생성자를 팩토리 메소드로 대체하면 이러한 제약을 없앨 수 있으며, 팩토리 메소드에서 생성자를 대신 호출하도록 수정할 수 있다.

### 생성자를 팩토리 메소드로 변경하기 - 절차
1. 팩토리 메소드를 정의하고, 본문에서 기존 생성자를 호출하도록 작성한다.
2. 생성자를 호출하던 코드는 팩토리 메소드를 호출하는 방식으로 수정하되 하나를 수정할 때마다 테스트를 진행한다.
3. 생성자의 가시 범위를 최소화한다.

### 함수를 명령으로 변경하기
* 함수는 프로그래밍의 기본적인 요소 중 하나이나, 함수를 함수만을 위한 객체 내부로 캡슐화하면 더 유용해지는 경우가 있다.
  * 이러한 객체를 명령 객체, 또는 단순히 명령이라고 표현한다.
  * 이 때, 명령 질의 분리 원칙의 명령과는 다른 의미를 갖는다.
* **명령 객체는 대부분 메소드 하나로 구성되며, 이러한 메소드를 요청하여 실행하는 것이 객체의 실제 목적**이 된다.
  * **이를 통해 길고 복잡한 함수가 사용하는 변수나 유효범위에 종속되지 않고 함수 추출하기 등의 리팩토링 기법을 적용할 수 있다**.
* 명령은 일반 함수 메커니즘보다 더 유연하게 함수를 제어하고 표현할 수 있도록 한다.
  * 예를 들어, 명령은 되돌리기와 같은 보조 연산을 제공할 수 있다.
  * 나아가 수명주기를 더욱 정밀하게 제어하기 위해 필요한 매개변수를 만드는 메소드도 제공할 수 있다.
* 명령 객체를 통해 일급 함수나 중첩 함수 기능을 제공하지 않는 언어에서도 유사한 기능을 흉내낼 수 있다.
* 그러나, **명령 객체의 유연성 역시 복잡성을 키우고 얻는 대가**이다.
  * 때문에 일급 함수를 사용할 수 있는 경우라면, 가능한 한 일급 함수를 사용하는 것이 바람직하다.
  * **반면 명령보다 더 간단한 방식으로는 얻을 수 없는 기능이 필요하다면 명령을 사용해도 무방**하다.

### 함수를 명령으로 변경하기 - 절차
1. 대상 함수의 기능을 옮기기 위한 빈 클래스를 정의하고, 클래스의 이름은 함수의 이름에 기초하여 명명한다.
2. 정의한 빈 클래스로 함수를 옮겨준다.
   * 이 때, 리팩토링이 완료되기까지는 기존 함수를 전달 함수로 남겨둔다.
   * 또한 명령과 관련된 함수의 이름은 사용하는 언어의 명명 규칙을 따라준다.
   * 규칙이 딱히 없는 경우, execute나 call과 같은 일반적인 명령 실행 함수의 이름을 명명할 수 있다.
3. 함수의 인수 각각은 명령의 필드로 만들어 생성자로 설정할지 고려한다.
   * **이러한 방식은 명령의 수명주기를 관리하거나 사용자 정의 기능 등을 제공해야 하는 경우에는 대개 매개변수가 복잡해지므로 편리**하다.

### 명령을 함수로 변경하기
* 명령 객체는 복잡한 연산을 다룰 수 있는 강력한 메커니즘을 제공한다.
  * 예를 들어, 큰 연산을 여러 작은 메소드로 쪼개고 필드를 통해 쪼개진 메소드끼리 정보를 공유할 수 있도록 한다.
* 그러나 **명령 객체는 함수를 하나 호출하여 정해진 일을 수행하는 용도로만 사용되므로, 로직이 크게 복잡하지 않다면 단점이 더 많다**.

### 명령을 함수로 변경하기 - 절차
1. 명령을 생성하는 코드와 명령의 실행 메소드를 호출하는 코드를 함께 함수로 추출한다.
2. 명령의 실행 함수가 호출하는 보조 메소드를 각각 인라인한다.
   * 보조 메소드가 값을 반환하는 경우, 함수 인라인보다 변수 추출하기 기법을 먼저 적용하는 것이 좋다.
3. 함수 선언 바꾸기 기법을 적용하여 생성자의 매개변수 모두를 명령의 실행 메소드로 옮겨준다.
4. 명령의 실행 메소드에서 참조하는 필드들 대신 대응되는 매개변수를 사용하도록 수정한다.
   * 이 때, 하나를 바꿀 때마다 테스트를 진행한다.
5. 생성자의 호출과 명령의 실행 메소드 호출을 호출자 내부로 인라인한 후, 테스트를 진행한다.
6. 죽은 코드 제거하기 기법을 적용하여 명령 클래스를 제거한다.

### 수정된 값을 반환하기
* 데이터가 어떻게 수정되어 변경되는지 추적하는 작업은 코드를 이해하는 과정에서 가장 어려운 부분 중 하나이다.
  * 특히, 같은 데이터 블록을 읽고 수정하는 코드가 여러 곳에 존재한다면 데이터의 수정 흐름과 코드의 흐름을 일치시키기 어렵다.
* 따라서 **데이터가 수정된다면 그 사실을 명확히 명시하고, 어느 함수가 무엇을 하는지 쉽게 알 수 있도록 하는 일은 매우 중요**하다.
* 함수의 목적이 변수를 수정하는 것이라면, 수정된 값을 반환하여 클라이언트가 이를 변수에 저장하도록 코드를 작성할 수 있다.
  * 이러한 방식은 클라이언트 코드를 읽을 때 변수가 수정될 것임을 분명하게 인식할 수 있다.
* **해당 리팩토링 기법은 값 하나를 계산하는 목적이 있는 함수에서 가장 효과적**이다.
  * 반면, 여러 값을 수정하는 함수에는 적절하지 못한 방법이다.

### 수정된 값을 반환하기 - 절차
1. 함수가 수정된 값을 반환하게 하고, 클라이언트가 그 값을 자신의 변수에 저장하도록 수정한 후에 테스트를 진행한다.
2. 호출되는 함수 내부에서 반환할 값을 가리키는 새로운 변수를 선언한 후 테스트를 진행한다.
3. 계산을 통한 초기화와 선언이 동시에 이루어지도록 통합한 후 테스트를 진행한다.
   * 프로그래밍 언어 차원에서 가능한 경우, 해당 변수를 불변으로 지정한다.
4. 호출되는 함수의 변수 이름을 새로운 역할에 어울리도록 수정한 후 테스트를 진행한다.

### 오류 코드는 예외로 변경하기
* 예외는 언어 차원에서 제공하는 독립적인 오류 처리 메커니즘이다.
  * 오류가 발견되면 예외를 던지고, 적절한 예외 핸들러를 찾을 때까지 콜스택을 타고 예외가 위로 전파된다.
* 예외를 사용하면 오류 코드를 일일히 검사하거나 오류를 식별하여 콜스택 위로 던지는 작업을 신경쓰지 않아도 된다.
* 예외에는 독자적인 흐름이 있으므로, 프로그램의 나머지에서 오류 발생에 따른 복잡한 대응 코드를 작성하거나 읽을 필요가 없도록 할 수 있다.
* 예외는 대다수의 다른 정교한 메커니즘과 함께 정확하게 사용되는 경우에만 최고의 효과를 낼 수 있다.
  * **예외는 예상 밖의 동작일 때만 사용되어야 하며, 프로그램의 정상 동작 범주에 들지 않는 오류 상황을 나타내는 경우에만 사용**되어야 한다.

### 오류 코드는 예외로 변경하기 - 절차
1. 콜스택 상위에 해당 예외를 처리할 예외 핸들러를 작성한 후 테스트를 진행한다.
   * 해당 핸들러는 처음에는 모든 예외를 다시 던지도록 정의한다.
   * 적절한 처리를 수행하는 핸들러가 이미 존재하는 경우, 지금의 콜스택도 처리할 수 있도록 확장한다.
2. 해당 오류 코드를 대체할 예외와, 그 밖의 예외를 구분할 식별 방법을 찾는다.
   * 이는 언어에 맞는 방식을 선택하며, 대부분의 언어에서는 서브클래스를 사용하는 것으로 충분하다.
3. 정적 검사를 수행한다.
4. catch 절을 수정하여 직접 처리할 수 있는 예외는 처리하고, 그렇지 않은 예외는 다시 던지도록 수정한 후 테스트를 진행한다.
5. 오류 코드를 반환하는 모든 곳에서 예외를 던지도록 수정하되, 하나를 수정할 때마다 테스트를 진행한다.
6. 모두 수정을 마쳤다면 해당 오류 코드를 콜스택 위로 전달하는 코드를 모두 제거한다.
   * 이 때, 하나를 수정할 때마다 테스트를 진행한다.

### 예외를 사전 확인으로 변경하기
* 예외는 오류 코드를 연쇄적으로 전파하던 기존의 긴 코드를 예외로 바꾸어 깔끔히 제거하도록 하는, 프로그래밍 언어의 발전에 의미 있는 개념이다.
* 그러나 다른 좋은 것들과 마찬가지로, 예외 역시 과용되기 쉽다.
* **예외는 반드시 뜻 밖의 오류 상황, 즉 예외적인 동작에서만 사용되어야 한다**.
  * 때문에 **함수 호출시 문제가 될 수 있는 조건을 미리 검사할 수 있는 경우, 예외를 던지는 것보다는 클라이언트 측에서 조건을 검사하도록 수정**해야 한다.

### 예외를 사전 확인으로 변경하기 - 절차
1. 예외를 유발하는 상황을 검사할 수 있는 조건문을 추가한다.
2. catch 블록의 코드를 조건문의 조건절 중 하나로 옮기고, 남은 try 블록의 코드는 다른 조건절로 옮긴다.
3. catch 블록에 어서션을 추가하고 테스트를 진행한다.
4. try - catch 블록을 제거한 후, 테스트를 진행한다.
# Objects
## 2022-04-04 Mon

## 합성과 유연한 설계
* 상속과 합성은 널리 사용되는 코드 재사용 기법이지만, 코드를 재사용하기 위한 목적을 제외하면 큰 차이를 보인다.

### 상속과 합성의 차이
* 상속은 부모 클래스와 자식 클래스를 연결하여 부모 클래스의 코드를 재사용한다.
   * 합성은 전체를 표현하는 객체가 부분을 표현하는 객체를 포함하여 호출하는 것으로 부분 객체의 코드를 재사용한다.
* 상속은 부모 클래스와 자식 클래스 사이의 의존성이 컴파일타임에 연결된다.
  * 합성은 두 객체 사이의 의존성이 런타임에 해결된다.
* 상속 관계는 is - a 관계이다.
  * 합성은 has - a 관계이다.
* 상속은 자식 클래스가 부모 클래스의 내부 구현에 대해 상세하게 알아야 하므로 상속 계층도 내의 클래스들의 결합도가 높아진다.
  * 합성은 부분 객체의 구현에 의존하지 않으며, 대신 퍼블릭 인터페이스에 의존한다.
  * **합성을 사용하는 경우, 포함된 객체의 내부 구현이 변경되더라도 영향을 최소화할 수 있기 때문에 변경에 안정적인 코드를 얻을 수 있다**.
* 상속 관계는 클래스 사이의 정적인 관계이며, 코드 작성 시점에 결정된 관계를 이후에 변경할 수 없다.
  * **합성 관계는 객체 사이의 동적인 관계이며, 런타임에 동적으로 관계를 변경**할 수 있다.
  * 때문에 합성 관계는 상속보다 변경에 대응하기 쉽고 유연한 설계를 얻을 수 있게 한다.
* 상속은 부모 클래스 내부에 구현된 코드 자체를 재사용하므로, 구현에 대해 의존한다.
  * **합성은 부분 객체의 퍼블릭 인터페이스를 재사용하므로, 구현에 대한 의존 대신 퍼블릭 인터페이스에 대한 의존으로 대체**할 수 있다.
  * 즉, 클래스 간의 높은 결합도를 객체 간의 낮은 결합도로 대체할 수 있다.
```
> 변경에 유연하게 대처할 수 있는 설계는 대부분의 경우에 정답이므로, 상속보다 객체 합성이 더 좋은 방법이다.
```

### 상속 관계를 합성 관계로 변경하기
* 상속을 합성으로 바꾸기 위해, 다음과 같은 절차를 따르도록 한다.
  1. 자식 클래스에 선언된 상속 관계를 제거한다.
  2. 부모 클래스의 인스턴스를 자식 클래스의 인스턴스 변수로 선언한다.
* **상속을 남용하는 경우 발생할 수 있는 아래와 같은 문제점은 합성 관계로 변경하는 것으로 모두 해결**된다.
  1. 자식 클래스의 용도에 적절하지 않은 부모 클래스의 오퍼레이션을 상속받을 수 있다.
  2. 자식 클래스가 부모 클래스의 메소드를 오버라이딩하는 경우, 자식 클래스가 부모 클래스의 메소드 호출 방법에 영향을 받을 수 있다.
  3. 자식 클래스와 부모 클래스 사이의 개념적 결합으로 인해 부모 클래스를 수정할 때 자식 클래스도 함께 수정해야할 수 있다.

### 구현 결합도를 제거하면서 퍼블릭 인터페이스를 상속받기
* 어떤 클래스의 모든 메소드를 상속받되, 구현에 대한 결합도는 제거하고 싶은 경우가 있을 수 있다.
  * 예를 들어, ArrayList의 모든 메소드를 상속받되 내부 구현과 결합되고 싶지 않은 경우이다.
* 이 경우, **인터페이스인 List를 구현하되 내부에 ArrayList의 인스턴스를 합성하는 것으로 구현 결합도를 제거하고 퍼블릭 인터페이스를 유지**할 수 있다.
* 해당 방식으로 필요한 메소드의 구현을 수정하되, 재정의하는 모든 인터페이스는 합성된 부분 객체에게 전달한다.
  * 이렇듯 **동일한 메소드의 호출을 그대로 전달하기 위해 추가되는 메소드를 포워딩 메소드라고 하며, 전달 과정 자체는 포워딩**이라고 한다.
```
> 포워딩은 기존 클래스의 인터페이스를 그대로 외부에 제공하되, 구현에 대한 결합 없이 일부 작동 방식을 변경하고 싶은 경우에 유용하게 사용할 수 있는 기법이다.
```
# Objects
## 2022-04-01 Fri

## 의존성 관리
* 잘 설계된 객체지향 애플리케이션은 책임이 명확하고 하나의 일만 잘 하는 작고 응집도 높은 객체들로 구성된다.
* 이러한 작은 객체들은 단독으로 수행할 수 있는 작업이 거의 없으므로, 필연적으로 다른 객체와의 협력을 수반한다.
* 이러한 **협력은 필수적이지만, 협력을 위한 의존성이 과도해지면 애플리케이션을 변경하기 어렵게 만드는 요인이 될 수 있다**.
  * 협력을 필요로 하는 객체는 협력 대상 객체를 알기 위해 결합되기 때문이다.
* 객체지향 설계의 핵심은 협력을 위해 필요한 의존성은 유지하면서도 변경에 방해되는 의존성을 제거하는 데에 있다.
  * **이런 관점에서 객체지향 설계란 의존성을 관리하는 것이며, 변화에 유연하도록 의존성을 정리하는 기술**이기도 하다.

### 변경과 의존성
* 어떤 객체가 협력을 위해 다른 객체를 필요로 할 때 두 객체 사이의 의존성이 발생한다.
* 이러한 의존성은 런타임과 구현 시점에 서로 다른 의미를 가진다.
  1. 런타임: 의존하는 객체가 정상 동작하기 위해 런타임에 의존 대상 객체도 반드시 존재해야 한다.
  2. 구현 시점: 의존 대상 객체가 변경되는 경우, 의존하는 객체도 함께 변경된다.
* **의존성은 방향성을 가지며, 항상 단방향**이다.
* **의존성이라는 용어는 두 요소 사이에서 의존 대상 요소가 변경될 때 의존하는 요소도 함께 변경될 수 있다는 점을 암시**한다.
  * 즉, 의존성은 변경의 전파 가능성을 의미하기도 한다.
* 의존성은 다시 다음과 같이 분류해볼 수 있다.
  1. 인스턴스 변수로 사용되는 의존성
  2. 메소드 인자로 전달되는 의존성
  3. 인터페이스 또는 부모 클래스 등 구현 및 상속의 대상
* 그러나 **종류를 불문하고 의존성이 갖는 의미는 같으며, 의존성은 항상 변경 전파 가능성을 암시**한다.

### 의존성 전이
* 의존성은 전이될 수 있으며, 객체 A가 의존하는 대상이 객체 C에 의존하는 객체 B인 경우 객체 A는 간접적으로 객체 C에도 의존한다.
* 의존성은 변경의 전파 가능성이므로, 모든 경우에 반드시 의존성이 전이되는 것은 아니다.
  * 실제로는 변경의 방향과 객체 별 캡슐화의 정도에 따라 변경 전파 여부는 달라질 수 있다.
  * 즉, 의존성 전이는 변경에 의해 영향이 전파될 수도 있다는 경고에 해당한다.
* 의존성은 전이될 수 있으므로, 직접 의존하는 경우인 직접 의존성과 전이된 의존성인 간접 의존성을 구분하기도 한다.
* 의존 대상은 클래스 뿐만 아니라 객체, 모듈, 또는 더 큰 실행 시스템일 수도 있다.
  * 즉, 의존성의 대상은 변경과 관련이 있는 어떤 개념에도 적용할 수 있다.
* **의존 대상이 무엇이건간에, 의존하고 있는 대상의 변경에 영향을 받을 수 있는 가능성을 시사하는 의존성의 본질은 변하지 않는다**.
# Objects
## 2022-04-01 Fri

## 의존성 관리
* 잘 설계된 객체지향 애플리케이션은 책임이 명확하고 하나의 일만 잘 하는 작고 응집도 높은 객체들로 구성된다.
* 이러한 작은 객체들은 단독으로 수행할 수 있는 작업이 거의 없으므로, 필연적으로 다른 객체와의 협력을 수반한다.
* 이러한 **협력은 필수적이지만, 협력을 위한 의존성이 과도해지면 애플리케이션을 변경하기 어렵게 만드는 요인이 될 수 있다**.
  * 협력을 필요로 하는 객체는 협력 대상 객체를 알기 위해 결합되기 때문이다.
* 객체지향 설계의 핵심은 협력을 위해 필요한 의존성은 유지하면서도 변경에 방해되는 의존성을 제거하는 데에 있다.
  * **이런 관점에서 객체지향 설계란 의존성을 관리하는 것이며, 변화에 유연하도록 의존성을 정리하는 기술**이기도 하다.

### 변경과 의존성
* 어떤 객체가 협력을 위해 다른 객체를 필요로 할 때 두 객체 사이의 의존성이 발생한다.
* 이러한 의존성은 런타임과 구현 시점에 서로 다른 의미를 가진다.
  1. 런타임: 의존하는 객체가 정상 동작하기 위해 런타임에 의존 대상 객체도 반드시 존재해야 한다.
  2. 구현 시점: 의존 대상 객체가 변경되는 경우, 의존하는 객체도 함께 변경된다.
* **의존성은 방향성을 가지며, 항상 단방향**이다.
* **의존성이라는 용어는 두 요소 사이에서 의존 대상 요소가 변경될 때 의존하는 요소도 함께 변경될 수 있다는 점을 암시**한다.
  * 즉, 의존성은 변경의 전파 가능성을 의미하기도 한다.
* 의존성은 다시 다음과 같이 분류해볼 수 있다.
  1. 인스턴스 변수로 사용되는 의존성
  2. 메소드 인자로 전달되는 의존성
  3. 인터페이스 또는 부모 클래스 등 구현 및 상속의 대상
* 그러나 **종류를 불문하고 의존성이 갖는 의미는 같으며, 의존성은 항상 변경 전파 가능성을 암시**한다.

### 의존성 전이
* 의존성은 전이될 수 있으며, 객체 A가 의존하는 대상이 객체 C에 의존하는 객체 B인 경우 객체 A는 간접적으로 객체 C에도 의존한다.
* 의존성은 변경의 전파 가능성이므로, 모든 경우에 반드시 의존성이 전이되는 것은 아니다.
  * 실제로는 변경의 방향과 객체 별 캡슐화의 정도에 따라 변경 전파 여부는 달라질 수 있다.
  * 즉, 의존성 전이는 변경에 의해 영향이 전파될 수도 있다는 경고에 해당한다.
* 의존성은 전이될 수 있으므로, 직접 의존하는 경우인 직접 의존성과 전이된 의존성인 간접 의존성을 구분하기도 한다.
* 의존 대상은 클래스 뿐만 아니라 객체, 모듈, 또는 더 큰 실행 시스템일 수도 있다.
  * 즉, 의존성의 대상은 변경과 관련이 있는 어떤 개념에도 적용할 수 있다.
* **의존 대상이 무엇이건간에, 의존하고 있는 대상의 변경에 영향을 받을 수 있는 가능성을 시사하는 의존성의 본질은 변하지 않는다**.

### 런타임 의존성과 컴파일타임 의존성
* 런타임은 애플리케이션이 실행되는 시점이며, 컴파일타임은 일반적으로 컴파일이 진행 중인 시점 또는 코드 그 자체를 말한다.
* **객체지향 애플리케이션에서 런타임의 주인공은 객체이므로, 런타임 의존성이 다루는 대상은 객체 간의 의존성**이다.
* 반면 **코드 관점에서 주인공은 클래스이므로, 컴파일타임 의존성은 일반적으로 클래스 간 의존성을 다룬다**.
* **중요한 것은 런타임 의존성과 컴파일타임 의존성은 서로 다를 수 있다는 사실**이다.
  * 예를 들어 인터페이스를 구현하는 클래스를 다형적으로 사용하는 경우, 런타임에서는 인스턴스화 상호작용하지만 컴파일타임에는 실체를 알 수 없다.
* 어떤 클래스의 인스턴스가 다양한 클래스의 인스턴스와 협력하기 위해서는 협력 대상 인스턴스의 구체적인 클래스를 알지 못해야 한다.
  * **실제로 협력하는 객체의 종류는 런타임에 해결해야 하며, 컴파일타임 구조와 런타임 구조 사이의 거리가 멀수록 설계는 유연**해진다.

### 컨텍스트 독립성
* 클래스는 자신과 협력할 객체의 구체적인 클래스에 대해 알아서는 안되며, 구체 클래스를 알수록 해당 클래스가 사용되는 문맥에 결합된다.
  * **구체 클래스에 대해 의존하는 것은 클래스의 인스턴스가 어떤 문맥에서 사용될지 구체적으로 명시하는 것**과 같다.
* **클래스가 특정한 문맥에 강하게 결합될수록 다른 문맥에서 사용하기는 더 어려워지므로, 클래스가 사용될 문맥은 최소한의 가정으로 구성**되어야 한다.
* 특정 문맥에 대해 최소한의 가정만으로 작성된 클래스는 다른 문맥에서 재사용하기가 더 수월해질 수 있다.
  * 이러한 특징을 컨텍스트 독립성이라고 부른다.
* 설계가 유연해지려면 가능한 한 자신이 실행될 컨텍스트에 대한 구체적인 정보를 적게 알아야 한다.
* **컨텍스트에 대한 정보가 적을수록 다양한 컨텍스트에서 재사용될 수 있으며, 결과 설계는 더욱 유연해지고 변화에 탄력적으로 대응할 수 있게 된다**.
```
> 시스템을 구성하는 객체가 컨텍스트 독립적이라면 해당 시스템은 변경이 쉽다.
> 이 때, 컨텍스트 독립성은 각 객체가 해당 객체를 실행하는 시스템에 대해 무엇도 알지 못하는 특징을 의미한다.
```

### 의존성 해결
* 컴파일타임에 작성된 의존성은 구체적인 런타임 의존성으로 대체되어야만 한다.
* **의존성 해결이란, 이렇듯 컴파일타임 의존성을 실행 컨텍스트에 맞는 적절한 런타임 의존성으로 교체하는 것을 의미**한다.
* 의존성을 해결하는 방법은 크게 다음과 같은 세 가지 방법으로 나눌 수 있다.
  1. 객체를 생성하는 시점에 생성자를 활용하여 의존성을 해결
  2. 객체 생성 후 setter 메소드로 의존성을 해결
  3. 메소드 실행시 인자로 넘겨 의존성을 해결
* 이 중 setter를 활용하는 방식은 객체를 생성한 후에도 의존하는 대상을 변경할 수 있는 가능성을 열기 위해 사용한다.
  * setter를 활용한 방식은 런타임에 의존 대상을 변경할 수 있으므로, 설계를 더 유연하게 만들 수 있다.
  * 반면 setter가 실행되기 전인 객체 실행 직후 등에는 상태가 불완전한 시점이 존재한다는 한계가 있다.
* **이상적인 방식은 객체 생성시 생성자를 활용하여 의존성을 해결하고 객체를 완전한 상태로 만든 후, 필요시 setter를 활용하는 방식**이다.
  * 해당 방식은 시스템의 상태를 안정적으로 유지하면서도 유연성을 향상시킬 수 있기 때문에 의존성 해결을 위해 선호되는 방식이다.
* 반면, 객체가 항상 의존성을 알 필요 없이 계산 시점에만 알아야하는 경우에는 메소드의 인자를 활용한다.
  * 해당 방식은 메소드가 실행될 때마다 의존 대상이 변경되어야 하는 경우에 유용하다.

### 의존성과 결합도
* 객체지향의 근간은 협력이며, 의존성은 객체들의 협력을 가능케 한다는 점에서 의의가 있다.
  * 그러나 필요 이상으로 과하게 정의된 의존성은 문제가 될 수 있다.
* 바람직한 의존성과 그렇지 않은 경우는 다음과 같이 구분할 수 있다.
  1. 다양한 환경에서 재사용 가능한 의존성은 바람직하다.
  2. 어떠한 의존성이 다양한 환경에서 클래스를 재사용할 수 없도록 강제하는 경우, 해당 의존성은 바람직하지 않다.
  3. **다른 환경에서 재사용하기 위해 내부 구현을 반드시 변경해야하는 모든 의존성은 바람직하지 않다**.
* 즉, 컨텍스트 독립적인 의존성은 바람직한 반면 컨텍스트에 강하게 결합된 의존성은 바람직하지 않다.
* 일반적으로 의존성은 결합도로 표현되며, 바람직한 의존성은 느슨한 결합도 또는 약한 결합도를 갖는다고 표현한다.
  * 반면, 바람직하지 못한 의존성은 강한 결합도를 갖는다고 표현할 수 있다.
* 반면 의존성과 결합도는 완전하게 동일한 의미를 갖지는 않는다.
  * 의존성은 두 요소 사이의 관계 자체의 유무를 나타낸다.
  * 결합도는 두 요소 사이의 의존성 정도를 나타낸다.

### 결합을 낳는 지식
* 객체 간에 서로를 알고 있는 지식의 양이 결합도를 결정하며, 더 많이 알수록 강하게 결합된다.
  * 다시 말해, 결합도의 정도는 한 요소가 자신이 의존하는 다른 요소에 대해 알고 있는 정보의 양으로 결정된다.
* **더 많이 아는 것은 더 한정적인 컨텍스트에서 활용 가능하다는 것을 의미하며, 이 경우 다른 컨텍스트에서 사용하기 위해 객체 내부의 수정이 필수불가결**하다.
```
> 느슨한 결합도를 유지하기 위해서는 협력 대상에 대해 가능한 한 적게 알아야 하며, 필요한 정보 외에는 감추는 것이 바람직하다.
```

### 추상화에 의존하기
* 추상화란 어떤 세부사항, 구조를 더 쉽게 이해하기 위해 특정 절차나 물체를 의도적으로 생략하여 복잡도를 낮추는 기법이다.
  * 즉, **추상화를 활용하면 불필요한 정보를 감추어 결합도를 느슨하게 유지할 수 있다**.
* 일반적으로 추상화와 결합도 관점에서 의존 대상은 다음과 같이 구분할 수 있으며, 아래쪽으로 갈수록 결합도는 느슨해진다.
  1. 구체 클래스 의존성
  2. 추상 클래스 의존성
  3. 인터페이스 의존성
* 인터페이스에 의존하면 상속 계층을 알지 못하더라도 협력이 가능하다.
  * 인터페이스 의존성은 수신 가능한 메시지에 대한 정보만을 남기므로, 추상 클래스보다 결합도가 낮다.
* 이로 인해 다양한 클래스 상속 계층에 속한 객체들이 동일한 메시지를 수신할 수 있도록 컨텍스트를 확장할 수 있게 된다.
* **중요한 것은 실행 컨텍스트에 대해 알아야 하는 정보를 줄일수록 결합도가 낮아진다는 사실**이다.
  * 즉, **의존하는 대상이 더 추상적일수록 결합도는 더 낮아진다**.

### 명시적인 의존성
* **의존성은 명시적으로 퍼블릭 인터페이스에 노출하는 것이 바람직**하다.
  * 반면 인스턴스 내부에서 의존성 대상 인스턴스를 직접 생성하는 방식은 의존성이 퍼블릭 인터페이스에 드러나지 않으므로, 숨겨진 의존성에 해당한다.
* 명시적이지 않은 의존성은 의존성을 파악하기 위해 반드시 내부 구현을 살펴봐야만 한다.
* 더 큰 문제는 명시적이지 않은 의존성을 갖는 클래스를 다른 컨텍스트에서 재사용하기 위해서는 반드시 내부 구현을 수정해야한다는 사실이다.
  * **코드의 수정은 언제나 잠재적인 버그의 가능성을 내포**한다.
* 의존성은 명시적으로 표현되어야 하며, 의존성을 구현 내부 깊숙한 곳 어딘가에 숨기지 않아야 한다.
  * **유연하고 재사용 가능한 설계란 퍼블릭 인터페이스를 통해 의존성을 명시적으로 드러내는 설계**이다.
* 의존성 자체는 반드시 필요하며, 부끄러운일이 아니므로 숨길 필요가 없다.
  * 진정 **경계해야할 것은 의존성 자체가 아닌 의존성을 숨기는 일이며, 의존성을 명시적으로 드러내는 것 만으로 설계는 유연해지고 재사용성이 향상**된다.

### 해로운 new 연산자
* **대부분의 언어에서 클래스의 인스턴스를 생성할 수 있는 new 연산자가 제공되지만, 잘 못 사용된 new는 클래스 간의 결합도를 극단적으로 높일 수 있다**.
* 이와 같이 new가 해로울 수 있는 이유는 다음과 같다.
  1. new 연산자를 활용하기 위해서는 반드시 구체 클래스의 이름을 알아야하므로, 추상화에 의존할 수 없다.
  2. new 연산자는 생성자에 포함되어야 하는 인자들도 알아야하므로, 클라이언트가 알아야하는 지식의 양이 더욱 늘어난다.
* **상술한 해로움은 구체 클래스에 직접 의존하는 클래스의 결합도가 높아진다는 사실에서 기인**한다.
  * 결합도 측면에서 구체 클래스는 그 자체만으로 클라이언트가 알아야하는 지식의 양을 늘리며, new는 이러한 단점을 더욱 부각시킨다.
* **이러한 문제를 해결하려면 인스턴스를 생성하는 로직과 생성된 인스턴스를 사용하는 로직을 분리하는 것이 바람직**하다.
  * 인스턴스를 생성하기 위해 new 연산자를 활용하는 것보다 상술한 의존성 해결 방식에 의해 인스턴스를 전달 받아 사용하는 것이 좋다.
  * 클래스는 전달받은 인스턴스를 사용하는 변수에 할당하여 사용하며, 해당 인스턴스와 협력하기 위해 메시지를 전송하는 일만 수행해야 한다.
* 이렇듯 **사용과 생성 책임을 분리하여 올바른 객체가 올바른 책임을 수행하게 하는 것은 훌륭한 설계를 창조하는 기반**이다.
```
> 사용과 생성의 책임을 분리하고, 의존성을 생성자에 명시적으로 드러내는 것이 바람직하다.
> 나아가 구체 클래스보다 추상 클래스에 의존하도록 하는 것으로 설계는 한 층 더 유연해질 수 있다.
```

### 해롭지 않은 경우의 new 연산자
* 클래스 안에서 객체의 인스턴스를 직접 생성하는 방식은 협력하는 기본 객체를 설정하는 경우에는 유용하게 사용할 수 있다.
  * 예를 들어, 대부분의 경우 협력하는 객체가 동일한 타입이라면 생성 책임을 클라이언트로 옮기는 것은 사용성을 저해할 수 있다.
* **이 경우 기본 객체를 생성하는 생성자를 추가하고, 해당 생성자에서 기존 생성자를 호출하는 생성자 체이닝을 활용하는 것으로 해결**할 수 있다.
* 체이닝 방식은 메소드 오버로딩에도 유용하게 사용할 수 있다.
* 설계는 언제나 트레이드오프이며, 이 경우 트레이드오프의 대상은 결합도와 사용성이다.
  * 자신의 프로젝트가 클래스의 사용성을 더 중시하는 경향이 있는 경우, 구체 클래스에 의존하더라도 사용성을 높이는 방식을 택할 수 있다.

### 표준 클래스에 대한 의존
* 의존성이 문제가 되는 경우는 의존성이 변경 가능성을 내포하기 때문이다.
* 따라서, **애당초 변경될 가능성이 없는 클래스라면 의존성과 인스턴스 생성은 전혀 문제되지 않는다**.
* Java의 경우 JDK에 포함된 표준 라이브러리가 이에 해당하며, 이러한 클래스들은 구체 클래스에 의존하거나 직접 인스턴스를 생성하는 것이 문제가 되지 않는다.
* 반면 클래스를 직접 생성하더라도 가능한 한 추상 타입을 사용하는 것이 확장성 측면에서 유리하다.
  * **의존성에 의한 영향이 적은 상황에서도 추상화에 의존하고, 명시적으로 의존성을 드러내는 것은 좋은 설계 습관에 해당**한다.

### 컨텍스트의 확장
* 새로운 기능을 추가하는 경우, 가장 쉬운 방식은 기존 클래스에 if 분기 또는 인스턴스 변수를 추가하여 대응하는 것이다.
* **그러나 기존에 없던 새로운 기능을 예외 케이스로서 추가하는 방식은 코드 내부를 직접 수정하게 하고, 결국 잠재적인 버그의 발생 가능성을 높이게 된다**.
* 이상적인 방식은 새로운 요구사항인 예외 케이스를 클래스 내부에서 처리하지 말고, 기존의 객체 간 협력 방식을 따르도록 한다.
  * 예를 들어, 할인하지 않는 요구사항의 추가를 기존 클래스 내부에서 처리하지 말고 할인이라는 역할을 수행할 수 있는 새로운 객체로 정의한다.
* 이를 통해 기존 클래스를 수정하지 않고도 새로운 기능을 추가하는 것으로 요구사항에 대응할 수 있게 된다.
  * 즉, **새로운 기능을 위해 절차적인 코드를 작성하는 것보다는 인스턴스를 추가하거나, 제거하거나, 조합을 달리하는 것으로 시스템의 동작 방식을 변경**한다.
* 컨텍스트의 확장이 가능하게 하려면 다음과 같은 상술한 원칙들을 준수는 클래스를 작성해야 한다.
  1. 가능한 한 추상화에 의존한다.
  2. 생성자를 통해 의존성을 명시한다.
  3. new 연산자와 같이 구체 클래스를 생성하는 책임은 클래스 외부로 옮긴다.
* **상술한 원칙은 모두 객체 간의 결합도를 낮추며, 이를 통해 유연하고 재사용 가능한 설계를 만드는 핵심 개념인 컨텍스트의 확장을 가능케 할 수 있게 된다**.

### 조합 가능한 행동
* 컨텍스트의 확장은 다양한 종류의 기능이 필요한 컨텍스트에서 협력 대상 인스턴스를 교체하는 것으로 객체를 재사용할 수 있도록 한다.
  * 어떤 객체와 협력하느냐에 따라 객체의 행동이 달라지는 것은 유연하고 재사용 가능한 설계의 특징이다.
* 또한 이렇듯 **유연하고 재사용 가능한 설계는 응집도 높은 책임들을 갖는 객체들을 다양한 방식으로 연결하여 애플리케이션의 기능을 쉽게 확장할 수 있다**. 
* 또한, 유연하고 재사용 가능한 설계는 객체가 어떻게 기능을 수행하는지 나열하지 않고, 무엇을 하는지 표현한다.
  * **결과 객체의 행동을 선언적으로 정의할 수 있게 되어 가독성이 높아진다**.
```
> 유연하고 재사용 가능한 설계란, 객체들의 행동을 조합하여 새로운 행동을 이끌어낼 수 있도록 하는 설계이다.
> 훌륭한 객체지향 설계란 객체가 어떻게 기능을 수행하는지 표현하는 것이 아닌, 객체들의 조합을 선언적으로 표현하여 객체들이 무엇을 하는지 알게 하는 설계이다.
> 또한, 이런 설계를 창조하기 위한 핵심은 의존성의 관리에 있다.
```
# Objects
## 2022-04-03 Sun

## 상속과 코드 재사용
* 코드를 쉽게 재사용할 수 있는 특징은 객체지향 프로그래밍의 장점 중 하나이다.
* 객체지향에서는 클래스에 코드를 작성하므로, 클래스를 재사용하기 위해서는 새로운 클래스를 추가하는 방식을 사용한다.
* 재사용 관점에서의 상속은 클래스 내부에 정의된 인스턴스 변수와 메소드를 자동으로 새로운 클래스에 추가하는 기법이다.

### DRY 원칙
* **중복 코드를 제거해야하는 가장 큰 이유는 중복 코드가 변경을 방해하기 때문**이다.
* 프로그램의 본질은 비즈니스와 관련된 지식을 코드로 변환하는 데에 있으며, 이러한 지식은 항상 변하기 마련이다.
  * 때문에 **지식을 표현하는 코드 역시 항상 변경될 것이라고 생각하는 것이 좋다**.
  * 일단 새로운 코드를 추가했다면, 해당 코드는 언젠간 변경될 것이다.
* **코드는 언젠가 수정되기 마련인 특징에 기반하여, 중복 코드는 코드를 수정하기 위해 필요한 노력을 몇 배로 증가**시킨다.
* **코드의 중복을 판단하는 기준은 코드 모양의 유사성이 아닌 변경**이다.
  * 예를 들어, 요구사항이 변경되었을 때 함께 수정되어야 하는 코드는 중복이다.
  * 반면, 함께 수정될 필요가 없는 코드는 단지 로직이 유사한 것일 뿐 중복은 아니다.
  * 코드의 중복 여부를 결정하는 기준은 코드가 변경에 반응하는 방식이다.
* DRY 원칙은 프로그래머들이 마땅히 따라야하는 원칙이며, 동일한 지식을 중복하지 말 것을 강조한다.
  * DRY는 Don't Repeat Yourself의 약자이다.
  * 신뢰할 수 있고 수정하기 쉬운 소프트웨어를 만들기 위한 효과적인 방법으로서 DRY 원칙을 준수하고, 중복을 제거할 수 있다.
* **DRY 원칙은 다른 여러 이름으로도 불리우지만, 언제나 핵심은 코드 안에서 중복된 지식이 존재하지 않아야한다는 점**이다.

### 중복과 변경
* 중복 코드는 항상 함께 수정되므로, 수정 과정에서 누락된 것이 하나라도 존재한다면 바로 버그로 이어지게 된다.
  * 더 큰 문제는 중복 코드는 서로 다르게 수정하기가 쉽다는 점이다.
* **중복 코드를 제거하지 않고 코드를 수정하는 유일한 방법은 새로운 중복 코드를 추가하는 것이므로, 중복 코드는 항상 새로운 중복 코드를 부른다**.
* 나아가 새로운 중복 코드를 추가하는 과정에서는 항상 코드의 일관성이 무너질 위험이 수반된다.
* 결과, 중복 코드가 늘어날수록 애플리케이션은 변경에 취약해지고 새로운 버그가 발생할 가능성이 높아진다.
  * **중복 코드의 양이 많아질수록 버그는 늘어나는 반면, 코드를 변경하는 속도는 느려진다**.
* **이를 해결하기 위해서는 중복 코드를 추가하는 대신에 중복을 제거해야 하며, 기회가 생길 때마다 코드에 DRY 원칙을 적용**해야 한다.

### 타입 코드의 사용
* 두 클래스의 중복을 제거하는 방법 중 하나는 두 클래스를 단일 클래스로 합치고, 내부의 enum을 통해 타입을 구분하는 것이다.
  * 이 경우, 클래스의 타입 코드로 적용된 enum에 따라 실제 로직을 if - else 분기로 구분하게 된다.
* 그러나 **타입 변수를 활용하는 이러한 클래스는 앞서 다룬 바와 같이 낮은 응집도와 높은 결합도라는 또 다른 문제에 직면**하게 된다.
* **객체지향 프로그래밍 언어는 타입 코드를 사용하지 않고도 중복 코드를 관리할 수 있는 방법인 상속을 제공**한다.

### 상속을 활용한 중복 코드의 제거
* 상속의 기본적인 아이디어는 이미 존재하는 클래스와 유사한 클래스가 필요한 경우, 코드를 복사하지 말고 상속을 활용하여 코드를 재사용하라는 것이다.
* 그러나 **잘못 사용된 상속은 요구사항과 실제 구현의 차이를 크게 벌려 코드를 이해하기 어렵게 만든다**.
  * 특히 상속을 염두에 두고 설계되지 않은 클래스를 상속에 활용하는 경우, 이러한 현상은 더욱 두드러지게 나타난다.
* **상속을 통해 코드를 재사용하는 경우는 개발자의 가정을 이해하기 전에는 코드를 이해하기도 어려운 문제**가 있다.
  * 다시 말해, 상속을 이용하여 코드를 재사용하려면 부모 클래스의 개발자가 세운 과정이나 추론 과정을 정확히 이해해야 한다.
* 앞서 다룬 바와 같이 **하나의 모듈이 다른 모듈에 대해 많은 지식을 갖고 있을수록 결합도는 높아지며 변경은 어려워진다**.
* 때문에 **상속은 결합도를 높이며, 상속이 초래하는 부모 클래스와 자식 클래스 사이의 강한 결합은 코드를 수정하기 어렵게 만드는 요인**이 된다.
* 또한 부모 클래스의 메소드를 과도하게 재사용하는 경우, 부모 클래스가 수정되었을 때 자식 클래스에는 새로운 중복 코드가 추가될 가능성이 있다.

### 상속을 위한 경고
```
> 자식 클래스의 메소드에서 super 참조를 활용하여 부모 클래스의 메소드를 직접 호출하는 경우, 두 클래스는 강하게 결합된다.
> super 참조를 활용한 호출을 제거할 수 있는 방법을 찾아 불필요한 결합을 제거해야 한다.
```
* 상속을 활용하면 적은 노력으로 새로운 기능을 쉽고, 빠르게 추가할 수 있다.
  * **그러나 이로 인해 커다란 대가를 치뤄야할 수도 있다**.
* 상술한 바와 같이, **상속 관계로 연결된 자식 클래스가 부모 클래스의 변경에 취약해지는 현상은 취약한 기반 클래스 문제라는 용어로 정의**된다.
  * **취약한 기반 클래스 문제는 단순히 코드 재사용을 목적으로 상속을 사용한 경우에 발생하는 가장 대표적인 문제**이다. 
# Objects
## 2022-03-26 Sat

## 객체지향 프로그래밍
```
> 객체지향은 '객체'를 지향하는 프로그래밍 기법이다.
```
### 협력, 객체, 그리고 클래스
* 객체지향은 객체를 지향하는 것이며, 이 말은 너무나도 당연하게 와닿는다.
* 그러나 **대부분의 개발자는 프로그램을 작성하는 과정에서, 어떤 속성과 메소드를 갖는 클래스가 필요한지 고민하곤 한다**.
  * 이는 '객체'를 지향해야하는 본질과는 거리가 먼 접근법이다.
* **진정한 객체지향 패러다임으로의 전환은 클래스보다 객체에 초점을 맞출 때 성취**할 수 있다.
* 진정한 객체지향을 위해, 프로그래밍 과정에서는 특히 다음의 두 가지 항목에 집중할 수 있어야 한다.
  1. 어떤 클래스를 작성할지 고민하기에 앞서 어떤 객체들이 필요한지 고민해야 한다.
     * **클래스는 특정 객체들이 공유하는 공통적인 상태와 행동을 추상화한 개념**에 지나지 않는다.
     * 클래스의 윤곽을 잡으려면 객체군이 어떤 상태와 행동을 갖는지를 우선 고려해야 하며, 이러한 객체 위주의 접근법은 설계 과정을 단순화 한다.
  2. **객체를 독립적인 존재가 아닌, 목표 기능을 구현하기 위해 상호작용하는 공동체의 일원으로 바라봐야 한다**.
     * 객체는 홀로 존재하지 않으며, 다른 객체를 돕거나 의존하는 협력적인 존재다.
     * **객체를 협력 가능한 공동체의 일원으로 보는 관점은 설계를 더욱 유연하고 확장성 있게 한다**.
* **상술한 과정을 통해 객체들의 윤곽이 드러나면 이를 토대로 공통된 특성과 상태를 갖는 객체 타입을 정의**할 수 있다.
  * 이렇게 정의된 타입을 기반으로 클래스를 작성한다.
```
> 훌륭한 협력은 훌륭한 객체를 낳고, 훌륭한 객체는 훌륭한 클래스를 낳는다.
```

### 도메인 구조를 반영하는 프로그램 구조
* **도메인이란, 문제를 해결하기 위해 사용자가 프로그램을 사용하는 분야를 가리키는 용어**이다.
  * 소프트웨어는 사용자의 어떤 문제를 해결하기 위해 만들어진다.
* 객체지향 패러다임은 요구사항을 분석하는 초기부터 프로그램을 구현하는 마무리까지 객체라는 동일한 추상화 기법을 적용할 수 있기에 강력하다.
  * **이 과정에서 요구사항과 프로그램은 객체라는 동일한 관점을 적용**할 수 있다.
  * 때문에 도메인을 구성하는 개념은 프로그램의 객체와 클래스 구조로 매끄럽게 연결될 수 있다.
```
> 객체지향 패러다임은 도메인을 구성하는 요소들의 개념과 관계를 적절히 정의하는 것이 클래스 구조에 그대로 반영할 수 있기 때문에 강력하다.
```

### 클래스의 구현
* 도메인 개념들의 구조를 반영하는 클래스 구조가 설계되었다면, 적절한 프로그래밍 언어를 활용하여 이 구조를 실제로 구현해야 한다.
* **클래스를 구현하거나, 다른 개발자가 개발한 클래스를 사용할 때 가장 중요한 것은 클래스의 경계를 구분짓는 것**이다.
  * Java의 경우, 일반적으로 접근 제어자를 통해 경계를 구분한다.
  * **클래스는 내부와 외부를 구분하며, 훌륭한 클래스를 설계하는 핵심은 외부에 공개할 부분과 내부로 감출 부분을 결정하는 것**이다.
  * 잘 설계된 클래스는 객체의 속성을 내부로 감추고, 메소드를 활용해서만 상태를 변경할 수 있도록 해야한다.
```
> 내부와 외부로 경계가 명확히 구분된 클래스의 객체는 자율성이 보장되고, 개발자에게는 구현의 자유가 제공된다.
```

### 자율적인 객체
* 객체는 다음과 같은 중요한 특징을 갖는다.
  1. 객체는 상태와 행동을 함께 갖는 복합적인 존재이다.
  2. 객체는 스스로 판단하고 행동할 수 있는 자율적인 존재이다.
* 일반적으로 **객체는 상태와 행동을 함께 포함하는 단위로 정의되며, 이렇듯 데이터와 기능을 하나의 객체 내부로 묶어두는 것을 캡슐화라고 한다**.
* 대부분의 **객체지향 언어는 상태와 행동을 캡슐화하는 것에서 한 발 더 나아가, 이들에 대한 접근을 통제하는 접근 제어 기능을 제공**한다.
  * 캡슐화된 객체의 구성 요소에 접근을 제어하는 이유는 객체를 자율적인 존재로 만들기 위함이다.
* **객체지향의 핵심은 객체들이 스스로 상태를 관리하고, 상태에 따라 판단하고, 판단에 따라 행동할 수 있는 자율적인 객체들의 공동체를 구성하는 것**이다.
  * 객체가 자율적인 존재로 거듭나기 위해 외부는 객체 내부에 간섭하지 않아야 하므로, 객체가 어떻게 동작하는지 알 필요도 없다.
  * 때문에 **객체의 결정에 외부로부터 개입하는 것보다 객체가 스스로 최선의 결정을 내릴 수 있다고 믿고 기다리는 것이 이상적**이다.
* 객체지향 언어 차원에서 지원되는 캡슐화와 접근제어 기능은 객체를 다음과 같은 두 부분으로 나눈다.
  1. 외부에서 접근 가능한 퍼블릭 인터페이스
  2. 외부에서 접근이 불가능하고, 내부에서만 접근이 가능한 내부 구현
* 이러한 **인터페이스와 구현의 분리 원칙은 훌륭한 객체지향 프로그램을 만들기 위해 반드시 준수해야하는 핵심 원칙**이다.
  * 이 때, public으로 지정된 메소드만 퍼블릭 인터페이스로 취급한다.
  * Java 인터페이스의 메소드가 기본적으로 public인 이유에 해당할 듯하다!
* 일반적으로 객체의 상태는 내부로 숨기고, 객체가 수행할 수 있는 기능인 행동은 외부에 공개해야 한다.

### 프로그래머의 자유
* 프로그래머의 역할은 크게 다음과 같이 나눌 수 있다.
  1. 새로운 데이터 타입을 정의하는 클래스 작성자
  2. 여러 데이터 타입을 활용하여 애플리케이션을 구축해나가는 클라이언트 프로그래머
* 클래스 작성자는 클래이언트 프로그래머에게 필요한 부분만 공개하고, 나머지는 내부로 숨겨야 한다.
  * 이를 구현 은닉이라고 하며, 인터페이스가 변경되지 않는 이상 클라이언트 프로그래머에게 끼칠 영향을 걱정하지 않고 내부 구현을 변경할 수 있다.
* 구현 은닉은 다음과 같은 이유에서 모든 개발자에게 유용하다.
  1. 클라이언트 프로그래머는 인터페이스만 알아두면 되므로, 내부 구현을 알 필요조차 없다.
  2. 클래스 작성자는 인터페이스가 변경되지 않는 이상 외부 영향을 걱정하지 않고 내부 로직을 자유롭게 변경할 수 있다.
* **상술한 이유에서, 클래스를 개발하는 개발자는 인터페이스와 구현을 깔끔하고 명확하게 분리하기 위해 충분한 노력을 기울여야 한다**.
* **설계는 변경을 관리하기 위해 필요하며, 객체지향 언어는 객체간 의존성을 적절히 관리함으로써 변경의 영향 범위를 제어할 수 있는 다양한 기능을 제공**한다.
  * 객체의 변경을 관리하기 위해 제공되는 기법 중 대표적인 것이 접근 제어이다.

### 협력하는 객체의 공동체
* 객체지향의 장점은 객체를 이용하여 도메인의 의미를 풍부하게 표현할 수 있다는 점이다.
* 개념의 **의미를 명시적이고 분명하게 표현할 수 있다면, 해당 개념이 단 하나의 인스턴스 변수만 갖더라도 객체를 사용하여 구현하는 것이 이상적**이다.
  * 이렇듯 개념을 보다 명시적으로 표현하기 위해 노력하는 것은 전체적인 설계의 명확성과 유연성을 높이는 첫걸음이다.
* **객체지향 프로그램을 작성하는 경우, 우선 협력의 관점에서 어떤 객체가 필요할지 결정**한다.
  * 그 후 공통되는 상태와 행위를 구현하기 위한 클래스를 작성하도록 한다.

### 협력과 메시지
* 협력이란, 프로그램에서 어떠한 기능을 구현하기 위해 객체들 간에서 발생하는 상호작용 전반을 일컫는다.
  * 객체는 다른 객체의 인터페이스를 통해 임의의 행동을 수행하도록 요청할 수 있다.
  * 요청을 받은 객체는 자율적인 방법으로 요청을 적절히 처리한 후에 응답한다.
* **객체가 다른 객체와 상호작용할 수 있는 유일한 방법은 메시지를 전송하는 것**이다.
  * 이 때, 메시지를 전달받은 객체는 메시지를 수신했다고 표현할 수 있다.
* 메시지를 수신한 객체는 스스로 내린 결정에 따라 메시지를 처리할 방법을 결정한다.
  * 이렇듯 수신한 메시지를 처리하기 위한 자신만의 방법을 메소드라고 한다.
* 메시지와 메소드는 명확히 구분해야 하며, 이는 객체지향 패러다임의 확장성과 유연성, 유용성을 든든히 뒷받침하는 개념 중 하나이다.
  * 예를 들어, 다형성은 메시지와 메소드를 구분하는 것에서부터 시작한 개념이다.
* 메시지를 전송하는 객체는 수신 객체가 해당 메시지를 처리해줄 수 있다고 믿고 메시지를 전달한다.
* 메시지는 수신하는 객체는 메시지에 따라 자신만의 적절한 메소드를 선택하여 처리한다.
```
> 메시지를 처리하는 방법을 결정하는 것은 메시지를 수신한 객체의 문제이다.
```
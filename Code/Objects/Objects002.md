# Objects
## 2022-03-26 Sat

## 객체지향 프로그래밍
```
> 객체지향은 '객체'를 지향하는 프로그래밍 기법이다.
```
### 협력, 객체, 그리고 클래스
* 객체지향은 객체를 지향하는 것이며, 이 말은 너무나도 당연하게 와닿는다.
* 그러나 **대부분의 개발자는 프로그램을 작성하는 과정에서, 어떤 속성과 메소드를 갖는 클래스가 필요한지 고민하곤 한다**.
  * 이는 '객체'를 지향해야하는 본질과는 거리가 먼 접근법이다.
* **진정한 객체지향 패러다임으로의 전환은 클래스보다 객체에 초점을 맞출 때 성취**할 수 있다.
* 진정한 객체지향을 위해, 프로그래밍 과정에서는 특히 다음의 두 가지 항목에 집중할 수 있어야 한다.
  1. 어떤 클래스를 작성할지 고민하기에 앞서 어떤 객체들이 필요한지 고민해야 한다.
     * **클래스는 특정 객체들이 공유하는 공통적인 상태와 행동을 추상화한 개념**에 지나지 않는다.
     * 클래스의 윤곽을 잡으려면 객체군이 어떤 상태와 행동을 갖는지를 우선 고려해야 하며, 이러한 객체 위주의 접근법은 설계 과정을 단순화 한다.
  2. **객체를 독립적인 존재가 아닌, 목표 기능을 구현하기 위해 상호작용하는 공동체의 일원으로 바라봐야 한다**.
     * 객체는 홀로 존재하지 않으며, 다른 객체를 돕거나 의존하는 협력적인 존재다.
     * **객체를 협력 가능한 공동체의 일원으로 보는 관점은 설계를 더욱 유연하고 확장성 있게 한다**.
* **상술한 과정을 통해 객체들의 윤곽이 드러나면 이를 토대로 공통된 특성과 상태를 갖는 객체 타입을 정의**할 수 있다.
  * 이렇게 정의된 타입을 기반으로 클래스를 작성한다.
```
> 훌륭한 협력은 훌륭한 객체를 낳고, 훌륭한 객체는 훌륭한 클래스를 낳는다.
```

### 도메인 구조를 반영하는 프로그램 구조
* **도메인이란, 문제를 해결하기 위해 사용자가 프로그램을 사용하는 분야를 가리키는 용어**이다.
  * 소프트웨어는 사용자의 어떤 문제를 해결하기 위해 만들어진다.
* 객체지향 패러다임은 요구사항을 분석하는 초기부터 프로그램을 구현하는 마무리까지 객체라는 동일한 추상화 기법을 적용할 수 있기에 강력하다.
  * **이 과정에서 요구사항과 프로그램은 객체라는 동일한 관점을 적용**할 수 있다.
  * 때문에 도메인을 구성하는 개념은 프로그램의 객체와 클래스 구조로 매끄럽게 연결될 수 있다.
```
> 객체지향 패러다임은 도메인을 구성하는 요소들의 개념과 관계를 적절히 정의하는 것이 클래스 구조에 그대로 반영할 수 있기 때문에 강력하다.
```

### 클래스의 구현
* 도메인 개념들의 구조를 반영하는 클래스 구조가 설계되었다면, 적절한 프로그래밍 언어를 활용하여 이 구조를 실제로 구현해야 한다.
* **클래스를 구현하거나, 다른 개발자가 개발한 클래스를 사용할 때 가장 중요한 것은 클래스의 경계를 구분짓는 것**이다.
  * Java의 경우, 일반적으로 접근 제어자를 통해 경계를 구분한다.
  * **클래스는 내부와 외부를 구분하며, 훌륭한 클래스를 설계하는 핵심은 외부에 공개할 부분과 내부로 감출 부분을 결정하는 것**이다.
  * 잘 설계된 클래스는 객체의 속성을 내부로 감추고, 메소드를 활용해서만 상태를 변경할 수 있도록 해야한다.
```
> 내부와 외부로 경계가 명확히 구분된 클래스의 객체는 자율성이 보장되고, 개발자에게는 구현의 자유가 제공된다.
```

### 자율적인 객체
* 객체는 다음과 같은 중요한 특징을 갖는다.
  1. 객체는 상태와 행동을 함께 갖는 복합적인 존재이다.
  2. 객체는 스스로 판단하고 행동할 수 있는 자율적인 존재이다.
* 일반적으로 **객체는 상태와 행동을 함께 포함하는 단위로 정의되며, 이렇듯 데이터와 기능을 하나의 객체 내부로 묶어두는 것을 캡슐화라고 한다**.
* 대부분의 **객체지향 언어는 상태와 행동을 캡슐화하는 것에서 한 발 더 나아가, 이들에 대한 접근을 통제하는 접근 제어 기능을 제공**한다.
  * 캡슐화된 객체의 구성 요소에 접근을 제어하는 이유는 객체를 자율적인 존재로 만들기 위함이다.
* **객체지향의 핵심은 객체들이 스스로 상태를 관리하고, 상태에 따라 판단하고, 판단에 따라 행동할 수 있는 자율적인 객체들의 공동체를 구성하는 것**이다.
  * 객체가 자율적인 존재로 거듭나기 위해 외부는 객체 내부에 간섭하지 않아야 하므로, 객체가 어떻게 동작하는지 알 필요도 없다.
  * 때문에 **객체의 결정에 외부로부터 개입하는 것보다 객체가 스스로 최선의 결정을 내릴 수 있다고 믿고 기다리는 것이 이상적**이다.
* 객체지향 언어 차원에서 지원되는 캡슐화와 접근제어 기능은 객체를 다음과 같은 두 부분으로 나눈다.
  1. 외부에서 접근 가능한 퍼블릭 인터페이스
  2. 외부에서 접근이 불가능하고, 내부에서만 접근이 가능한 내부 구현
* 이러한 **인터페이스와 구현의 분리 원칙은 훌륭한 객체지향 프로그램을 만들기 위해 반드시 준수해야하는 핵심 원칙**이다.
  * 이 때, public으로 지정된 메소드만 퍼블릭 인터페이스로 취급한다.
  * Java 인터페이스의 메소드가 기본적으로 public인 이유에 해당할 듯하다!
* 일반적으로 객체의 상태는 내부로 숨기고, 객체가 수행할 수 있는 기능인 행동은 외부에 공개해야 한다.

### 프로그래머의 자유
* 프로그래머의 역할은 크게 다음과 같이 나눌 수 있다.
  1. 새로운 데이터 타입을 정의하는 클래스 작성자
  2. 여러 데이터 타입을 활용하여 애플리케이션을 구축해나가는 클라이언트 프로그래머
* 클래스 작성자는 클래이언트 프로그래머에게 필요한 부분만 공개하고, 나머지는 내부로 숨겨야 한다.
  * 이를 구현 은닉이라고 하며, 인터페이스가 변경되지 않는 이상 클라이언트 프로그래머에게 끼칠 영향을 걱정하지 않고 내부 구현을 변경할 수 있다.
* 구현 은닉은 다음과 같은 이유에서 모든 개발자에게 유용하다.
  1. 클라이언트 프로그래머는 인터페이스만 알아두면 되므로, 내부 구현을 알 필요조차 없다.
  2. 클래스 작성자는 인터페이스가 변경되지 않는 이상 외부 영향을 걱정하지 않고 내부 로직을 자유롭게 변경할 수 있다.
* **상술한 이유에서, 클래스를 개발하는 개발자는 인터페이스와 구현을 깔끔하고 명확하게 분리하기 위해 충분한 노력을 기울여야 한다**.
* **설계는 변경을 관리하기 위해 필요하며, 객체지향 언어는 객체간 의존성을 적절히 관리함으로써 변경의 영향 범위를 제어할 수 있는 다양한 기능을 제공**한다.
  * 객체의 변경을 관리하기 위해 제공되는 기법 중 대표적인 것이 접근 제어이다.

### 협력하는 객체의 공동체
* 객체지향의 장점은 객체를 이용하여 도메인의 의미를 풍부하게 표현할 수 있다는 점이다.
* 개념의 **의미를 명시적이고 분명하게 표현할 수 있다면, 해당 개념이 단 하나의 인스턴스 변수만 갖더라도 객체를 사용하여 구현하는 것이 이상적**이다.
  * 이렇듯 개념을 보다 명시적으로 표현하기 위해 노력하는 것은 전체적인 설계의 명확성과 유연성을 높이는 첫걸음이다.
* **객체지향 프로그램을 작성하는 경우, 우선 협력의 관점에서 어떤 객체가 필요할지 결정**한다.
  * 그 후 공통되는 상태와 행위를 구현하기 위한 클래스를 작성하도록 한다.

### 협력과 메시지
* 협력이란, 프로그램에서 어떠한 기능을 구현하기 위해 객체들 간에서 발생하는 상호작용 전반을 일컫는다.
  * 객체는 다른 객체의 인터페이스를 통해 임의의 행동을 수행하도록 요청할 수 있다.
  * 요청을 받은 객체는 자율적인 방법으로 요청을 적절히 처리한 후에 응답한다.
* **객체가 다른 객체와 상호작용할 수 있는 유일한 방법은 메시지를 전송하는 것**이다.
  * 이 때, 메시지를 전달받은 객체는 메시지를 수신했다고 표현할 수 있다.
* 메시지를 수신한 객체는 스스로 내린 결정에 따라 메시지를 처리할 방법을 결정한다.
  * 이렇듯 수신한 메시지를 처리하기 위한 자신만의 방법을 메소드라고 한다.
* 메시지와 메소드는 명확히 구분해야 하며, 이는 객체지향 패러다임의 확장성과 유연성, 유용성을 든든히 뒷받침하는 개념 중 하나이다.
  * 예를 들어, 다형성은 메시지와 메소드를 구분하는 것에서부터 시작한 개념이다.
* 메시지를 전송하는 객체는 수신 객체가 해당 메시지를 처리해줄 수 있다고 믿고 메시지를 전달한다.
* 메시지는 수신하는 객체는 메시지에 따라 자신만의 적절한 메소드를 선택하여 처리한다.
```
> 메시지를 처리하는 방법을 결정하는 것은 메시지를 수신한 객체의 문제이다.
```

### 컴파일 시점 의존성과 런타임 시점 의존성
* 다형성에 의해 코드의 의존성과 실행 시점의 의존성은 다를 수 있다.
  * 즉, 클래스 간 의존성과 객체 간 의존성은 다를 수 있다.
* **코드의 의존성과 실행 시점의 의존성이 다를수록 코드의 유연성과 확장성은 커지지만, 코드를 이해하기는 어려워진다**.
* **다시 말해 설계가 유연해질수록 코드의 가독성과 디버깅 난이도는 높아진다**. 
  * 훌륭한 객체지향 개발자가 되기 위해서는 언제나 유연성과 가독성 사이에서 고민해야 한다.

### 차이에 의한 프로그래밍
* 임의의 클래스를 하나 추가하려고 하는데, 해당 클래스와 유사한 기존의 클래스가 이미 존재하는 경우가 있을 수 있다.
* 이 경우 가장 좋은 방법은 해당 클래스의 코드를 수정하지 않고 재사용하는 것이며, 상속은 이를 가능케하는 기능이다.
  * **상속은 객체지향에서 코드를 재사용하기 위해 널리 사용되는 방법이며, 기존 클래스를 기반으로 새로운 클래스를 쉽고 빠르게 추가할 수 있게 한다**.
* 이렇듯 **부모 클래스와 다른 부분만을 추가하여 새로운 클래스를 쉽고 빠르게 작성하는 방법을 차이에 의한 프로그래밍이라고도 한다**.

### 상속과 인터페이스
* **상속은 메소드나 인스턴스 변수의 재사용이 모든 목적을 대변하지 않으며, 오히려 부모가 제공하는 인터페이스를 자식이 상속받을 수 있는 점이 중요**하다.
* 인터페이스는 해당 객체가 이해할 수 있는 메시지의 목록을 정의하는 것이며, 자식 클래스는 상속을 통해 부모의 모든 인터페이스를 포함하게 된다.
* **외부 객체의 관점에서, 부모의 인터페이스는 자식에게도 적용되므로 둘을 동일한 타입으로 간주할 수 있게 된다**.
  * 외부 객체의 입장에서 실제로 자신과 소통하는 객체의 타입이 무엇인지는 중요하지 않다.
  * 오히려 **대상 객체가 자신이 전달하는 메시지를 수신할 수 있다는 사실만이 중요**하다.
* 업캐스팅은 이처럼 자식 클래스가 부모 클래스를 대신하는 것을 말한다.
* 상속은 다시 다음의 두 종류로 나눌 수 있다.
  1. 구현 상속: 코드를 재사용하기 위한 목적으로 사용하는 상속
  2. 인터페이스 상속: 부모와 자식이 공통의 인터페이스를 공유하기 위해 사용하는 상속
* **상속은 구현 상속보다 인터페이스 상속을 위해서만 사용되어야 한다**.
  * **일반적으로 상속은 코드 재사용이 주된 목적이라는 오해가 있지만, 이에 해당하는 구현 상속은 변경에 취약한 코드를 낳을 확률이 높다**.

### 다형성
* 메시지를 전달하는 객체가 동일한 메시지를 전송하지만, 실제로 어떤 메소드가 실행되는지는 메시지를 수신하는 객체의 클래스에 따라 달라진다.
  * 이렇듯 **동일한 메시지를 수신했을 때 수신 객체의 타입에 따라 다르게 응답할 수 있는 특징을 다형성이라고 한다**.
  * 다형적인 협력에 참여하는 모든 수신 객체는 같은 메시지를 이해할 수 있어야 하므로, 동일한 인터페이스를 제공해야 한다.
* 다형성은 객체지향 프로그래밍에서 컴파일 시간의 의존성과 실행 시간의 의존성이 다를 수 있다는 사실을 기반으로 하는 개념이다.
* 객체지향이 컴파일 시점의 의존성과 실행 시점의 의존성을 분리하고, 동일한 메시디를 선택적으로 다른 메소드에 연결할 수 있는 이유는 지연 바인딩 덕분이다.
  * **동적 바인딩이란, 메시지와 메소드를 실행 시점에 바인딩하여 실행될 메소드를 실행 시점에 결정하는 특징**이다.
  * 반면 정적 바인딩에서는 컴파일 시점에 실행될 함수가 결정된다.
* **다형성은 상속과 함께 언급되곤 하지만, 클래스를 상속받는 것만이 다형성을 구현하는 유일한 방법은 아니다**.

### 인터페이스와 다형성
* 구현은 공유할 필요가 없고 순수하게 인터페이스만 공유하고 싶은 경우, 인터페이스를 활용하여 다형성을 구현할 수 있다.
* 동일한 인터페이스를 구현하는 클래스들은 같은 인터페이스를 공유하는 특징으로 인해 다형적인 협력에 참여할 수 있다.

### 추상화의 힘
* **프로그래밍 언어 측면에서 추상 클래스 또는 인터페이스가 추상적이라고 말할 수 있는 이유는 인터페이스에 초점을 맞추기 때문**이다.
  * 이들은 **같은 계층에 속하는 클래스들이 공통으로 가질 수 있는 인터페이스를 정의하고, 구현의 일부 또는 전체의 결정은 자식에게 위임**한다.
* 추상화는 다음과 같은 장점을 갖는다.
  1. 추상화의 계층만 따로 볼 경우, 요구사항의 정책을 높은 수준에서 서술할 수 있다.
  2. 추상화를 적용할 경우 설계는 더 유연해진다.
* **추상화를 사용하면 세부적인 내용은 무시하고 상위 정책을 쉽게 표현할 수 있다**.
  * 추상화를 이용한 설계는 필요에 따라 표현 수준을 조정할 수 있게 한다.
* **추상화를 이용하면 기존 코드를 수정하지 않고도 기능을 확장할 수 있으므로, 유연성이 필요한 곳에는 추상화가 적용되어야 한다**.

### 코드의 재사용
* 상속은 코드를 재사용하기 위해 널리 사용되는 방법이지만, 이것이 좋은 방법이라는 의미는 아니다.
  * 코드 재사용 측면에서는 상속보다는 합성이 더 좋은 방법이다.
* **합성이란, 코드를 재사용하려는 다른 객체의 인스턴스를 자신의 인스턴스 변수로 포함하여 재사용하는 방식**이다.

### 상속의 단점
* 상속은 코드를 재사용하기 위해 널리 사용되는 방법이지만, 다음과 같은 큰 단점을 갖는다.
  1. 상속은 캡슐화를 위반한다.
  2. 상속은 설계의 유연성을 잃게 만든다.
* **상속을 이용하려면 부모 클래스의 내부 구조를 잘 알고 있어야 하므로, 캡슐화가 위반된다**.
  * 이로 인해 부모 클래스의 구현은 자식 클래스에게 노출되고, 둘이 강하게 결합되게 한다.
  * 따라서 상속을 활용한 코드는 부모의 변경이 자식에게 전파되기 쉽고, 결과 변경하기 어려워진다.
* **상속은 설계를 유연하지 못하게 하며, 이는 부모 클래스와 자식 클래스의 관계가 컴파일 시점에 결정되기 때문**이다.
  * 상속을 사용하는 객체는 실행 시점에 종류를 변경하는 것이 불가능하다.
  * 합성을 사용하는 경우, 런타임에서 새로운 인스턴스를 만들어 넘겨주는 것으로 간단하게 종류를 변경하도록 할 수 있으므로 유연하다.

### 합성
* **합성은 인터페이스에 정의된 메시지를 통해서만 코드를 재사용하는 방식**이며, 합성을 사용하는 코드는 인터페이스를 통해 약하게 결합된다.
* 합성은 상속의 두 가지 문제를 모두 해결한다.
  1. 인터페이스에 정의된 메시지를 통해서만 코드를 재사용하므로, 구현은 캡슐화된다.
  2. 의존하는 인스턴스를 비교적 쉽게 교체할 수 있으므로, 설계를 유연하게 한다.
* 코드 재사용 측면에서는 상속보다 합성이 좋지만, 상속을 절대 사용하지 말아야하는 것은 아니다.
  * 오히려 대부분의 설계에서는 상속과 합성을 함께 사용해야 한다.
* 일반적으로 객체지향 프로그래밍은 클래스에 상태와 메소드를 채워넣고, 상속을 통해 재사용하는 방법으로만 여겨지곤 한다.
  * 프로그래밍에서 상속과 클래스는 중요하지만, 너무 프로그래밍 관점에 치우치면 객체지향의 본질을 놓치기 쉽다.
  * 객체지향의 본질은 객체를 지향하는 것이므로, 객체를 떼어놓고 생각하는 것은 완전히 무의미하다.
* 객체지향에서 가장 중요한 것은 애플리케이션의 기능을 구현하기 위해 협력에 참여하는 객체들의 상호작용이다.
  * 객체들은 협력을 위해 역할을 부여받고, 역할에 맞는 책임을 수행한다.
* **객체지향 설계의 핵심은 적절한 협력으로 분리하고, 협력에 필요한 역할을 정의하고, 역할을 수행할 수 있는 적절한 객체에게 적절한 책임을 할당하는 것**이다.
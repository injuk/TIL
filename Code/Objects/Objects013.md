# Objects
## 2022-04-06 Wed

## 서브클래싱과 서브타이핑
* 앞서 다룬 바와 같이, 상속은 크게 다음과 같은 두 용도로 사용된다.
  1. 타입 계층의 구현
  2. 코드의 재사용
* 타입 계층 안에서 부모 클래스는 일반적인 개념을 구현하고, 자식 클래스는 특수한 개념을 구현한다.
  * 즉, **상위 클래스는 하위 클래스의 일반화된 개념을 표현**한다.
* 코드 재사용 측면에서, 상속은 간단한 선언만으로 부모 클래스의 코드를 재사용할 수 있도록 하지만 너무 강하게 결합되는 부작용을 수반한다.
* **상속을 사용하는 기본적인 목표는 코드의 재사용이 아닌 타입 계층의 구현**이어야만 한다.
  * 코드 재사용을 목적으로 사용된 상속은 부모 클래스와 자식 클래스를 강하게 결합시켜 설계의 변경과 확장을 방해한다.
  * 반면 **타입 계층을 목적으로 사용된 상속은 다형적으로 동작하는 객체 관계에 기반한 유연하고 확장성 있는 설계를 얻을 수 있게 한다**.
```
> 동일한 메시지에 서로 다르게 행동할 수 있는 다형적인 객체를 구현하기 위해, 객체의 행동을 기반으로 타입 계층을 구성해야 한다.
> 상속은 이를 위한 쉽고 편안한 방법을 제공한다는 점에 그 의의가 있다.
```

### 타입
* 타입의 의미를 이해하기 위해 개념 관점에서의 타입과 프로그래밍 언어 관점에서의 타입으로 이해할 수 있다. 
  1. 개념 관점에서의 타입: 우리가 인지하는 사물의 종류를 나타내는 개념이다.
  2. 프로그래밍 언어 관점의 타입: 비트에 의미와 제약을 부여하기 위해 사용되는 개념이다.

### 개념 관점에서의 타입
* 우리가 인지하는 사물의 종류가 개념 관점에서의 타입에 해당하며, 해당 타입으로 분류될 수 있는 대상을 인스턴스 또는 객체라고 한다.
* 개념 관점에서의 타입은 다시 다음의 세 개념으로 구성된다.
  1. 심볼: 타입에 붙인 이름.
  2. 내연: 타입의 정의로서, 타입에 속하는 객체들이 갖는 공통적인 속성이나 행동의 집합.
  3. 외연: 타입에 속하는 객체들의 집합.

### 프로그래밍 언어 관점의 타입
* 하드웨어는 데이터를 0과 1로 구성된 비트 스트림으로 취급하지만, 비트 자체에는 타입이라는 개념을 부여할 수 없다.
  * 따라서 특정 비트 스트림을 문자열로 취급할지, 정수로 취급할지 구분하는 것은 전적으로 애플리케이션에 의해 결정된다.
* 따라서 **프로그래밍 언어 관점에서의 타입이란, 이러한 비트 스트림에 의미를 부여하기 위해 정의된 제약과 규칙을 가리키는 용어**이다. 
* 프로그래밍 언어에서 타입은 다음과 같은 두 목적을 위해 사용된다.
  1. 타입에 수행될 수 있는 유효한 오퍼레이션 집합을 정의.
     * 모든 객체지향 언어는 객체의 타입에 따라 적용 가능한 연산자의 종류를 제한하는 것으로 개발자의 실수를 미연에 방지한다.
  2. 타입에 수행되는 오퍼레이션에 대해 미리 약속된 문맥을 제공.
     * Java의 + 연산자는 피연산자의 타입에 따라 달리 동작할 수 있다.
     * Java의 **new 연산자는 타입에 정의된 크기만큼의 공간을 할당하고 생성된 객체를 초기화하는 타입 생성자를 호출**한다.
```
> 타입은 적용 가능한 오퍼레이션의 종류와 의미를 정의하고, 코드의 의미를 명확하게 전달하여 개발자의 실수를 방지하기 위해 사용한다.
```

### 객체지향 패러다임 관점에서의 타입
```
> 개념 관점에서의 타입은 공통의 특징을 공유하는 대상들의 분류이다. 
> 프로그래밍 언어 관점에서는 동일한 오퍼레이션을 적용할 수 있는 인스턴스의 집합이다.
```
* 객체지향 프로그래밍에서, 오퍼레이션은 객체가 수신할 수 있는 메시지를 의미한다.
* 따라서 **객체의 타입이란 객체가 수신할 수 있는 메시지의 종류를 정의**하는 것이다.
  * 객체가 수신할 수 있는 메시지의 집합은 퍼블릭 인터페이스라는 용어로 부를 수 있다.
  * 즉, **객체지향 프로그래밍에서 타입을 정의하는 것은 객체의 퍼블릭 인터페이스를 정의하는 것**과 같다.
* 개념 관점에서의 **타입은 공통의 특성을 가진 객체들을 분류하는 기준**이다.
* 객체지향에서 **객체들이 갖는 공통의 특성은 객체가 수신할 수 있는 메시지이므로, 동일한 퍼블릭 인터페이스를 갖는 객체는 동일한 타입으로 분류**할 수 있다.
* 상술한 내용을 토대로 객체지향 프로그래밍 관점에서의 타입은 다음과 같이 정의할 수 있다.
```
> 객체의 퍼블릭 인터페이스가 객체의 타입을 결정한다.
> 동일한 퍼블릭 인터페이스를 제공하는 객체들은 동일한 타입으로 분류할 수 있다.
```
* 이는 즉 **앞서 다뤄온 바와 같이 객체에게 중요한 것은 속성이 아닌 행동임을 강조**한다.
  * 객체들이 동일한 상태를 갖더라도 퍼블릭 인터페이스가 다르다면 타입이 다른 것이다.
  * 반면 객체들의 상태가 제각각이더라도 퍼블릭 인터페이스가 같다면 같은 타입으로 분류된다.
```
> 객체의 타입을 결정하는 것은 내부의 속성이 아닌 외부에 제공하는 행동이므로, 객체를 바라볼 때에는 항상 객체가 외부에 제공하는 행동에 초점을 맞추어야 한다.
```

### 타입 간의 포함 관계
* 수학에서의 집합이 다른 집합을 포함할 수 있듯, 타입 역시 객체들의 집합이므로 다른 타입을 포함할 수 있다.
  * 타입에 포함되는 객체들을 상세한 기준으로 묶어 새로운 타입으로 정의할 경우, 새로운 타입은 자연스레 기존 타입의 부분집합이 된다.
  * 즉, **타입은 집합 관점에서 더 세분화된 타입의 집합을 부분집합으로 포함할 수 있다**.
  * 타입은 다른 타입에 포함될 수 있으므로, 동일한 인스턴스는 하나 이상의 타입으로 분류될 수 있다.
* **다른 타입을 포함하는 타입은 외연 관점에서는 더 크고, 내연 관점에서는 더 일반적**이다.
  * 반면, **다른 타입에게 포함되는 타입은 외연 관점에서 더 작고, 내연 관점에서는 더 특수하고 구체적**이다.
  * 이를 통해 포함 관계로 연결되는 타입 간에는 개념적으로 일반화와 특수화 관계가 존재한다는 사실을 알 수 있다.
* 타입 계층을 구성하는 두 타입 간의 관게는 다음과 같이 분류된다.
  1. 슈퍼타입: 타입 계층을 구성하는 두 타입 관계에서 더 일반적인 타입이다.
  2. 서브타입: 두 타입 관계에서 더 특수한 타입이다.
* 또한, 객체의 정의를 의미하는 내연 관점에서 일반화와 특수화는 다음과 같은 의미를 갖는다.
  1. **객체의 정의를 의미하는 내연 관점에서, 일반화란 임의의 타입의 정의를 더 보편적이고 추상적으로 만드는 과정**이다. 
  2. **반면, 특수화란 임의의 타입의 정의를 더 구체적이고 문맥에 종속적으로 만드는 과정**이다.
* 객체의 집합 자체를 의미하는 외연 관점에서, 슈퍼셋과 서브셋의 개념을 확인할 수 있다.
  1. **일반적인 타입의 인스턴스 집합은 더 특수하고 구체적인 타입의 인스턴스 집합을 포함하는 슈퍼셋**이다.
  2. 반면 **더 특수한 타입의 인스턴스 집합은 일반적인 타입의 인스턴스 집합에 포함되는 서브셋**이다.
  * 즉, **특수한 타입에 속하는 인스턴스는 동시에 더 일반적인 타입의 인스턴스이기도** 하다.
```
> 일반화는 다른 타입을 완전히 포함하거나 내포하는 타입을 식별하는 행위, 또는 식별된 결과 그 자체이다.
> 특수화는 다른 타입에 포함되거나 완전히 내포되는 타입을 식별하는 행위, 또는 식별된 결과 그 자체이다.
```

### 내연과 외연 관점에서의 서브타입과 슈퍼타입
* 서브타입은 다음과 같은 특징을 갖는 타입이다.
  1. 집합에 포함되는 인스턴스들은 조금 더 큰 집합에 포함된다.
  2. 타입 정의는 다른 타입보다 조금 더 구체적이다.
* 반면, 슈퍼타입은 다음과 같은 특징을 갖는다.
  1. 집합이 다른 집합의 모든 멤버를 포함한다.
  2. 타입 정의가 다른 타입에 비해 조금 더 일반적이다.

### 객체지향 프로그래밍과 타입 계층
* 객체의 타입을 결정하는 것은 퍼블릭 인터페이스다.
  * 즉, **일반적인 타입이란 비교하려는 타입에 속한 객체들의 퍼블릭 인터페이스보다 더 일반적인 퍼블릭 인터페이스를 갖는 객체들의 타입**이다.
  * 특수한 타입이란, 비교하려는 타입에 속한 객체들의 퍼블릭 인터페이스보다 더 특수한 퍼블릭 인터페이스를 갖는 객체들의 타입이다.
* 퍼블릭 인터페이스의 관점에서, 슈퍼타입과 서브타입은 다음과 같이 정의된다.
  1. 슈퍼타입이란, 서브타입이 정의한 퍼블릭 인터페이스를 일반화하여 상대적으로 범용적이고 넓은 의미로 정의한 것이다.
  2. 서브타입이란, 슈퍼타입이 정의한 퍼블릭 인터페이스를 특수화하여 상대적으로 구체적이고 좁은 의미로 정의한 것이다.
* 즉, **일반적인 타입과 구체적인 타입의 관계를 형성하는 기준은 퍼블릭 인터페이스**이다.
* 상술했듯, 서브타입의 인스턴스 집합은 슈퍼타입 인스턴스 집합의 부분집합이다.
  * 때문에 **더 특수한 퍼블릭 인터페이스를 갖는 객체들은 동시에 더 일반적인 퍼블릭 인터페이스를 갖는 객체들의 집합에 포함**된다.
```
> 서브타입의 인스턴스는 슈퍼타입의 인스턴스로 간주될 수 있으며, 이를 이해하는 것은 상속과 다형성을 이해하기 위한 출발점이다.
```

### 서브클래싱과 서브타이핑
* 객체지향 프로그래밍에서 타입을 구현하는 일반적인 방법은 클래스를 활용하는 것이며, 타입 계층을 구현하는 일반적인 방법은 상속을 이용하는 것이다.
* **상속을 이용하여 구현한 타입 계층은 부모 클래스가 슈퍼타입, 자식 클래스가 서브 타입의 역할을 수행하도록 클래스 간 관계를 정의하는 것**이다.
* 어떤 타입이 다른 타입이 서브타입이 되기 위해, 다음과 같은 두 조건을 모두 충족하는 경우에만 상속을 적용해야 한다.
  1. 상속 관계가 is - a 관계를 모델링해야 한다.
     * 일반적으로 **'자식 클래스는 부모 클래스이다'라고 해도 이상하지 않은 경우에만 상속을 사용할 것을 고려**한다.
  2. 클라이언트 입장에서 부모 클래스의 타입으로 자식 클래스를 사용해도 무방해야 한다.
     * **정의된 상속 계층을 활용하는 클라이언트 입장에서 부모 클래스와 자식 클래스의 차이를 알 수 없어야 한다**.
     * 이러한 특징을 부모와 자식 클래스의 행동 호환성이라고 한다.
* 설계 관점에서 상속의 적용 여부를 결정하려면, 상술한 두 조건 중 두번째 질문에 더 초점을 맞추어야 한다.
  * **클라이언트 관점에서 각 클래스에 기대하는 행동이 다른 경우, 어휘적으로 is a 관계를 만족하더라도 상속을 적용하지 않아야 한다**.

### is - a 관계
* **두 클래스가 어휘적으로 is - a 관계를 모델링하는 경우에만 상속을 사용할 수 있어야 하지만, 이 관계가 언제나 직관직어고 명쾌하지는 않다**.
```
> 펭귄은 새이다.
> 새는 날 수 있다.
```
* 상술한 예시는 어휘적인 정의보다는 행동에 초점을 맞추어 타입 계층을 구성해야 한다는 사실을 보여준다.
  * 어휘적으로 펭귄은 새가 맞지만, 펭귄은 날 수 없으므로 새의 서브타입이 될 수는 없다.
  * 그러나 요구사항이 나는 행동을 필요로 허지 않는 경우에는 서브타입이 될 수 있다.
* 이렇듯 **타입 계층의 의미는 행동이라는 문맥에 따라 달라질 수 있다**.
* 슈퍼타입과 서브타입 관계에서는 is - a 관계보다 행동 호환성이 더 중요하다.
* 어떤 **두 대상을 is - a 관계로 표현할 수 있더라도 우선은 상속을 적용할 수 있는 후보로만 생각하는 것이 바람직**하다.
  * 애플리케이션 내부에 위치한 두 개념이 어떤 방식으로 사용되고, 협력하는지 이해한 후에 상속을 결정해도 전혀 늦지 않다.
  * 즉, **너무 성급하게 상속을 결정하지 않아도 무방**하다.

### 행동 호환성
* 펭귄이 새가 아니라는 사실을 받아들이기 위한 **출발점은 타입이 행동과 관련이 있다는 사실에 주목하는 것**이다.
  * 타입 간의 이름에 연관성이 있더라도, 행동에 연관성이 없다면 is - a 관계를 사용하지 않아야 한다.
  * **새와 펭귄의 서로 다른 행동 양식은 둘을 동일한 타입 계층으로 묶지 않아야 한다는 점을 강하게 경고하며, 이 경고에 귀 기울일 수 있어야 한다**.
* 반드시 **두 타입 사이에서 행동이 호환될 수 있는 경우에만 타입 계층으로 묶어야 한다**.
* 이 때, **행동의 호환 여부를 판단하는 기준은 언제나 클라이언트의 관점**이 되어야 한다.
  * **클라이언트가 두 타입이 동일하게 행동할 것이라고 기대한다면 두 타입을 동일한 타입 계층으로 묶을 수 있다**.
  * 반면 클라이언트가 보기에 두 타입이 동일하게 행동하지 않을 것이라고 기대된다면 두 타입은 동일 타입 계층으로 묶지 않아야 한다.
* 예를 들어 클라이언트의 관점에서 판단할 때, 새는 모두 날 수 있을 것이라고 기대될 것이므로 펭귄은 새의 서브타입이 될 수 없다.
  * 이는 **단순히 is - a 관계를 만족하는 것이 두 타입이 올바른 타입 계층을 구성하지는 않는다는 사실**을 보여준다.
  * **중요한 것은 클라이언트의 기대이며, 타입 계층을 이해하기 위해서는 반드시 타입 계층이 사용될 문맥을 이해**해야 한다.

### 끼워 맞추는 상속
* 그러나 **대부분의 개발자는 펭귄이 새이며, is - a 관계를 만족한다는 사실에 현혹되어 상속 계층에 끼워 맞출 수 있는 다음과 같은 방법을 찾곤 한다**.
  1. fly 메소드를 오버라이딩한 후 내부 구현을 비워둔다.
  2. fly 메소드를 오버라이딩한 후, 호출된 경우에 UnsupportedOperationException 예외를 던진다.
  3. fly 메소드를 사용하는 클라이언트 메소드에서 instanceof 연산자를 활용하여 펭귄이 아닌 경우에만 fly 메소드를 호출한다.
* 그러나 세 방식은 모두 새와 펭귄의 행동 호환성을 지키지 않으므로 바람직한 대처 방법으로 볼 수 없다.
* 심지어 세 번째 방식의 경우, **new 연산자와 마찬가지로 구체적인 클래스에 대해 결합도를 높이는 instanceof 연산자를 사용**하고 있다.
  * 이 방식은 도도새, 키위새 등 행동이 호환되지 않는 새로운 객체가 추가될 때마다 if - else 분기를 늘리게 되므로 결합도를 높인다.
  * **일반적으로 instanceof 연산자와 같이 객체의 타입을 확인하는 코드는 새로운 타입을 추가할 때마다 분기를 추가해야하므로 개방 폐쇄 원칙을 위반**한다.

### 클라이언트의 기대에 부응하기
* 상술했듯, 행동 호환성을 만족시키지 않는 대상들의 상속 계층을 그대로 유지하면서 클라이언트의 기대를 충족시킬 방법은 매우 찾기 어렵다.
* **해당 문제를 해결하는 방법은 클라이언트의 기대에 맞을 수 있도록 상속 계층을 분리하는 것**이다.
  * 펭귄의 예로 들어, 클라이언트는 날 수 있는 새 타입과 날 수 없는 새 타입을 기대할 수 있을 것이라고 예상할 수 있다.
  * 이러한 **클라이언트의 기대에 부응할 수 있도록 상속 계층을 두 분류로 나누어 문제를 해결**할 수 있다.
* 또 다른 **문제 해결 방법으로, 클라이언트에 따라 인터페이스를 분리하여 해결**할 수 있다.
  * 예를 들어, 새에 대해 클라이언트가 기대하는 바가 걷기와 날기라면 두 가지 인터페이스를 분리할 수 있다.
  * 이렇듯 **인터페이스는 클라이언트가 기대하는 바에 따라 분리되어야 한다**.
* **인터페이스를 활용한 분리에서, 만약 새 클래스의 코드를 펭귄 클래스가 일부 재사용해야 하는 경우에는 합성을 활용**한다.
  * 이 경우, 새 클래스의 퍼블릭 인터페이스를 활용한 코드의 재사용이 가능하다는 사실이 전제되어야 한다.
  * 이 과정에서 새 클래스를 수정해야하는 경우도 있을 수 있지만, 대부분의 경우에 불안정한 상속 계층을 유지하는 것보다 새의 재사용성을 높이는 것이 더 좋다.
* **대부분의 경우 인터페이스는 클라이언트의 요구사항이 변경될 때 함께 수정**된다.
  * 따라서, 클라이언트에 따라 인터페이스를 분리하는 것으로 각 클라이언트의 요구가 변경되더라도 영향 범위를 제어할 수 있다.
* 이와 같이 **인터페이스를 클라이언트의 기대에 맞추어 분리함으로써 변경에 의한 영향을 제어하는 설계 원칙은 인터페이스 분리 원칙**에 해당한다.
  * **인터페이스 분리 원칙에 따라, 클라이언트는 항상 자신이 사용하는 메소드에만 의존할 수 있도록 인터페이스를 분리**해야 한다.
  * 이를 통해 호출하지 않는 메소드에 대한 클라이언트 의존성을 제거하고, 클라이언트가 서로에게 독립적이 되도록 할 수 있다.

### 현실을 반영하지 않는 설계
* 앞서 다룬 변경 후의 설계는 날 수 있는 새와 날 수 없는 새로 구분되어 현실 세계를 반영한다.
* **그러나 반드시 설계가 현실을 반영해야 할 필요는 없다는 사실을 기억**해야 한다
  * **중요한 것은 설계가 반영할 도메인의 요구사항이며, 그 안에서 클라이언트가 객체에게 요구하는 행동**이다.
* 요구사항이 날 수 있는 행동에 관심이 없는 경우, 상속 계층에 날 수 있는 새를 추가하는 것은 설계의 복잡성을 불필요하게 늘리는 일에 해당한다.
* 따라서 **설계는 현실을 정확하게 묘사하는 것보다 요구사항을 실용적으로 수용하는 것을 목표**로 해야 한다.
```
> 자연어에 현혹되지 말고 요구사항 속에서 클라이언트가 기대하는 행동에 집중해야만 한다.
> 클래스의 이름 사이의 연관성은 아무런 의미도 없으며, 두 클래스 사이의 행동이 호환되지 않는다면 올바른 타입 계층이 아니므로 상속을 적용하지 않아야 한다.
```

### 서브클래싱, 서브타이핑
* 앞서 다룬 바와 같이 상속은 코드 재사용과 타입 계층의 구성이라는 두 가지 목적으로 사용되며, 서브클래싱과 서브타이핑은 각 목적에 대해 붙여진 명칭이다.
  1. 서브클래싱: 다른 클래스의 코드를 재사용할 목적으로 사용된 상속이며, 이 경우 자식 클래스는 부모 클래스를 대체할 수 없다.
  2. 서브타이핑: 타입 계층을 구성하기 위해 사용된 상속이며, 이 경우 자식 클래스는 부모 클래스를 대체할 수 있는 서브타입이다. 
* 서브클래싱은 구현을 재사용하기 위한 목적을 갖기에 구현 상속, 클래스 상속이라고도 부를 수 있다.
  * 반면, 서브타이핑은 인터페이스 상속이라는 용어로 부를 수 있다.
* 클래스 상속에 해당하는 **서브클래싱은 객체의 구현을 정의할 때 이미 정의되어 있는 객체의 구현을 바탕으로 코드를 공유**한다.
  * 앞서 다룬 **나쁜 설계의 예시에 해당하는 대부분의 상속은 구현을 재사용하기 위해 사용된 서브클래싱에 해당**한다.
* 반면 **서브타이핑은 인터페이스 상속으로서 객체가 다른 곳에서 사용될 수 있음을 의미**한다.

### 서브타이핑 관계의 유지
* 슈퍼타입과 서브타입 사이에서 가장 중요한 것은 퍼블릭 인터페이스이다.
* **슈퍼타입 인스턴스를 요구하는 모든 곳에서 서브타입으로 대체할 수 있도록, 서브타입 퍼블릭 인터페이스는 슈퍼타입 이상의 오퍼레이션을 포함해야 한다**.
  * 이 경우, 개념적으로 서브타입이 슈퍼타입의 퍼블릭 인터페이스를 상속받는 것처럼 보인다.
* **서브타이핑 관계가 유지되려면 서브타입이 슈퍼타입의 모든 행동을 동일하게 할 수 있도록 행동 호환성을 만족해야** 한다.
* 자식 클래스가 부모 클래스를 대체할 수 있으려면, 부모 클래스가 사용되는 모든 문맥에서 자식 클래스가 동일하게 행동할 수 있어야 한다.
* 또한 **행동 호환성을 만족하는 상속 관계는 부모 클래스를 새로운 자식 클래스로 대체하더라도 시스템의 정상 동작을 보장해야** 한다.
* 즉, **자식 클래스와 부모 클래스 사이의 행동 호환성은 부모 클래스에 대한 자식 클래스로의 대체 가능성을 포함**한다.
* 이러한 행동 호환성과 대체 가능성은 올바른 상속 관계를 구축하기 위해 따라야할 기본적인 지침이며, 리스코프 치환 원칙이라고도 부를 수 있다.

### 리스코프 치환 원칙
* 상속 관계로 연결한 두 클래스가 서브타이핑 관계를 만족시키려면 다음의 조건을 만족시켜야 한다.
  1. 서브타입은 기반 타입에 대해 대체 가능해야 한다.
  2. 클라이언트는 차이점을 인지하지 못한 상태에서 기반 클래스의 인터페이스로 서브클래스를 사용할 수 있어야 한다.
* 이러한 원칙은 올바른 상속 관계의 특징을 정의하는 리스코프 치환 원칙에 해당하며, 행동 호환성을 설계 원칙으로 정립한 경우에 해당한다.
* **리스코프 치환 원칙에 따르면, 자식 클래스가 부모 클래스와의 행동 호환성을 유지함으로써 부모를 대체할 수 있도록 구현된 상속 관계만이 서브타이핑**이다.
  * 예를 들어, Stack 클래스는 클라이언트가 Vector에 기대하는 행동을 제공하지 않으므로 리스코프 치환 원칙을 위배한다.
```
> 두 클래스가 리스코프 치환 원칙을 위배하는 경우 서브타이핑 관계가 아닌 서브클래싱 관계이다.
> 언제나 중요한 것은 클라이언트 관점에서 두 클래스 간의 행동 호환성 여부이며, 행동 호환성이 보장된느 경우에만 자식 클래스는 부모 클래스를 대체할 수 있다.
```

## 2022-04-07 Thu
### 클라이언트와 대체 가능성
* **리스코프 치환 원칙은 자식 클래스가 부모 클래스를 대체하기 위해서는 부모 클래스에 대한 클라이언트 관점에서의 가정을 준수해야한다는 점을 강조**한다.
* Stack과 Vector의 관계가 서브타이핑이 아닌 서브클래싱인 이유도 여기에 있으며, 클라이언트가 Vector에 기대하는 행동은 Stack과 호환되지 않는다.
  * 이는 상속으로 인해 Stack에 포함되지 않아야하는 Vector의 퍼블릭 인터페이스가 포함되었기 때문이다.
  * **서브타이핑을 만족하기 위해서는 자식 클래스가 제공하는 퍼블릭 인터페이스의 오퍼레이션 개수는 부모 클래스와 동일하거나 더 많아야 한다**.
* 이에 따라, **리스코프 치환 원칙은 클라이언트를 고려하지 않은 채로 보는 모델은 충분히 검증할 수 없다는 결론을 이끌어낸다**.
  * **상속 관계는 클라이언트의 관점에서 자식 클래스가 부모 클래스를 대체할 수 있을 때에만 올바르다**.
```
> 부모 클래스에 대한 자식 클래스의 대체 가능성을 결정하는 것은 언제나 클라이언트이다.
```

### is - a 관계 II
* 클라이언트 관점에서 자식 클래스의 행동이 부모 클래스의 행동과 호환되지 않아 대체가 불가능하다면, 이는 진정한 의미의 is - a 관계로 볼 수 없다.
  * is - a 관계는 클라이언트 입장에서도 is - a 관계를 유지할 때에만 참이다.
  * is - a 관계를 충족시키는지 판단하는 경우, 항상 '클라이언트의 입장에서 is - a 관계를 충족하는가'로 생각해야 한다.
* **is - a 관계는 객체지향에서 중요한 것이 객체의 속성보다는 객체의 행동이라는 점을 강조**한다. 
  * **클라이언트를 고려하지 않은 상태에서 개념과 속성의 측면에서 상속 관계를 정의할 경우, 리스코프 치환 원칙을 위배하는 서브클래싱이 될 확률이 높다**.
* is - a 관계는 또한 적절한 명명을 요구하는 것으로 생각할 수 있다.
  * 예를 들어, **슈퍼타입과 서브타입의 행동이 클라이언트 관점에서도 호환된다면 두 타입은 is - a 관계를 만족하도록 명명해야 한다**.
* 결론적으로, **상속은 서브타이핑을 위해 사용될 경우에만 is - a 관계**이다.
```
> 다른 객체지향 원칙이 그렇듯, is - a 관계에서도 중요한 것은 이름보다 행동이다.
```

### 유연한 설계를 뒷받침하는 리스코프 치환 원칙
* **리스코프 치환 원칙은 클라이언트가 어떠한 자식 클래스와도 협력할 수 있는 상속 구조를 구현하는 가이드를 제공**한다.
  * 새로운 자식 클래스를 추가하더라도 클라이언트 입장에서 동일하게 행동한다면, 클라이언트의 수정 없이 상속 계층을 확장할 수 있다.
  * 즉, **리스코프 치환 원칙을 따르는 설계는 유연성 뿐만 아니라 확장성 또한 높다**.
* 이렇듯 리스코프 치환 원칙은 개방 폐쇄 원칙을 지원하도록 돕는다.
  * **자식 클래스가 클라이언트 관점에서 부모 클래스를 대체할 수 있다면, 기능 확장을 위해 자식 클래스를 새로 추가하더라도 코드를 수정할 필요가 없다**.
  * 다시 말해, **리스코프 치환 원칙은 개방 폐쇄 원칙을 만족시키기 위한 전제 조건**이다.
* 일반적으로, 리스코프 치환 원칙을 위배하는 것은 잠재적으로 개방 폐쇄 원칙 역시 위배한다.
```
> 핵심은 클라이언트 관점에서 슈퍼타입에 대해 기대하는 모든 것이 서브타입에도 적용되어야 한다는 사실이다.
```

### 계약에 의한 설계와 서브타이핑
* 계약에 의한 설계란, 클라이언트와 서버 사이의 협력을 의무와 이익으로 구성되는 계약 관점으로 표현하는 것이다.
* 계약에 의한 설계는 다음과 같은 요소로 구성된다.
  1. 사전조건: **클라이언트가 정상적으로 메소드를 실행하기 위해 만족해야 하는 조건**이다.
  2. 사후조건: 메소드가 실행된 후 **서버가 클라이언트에게 보장하는 조건**이다.
  3. 클래스 불변식: 메소드 실행 전과 실행 후 **인스턴스가 만족해야하는 조건**이다.
* 계약에 의한 설계 관점에서 협력하는 클라이언트와 슈퍼타입 인스턴스 사이의 관계를 계약으로 보며, 계약을 준수하는 경우에만 협력할 수 있다.
* 리스코프 치환 원칙은 서브타입으로 인정받기 위해 슈퍼타입 인스턴스가 서브타입으로 대체되더라도 클라이언트 관점에서 협력에 지장이 없어야 한다는 것을 의미한다.
* 둘을 조합할 경우, 서브타입이 슈퍼타입처럼 보일 수 있는 서브타이핑을 위해서는 클라이언트가 슈퍼타입과 맺은 계약을 서브타입도 준수해야 하는 것으로 귀결된다.
```
> 계약에 의한 설계는 클라이언트 관점에서 대체 가능성을 계약으로 설명할 수 있다는 사실을 보여준다.
> 서브타이핑을 위해 상속을 사용하는 경우, 부모 클래스가 클라이언트와 맺는 제약에 관해 깊이 있게 고민해볼 필요가 있다.
```

### 서브타입과 계약
* 계약 관점에서 상속이 초래하는 가장 큰 문제점은 자식 클래스가 부모 클래스의 메소드를 오버라이딩할 수 있다는 점이다.
* 계약에 의한 설계의 관점에서 자식 클래스가 부모 클래스의 서브 타입이 될 수 있도록, 다음의 조건을 만족해야 한다.
  1. 서브타입에 더 강력한 사전 조건은 정의할 수 없다.
  2. 서브타입에 슈퍼타입과 같거나 더 약한 사전 조건은 정의할 수 있다.
  3. 서브타입에 슈퍼타입과 같거나 더 강한 사후 조건은 정의할 수 없다.
  4. 서브타입에 더 약한 사후 조건은 정의할 수 없다.
# Objects
## 2022-03-24 Thu

## OOP
```
> 객체지향의 핵심은 클래스가 아닌 객체이며, 객체는 독립된 존재가 아닌 적절한 역할과 책임을 수행하며 협력하는 공동체의 일원이다.
> 객체지향 프로그래밍은 책임과 권한을 갖는 객체들이 서로 메시지를 주고 받으며 협력하여 필요한 기능을 수행하는 시스템을 개발하는 방법이다.
```

### 객체지향을 왜 공부해야 하는가?
* 프로그래밍 패러다임은 특정 시대의 개발자들에 의해 수립된 프로그래밍 방법, 문제 해결 방법, 스타일이다.
* 따라서, **개발자가 어떤 패러다임을 적용하느냐에 따라 해결해야 할 문제를 바라보는 방식과 프로그램의 작성법은 달라진다**.
* 프로그래밍 패러다임은 개발자 집단이 동일한 프로그래밍 스타일과 모델을 공유하는 것으로 불필요한 의견 충돌을 방지할 수 있다.
  * 또한, **주니어 개발자에게 프로그래밍 패러다임을 교육하는 것으로 동일한 규칙과 방법을 공유하는 개발자로 성장시킬 수 있다**.
* 과학 패러다임과 달리, 프로그래밍 패러다임은 공존할 수 있으며 상호 보완할 수 있다.
  * 프로그래밍 패러다임은 혁명적이라기보다는 발전적인 특징을 갖는다.
* **객체지향 역시 은총알이 아니므로, 객체지향이 적합하지 않은 상황에서는 언제나 다른 패러다임을 적용할 수 있는 역량을 길러야 한다**.

## 객체와 설계
* 어떤 분야든지 이론을 정립할 수 없는 초기에는 실무가 급속한 발전을 이룬 후, 실무의 실용성을 입증하는 이론이 뒤따르기 시작한다.
  * **이러한 흐름은 해당 분야가 충분히 성숙해지는 시점에서야 이론이 실무를 추월**할 수 있다.
* 역사가 오래된 **다른 공학 분야에 비해 소프트웨어 분야의 역사는 매우 짧으므로, 적어도 소프트웨어에서는 이론보다 실무가 중요**하다.
* 소프트웨어 개발에서 실무가 이론보다 앞서는 대표적인 분야로는 설계와 유지보수가 있다.
  * 해당 분야에서, 실무는 이론을 압도한다.
  * 때문에 **설계에 관해 설명할 때 가장 유용한 도구는 이론으로 치장된 개념이나 용어가 아닌 개발자의 실무 도구인 코드 그 자체**이다.

### 모듈의 기능
* 모듈이란 그 크기에 관계 없이 클래스, 패키지, 라이브러리처럼 프로그램을 구성하는 임의의 요소이다.
* 모든 **소프트웨어 모듈은 다음의 세 가지 목적**을 갖는다.
  1. 모듈은 실행 중에 제대로 동작할 수 있어야 한다.
  2. 모듈은 변경을 위해 존재해야 한다.
  3. 모듈은 코드를 읽는 개발자와 의사소통하기 쉬워야 한다.
* 3.의 원칙에 의해 우리의 코드는 이해 가능해야 한다.
  * 이해 가능한 코드란, 동작이 개발자의 예상에서 크게 벗어나지 않는 코드이다.
* 만약 코드의 동작 방식이 상식에 어긋나거나, 특정 코드를 이해하기 위해 기억해야 할 세부사항이 많다면 코드를 이해하기 어렵다.
* 그러나 **목적을 달성하지 못했을 때 3.보다 더 부정적인 영향을 끼치기 쉬운 것은 변경에 취약한 코드**이다.

### 변경에 취약한 코드
* **임의의 클래스 A의 내부 내용을 다른 클래스가 많이 알고 있을수록 A를 변경하기 어렵다**. 
  * 이는 객체 사이의 의존성과 관련된 문제이며, 의존성은 변경에 대한 영향을 암시한다.
  * **의존성이란 단어에는 어떤 객체가 변경될 때, 의존되는 모든 객체도 함께 변경될 수 있는 가능성이 내포**되어 있다.
* 반면, 의존성은 완전히 제거하고 말살해야하는 대상이 아니다.
  * **객체지향의 궁극적인 목적은 객체들이 서로 의존하며 협력하는 공동체를 구축하는 것**임을 떠올리자.
* 때문에 **개발자의 목표는 의존성의 완전한 제거가 아닌, 애플리케이션에 필요한 최소한의 의존성을 유지하되 불필요한 의존성을 제거하는 것**이다.
* **객체 사이의 의존성이 불필요하게 높은 경우를 결합도가 높다고도 표현**할 수 있다.
  * 이러한 **결합도는 의존성과 관련되어 있으며, 결합도가 높을수록 결합된 객체들이 함께 변경될 확률도 높아진다**.
  * 즉, 결합도가 높은 객체들은 함께 변경될 가능성이 높다.
* 때문에 **변경에 취약한 코드를 만들지 않으려면 객체 사이의 결합도를 낮추고 변경 용이성을 높여야 한다**.

## 설계의 개선
* **변경이 어려운 코드를 해결하려면 각 객체 사이에 공유되는 정보를 되도록 차단하고, 결합된 각 객체를 자율적인 존재로 만들어두어야 한다**.

## 2022-03-25 Fri
### 자율성을 높이기
* 결합도가 높은 객체들의 자율성을 높이려면 객체가 서로의 세부 사항에 접근하지 못하도록 하는 것이다.
  * 이렇듯 **개념적, 물리적으로 객체 내부의 세부 사항을 숨기는 것을 캡슐화라고 할 수 있다**.
* **캡슐화를 통해 객체 내부 접근을 제한하는 것으로 객체 간의 결합도를 낮출 수 있으며, 설계는 변경에 대응하기 쉬워진다**.
* 객체 A가 객체 B의 어떤 메소드를 호출하고, 객체 B는 이 메소드에 응답하기 위해 객체 C와 상호작용한다고 가정할 때,
  1. 객체 A는 객체 C가 객체 B에 포함되는 것을 알지 못한다.
  2. 객체 A는 객체 B가 노출하는 인터페이스에만 의존한다.
  3. **객체 B가 내부적인 동작에서 객체 C를 사용하는 것은 구현의 영역**이다.
* 이렇듯 **객체를 인터페이스와 구현으로 나누고 인터페이스만을 공개하는 것은 객체 사이의 결합도를 낮추는 데에 결정적인 역할**을 한다.
  * **인터페이스를 활용하는 방식은 객체 사이의 결합도를 낮추고, 변경하기 쉬운 코드를 작성하기 위한 가종 기본적인 설계 원칙**이다.

### 보다 직관적이고 변경하기 쉽게 하기
* **각 객체가 자기 자신의 문제를 스스로 해결하도록 코드를 수정하거나, 작성하는 것이 바람직**하다.
  * 그렇지 않은 경우, 각 객체는 서로의 내부에 구현된 세부 사항을 알고 있어야 하므로 직관적이지 못하고 변경에도 취약하다.
* 이렇듯 **객체의 자율성을 높이는 방향으로 설계하거나 개선할 경우, 이해하기 쉽고 유연하여 변경이 쉬운 설계를 얻을 수 있다**.

### 캡슐화와 응집도
* **핵심은 객체 내부의 상태는 가능한 한 캡슐화하고, 객체 간에서는 오로지 메시지를 통해서만 상호작용 해야한다는 점**이다.
  * 예를 들어, 객체 A는 객체 B가 어떤 메소드를 갖고, 이 메소드에 어떤 메시지를 보냈을 때 응답하리라는 사실만을 알고 있으면 된다.
* 이렇듯 **밀접하게 연관된 작업만을 수행하고, 연관 없는 작업은 다른 객체에 위임하는 객체를 응집도가 높다고 표현**할 수 있다.
  * 결합도는 객체 간의 결합 정도인 반면, 응집도는 객체 내부의 작업 관련성을 표현하는 지표이다.
  * 때문에 **자신의 데이터는 스스로 처리하는 자율성 높은 객체를 작성하면 자연스레 결합도는 낮아지고, 응집도는 높아진다**.

### 객체의 응집도를 높이기
* 객체는 자신의 데이터를 스스로 책임져야 한다.
  * 자신이 소유하지 않는 데이터를 이용하여 작업을 처리하는 객체에는 연관성 높은 작업이 할당될 수 없다.
* **객체는 항상 자신의 데이터는 스스로 처리하는 자율적인 존재여야 하며, 이것이 응집도를 높이는 첫 번째**이다.
* **객체 개개의 관점에서는 외부의 간섭을 최대한 배제하고, 객체 간에는 메시지를 통해서만 협력**해야 한다.
* 이러한 자율적인 객체들의 공동체를 만드는 것으로 훌륭한 객체지향 설계를 얻어낼 수 있다.
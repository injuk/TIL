# Objects
## 2022-03-24 Thu

## OOP
```
> 객체지향의 핵심은 클래스가 아닌 객체이며, 객체는 독립된 존재가 아닌 적절한 역할과 책임을 수행하며 협력하는 공동체의 일원이다.
> 객체지향 프로그래밍은 책임과 권한을 갖는 객체들이 서로 메시지를 주고 받으며 협력하여 필요한 기능을 수행하는 시스템을 개발하는 방법이다.
```

### 객체지향을 왜 공부해야 하는가?
* 프로그래밍 패러다임은 특정 시대의 개발자들에 의해 수립된 프로그래밍 방법, 문제 해결 방법, 스타일이다.
* 따라서, **개발자가 어떤 패러다임을 적용하느냐에 따라 해결해야 할 문제를 바라보는 방식과 프로그램의 작성법은 달라진다**.
* 프로그래밍 패러다임은 개발자 집단이 동일한 프로그래밍 스타일과 모델을 공유하는 것으로 불필요한 의견 충돌을 방지할 수 있다.
  * 또한, **주니어 개발자에게 프로그래밍 패러다임을 교육하는 것으로 동일한 규칙과 방법을 공유하는 개발자로 성장시킬 수 있다**.
* 과학 패러다임과 달리, 프로그래밍 패러다임은 공존할 수 있으며 상호 보완할 수 있다.
  * 프로그래밍 패러다임은 혁명적이라기보다는 발전적인 특징을 갖는다.
* **객체지향 역시 은총알이 아니므로, 객체지향이 적합하지 않은 상황에서는 언제나 다른 패러다임을 적용할 수 있는 역량을 길러야 한다**.

## 객체와 설계
* 어떤 분야든지 이론을 정립할 수 없는 초기에는 실무가 급속한 발전을 이룬 후, 실무의 실용성을 입증하는 이론이 뒤따르기 시작한다.
  * **이러한 흐름은 해당 분야가 충분히 성숙해지는 시점에서야 이론이 실무를 추월**할 수 있다.
* 역사가 오래된 **다른 공학 분야에 비해 소프트웨어 분야의 역사는 매우 짧으므로, 적어도 소프트웨어에서는 이론보다 실무가 중요**하다.
* 소프트웨어 개발에서 실무가 이론보다 앞서는 대표적인 분야로는 설계와 유지보수가 있다.
  * 해당 분야에서, 실무는 이론을 압도한다.
  * 때문에 **설계에 관해 설명할 때 가장 유용한 도구는 이론으로 치장된 개념이나 용어가 아닌 개발자의 실무 도구인 코드 그 자체**이다.

### 모듈의 기능
* 모듈이란 그 크기에 관계 없이 클래스, 패키지, 라이브러리처럼 프로그램을 구성하는 임의의 요소이다.
* 모든 **소프트웨어 모듈은 다음의 세 가지 목적**을 갖는다.
  1. 모듈은 실행 중에 제대로 동작할 수 있어야 한다.
  2. 모듈은 변경을 위해 존재해야 한다.
  3. 모듈은 코드를 읽는 개발자와 의사소통하기 쉬워야 한다.
* 3.의 원칙에 의해 우리의 코드는 이해 가능해야 한다.
  * 이해 가능한 코드란, 동작이 개발자의 예상에서 크게 벗어나지 않는 코드이다.
* 만약 코드의 동작 방식이 상식에 어긋나거나, 특정 코드를 이해하기 위해 기억해야 할 세부사항이 많다면 코드를 이해하기 어렵다.
* 그러나 **목적을 달성하지 못했을 때 3.보다 더 부정적인 영향을 끼치기 쉬운 것은 변경에 취약한 코드**이다.

### 변경에 취약한 코드
* **임의의 클래스 A의 내부 내용을 다른 클래스가 많이 알고 있을수록 A를 변경하기 어렵다**. 
  * 이는 객체 사이의 의존성과 관련된 문제이며, 의존성은 변경에 대한 영향을 암시한다.
  * **의존성이란 단어에는 어떤 객체가 변경될 때, 의존되는 모든 객체도 함께 변경될 수 있는 가능성이 내포**되어 있다.
* 반면, 의존성은 완전히 제거하고 말살해야하는 대상이 아니다.
  * **객체지향의 궁극적인 목적은 객체들이 서로 의존하며 협력하는 공동체를 구축하는 것**임을 떠올리자.
* 때문에 **개발자의 목표는 의존성의 완전한 제거가 아닌, 애플리케이션에 필요한 최소한의 의존성을 유지하되 불필요한 의존성을 제거하는 것**이다.
* **객체 사이의 의존성이 불필요하게 높은 경우를 결합도가 높다고도 표현**할 수 있다.
  * 이러한 **결합도는 의존성과 관련되어 있으며, 결합도가 높을수록 결합된 객체들이 함께 변경될 확률도 높아진다**.
  * 즉, 결합도가 높은 객체들은 함께 변경될 가능성이 높다.
* 때문에 **변경에 취약한 코드를 만들지 않으려면 객체 사이의 결합도를 낮추고 변경 용이성을 높여야 한다**.
```
> 불필요한 의존성은 결합도를 높이며, 변경을 어렵게 한다.
```

## 설계의 개선
* **변경이 어려운 코드를 해결하려면 각 객체 사이에 공유되는 정보를 되도록 차단하고, 결합된 각 객체를 자율적인 존재로 만들어두어야 한다**.

## 2022-03-25 Fri
### 자율성을 높이기
* 결합도가 높은 객체들의 자율성을 높이려면 객체가 서로의 세부 사항에 접근하지 못하도록 하는 것이다.
  * 이렇듯 **개념적, 물리적으로 객체 내부의 세부 사항을 숨기는 것을 캡슐화라고 할 수 있다**.
* **캡슐화를 통해 객체 내부 접근을 제한하는 것으로 객체 간의 결합도를 낮출 수 있으며, 설계는 변경에 대응하기 쉬워진다**.
* 객체 A가 객체 B의 어떤 메소드를 호출하고, 객체 B는 이 메소드에 응답하기 위해 객체 C와 상호작용한다고 가정할 때,
  1. 객체 A는 객체 C가 객체 B에 포함되는 것을 알지 못한다.
  2. 객체 A는 객체 B가 노출하는 인터페이스에만 의존한다.
  3. **객체 B가 내부적인 동작에서 객체 C를 사용하는 것은 구현의 영역**이다.
* 이렇듯 **객체를 인터페이스와 구현으로 나누고 인터페이스만을 공개하는 것은 객체 사이의 결합도를 낮추는 데에 결정적인 역할**을 한다.
  * **인터페이스를 활용하는 방식은 객체 사이의 결합도를 낮추고, 변경하기 쉬운 코드를 작성하기 위한 가종 기본적인 설계 원칙**이다.

### 보다 직관적이고 변경하기 쉽게 하기
* **각 객체가 자기 자신의 문제를 스스로 해결하도록 코드를 수정하거나, 작성하는 것이 바람직**하다.
  * 그렇지 않은 경우, 각 객체는 서로의 내부에 구현된 세부 사항을 알고 있어야 하므로 직관적이지 못하고 변경에도 취약하다.
* 이렇듯 **객체의 자율성을 높이는 방향으로 설계하거나 개선할 경우, 이해하기 쉽고 유연하여 변경이 쉬운 설계를 얻을 수 있다**.

### 캡슐화와 응집도
* **핵심은 객체 내부의 상태는 가능한 한 캡슐화하고, 객체 간에서는 오로지 메시지를 통해서만 상호작용 해야한다는 점**이다.
  * 예를 들어, 객체 A는 객체 B가 어떤 메소드를 갖고, 이 메소드에 어떤 메시지를 보냈을 때 응답하리라는 사실만을 알고 있으면 된다.
* 이렇듯 **밀접하게 연관된 작업만을 수행하고, 연관 없는 작업은 다른 객체에 위임하는 객체를 응집도가 높다고 표현**할 수 있다.
  * 결합도는 객체 간의 결합 정도인 반면, 응집도는 객체 내부의 작업 관련성을 표현하는 지표이다.
  * 때문에 **자신의 데이터는 스스로 처리하는 자율성 높은 객체를 작성하면 자연스레 결합도는 낮아지고, 응집도는 높아진다**.

### 객체의 응집도를 높이기
* 객체는 자신의 데이터를 스스로 책임져야 한다.
  * 자신이 소유하지 않는 데이터를 이용하여 작업을 처리하는 객체에는 연관성 높은 작업이 할당될 수 없다.
* **객체는 항상 자신의 데이터는 스스로 처리하는 자율적인 존재여야 하며, 이것이 응집도를 높이는 첫 번째**이다.
* **객체 개개의 관점에서는 외부의 간섭을 최대한 배제하고, 객체 간에는 메시지를 통해서만 협력**해야 한다.
* 이러한 자율적인 객체들의 공동체를 만드는 것으로 훌륭한 객체지향 설계를 얻어낼 수 있다.

### 객체지향과 절차지향
* **절차지향, 절차적 프로그래밍은 작업을 정의하는 프로세스와 작업 대상인 데이터를 별도의 모듈에 위치시키는 방식**이다.
  * 이러한 방식에서는 데이터의 변경으로 인한 영향을 지역적으로 고립시키기 어렵다.
  * 때문에 **절차적 프로그래밍에서는 변경하기 어려운 코드가 양산되는 경향**이 있다.
* **변경하기 쉬운 설계는 한 번에 하나의 클래스만 변경해도 무방한 설계**이다.
  * 반면 절차적 프로그래밍은 프로세스가 필요한 모든 데이터에 의존하므로, 변경에 취약할 수 밖에 없다.
  * 이러한 **문제를 해결하려면 데이터를 갖는 모듈이 자신의 데이터를 스스로 처리하도록 프로세스의 위치를 적절히 옮기는 것**이다.
* **객체지향 프로그래밍이란, 이처럼 데이터와 프로세스가 모두 동일한 모듈 내부에 위치하도록 프로그래밍하는 방식**이다.
* 훌륭한 **객체지향 설계의 핵심은, 캡슐화를 적절히 이용하여 의존성을 관리하고, 객체 사이의 결합도를 낮추는 것**에 있다.
  * 객체지향이 절차지향에 비해 더 유연한 이유는 여기에 있다.
  * **객체지향은 자신의 데이터를 직접 처리해야 한다는 우리의 직관에 들어맞고, 객체 내부의 변경 사항을 외부에 파급하지 않도록 제어할 수 있어 변경도 쉽다**.

### 책임의 이동
* 절차지향과 객체지향의 근본적인 차이는 책임의 이동에 있으며, 이를 쉽게 이해하려면 두 방식이 기능을 처리하는 방법을 확인하는 것이다.
  * 책임이란, 객체지향에서 기능을 가리키는 용어이다.
* 절차적 프로그래밍에서의 작업 흐름은 하나의 모듈에 집중되기 쉽다.
  * 해당 모듈은 다른 모든 모듈에 의존하기 쉬우며, 책임이 집중된다.
* **객체지향 프로그래밍에서는 제어 흐름이 각 객체에 적절히 분산되므로, 하나의 기능을 완성하기 위해 필요한 책임은 여러 객체에 분산**된다.
  * **절차지향에서 하나의 모듈에 집중된 기능이 객체지향에서는 각 객체에 분산되므로, 책임이 이동한 셈**이 된다.
* **객체지향 설계에서는 모든 책임을 갖는 독재자가 존재하지 않아야 하며, 각 객체에 책임이 적절히 분산되는 것이 이상적**이다.
  * 이에 따라 각 객체는 자기 자신을 스스로 책임지게 된다.
```
> 객체지향이 적용된 애플리케이션은 스스로 책임을 수행하는 자율적인 객체들의 공동체로 구성된다.
```

### 객체지향 설계의 걸림돌
* 객체지향 설계를 어렵게 만드는 것은 의존성이며, 불필요한 의존성은 객체 사이의 결합도를 높여 변경을 어렵게 한다.
* 세부사항을 객체에 캡슐화하는 등의 방법을 통해 불필요한 의존성은 제거해야 하며, 이를 통해 객체 사이의 결합도를 낮출 수 있다.

### 훌륭한 객체지향 설계
* **객체지향 설계의 핵심은 객체가 어떤 데이터를 갖느냐가 아닌, 객체에 어떤 책임을 할당할지 결정하는 것**에 있다.
  * **객체는 다른 객체와의 협력이라는 문맥 안에서 자신의 역할을 수행하기 위해 필요한 적절한 책임이 할당되어야 한다**.
* 상술한 객체지향 설계의 핵심이 온전하게 지켜져 적절한 객체에 적절한 책임이 할당될 경우, 이해하기 쉬운 구조와 읽기 쉬운 코드를 얻을 수 있다.
* **불필요한 세부사항은 임의의 객체 내부로 캡슐화되어야 하며, 이를 통해 객체의 자율성과 응집도를 높이는 것이 바람직**하다.
  * 결과 응집도 높은 객체들의 공동체인 객체지향 애플리케이션이 완성될 수 있다.
  * 훌륭한 객체지향 설계는 소프트웨어를 구성하는 모든 객체들이 자율적으로 행동하는 설계이다.
```
> 불필요한 세부사항을 캡슐화한 자율적인 객체들이 낮은 결합도와 높은 응집도를 유지하며 서로 협력하도록 최소한의 의존성을 남기는 것이 훌륭한 객체지향 설계이다.
```

### 설계의 특징
* 설계는 다음과 같은 특징을 갖는다.
  1. 어떤 기능을 설계하는 방법은 하나 이상일 수 있다.
  2. 동일한 기능을 하나 이상의 방법으로 설계할 수 있으므로, 설계에는 반드시 트레이드오프를 고려해야하는 시점이 온다.
  3. **어떠한 경우에도 모든 사람을 만족시키는 설계를 만들 수는 없으며, 설계는 언제나 트레이드오프의 산물**이다.
```
> 설계는 균형의 예술이며, 훌륭한 설계는 적절히 처리된 트레이드오프의 결과물이다.
```

### 무생물과 객체지향
* 객체지향의 세계에서는 실세계에서 자율적인 존재가 아닌 무생물을 객체화해야 한다.
  * 이는 즉 **무생물 역시 스스로 행동하고, 자신을 책임질 수 있는 자율적인 존재로 취급해야 함을 의미**한다.
* 무생물 등 현실에서는 수동적인 존재들은 객체지향의 세계에서는 모두 능동적이고 자율적인, 싱싱한 존재로 바뀌어야 한다.
* 이렇듯 **능동적이고 자율적인 존재로 취급하여 객체를 설계하는 원칙을 의인화**라고도 부를 수 있다.
```
> 의인화 관점에서 소프트웨어는 생물로 취급할 수 있다.
> 모든 생물처럼 소프트웨어는 태어나고, 살아가고, 죽는다.
```

### 왜 설계가 필요한가?
* 설계는 구현과 별개로 생각할 수 없으며, 모든 코드를 작성하는 순간 코드의 위치를 결정하는 과정에서 나온다.
  * 설계는 코드 작성의 일부이며, 코드를 작성하지 않고서는 검증도 불가능하다.
```
> 설계란, 코드를 배치하는 것이다.
```
* 좋은 설계란, 모든 프로그램이 갖는 다음의 두 가지 요구사항을 충족시키는 것이다.
  1. 오늘 요구하는 기능을 온전히 수행해야 한다.
  2. 내일의 변경사항을 매끄럽게 수용할 수 있어야 한다.
* **설계에서 변경 수용 가능성이 중요한 이유는 요구사항이 항상 변경되기 때문**이다.
  * 개발 시작 시점에 모든 요구사항을 수집하는 것은 불가능하며, 그렇다고 하더라도 개발 과정에서 요구사항 자체가 변경될 수 있다.
* 또 다른 이유로, **코드의 변경에는 언제나 버그 발생 가능성이 수반**된다.
  * 수정하지 않는다면 버그는 발생하지 않을 것이며, 이러한 버그의 문제점은 수정 의지 자체를 꺾어버리는 점에 있다.

### 객체지향 설계의 결론
* **우리가 진정 원하는 것은 변경에 유연하게 대응할 수 있는 코드**이다.
* 이러한 측면에서 객체지향 프로그래밍은 의존성을 효율적으로 통제할 수 있는 다양한 방법을 제공하며, 요구사항 변경에 더 쉽게 대응할 수 있도록 한다.
  * **변경 가능한 코드란, 이해가 쉬운 코드**이다.
* 객체지향은 우리가 세상을 바라보는 방식대로 코드를 작성할 수 있도록 한다.
* 객체지향은 우리가 예상하는 방식대로 객체가 행동하는 것을 보장하여 코드를 쉽게 이해할 수 있도록 하고, 결과 변경 가능한 코드를 작성할 수 있도록 한다.
* **객체지향의 세계에서 애플리케이션은 객체들로 구성되며, 애플리케이션의 기능은 객체 간의 상호작용으로 구현**된다.
  * 이 때, 객체 간의 상호작용은 객체 사이에 오가는 메시지인 메소드 호출로 표현된다.
* 애플리케이션을 구현하기 위해 객체들이 협력하는 과정에서, 객체들은 서로 다른 객체와 의존하게 된다.
  * **메시지를 전송하기 위해 필요한 사전 지식은 두 객체를 결합시키며, 이러한 결합은 객체 사이의 의존성**으로 나타난다.
* **훌륭한 객체지향 설계는 협력하는 코드를 변경하기 어렵게 만드는 객체 사이의 의존성을 적절히 관리하는 설계**이다.
# Objects
## 2022-03-30 Wed

## 메시지와 인터페이스
* 객체지향의 가장 큰 오해는 애플리케이션을 클래스의 집합으로 구성하기 위해 전체 개발 활동의 중심에 클래스를 두어야한다는 사실이다.
  * 클래스는 중요하지만, 어디까지나 객체지향을 구현하기 위한 도구에 지나지 않는다.
  * 클래스에 집착하는 경우, 경직되고 유연하지 못한 설계가 될 가능성이 크다.
* **훌륭한 객체지향 코드를 위해서는 클래스가 아닌 객체를 지향하며, 더 나아가 협력 안에서 객체가 수행하는 책임에 초점을 두어야 한다**.
  * 이 때, **책임은 객체가 수신할 수 있는 메시지의 기반이 되는 사실이 중요**하다.
* **객체지향 애플리케이션에서 가장 중요한 재료는 클래스가 아니라 객체들이 주고받는 메시지**이다.
* **클래스 사이의 정적인 관계에서 객체들이 주고받는 동적인 메시지로 초점을 전환하는 것은 객체지향 개발자로 성장하기 위한 첫걸음**이다.
  * 즉, 애플리케이션은 클래스로 구성되지만 실제로는 메시지를 통해 정의된다.
* 객체들이 주고받는 메시지들은 각 객체의 퍼블릭 인터페이스를 구성한다.

### 협력과 메시지
* 협력은 객체가 다른 객체에게 무언가를 요청할 때 시작하며, 메시지는 객체 간의 협력을 가능하게 하는 유일한 매개체이다.
  * 이렇듯 **메시지를 매개로하는 요청과 응답이 조합되어 두 객체 사이의 협력을 구성**하게 된다.
* 이러한 **메시지 송수신 구조는 전통적인 클라이언트 서버 모델로 치환될 수 있으며, 협력은 클라이언트가 서버에게 서비스를 요청하는 단방향 상호작용**이다.
* 협력에 참여하는 객체는 일반적으로 클라이언트와 서버의 역할을 동시에 수행하며, 다음과 같은 두 종류의 메시지 집합을 갖는다.
  1. 객체가 수신하는 메시지의 집합
  2. 객체가 다른 객체에게 전송하는 메시지의 집합
* 대부분의 경우 객체가 수신하는 메시지의 집합에만 초점이 맞추어지곤 한다
  * 그러나 **협력에 적합한 객체를 설계하기 위해 외부에 전송하는 메시지의 집합도 함께 고려하는 것이 바람직**하다.
```
> 객체는 독립적으로 수행할 수 있는 것보다 더 큰 책임을 수행하기 위해 반드시 다른 객체와 협력해야 한다.
> 이 때, 두 객체 사이의 협력을 가능케하는 유일한 매개체는 메시지이다.
```

### 메시지와 메시지 전송
* 메시지는 객체들이 협력하기 위해 사용할 수 있는 유일한 의사소통 수단이다.
  * 메시지는 오퍼레이션 이름, 인자로 구성된다.
* 메시지 전송은 하나의 객체가 또 다른 객체에게 도움을 요청하는 것을 가리킨다.
  * 메시지 전송은 오퍼레이션 이름, 인자로 구성된 메시지와 메시지 수신자로 구성된다.
```
> doSomething(withThis)는 메시지이다.
> hey.doSomething(withThis)는 메시지 전송이다.
```

### 메시지와 메소드
* 메소드는 메시지를 수신했을 때 **실제로 실행되는 함수**를 말한다.
* 중요한 것은 동일한 이름의 변수에 동일한 메시지를 전송했더라도, 다형성에 의해 객체의 타입에 따라 실행되는 메소드는 다를 수 있다.
  * 즉, **메시지는 같지만 메소드는 다를 수 있다**.
* 전통적인 방식에서, 개발자는 정확히 어떤 함수가 실행될지 알고 있으므로 코드의 의미는 컴파일 시점과 런타임 시점에 동일하다.
* 반면 **객체지향에서는 메시지와 메소드가 분리된 개념이고, 런타임에 연결되므로 컴파일 시점과 런타임 시점에 의미가 달라질 수 있다**.
  * 다시 말해 실행 시간에 수신자의 실제 클래스와 객체에 기반하여 메시지를 메소드에 바인딩하게 된다.
  * 때문에 메시지 전송을 코드 상에서 표현하는 과정에서는 실제로 어떤 메소드가 실행될지 알 수 없다.
* 따라서 객체지향에서는 협력을 위해 메시지를 송신해야 하고, 해당 메시지를 수신하는 객체가 있고, 해당 객체가 이를 적절히 처리해줄 것을 믿을 수 밖에 없다.
* **이러한 구조에서 메시지 전송자와 메시지 수신자는 느슨하게 결합**되므로 유연성과 확장성 측면에서 이점을 얻을 수 있다.
  1. 메시지 전송자는 어떤 메시지를 전송해야하는지만 알면 된다.
  2. 메시지 수신자는 누가 메시지를 전송하는지 알 필요가 없으며, 메시지가 도착했다는 사실만 안 채 스스로 메소드를 결정할 수 있다.

### 퍼블릭 인터페이스와 오퍼레이션
* 객체는 안과 밖을 명확하게 구분하는 경계를 가지며, 외부에서 볼 때 객체의 내부는 가려져 보이지 않게 된다.
* 이 경우, **외부의 객체는 오로지 객체가 공개하는 메시지의 집합을 통해서만 객체와 상호작용이 가능**하다.
  * 이렇듯 객체가 외부 객체로부터의 메시지를 수신하기 위해 공개하는 메시지의 집합을 퍼블릭 인터페이스라고 한다.
* 프로그래밍 언어적 관점에서 **퍼블릭 인터페이스에 포함된 메시지는 오퍼레이션**이라고도 부를 수 있다.
  * **오퍼레이션은 수행 가능한 어떤 행동에 대한 추상화이며, 일반적으로 내부의 구현 코드를 제외하고 메소드 시그니쳐만을 가리키는 경우가 많다**.
* 반면 **메시지를 수신했을 때 객체가 메시지를 처리하기 위해 실제로 실행하는 코드는 메소드**이다.
```
> 퍼블릭 인터페이스의 각 요소는 오퍼레이션이다.
> 반면, 오퍼레이션을 실제로 구현한 것은 메소드이다.
```
* 프로그래밍 언어적 관점에서 객체가 메시지를 전송하면, 런타임에서 메시지 전송은 오퍼레이션 호출로 해석된다.
* 이후 메시지를 수신하는 실제 객체의 타입을 기반으로 적절한 메소드를 찾아 실행하게 된다.
* 이 경우, **퍼블릭 인터페이스와 메시지 관점에서 객체는 실제 메소드를 명시한 것이 아니므로 메소드 호출보다는 오퍼레이션 호출이라는 용어가 적절**하다.

### 시그니쳐
* 오퍼레이션 또는 메소드의 이름과 파라미터 목록을 합쳐 시그니쳐라는 용어로 가리킨다.
  * 때문에 **오퍼레이션은 구현 없이 시그니쳐만을 정의한 셈**이 된다.
  * 반면 메소드는 시그니쳐에 구현이 더해진다.
* 일반적으로, 메시지를 수신한 객체는 호출된 오퍼레이션의 시그니쳐와 동일한 메소드를 실행한다.
* **중요한 것은 객체가 수신할 수 있는 메시지가 객체의 퍼블릭 인터페이스와, 내부에 포함될 오퍼레이션을 결정한다는 사실**이다.
```
> 객체의 퍼블릭 인터페이스는 객체의 품질을 결정하므로, 결국 메시지가 객체의 품질을 결정한다.
```
# Objects
## 2022-03-30 Wed

## 메시지와 인터페이스
* 객체지향의 가장 큰 오해는 애플리케이션을 클래스의 집합으로 구성하기 위해 전체 개발 활동의 중심에 클래스를 두어야한다는 사실이다.
  * 클래스는 중요하지만, 어디까지나 객체지향을 구현하기 위한 도구에 지나지 않는다.
  * 클래스에 집착하는 경우, 경직되고 유연하지 못한 설계가 될 가능성이 크다.
* **훌륭한 객체지향 코드를 위해서는 클래스가 아닌 객체를 지향하며, 더 나아가 협력 안에서 객체가 수행하는 책임에 초점을 두어야 한다**.
  * 이 때, **책임은 객체가 수신할 수 있는 메시지의 기반이 되는 사실이 중요**하다.
* **객체지향 애플리케이션에서 가장 중요한 재료는 클래스가 아니라 객체들이 주고받는 메시지**이다.
* **클래스 사이의 정적인 관계에서 객체들이 주고받는 동적인 메시지로 초점을 전환하는 것은 객체지향 개발자로 성장하기 위한 첫걸음**이다.
  * 즉, 애플리케이션은 클래스로 구성되지만 실제로는 메시지를 통해 정의된다.
* 객체들이 주고받는 메시지들은 각 객체의 퍼블릭 인터페이스를 구성한다.

### 협력과 메시지
* 협력은 객체가 다른 객체에게 무언가를 요청할 때 시작하며, 메시지는 객체 간의 협력을 가능하게 하는 유일한 매개체이다.
  * 이렇듯 **메시지를 매개로하는 요청과 응답이 조합되어 두 객체 사이의 협력을 구성**하게 된다.
* 이러한 **메시지 송수신 구조는 전통적인 클라이언트 서버 모델로 치환될 수 있으며, 협력은 클라이언트가 서버에게 서비스를 요청하는 단방향 상호작용**이다.
* 협력에 참여하는 객체는 일반적으로 클라이언트와 서버의 역할을 동시에 수행하며, 다음과 같은 두 종류의 메시지 집합을 갖는다.
  1. 객체가 수신하는 메시지의 집합
  2. 객체가 다른 객체에게 전송하는 메시지의 집합
* 대부분의 경우 객체가 수신하는 메시지의 집합에만 초점이 맞추어지곤 한다
  * 그러나 **협력에 적합한 객체를 설계하기 위해 외부에 전송하는 메시지의 집합도 함께 고려하는 것이 바람직**하다.
```
> 객체는 독립적으로 수행할 수 있는 것보다 더 큰 책임을 수행하기 위해 반드시 다른 객체와 협력해야 한다.
> 이 때, 두 객체 사이의 협력을 가능케하는 유일한 매개체는 메시지이다.
```

### 메시지와 메시지 전송
* 메시지는 객체들이 협력하기 위해 사용할 수 있는 유일한 의사소통 수단이다.
  * 메시지는 오퍼레이션 이름, 인자로 구성된다.
* 메시지 전송은 하나의 객체가 또 다른 객체에게 도움을 요청하는 것을 가리킨다.
  * 메시지 전송은 오퍼레이션 이름, 인자로 구성된 메시지와 메시지 수신자로 구성된다.
```
> doSomething(withThis)는 메시지이다.
> hey.doSomething(withThis)는 메시지 전송이다.
```

### 메시지와 메소드
* 메소드는 메시지를 수신했을 때 **실제로 실행되는 함수**를 말한다.
* 중요한 것은 동일한 이름의 변수에 동일한 메시지를 전송했더라도, 다형성에 의해 객체의 타입에 따라 실행되는 메소드는 다를 수 있다.
  * 즉, **메시지는 같지만 메소드는 다를 수 있다**.
* 전통적인 방식에서, 개발자는 정확히 어떤 함수가 실행될지 알고 있으므로 코드의 의미는 컴파일 시점과 런타임 시점에 동일하다.
* 반면 **객체지향에서는 메시지와 메소드가 분리된 개념이고, 런타임에 연결되므로 컴파일 시점과 런타임 시점에 의미가 달라질 수 있다**.
  * 다시 말해 실행 시간에 수신자의 실제 클래스와 객체에 기반하여 메시지를 메소드에 바인딩하게 된다.
  * 때문에 메시지 전송을 코드 상에서 표현하는 과정에서는 실제로 어떤 메소드가 실행될지 알 수 없다.
* 따라서 객체지향에서는 협력을 위해 메시지를 송신해야 하고, 해당 메시지를 수신하는 객체가 있고, 해당 객체가 이를 적절히 처리해줄 것을 믿을 수 밖에 없다.
* **이러한 구조에서 메시지 전송자와 메시지 수신자는 느슨하게 결합**되므로 유연성과 확장성 측면에서 이점을 얻을 수 있다.
  1. 메시지 전송자는 어떤 메시지를 전송해야하는지만 알면 된다.
  2. 메시지 수신자는 누가 메시지를 전송하는지 알 필요가 없으며, 메시지가 도착했다는 사실만 안 채 스스로 메소드를 결정할 수 있다.

### 퍼블릭 인터페이스와 오퍼레이션
* 객체는 안과 밖을 명확하게 구분하는 경계를 가지며, 외부에서 볼 때 객체의 내부는 가려져 보이지 않게 된다.
* 이 경우, **외부의 객체는 오로지 객체가 공개하는 메시지의 집합을 통해서만 객체와 상호작용이 가능**하다.
  * 이렇듯 객체가 외부 객체로부터의 메시지를 수신하기 위해 공개하는 메시지의 집합을 퍼블릭 인터페이스라고 한다.
* 프로그래밍 언어적 관점에서 **퍼블릭 인터페이스에 포함된 메시지는 오퍼레이션**이라고도 부를 수 있다.
  * **오퍼레이션은 수행 가능한 어떤 행동에 대한 추상화이며, 일반적으로 내부의 구현 코드를 제외하고 메소드 시그니쳐만을 가리키는 경우가 많다**.
* 반면 **메시지를 수신했을 때 객체가 메시지를 처리하기 위해 실제로 실행하는 코드는 메소드**이다.
```
> 퍼블릭 인터페이스의 각 요소는 오퍼레이션이다.
> 반면, 오퍼레이션을 실제로 구현한 것은 메소드이다.
```
* 프로그래밍 언어적 관점에서 객체가 메시지를 전송하면, 런타임에서 메시지 전송은 오퍼레이션 호출로 해석된다.
* 이후 메시지를 수신하는 실제 객체의 타입을 기반으로 적절한 메소드를 찾아 실행하게 된다.
* 이 경우, **퍼블릭 인터페이스와 메시지 관점에서 객체는 실제 메소드를 명시한 것이 아니므로 메소드 호출보다는 오퍼레이션 호출이라는 용어가 적절**하다.

### 시그니쳐
* 오퍼레이션 또는 메소드의 이름과 파라미터 목록을 합쳐 시그니쳐라는 용어로 가리킨다.
  * 때문에 **오퍼레이션은 구현 없이 시그니쳐만을 정의한 셈**이 된다.
  * 반면 메소드는 시그니쳐에 구현이 더해진다.
* 일반적으로, 메시지를 수신한 객체는 호출된 오퍼레이션의 시그니쳐와 동일한 메소드를 실행한다.
* **중요한 것은 객체가 수신할 수 있는 메시지가 객체의 퍼블릭 인터페이스와, 내부에 포함될 오퍼레이션을 결정한다는 사실**이다.
```
> 객체의 퍼블릭 인터페이스는 객체의 품질을 결정하므로, 결국 메시지가 객체의 품질을 결정한다.
```

### 인터페이스와 설계 품질
* 좋은 인터페이스는 최소한의 인터페이스와 추상적인 인터페이스이다.
  1. 최소한의 인터페이스: 필요한 오퍼레이션만 포함해야 한다.
  2. 추상적인 인터페이스: 어떻게 하는지보다는 무엇을 하는지 표현해야 한다.
* 이러한 좋은 인터페이스를 설계할 수 있도록 하는 가장 좋은 방법은 책임 주도 설계 방식을 따르는 것이다.
  * 책임 주도 설게는 메시지를 먼저 선택함으로써 협력과는 무관한 오퍼레이션을 배제한다.
  * 객체가 메시지를 선택하는 것이 아니라 메시지가 객체를 선택하게 함으로써 클라이언트의 의도를 메시지로 표현한다.
* 또한 퍼블릭 인터페이스의 품질에 영향을 주는 다음과 같은 원칙과 기법들을 이해하면 훌륭한 인터페이스를 얻을 수 있는 안목을 넓힐 수 있다.
  1. 디미터 법칙
  2. 묻지 말고 시키기
  3. 의도를 드러내는 인터페이스
  4. 명령 - 쿼리 분리

### 디미터 법칙
* 디미터 법칙은 오직 인접한 이웃과만 말하도록 권장하며, 객체 내부 구조와 강하게 결합되지 않도록 협력 경로를 제한해야 한다는 원칙이다.
  * Java의 경우, 디미터 법칙은 obj.outer.inner와 같이 참조 연산자를 둘 이상 사용하지 않아야 하는 점을 강조한다.
* 디미터 법칙은 협력하는 객체 내부 구조와 깊이 결합될 경우 발생하는 문제를 해결하기 위해 제안되었다.
* 디미터 법칙에 따르려면 클래스 내부의 메소드는 다음과 같은 조건을 만족하는 인스턴스에만 메시지를 전송하도록 코드를 작성해야 한다.
  1. this 객체
  2. 메소드의 매개변수
  3. this의 속성
  4. this의 속성인 컬렉션의 각 요소
  5. 메소드 내에서 생성된 지역 객체
* 디미터 법칙을 준수할 경우 다음과 같은 특징을 갖는 부끄럼타는 코드를 작성할 수 있다.
  1. 부끄럼타는 코드는 불필요한 어떤 것도 다른 객체에게 보여주지 않는다.
  2. 부끄럼타는 코드는 다른 객체의 구현에 의존하지 않는다.
* 디미터 법칙을 따르는 코드는 메시지 수신자의 내부 구조가 전송자에게 노출되지 않으므로, 전송자는 수신자의 내부 구현에 결합될 일이 없다.
  * 즉, 클라이언트와 서버 사이의 낮은 결합도를 유지할 수 있게 된다.
* 디미터 법칙을 위반하는 코드는 수신자의 내부 구조에 대해 물어보고, 반환받은 요소에 대해 연쇄적으로 메시지를 전송한다.
  * 따라서 인터페이스와 구현의 분리 원칙을 위배하며, 객체의 내부 구조가 외부로 노출된다.
* 디미터 법칙을 준수하도록 개선된 코드에서는 메시지 전송자가 더 이상 메시지 수신자의 내부 구조에 대해 묻지 않는다.
  * 대신 자신이 원하는 것을 명확히 명시하고, 단순히 수행하도록 요청한다.
* 즉, **디미터 법칙은 객체의 내부 구조를 묻는 메시지보다는 무언가를 시키는 메시지가 더 바람직하다는 점을 시사**한다.
* 디미터 법칙을 준수하는 코드는 정보를 처리하기 위해 필요한 책임을 정보를 갖는 객체에게 할당하므로, 높은 응집도를 갖는 객체가 된다.

### 묻지 말고 시키기
* **상술한 디미터 법칙은 훌륭한 메시지는 객체의 상태에 묻기보다 원하는 것을 시켜야한다는 사실을 강조**한다.
  * 묻지 말고 시키기 원칙은 이런 스타일의 메시지 작성을 장려한다.
* **절차적인 코드는 정보를 대상에게 물어보고 얻어낸 후에 결정하지만, 객체지향적인 코드는 객체 스스로 결정을 내리도록 시켜야한다**.
  * 객체지향적인 코드에서는 객체의 외부에서 대상 객체의 내부 상태를 기반으로 결정을 내리는 것은 캡슐화를 위반한다.
* **객체지향의 기본은 함께 변경되기 쉬운 정보와 행동을 하나의 단위로 통합하는 것**이다. 
  * 묻지 말고 시키기 원칙을 준수할 경우, 밀접한 관련이 있는 정보와 행동을 하나의 단위로 통합할 수 있다.
  * 따라서 자연스럽게 정보 전문가에게 책임이 할당되고, 높은 응집도를 갖는 클래스를 얻게 된다.
* 묻지 말고 시키기 원칙과 디미터 법칙은 훌륭한 인터페이스를 작성하기 위한 좋은 지침이 된다.
  * **내부의 상태를 묻는 오퍼레이션이 인터페이스에 포함된다면, 수신 객체의 책임이 외부로 누수된 것이므로 더 나은 방법을 고민**해야 한다.
  * 상태를 묻는 오퍼레이션은 행동을 요청하는 오퍼레이션으로 대체해야 한다.
  * **협력을 설계하고 객체가 수신할 메시지를 결정하는 매 순간 두 원칙을 준수하는지 고민해야 하며, 이를 통해 퍼블릭 인터페이스의 품질을 향상**시킬 수 있다.

### 의도를 드러내는 인터페이스
* 단순하게 객체에게 아무것도 묻지 않고 시킨다고 해서 모든 문제가 해결되지는 않으며, 객체는 어떻게 작업을 수행하는지 노출하지 않아야 한다.
  * **인터페이스는 객체가 어떻게 행동하는지가 아닌, 무엇을 하는지 서술해야 한다**.
* 메소드를 명명하는 방법은 크게 다음과 같이 나누어볼 수 있다.
  1. 메소드가 작업을 어떻게 수행하는지 드러내는 명명법
  2. 메소드가 무슨 작업을 수행하는지 드러내는 명명법
* 어떻게 수행하는지 드러내는 명명법은 다음과 같은 문제점이 존재한다.
  1. 내부의 구현을 드러내며, 여러 메소드가 동일한 작업을 수행하더라도 알아내기 어려운 단점이 있다. 
  2. 또한 메소드 수준에서 캡슐화를 위반하며, 동일한 역할을 수행하는 객체를 교체할 경우 객체와 메소드를 모두 수정해야만 하므로 변경에 취약하다.
  3. **이름 자체가 내부 구현을 설명해야 하므로, 너무 이른 시기에 내부 구현부터 고민**하게 만든다.
* 반면 무엇을 하는지 드러내는 명명법은 다음과 같은 장점이 존재한다.
  1. **무엇을 하는지 드러내는 명명법은 명명이 상대적으로 어렵지만, 코드의 가독성과 유연성 측면에서 큰 이점을 얻을 수 있다**.
  2. **객체가 협력 안에서 수행하는 책임에 관해 고민하게 만들며, 결과 메시지의 목적을 먼저 생각하도록 유도**한다.
  3. **결과적으로 협력하고자하는 클라이언트의 의도에 부합하는 메소드의 이름을 결정**하게 된다.
* **메소드가 무엇을 수행하는지에 초점을 맞출 경우, 클라이언트 관점에서 동일한 작업을 수행하는 메소드를 하나의 타입 계층으로 묶을 수 있다**.
  * **이로 인해 다형성을 활용하여 다양한 타입의 객체가 참여할 수 있는 유연한 협력을 이끌어낼 수 있다**.
* 상술한 무엇을 하는지 드러내는 메소드의 명명법은 의도를 드러내는 선택자 패턴이라고도 부를 수 있다.
* 의도를 드러내는 선택자 패턴은 인터페이스 레벨로 확장되어 의도를 드러내는 인터페이스 패턴이 될 수 있다.
  * **해당 패턴은 구현과 관련된 모든 정보를 캡슐화하고, 퍼블릭 인터페이스에는 협력과 관련된 의도만을 표현할 것이 권장**된다.
  * **결과와 목적만을 포함하도록 클래스와 오퍼레이션의 이름이 명명되어야 하며, 의도를 표현하는 추상적인 인터페이스 뒤로 모든 내부 구현을 캡슐화**해야 한다.
  * 이 때, 오퍼레이션의 이름에는 협력이라는 문맥 역시 반영되어야 한다.
```
> 가독성 있고 유연하며 협력적인 객체를 만들기 위해서는 객체에게 묻지 말고 시키되, 클라이언트의 의도가 드러나는 메시지를 전달하라.
```
* **일단 디미터 법칙과 묻지 말고 시키기 원칙을 따르는 인터페이스를 작성한 후, 클라이언트의 의도가 명확히 드러나도록 반영되는지 확인하는 것이 이상적**이다.

### 함께 사용하기
* 객체지향 개발자는 결합도가 낮으면서도 의도를 명확히 드러내는 간결한 협력을 원하며, 상술한 세 원칙은 이에 다음과 같은 도움을 줄 수 있다.
  1. 디미터 법칙: 객체 간의 협력을 설계할 때 캡슐화를 위반하는 메시지가 인터페이스에 포함되지 않도록 제한한다.
     * **디미터 법칙을 위배하는 경우 접근자 등을 통해 내부 구현을 가져온 후 연쇄적인 행동을 요청하므로, 내부 구현이 퍼블릭 인터페이스에 드러나게 된다**.
  2. 묻지 않고 시키기: 디미터 법칙을 준수하는 협력을 만들기 위한 스타일을 제시한다.
  3. 의도를 드러내는 인터페이스: 퍼블릭 인터페이스에 어떤 이름이 드러나야하는지에 대한 가이드를 제공하며, 코드의 목적을 명확하게 소통할 수 있도록 지원한다.

### 원칙의 함정
* 상술한 원칙들은 객체의 퍼블릭 인터페이스를 깔끔하고 유연하게 만들 수 있는 원칙이지만, 절대적이지는 않다.
* 설계는 언제나 트레이드오프의 산물이며, 나아가 설계를 적절히 트레이드오프할 수 있는 능력은 숙련자와 초보자를 구분하는 중요한 기준이다.
  * 초보자는 원칙을 맹목적으로 추종하며, 원칙들이 충돌하는 경우에도 끼워맞추려 시도할 수 있다.
  * 이 경우, 설계는 일관성을 잃고 코드는 무질서하게 된다.
* 원칙이 상황에 적합하지 않다고 생각되는 경우, 과감하게 원칙을 무시해야 한다.
* 중요한 것은 언제 원칙이 적절하고, 언제 적절하지 않은지 판단할 수 있는 능력이다.

### 디미터 법칙의 오해
* 디미터 법칙은 결합도와 관련된 원칙이며, 참조 연산자의 개수를 하나로 강제하는 규칙이 아니다.
  * 즉, 하나 이상의 참조 연산자를 사용하는 모든 케이스가 디미터 법칙을 위반하는 것은 아니다.
* **많은 참조 연산자를 사용한 코드더라도 객체의 내부 구현을 외부로 노출하지 않는다면 디미터 법칙을 준수하는 코드**이다.

### 결합도와 응집도 가치의 충돌
* 일반적으로 객체의 상태를 물어본 후 반환된 상태를 기반으로 다음 결정을 내리는 것은 묻지 말고 시키기 원칙을 준수하도록 수정되어야 한다.
  * 이 경우, 일반적으로 적절한 방법은 메소드의 위치를 적절한 객체에 옮긴 후 위임 메소드를 작성하는 것이다.
* 위임 메소드를 활용하여 객체의 내부 구조를 감추는 경우, 협력에 참여하는 객체들의 결합도를 낮추는 동시에 객체의 응집도를 높일 수 있다.
* 그러나 맹목적으로 위임 메소드를 작성하는 경우, 동일한 퍼블릭 인터페이스 내부에 어울리지 않는 오퍼레이션들이 추가될 수 있다.
  * 즉, **객체와 상관 없는 책임들이 할당될 수 있다**.
  * 클래스는 하나의 변경 원인만을 가져야 하므로, 맹목적인 원칙 준수는 변경에 취약한 구조를 낳게 된다.
* 무작정 디미터 법칙과 묻지 말고 시키기 원칙을 준수할 경우 애플리케이션에 응집도가 낮은 객체가 넘쳐날 수 있게 된다.
* **객체에게 시키는 것이 항상 가능한 것은 아니며, 가끔은 물어본 후에 결정해야할 수도 있다**.
```
> 소프트웨어 설계에 절대적인 법칙이란 존재하지 않으므로, 원칙을 맹신하지 말아야 한다.
> 때문에 원칙이 적절한 상황과 부적절한 상황을 판단할 수 있는 안목을 기르는 것이 중요하다.
```

### 명령 - 쿼리 분리 원칙
* 명령 쿼리 분리 원칙은 퍼블릭 인터페이스에 오퍼레이션을 정의하기 위해 참고할 수 있는 지침을 제공한다.
* 일반적으로, 어떠한 절차를 묶어 재사용이 가능하도록 이름을 부여한 기능 모듈을 루틴이라고 한다.
* 루틴은 다시 다음과 같은 기준에서 프로시저와 함수로 구분할 수 있다.
  * 프로시저: 부수효과를 발생시키지만, 값을 반환할 수 없다.
  * 함수: 값을 반환할 수 있지만, 부수효과는 발생시키지 않는다.
* **명령과 쿼리는 객체의 인터페이스 측면에서 프로시저와 함수를 가리키는 또 다른 이름**이다.
  * 명령: 객체의 상태를 수정하는 오퍼레이션에 해당하며, 개념적으로 프로시저와 동일하다.
  * 쿼리: 객체와 관련된 정보를 반환하는 오퍼레이션에 해당하며, 개념적으로 함수와 동일하다.
* **해당 원칙은 결국 오퍼레이션은 명령이거나, 쿼리 중 하나여야 한다는 사실을 강조**한다.
  * **어떠한 오퍼레이션도 명령인 동시에 쿼리일 수는 없다**.
* 명령 쿼리 분리 원칙은 객체들을 독립적인 기계로 보는 객체지향의 오랜 전통에 기이하며, 이에 따라 작성된 객체 인터페이스를 명령 쿼리 인터페이스라고 한다.
* 명령과 쿼리를 뒤섞으면 실행 결과를 예측하기 어려워진다.
  * 예를 들어 겉으로 보기에는 쿼리 같지만 실제로는 부수효과를 갖는 메소드는 이해하기 어렵고, 잘 못 사용되기 쉽고, 버그의 원인이 될 수 있다.
  * 이러한 **문제를 미연에 방지하는 깔끔한 해결책은 명령과 쿼리를 가능한 한 명확히 분리하는 것**이다.
* 반환값이 있는 메소드는 쿼리이므로 부수 효과에 대한 부담이 없어 몇 번을 호출해도 상관이 없다.
* 반면 반환값이 없는 메소드는 명령이므로, 호출시 부수 효과에 주의해야 한다.
  * 이러한 구분법은 모든 메소드를 하나씩 분석하는 것보다, 반환값의 존재유무만을 판단하는 것으로 명령과 쿼리를 간단하게 구분할 수 있다.
* 명령과 쿼리의 분리가 언뜻 인터페이스 를 더 복잡하게 만드는 것처럼 보일지라도, 이를 통해 얻어지는 이점이 더 크다.
  * **퍼블릭 인터페이스를 설계할 때 명령과 쿼리를 명확히 분리할 경우 코드는 예측 가능하고, 가독성과 디버깅 용이성 및 유지보수성이 향상**될 수 있다.

### 참조 투명성
* 참조 투명성이란 표현식 e에서 모든 e를 e의 값으로 바꾸더라도 결과가 달리지지 않는 특성을 말하며, 수학은 참조 투명성을 만족시키는 이상적인 예시이다.
  * 반면 객체지향 패러다임은 객체의 상태 변경이라는 부수효과를 기반으로 하므로, 참조 투명성은 예외에 가깝다.
* 그러나 **명령과 쿼리를 엄격하게 분류하면 객체의 부수효과를 제어하기가 쉬워지므로, 간접적으로 다음과 같은 참조 투명성의 이점을 누릴 수 있게 된다**.
  1. 모든 함수를 이미 알고 있는 하나의 값으로 대체할 수 있으므로, 식을 쉽게 계산할 수 있다.
  2. 모든 곳에서 함수의 결과가 동일하므로, 식의 순서를 변경하더라도 결과는 변하지 않는다.

### 명령형 프로그래밍과 함수형 프로그래밍
* 부수효과를 기반으로 하는 프로그래밍 방식은 명령형 프로그래밍이며, 대부분의 프로그래밍 언어는 명령형 프로그래밍 언어의 범주에 속한다.
  * 대부분의 객체지향 언어 역시 상태를 변경시키는 연산들을 나열하며, 메시지에 의한 상태 변경에 집중하므로 명령형 프로그래밍 언어로 분류된다.
* 반면 함수형 프로그래밍은 부수효과가 존재하지 않는 수학적인 함수에 기반한다.
* 함수형 프로그래밍에서는 참조 투명성의 장점을 극대화할 수 있으며, 결과 명령형 프로그래밍에 비해 프로그램의 결과를 이해하고 예측하기 쉽다.

### 책임에 초점을 맞추기
* **상술한 모든 원칙을 준수하는 가장 쉬운 방법은 객체가 수행할 책임에 초점을 맞추고 메시지를 먼저 선택하는 것**이다.
  * 메시지를 먼저 선택하고, 그 후에 메시지를 처리할 객체를 선택하는 것은 디미터 법칙과 묻지 말고 시키기, 의도를 드러내는 인터페이스 설계를 준수하게 한다.
  * 구현에 앞서 객체 간의 협력에 초점을 맞추고, 협력 방식을 단순하고 유연하게 작성하는 것은 명령과 쿼리를 자연스럽게 분리하고 이를 명시적으로 드러낸다.
* 우리에게 중요한 것은 협력에 적합한 객체가 아닌 협력에 적합한 메시지이다.
  * 따라서, **훌륭한 메시지를 얻기 위한 출발점은 책임 주도 설계 원칙을 충실히 따르는 것**이다.
  * **책임 주도 설계 원칙은 메시지가 객체를 선택하므로, 협력에 적절한 메시지를 결정할 확률이 높다**.
```
> 책임 주도 설계 방법에 따라 메시지가 객체를 결정하게 하는 것으로 설계는 아름답고 깔끔해지며, 우아해보이기까지 한다.
```
# Objects
## 2022-04-09 Sat

## 계약에 의한 설계
* 의도를 드러내도록 인터페이스를 다듬고 명령과 쿼리를 분리했더라도 명령으로 인한 부수효과를 명확하게 표현하는 데에는 한계가 있다.
* 물론 메소드의 구현이 단순하다면 내부를 살펴보는 것만으로 부수효과를 이해할 수 있다.
  * 반면, 구현이 복잡하고 부수효과를 가진 다수의 메소드를 연이어 호출하는 코드를 분석하는 경우에는 실행 결과를 예측하기 어려울 수 밖에 없다.
* 즉, 인터페이스만으로는 객체의 행동에 관한 다양한 관점을 전달하기 어렵다.
  * 우리에게 **필요한 것은 명령의 부수효과를 주석보다 쉽고 명확하게 표현할 수 있는 커뮤니케이션 수단이며, 계약에 의한 설계는 좋은 예시**가 된다.
* 계약에 의한 설계를 적용하는 것으로 협력에 필요한 다양한 제약과 부수효과를 명시적으로 정의하고 문서화할 수 있다.
  * 클라이언트 개발자는 오퍼레이션의 구현을 확인하지 않더라도 객체의 사용법을 이해할 수 있게 된다.
  * 계약은 실행 가능하므로, 구현에 동기화되어 있는지 여부를 런타임에 검증할 수 있어 오래된 주석처럼 뒤처지는 걱정을 할 필요가 없다.
* 계약에 의한 설계는 클래스의 부수 효과를 명시적으로 문서화하고, 명확하게 커뮤니케이션할 수 있으며 실행 가능한 검증 도구로 사용할 수 있다.

### 부수 효과의 명시
* 객체지향의 핵심은 협력 안에서 객체들이 수행하는 행동이다.
* 그러나 프로그래밍 언어로 작성된 인터페이스는 객체가 수신할 수 있는 메시지를 명시할 수 있지만, 객체 간 의사소통 방식은 제어할 수 없다.
  * 즉, **메소드 시그니쳐를 통해 메시지를 전달하지만 협력을 위해 필요한 약속이나 제약 등은 인터페이스를 통해 전달할 수 없다**.
  * 때문에 협력과 관련된 상당한 절차는 암시적으로 남게 된다.
* 계약에 의한 설계를 지원하는 라이브러리를 활용하는 경우, 일반 로직과 구분할 수 있도록 제약 조건을 명시할 수 있다.
  * 이러한 방식을 사용하지 않는 일반 코드의 경우, 제약 조건을 기술하는 코드와 일반 분기문을 구분하기 어려우므로 반드시 코드를 분석해야 한다.
  * 계약에 의한 설계를 지원하는 라이브러리들은 작성된 제약 조건들을 코드로부터 추출하는 문서화를 지원하며, 조건의 만족 여부를 런타임에서 체크할 수 있다.
```
> 계약에 의한 설계를 사용하면 제약 조건을 명시적으로 표현하고, 조건을 자동으로 문서화하며 실행을 통해 검증할 수 있다.
```

### 계약
* 계약의 세부적인 내용은 상황에 따라 다르지만, 일반적으로는 다음과 같은 특성을 갖는다.
  1. 각 계약 당사자는 계약으로부터 이익을 기대하고, 이익을 위해 각자의 의무를 이행한다.
  2. 각 계약 당사자의 이익과 의무는 계약서에 문서화한다.
* 계약에서, 어느 한 쪽의 계약 당사자의 의무는 반대쪽 계약 당사자의 권리가 된다.
* 두 계약 당사자 중 어느 한 쪽이라도 계약서에 명시된 내용을 위반하는 경우, 계약은 정상적으로 완료되지 않는다.
* 일반적으로, 계약상 어느 한 쪽 계약 당사자가 고용주더라도 반대쪽 계약 당사자가 계약을 이행하는 구체적인 방식에 대해서는 간섭하지 않는다.
  * 즉, 피고용주는 자신의 계약 이행 방식을 자유롭게 결정할 수 있다.
* 이렇듯 계약은 협력을 명확하게 정의하고 소통할 수 있는 범용적인 아이디어이다.
  * 그렇다면, **두 당사자가 협력하기 위해 사용하는 계약이라는 아이디어를 객체들이 협력하는 방식에도 적용할 수 있지 않을까**?
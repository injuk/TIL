# Objects
## 2022-04-09 Sat

## 계약에 의한 설계
* 의도를 드러내도록 인터페이스를 다듬고 명령과 쿼리를 분리했더라도 명령으로 인한 부수효과를 명확하게 표현하는 데에는 한계가 있다.
* 물론 메소드의 구현이 단순하다면 내부를 살펴보는 것만으로 부수효과를 이해할 수 있다.
  * 반면, 구현이 복잡하고 부수효과를 가진 다수의 메소드를 연이어 호출하는 코드를 분석하는 경우에는 실행 결과를 예측하기 어려울 수 밖에 없다.
* 즉, 인터페이스만으로는 객체의 행동에 관한 다양한 관점을 전달하기 어렵다.
  * 우리에게 **필요한 것은 명령의 부수효과를 주석보다 쉽고 명확하게 표현할 수 있는 커뮤니케이션 수단이며, 계약에 의한 설계는 좋은 예시**가 된다.
* 계약에 의한 설계를 적용하는 것으로 협력에 필요한 다양한 제약과 부수효과를 명시적으로 정의하고 문서화할 수 있다.
  * 클라이언트 개발자는 오퍼레이션의 구현을 확인하지 않더라도 객체의 사용법을 이해할 수 있게 된다.
  * 계약은 실행 가능하므로, 구현에 동기화되어 있는지 여부를 런타임에 검증할 수 있어 오래된 주석처럼 뒤처지는 걱정을 할 필요가 없다.
* 계약에 의한 설계는 클래스의 부수 효과를 명시적으로 문서화하고, 명확하게 커뮤니케이션할 수 있으며 실행 가능한 검증 도구로 사용할 수 있다.

### 부수 효과의 명시
* 객체지향의 핵심은 협력 안에서 객체들이 수행하는 행동이다.
* 그러나 프로그래밍 언어로 작성된 인터페이스는 객체가 수신할 수 있는 메시지를 명시할 수 있지만, 객체 간 의사소통 방식은 제어할 수 없다.
  * 즉, **메소드 시그니쳐를 통해 메시지를 전달하지만 협력을 위해 필요한 약속이나 제약 등은 인터페이스를 통해 전달할 수 없다**.
  * 때문에 협력과 관련된 상당한 절차는 암시적으로 남게 된다.
* 계약에 의한 설계를 지원하는 라이브러리를 활용하는 경우, 일반 로직과 구분할 수 있도록 제약 조건을 명시할 수 있다.
  * 이러한 방식을 사용하지 않는 일반 코드의 경우, 제약 조건을 기술하는 코드와 일반 분기문을 구분하기 어려우므로 반드시 코드를 분석해야 한다.
  * 계약에 의한 설계를 지원하는 라이브러리들은 작성된 제약 조건들을 코드로부터 추출하는 문서화를 지원하며, 조건의 만족 여부를 런타임에서 체크할 수 있다.
```
> 계약에 의한 설계를 사용하면 제약 조건을 명시적으로 표현하고, 조건을 자동으로 문서화하며 실행을 통해 검증할 수 있다.
```

### 계약
* 계약의 세부적인 내용은 상황에 따라 다르지만, 일반적으로는 다음과 같은 특성을 갖는다.
  1. 각 계약 당사자는 계약으로부터 이익을 기대하고, 이익을 위해 각자의 의무를 이행한다.
  2. 각 계약 당사자의 이익과 의무는 계약서에 문서화한다.
* 계약에서, 어느 한 쪽의 계약 당사자의 의무는 반대쪽 계약 당사자의 권리가 된다.
* 두 계약 당사자 중 어느 한 쪽이라도 계약서에 명시된 내용을 위반하는 경우, 계약은 정상적으로 완료되지 않는다.
* 일반적으로, 계약상 어느 한 쪽 계약 당사자가 고용주더라도 반대쪽 계약 당사자가 계약을 이행하는 구체적인 방식에 대해서는 간섭하지 않는다.
  * 즉, 피고용주는 자신의 계약 이행 방식을 자유롭게 결정할 수 있다.
* 이렇듯 계약은 협력을 명확하게 정의하고 소통할 수 있는 범용적인 아이디어이다.
  * 그렇다면, **두 당사자가 협력하기 위해 사용하는 계약이라는 아이디어를 객체들이 협력하는 방식에도 적용할 수 있지 않을까**?

### 계약에 의한 설계 II
* 계약에 의한 설계에서, 계약은 협력에 참여하는 두 객체 사이의 의무와 이익을 문서화한 개념으로 다음과 같이 취급된다.
  1. 협력에 참여하는 각 객체는 이익을 기대하고, 이익을 위해 의무를 이행한다.
  2. **협력에 참여하는 각 객체의 이익과 의무는 객체의 인터페이스에 문서화**된다.
* 계약에 의한 설계는 인터페이스에 대한 프로그래밍 원칙의 확장이다.
  * 계약에 의한 설계를 통해 오퍼레이션의 시그니쳐를 구성하는 다양한 요소를 통해 협력에 참여하는 객체들이 지켜야하는 제약을 명시할 수 있다.
  * 또한, 이러한 제약을 인터페이스의 일부로 만드는 것으로 코드를 분석하지 않고도 인터페이스의 사용법을 이해할 수 있다.
* 메소드의 이름과 매개변수의 이름으로 구성되는 시그니쳐를 통해 오퍼레이션이 클라이언트에게 어떤 것을 제공하려는지 충분히 설명할 수 있다.
  * 즉, **의도를 드러내는 인터페이스를 통해 오퍼레이션 시그니쳐만으로도 클라이언트와 서버가 협력을 위해 수행하는 제약을 어느 정도는 명시**할 수 있다.
* 협력하는 객체들은 정상적인 상태를 갖는 상대 객체와 협력해야 하며, 이 과정에서 계약에 의한 설계를 구성하는 세 요소를 엿볼 수 있다.
  1. 사전조건: 서버는 자신이 처리할 수 있는 범위의 값들을 클라이언트가 전달할 것이라고 기대한다.
  2. 사후조건: 클라이언트는 자신이 원하는 값을 서버가 반환할 것이라고 기대한다.
  3. 불변식: 클라이언트는 메시지 전송 전과 후의 서버 상태가 정상일 것을 기대한다.
* 계약에 의한 설계를 구성하는 세 요소는 다음과 같은 의미로 이해할 수 있다.
  1. 사전조건이란 메소드가 호출되기 위해 만족되어야 하는 조건이며, 이를 만족하는 것은 클라이언트의 의무이다.
  2. 사후조건이란 메소드가 실행된 후에 클라이언트에게 보장해야 하는 조건이며, 이를 만족하는 것은 서버의 의무이다.
  3. 불변식이란 항상 참이라고 보장되는 서버의 조건이며, 메소드 실행 전 또는 후에 불변식은 항상 참이어야 한다.
* 상술한 세 요소를 기술할 때에는 실행 절차를 기술할 필요 없이 상태 변경만을 명시하므로, 코드의 이해와 분석이 쉬워진다.

### 사전조건
* 사전조건이란 메소드가 정상적으로 실행되기 위해 만족해야 하는 조건이며, 이를 만족시키는 것은 메소드를 실행하는 클라이언트의 의무이다.
  * 따라서 메소드가 실행되지 않는다면 클라이언트에 버그가 있다는 것을 의미한다.
  * 사전조건이 만족되지 않을 경우, 서버는 메소드를 실행할 의무가 없다.
* 일반적으로 사전조건은 메소드에 전달된 인자의 정합성을 체크하기 위해 사용한다.
  * 예를 들어, 클라이언트가 사전조건을 만족시키지 못하는 경우 메소드는 최대한 빨리 실패하여 클라이언트 버그를 알려야 한다.

### 사후조건
* 사후조건은 메소드의 실행 결과가 올바른지 검사하고, 실행 후에도 객체가 유효한 상태를 유지하는지 검증한다.
  * 따라서 사후조건을 통해 메소드를 호출한 후 무슨 일이 발생했는지 설명할 수 있게 된다.
* 클라이언트가 사전조건을 만족시켰음에도 서버가 사후조건을 만족시키지 못한다면, 이는 곧 서버에 버그가 있음을 의미한다.
* 일반적으로, 사후조건은 다음과 같은 용도로 사용된다.
  1. 인스턴스 변수의 상태가 올바른지 서술
  2. 메소드에 전달된 파라미터의 값이 올바르게 변경되었는지 서술
  3. 반환값이 올바른지 서술
* 일반적으로 다음과 같은 이우에 의해 사전조건보다 사후조건을 정의하는 것이 더 어려울 수 있다.
  1. 한 메소드 안에서 여러 개의 return 문이 나올 수 있으므로, 모든 return 문 마다 결과값이 올바른지 확인해야 한다.
  2. 실행 전의 값과 실행 후의 값을 비교해야할 수 있으나, 실행 전의 값이 메소드 실행으로 인해 변경되었을 수 있다.
* 그러나 계약에 의한 설계를 지원하는 라이브러리는 대부분 상술한 두 상황에 대응할 수 있는 방법을 제공한다.

### 불변식
* 사전조건과 사후조건은 각 메소드마다 다를 수 있으나, 불변식은 인스턴스 생명주기 전체에 걸쳐 지켜져야하는 규칙을 명시한다.
  * 때문에, 일반적으로 불변식은 객체 내부 상태와 관련이 있다.
* 또한, 불변식은 다음과 같은 특징을 갖는다.
  1. 불변식은 클래스의 모든 인스턴스가 생성된 후에 만족해야 하며, 때문에 클래스에 정의된 모든 생성자는 불변식을 준수해야 한다.
  2. 불변식은 클라이언트에 의해 호출 가능한 모든 메소드에 의해 준수되어야 하며, 적어도 메소드 실행 전과 실행 후에는 항상 불변식을 만족하는 상태여야 한다.
* 상술한 특징으로 인해, 불변식은 클래스의 모든 메소드의 사전조건과 사후조건에 추가되는 공통의 조건으로 생각할 수도 있다.
  * 불변식은 메소드가 실행되기 전에 사전조건과 함께 실행된다.
  * 불변식은 메소드가 실행된 후에 사후조건과 함께 실행된다.
* 즉, 불변식은 생성자 실행 후, 메소드 실행 전, 메소드 실행 후에 반드시 호출되어야 한다.
  * 결국 작성해야하는 코드의 양이 늘지만, 다행스럽게도 대부분의 계약에 의한 설계를 지원하는 라이브러리는 이러한 코드를 자동으로 추가해준다. 

## 2022-04-10 Sun
### 계약에 의한 설계와 서브타이핑
* 상술했듯, 계약에 의한 설계의 핵심은 클라이언트와 서버 사이의 견고한 협력을 위해 준수해야하는 규약을 정희하는 것이다.
* 클라이언트라는 단어에 초점을 맞출 경우, 게약에 의한 설계와 리스코프 치환 원칙이 맞닿는 지점을 확인할 수 있다.
  * 리스코프 치환 원칙이란, 슈퍼타입의 인스턴스와 협력하는 클라이언트의 관점에서 서브타입의 인스턴스가 슈퍼타입을 대체하더라도 협력에 가능함을 의미한다.
* 즉, 둘을 조합하면 **서브타입이 리스코프 치환 원칙을 준수할 수 있으려면 클라이언트와 슈퍼타입 간에 맺어진 계약을 준수해야한다는 뜻**과 같다.
* **리스코프 치환 원칙의 규칙은 협력에 참여하는 객체에 대한 기대를 나타내는 계약 규칙과, 교체 가능한 타입과 관련된 가변성 규칙으로 세분화**할 수 있다.
  1. 계약 규칙이란, 슈퍼타입과 서브타입 사이의 사전조건, 사후조건, 불변식에 대해 서술할 수 있는 제약에 관한 규칙이다.
     1. 서브타입에 더 강력한 사전조건을 정의할 수 없다.
     2. 서브타입에 더 완화된 사후조건을 정의할 수 없다.
     3. 슈퍼타입의 불변식은 서브타입에서도 반드시 유지되어야 한다.
  2. 가변성 규칙이란, 파라미터와 리턴 타입의 변형과 관련된 규칙이다.
     1. 서브타입의 메소드 파라미터는 반공변성을 지녀야 한다.
     2. 서브타입의 리턴 타입은 공변성을 가져야 한다.
     3. 서브타입은 슈퍼타입이 발생시키는 예외와 다른 타입의 예외를 발생시키지 않아야 한다.

### 슈퍼타입의 불변식은 서브타입에서도 반드시 유지하기
* 불변식은 메소드가 실행되기 전과 후에 반드시 만족해야하는 조건을 가리킨다.
  * 모든 객체는 객체가 생성된 직후부터 소멸될 때까지 불변식을 만족시켜야 한다.
  * 예를 들어, 클래스로부터 생성된 인스턴스의 인스턴스 변수 중 null이 아니어야 하는 변수 등 특정 상태를 만족시켜야하는 경우를 말한다.
* protected로 정의된 인스턴스 변수의 경우, 생성자에서 null 체크를 수행하더라도 자식 클래스에서 해당 값을 수정하여 불변식을 깨트릴 가능성이 존재한다.
  * 이는 계약의 관점에서 캡슐화의 중요성을 잘 보여준다.
  * 자식 클래스가 계약을 위반할 수 있는 코드를 작성하지 못하도록 모든 인스턴스 변수의 가시성은 private 이어야 한다.
* 만약 **자식 클래스에서 부모 클래스의 인스턴스 변수의 상태를 변경하고 싶다면, protected 접근자 메소드를 제공하되 해당 메소드에서 불변식을 검사**한다.

### 가변성 규칙
* 가변성 규칙은 중요도에 비해 대부분의 개발자들이 관심을 갖지 않는 항목이지만, 리스코프 치환 원칙을 깊이 이해하기 위해서는 해당 규칙을 이해하는 것이 좋다.

### 서브타입은 슈퍼타입이 발생시키는 예외와 다른 타입의 예외를 발생시키지 않아야 한다.
* 일반적으로 **부모 클래스가 던지는 예외가 속한 상속 계층과 다른 계층에 속하는 예외를 던지는 자식 클래스는 서브타입이 아니며, 부모를 대체할 수 없다**.
* 클라이언트 관점에서 자식 클래스가 부모 클래스가 수행하는 일보다 적은 일을 수행하는 경우, 이는 부모 클래스와 동일하다고 볼 수 없다.
* 즉, 클라이언트 관점에서 부모 클래스보다 못한 자식 클래스는 서브타입이 아니다.

### 서브타입의 리턴 타입은 공변성을 가져야 한다.
* T의 서브타입 클래스 S의 관계에서, 두 타입의 치환 가능성에 따라 공변성, 반공변성, 무공변성은 각각 다음과 같은 의미를 갖는다.
  1. 공변성: S와 T 사이의 서브타입 관계는 유지되며, S는 T 대신 사용될 수 있다.
  2. 반공변성: S와 T 사이의 서브타입 관계가 역전되며, T가 S 대신 사용될 수 있다.
  3. 무공변성: S와 T 사이의 아무런 관계가 존재하지 않으므로, 서로를 어떠한 방식으로도 대체할 수 없다.
* 부모 클래스에서 구현된 메소드를 자식 클래스가 오버라이딩하는 경우, 부모 클래스에서 선언한 반환 타입의 서브타입을 반환 타입으로 지정할 수 있다.
  * 이는 **리턴 타입 공변성에 해당하며, 메소드를 구현하는 클래스의 타입 계층 방향과 리턴 타입의 타입 계층의 방향이 동일한 경우**이다.
* 리스코프 치환 원칙과 관련된 계약 규칙에서, 서브타입에서 메소드의 사후조건은 강화될 수 있다.
  * **리턴 타입 공변성은 서브타입을 반환하므로 더 강력한 사후조건을 정의하는 것과 같고, 따라서 계약을 위반하지 않는다**.
  * 이론적으로는 메소드 리턴 타입을 공변적으로 정의하는 것으로 리스코프 치환 원칙을 만족할 수 있으나, 실제로는 언어의 공변 개념 지원 여부에 따라 결정된다.

### 서브타입의 메소드 파라미터는 반공변성을 가져야 한다.
* 파라미터 타입 반공변성이란, 다음과 같은 의미를 갖는다.
  * 부모 클래스에서 구현된 메소드를 자식 클래스에서 오버라이딩하는 경우, 파라미터 타입을 부모 클래스에서 사용한 파라미터의 슈퍼타입으로 지정할 수 있다.
  * Java에서는 지원되지 않는 개념이다.
* 즉, **파라미터 타입 반공변성이란 메소드를 정의한 클래스의 타입 계층과 파라미터의 타입 계층이 반대 방향인 경우 서브타입 관계를 만족한다는 것을 의미**한다.
* 리스코프 치환 원칙과 관련된 계약 규칙에서, 서브타입에서 메소드의 사전조건이 약화되더라도 클라이언트의 입장에는 영향이 없다.
  * 서브타입 대신 슈퍼타입을 파라미터로 전달받는 것은 더 약한 사전조건을 정의하는 것과 같다.
  * 따라서, 파라미터 타입 반공변성은 계약에 의한 설계 관점에서 계약을 위반하지 않는다.

### 리턴 타입 공변성과 파라미터 타입 반공변성
* 상술한 두 개념은 사전조건과 사후조건 관점에서 설명할 수 있다.
  * 서브타입은 슈퍼타입에서 정의한 것보다 더 강력한 사전조건을 정의할 수 없지만, 더 약한 사후조건은 정의할 수 있다.
* **사전조건은 파라미터에 대한 제약조건이므로, 슈퍼타입에서 정의한 파라미터 타입에 대한 계약 조건을 완화할 수 있다**.
  * 때문에 더 완화된 슈퍼타입을 파라미터로 전달받을 수 있다.
* 사후조건은 리턴 타입과 관련이 있는 제약조건이므로, 서브타입은 슈퍼타입에서 정의한 사후조건을 완화할 수 없다.
  * 그러나 **사후조건을 강화할 수는 있으므로 슈퍼타입에서 정의한 리턴 타입보다 더 강화된 서브타입 인스턴스를 반환하는 것은 가능**하다.
* 객체지향 언어 중 파라미터 반공변성을 지원하는 언어는 거의 없으나, 제네릭 프로그래밍에서는 중요한 의미를 갖는다.

### 함수타입과 서브타이핑
* 최근의 객체지향 언어들은 이름 없는 메소드를 정의할 수 있는 기능을 익명 함수, 함수 리터럴, 람다 표현식 등의 이름으로 제공한다.
* **이름 없는 메소드를 정의할 수 있도록 지원하는 언어들은 객체의 타입 뿐만 아니라 메소드의 타입까지도 정의할 수 있도록 허용**한다.
  * 또한, 타입에서 정의한 시그니쳐를 준수하는 메소드를 해당 타입의 인스턴스로 간주한다.
* 마치 객체의 서브타입이 슈퍼타입을 대체할 수 있는것처럼, 메소드 역시 같은 기능을 다음과 같이 제공한다.
  1. **메소드에 대한 타입을 정의할 수 있으므로, 메소드 타입의 서브타입을 정의할 수 있다**.
  2. **서브타입 메소드는 슈퍼타입 메소드를 대체할 수 있다**.
* **파라미터 타입이 반공변성을 갖고 리턴 타입이 공변성을 갖는다면 메소드는 오버라이딩 가능**하다.
  * **메소드가 오버리이딩 가능하다면 메소드가 대체 가능하다는 것과 같으므로, 두 메소드 사이에 서브타이핑 관계가 존재함을 의미**한다.
* **두 메소드의 파라미터와 리턴 타입을 비교했을 때, 어느 한 쪽의 메소드의 파라미터가 슈퍼타입이고 리턴 타입이 서브타입이라면 해당 메소드는 서브타입**이다.
* 그러나 서브타입 관계를 구현하는 방식은 언어마다 다르므로, 우선 자신이 사용하는 언어가 함수 타입에 대한 서브타입 관계를 준수하는지 확인할 필요가 있다.

### 계약에 의한 설계 관점에서의 리스코프 치환 원칙
* **서브타입이 슈퍼타입을 치환할 수 있다는 것은 계약에 의한 설계에서 정의한 계약 규칙과 가변성 규칙을 준수하는 것을 의미**한다.
* 진정한 서브타이핑 관계를 만들고 싶다면 다음과 같은 규칙을 반드시 준수하도록 한다.
  1. 서브타입에 더 강력한 사전조건 또는 더 완화된 사후조건을 정의하지 않는다.
  2. 슈퍼타입의 불변식을 유지하기 위해 노력한다.
  3. 서브타입에서 슈퍼타입에서 정의하지 않은 예외를 던지지 않도록 정의한다.
* **자신이 사용하는 언어가 메소드 파라미터에 대한 반공변성과 리턴 타입에 대한 공변성을 지원하는 경우, 이를 서브타이핑 관점에 활용할 수 있는지 고민**한다.
  * 게약에 의한 설계를 지원하는 프레임워크를 사용하지 않더라도 치환 가능한 타입 계층을 구축하는 경우라면 계약에 의한 설계 관점을 고려할 수 있다. 
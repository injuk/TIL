# Objects
## 2022-04-09 Sat

## 계약에 의한 설계
* 의도를 드러내도록 인터페이스를 다듬고 명령과 쿼리를 분리했더라도 명령으로 인한 부수효과를 명확하게 표현하는 데에는 한계가 있다.
* 물론 메소드의 구현이 단순하다면 내부를 살펴보는 것만으로 부수효과를 이해할 수 있다.
  * 반면, 구현이 복잡하고 부수효과를 가진 다수의 메소드를 연이어 호출하는 코드를 분석하는 경우에는 실행 결과를 예측하기 어려울 수 밖에 없다.
* 즉, 인터페이스만으로는 객체의 행동에 관한 다양한 관점을 전달하기 어렵다.
  * 우리에게 **필요한 것은 명령의 부수효과를 주석보다 쉽고 명확하게 표현할 수 있는 커뮤니케이션 수단이며, 계약에 의한 설계는 좋은 예시**가 된다.
* 계약에 의한 설계를 적용하는 것으로 협력에 필요한 다양한 제약과 부수효과를 명시적으로 정의하고 문서화할 수 있다.
  * 클라이언트 개발자는 오퍼레이션의 구현을 확인하지 않더라도 객체의 사용법을 이해할 수 있게 된다.
  * 계약은 실행 가능하므로, 구현에 동기화되어 있는지 여부를 런타임에 검증할 수 있어 오래된 주석처럼 뒤처지는 걱정을 할 필요가 없다.
* 계약에 의한 설계는 클래스의 부수 효과를 명시적으로 문서화하고, 명확하게 커뮤니케이션할 수 있으며 실행 가능한 검증 도구로 사용할 수 있다.

### 부수 효과의 명시
* 객체지향의 핵심은 협력 안에서 객체들이 수행하는 행동이다.
* 그러나 프로그래밍 언어로 작성된 인터페이스는 객체가 수신할 수 있는 메시지를 명시할 수 있지만, 객체 간 의사소통 방식은 제어할 수 없다.
  * 즉, **메소드 시그니쳐를 통해 메시지를 전달하지만 협력을 위해 필요한 약속이나 제약 등은 인터페이스를 통해 전달할 수 없다**.
  * 때문에 협력과 관련된 상당한 절차는 암시적으로 남게 된다.
* 계약에 의한 설계를 지원하는 라이브러리를 활용하는 경우, 일반 로직과 구분할 수 있도록 제약 조건을 명시할 수 있다.
  * 이러한 방식을 사용하지 않는 일반 코드의 경우, 제약 조건을 기술하는 코드와 일반 분기문을 구분하기 어려우므로 반드시 코드를 분석해야 한다.
  * 계약에 의한 설계를 지원하는 라이브러리들은 작성된 제약 조건들을 코드로부터 추출하는 문서화를 지원하며, 조건의 만족 여부를 런타임에서 체크할 수 있다.
```
> 계약에 의한 설계를 사용하면 제약 조건을 명시적으로 표현하고, 조건을 자동으로 문서화하며 실행을 통해 검증할 수 있다.
```

### 계약
* 계약의 세부적인 내용은 상황에 따라 다르지만, 일반적으로는 다음과 같은 특성을 갖는다.
  1. 각 계약 당사자는 계약으로부터 이익을 기대하고, 이익을 위해 각자의 의무를 이행한다.
  2. 각 계약 당사자의 이익과 의무는 계약서에 문서화한다.
* 계약에서, 어느 한 쪽의 계약 당사자의 의무는 반대쪽 계약 당사자의 권리가 된다.
* 두 계약 당사자 중 어느 한 쪽이라도 계약서에 명시된 내용을 위반하는 경우, 계약은 정상적으로 완료되지 않는다.
* 일반적으로, 계약상 어느 한 쪽 계약 당사자가 고용주더라도 반대쪽 계약 당사자가 계약을 이행하는 구체적인 방식에 대해서는 간섭하지 않는다.
  * 즉, 피고용주는 자신의 계약 이행 방식을 자유롭게 결정할 수 있다.
* 이렇듯 계약은 협력을 명확하게 정의하고 소통할 수 있는 범용적인 아이디어이다.
  * 그렇다면, **두 당사자가 협력하기 위해 사용하는 계약이라는 아이디어를 객체들이 협력하는 방식에도 적용할 수 있지 않을까**?

### 계약에 의한 설계 II
* 계약에 의한 설계에서, 계약은 협력에 참여하는 두 객체 사이의 의무와 이익을 문서화한 개념으로 다음과 같이 취급된다.
  1. 협력에 참여하는 각 객체는 이익을 기대하고, 이익을 위해 의무를 이행한다.
  2. **협력에 참여하는 각 객체의 이익과 의무는 객체의 인터페이스에 문서화**된다.
* 계약에 의한 설계는 인터페이스에 대한 프로그래밍 원칙의 확장이다.
  * 계약에 의한 설계를 통해 오퍼레이션의 시그니쳐를 구성하는 다양한 요소를 통해 협력에 참여하는 객체들이 지켜야하는 제약을 명시할 수 있다.
  * 또한, 이러한 제약을 인터페이스의 일부로 만드는 것으로 코드를 분석하지 않고도 인터페이스의 사용법을 이해할 수 있다.
* 메소드의 이름과 매개변수의 이름으로 구성되는 시그니쳐를 통해 오퍼레이션이 클라이언트에게 어떤 것을 제공하려는지 충분히 설명할 수 있다.
  * 즉, **의도를 드러내는 인터페이스를 통해 오퍼레이션 시그니쳐만으로도 클라이언트와 서버가 협력을 위해 수행하는 제약을 어느 정도는 명시**할 수 있다.
* 협력하는 객체들은 정상적인 상태를 갖는 상대 객체와 협력해야 하며, 이 과정에서 계약에 의한 설계를 구성하는 세 요소를 엿볼 수 있다.
  1. 사전조건: 서버는 자신이 처리할 수 있는 범위의 값들을 클라이언트가 전달할 것이라고 기대한다.
  2. 사후조건: 클라이언트는 자신이 원하는 값을 서버가 반환할 것이라고 기대한다.
  3. 불변식: 클라이언트는 메시지 전송 전과 후의 서버 상태가 정상일 것을 기대한다.
* 계약에 의한 설계를 구성하는 세 요소는 다음과 같은 의미로 이해할 수 있다.
  1. 사전조건이란 메소드가 호출되기 위해 만족되어야 하는 조건이며, 이를 만족하는 것은 클라이언트의 의무이다.
  2. 사후조건이란 메소드가 실행된 후에 클라이언트에게 보장해야 하는 조건이며, 이를 만족하는 것은 서버의 의무이다.
  3. 불변식이란 항상 참이라고 보장되는 서버의 조건이며, 메소드 실행 전 또는 후에 불변식은 항상 참이어야 한다.
* 상술한 세 요소를 기술할 때에는 실행 절차를 기술할 필요 없이 상태 변경만을 명시하므로, 코드의 이해와 분석이 쉬워진다.

### 사전조건
* 사전조건이란 메소드가 정상적으로 실행되기 위해 만족해야 하는 조건이며, 이를 만족시키는 것은 메소드를 실행하는 클라이언트의 의무이다.
  * 따라서 메소드가 실행되지 않는다면 클라이언트에 버그가 있다는 것을 의미한다.
  * 사전조건이 만족되지 않을 경우, 서버는 메소드를 실행할 의무가 없다.
* 일반적으로 사전조건은 메소드에 전달된 인자의 정합성을 체크하기 위해 사용한다.
  * 예를 들어, 클라이언트가 사전조건을 만족시키지 못하는 경우 메소드는 최대한 빨리 실패하여 클라이언트 버그를 알려야 한다.

### 사후조건
* 사후조건은 메소드의 실행 결과가 올바른지 검사하고, 실행 후에도 객체가 유효한 상태를 유지하는지 검증한다.
  * 따라서 사후조건을 통해 메소드를 호출한 후 무슨 일이 발생했는지 설명할 수 있게 된다.
* 클라이언트가 사전조건을 만족시켰음에도 서버가 사후조건을 만족시키지 못한다면, 이는 곧 서버에 버그가 있음을 의미한다.
* 일반적으로, 사후조건은 다음과 같은 용도로 사용된다.
  1. 인스턴스 변수의 상태가 올바른지 서술
  2. 메소드에 전달된 파라미터의 값이 올바르게 변경되었는지 서술
  3. 반환값이 올바른지 서술
* 일반적으로 다음과 같은 이우에 의해 사전조건보다 사후조건을 정의하는 것이 더 어려울 수 있다.
  1. 한 메소드 안에서 여러 개의 return 문이 나올 수 있으므로, 모든 return 문 마다 결과값이 올바른지 확인해야 한다.
  2. 실행 전의 값과 실행 후의 값을 비교해야할 수 있으나, 실행 전의 값이 메소드 실행으로 인해 변경되었을 수 있다.
* 그러나 계약에 의한 설계를 지원하는 라이브러리는 대부분 상술한 두 상황에 대응할 수 있는 방법을 제공한다.

### 불변식
* 사전조건과 사후조건은 각 메소드마다 다를 수 있으나, 불변식은 인스턴스 생명주기 전체에 걸쳐 지켜져야하는 규칙을 명시한다.
  * 때문에, 일반적으로 불변식은 객체 내부 상태와 관련이 있다.
* 또한, 불변식은 다음과 같은 특징을 갖는다.
  1. 불변식은 클래스의 모든 인스턴스가 생성된 후에 만족해야 하며, 때문에 클래스에 정의된 모든 생성자는 불변식을 준수해야 한다.
  2. 불변식은 클라이언트에 의해 호출 가능한 모든 메소드에 의해 준수되어야 하며, 적어도 메소드 실행 전과 실행 후에는 항상 불변식을 만족하는 상태여야 한다.
* 상술한 특징으로 인해, 불변식은 클래스의 모든 메소드의 사전조건과 사후조건에 추가되는 공통의 조건으로 생각할 수도 있다.
  * 불변식은 메소드가 실행되기 전에 사전조건과 함께 실행된다.
  * 불변식은 메소드가 실행된 후에 사후조건과 함께 실행된다.
* 즉, 불변식은 생성자 실행 후, 메소드 실행 전, 메소드 실행 후에 반드시 호출되어야 한다.
  * 결국 작성해야하는 코드의 양이 늘지만, 다행스럽게도 대부분의 계약에 의한 설계를 지원하는 라이브러리는 이러한 코드를 자동으로 추가해준다. 
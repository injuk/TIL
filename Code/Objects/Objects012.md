# Objects
## 2022-04-05 Tue

## 다형성
* 앞서 다룬 바와 같이 코드 재사용을 목적으로 상속을 사용하면 변경이 어렵고 유연하지 않은 설계를 얻기 쉽다.
  * 즉, **상속의 목적은 재사용이 아니다**!
* **상속은 타입 계층을 구조화하기 위해서만 사용해야 하며, 이렇게 정의된 타입 계층은 객체지향 프로그래밍의 중요한 특성인 다형성의 기반을 제공**한다.
```
> 상속을 이용한 클래스를 추가하는 경우, 반드시 상속의 용도를 자문하도록 한다.
> 코드 재사용을 목적으로 한다면, 상속을 사용하지 않아야 한다.
> 클라이언트 관점에서 동일하게 행동하는 인스턴스들을 그룹화하기 위해서라면, 상속을 사용해도 무방하다.
```

### 다형성의 이해
* 컴퓨터 과학에서의 다형성이란, 하나의 추상 인터페이스에 코드를 작성하고 해당 추상 인터페이스에 대해 서로 다른 구현을 연결할 수 있는 능력으로 정의된다.
  * 즉, 다형성은 여러 타입을 대상으로 동작할 수 있는 코드를 작성할 수 있는 능력이다.
* 객체지향 프로그래밍에서 사용되는 다형성은 크게 다음과 같은 갈래로 세분화된다.
  1. 유니버설 다형성
     1. 매개변수 다형성
     2. 포함 다형성
  2. 임시 다형성
     1. 오버로딩 다형성
     2. 강제 다형성
* 오버로딩 다형성이란, 하나의 클래스 안에 동일한 이름의 메소드가 여럿 존재하는 경우를 말한다.
* 강제 다형성이란, 언어가 지원하는 자동적인 타입 변환이나 사용자가 구현한 타입 변환을 통해 동일한 연산자를 다양한 타입에 사용할 수 있는 경우를 말한다.
  * Java의 예로 들어, + 연산자는 정수 연산과 문자열이 포함된 연산에서 다르게 동작한다.
* 매개변수 다형성이란 제네릭과 관련이 깊으며, 다양한 타입의 요소를 다루기 위해 동일한 오퍼레이션을 사용하는 경우를 말한다.
  * 클래스의 인스턴스 변수나 메소드 매개변수 타입을 임의의 타입으로 선언한 후, 실제로 사용하는 시점에 구체적인 타입을 지정하는 방식이다.
* 포함 다형성이란 서브타입 다형성으로도 불리우며, 동일한 메시지가 수신 객체에 따라 실제로 수행되는 기능이 달라지는 경우를 말한다.
  * **가장 널리 알려진 형태의 다형성이므로, 일반적으로 다형성이라는 말이 가리키는 것은 포함 다형성**이다.

### 포함 다형성
* 포함 다형성을 구현하는 가장 일반적인 방법은 상속을 활용하는 것이다.
  * 자식 클래스에서 부모 클래스의 메소드를 오버라이딩한 후 클라이언트가 부모 클래스를 참조하도록 한다.
* **포함 다형성은 서브타입 다형성이라고도 불리우며, 이는 포함 다형성을 위한 전제로서 자식 클래스가 부모 클래스의 서브타입이어야 한다는 점을 의미**한다.
  * **상속의 진정한 목적은 코드 재사용이 아닌, 다형성을 위한 서브타입 계층을 구축하는 것**이다!
* 포함 다형성을 위해 상속을 사용하는 가장 큰 이유는 상속이 클래스들을 계층화한 후, 상황에 따라 적절한 메소드를 선택하는 메커니즘을 제공하기 때문이다.

### 상속의 용도
* **객체지향 패러다임의 근간을 이루는 아이디어는 데이터와 행동을 객체라는 하나의 단위로 묶는 것**이다.
  * 즉, 객체지향 프로그램을 작성하려면 항상 데이터와 행동 관점을 함께 고려해야 한다.
* **상속 역시 해당 원칙의 예외가 될 수 없으며, 이에 따라 다음과 같은 목적을 가지리라고 오해**할 수 있다.
  1. 데이터 관점의 상속: 부모 클래스의 모든 데이터를 자식 클래스가 자동으로 포함한다.
  2. 행동 관점의 상속: 부모 클래스에 정의된 일부 메소드를 자식 클래스에 포함시킬 수 있다.
* 데이터와 행동 관점에서만 바라본 상속은 마치 코드 재사용에 목적이 있는 것 처럼 보이지만, 이 경우 이해하기 어렵고 유지보수성이 떨어지는 코드를 만들기 쉽다.
```
> 상속은 프로그램을 구성하는 개념들을 기반으로 다형성을 가능케하는 타입 계층을 구축하기 위해 존재하는 기능이다.
```

### 데이터 관점의 상속
* **개념적으로 자식 클래스를 인스턴스화했을 경우, 인스턴스 내부에 부모 클래스의 인스턴스가 포함되는 식으로 생각하는 것이 유용**하다.
  * 실제로 객체를 메모리에 생성하는 방식이나 구조는 언어나 실행 환경에 따라 다르다!
* 인스턴스를 참조하는 변수는 자식 클래스를 가리키므로, 특별한 방법을 사용하지 않으면 자식 클래스 내부에 포함된 부모 클래스의 인스턴스 직접 접근할 수는 없다.
* 이렇듯 **데이터 관점에서의 상속은 자식 클래스의 인스턴스 안에 부모 클래스의 인스턴스를 포함하는 것**이다.
  * 때문에 자식 클래스의 인스턴스는 자동으로 부모 클래스에 정의된 모든 인스턴스 변수를 내부에 포함하게 된다.

### 행동 관점의 상속
* 상술했듯, 데이터 관점의 상속은 자식 클래스의 인스턴스 안에 부모 클래스의 인스턴스를 포함하는 개념이다.
* 그러나 **행동 관점의 상속은 부모 클래스가 정의한 일부 메소드를 자식 클래스의 메소드에 포함시키는 것을 의미**한다. 
* 일반적으로 부모 클래스의 모든 퍼블릭 메소드는 자식 클래스의 퍼블릭 인터페이스에 포함된다.
  * 때문에 외부의 객체가 부모 클래스의 인스턴스에 전송할 수 있는 모든 메시지는 자식 클래스의 인스턴스에도 전송할 수 있다.
* 부모 클래스에 정의되어 있지만 자식 클래스에는 정의하지 않은 메소드를 호출하는 경우, 호출 대상 메소드는 런타임에 결정된다.
  * **자식 클래스에 정의되지 않은 메소드는 시스템이 런타임에 부모 클래스 안에서 탐색하는 식으로 동작**한다.
* 객체의 경우 서로 다른 상태를 저장할 수 있도록 인스턴스 별로 독립된 메모리 공간을 할당받아야만 한다.
* 반면 **메소드의 경우, 동일한 클래스의 인스턴스끼리 공유가 가능하므로 클래스는 하나만 메모리에 로드**한다.
  * 이후 **각 인스턴스는 클래스를 가리키는 포인터를 갖는다**.
* **각 객체는 자신의 클래스의 위치를 가리키는 class라는 이름의 포인터를 갖고, 이 포인터를 활용하여 자신의 클래스 정보에 접근할 수 있다**.
* 또한 각 클래스는 자신의 부모를 가리키는 parent라는 이름의 포인터도 가지며, 이를 통해 클래스의 상속 계층에 따라 부모 클래스의 정의로 이동할 수 있다.
* 상술한 정보를 토대로, 자식 클래스의 인스턴스를 통해 부모 클래스에 정의된 메소드를 호출할 경우 다음과 같은 순서로 실행된다.
  1. **메시지를 수신한 객체는 class 포인터로 연결된 자신의 클래스에서 적절한 메소드를 찾는다**.
  2. **메소드가 존재하지 않는 경우, 자신의 클래스에 포함된 parent 포인터를 활용하여 부모 클래스의 메소드를 차례로 탐색**한다.
     * 이러한 탐색 흐름은 최상위 부모 클래스인 Object에 이르기까지 반복된다.
  3. 적절한 메소드가 있는 경우, 실행한다.

### 업캐스팅과 동적 바인딩
* 코드 안에 선언된 참조 타입과 무관하게 실제로 메시지를 수신하는 객체의 타입에 따라 실행되는 메소드는 달라질 수 있다.
  * 이러한 동작을 뒷받침하는 것은 업캐스팅과 동적 바인딩이다.
* 업캐스팅이란, 부모 클래스 타입으로 선언된 변수에 자식 클래스의 인스턴스를 할당하는 것이다.
* 동적 바인딩이란, 선언된 변수의 타입이 아닌 실제로 메시지를 수신하는 객체의 타입에 따라 실행되는 메소드가 결정되는 것이다.
  * 이는 **객체지향 시스템이 메시지를 처리할 메소드를 컴파일타임이 아닌 런타임에서 결정하기 때문에 가능**하다.
* 업캐스팅은 서로 다른 클래스의 인스턴스를 같은 타입에 할당하는 것을 가능케하므로, 부모 클래스에 작성된 코드를 수정하지 않고도 자식 클래스에 적용할 수 있다.
* **동적 메소드 탐색은 부모 클래스의 타입에 대해 메시지를 전송했더라도, 실행 시에는 실제 클래스를 기반으로 실행될 메소드가 선택되게 한다**.
  * 따라서, 코드를 수정하지 않고도 실행되는 메소드를 변경할 수 있다.

### 업캐스팅
* 상속을 이용하면 부모 클래스의 퍼블릭 인터페이스가 자식 클래스와 합쳐지므로, 부모 인스턴스에게 전달할 수 있는 메시지는 자식에게도 절달할 수 있다.
* 컴파일러는 명시적인 타입 변환 없이 자식 클래스가 부모 클래스를 대체할 수 있도록 허용한다.
  * 이러한 특징을 활용할 수 있는 대표적인 두 방식은 대입문과 메소드의 파라미터 타입이다.
  * 이렇듯 **모든 객체지향 언어는 명시적인 타입 변환 없이도 부모 클래스 타입의 참조 변수에 자식 클래스의 인스턴스를 대입할 수 있도록 한다**.
* 반대로 부모 클래스의 인스턴스를 자식 클래스 타입으로 변경하기 위해서는 명시적인 타입 캐스팅이 필요하며, 이는 다운캐스팅에 해당한다.
* 컴파일러 관점에서, 자식 클래스는 아무런 제약 없이 부모 클래스를 대체할 수 있다.
  * 따라서 부모 클래스와 협력하는 클라이언트는 다양한 자식 클래스의 인스턴스와 협력할 수 있다.
  * **여기서 자식 클래스란, 현자 상속 계층에 포함된 클래스 뿐만 아니라 앞으로 추가될지도 모르는 미래의 자식 클래스까지 포함**한다.
* 이러한 특징 덕에 **업캐스팅은 어떠한 자식 클래스와도 협력을 가능케하는 무한한 확장 가능성을 갖고, 따라서 설계는 유연하고 확장 가능**하다.

### 동적 바인딩
* 전통적인 언어들은 코드를 작성하는 시점에 호출될 함수가 결정되므로, 컴파일타임에 함수를 결정한다.
  * 이렇듯 컴파일타임에 호출할 수 있는 함수를 결정하는 방식은 정적 바인딩 또는 컴파일타임 바인딩이라고 부른다.
* 반면 객체지향 언어에서는 메시지를 수신했을 때 실행될 메소드가 런타임에 결정된다.
  * 이렇듯 실행될 메소드가 런타임에 결정되는 방식을 동적 바인딩 또는 지연 바인딩이라고 부른다.
* **객체지향 언어가 제공하는 업캐스팅과 동적 바인딩을 활용하면 부모 클래스 참조에 대한 메시지 전송을 자식 클래스에 대한 메소드 호출로 변환**할 수 있다.
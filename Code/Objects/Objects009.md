# Objects
## 2022-04-02 Sat

## 유연한 설계
### 개방 폐쇄 원칙
```
> 클래스, 모듈, 함수 등의 소프트웨어 개체는 확장에 대해 열려 있어야 하고, 수정에 대해서는 닫혀 있어야 한다. 
```
* 개방 폐쇄 원칙은 확장 가능하고, 변화에 유연하게 대응할 수 있는 설계를 만들 수 있는 원칙 중 하나이다.
* 키워드는 확장과 수정이며, 둘은 각각 애플리케이션의 동작과 코드의 관점을 다음과 같이 반영한다.
  1. 확장에 대해 열림: **애플리케이션의 요구사항이 변경될 때, 변경에 맞는 새로운 동작을 추가하여 기능을 확장**할 수 있다.
  2. 수정에 대해 닫힘: **코드를 수정하지 않고도 애플리케이션의 동작을 추가하거나 변경**할 수 있다.
* 개방 폐쇄 원칙을 준수하는 코드는 기존 코드를 전혀 수정하지 않은 채 새로운 클래스를 추가하는 것으로 애플리케이션의 동작을 확장할 수 있다.
  * 개방 폐쇄 원칙이 말하는 유연한 설계란, 기존의 코드를 수정하지 않고도 애플리케이션의 동작을 확장할 수 있는 설계를 말한다.

### 컴파일타임 의존성의 고정과 런타임 의존성의 변경
* 개방 폐쇄 원칙은 런타임 의존성과 컴파일타임 의존성과 관련된 이야기이다.
* 앞서 다룬 바와 같이, 유연하고 재사용 가능한 설계의 런타임 의존성과 컴파일타임 의존성은 서로 다른 구조를 갖는다.
* **개방 폐쇄 원칙을 준수하는 코드는 컴파일타임 의존성을 수정하지 않고도 런타임 의존성을 쉽게 변경**할 수 있다.
  * **의존성 관점에서 개방 폐쇄 원칙을 준수하는 설계란, 컴파일타임 의존성을 유지하면서 런타임 의존성의 가능성을 확장 또는 수정할 수 있는 구조**이다.

### 추상화가 핵심이다
* 개방 폐쇄 원칙의 핵심은 추상화에 의존하는 것이다.
* **추상화 과정을 거치면 문맥이 바뀌더라도 변하지 않는 부분만 남으며, 문맥에 따라 변하는 부분은 생략**될 수 있다.
  * 추상화를 사용하면 생략된 부분을 문맥에 적절한 내용으로 구현하여 각 문맥에 적합한 기능을 구체화하고 확장할 수 있다.
* 개방 폐쇄 원칙의 관점에서, 생략되지 않고 남겨지는 부분은 다양한 문맥에서의 공통점이 반영된 추상화의 결과이다.
  * **이러한 공통 부분은 문맥이 교체되더라도 변경되지 않아야 한다**.
  * 즉, **공통 부분은 수정할 필요가 없어야 하므로 추상화 부분은 수정에 대해 닫혀 있다**.
* 반면 **추상화를 통해 생략된 부분은 기능 확장의 여지를 남기며, 이로 인해 추상화가 개방 폐쇄 원칙을 가능케 한다**.
* 단순히 특정 개념을 추상화하는 것이 모두 수정에 대해 닫힌 설계를 만들 수 있다는 의미는 아니다.
  * **개방 폐쇄 원칙에서 폐쇄를 가능케 하는 것은 의존성의 방향이며, 수정에 대한 영향을 최소화하기 위해서는 모든 요소가 추상화에 의존해야 한다**.
* 변경에 의한 파급 효과를 피하기 위해서는 변하는 것과 변하지 않는 것이 무엇인지 이해하고, 이를 추상화의 목적으로 삼아야만 한다.
  * **추상화가 수정에 대해 닫혀있을 수 있는 이유는 변경되지 않을 부분만 신중하게 결정하여 올바른 추상화를 주의 깊게 선택했기 때문**이다.
```
> 변하지 않는 부분을 고정하고, 변하는 부분을 생략하는 추상화 기법은 개방 폐쇄 원칙의 기반이 된다.
> 추상화는 확장을 가능하게 하고, 추상화에 대한 의존은 폐쇄를 가능하게 한다.
```
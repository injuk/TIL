# Objects
## 2022-03-27 Sun

## 역할, 책임, 협력
* **객체지향 패러다임의 관점에서 핵심은 상속과 클래스가 아닌 역할과 책임, 협력**에 있다.
  * 상속과 클래스 역시 중요하지만, 이는 설계보다 구현에 가까운 내용이므로 객체지향 패러다임의 본질과는 거리가 있다.
* 객체지향의 본질은 협력하는 객체들의 공동체를 창조하는 것이므로, 설계의 핵심은 협력을 구성하기 위한 객체를 찾고 적절한 책임을 할당하는 과정에서 드러난다.
* 반면 클래스와 상속은 객체의 책임과 협력이 어느 정도 구성된 후에 사용할 수 있는 구현 메커니즘에 지나지 않는다.
  * 객체의 협력을 위한 역할, 책임을 결정하지 못한 상태에서 구현에 초점을 맞추는 것은 변경이 어렵고 유연하지 못한 코드를 낳는 원인이 된다.
  * 역할, 책임, 협력이 자리잡지 못한 애플리케이션은 아무리 응집도 높은 클래스로 구성된다고 해도 장기적으로 실패하기 쉽다.
* 객체지향 원칙을 따르는 애플리케이션의 제어 흐름은 어떤 하나의 객체에 의해 통제되지 않고, 다양한 객체들 사이에 균형 있게 분배된다.
  * 중요한 것은 객체들이 기능을 구현하기 위해 메시지를 주고받으면서 서로 상호작용한다는 점이다.
* **객체들이 애플리케이션의 기능을 완성하기 위해 수행하는 상호작용이 협력**이다.
* **객체들이 협력에 참여하기 위해 수행하는 로직은 책임**이다.
* **객체들이 협력 안에서 수행하는 책임들이 모여 객체가 수행하는 역할**이 된다.
```
> 객체지향에서 가장 중요한 것은 객체의 역할과 책임, 그리고 협력이다.
```

### 협력
* 객체지향 시스템은 자율적인 객체들의 공동체이므로, 객체는 고립된 존재가 아닌 사회적인 존재이다.
* **협력은 객체지향의 세계에서 기능을 구현할 수 있는 유일한 방법**이다.
* **메시지 전송은 객체 사이의 협력을 위해 사용할 수 있는 유일한 소통 방법**이다.
  * 객체는 다른 객체의 내부 구현에 접근할 수 없으므로, 오로지 메시지 전송을 통해서만 다른 객체에게 도움을 요청할 수 있다.
* **두 객체는 상호작용을 통해 더 큰 책임을 수행**하게 되므로, 객체의 협력을 설게할 때에는 분리된 인스턴스가 아닌 협력하는 파트너도 인식해야 한다.
* 메시지를 수신하는 객체는 요청에 응답하기 위해 메소드를 실행하며, 객체는 메시지를 처리할 방법을 스스로 결정한다.
  * 이 때, **각 객체는 자신이 할 수 없는 일을 다른 객체에게 위임하는 것으로 전체적인 자율성을 향상**시킬 수 있다.
* **객체를 자율적으로 만드는 가장 기본적인 방법은 내부 구현을 캡슐화하는 것**이다.
  * 캡슐화를 통해 변경이 적용되는 범위를 제한할 수 있으며, 때문에 자율적인 객체는 변경이 쉽다.
* 자율적인 객체는 자신에게 할당된 책임을 수행하던 중 알 수 없는 정보 또는 외부의 도움이 필요한 경우, 적절한 객체에게 메시지를 전송하여 협력을 요청한다.
* 이렇듯 **객체 사이의 협력을 구성하는 일련의 요청과 응답을 정의하는 것으로 애플리케이션의 기능을 구현**할 수 있다.

### 설계를 위한 문맥을 결정하는 협력
* 애플리케이션 안에 어떠한 객체가 필요하다면, 그 이유는 단 하나여야 한다.
  * 이는 **객체가 협력에 참여하기 때문으로, 객체가 협력에 참여할 수 있는 이유 역시 협력에 필요한 행동을 보유하기 때문**이다.
* **객체의 행동을 결정하는 것은 객체가 참여하고 있는 협력**이며, 협력은 객체의 존재 이유와 수행하는 행동의 동기를 제공한다.
* **객체는 협력을 위해 존재하므로, 협력이라는 문맥을 고려하지 않고 객체의 행동을 결정하는 것은 의미가 없다**.
* **객체의 행동을 결정하는 것이 협력이라면, 객체의 행동은 상태를 결정**한다.
  * 상태는 객체가 행동을 수행하기 위해 필요한 정보이며, 객체는 자신의 상태를 스스로 결정하고 처리하는 자율적인 존재여야 한다.
  * 즉, 상태는 행동을 위해 존재한다.
* 결국 **객체가 참여하는 협력이 객체의 행동과 상태를 모두 결정하는 셈이므로, 협력은 객체 설계에 필요한 일종의 문맥을 제공**한다. 
  * 객체는 본질적으로 상태와 행동을 함께 캡슐화하는 실행 단위이므로, 객체를 설계하는 과정에서 협력을 문맥 삼을 수 있다. 

### 책임
* 객체를 설계하기 위해 알아야하는 문맥인 협력이 갖춰진 후라면, 협력에 필요한 행동을 수행할 수 있는 적합한 객체를 찾아야 한다.
* 이 때, **협력에 참여하기 위해 객체가 수행해야하는 행동을 책임이라고 부를 수 있다**.
  * **협력 안에서 객체에게 할당된 책임은 외부의 인터페이스와 내부의 속성 정보를 결정**한다.
* 책임이란 객체에 의해 정의되는 응집도 있는 행위의 집합이다.
* 객체의 책임은 크게 다음으로 구성된다.
  1. 하는 것: 객체가 무엇을 할 수 있는가
  2. 아는 것: 객체가 무엇을 알고 있는가
* **협력 안에서 객체는 메시지를 수신하여 책임을 수행하지만, 일반적으로 책임과 메시지의 크기는 다를 수 있다**.
  * 책임은 객체의 행동을 종합적이고 간략하게 서술하므로 메시지보다 추상적이고 개념적으로도 더 큰 개념이다.
  * 단순한 책임이라고 생각했던 것이 여러 메시지로 분할되거나, 단일 객체가 수행할 수 있다고 판단했던 책임이 여러 객체들이 협력하는 책임으로 발전하기도 한다.
* 중요한 것은 책임 관점에서 아는 것과 하는 것은 밀접하게 연관된다는 사실이다.
  * 따라서, **객체는 자신이 맡은 책임을 수행하기 위해 필요한 정보를 알고 있어야할 책임이 있다**.
  * 또한 **자신이 할 수 없는 일을 도와줄 수 있는 객체를 알고 있어야할 책임도 있다**.
  * 이는 곧 객체가 어떤 책임을 수행하기 위해 필요한 정보를 함께 알아야하는 책임도 있다는 사실로 이어진다.
* **책임은 객체지향 설계의 핵심이며, 협력은 객체에게 할당할 책임을 결정할 수 있는 문맥을 제공하는 점에서 중요**하다.
  * 적절한 협력은 적절한 책임을 제공하고, 적절한 책임은 적절한 객체에게 할당되어야만 단순하고 유연한 설계를 만들어낼 수 있다.
  * 객체에게 얼마나 적절한 책임을 할당하느냐가 전체적인 설계의 품질을 결정하며, 객체의 구현은 상대적으로 책임보다 덜 중요하다. 
```
> 객체지향 설계에서 가장 중요한 능력은 책임을 적절한 객체에 할당하는 것이다.
```

### 책임의 할당
* 자율적인 객체를 만드는 가장 기본적인 방법은 책임을 수행하기 위해 필요한 정보를 가장 잘 아는 전문가 객체에게 책임을 할당하는 것이다.
  * 객체들은 협력에 필요한 지식과 방법을 가장 잘 아는 객체에게 도움을 요청하고, 이에 응답하기 위한 행동이 해당 객체의 책임이 된다.
* 객체에게 책임을 할당하려면 우선 협력이라는 문맥이 정의되어야 한다.
  * 협력을 설계하는 출발점은 시스템이 제공하는 기능을 하나의 커다란 책임으로 바라보는 것이다.
* **객체가 책임을 수행하게 하는 유일한 방법은 메시지를 전송하는 것이므로, 책임을 할당하는 것은 메시지의 이름을 결정하는 것과 같다**.
  * **객체지향 설계는 시스템의 책임을 더 작은 책임으로 나누고, 이를 객체에게 할당하는 반복적인 과정을 통해 진행**된다.
  * 또는 **객체지향 설계는 협력에 필요한 메시지를 찾고, 메시지에 적합한 객체를 선택하는 반복적인 과정으로 볼 수도 있다**.
  * 따라서 메시지는 메시지를 수신하는 객체의 책임을 결정하는 셈이 된다.
* **상술한 과정에서 결정된 메시지는 최종적으로 객체의 퍼블릭 인터페이스를 구성**하게 된다.

### 책임 주도 설계
* 상술했듯, 협력을 설계하려면 책임에 초점을 맞추어야 한다.
* 이렇듯 책임을 찾은 후 책임에 적절할 객체를 찾아 할당하는 방식을 책임 주도 설계라고 한다.
* 협력은 객체를 설계하기 위한 문맥을 제공하므로, 협력이 책임을 이끌어낸다.
* 책임은 협력에 참여할 객체를 결정하므로, 책임 주도 설계는 자연스럽게 객체의 구현보다 책임에 초점을 맞추도록 한다.
* **책임에 집중하는 것은 유연하고 견고한 객체지향 시스템을 설계하는 과정에서 가장 중요한 것이 책임이기 때문에 의미가 있다**.

### 메시지는 객체를 결정한다
* **객체에게 책임을 할당하는 과정에서 필요한 메시지를 먼저 찾아낸 후에서야 객체를 결정하는 것은 메시지가 객체를 선택한다는 점을 시사**한다.
* 메시지가 객체를 선택해야 하는 이유는 다음과 같다.
  1. 이로 인해 객체는 최소한의 인터페이스를 갖게 된다.
  2. 이로 인해 객체는 충분히 추상적인 인터페이스를 갖게 된다.
* 필요한 메시지가 식별될 때까지 객체의 퍼블릭 인터페이스에 무엇도 추가되지 않으므로, 객체는 꼭 필요한 크기의 퍼블릭 인터페이스를 노출하게 된다.
* **객체의 인터페이스는 무엇을 할 수 있는지 표현하지만, 어떻게 수행하는지는 표현하지 않아야 한다**.
  * 메시지는 외부의 객체가 요청하는 무언가에 초점을 맞추므로, 메시지를 먼저 식별하는 것은 자연스러운 흐름이다.
* **협력을 구성하는 객체들의 인터페이스는 충분히 추상적이면서 최소한의 크기를 유지하는 것이 이상적이며, 메시지로 객체를 결정하면 이를 쉽게 이룰 수 있다**.

### 행동은 상태를 결정한다
* 객체의 존재의의는 협력에 참여하는 것이며, 협력에 참여하기 위해 객체는 필요한 행동을 제공해야 한다.
  * **객체가 협력에 참여하는 유일한 방법이 행동이기에 객체를 객체답게 하는 것은 객체의 상태보다는 객체가 제공하는 행동**이다.
* 객체의 적절성을 판단하는 기준은 객체가 얼마나 적절한 책임을 갖는지이며, 적절한 책임은 협력에 있어 객체가 얼마나 적절한 행동을 수행하느냐에 따라 결정된다.
* 반면 **객체의 행동보다 상태에 초점을 맞추는 방식은 객체의 내부 구현이 퍼블릭 인터페이스에 노출되게 만들기 때문에 캡슐화를 저해**한다.
  * 따라서 **캡슐화를 위배하지 않기 위해 구현에 대한 결정은 가능한 한 미루면서, 행위를 고려하기 위해 협력이라는 문맥에서 객체를 생각**해야 한다.
  * 객체가 무엇을 제공하고, 다른 객체로부터 무엇을 얻어야하는지 고민해야 훌륭한 책임 할당이 가능하다.
* **개별 객체의 상태와 행동보다 시스템의 기능을 구현하기 위해 필요한 협력에 초점을 맞추면 자연스레 응집도가 높고 결합도는 낮은 객체들을 만들어낼 수 있다**.
  * 이 과정에서, 객체의 상태는 단순히 객체의 행동에 필요한 재료에 불과하다.
```
> 협력은 객체의 행동을 결정하고, 행동은 상태를 결정한다.
> 결정된 행동은 객체의 책임과 같다.
```

### 역할과 협력
* 객체는 협력이라는 문맥 안에서 특정한 목적을 갖게 되며, 이는 협력 안에서 객체가 맡게 되는 여러 책임의 집합으로 표시된다.
  * 이 때, **객체가 특정한 협력 안에서 수행하는 책임의 집합이 역할**이 된다.
  * 실제로도 협력을 모델링하는 과정에서는 특정한 객체보다 역할에 책임을 할당하게 된다.
* 협력에서 메시지를 처리하는 과정은 다음과 같은 순서로 진행된다.
  1. 메시지를 수행할 수 있는 적절한 역할을 찾는다.
  2. 역할을 진행할 적절한 객체를 선택한다.

### 유연성과 재사용성이 높은 협력
* 역할은 유연성과 재사용성이 높은 협력을 얻을 수 있게 한다는 점에서 중요하다.
* **역할은 하나의 메시지에 응답할 수 있는 대표자 역할을 수행하며, 역할 아래에서 책임을 수행할 수 있는 여러 객체를 교대로 갈아 끼울 수 있다**.
  * 이 경우 대표자 자체가 역할이므로, 역할은 다른 것으로 교체할 수 있는 책임의 집합이라고 생각할 수 있다.
* 역할은 여러 종류의 구체적인 객체를 포괄하는 추상화된 개념이다.
* **동일한 책임을 수행하는 역할을 기반으로 여러 협력을 하나로 통합할 수 있다**.
  * 이를 통해 불필요한 코드 중복을 제거할 수 있으며, 협력은 한 층 더 유연해진다.
* 할인 정책을 예로 들어, 비율 할인과 정액 할인은 다른 협력처럼 보이지만 할인이라는 역할 아래 묶일 수 있다.
  * 따라서 비율 할인과 정액 할인을 처리하는 각 객체를 할인이라는 역할 아래 묶어두면 때에 따라 둘을 교체할 수도 있을 뿐더러, 새로운 할인을 추가하기도 쉽다.
* **책임과 역할을 중심으로 협력을 바라보는 관점은 변경과 확장이 용이하도록 설계의 유연성을 높여줄 수 있다**.
* **역할은 추상화된 개념이므로, 역할을 구현하는 일반적인 방법은 추상 클래스 또는 인터페이스**이다.
  * 역할을 수행할 수 있는 여러 객체의 상태와 행동에 공통 부분이 존재하는 경우, 추상 클래스를 고려할 수 있다.
  * 역할을 수행할 수 있는 여러 객체의 행동인 책임 목록만 정의하는 경우, 인터페이스를 고려할 수 있다.
* 추상 클래스와 인터페이스 방식 모두 동일한 책임을 수행할 수 있는 객체들을 협력 안에 수용하도록 하는 역할이 된다.
  * 따라서 **협력 안에서 역할이 어떤 책임을 수행해야하는지 결정하는 것이 중요하며, 역할의 구현은 그 다음의 문제**다.

### 객체와 역할
* 역할은 객체가 참여할 수 있는 일종의 슬롯 역할을 하여 여러 객체를 교체할 수 있도록 한다.
* 반면 **오직 한 종류의 객체만이 협력에 참여하는 경우, 복잡성을 피하기 위해 역할이 아닌 객체 자체로 간주하는 것이 바람직**하다. 
  * 역할이라는 개념은 여러 종류의 객체들이 참여할 수 있는 경우에 사용한다.
* 대부분의 경우 역할과 객체를 명확히 분류하는 것은 어렵다.
  * 따라서 설계 초반에는 협력과 책임의 큰 그림을 탐색하는 것을 최우선으로 하되, 역할과 객체를 명확히 구분하지 않도록 한다.
  * **애매한 경우에는 항상 객체로 시작하되, 반복적으로 책임과 협력을 정제해가며 적시에 객체로부터 역할을 분리하는 것이 가장 이상적**이다.
* **중요한 것은 책임이므로, 설계 초반에 다루는 대부분의 대상은 CRC의 후보 개념으로 취급하는 것이 합리적인 선택**이다.
  * 후보는 추후 객체, 역할, 클래스 무엇이 될 수도 있지만 초반에는 이를 명확히 구분짓지 않도록 한다.
  * 언제나 중요한 것은 협력을 위해 어떤 책임이 필요한지 이해하는 것이다.
* 다양한 객체들이 협력에 참여하는 것이 확실하다면 역할로 시작하되, 그렇지 않거나 애매한 경우에는 구체적인 객체로 시작한다.
* 중요한 것은 협력을 구체적인 객체가 아닌 추상적인 역할의 관점에서 설계하면 협력이 유연하고 재사용 가능해진다는 사실이다.
  * 즉, 역할의 장점은 설계의 구성 요소를 추상화할 수 있다는 점이다.

### 역할과 추상화
* 앞서 다룬 바와 같이, 추상화는 크게 다음과 같은 장점을 갖는다.
  1. 추상화 계층을 사용하는 것으로 중요한 정책을 상위 수준에서 단순화할 수 있다.
  2. 설계가 유연해진다.
* 역할은 공통의 책임을 기반으로 객체의 종류를 숨기므로, 역할을 객체의 추상화로 볼 수도 있다.
* 협력이라는 관점에서는 세부적인 사항을 무시하고 추상화에 집중하는 것이 유용하다.
* 객체에게 중요한 것은 언제나 행동이며, 역할은 동일한 협력을 수행하는 객체를 추상화할 수 있기 때문에 중요한 개념이다.
  * 협력 안에서 동일한 책임을 수행하는 객체들은 동일한 역할을 수행하므로 서로 대체가 가능하다.
  * 이를 통해 기존 코드를 수정하지 않고도 앞으로 추가될 미지의 코드들을 유연하게 반영할 수 있다.

### 객체와 협력, 역할
* 객체는 다양한 역할을 가질 수 있다.
* 그러나 **객체는 협력에 참여할 때, 협력 관점에서는 하나의 역할로만 보여져야 한다**.
  * 객체가 다른 협력에 참여할 때에는 다른 역할로 보여질 수 있다.
* **협력 관점에서, 동일한 역할을 수행하는 객체들은 서로를 대체할 수 있다**.
* 역할은 특정한 객체군을 캡슐화하므로, 동일한 역할을 수행하는 객체들은 다형적이다.
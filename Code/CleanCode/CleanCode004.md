# CleanCode
## 2022-01-29 Sat

## 형식 맞추기
* 코드가 깔끔하고, 일관적이라면 독자에게 전문가가 짰다는 인상을 준다.
  * 반면 코드의 형식에 일관성이 없으면, 독자는 모든 코드가 무성의하게 짜여졌을 것이라고 생각하게 된다.
* 때문에 프로그래머는 형식을 깔끔하게 맞추어 코드를 짜야 한다.
  * 스스로 코드 형식을 맞추기 위한 규칙을 정하고, 규칙을 따라야 한다.
  * 개인이 아닌 팀이라면, 팀 전체가 합의하고 따르는 규칙이 필요하다.
* 필요하다면 규칙을 자동으로 검사해주는 도구를 활용해볼 수도 있다.

### 형식은 왜 맞추어야 하는가?
* **코드의 형식은 의사소통의 일환이며, 개발자의 의무로서 너무나도 중요**하다.
  * 단순히 동작하기만 하는 코드는 개발자의 첫번째 의무가 아니다.
* 오늘 구현한 기능은 다음에 바뀔 확률이 매우 높다.
  * 그러나 **오늘 구현한 코드의 가독성은 앞으로의 코드 퀄리티에 큰 영향**을 미친다.
* 오랜 시간이 지나 기존 코드가 사라지더라도, 초반에 확립한 코드 스타일과 가독성은 유지보수와 확장성에 계속해서 영향을 준다.
* **원래 코드는 사라질지언정, 개발자가 확립한 스타일과 원칙은 사라지지 않는다**.

### 적절한 행 길이의 유지
* 각 파일을 500줄을 넘지 않는 200줄 정도의 파일로 구성하더라도 충분히 커다란 시스템을 구축할 수 있다.
  * **일반적으로 큰 파일보다 작은 파일이 이해하기 쉽다**.
* 소스 코드는 마치 직관적인 신문 기사처럼 작성되어야 한다.
  * 신문은 짧고 다양한 기사로 작성되므로 읽기가 쉽다! 
  1. 이름만 보고도 올바른 모듈을 살펴보고 있는지 판단할 수 있도록 신경써서 명명한다.
  2. 소스 코드의 첫 부분은 고차원 개념과 알고리즘을 설명한다.
  3. 첫 부분으로부터 아래로 내려갈수록 의도를 세세하게 묘사한다.
  4. 가장 마지막에는 저차원의 함수와 세부사항을 작성한다.
* 소스 코드를 구성하는 **각 개념(패키지 선언, import, 메소드 선언, 등)은 빈 행으로 구분**한다.
  * 빈 행은 새로운 개념을 시작하겠다는 시각적인 단서의 역할을 해준다.

### 세로 형식 맞추기
* 서로 **밀접한 코드들은 세로로 가까이에** 두어야 한다.
  * 예를 들어, 클래스의 변수 사이를 불필요하게 주석으로 떨어트릴 필요가 없다.
* **밀접한 개념을 다루는 함수는 세로로 가까이에** 두어야 한다.
  * 그렇지 않으면 시스템의 기능을 이해하려는데 소스 코드 파일의 위 아래를 돌아다니며 코드 조각을 찾는데에 시간을 소모하게 된다.
  * **각 함수, 또는 두 개념이 다른 파일에 속한다면 이 규칙은 적용할 수 없다**.
* **변수는 사용하는 위치와 최대한 가깝게 선언**한다.
  * 짧은 함수를 작성한다면, 지역 변수는 함수의 첫 부분에 선언한다.
* **인스턴스 변수는 변수 간에 세로 거리를 두지 않고 클래스의 첫 부분에 선언**한다.
  * 사실 이 규칙은 프로그래밍 언어마다 적용되는 관습이 다르다. 예를 들어, Java는 클래스의 첫 부분이지만 C++은 클래스의 마지막 부분을 권장한다.
  * **중요한 것은 잘 알려진, 합의된 위치에 인스턴스 변수를 모은다는 사실**이다.
    * 변수의 선언 위치가 어디인지, 코드를 읽는 개발자가 바로 알 수 있으면 된다.
* **한 함수가 또 다른 함수를 호출한다면, 두 함수는 세로로 가까이에 배치**되어야 한다.
  * 이 때, **코드가 자연스럽게 읽힐 수 있도록 호출하는 함수를 호출되는 함수보다 먼저 작성**한다.
    * C / C++과 같은 함수들은 함수를 호출하기 위해 미리 선언해두어야 하므로, 반대의 특징을 갖는다.
  * 상술한 규칙들이 잘 적용된 코드라면, 코드를 읽는 개발자는 호출된 함수가 가까운 세로 위치에 작성되리라는 사실을 짐작할 수 있다.
  * 이러한 **간단한 규칙을 통해 함수의 위치를 쉽게 찾아낼 수 있으므로, 모듈 전체의 가독성을 높이는 효과**를 낼 수 있다.
* 다음과 같은 이유에서 서로를 끌어당기는 코드들이 있다.
  1. 한 함수가 다른 함수를 호출하는 직접적 종속성
     * **함수 호출 종속성은 함수를 호출하는 함수를 호출되는 함수보다 먼저 작성하는 방식을 통해 아래를 향하도록 유지**한다.
     * 이를 통해 소스 코드 모듈은 고차원에서 저차원으로, 자연스럽게 위에서부터 아래로 내려간다.
  2. 선언된 변수와, 변수를 사용하는 함수
  3. **비슷한 동작을 수행하는 함수군**
     * 명명법이 동일하고, 기본 기능이 유사하고 간단한 함수들은 가까이에 배치한다.
  * 이러한 특징을 갖는 코드들은 '개념적 친화도가 높다'라고 표현할 수 있다.
* 일반적으로 함수 호출 종속성은 아래 방향으로 유지한다.
* 이렇듯 코드는 신문 기사와 같이 가장 중요한 개념을 먼저 표현한다.
  * 중요한 개념을 표현할 때에는 최대한 세세한 내용을 제외시킨다.
  * 배제된 세세한 사항은 글의 하단에 표현한다.
* 이러한 규칙이 지켜진 경우, 개발자는 몇 개의 함수만 보더라도 전체적인 개념을 쉽게 파악할 수 있다.

### 가로 형식 맞추기
* **개발자는 짧은 행을 선호한다!**
* 가로로는 공백을 통해 밀접한 개념과 느슨한 개념을 표현할 수 있다.
  1. 할당문은 좌항과 우항을 분명하게 나누기 위해 공백으로 구분한다.
  2. 함수로 전달하는 매개변수는 함수 자체와 밀접한 연관이 있으므로 괄호와 매개변수 사이에 공백을 두지 않는다.
  3. 공백은 연산자 우선순위를 직관적으로 보여주기 위해 사용할 수도 있다.
     * 예를 들어, b*b - 4*a*c 는 공백을 적절히 사용한 것 만으로 우선순위가 직관적으로 드러난다.
```
(() => {
    // 할당문 좌우에 공백을 두어 구분한다.
    const name = 'ingnoh';
    const age = 10;
    // 함수와 매개변수는 밀접한 관계가 있으므로, ( name, age )와 같이 공백을 사용하지 말아야 한다.
    whoAmI(name, age);
})();

function whoAmI(name, age) {
    console.log(`My name is ${name} and I am ${age} years old`);
}
```
* 인스턴스 변수의 선언과 초기화문을 정렬하는 것은 좋은 방법이 아니다.
  * **정렬이 필요할 정도로 긴 선언부는 정렬의 문제가 아닌 클래스 분할의 문제**이다.
  * 선언부가 너무 길다면 클래스를 별도로 쪼개는 것을 고려해야 한다.
```
class VariableInitiator {
    // 이런짓 하지 말자는 뜻이다.
    private     String      name;
    private     int         age;
    private     char        gender;
    public      String[]    address;
    protected   boolean     signed;
    
    VariableInitiator() {
        name        =   "ingnoh";
        age         =   10;
        gender      =   'M';
        address     =   new String[] { "A", "B" };
        signed      =   false;
    }
}
```
* 코드 내부에 적용되는 범위(scope)를 표현하기 쉬운 방법은 코드의 들여쓰기이며, 이는 개발자들에게 친숙한 표기법이다.
  * 예를 들어, 파일 수준의 범위를 갖는 클래스 정의와 같은 문장은 들여쓰지 않는다.
  * 반면 클래스 내부에 위치한 메소드는 클래스 정의보다 한 수준 들여쓴다.
  * 메소드 내부에 위치한 실행문 코드는 메소드 정의보다 한 수준 들여쓴다.
  * 실행문에 블록이 포함된다면, 블록 내부의 코드는 한 수준 들여쓴다.
* 단순해보이는 **들여쓰기는 코드가 속하는 범위를 시각적으로 표현함으로써 분석해야만 하는 코드의 범위와 가독성에 지대한 영향**을 준다.
  * 극단적으로, 들여쓰기가 없다면 사람이 코드를 읽는 것은 불가능에 가까워질 수도 있다.
* 간단한 if문, while문, 함수 등의 코드에서는 종종 들여쓰기를 제외하고 싶은 유혹에 빠질 수 있다.
  * 이러한 **유혹에 빠지지 않고 반드시 개행과 들여쓰기로 범위를 제대로 표현하는 것이 바람직**하다.
  * **반면 if문 / while문 블록에 하나의 실행문만 포함되는 경우는 실행문을 감싸는 블록을 생략해도 좋다**.
    * 누락되지 말아야할 것은 블록 내부의 들여쓰기이다!
```
class Main {
    public static void main(String[] args) {
        System.out.println(new Person().greeting("ingnoh"));
    }
}

class Person {
    // 이런짓 하지 말자는 뜻이다.
    // public String greeting(String name) { return "Hello, " + name + "!"; }
    
    public String greeting(String name) { 
        return "Hello, " + name + "!"; 
    }
}
```
* 프로그래머라면 개개인이 선호하는 코드 작성 규칙이 있다.
  * 그러나 **개발팀에 속하는 프로그래머가 선호해야하는 규칙은 팀의 규칙**이다.
* 팀은 하나의 코드 작성 규칙에 합의하고, 모두가 그 규칙에 따라야만 한다.
  * 스타일은 일관적이고 매끄러워야 한다.
  * 그래야만 소스 코드, 나아가 소프트웨어가 일관된 스타일을 가질 수 있다.
* **좋은 시스템은 읽기 쉬운 문서로 이루어져야만 한다**.
  * 이는 **작성된 소스 코드 자체가 구현 표준 문서가 되어야 한다는 의미**이다.
* **코드를 읽는 개발자로 하여금 하나의 소스 코드에 적용된 스타일은 반드시 다른 소스 코드에도 적용되리라는 신뢰성을 줄 수 있어야** 한다.
  * 온갖 스타일을 뒤섞어 소스 코드를 복잡하게 만들지 말아야 한다.

### 개인 리마인드용
* 나는 여지껏 함수 내부의 단락을 구분하기 위해 개행을 넣곤 했다.
```
(() => {
    printNumberAndPlusOneAndPrintNumberAndDivideTwoAndPrintNumber(10);
})();

// 함수의 기능을 구분하기 위해 개행을 넣은 예시
function printNumberAndPlusOneAndPrintNumberAndDivideTwoAndPrintNumber(number) {
    console.log(`number: ${number}`);
    
    number++;
    
    console.log(`number: ${number}`);
    
    number /= 2;
    
    console.log(`number: ${number}`);
}
```
* 함수 내부에 위치한 코드의 단락을 구분하기 위한 개행은 지양하도록 하자.
  * **함수의 단락을 나누는 것이 아니라, 함수 자체를 작게 쪼개는 방향으로 생각**해야 한다.
```
(() => {
    printNumberAndPlusOneAndPrintNumberAndDivideTwoAndPrintNumber(10);
})();

function printNumberAndPlusOneAndPrintNumberAndDivideTwoAndPrintNumber(number) {
    printNumber(number);
    number = plusOne(number);
    printNumber(number);
    number = divideTwo(number);
    printNumber(number);
}

function printNumber(number) {
    console.log(`number: ${number}`);
}

function plusOne(number) {
    return number + 1;
}

function divideTwo(number) {
    return number / 2;
}
```

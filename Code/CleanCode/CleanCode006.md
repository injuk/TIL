# CleanCode
## 2022-01-31 Mon

## 경계
* 모든 소스 코드를 직접 개발하는 경우는 드물다.
* 어떤 식으로든 시스템에 외부 코드가 포함되며, 외부의 코드는 우리의 코드에 깔끔하게 통합되어야 한다.

### 외부 코드의 사용
* 인터페이스 제공자와 사용자 사이에는 특유의 긴장이 존재하며, 이로 인해 시스템 경계에서의 문제가 생길 수 있다.
* 예를 들어, java.util.Map은 Map을 사용하는 모든 메소드가 clear를 호출하여 Map의 내용을 지워버릴 수 있다.
  * 즉, 메소드별 권한 제어가 불가능하다. 필요하지 않은 기능까지 제공하는 것을 막을 수 없다.
* 또한 Map의 인스턴스를 반환값으로, 인수로 여기저기 넘기는 구조라면 Map이 변경되었을 때 수정되어야할 부분이 많다.
  * 실제로 JDK 1.5에서 Map 인터페이스는 변경이 있었다.
* 이러한 문제는 Map의 사용을 위한 래퍼 클래스를 만드는 것으로 깔끔하게 정리할 수 있다.
  * 아래는 Sensors 클래스에서 경계 인터페이스인 Map을 관리하고 변환하는 예시이다.
```
public class Sensors {
    private Map sensors = new HashManp();
    public Sensors getById(String id) {
        return (Sensor) sensors.get(id);
    }
    // 생략...
}
```
* 위 방식의 장점은 다음과 같이 생각해볼 수 있다.
  1. 제네릭을 사용하지 않은 경우의 명시적 형변환 책임을 클라이언트로 넘기지 않아 깔끔하다.
  2. 필요한 기능, 인터페이스만 public 메소드로 정의하여 노출할 수 있다.
     * 결과 코드의 이해는 쉬워지고, 사용에 주의가 필요한 메소드의 오용을 막을 수 있다. 
* 상술한 방식은 **경계 인터페이스인 Map을 클래스 Sensors 내부로 숨긴** 것이다.
  * 때문에 **Map 인터페이스가 수정되더라도 프로그램의 나머지에는 영향을 주지 않는다**.
  * **제네릭 역시 Sensors 내부에서 관리되므로, Map을 사용하는 메소드 호출자는 이를 신경쓸 필요가 없다**.
* **Map과 같은 Collection을 사용할 때마다 래퍼 클래스를 만들어야 한다는 의미는 아니다**.
  * **중요한 것은 외부 코드로부터 포함된 경계 인터페이스를 여기저기 넘겨가며 사용하지 말아야한다는 점을 기억**하자.
  * **Map과 같은 경계 인터페이스를 사용하는 경우, 이를 이용하는 클래스나 클래스 계열 밖으로 public하게 노출되지 않도록 해야** 한다.
    * 예를 들어, Map 인스턴스를 public한 API의 인수로 넘기거나 반환하지 말아야 한다.

### 경계 익히기
* 외부에서 가져온 패키지를 사용하면 적은 시간에 빠르게 개발할 수 있는 장점이 있다.
* 그러나 가져온 패키지에 포함된 코드를 익히고, 통합하는 것을 병행하는 작업은 비용이 많이 드는 작업이다.
* 외부 패키지의 코드를 익히기 위해, 우리는 학습 테스트 기법을 활용해볼 수 있다.
  * 학습 테스트는 간단한 테스트 케이스를 작성하여 외부 코드를 테스트하는 방식이다.
  * 우리가 **외부 코드를 사용하려는 방식대로 테스트 케이스를 만들어 외부 API를 호출하며, 통제된 환경에서 API를 제대로 이해하고 있는지 확인**한다.
* 학습 테스트는 다음과 같은 순서로 진행할 수 있다.
  1. 패키지를 내려받는다.
  2. 문서를 자세히 읽기 전에 간단한 테스트 케이스를 작성한다.
  3. 원하는 동작이 나올 때까지 문서를 읽고, 구글링하여 테스트 케이스를 수정한다.
     * 3.의 과정에서 외부 코드가 돌아가는 원리를 상당히 이해하게 된다.
  4. 학습 테스트 과정에서 얻은 지식을 간단한 단위 케이스 몇 가지로 표현하도록 한다.
  5. 학습 테스트를 통해 충분한 지식을 얻었다면, **습득한 지식을 총동원하여 독자적인 클래스로 캡슐화한다**.
     * 이를 통해 **나머지 프로그램은 외부로부터 가져온 패키지의 코드인 경계 인터페이스에 대해 알 필요가 없다**.

### 학습 테스트의 이점
* **학습 테스트는 비용보다 결과가 더 크다**. 즉, 공짜 이상이다.
  * 어차피 외부 API를 익혀야하므로, 사실상 비용이 없는 셈이다.
* 학습 테스트를 통해 필요한 지식만 손쉽게 확보하며, 외부 코드와 기능에 대한 이해도를 높일 수 있다.
* **외부 패키지의 새로운 버전이 나온다면 학습 테스트를 돌려 차이가 있는지 확인**한다.
  * 외부 코드가 우리의 코드에 통합된 이후로도 평생 호환되는 것을 보장할 수는 없다.
    * 외부 패키지는 새로운 버전이 나올 때마다 코드를 통합한 우리에게 새로운 위험이 된다. 
  * 학습 테스트는 학습 뿐만 아니라 패키지가 예상한대로 동작하는지 검증하는데에 재활용된다.
    * 새 버전이 우리의 코드와 호환되지 않으면 학습 테스트를 통해 이를 금방 밝혀낼 수 있다.
* 학습 테스트를 통한 **학습이 필요치 않더라도 외부 경계 인터페이스에 대한 테스트 코드는 필요**하다.
  * 이러한 경계 테스트 코드의 작성을 통해 패키지를 새로운 버전으로 업그레이드하기 쉬워진다.
  * **경계 테스트 코드를 작성하지 않는다면 프로젝트가 낡은 버전의 패키지에 종속**될 수 있다.

### 존재하지 않는 코드의 사용
* 다른 팀과 협업하다 보면, 다른 팀의 코드와 우리 팀의 코드가 서로를 호출하는 경계가 발생한다.
* 만약 상대 팀에서 인터페이스도 정의하지 못한 상태라면, 다음과 같은 흐름으로 개발을 진행해볼 수 있다.
  1. 우선 경계로부터 먼 부분부터 개발한다.
  2. 충분히 개발이 진행되었지만 상대 팀에서 인터페이스를 정의하지 못했다면, 자체적인 인터페이스와 추상 메소드를 정의한다.
     * 우리가 바라는 형태의 인터페이스를 설계하므로, 인터페이스를 전적으로 통제할 수 있다.
     * 따라서 코드 가독성이 높아지고 의도가 분명해진다.
     * 또한 API를 올바르게 사용하고 있는지 확인하기 위해 해당 인터페이스를 구현하는 Mock 클래스를 정의하여 경계 테스트 케이스를 작성해둘 수 있다.
  3. 상대 팀의 인터페이스 설계 및 API 개발이 완료된다면, 2.의 인터페이스와 상대 팀의 API 간극을 Adapter 패턴을 통해 메꾼다.
     * **Adapter 패턴을 통해 상대 팀의 API를 사용하는 코드가 캡슐화되므로 상대 팀의 수정사항에 대응할 코드를 하나의 클래스로 모을 수 있다**.

### 결론
* 경계는 언제나 변경을 함께 생각해야만 한다.
* 잘 설계된 소프트웨어는 변경에 많은 비용이 들지 않는다.
* 우리가 통제할 수 없는 코드를 사용한다면, 추후에 있을 변경에 대응하는 비용이 너무 커지지 않을 수 있도록 신중히 대비해야 한다.
  1. 경계에 위치하는 코드는 깔끔하게 분리한다.
  2. 외부 코드의 세부사항을 알 필요가 없도록, 동작의 기대사항을 정의하는 테스트 케이스를 작성한다.
  3. 외부 패키지를 호출하는 코드는 가능한한 줄여 경계를 관리한다.
  * 이는 다음과 같은 두 가지 방식 중 하나로 경계를 관리할 수 있다.
    1. java.util.Map의 예시와 같이 **래퍼 클래스로 경계를 감싸거나**,
    2. **Adapter 패턴을 적용하여 우리가 원하는 인터페이스를 외부 코드가 제공하는 인터페이스로 변환**한다.
    * **두 방식 모두 코드 가독성이 높아지고, 경계 인터페이스를 사용하는 일관성이 높아지고, 외부 패키지 변경에 대한 비용이 줄어**든다.
* **통제가 불가능한 외부 코드보다 통제가 가능한 우리의 코드에 의존하는 것이 언제나 바람직**하다. 
# CleanCode
## 2022-01-27 Thu

* **소프트웨어와 관련된 작업의 80% 이상은 유지보수**이다.
  * 책임 있는 **개발자는 유지보수의 중요성을 인지하고 제품 생명주기를 고려할 수 있어야** 한다.
  * 소프트웨어의 품질은 위대한 방법론이 아니라 사심 없이 기울이는 관심에서 나온다.
* 일본의 품질 관리론에서 비롯된 다섯가지 프로그래밍 원칙은 일본어 머릿 글자를 딴 5S로 정리된다.
  1. Seiri: 정리, 적젊한 명명을 통해 무엇이 어디에 있는지 알 수 있어야 한다.
  2. Seiton: 정돈, 코드는 누구나 예상할 수 있는 위치에 있어야 한다.
  3. Seiso: 청소, 이력이나 기대 사항을 작성하거나 미련이 남은 코드를 보존하기 위한 주석은 제거해야 한다. 
  4. Seiketsu: 청결, 조직 내에서 지켜야할 일관적인 구현 스타일과 기법, 표준 수립은 필요하다.
  5. Shutsuke: 생활화, 관례를 따르고 자기 작품을 자주 돌아보고, 변경할 수 있어야 한다.
* 버그가 발생할 때까지 방치하는 유지보수 유기는 일어나지 않아야 하며, 이를 위해 코드를 계속해서 리팩토링해야 한다.
  * 한 발 더 나아가 처음부터 유지보수하기 쉬운 코드를 만들 수도 있을 것이다.
  * 때문에 **가독성이 좋은 코드는 동작하는 코드만큼 중요**하다.

## 깨끗한 코드
* **코드는 요구사항을 상세히 표현하는 수단**이다.
  * 요구사항을 기계가 실행할 수 있을 정도로 상세하게 명시하는 작업이 프로그래밍이며, 그 결과물이 코드이다.
  * 거꾸로 말하면, 충분히 상세하게 명시된 요구사항은 코드만큼 정형적이며, 테스트 케이스로 사용할 수도 있을 것이다.
* 나쁜 코드는 개발 속도를 크게 떨어트리며, 조직의 생산성 저하로 직결된다.
* 개발자들은 나쁜 코드가 되는 이유를 관리자, 고객, 다른 팀 등 외부 요인에서 찾는 경우가 많다.
  * 그러나 **잘못은 전적으로 나쁜 코드가 되도록 방치한 프로그래머**에게 있다.
    * 나쁜 코드의 위험성을 이해하지 못하는 관리자의 말을 그대로 따르는 것은 전문가답지 못한 행위이다. 
  * 좋은 코드를 사수하는 것은 프로그래머의 책임이다.
```
> 기한에 맞추기 위해 나쁜 코드를 양산하는 것은 잘못된 접근이다. 나쁜 코드는 기한을 놓치게 만든다.
> 빨리 가는 유일한 방법은 언제나 코드를 깨끗하게 유지하는 습관에 있다.
```
* 코드의 좋고 나쁨을 구분할 수 있다는 것이 깨끗한 코드를 작성할 수 있다는 뜻은 아니다.
* 누군가는 타고나고, 누군가는 노력 끝에 얻어내는 '코드 감각'은 코드의 좋고 나쁨을 구분할 수 있도록 한다.
  * 나아가 '코드 감각'이 있는 프로그래머는 나쁜 코드를 좋은 코드로 개선할 방안을 떠올리고, 최고 방안까지 이동하는 경로를 계획한다.
* 좋은, 깨끗한 코드는 무엇일까? 깨끗한 코드는,
  1. 보기에 즐거운 코드이다.
  2. 세세한 사항까지 꼼꼼하게 처리하는 코드이다.
  3. 잘 쓴 문장처럼 읽히는 코드이다.
  4. 다른 사람이 고치기 쉬운 코드이다.
  5. 테스트 케이스가 있는 코드이다.
     * 아무리 코드가 우아해도, **테스트 케이스가 없는 코드는 깨끗할 수 없다**.
  6. 시간을 들여 깔끔하고 단정하게 정리한, 주의 깊게 작성한 코드이다.
  7. 중복을 줄이고, 표현력을 높이고, 처음부터 간단한 추상화를 고려한 코드이다.
  8. 읽으면서 놀랄 일이 없는 코드이다.
     * 깨끗한 코드는 읽으면서 짐작한대로 실제로 동작한다.
* 코드를 읽는 시간과 작성하는 시간의 비율은 항상 코드를 읽는 시간이 우세하다.
  1. 주변 코드를 읽지 않으면 새로운 코드를 작성할 수 없다.
  2. 주변 코드가 읽기 쉬우면 새로운 코드를 작성하기 쉽다.
  3. 주변 코드가 어려우면 새로운 코드를 작성하기 어렵다.
  4. 상술한 논리에 따라 빠르게 작업을 끝내려면, 읽기 쉬운 코드를 작성하면 된다.
     * 코드를 읽는 시간이 개발 작업에서 차지하는 비중이 더 크기 때문이다.
  5. 따라서 읽기 쉬운 코드는 매우 중요하다.
* 보이스카우트 규칙: **시간이 지나도 언제나 코드를 깨끗하게 유지해야 한다**.
  * **체크아웃할 때보다 좀 더 깨끗한 코드를 체크인한다면 코드는 절대 나빠지지 않는다**.
```
캠프장은 처음 왔을 때보다 더 깨끗하게 해놓고 떠나라.
```
* **예술 책을 읽는다고 예술가가 된다는 보장은 없다**.

## 의미 있는 명명법
* 소프트웨어에서는 어디에나 명명이 필요하므로, 의미 있는 명명법을 활용하면 여러 모로 편리함을 누릴 수 있다.

### 분명히 드러나는 의도
* 의도가 분명히 드러나는 좋은 이름을 떠올리기에는 시간이 오래 걸리지만, 이로 인해 절약될 시간이 더 많다.
* 변수, 함수, 클래스의 이름은 다음의 질문에 주석 없이 대답할 수 있어야 한다.
  1. 존재 이유?
  2. 수행하는 기능?
  3. 사용하는 방법?
* **주석이 필요한 이름은 의도를 분명히 드러내지 못한 것**이다.
* 너무 단순하게 명명된 이름은 코드의 단순성이 아닌 함축성에서 문제가 발생한다.
  * 즉, 코드 맥락이 코드 자체에 드러나지 않게 된다.

### 잘못된 정보는 피하기
* 코드 상에 코드의 의미를 흐리는 잘못된 정보, 단서를 남겨서는 안 된다.
* 예를 들어, 어떤 객체가 List의 구현체가 아닌데도 참조 변수에 List라는 단어를 포함하면 개발자에게 잘못된 정보를 줄 수 있다.
* 서로 흡사한 이름을 사용하지 않도록 한다.
* 소문자 l과 대문자 O 등, 혼동을 주기 쉬운 변수의 명명을 피한다.
  * 폰트의 적용으로 차이점을 드러내는 방식은 적절하지 못하다.
  * 이러한 방식은 현재와 미래에 입사할 모든 개발자에게 폰트의 적용을 강요하게 된다. 그냥 이름만 바꾸면 해결될 문제다!

### 의미 있는 구분
* 컴파일러나 인터프리터만 통과하기 위해 코드를 구현하는 경우, 스스로 문제를 일으키게 된다.
* 같은 스코프 내부에서 class라는 변수가 사용되었다고 klass와 같은 단어를 사용하는 방식은 바람직하지 못하다.
* a1, a2, a3과 같은, 아무런 정보를 제공하지 못하는 의미 없는 명명도 바람직하지 못하다.
* 개념을 구분하지 않고 이름만 다르게 하는 명명 또한 피해야 한다.
  * UserInfo, UserData는 척 보기에도 그 차이를 알 수 없다.
  * 이러한 단어를 의미가 불분명한 불용어라고 표현한다.
* 중복된 표현 역시 불용어에 포함된다.
  * 예를 들어, 변수의 이름에 variable이라는 단어를 쓰거나 표 이름에 table이라는 단어를 쓰는 경우가 포함된다.
* customerInfo와 customer, accountData와 account, theMessage와 message 등... 읽는 사람이 차이를 알 수 없는 명명은 피해야 한다.

### 발음하기 쉬운 이름
* 사람들은 단어에 능숙하며, 단어는 발음이 가능하다. 변수의 이름은 발음이 쉬워야 한다.
  * 발음할 수 없는 단어의 사용은 코드의 가독성 뿐만 아니라 개발자 간의 소통에도 악영향을 미친다.
* wslamfd와 같은 발음할 수 없는 단어의 사용을 지양하자. 이런 이름은 만들기도 어렵다.

### 검색하기 쉬운 이름
* 문자 하나를 사용하는 이름은 눈에 띄지 않는다.
  * 예를 들어, 변수 이름이 e라면 해당 변수를 찾기가 너무 어려워진다.
  * 이러한 경우는 검색 결과를 하나하나 찾으며 코드의 의미를 분석해야 원하는 변수를 찾을 수 있게 된다.
* 이런 관점에서, 의미가 분명하다면 **긴 변수 이름이 짧은 변수 이름보다 낫다**.
  * 즉, 검색하기 쉬운 이름은 항상 좋다.
* 아주 간단한 메소드에서는 로컬 변수로서 한 문자의 사용을 고려할 수 있다.
  * **변수의 이름 길이는 변수가 적용되는 범위의 크기에 비례**해야 한다.
```
예시: array.forEach(e => { console.log(e) });
```
* 이름을 충분히 의미 있게 짓는 경우 코드는 길어진다.
  * 그러나 쉬운 검색에서 얻을 수 있는 이점이 더 크다.

### 인코딩 지양
* 유형이나 범위 정보 등을 이름에 포함하지 말아야 한다.
  * 인코딩은 과거의 컴파일러들이 타입을 점검하지 않은데서 발생한 관습이다.
  * 요즘의 컴파일러들은 훨씬 많은 타입을 자체적으로 지원하고, 타입을 기억하고 강제한다.
* 인코딩된 이름은 발음이 어렵고, 오타가 발생하기도 쉽다.
* **클래스나 함수는 접두어의 인코딩이 필요 없을 정도로 작아야 하며, 멤버 변수를 다른 색으로 표시하거나 눈에 띄게 보여주는 IDE를 사용해야** 한다.

### 기억력을 자랑하지 말 것
* 코드를 읽는 개발자가 이상하게 명명된 변수의 이름을 자신이 아는 이름으로 변환해가며 이해해야 한다면, 잘못 명명된 경우에 해당한다.
* 예를 들어, 전통적인 for문 내부의 i, j, k 등의 변수는 코드 컨벤션 상 문제가 없다.
  * 이 외의 경우에는 코드를 읽는 개발자가 변수의 기능을 추론해야 하므로 대부분 적절하지 못하다.
* **전문적인 프로그래머는 명료한 코드가 최고라는 사실을 이해하며, 자신의 능력을 활용하여 남들이 이해하는 코드를 작성**한다.

### 클래스와 메소드의 명명
* 클래스나 객체의 이름은 명사(또는 명사구)가 적절하다.
  * Manager, Processor, Data, Info와 같은 단어는 사용을 지양한다.
  * 동사는 사용하지 않는다.
* 메소드 이름은 동사(또는 동사구)가 적절하다.
  * 예를 들어, [동사] 또는 [동사][대상]이 적절하다.
    * save, savePage, 등
  * 접근자, 설정자, 조건자는 이름 앞에 get / set / is를 붙여준다.
* **생성자를 중복정의하는 경우 정적 팩토리 메소드를 사용**한다.
  * 이 때, 메소드는 인수를 설명하는 이름을 사용한다.
```
class Main {
    public static void main(String[] args) {
        User agingUser = User.withAge("Hong", 20); // 정적 팩토리 메소드 활용
        User onlyNamedUser = User.withoutAge("Hong");
        
        System.out.println(agingUser.age);
        System.out.println(onlyNamedUser.age);
    }
}

class User {
    String name;
    int age;
    
    // 생성자 사용 제한
    private User(String name) {
        this.name = name;
        this.age = 10;
    }
    
    private User(String name, int age) {
        this.name = name;
        this.age = age;
    }
    
    // 정적 팩토리 메소드
    public static User withoutAge(String name) {
        return new User(name);
    }
    
    public static User withAge(String name, int age) {
        return new User(name, age);
    }
}
```

### 기발한 이름 피하기
* 기발하고 재치 있는 이름은 코드 작성자와 같은 감성을 가진 사람만이 기억한다.
* 재미있는 이름보다 명료한 이름을 사용하며, 특정 문화에서만 사용하는 표현은 지양한다.
  * 의도는 분명하고 솔직하게 표현되어야 한다.

### 한 개념에 한 단어를 사용하기
* 추상적인 개념 하나에 단어 하나를 선택하고, 계속해서 이를 사용하도록 해야 한다.
  * 예를 들어, 같은 기능을 하는 메소드의 이름이 클래스마다 fetch, get, retrieve 등으로 달라지는 경우 이를 이해하는 데에 시간이 든다.
  * 이러한 명명 방식은 어느 클래스에서 어떤 유형의 단어를 사용했는지 기억하기 어려워진다.
* 메소드 이름은 독자적이고 일관적이어야 한다. 주석을 확인하지 않고도 프로그래머가 메소드를 선택할 수 있어야 한다.

### 말장난 하지 않기
* 같은 단어를 두 가지 목적으로 사용하는 일을 피해야 한다.
  * 즉, 같은 맥락이 아닌데도 일관성 유지를 위해 동일한 단어를 선택하는 것은 바람직하지 않다.
* 여러 클래스에서 두 값을 더하는 add 메소드를 사용하고 있는 상황에서, 일관성 유지를 위해 집합에 값을 추가하는 메소드의 이름을 add라고 짓는 것은 말장난이다.
  * 이 경우, insert 또는 append와 같은 단어를 사용하는 것이 적절하다.
* **프로그래머는 언뜻 봐도 이해가 가능한, 이해하기 쉬운 코드를 짜야** 한다.
* **의미를 해독할 책임이 독자에게 있는 것이 아닌, 의도를 밝힐 책임이 저자에게 있어야 한다**.

### 해법 영역과 문제 영역
* 코드를 읽을 사람도 프로그래머이므로, 전산 용어나 알고리즘, 패턴 등은 사용해도 좋다.
  * 모든 이름을 domain(문제 영역)에서 가져오는 것보다는 직관적인 해법 영역의 용어를 사용할 수 있다.
  * 기술 개념에는 그 기술의 이름이 가장 적합하다.
* 적절한 해법 영역의 용어가 없다면 domain에서 이름을 가져온다.
* 개발자는 domain과 해법 영역을 구분할 수 있어야 한다.
  * domain과 관련된 코드는 domain에서 이름을 따와야 한다.

### 의미 있는 맥락을 추가하기
* 스스로 의미가 분명한 이름은 바람직하나, 그렇지 못한 이름도 있다.
* 이런 경우 **클래스나 메소드 공간에 이름을 넣는 것으로 맥락을 잡아줄 수 있다**.
  * 이러한 방법이 모두 실패하고 나서야 접두어를 고려할 수 있다.
* 예를 들어 state라는 변수는 그 자체로는 의미가 모호하지만, Address 클래스의 멤버 변수라면 주소의 일부라는 것을 맥락 상 이해할 수 있다.

### 불필요한 맥락은 피하기
* 일반적으로는 긴 이름이 좋지만, 불필요한 맥락에 의해 의미는 불분명한 채 이름만 길어지는 경우는 지양해야 한다.

### 결론
* 좋은 이름을 선택할 수 있으려면 설명 능력도 좋아야 하고, 문화적인 배경도 같아야 한다.
* 좋은 이름을 선택하는 능력은 기술, 관리 문제가 아닌 교육의 문제이다.
* 변수의 이름을 더 좋게 바꾸는 작업은 개발자들에게도 환영받을 것이다.
  * 개발자들은 일반적으로 자신의 클래스와 메소드의 이름을 모두 기억하지 못한다.
  * 이러한 **암기는 IDE에게 맡기고, 우리는 문장이나 문단처럼 / 적어도 표나 자료구조처럼 읽히는 코드를 짜는 데에 집중해야** 한다.
* 다른 코드 개선 작업처럼 누군가는 의미 있는 명명으로 변경하는 과정을 질책할 수도 있지만, **그게 무서워서 코드를 개선하려는 노력을 중단해서는 안된다**.
  * 이러한 **코드의 개선은 단기적인 효과는 물론 장기적인 이익도 보장되는 확실한 방법**이다.
# CleanCode
## 2022-01-30 Sun

## 자료의 추상화
* 변수를 private으로 설정했더라도 getter와 setter가 public이라면 구현은 외부로 노출된 셈이다.
  * 단순히 변수 사이에 함수라는 계층을 추가한 것으로 구현이 숨겨지지는 않는다.
  * **구현을 숨기려면 추상화가 필요**히다.
* 사용자가 **구현을 모르는 채로 추상적인 인터페이스를 활용하여 자료의 핵심을 조작할 수 있어야만 진정한 의미의 클래스**라고 할 수 있다.
* 그러나 인터페이스를 사용한다고 해서 자료가 항상 감춰지는 것도 아니다.
  * **클래스에 포함된 자료를 세세하게 공개하는 것보다 추상적인 개념으로 표현하는 것이 좋다**.
```
// Bad: 구체적인 자료 구조이며, 인터페이스의 두 함수는 어떠한 변수의 값을 구체적인 형태로 그대로 반환하는 것처럼 보인다.
public interface Vehicle {
    double getFuelTankCapacityInGallons();
    double getGallonsOfGasoline();
}
// Good: 추상적인 객체이며, 백분율이라는 추상적인 개념으로 반환하므로 이 값이 어떤 변수로부터 비롯되었는지 알 길이 없다.
public interface Vehicle {
    double getPercentFuelRemaining();
}
```
* 상술한 예시와 같이, 객체는 세세하게 공개되는 것보다는 추상적인 개념으로 표현되는 것이 좋다.
  * 단순히 getter와 setter를 포함하는 인터페이스만으로는 추상화되지 않는다.
* **개발자는 객체가 포함하는 자료를 표현할 가장 좋은 방법을 심각하게 고민해야** 한다!
  * **아무 생각 없이 getter와 setter를 추가하는 것은 가장 나쁜 방법**이다.
* 단순히 class로 작성되었다고 클래스이며 객체라고 판단해서는 안된다.
  * 추상화 정도를 토대로 객체와 자료 구조를 구분하도록 하자.

### 자료와 객체의 비대칭성
* **객체는 추상화를 통해 자료를 숨기고, 자료를 다루는 메소드만을 제공**한다.
  * 즉, 객체와 클래스는 추상적이다.
* 반면 **자료 구조, 또는 자료 구조체는 자료를 그대로 공개하며, 별다른 함수를 제공하지 않는다**.
  * 즉, 자료 구조는 구체적이다.
* 이렇듯 객체와 자료 구조는 본질적으로 상반된 특징을 갖는다.
  1. 자료 구조를 활용하는 절차적인 코드
     * 기존 자료 구조를 변경하지 않으면서 새로운 함수를 추가하기 쉽다.
     * 그러나 새로운 자료 구조를 추가한다면, 절차적인 코드를 변경해야 한다.
  2. 객체를 활용하는 객체 지향적인 코드
     * 인터페이스에 새로운 함수를 추가하면 모든 구현체를 수정해야 하므로, 함수 추가가 어렵다.
     * 그러나 기존 함수를 변경하지 않고도 새로운 클래스를 추가하기 쉽다.
* 둘은 상호 보완적이며, 어느 것이 맞고 어느 것이 틀리다고 보기 어렵다.
  * 객체 지향 코드에서 어려운 변경은 절차적인 코드에서 쉽고, 그 반대도 성립한다.
* 따라서 시스템을 개발하는 과정에서 발생하는 요구사항에 따라 구분할 수 있다.
  1. 새로운 자료 타입이 생성되기 쉬운 경우, 인터페이스와 클래스, 객체 지향 기법을 활용한다.
  2. 새로운 함수가 추가되기 쉬운 경우, 자료 구조 형태의 클래스와 절차적인 코드를 활용한다.
* 분별 있는 프로그래머는 **모든 것이 객체라는 생각은 미신**이라는 것을 안다.
  * 때로는 단순한 자료 구조 형태의 클래스와 절차적인 코드가 적합한 상황도 있다.
  * 때문에 항상 객체 지향을 도입하는 것보다는 요구 사항이 새로운 자료 타입이 추가되기 쉬운지, 새로운 함수가 추가되기 쉬운지를 잘 고려하여 판단하는 것이 바람직하다.

### 개인 리마인드용
* 잘 이해가 안되는 부분이 많지만, 다음과 같이 정리하기로 했다.
1. 객체와 자료 구조는 다르며, 둘 중 무엇이 좋고 나쁘고는 없다. 용도가 다르다.
   * 단순히 class 문법으로 작성했다고 모두 클래스와 객체가 되는 것은 아니다.
   * 모든 인스턴스 변수가 public이거나, private이더라도 getter와 setter를 그대로 노출하는 것은 자료 구조이다.
2. 시스템의 요구 사항에 맞춰 객체 지향적인 코드를 사용하거나, 절차 지향적인 코드와 자료 구조를 사용한다.
   * 이 때, 객체 지향을 사용하기로 했다면 무분별한 getter와 setter를 제공하는 것은 지양한다.
   * 개발자는 객체와 클래스를 어떻게 추상화할지 심각하게 고민하여 메소드를 작성하고, 내부의 구조를 숨겨야 한다.
   * **내부의 구조를 숨기는 이유는 다른 코드들이 해당 클래스에 의존하지 못하도록 하기 위해서**이다.
* 다루고자 하는 클래스가 객체라면 **무언가를 하라고 해야지, 내부 구조를 알려달라고 해서는 안된다**.

### 디미터 법칙
* 모듈은 자신이 조작하는 객체의 내부를 알 수 없어야 한다는 법칙이다.
* 디미터 법칙에 따르면, 클래스 C의 메소드 f는 다음과 같은 메소드만 호출해야 한다.
  1. 클래스 C의 메소드
  2. 메소드 f가 생성한 객체
  3. 메소드 f의 인수로 넘겨진 객체
  4. 클래스 C의 인스턴스 변수가 참조하는 객체
  * **그러나 위 네 가지 메소드가 반환하는 객체의 메소드는 호출하지 말아야** 한다!
* 기차 충돌: 연쇄적으로 메소드가 호출되어 기차가 충돌하는 것처럼 보이는 코드를 말한다.
```
String result = a.getB().getC().getD();
```
* **특정한 코드가 디미터 법칙을 위반하는지 여부는 호출되는 것이 객체인지 자료 구조인지에 따라 다르다**.
* 객체의 정보를 토대로 연쇄적으로 호출한다면, 객체는 내부 구조가 숨겨져야 마땅하므로 디미터 법칙을 위반한다.
  * 위 코드를 예로 들면, a, b, c가 객체인 경우 디미터 법칙을 위반한다.
* 자료 구조의 정보를 토대로 연쇄적으로 호출한다면, 자료 구조의 내부 구조는 원래 공개되어야 하므로 디미터 법칙을 위반하지 않는다.
  * 위 코드를 예로 들면, a, b, c가 자료 구조인 경우 디미터 법칙이 적용되지 않는다.
  * **이 경우, 애초에 getter 구현 없이 a.b.c.d 형태로 코드가 수정되어야** 한다.
    * 자료 구조는 내부 구조가 공개되므로 별도의 조회 코드가 필요 없으며, 디미터 법칙을 거론할 필요도 없어진다.
* **자료 구조는 무조건 getter, setter 없이 공개 변수만을 포함하고, 객체는 비공개 변수와 공개 함수를 포함하는 것이 바람직**하다.
  * 그러나 사용하는 프레임워크나 표준에 따라 자료 구조에도 getter와 setter의 정의가 강요될 수 있다.

### 잡종 구조
* 최악의 경우 절반은 객체, 절반은 자료 구조인 형태의 클래스가 만들어질 수 있으며, 이를 잡종 구조라고 한다.
  * 예를 들어, 중요한 함수도 있고 공개 변수(또는 비공개 변수와 공개된 getter / setter)도 있다.
  * 이러한 클래스를 사용하는 개발자는 공개된 getter와 setter를 통해 절차적인 코드처럼 내부 변수를 사용하고 싶도록 만든다.
* 잡종 구조는 객체 지향적인 코드와 절차 지향적인 코드의 단점만 모인 최악의 구조이므로 피하는 것이 좋다.

### DTO
* 자료 구조체의 전형적인 형태는 public한 변수만 있고 아무런 함수가 없는 클래스이다.
  * 이러한 형태의 자료 구조체를 Data Transfer Object라고 한다.
  * DTO는 굉장히 유용한 구조체이다.
* 자료 구조체의 형태 중 더 일반적인 형태는 Bean이다.
  * Bean은 private한 변수와 public한 getter, setter를 갖는다.
  * 일종의 **사이비 캡슐화이며, 별다른 이익을 제공하지 못한다**.
* DTO의 특수한 형태로는 활성 레코드가 있다.
  * 활성 레코드는 DTO 또는 Bean의 형태에 save나 find와 같은 탐색 함수를 제공한다.
  * 주로 데이터베이스 테이블, 또는 다른 소스로부터 자료를 직접 변환한 결과로 사용된다.
* **활성 레코드는 자료 구조로 취급해야 한다**.
  * 활성 레코드에 비즈니스 규칙 메소드를 추가하여 객체로 취급해서는 안 되며, 이는 전형적인 잡종 구조이다.
  * 비즈니스 규칙을 담으면서 내부 자료를 숨겨야하는 작업은 객체로서 따로 생성하여 사용하는 것이 바람직하다.

### 결론
* 객체는,
  1. 동작을 공개한다.
  2. 내부 자료는 숨긴다.
  3. 기존 동작을 변경하지 않으면서 새로운 객체 타입을 추가히기 쉽다.
  4. 기존 객체에 새로운 동작을 추가하는 것은 어렵다.
* 자료 구조는,
  1. 내부 자료를 그대로 공개한다.
  2. 별도의 동작은 제공하지 않는다.
  3. 기존 자료 구조에 새로운 동작을 추가하기 쉽다.
  4. 기존 함수에 새로운 자료 구조를 추가하기는 어렵다.
* 시스템을 구현할 때,
  1. 새로운 자료 타입을 추가하기 위한 유연성이 필요하다면 객체와 객체 지향적인 코드가 적합하다.
  2. 새로운 동작을 추가하기 위한 유연성이 필요하다면 자료 구조와 절차적인 코드가 적합하다.
  3. 똑똑한 **개발자는 객체 지향적인 코드와 절차적인 코드에 편견 없이 직면한 문제에 대해 최적인 해결책을 찾아낸다**.

## 오류 처리
* 오류 처리는 프로그램에서 반드시 필요한 요소이다.
* 뭔가가 잘못될 가능성은 항상 존재하며, 이를 바로잡을 책임은 개발자에게 있다.
* 여기저기 흩어진 오류 처리 코드는 실제 코드의 기능을 파악하게 어렵게 만들며, 깨끗해져야할 필요가 있다.

### 오류 코드보다 예외 사용하기
* Java를 예로 들어, 코드는 논리 코드와 오류 처리 코드로 나누어 생각할 수 있다.
  * 메소드의 기능을 수행하는 논리 코드와 오류 처리 코드가 뒤섞이면 가독성과 코드 품질이 떨어진다.
  * 따라서 **오류가 발생하는 경우, 논리와 오류 처리를 뒤섞지 않도록 예외를 메소드 호출자에게 던지는 것이 낫다**.
* 논리 코드와 오류 처리 코드를 나누는 것으로 인해 가독성과 코드 품질을 개선할 수 있다.
  * 해당 코드의 개발자는 각 개념을 독립적으로 확인하고, 이해해볼 수 있게 된다.

### try - catch - finally 부터 작성하기
* try 블록은 어떤 면에서는 트랜잭션과 유사하다.
  * try 블록에서 무슨 일이 생기더라도 catch 블록은 프로그램의 상태를 일관성 있게 유지해야 하기 때문이다.
    * 때문에 try - catch - finally 블록부터 작성하는 것이 좋다.
    * 이를 통해 try 블록에서 생길 수 있는 모든 일에 대해 호출자가 기대하는 상태를 정의하기 쉬워진다.
* 우선 강제로 예외를 일으키는 테스트를 작성하고, 그 후 테스트를 통과하는 코드로 수정한다.
  * 이를 통해 자연스럽게 try 블록의 트랜잭션 범위를 구현하게 되므로, 범위 내에서 트랜잭션의 본질을 유지하기가 쉬워진다.

### unchecked 예외의 사용
* checked 예외는 메소드를 선언할 때 반환할 예외를 모두 선언부에 열거해주어야 한다.
  * 또한, 메소드가 반환하는 예외의 목록은 메소드 유형의 일부이다.
  * 코드가 메소드를 사용하는 방식이 메소드의 선언부와 다르면 컴파일도 되지 않는다.
* **checked 예외는 OCP를 위반**한다.
  * 예를 들어, 메소드에서 예외를 던지는데 이를 처리하는 catch 블록이 세 단계 위의 메소드에 있는 경우가 있다.
  * 하위 단계의 메소드 코드가 변경되면 상위 단계의 모든 메소드 선언부가 변경되어야 한다.
  * 심지어, 모둘의 내용이 바뀌지 않았더라도 선언부의 변경으로 인해 모듈 전체를 재빌드 후 배포해야 한다.
* 이렇듯 **checked 예외를 사용하는 케이스는 throws 경로 상에 위치하는 모든 함수로부터 연쇄적인 수정이 발생**한다.
  * 또한, **모든 함수가 최하위 함수가 던지는 예외를 알아야하므로 캡슐화도 깨진다**.
* 중요한 라이브러리의 작성 등, 때로는 checked 예외도 중요하다.
  * 그러나 일반적인 애플리케이션은에서는 checked 예외를 사용함으로써 발생한 의존성 처리에 드는 비용이 이득보다 더 커지게 된다.

### 예외에 의미를 제공하기
* Java에서는 모든 예외에 대한 호출 스택을 지원한다.
  * 그러나 호출 스택만으로는 예외의 발생한 이유를 설명할 수 없다. 부족하다.
* **실패하여 발생한 예외를 던질 때에는 예외 발생 전후 상황을 덧붙인다**.
  * 예를 들어, 오류 메시지에 실패한 연산과 실패 유형 등의 정보를 담아 예외와 함께 던진다.
  * **애플리케이션이 로깅을 사용한다면 catch 블록에서 오류를 기록할 수 있도록 충분한 정보가 넘겨져야** 한다.

### 호출자를 고려한 예외 클래스의 정의
* 오류를 분류하는 방법은 많다.
  1. 오류가 발생한 위치로 분류
  2. 오류가 발생한 컴포넌트로 분류
  3. 오류의 유형으로 분류
* 그러나 오류의 정의에서 개발자에게 가장 중요한 관심사는 **오류를 잡아내는 방법**이다!
* 일반적으로 외부 라이브러리를 사용하는 경우, 해당 라이브러리가 발생시킬 수 있는 모든 에러를 여러 개의 catch 문으로 작성하여 대비하는 경우가 있다.
  * 이를 통해 만들어진 중복이 심한 코드는 래퍼 클래스를 별도로 정의하여 간단하게 해결할 수 있다.
  * 래퍼 클래스는 호출하는 라이브러리의 API를 감싸며, 발생 가능한 모든 유형을 나타내는 하나의 예외 유형 하나를 반환한다.
* 래퍼 클래스는 외부 API를 사용하는 경우에 매우 유용하다.
  * **실제로도 외부 API를 사용할 때 래퍼 클래스의 사용은 필수적이다.**
    * 라이브러리와 프로그램 사이의 의존성이 떨어진다.
    * 또한, 나중에 다른 라이브러리로 변경하기도 쉽다!
  * 감싸기 기법을 활용한 래퍼 클래스는 특정 업체가 설계한 API의 방식에 종속되지 않도록 한다.
* 일반적으로 예외 클래스가 하나만 있어도 충분한 코드가 많다.
  * 예를 들어, 예외 클래스에 포함된 정보로 오류를 구분해도 괜찮은 경우가 있다.
* **한 예외는 잡지만 다른 예외는 무시해도 괜찮은 경우에만 여러 예외 클래스를 사용**한다.

### 정상 흐름을 정의하기
* 상술한 **예외 클래스의 정의의 핵심은 비즈니스 논리를 나타내는 코드와 오류 처리 코드를 분리하는 데에 있다**.
* 그러나 try 블록에서 대응하지 못하는 이상 상황에 대한 비즈니스 로직을 catch 블록에서 수행하는 경우, 가독성이 떨어지는 문제가 있다.
  * 이러한 예외 상황에 따라 달라지는 처리 방식은 논리를 이해하기 어렵게 만든다.
```
try {
  int amount = testDAO.getAmount();
  total += amount.getTotal();
} catch(TestAmountNotFound e) {
  // try 블록에서 에러가 발생한 경우, 다른 로직을 타야 한다.
  // 이러한 코드 구조로 인해 논리가 흐려지는 결과가 발생한다.
  total += getAnotherAmount();
}
```
* 상술한 경우, testDAO를 고쳐 getTotal()이 특수한 상황을 처리할 수 있도록 해야 한다.
  * 특수 사례 패턴에 해당하는 대응이며, 이러한 패턴은 클래스를 만들거나 객체를 조작하여 특수 상황을 처리한다.
  * 이를 통해 **클래스나 객체가 예외 상황을 캡슐화하여 처리하므로, 클라이언트 코드에서 예외 상황을 처리할 필요가 없어**진다.

### null을 반환하지 않기
* 습관적인 null의 반환은 우리가 흔히 저지르는 실수이다.
  * 이러한 습관은 한 줄 건너 하나씩 NullPointerException을 막기 위한 null 체크 코드를 작성하는 코드로 드러난다.
* null을 반환하는 코드는 일거리를 늘릴 뿐만 아니라, 호출자에게 문제를 떠넘기는 나쁜 방식이다.
* 이렇게 발생된 NullPointerException이 catch될지도 모르고, 아닐지도 모른다.
  * **그러나 어느 쪽이든 나쁜 상황**이다.
* 애플리케이션 저 아랫단에서 발생한 NullPointerException은 처리하기가 매우 힘들다.
* null을 반환하고 싶은 욕구가 든다면, 다음의 방식을 고려하여 해결한다.
  1. null 대신 예외를 던진다.
  2. 특수 사례 객체를 반환한다.
  3. 사용하려는 API가 외부 API라면, 래퍼 클래스를 활용한 감싸기 메소드로 예외를 던지거나 특수 사례 객체를 반환한다.
  * 대부분의 경우는 특수 사례 객체가 손쉬운 해결책이 된다.
  * Collections.emptyList()와 같은 메소드로 특수 사례 객체를 반환하면 가독성이 오를 뿐더러, NullPointerException의 발생 가능성도 줄일 수 있다. 

### null을 전달하지 않기
* 상술했듯이 메소드 작성자의 문제로 null이 반환되는 것은 나쁘다.
* 그러나 **메소드 호출자의 문제로 메소드의 인수로 null을 전달하는 것은 더 나쁘다**.
* 메소드 작성자는 인수로 null이 전달되는 경우를 방어하기 위해 다음의 상황을 고려할 수도 있다.
  1. 인수의 null 여부를 체크하고 새롭게 정의한 예외를 던지기...?
  * 이 방식은 던져진 예외를 처리할 처리기가 필요해지는 아쉬움이 있다.
  2. assert 문을 활용하여 인수의 null 여부를 체크하고 인수에 null이 전달되면 안된다고 알리기...? 
  * 이 방식은 코드 가독성에는 도움이 될지 모르지만, 여전히 문제를 해결하지 못한다.
  * 위 두 방식은 각자 다른 문제에 의해 문제를 완벽히 해결하지 못한다.
* 대다수의 프로그래밍 언어는 호출자의 실수로 인해 전달된 null을 처리하는 방법이 없다.
* 때문에 **메소드 호출자가 애초에 null을 인수로 넘기지 못하도록 금지 정책을 팀 내부에서 정의하는 것이 합리적**이다.
  * **인수로 null이 넘어온 경우, 메소드 작성자의 무책임이 아닌 메소드 호출자의 부주의**로 봐야 한다.
  * 이러한 정책을 통해 부주의한 실수를 저지를 확률을 낮춰야 한다.

### 결론
* **깨끗한 코드는 가독성만큼 안정성도 중요하며, 두 가치는 tradeoff 관계가 아니다**.
* **오류 처리 코드는 논리 처리 코드와 분리되어 각각 독자적으로 고려되어야** 한다.
* 이를 통해 작성된 깨끗한 코드는 오류 처리와 프로그램의 논리의 독립적인 추론을 가능케 하며, 코드 유지보수성을 크게 높여준다.

### 개인 리마인드용 - 특수 사례 패턴? 특수 사례 객체?
* 특수 사례 패턴은 특수한 상황에 대한 처리를 호출자에게 맡기지 않고, 함수 내부에서 적절한 기본값을 정의하는 것으로 이해하였다.
* Javascript로 예시를 들면 다음과 같다.
```
function getList(case) {
  let result;
  if(case === true)
    result = [ 1 ];
  if(case === false)
    result = [];
  return result;
}
```
* 위 코드는 case에 true나 false가 아닌 경우 undefined가 반환된다.
* 만약 배열을 받아 순회할 목적에서 해당 함수를 작성하였다면 undefined에 대한 처리를 호출자가 해야 한다.
* 특수 사례 패턴을 적용하면 다음과 같을 것이다.
```
function getList(case) {
  // default 값을 정의하는 것으로 외부 호출자는 더 이상 undefined 처리를 할 필요가 없다.
  let result = []; 
  if(case === true)
    result = [ 1 ];
  if(case === false)
    result = [];
  return result;
}
```
* Java의 경우, 위와 같은 상황은 Collections.emptyList() 메소드를 통해 빈 읽기 전용 리스트를 반환하는 것으로 대응할 수 있다.
  * 이렇게 반환되는 객체가 특수 사례 객체이다.
# CleanCode
## 2022-01-30 Sun

## 자료의 추상화
* 변수를 private으로 설정했더라도 getter와 setter가 public이라면 구현은 외부로 노출된 셈이다.
  * 단순히 변수 사이에 함수라는 계층을 추가한 것으로 구현이 숨겨지지는 않는다.
  * **구현을 숨기려면 추상화가 필요**히다.
* 사용자가 **구현을 모르는 채로 추상적인 인터페이스를 활용하여 자료의 핵심을 조작할 수 있어야만 진정한 의미의 클래스**라고 할 수 있다.
* 그러나 인터페이스를 사용한다고 해서 자료가 항상 감춰지는 것도 아니다.
  * **클래스에 포함된 자료를 세세하게 공개하는 것보다 추상적인 개념으로 표현하는 것이 좋다**.
```
// Bad: 구체적인 자료 구조이며, 인터페이스의 두 함수는 어떠한 변수의 값을 구체적인 형태로 그대로 반환하는 것처럼 보인다.
public interface Vehicle {
    double getFuelTankCapacityInGallons();
    double getGallonsOfGasoline();
}
// Good: 추상적인 객체이며, 백분율이라는 추상적인 개념으로 반환하므로 이 값이 어떤 변수로부터 비롯되었는지 알 길이 없다.
public interface Vehicle {
    double getPercentFuelRemaining();
}
```
* 상술한 예시와 같이, 객체는 세세하게 공개되는 것보다는 추상적인 개념으로 표현되는 것이 좋다.
  * 단순히 getter와 setter를 포함하는 인터페이스만으로는 추상화되지 않는다.
* **개발자는 객체가 포함하는 자료를 표현할 가장 좋은 방법을 심각하게 고민해야** 한다!
  * **아무 생각 없이 getter와 setter를 추가하는 것은 가장 나쁜 방법**이다.
* 단순히 class로 작성되었다고 클래스이며 객체라고 판단해서는 안된다.
  * 추상화 정도를 토대로 객체와 자료 구조를 구분하도록 하자.

### 자료와 객체의 비대칭성
* **객체는 추상화를 통해 자료를 숨기고, 자료를 다루는 메소드만을 제공**한다.
  * 즉, 객체와 클래스는 추상적이다.
* 반면 **자료 구조, 또는 자료 구조체는 자료를 그대로 공개하며, 별다른 함수를 제공하지 않는다**.
  * 즉, 자료 구조는 구체적이다.
* 이렇듯 객체와 자료 구조는 본질적으로 상반된 특징을 갖는다.
  1. 자료 구조를 활용하는 절차적인 코드
     * 기존 자료 구조를 변경하지 않으면서 새로운 함수를 추가하기 쉽다.
     * 그러나 새로운 자료 구조를 추가한다면, 절차적인 코드를 변경해야 한다.
  2. 객체를 활용하는 객체 지향적인 코드
     * 인터페이스에 새로운 함수를 추가하면 모든 구현체를 수정해야 하므로, 함수 추가가 어렵다.
     * 그러나 기존 함수를 변경하지 않고도 새로운 클래스를 추가하기 쉽다.
* 둘은 상호 보완적이며, 어느 것이 맞고 어느 것이 틀리다고 보기 어렵다.
  * 객체 지향 코드에서 어려운 변경은 절차적인 코드에서 쉽고, 그 반대도 성립한다.
* 따라서 시스템을 개발하는 과정에서 발생하는 요구사항에 따라 구분할 수 있다.
  1. 새로운 자료 타입이 생성되기 쉬운 경우, 인터페이스와 클래스, 객체 지향 기법을 활용한다.
  2. 새로운 함수가 추가되기 쉬운 경우, 자료 구조 형태의 클래스와 절차적인 코드를 활용한다.
* 분별 있는 프로그래머는 **모든 것이 객체라는 생각은 미신**이라는 것을 안다.
  * 때로는 단순한 자료 구조 형태의 클래스와 절차적인 코드가 적합한 상황도 있다.
  * 때문에 항상 객체 지향을 도입하는 것보다는 요구 사항이 새로운 자료 타입이 추가되기 쉬운지, 새로운 함수가 추가되기 쉬운지를 잘 고려하여 판단하는 것이 바람직하다.

### 개인 리마인드용
* 잘 이해가 안되는 부분이 많지만, 다음과 같이 정리하기로 했다.
1. 객체와 자료 구조는 다르며, 둘 중 무엇이 좋고 나쁘고는 없다. 용도가 다르다.
   * 단순히 class 문법으로 작성했다고 모두 클래스와 객체가 되는 것은 아니다.
   * 모든 인스턴스 변수가 public이거나, private이더라도 getter와 setter를 그대로 노출하는 것은 자료 구조이다.
2. 시스템의 요구 사항에 맞춰 객체 지향적인 코드를 사용하거나, 절차 지향적인 코드와 자료 구조를 사용한다.
   * 이 때, 객체 지향을 사용하기로 했다면 무분별한 getter와 setter를 제공하는 것은 지양한다.
   * 개발자는 객체와 클래스를 어떻게 추상화할지 심각하게 고민하여 메소드를 작성하고, 내부의 구조를 숨겨야 한다.
   * **내부의 구조를 숨기는 이유는 다른 코드들이 해당 클래스에 의존하지 못하도록 하기 위해서**이다.
* 다루고자 하는 클래스가 객체라면 **무언가를 하라고 해야지, 내부 구조를 알려달라고 해서는 안된다**.

### 디미터 법칙
* 모듈은 자신이 조작하는 객체의 내부를 알 수 없어야 한다는 법칙이다.
* 디미터 법칙에 따르면, 클래스 C의 메소드 f는 다음과 같은 메소드만 호출해야 한다.
  1. 클래스 C의 메소드
  2. 메소드 f가 생성한 객체
  3. 메소드 f의 인수로 넘겨진 객체
  4. 클래스 C의 인스턴스 변수가 참조하는 객체
  * **그러나 위 네 가지 메소드가 반환하는 객체의 메소드는 호출하지 말아야** 한다!
* 기차 충돌: 연쇄적으로 메소드가 호출되어 기차가 충돌하는 것처럼 보이는 코드를 말한다.
```
String result = a.getB().getC().getD();
```
* **특정한 코드가 디미터 법칙을 위반하는지 여부는 호출되는 것이 객체인지 자료 구조인지에 따라 다르다**.
* 객체의 정보를 토대로 연쇄적으로 호출한다면, 객체는 내부 구조가 숨겨져야 마땅하므로 디미터 법칙을 위반한다.
  * 위 코드를 예로 들면, a, b, c가 객체인 경우 디미터 법칙을 위반한다.
* 자료 구조의 정보를 토대로 연쇄적으로 호출한다면, 자료 구조의 내부 구조는 원래 공개되어야 하므로 디미터 법칙을 위반하지 않는다.
  * 위 코드를 예로 들면, a, b, c가 자료 구조인 경우 디미터 법칙이 적용되지 않는다.
  * **이 경우, 애초에 getter 구현 없이 a.b.c.d 형태로 코드가 수정되어야** 한다.
    * 자료 구조는 내부 구조가 공개되므로 별도의 조회 코드가 필요 없으며, 디미터 법칙을 거론할 필요도 없어진다.
* **자료 구조는 무조건 getter, setter 없이 공개 변수만을 포함하고, 객체는 비공개 변수와 공개 함수를 포함하는 것이 바람직**하다.
  * 그러나 사용하는 프레임워크나 표준에 따라 자료 구조에도 getter와 setter의 정의가 강요될 수 있다.

### 잡종 구조
* 최악의 경우 절반은 객체, 절반은 자료 구조인 형태의 클래스가 만들어질 수 있으며, 이를 잡종 구조라고 한다.
  * 예를 들어, 중요한 함수도 있고 공개 변수(또는 비공개 변수와 공개된 getter / setter)도 있다.
  * 이러한 클래스를 사용하는 개발자는 공개된 getter와 setter를 통해 절차적인 코드처럼 내부 변수를 사용하고 싶도록 만든다.
* 잡종 구조는 객체 지향적인 코드와 절차 지향적인 코드의 단점만 모인 최악의 구조이므로 피하는 것이 좋다.

### DTO
* 자료 구조체의 전형적인 형태는 public한 변수만 있고 아무런 함수가 없는 클래스이다.
  * 이러한 형태의 자료 구조체를 Data Transfer Object라고 한다.
  * DTO는 굉장히 유용한 구조체이다.
* 자료 구조체의 형태 중 더 일반적인 형태는 Bean이다.
  * Bean은 private한 변수와 public한 getter, setter를 갖는다.
  * 일종의 **사이비 캡슐화이며, 별다른 이익을 제공하지 못한다**.
* DTO의 특수한 형태로는 활성 레코드가 있다.
  * 활성 레코드는 DTO 또는 Bean의 형태에 save나 find와 같은 탐색 함수를 제공한다.
  * 주로 데이터베이스 테이블, 또는 다른 소스로부터 자료를 직접 변환한 결과로 사용된다.
* **활성 레코드는 자료 구조로 취급해야 한다**.
  * 활성 레코드에 비즈니스 규칙 메소드를 추가하여 객체로 취급해서는 안 되며, 이는 전형적인 잡종 구조이다.
  * 비즈니스 규칙을 담으면서 내부 자료를 숨겨야하는 작업은 객체로서 따로 생성하여 사용하는 것이 바람직하다.

### 결론
* 객체는,
  1. 동작을 공개한다.
  2. 내부 자료는 숨긴다.
  3. 기존 동작을 변경하지 않으면서 새로운 객체 타입을 추가히기 쉽다.
  4. 기존 객체에 새로운 동작을 추가하는 것은 어렵다.
* 자료 구조는,
  1. 내부 자료를 그대로 공개한다.
  2. 별도의 동작은 제공하지 않는다.
  3. 기존 자료 구조에 새로운 동작을 추가하기 쉽다.
  4. 기존 함수에 새로운 자료 구조를 추가하기는 어렵다.
* 시스템을 구현할 때,
  1. 새로운 자료 타입을 추가하기 위한 유연성이 필요하다면 객체와 객체 지향적인 코드가 적합하다.
  2. 새로운 동작을 추가하기 위한 유연성이 필요하다면 자료 구조와 절차적인 코드가 적합하다.
  3. 똑똑한 **개발자는 객체 지향적인 코드와 절차적인 코드에 편견 없이 직면한 문제에 대해 최적인 해결책을 찾아낸다**.
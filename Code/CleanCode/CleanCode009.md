# CleanCode
## 2022-02-02 Wed

## 동시성
* 동시성과 깔끔한 코드는 양립하기가 어렵다!
* 동시성은 결합(coupling)을 없애기 위해 고려할 수 있는 전략이다.
  * **정확히는 육하원칙에서 무엇과 언제를 분리하는 전략**이다.
* 단일 스레드 프로그램은 무엇과 언제가 밀접하지만, 이를 성공적으로 분리하면 애플리케이션의 구조와 효율이 극적으로 향상된다.

### 미신과 오해
* 동시성은 언제나 유익하지는 않지만, 반드시 필요한 상황이 존재한다.
* 그러나 동시성은 어려울 뿐더러, 다음과 같은 일반적인 오해가 쌓여 있다.
  1. 동시성은 항상 성능을 높인다?
     * 예를 들어, 대기 시간이 매우 길어 여러 스레드가 하나의 프로세스를 공유할 수 있는 경우라면 그렇다.
     * 또는 여러 프로세서가 동시에 처리할 독립된 계산이 많은 경우에도 그렇다.
     * 그러나 **두 가지 경우 모두 자주 발생하는 상황이 아니며, 때문에 동시성은 떄떄로 성능을 높인다고 봐야** 한다.
  2. 동시성의 구현과 설계는 관계가 없다?
     * 단일 스레드 시스템과 다중 스레드 시스템은 설계 자체가 크게 다르다.
     * 일반적으로, 무엇과 언제가 분리되면 시스템의 구조는 크게 달라진다.
* 반면 다음의 내용은 동시성과 관련하여 타당한 사실을 서술한다.
  1. 동시성은 다소 부하를 유발한다.
     * 성능 측면에서 추가적인 부하가 있으며, 추가적인 코드 작성도 필요하다.
  2. 동시성은 복잡하다.
     * 간단한 문제라도 동시성을 활용하면 어려워진다.
  3. 일반적으로 동시성 버그는 재현이 어렵다.
     * 때문에 실제 결함으로 간주되지 않고, 일회용 버그로 여겨 무시되는 경우가 많다.
  4. 동시성을 구현하려면 대부분 근본적인 설계 전략을 재고해야 한다.
* 동시성은 간단한 로직에서도 두 스레드가 같은 변수를 동시에 참조하는 경우가 발생하기 쉬워 문제가 발생한다.
  * 대부분의 경우 올바른 답을 내놓지만, 그렇다고 해도 잘못된 결과를 내는 일부의 경로는 문제가 된다.

## 2022-02-03 Thu
### 동시성 방어 원칙
* 단일 책임 원칙을 준수한다.
  * 동시성 코드는 독자적인 개발, 변경, 조율 주기가 있다.
  * 동시성 코드는 다른 코드와는 다른 독자적인 난관이 있다.
  * 동시성 코드는 주변에 있는 코드가 발목을 잡지 않더라도 충분히 어렵다.
  * 따라서, **동시성 코드는 다른 코드와 분리되어야 한다**.
* 자료 범위를 제한한다.
  * 객체 하나를 공유하여 동일 필드를 수정하면 예상치 못한 결과가 발생한다.
    * 때문에 임계 영역의 수 자체를 줄이는 것이 중요하다.
  * 공유 자료를 수정하는 위치가 많을수록,
    1. 보호할 임계 영역의 처리를 빼먹거나,
    2. 모든 임계 영역을 올바르게 보호했는지 확인하느라 반복적인 작업을 수행하거나,
    3. 안그래도 찾기 어려운 버그가 더욱 찾기 어려워진다.
  * 따라서, **자료를 캡슐화하고 공유 자료를 최대한 줄여야 한다**.
* 자료의 복사본을 이용한다.
  * **공유 자료를 줄이려면 처음부터 공유하지 않는 방법이 가장 좋다**.
    * 예를 들어, 객체를 복사하여 읽기 전용으로 사용하는 방법을 적용할 수 있다.
  * 객체를 복사하는데에서 발생하는 부하가 우려될 수 있으나, 동기화를 피할 수 있다면 이로 인해 절약한 수행 시간이 더 이득이 될 수 있다.
* 쓰레드는 가능한 한 독립적으로 구현되어야 한다.
  * 다른 쓰레드와 자료를 공유하지 않고, 각 쓰레드는 요청 하나를 처리한다.
  * 이 과정에서, 쓰레드가 사용하는 모든 정보는 비공유 지역에서 가져와 자신의 로컬 별수에 저장한다.
  * **이를 통해 마치 쓰레드들이 세상에 자신만이 존재하는 것처럼 동작하도록 할 수 있고, 다른 쓰레드와 동기화할 필요가 없어진다**.
  * 독자적인 쓰레드로서 가능하면 다른 프로세서에서도 동작할 수 있도록, 자료를 독립적인 단위로 분할한다.

### 라이브러리를 이해하기
* Java는 1.5부터 동시성 측면에서 발전이 있었다.
* 1.5 이상의 Java를 사용한다면 다음의 내용을 고려해야 한다.
  1. 쓰레드 환경에서 안전한 컬렉션을 사용한다.
     * 예를 들어, ConcurrentHashMap은 거의 모든 상황에서 HashMap보다 빠르고 쓰레드 안전하다.
  2. 서로 무관한 작업을 수행할 때는 executor 프레임워크를 활용한다.
  3. 가능하다면 쓰레드가 블로킹되지 않는 방법을 활용한다.
  4. 일부 클래스 라이브러리는 애초에 쓰레드 안전하지 못하다.
* **복잡한 동시성 설계는 언어 차원에서 지원하는 클래스의 사용을 고려**한다.
  * ReentrantLock, Semaphore, CountDownLatch 등이 있다.
  * 더 나가아 다음의 패키지를 익힐 수 있도록 해야 한다.
    1. java.util.concurrent
    2. java.util.concurrent.atomic
    3. java.util.concurrent.locks

### 다중 쓰레드 실행 모델의 이해
* 다중 쓰레드 애플리케이션을 분류하는 방식은 크게 다음과 같다.
    1. 생산자-소비자: 생산자와 소비자 사이에 한정된 자원인 대기열을 두는 방식에 해당한다.
    2. 읽기-쓰기: 읽기 쓰레드가 공유 자원을 읽지만, 쓰기 쓰레드가 간혹 공유 자원을 갱신하는 경우에 해당한다.
    3. 식사하는 철학자들: 쓰레드의 동작에 여러 자원이 필요한 경우, 각 쓰레드가 몇몇 자원만을 점유하여 다른 자원의 해제를 기다리는 경우에 해당한다.
* 대다수의 다중 쓰레드 문제는 이러한 세 경우 중 하나에 속한다.
* 각 모델을 학습하고, 해법을 직접 구현하는 것으로 실전 문제에 대비해야 한다.

### 동기화하는 메소드 사이에 존재하는 의존성을 이해하기
* 동기화하는 메소드 사이에서 의존성이 존재하면 동시성 코드에서 찾아내기 어려운 버그가 발생한다.
* Java의 경우, 각각의 개별 메소드를 보호하는 synchronized 키워드를 제공한다.
  * **그러나 공유 클래스 하나에 동기화 메소드가 여럿이라면, 구현이 올바른지 다시 확인**해야 한다.
  * **공유 객체 하나에는 메소드를 하나만 사용한다**.
* 공유 객체 하나에 여러 메소드가 필요한 상황도 발생할 수 있으며, 이 경우 다음의 방법을 고려한다.
  1. 클라이언트에서 잠그기: 클라이언트에서 첫 번째 메소드를 호출하기 전에 서버를 잠근다.
     * 마지막 메소드를 호출할 때까지는 잠금을 유지한다.
  2. 서버에서 잠그기: 서버를 잠그고 모든 메소드를 호출한 후에 잠금을 해제하는 메소드를 서버 측에 구현하고, 클라이언트가 이를 호출하도록 한다.
  3. 연결 서버: 잠금을 수행하는 중간 단계를 작성한다.
     * 서버에서 잠그는 방식과 유사하지만, 기존의 서버를 변경하지 않는다.

### 동기화하는 부분을 작게 만들기
* Java의 synchronized 키워드는 락을 설정하며, 같은 락으로 감싼 코드 영역은 하나의 쓰레드만 실행이 가능하다.
  * 이러한 락은 쓰레드를 지연시키고, 부하를 가중시키는 역기능이 있다.
* synchronized 문은 남발하지 않고, 필요한 영역에서만 사용해야 한다.
  * 예를 들어, 임계 영역은 반드시 보호해야 한다.
  * 코드를 작성할 때에는 임계 영역의 수를 최대한 줄인다.
* 필요 이상으로 synchronized 블록을 크게 만드는 것도 지양해야 한다.
  * 이는 쓰레드 간의 경쟁 상태를 늘리고, 결과 프로그램의 성능을 떨어트린다.
* **동기화하는 부분은 최대한 작게 만들어져야 한다**.

### 올바른 종료 코드의 구현은 어렵다!
* 영구적으로 동작하는 시스템의 구현과 잠시만 동작한 후 깔끔하게 종료하는 시스템의 구현은 다르다.
* 깔끔하게 종료하는 코드는 바르게 구현하기 매우 어렵다.
  * 다중 쓰레드 환경에서, 이러한 코드는 데드락이 빈번하게 발생한다.
* 만약 깔끔하게 종료하는 다중 쓰레드 코드를 작성해야 한다면 개발 초기부터 고민하고 구현을 시도해야 한다.
  * 계획보다 오래걸릴 가능성이 높으며, 생각보다 어려우므로 이미 고안된 알고리즘을 검토해야 한다.

### 쓰레드 코드의 테스트
* 올바른 코드를 증명하기는 현실적으로 불편하므로, 충분한 테스트를 통해 위험을 낮추는 방식을 택한다.
* 그러나 공유 자원을 사용하는 쓰레드가 늘어나기 시작하면 상황이 크게 복잡해진다.
* 다중 쓰레드 시스템의 경우, 문제를 노출하는 테스트 케이스를 작성한다.
  * 또한 프로그램의 설정과 부하를 바꾸어가며 자주 테스트한다.
  * 실패한 원인은 반드시 추적하고 해결되어야 하며, 과반수의 테스트에 통과한다고 그냥 넘어가는 일은 절대로 발생해서는 안된다.

### 쓰레드 코드 작성의 구체적인 지침
1. 말이 되지 않는 실패는 잠정적인 쓰레드 문제로 취급한다.
   * 대다수 개발자는 쓰레드가 다른 코드와 상호작용하는 방식을 직관적으로 이해하지 못한다.
   * 쓰레드 코드에서 발생하는 버그는 수백만 번에 한 번씩 발생하기도 하며, 에러의 재현이 매우 어려울 수 있다.
   * **그러나 문제를 일회성으로 치부하고 그냥 넘어가지 않아야 한다**.
     * 일회성 문제를 계속해서 무시하면 잘못된 코드 위에 잘못된 코드가 쌓이는 꼴이다.
2. 다중 쓰레드를 고려하지 않은 순차 코드부터 제대로 작성한다.
   * 쓰레드 환경 밖에서 발생하는버그와 다중 쓰레드 환경에서 발생하는 버그를 동시에 디버깅하지 않는다.
   * 우선 쓰레드 환경 밖에서 발생하는 코드를 똑바로 테스트하고, 디버깅해야 한다.
     * 일반적으로 쓰레드가 호출하는 POJO를 만든다.
     * POJO로 작성된 코드는 쓰레드를 알지 못하므로, 쓰레드 환경 밖에서도 테스트가 가능하다.
     * POJO에 포함되는 코드는 많을수록 좋다.
3. 다중 쓰레드를 활용하는 코드는 다양한 환경에 쉽게 끼워넣을 수 있도록 작성한다.
   * 쓰레드의 수를 바꾸어 실행하거나, 실행 중에 쓰레드 수를 바꿔본다.
   * 쓰레드 코드를 운영 환경과 테스트 환경에서 돌려본다.
   * 테스트 코드를 다양한 속도로 돌려본다.
   * 반복 테스트가 가능하도록 테스트 케이스를 작성한다.
   * **다양한 설정에서 실행할 목적으로, 여러 다른 환경에 쉽게 끼워넣을 수 있는 코드를 작성해야** 한다.
4. 다중 쓰레드를 활용하는 코드 부분은 상황에 맞게 조율할 수 있도록 작성되어야 한다.
   * 적절한 쓰레드 개수를 파악하려면 상당한 시행착오가 필요하므로, 처음부터 다양한 설정으로 프로그램의 성능 측정 방법을 강구한다.
   * 쓰레드의 개수를 조율하기 쉽게 코드를 구현한다.
5. 프로세서 수보다 많은 쓰레드를 동작시켜본다.
   * 시스템이 쓰레드를 스와핑할 때에도 문제가 발생할 수 있다.
   * 스와핑을 고의로 일으키기 위해 프로세서 수보다 많은 쓰레드를 활용한다.
   * 스와핑이 많아질수록 임계 영역 처리를 빼먹은 코드와 데드락을 발생시키는 코드를 찾기 쉬워진다.
6. 다른 플랫폼에서 돌려본다.
   * 다중 쓰레드 코드는 플랫폼에 영향을 받는다!
   * 처음부터, 자주 모든 목표 플랫폼에서 코드를 동작시켜본다.
   * 운영체제마다 쓰레드를 처리하는 정책이 다르기 때문에 결과는 달라질 수 있다.
7. 코드에 보조 코드를 넣어 돌려보고, 강제로 실패를 일으키게 한다.
   * 쓰레드 코드는 오류를 찾기 쉽지 않으며, 이는 코드의 실행 경로 중 실패 케이스가 소수에 해당하기 때문이다.
   * 이러한 경우 wait, yield, sleep 등의 보조 코드를 추가하여 코드의 실행 순서를 조절해볼 수 있다.
     * 잘못된 코드는 차라리 초반에 자주 실패하는 편이 좋다.
   * 코드에 보조 코드를 추가하는 방법은 크게 두가지이다.
     1. 직접 구현하기
     2. 자동화하기

### 코드에 보조 코드를 추가하는 방법
1. 직접 구현하기
   * 코드에 wait, sleep, yield, priority 함수를 추가하여 테스트한다.
   * 까다로운 테스트를 테스트할 때에 적합하다.
   * yield를 예로 들어, 코드의 실행 경로를 명시적으로 변경하므로 이전에 드러나지 않았던 버그가 발생할 확률을 높여준다.
   * 이러한 경우 **코드의 실패는 yield의 추가가 원인이 아니며, 원래 잘못된 코드임이 드러났을 뿐**이다.
   * 직접 구현하는 방식은 다음과 같은 어려움이 있다.
     1. 보조 코드를 삽입할 위치를 찾아야 한다.
     2. 보조 코드를 그대로 남겨두면 프로그램의 성능에 악영향을 미친다.
     3. 무작위적이며, 사실상 버그가 드러나지 않을 확률이 더 높다.
   * 배포 환경 뿐만 아니라 테스트 환경에서도 보조 코드를 실행하거나, 실행할 때마다 설정을 변경할 방법을 고려해야 오류가 드러날 확률이 높아진다.
   * **쓰레드를 전혀 모르는 POJO와 쓰레드를 제어하는 클래스로 프로그램을 분할했다면 보조 코드를 추가할 위치를 찾기 쉬워진다**.
2. 자동화하기
   * 보조 코드를 자동으로 추가하기 위해 적절한 자동화 도구를 사용한다.
   * 코드를 흔들어(jiggle) 쓰레드를 매번 다른 순서로 실행해본다.
   * 좋은 테스트 케이스와 흔들기 기법은 오류 발생 확률을 크게 높여준다.

### 결론
* 다중 쓰레드 코드는 올바로 구현하기 매우 어려우며, 작성해야 하는 경우에는 신중하고 깨끗하게 작성한다.
  1. 반드시 SRP를 준수한다.
  2. POJO를 활용하여 쓰레드를 아는 코드와 모르는 코드로 분리한다.
  3. 쓰레드 코드의 테스트 시에는 쓰레드만 테스트한다.
  4. **쓰레드 코드는 최대한 작아야 한다**.
  * **이렇듯 깔끔한 접근 방식을 취한다면 코드가 올바로 동작할 가능성이 크게 높아진다**.
* 동시성 오류를 일으키는 잠정적인 원인을 철저히 이해한다.
* 보호할 코드를 찾는 방법과, 특정한 영역을 잠그는 방법을 이해한다.
  * 잠글 필요 없는 코드는 잠그지 않도록 한다.
* 공유하는 객체 수와 범위를 최대한 줄여야 한다.
* 클라이언트에게 공유 상태를 관리할 책임을 떠넘기지 않는다.
* 쓰레드 코드는 뜬금 없이 오류가 발생할 수 있다.
  * 이를 **사전에 적발하기 위해 많은 플랫폼에서 많은 설정으로 반복적으로, 계속해서 테스트**한다.
  * 이러한 테스트 용이성은 TDD 3대 규칙을 따르는 것으로 자연히 얻어질 수 있으므로, 적극적으로 활용한다.
  * 테스트 용이성이란, 더 넓은 설정 범위에서 코드를 수행하기 위해 필요한 기능을 제공할 수 있을 정도로 플러그인된 수준을 말한다.
* 초반부터 보조 코드를 고려하고, 시간을 들여 보조 코드를 추가하는 것으로 오류를 발생시켜본다.
* 어떻게 하더라도 문제는 발생하며, **문제를 일회성으로 치부하여 처리하지 않고 넘기는 일은 발생하지 않도록 해야 한다**.
* **쓰레드 코드는 출시하기 전까지 최대한 오랫동안 동작시켜보아야 한다**.
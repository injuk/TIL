# CleanCode
## 2022-02-03 Thu

## 점진적인 개선
* 프로그래밍은 과학보다는 공예에 가깝다.
* **깨끗한 코드를 작성하려면 먼저 지저분한 코드를 작성한 후에 반드시 정리**해야만 한다.
  * 작문과 유사하다. 초안을 작성하고, 퇴고하여 2안, 3안, 최종안을 작성한다.
* 대부분의 개발자는 우선 돌아가는 프로그램을 만들고, 그 후에 다음 업무로 넘어간다.
  * 이와 같은 행동은 전문가로서는 자살행위에 가깝다!
  * 만약 이런 생각을 하고 있다면, 자신이 짠 코드의 초안(이자 완성본)을 남들이 봤을 때 어떤 생각을 할지 떠올려보자.

### 잠깐 멈추기
* 여러 요구사항을 만족하는 과정에서 코드가 기하급수적으로 지저분해짐을 느낀다면, 우선 작업을 멈춘 후 리팩토링을 진행해보자.
  * 개발을 계속한다면 동작하는 프로그램은 완성될지 몰라도 리팩토링 조차 어려운 코드가 될 가능성이 높다.

### 점진적으로 개선하기
* **프로그램을 망가트리는 가장 좋은 방법은 개선이라는 명목 아래 구조를 크게 바꾸는 것**이다.
  * 이 경우, 프로그램은 개선되는 것이 아니라 회복되지 않을 정도로 망가질 수도 있다.
* **TDD는 언제나 프로그램이 돌아가야 한다는 원칙을 따르므로, 점진적인 개선에 적합**하다.
  * TDD는 시스템을 망가트리는 변경과 개선사항을 허용하지 않는다.
  * TDD과정에서 변경 전 후의 프로그램이 모두 동작한다는 것을 확인하기 위해, 언제든지 확인할 수 있는 자동화된 테스트 수트를 작성하도록 한다.
    * 일반적으로 자동화된 테스트 수트는 단위 테스트 수트와 인수 테스트 수트로 구성된다.
* **소프트웨어 설계는 분할만 잘해도 품질이 크게 높아진다**.
  * 적절한 위치에 코드를 분리하기만 해도 설계는 훨씬 좋아진다.
  * 관심사, 도메인을 분리하면 코드를 이해하고 보수하기 훨씬 쉬워질 수 있다.

### 결론
* **단순히 돌아만 가는 코드에 만족하는 프로그래머는 전문가 정신이 부족한 것**이다.
  * 설계와 구조를 개선할 시간이 없다고 말할 수도 있으나, 이는 말 그대로 변명에 불과하다.
  * **나쁜 코드보다 프로젝트에 장기적으로 악영향을 미치는 요인은 없다**.
* 나쁜 일정, 나쁜 요구사항은 다시 짜거나 정의할 수 있다.
  * 그러나 나쁜 코드는 썩어 문드러지며, 영원히 악성 코드라는 굴레에서 벗어날 수 없게 만든다.
* 나쁜 코드도 깨끗한 코드가 될 수 있지만, 개선하는 작업은 비용이 크게 드는 작업이며 상당한 시간과 인내를 필요로 한다.
  * 반면 **처음부터 깨끗한 코드를 작성하고, 계속해서 유지하는 것은 상대적으로 쉽다**.
* **코드는 언제나 깔끔하고 단순하게 정리해야 하며, 썩어 문드러지도록 방치해서는 안된다**.
# CleanCode
## 2022-02-04 Fri

## 냄새와 휴리스틱
* 아래의 사항은 모두 코드 냄새에 속하는 항목이다.
### 주석
1. 부적절한 정보
* 변경 이력 등, 소스 코드 관리 시스템과 같은 별도 시스템에 저장할 수 있는 정보는 주석으로 작성하지 않는다.
  * 일반적으로 작성자, 최종 수정일, 이슈 번호 등과 같은 메타 정보만 주석으로 작성한다.
  * 주석은 코드와 설계에 기술적인 설명을 부연하는 수단이다.
2. 쓸모 없는 주석
* 오래되거나 엉뚱한, 잘못된 주석은 더 이상 쓸모가 없다.
  * 쓸모 없어진 주석은 빠르게 삭제하는 것이 좋다.
  * 쓸모 없어질 주석은 애당초 작성하지 않는 것이 좋다.
* 쓸모 없는 주석은 코드와 무관하며, 코드를 그릇된 방향으로 이끌 수 있다.
3. 중복된 주석
* 코드만으로 충분한데 구구절절 설명을 주석으로 덧붙일 필요는 없다.
```
num += 1; // num에 1을 더한다.
```
* 메소드 시그니쳐만 설명하는 Javadoc도 중복된 주석이다.
```
/**
 * @param isVideo 값.
 * @param files 목록.
 */
function makeList(isVideo, files = []) {
// 생략
```
4. 성의 없는 주석
* 작성할 가치가 있는 주석이라면 시간을 들여 최대한 멋지게 작성되어야 한다.
  * 단어를 신중히 선택하고, 문법을 준수한다.
  * 간결하고 명료하게 작성한다.
5. 주석 처리된 코드
* 주석으로 처리된 코드는 얼마나 오래되었고, 얼마나 중요한지 알 방법이 없다.
  * 때문에 누군가가 사용할 것이라고 믿고 아무도 삭제하지 않으며, 주석 처리된 코드는 낡아간다.
* 주석으로 처리된 코드는 흉물 그 자체이므로, 내버려두지 말고 발견 즉시 지워버려야 한다.
  * 어차피 소스 코드 관리 시스템이 기억할 것이다.
  
### 환경
1. 여러 단계로 빌드되어야 하는 프로그램
* 빌드는 한 단계로 끝나야 한다.
* 이해할 수 없는 명령이나 스크립트를 실행하여 각각의 요소를 따로 빌드할 필요가 없어야 한다.
* 하나의 명령으로 전체를 체크아웃하고, 다시 하나의 명령으로 빌드가 가능해야 한다.
2. 여러 단계로 테스트되어야 하는 프로그램
* 모든 단위 테스트는 하나의 명령어로 수행되어야 한다.
  * IDE에서 원 버튼을 통해 모든 테스트가 동작하는 것이 가장 이상적이다.
* 모든 테스트를 한 번에 실행하는 능력은 아주 근본적이며, 또 중요하므로 그 방법은 빠르고, 쉽고, 명백해야 한다.

### 함수
1. 너무 많은 인수를 갖는 함수
* 함수에서 인수 목록은 적을 수록 좋다.
* 인수는 하나도 없는 것이 가장 좋다.
2. 출력 인수를 사용하는 함수
* 출력 인수는 직관적이지 못하다.
* 함수에서 뭔가의 상태를 변경해야 한다면, 출력 인수가 아닌 함수가 속한 객체의 상태를 변경하도록 해야 한다.
3. 플래그 인수를 사용하는 함수
* **boolean 형태의 인수는 함수가 여러 기능을 수행한다는 명백한 증거이므로, 반드시 피해야 한다**.
4. 아무도 호출하지 않는 함수
* 죽은 함수는 낭비이므로 과감히 삭제한다.
  * 이 역시 소스 코드 관리 시스템에 의해 기억되므로, 걱정할 필요가 없다!

### 일반
1. 하나의 소스 파일에 여러 프로그래밍 언어가 혼재되는 경우
* 이상적으로는 소스 파일 하나에 언어 하나만 사용하는 방식이 가장 좋다.
* 하나의 소스 파일에 포함되는 언어 수와 범위를 최대한 줄일 수 있도록 해야 한다.
2. 당연한 동작이 구현되지 않은 경우
* 함수나 클래스는 다른 프로그래머가 당연하게 여길 만한 동작과 기능을 제공해야만 한다.
* 당연한 동작이 구현되지 않으면, 코드를 읽거나 사용하는 사람이 함수의 기능을 직관적으로 예상하기 어렵다.
  * 나아가 함수 작성자를 믿지 못하게 되며, 코드를 일일이 살피도록 만든다.
3. 경계가 올바르게 처리되지 않은 경우
* [경계란?](https://github.com/injuk/TIL/blob/master/Code/CleanCode/CleanCode006.md)
* 일반적으로 개발자들은 머릿속에서 코드를 동작시키는 것으로 끝낸다.
  * 자신의 직관에 의존하며, 모든 경계에서 코드를 증명하려고 하지 않는다.
* 모든 경계 조건, 모든 예외는 우아하고 직관적인 알고리즘을 좌초시킬 수 있는 암초이다.
* 스스로의 직관에 의존하지 말고, **부지런하게 모든 경계 조건을 찾아내어 이를 테스트할 수 있는 테스트 케이스를 작성**해야 한다.
4. 안전 절차를 무시하는 경우
* 안전 절차를 무시하는 행위가 위험하다는 것은 상식이다.
* 당연히 컴파일러 경고를 꺼버리는 경우나, 실패한 테스트 케이스를 무시하는 행위 역시 위험하다.
5. 중복된 코드
* 코드에서 발견된 중복은 추상화할 기회로 간주되어야 한다.
  * 중복된 코드를 하위 루틴이나 별도의 클래스로 분리한다.
* 추상화로 중복을 정리하면 설계 언어의 어휘가 늘어나며, 추상화 수준이 높아지므로 구현이 빨라지고 오류가 적어진다.
* 코드가 중복되는 유형은 크게 다음과 같이 분류할 수 있다.
  1. 같은 코드가 여기 저기서 발견되는 경우
     * 복사 붙여넣기의 잔재이다.
     * 이러한 중복은 간단한 메소드로 교체되어야 한다.
  2. 여러 모듈에서 switch / case문이나 if / else 문을 통해 같은 조건을 확인하는 중복의 경우
     * 이러한 중복은 다형성으로 대체되어야 한다.
  3. 알고리즘은 유사하지만, 실행 코드가 다른 중복의 경우
     * TemplateMethod 패턴이나 Strategy 패턴으로 중복을 제거한다.
     * [TemplateMethod 패턴](https://github.com/injuk/TIL/blob/master/Code/DesignPattern/DesignPattern001.md), [Strategy 패턴](https://github.com/injuk/TIL/blob/master/Code/DesignPattern/DesignPattern008.md)
* 대부분의 디자인 패턴은 중복을 제거하는 방법이다. 
* 어디서든 중복을 발견하면 없앨 수 있어야 한다!
6. 추상화 수준이 올바르지 않은 경우
* 추상화는 저차원 상세 개념에서 고차원 일반 개념을 분리한다.
* 추상화는 철저하게 모든 저차원 개념을 파생 클래스에, 고차원 개념을 기초 클래스에 정의해야 한다.
  * 기초 클래스는 구현 정보 및 세부사항에 무지해야 한다.
* 추상화는 개발자에게 가장 어려운 작업 중 하나이며, 잘못된 경우 임시변통으로 고치는 방법이 불가능하다.
7. 기초 클래스가 파생 클래스에 의존하는 경우
* 개념을 기초 클래스와 파생 클래스 사이에서 분리하는 이유는 개념 간의 독립성을 보장하기 위해서이다.
* 일반적으로, 기초 클래스는 파생 클래스에 대해 무지해야 한다.
8. 과도한 정보를 담는 경우
* 잘 정의된 모듈은 인터페이스가 작으며, 작은 인터페이스로도 다양한 동작이 가능하다.
* 잘 정의된 인터페이스는 많은 함수를 제공하지 않으므로 결합도도 낮아진다.
  * 부실하게 정의된 인터페이스는 온갖 함수를 호출하도록 제공하므로, 결합도가 높아진다.
* 개발자는 클래스나 모듈 인터페이스에 노출할 함수를 제한할 수 있어야 한다.
* 일반적으로,
  1. 클래스가 제공하는 메소드는 적을수록 좋다.
  2. 함수가 알고 있는 변수 수는 적을수록 좋다.
  3. 클래스에 포함되는 인스턴스 변수 수는 적을수록 좋다.
  * 즉, 정보를 제한하는 것으로 결합도를 낮추어야 한다.
9. 실행되지 않는 죽은 코드가 포함된 경우
* 불가능한 조건을 확인하는 if문과 throw가 없는 catch 블록이 예시가 된다.
* 죽은 코드를 발견하면 그 즉시 제거할 수 있어야 한다.
10. 수직으로 크게 분리되는 경우
* 변수와 함수는 사용되는 위치에 가깝게 정의해야 한다.
  * 예를 들어, 지역 변수는 사용하기 직전에 선언되어야 한다.
  * 비공개 함수는 호출 직후에 정의해야 한다.
11. 일관성이 부족한 경우
* 어떤 하나의 개념을 특정한 방식으로 구현했다면, 유사한 개념도 같은 방식으로 구현되어야 한다.
* 표기법은 신중하게 결정하며, 하나의 함수에서 결정한 표기법을 다른 함수에서도 적용한다.
12. 잡동사니
* 비어 있는 기본 생성자, 사용되지 않는 변수, 함수, 등등은 모두 발견 즉시 제거되어야 한다.
* 소스 코드는 언제나 깔끔하게 정리하고, 유지해야 한다.
13. 인위적인 결합이 발생한 경우
* 서로 관련 없는 개념을 인위적으로 결합하지 않아야 한다.
  * 예를 들어, 일반적인 경우에 enum은 특정 클래스에 속할 필요가 없다.
  * 범용적으로 사용되는 static 메소드도 특정 클래스에 반드시 속해야만 하는 이유가 없다.
* 일반적으로, 이러한 인위적인 결합은 당장 편한 위치에 정의하는 것으로 발생한다.
  * 함수, 상수, 변수의 선언에는 시간을 들여 올바른 위치를 고민해야 한다.
14. 기능에 대한 욕심
* 클래스의 메소드는 자신 클래스의 변수와 함수에만 관심을 가져야 한다.
* 다른 클래스의 변수와 함수에 관심을 갖고, 참조자와 변경자를 통해 그 객체를 조작하지 않아야 한다.
* 하나의 클래스의 내용을 다른 클래스에 노출하는 이러한 문제는 일반적으로 제거되는 것이 바람직하다.
15. 선택자 인수
* 선택자 인수는 일반적으로 boolean을 인수로 받는 경우를 말한다.
  * **선택자 인수는 가독성을 떨어트릴 뿐더러 여러 함수의 기능을 하나로 조합**하고자 한다.
* boolean을 통해 동작이 변경되는 함수는 하나의 함수를 작은 함수로 쪼개지 않으려는 게으름의 결과이다.
* boolean 뿐만 아니라, 인수를 통해 함수의 동작을 제어하는 행위는 모두 바람직하지 않다.
16. 의도가 모호한 경우
* 코드를 작성할 때에는 읽는 사람에게 코드의 의도를 명백히 밝힐 수 있도록 신중하게 작성한다.
  * 수식의 행을 마음대로 변경하거나, 헝가리식 표기법을 적용하는 경우가 이를 위반한다.
17. 잘못 지운 책임
* 개발자의 중요한 결정 중 하나는 코드를 배치할 위치를 결정하는 것이다.
  * 결정이 어렵다면, 함수의 이름을 참고하여 기능이 배치되어야 하는 위치를 결정한다.
* 코드는 읽는 사람으로 하여금 자연스러운 위치에 배치해야 한다.
  * 개발자가 편리한 배치 방식을 활용하기보다는 독자에게 직관적인 위치를 사용하도록 한다.
18. 적절하지 않은 static 함수의 사용
* 특정 인스턴스와는 관련이 없고, 재정의할 가능성도 없는 메소드는 static으로 작성할 수 있다.
  * 그러나 함수를 재정의할 가능성이 존재하는 경우라면 인스턴스 메소드로 정의한다.
* 일반적으로 static 메소드보다 인스턴스 메소드가 좋다.
  * 가능하다면 인스턴스 메소드로 정의하되, 반드시 static으로 정의해야되는 경우에는 재정의 가능성을 꼼꼼히 따져봐야 한다.
19. 서술적인 변수명을 사용하지 않는 경우
* 프로그램의 가독성을 높이는 효과적인 방법 중 하나는,
  1. 동작을 여러 단계로 나누고,
  2. 중간 값으로 서술적인 변수명을 사용하는 것이다.
* 서술적인 변수 이름은 많이 써도 괜찮으며, 많을수록 좋다.
  * 위 방식을 사용하는 것만으로도 모듈의 가독성은 확실히 올라간다!
20. 이름과 기능이 일치하는 함수의 사용
* 이름만으로 동작이 명백히 드러나지 않아 구현을 확인하거나 문서를 뒤져야 한다면 깨끗하게 작성된 코드가 아니다.
* 이 경우, 더 좋은 이름으로 바꾸거나 더 좋은 이름을 붙일 수 있도록 기능을 정리해야 한다.
21. 알고리즘을 이해하지 못한 경우
* 대부분의 지저분한 코드는 알고리즘을 이해하지 못한 채 적당히 if / else와 플래그로 구현한 탓이다.
* 구현이 끝났다고 선언하기 전에 함수의 동작 원리를 확실히 이해하는지 점검해야 한다.
  * 개발자는 자신이 구현한 함수의 알고리즘이 올바르다는 사실을 알아야 한다.
* 알고리즘의 타당성을 확인하고 이해하려면 함수를 최대한 깔끔하고 명확하게 재구성하는 것이 최고의 방법이다.
22. 논리적인 의존성이 드러나지 않는 경우
* 하나의 모듈이 다른 모듈에 의존한다면, 물리적인 의존성도 있어야만 한다.
* 의존하는 모든 정보는 명시적으로 요청하는 것이 좋다.
  * 의존하는 모듈이 의존되는 모듈에 대해 무언가를 가정하는 것은(= 논리적으로 의존하는 것은) 바람직하지 못하다.
  * 예를 들어, 하나의 클래스가 다른 클래스에서 사용하는 값이 X이겠거니, 하고 동작하지 않아야 한다는 의미이다.
23. if 문, switch문을 다형성보다 우선하는 경우
* switch 문은 개발자에게 구현에 손쉬운 방식으로서 선택되곤 한다.
* 그러나 당장 switch 문을 덜컥 선택하기 전에, 다형성으로 구현이 가능한지 우선 고려되어야만 한다.
24. 표준 표기법을 따르지 않는 경우
* 팀은 업계 표준에 기반한 구현 표준을 정의하고, 따라야 한다.
* 표준으르 설명하는 문서는 별도로 작성하지 않고, 코드 자체로 충분해야 한다.
* 팀의 표준은 팀 구성원이 모두 동의하고 따라야 하며, 팀원은 이 사실을 이해할 정도로 성숙해야 한다.
25. 매직 넘버를 그대로 사용하는 경우
* 하루를 초로 환산한 86,400과 같은 숫자는 명명된 상수로 대체한다.
* 이 규칙은 모든 숫자에 적용될 필요는 없다.
  * 예를 들어, num * 2를 굳이 num * TWO로 변경할 필요까지는 없다.
* 매직 넘버는 숫자만 의미하지 않으며, 의미가 분명하지 않은 토큰을 모두 포함하는 용어이다.
  * 예를 들어, John Doe와 같은 문자열이 있다.
26. 정확하지 않은 경우
* 코드를 작성할 때, 무언가를 결정해야 한다면 확실히 결정한다.
  * 결정을 내린 이유와 예외 처리 방법을 확실히 짚고 넘어간다.
* 예를 들어, 호출하는 함수가 null을 반환할 수도 있다면 null을 반드시 점검한다.
* 조회 결과가 하나뿐일 것만 같다면 정말 하나인지 확실히 확인한다.
27. 관례와 구조가 사용되지 않는 경우
* 설계에 대한 결정을 강제하려면 규칙보다 관례를 적용한다.
* 나아가 관례보다는 구조 자체를 강제하는 것이 더 좋다.
  * 예를 들어, enum은 switch 문보다 추상 메소드가 존재하는 기초 클래스에 위치하는 것이 더 좋다.
  * switch문은 매번 구현을 강제할 수 없지만, 기초 클래스는 모든 추상 메소드가 구현되어야 하기 때문이다.
28. 캡슐화되지 않은 조건을 사용하는 경우
* boolean으로 표현되는 논리는 이해하기 어려우므로, 조건의 의도를 명시하는 함수로 대체한다.
29. 부정 조건을 자주 사용하는 경우
* 일반적으로, 부정 조건은 긍정 조건보다 이해하기 어렵다.
* 가능하다면 부정 조건 대신 긍정 조건을 사용해야 한다.
30. 하나 이상의 기능을 수행하는 함수
* 여러 단락으로 이어 일련의 작업을 수행하는 함수는 대부분 하나만 수행하는 함수가 아니다.
* 이러한 큰 함수는 하나만 수행하는 더 작은 함수 여럿으로 나누어야 한다.
31. 시간적 결합이 숨겨진 경우
* 시간적인 결합은 때로 필요하지만, 숨겨져서는 안 된다.
* 함수를 작성할 때 함수의 인수를 적절히 배치하여 함수의 호출 순서를 명백히 드러내도록 한다.
* 이로 인해 함수가 복잡해질 수 있으나, 의도적으로 추가한 구문적 복잡성이 시간적인 복잡성을 드러내는 이점이 있다.
32. 일관성이 유지되지 않는 경우
* 코드 구조를 정의할 때에는 이유를 고민하며, 고민한 이유를 코드 구조로 명백하게 표현해야만 한다.
* 시스템 전반적으로 일관성이 유지된다면, 다른 개발자들도 일관성을 따르고 보존하려고 할 것이다.
33. 경계 조건이 캡슐화되지 않은 경우
* 경계 조건은 한 곳에서 별도로 처리하며, 코드 이곳 저곳에 흩어놓지 않는다.
  * 예를 들어, 코드 여기저기에 +1이나 -1을 늘어놓지 않는다.
  * 이러한 경계 조건은 변수로 캡슐화하는 것이 바람직하다.
34. 함수가 추상화 수준을 여러 단계 내려가려고 하는 경우
* 함수 내부의 모든 문장은 추상화 수준이 동일해야 한다.
  * 이 때, 추상화 수준은 함수 이름이 의미하는 작업보다 한 단계만 낮아야 한다.
* 추상화 수준의 분리는 리팩토링을 수행하는 가장 중요한 이유 중 하나이며, 제대로 수행하기 가장 어려운 작업이기도 하다.
  * 함수에서 추상화 수준을 분리하려 시도한다면, 앞서 드러나지 않았던 추상화 수준이 다시 드러날 수도 있다.
35. 설정 정보를 저차원 함수에 숨긴 경우
* 기본값 상수 및 설정 관련 상수는 추상화 최상위 단계에 두어야 한다.
  * 저차원 함수로 숨겨서는 안되며, 대신 고차원 함수에서 저차원 함수를 호출할 때 인수로 넘기는 방법을 사용한다.
  * 그래야만 변경하기도 쉽다.
* 저차원 함수에 상수 값을 정의하여 숨기는 것은 지양해야 할 행위이다.
36. 추이적인 탐색을 사용하는 경우
* 일반적으로, 하나의 모듈은 주변의 모듈을 알 수 없을수록 좋다.
* 각 모듈은 디미터의 법칙을 준수해야 하며, 자신이 직접 사용하는 모듈만 알아야 한다.
  * 원하는 메소드를 찾기 위해 객체 그래프를 따라 시스템을 탐색하는 일이 발생하지 않아야 한다.
* 내가 사용하는 모듈이 나에게 필요한 모든 서비스를 제공해야 한다.

### Java
1. 긴 import 목록을 사용하는 경우
* **패키지에서 클래스 둘 이상을 사용한다면, 와일드카드(*)를 활용하여 패키지 전체를 import한다**.
* 명시적인 import 문은 강한 의존성을 생성하지만, 와일드카드는 그렇지 않다.
  * 명시적으로 클래스를 import하면, 해당 클래스는 반드시 존재해야 한다.
  * 와일드카드로 패키지를 지정하는 경우, 단순히 패키지가 검색 경로에 추가되므로 특정 클래스가 반드시 존재할 필요가 없다.
    * 즉, 진정한 의미의 의존성이 생기지 않으므로 모듈 간 결합성이 낮아진다.
2. 상수를 상속하는 경우
* 예를 들어, 상수를 인터페이스에 넣고 그 인터페이스를 구현하여 상수를 사용하지 말아야 한다.
* 상수를 상속 계층 맨 위에 숨겨서 찾기 어렵게 만드는 것 보다 static import를 사용한다.
3. enum보다 상수를 선호하는 경우
* enum은 마음껏 활용되어야 한다.
* 상수는 의미를 잃을 수 있지만, 이름이 붙은 열거체인 enum은 그럴 가능성이 없다.
* enum은 메소드와 필드도 사용할 수 있는, 유연하고 서술적인 도구이다.
  * 이렇듯 강력한 도구인 enum의 문법을 확실히 확인하고 활용할 수 있어야 한다.

### 명명
1. 서술적인 이름을 사용하지 않는 경우
* 소프트웨어 가독성의 9할 이상은 명명된 이름이 결정한다.
* 이름은 신중하게 고민하며, 되도록 서술적인 이름을 선정한다.
* 신중하게 결정된 이름은 추가 설명이 포함된 코드보다 강력하다.
  * 이러한 이름은 읽는 사람으로 하여금 모듈 내부의 다른 함수가 하는 일을 짐작하도록 한다.
2. 적절히 추상화되지 않은 이름을 사용하는 경우
* 구현을 드러내는 이름보다는 클래스나 함수가 위치하는 추상화 수준을 반영하는 이름을 선택한다.
3. 표준 명명법을 활용하지 않는 경우
* 기존 명명법을 적절히 활용하면 코드를 이해하기 더 쉬워진다.
  * 예를 들어, Decorator 패턴을 활용하는 클래스는 이름에 Decorator라는 단어를 포함시킨다.
  * 또한, toString과 같은 직관적인 이름은 새로운 이름을 정의하는 것보다는 관례를 따르도록 한다.
* 프로젝트에 유효한 의미의 이름을 많이 사용할수록 읽는 사람의 부담은 줄어든다.
4. 명확하지 않은 이름을 사용하는 경우
* 함수와 변수의 이름은 목적을 명확히 밝히는 이름을 사용한다.
* 이름은 길어도 좋으며, 길다는 단점은 서술성으로부터 얻는 이점으로 충분히 보완할 수 있다.
5. 이름의 스코프와 길이가 비레하지 않는 경우
* 아주 작은 범위에서 활용되는 이름은 짧아도 좋다.
* 그러나 긴 범위에서 활용되는 이름은 정확하고 길어져야 한다.
6. 인코딩을 활용하는 경우
* 헝가리안 표기법과 같이, 이름에 유형 정보나 범위 정보를 넣지 않도록 한다.
* 오늘날의 환경은 특이한 명명 방법 없이도 모든 정보를 제공할 수 있다.
7. 부수 효과를 설명하지 못하는 이름을 사용하는 경우
* 함수, 변수, 클래스가 맡은 기능을 모두 설명하는 이름을 사용한다.
  * 이름에서 부수 효과를 숨기려고 해서는 안 된다.
  * 여러 작업을 수행하는 함수에 너무 짧은 이름을 붙여 혼란을 주지 않아야 한다.

### 테스트
1. 테스트 케이스가 충분하지 않은 경우
* 테스트 케이스는 잠재적으로 깨질 법한 부분을 모두 테스트해야 한다.
* 테스트 케이스가 확인하지 않은 조건이나, 검증하지 않은 계산이 있다면 테스트는 불완전한 것이다.
2. 커버리지 도구를 활용하지 않는 경우
* 커버리지 도구는 테스트가 놓친 부분을 알려주며, 이를 통해 테스트가 충분하지 않은 지점을 쉽게 찾을 수 있다.
3. 사소한 테스트는 건너 뛰는 경우
* 사소한 테스트는 작성하기 쉽지만, 테스트 케이스가 제공하는 문서적인 가치는 구현에 드는 비용보다 훨씬 크다.
4. 불분명한 테스트를 방치하는 경우
* 요구사항이 불분명하여 프로그램의 동작 방식을 확인하기 어려운 상황도 발생할 수 있다.
* 이 경우, 불분명한 요구사항을 표현하는 테스트 케이스를 주석 처리하거나 @Ignore 어노테이션을 붙여 표현한다.
5. 경계 조건을 테스트하지 않는 경우
* 경계 조건은 반드시 신경써서 테스트해야 한다.
6. 버그 주변을 적당히 테스트하는 경우
* **버그는 서로 모이는 경향이 있으므로, 하나의 함수에서 버그를 발견했다면 그 함수를 철저히 테스트해야 한다**.
7. 실패하는 패턴을 무시하는 경우
* 테스트 케이스를 꼼꼼히 작성하였다면, 테스트 케이스가 실패하는 패턴으로 문제의 원인을 짐작할 수도 있다.
* 합리적인 순서로 정렬되고, 꼼꼼하게 작성된 테스트 케이스는 실패 패턴을 드러낸다.
8. 테스트 커버리지 패턴을 무시하는 경우
* 테스트 케이스가 통과하는 도중 실행하거나, 실행하지 않는 코드를 통해 실패하는 테스트 케이스의 원인을 짐작할 수 있다.
9. 느린 테스트를 방치하는 경우
* 느린 테스트는 실행하고 싶지 않으며, 실제로도 실행을 하지 않게 된다.
* 때문에 테스트 케이스는 언제나 빠르게 돌아갈 수 있도록 최대한 신경써서 작성해야 한다.
# CleanCode
## 2022-02-01 Tue

## 클래스
* 함수를 바르게 구현하고 함수가 서로 관련을 맺는 방법 이외에도 더 높은 단계까지 신경쓰지 않는다면 깨끗한 코드를 만들기 어렵다.
* 클래스를 정의하는 표준 자바 관례는 다음과 같다.
  1. 정적 공개 상수가 있다면 맨 처음에 작성한다.
  2. 그 다음으로 정적 비공개 변수를 작성한다.
  3. 그 다음으로 비공개 인스턴스 변수를 작성한다.
     * 공개 변수가 필요한 경우는 거의 없다.
  4. 변수 목록의 작성이 끝나면 공개 함수를 작성한다.
  5. 비공개 함수는 자신을 호출하는 공개 함수 다음에 작성한다.
* 이를 통해 추상화 단계는 순차적으로 내려가고, 코드는 신문 기사처럼 읽힐 수 있다.
* 변수와 함수는 가능한 공개하지 않는 것이 좋다.
  * 그러나 테스트 코드 등이 접근해야하는 경우, 접근제어자를 protected로 작성하여 접근을 허용하기도 하다.
  * 이러한 결정 이전에는 반드시 private 상태를 유지할 방안을 강구해야 한다.
    * **캡슐화를 풀어버리는 결정은 언제나 최후의 보루**이다.

### 클래스를 작게 만들기
* 클래스는 작아야 한다.
  * **함수는 물리적인 행의 수로 크고 작음을 비교했다면, 클래스에서는 클래스가 맡은 책임을 세어볼 수 있다**.
* **클래스의 크기를 줄이는 첫번째 관문은 작명이며, 클래스의 이름은 해당 클래스의 책임을 기술**해야만 한다.
  * 만약 간결한 클래스 이름이 떠오르지 않는다면?
    * **클래스의 크기가 너무 크다**.
  * 만약 클래스 이름이 너무 모호하다면?
    * **클래스가 맡은 책임이 너무 많다**.
* **클래스는 if, and, or, but을 사용하지 않고 25 단어 내외로 설명이 가능해야** 한다.
  * 이러한 단어들이 들어가야만 설명이 가능한 클래스는 맡은 책임이 너무 많은 상태이다.

### SRP - 단일 책임 원칙
* 클래스나 모듈을 변경할 이유는 단 하나뿐이어야 한다.
  * 따라서 클래스는 책임, 즉 변경할 이유가 하나뿐이어야 한다.
  * 책임(=변경의 이유)를 파악하다 보면 코드를 추상하기도 쉬워진다.
* SRP는 객체 지향 설계에서 매우 중요한 개념이며, 지키기도 쉽지만 자주 무시되는 규칙이다.
  * 대다수의 개발자는 단일 책임 클래스가 많아지면 전체를 이해하기 어렵다고 말한다.
  * 그러나 클래스의 크기는 시스템의 이해도에 영향을 주지 않는다. 
    * 큰 클래스 몇 개로 구성된 시스템이나, 작은 클래스 여러 개로 구성된 시스템이나 이해에 드는 비용은 비슷하다.
* **규모가 큰 시스템은 논리가 많고 복잡하므로, 이러한 복잡성을 다루기 위해서는 반드시 체계적으로 정리해야만 한다**.
  * 그래야만 시스템의 수정사항이 있을 때 변경이 필요한 컴포넌트만 이해하고 작업할 수 있다.
  * **커다란 클래스 몇 개로 구성된 시스템은 수정과 관련 없는 부분까지 모두 이해할 것을 강요**한다.
* 언제나**큰 클래스 몇 개로 구성된 시스템보다 작은 클래스 여럿으로 구성된 시스템이 바람직**하다.
  * 단일 책임을 갖는 작은 클래스는 변경의 이유도 하나이며, 다른 작은 클래스들과 협력하여 시스템에 필요한 동작을 수행한다.

### Cohesion - 응집도
* 클래스는 인스턴스 변수 수가 적어야 하며, 메소드는 인스턴스 변수를 하나 이상 사용해야 한다.
* 응집도는 메소드가 변수를 더 많이 사용할수록 높아진다.
  * 이러한 경우는 메소드와 클래스가 응집도가 높다라는 표현을 사용한다.
  * 예를 들어, 대부분의 메소드가 클래스의 인스턴스 변수를 모두 사용하는 경우가 있다.
* **응집도가 높은 클래스는 메소드와 변수가 서로 의존하며 논리적인 단위로 묶이는 클래스이며, 일반적으로 선호되는 형태**이다.
* 함수를 작게, 매개 변수 목록은 짧게하는 전략을 따르다보면 때때로 몇몇 메소드만이 많은 인스턴스 변수를 사용할 수도 있다.
  * **이는 새로운 클래스로 쪼개야 한다는 신호가 되어 준다**.
  * 이러한 경우에는 응집도가 높아지도록 변수와 메소드를 적절히 분리하고, 새로운 클래스 2-3개로 쪼개주어야 한다.
* **클래스의 응집도는 되도록 높게 유지되는 것이 바람직**하다.

### 응집도를 유지하기
* **응집도를 유지하면 작은 클래스 여러 개**로 쪼개어지게 된다.
* 예를 들어, 다음과 같은 경우를 확인해보자.
  1. 지역 변수를 매우 많이 사용하는 큰 함수로부터 작은 함수 하나를 메소드로 추출하고자 한다.
  2. 이 때, 작은 함수는 큰 함수의 네 개 변수를 사용한다.
  3. 네 개의 변수를 작은 함수의 인수로 넘기는 것보다 인스턴스 변수로 승격하는 것이 바람직하다.
     * 인수 목록은 적게 유지되는 것이 좋기 때문이다.
     * 그러나 이 경우에는 **두 함수만이 사용하는 인스턴스 변수 목록이 발생하므로, 응집도가 낮아진다**.
  4. 몇몇 함수만 사용하는 몇몇 변수가 존재한다면, 독자적인 클래스로 쪼갤 수 있다!
  * 따라서, **클래스의 응집도가 낮아지는 것은 클래스를 쪼개야한다는 신호가 되어준다**.
* **커다란 함수를 작은 함수 여럿으로 쪼개다보면 큰 클래스를 작은 클래스 여럿으로 쪼갤 기회가 생긴다**.
  * 이 과정에서 프로그램은 체계가 잡히고 구조가 투명해진다.

### 변경하기 쉬운 클래스
* 대부분의 시스템은 지속적으로 변경되며, 변경 시점마다 시스템이 의도한대로 동작하지 않을 위험성이 함께한다.
  * **깨끗한 시스템은 클래스를 체계적으로 정리하며 변경에 함께하는 위험성을 낮춰준다**.
* 새로운 기능을 추가하거나 기존 기능을 변경할 때 건드려야하는 코드가 최소인 시스템 구조가 가장 바람직하다.
* **이상적인 시스템은 새로운 기능을 추가할 때 시스템을 확장할 뿐, 기존 코드를 변경하지는 않는다**.
  * 이러한 시스템은 함수 하나를 수정해도 다른 함수가 망가지지 않는다.

### 변경으로부터의 격리
* 요구 사항은 변하기 마련이며, 이에 따라 코드도 계속해서 변해간다.
* 또한, 객체 지향의 입문에서 우리는 다음과 같은 두 사실을 배웠다.
  1. 구체적인 클래스는 상세한 구현(=코드)을 포함한다.
  2. 추상적인 클래스는 개념만을 포함한다.
* **상세한 구현, 즉 구체적인 클래스에 의존하는 클라이언트 클래스는 구체적인 클래스의 구현이 변경되면 위험에 빠진다**.
  * **때문에 우리는 인터페이스와 추상 클래스를 활용하여 구현과 구현의 변경이 미치는 영향을 격리한다**.
* 상세한 구현에 의존하는 코드는 테스트도 어렵다.
  * 예를 들어, 주가나 환율 등 실시간으로 응답이 변하는 외부 API에 의존하는 클래스는 테스트 결과값이 항상 변할 것이다.
  * 이러한 경우, **테스트할 대상 메소드를 포함하는 인터페이스를 정의**하고 외부 API를 호출하기 위한 클래스를 새로이 만들되, 이 인터페이스를 구현하도록 한다.
    * **이로 인해 우리는 이제부터 외부 API를 호출하는 클래스를 흉내내는 테스트용 클래스를 생성할 수 있다**.
      * 예를 들어, 해당 인터페이스를 구현하는 테스트용 클래스는, 항상 고정된 값을 반환하도록 할 수 있다.
      * 이를 통해 구체적인 구현이 아닌 추상적인 개념을 표현하는 인터페이스에 의존하며, 구체적인 사실은 모두 숨길 수 있게 된다.
  * 이러한 과정을 통해 **시스템의 결합도를 낮출 수 있다**.
* 테스트가 가능할 정도로 시스템의 결합도를 낮추면 유연성과 재사용성이 높아진다.
  * **결합도가 낮다는 의미는 각 시스템의 요소가 다른 요소로부터, 그리고 다른 요소의 변경으로부터 잘 격리된다는 의미**이다.
  * 또한 시스템의 요소들이 서로 잘 격리된다면 각 요소를 이해하기도 쉽다.
* 결합도를 줄이려고 노력한다면, 또 다른 클래스 설계 원칙인 DIP를 따르는 클래스가 결과로 나오게 된다.
  * **본질적으로 DIP는 상세한 구현이 아닌 추상화에 의존해야한다는 원칙**이다.

### 개인 리마인드용 - 깨끗한 코드와 코드 길이
* 지저분한 코드를 깨끗한 코드로 리팩토링하는 과정에서 함수와 클래스를 분할하다보면 자연스레 코드의 길이는 길어진다.
* 이러한 현상의 원인으로는,
  1. 리팩토링 과정에서 길고 서술적인 명명을 사용하며,
  2. 코드에 주석을 추가하는 대신 함수와 클래스 정의를 활용하며,
  3. 가독성을 위해 공백을 추가하여 형식을 맞춰주기 때문이다.
* 안전하게 리팩토링하려면 우선 테스트 수트를 작성하고 한 번에 하나씩, 여러 번 조금씩 코드를 변경하며 테스트를 수행한다.
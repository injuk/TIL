# Objects
## 2022-04-10 Sun

## 타입 계층의 구현
* 일반적으로 퍼져있는 흔한 오해는 타입과 클래스가 동일한 개념이라는 것이다.
* 이는 사실이 아니며, **타입은 개념의 분류를 의미하는 반면 클래스는 타입을 구현하는 방법 중 하나에 불과**하다.
  * 타입 계층은 다양한 방식으로 구현된 타입들을 하나의 타입 계층으로 조합할 수 있으므로 더 복잡하다.
* **타입 계층은 동일한 메시지에 대한 행동 호환성을 전제로 하므로, 타입 계층을 구현하는 것은 곧 다형성을 구현하는 것**과 같다.
* **타입과 타입 계층을 구현한다고 해서 서브타이핑 관계가 보장되는 것은 아니다**.
  * 서브타이핑 관계는 서브타입이 슈퍼타입을 대체할 수 있도록 리스코프 치환 원칙을 준수해야 한다.

### 클래스를 이용하는 타입 계층의 구현
* **타입은 객체의 퍼블릭 인터페이스를 가리키므로 클래스는 객체의 타입과 구현을 동시에 정의하는 셈**이다.
  * 이러한 이유로 객체지향 언어에서는 클래스를 사용자 정의 타입이라는 명칭으로도 부르곤 한다.
* **타입을 구현할 수 있는 방법이 단 한 가지만 존재하는 경우에 한해 타입과 클래스는 동일하게 취급할 수 있다**.
* 반면, **타입을 구현할 수 있는 방법이 다양해지는 시점부터는 클래스와 타입이 갈라지기 시작**한다.
* 상속을 이용하여 자식 클래스가 부모 클래스의 구현 뿐만 아니라 퍼블릭 인터페이스도 상속할 수 있으므로, 타입 계층을 쉽게 구현할 수 있다.
  * 그러나 상속은 자식 클래스가 부모 클래스에게 강하게 결합되도록 하므로, 구체 클래스를 상속받는 것은 지양해야 한다.
  * 가능하다면 추상 클래스를 상속하거나 인터페이스를 구현하도록 한다.

### 인터페이스를 이용하는 타입 계층의 구현
* **상속으로 인한 결합도 문제를 피하고, 다중 상속이라는 제약도 해결할 수 있는 방법은 클래스가 아닌 인터페이스를 활용하는 것**이다.
  * 인터페이스와 클래스를 조합하여 사용하는 것으로 다중 상속의 딜레마에 빠지지 않을 수 있고, 단일 상속 계층으로 인한 결합도 문제도 회피할 수 있다.
* **인터페이스가 다른 인터페이스를 확장하도록 만드는 것으로 슈퍼타입과 서브타입 간의 타입 계층을 구성**할 수 있다.
* 인터페이스와 클래스를 조합하여 사용하는 것으로 다음과 같은 효과를 얻을 수 있다.
  1. 여러 클래스가 동일한 타입을 구현할 수 있다: **서로 다른 클래스를 이용해서 구현하더라도 동일한 타입으로 취급**할 수 있다.
  2. 하나의 클래스가 여러 타입을 구현할 수 있다.
* **중요한 것은 인터페이스를 통해 타입을 정의하고 클래스로 객체를 구현하는 것으로, 클래스 상속 없이 타입 계층을 구현할 수 있다는 점**이다.

### 클래스와 타입의 차이
* 클래스와 타입의 차이점을 이해하는 것은 설계 관점에서 매우 중요하다.
  1. 타입: **동일한 퍼블릭 인터페이스를 갖는 객체들의 범주**이다.
  2. 클래스: **타입에 속하는 객체들을 구현하기 위한 구현 메커니즘**
* **객체지향에서 중요한 것은 협력 안에서 객체가 제공하는 행동이므로, 타입은 클래스보다 중요한 개념**이다.
  * 타입이 식별된 후에서야 타입에 속하는 객체를 구현하기 위해 클래스를 사용하게 된다.
```
> 중요한 것은 객체가 외부에 제공하는 행동인 타입을 중심으로 객체들의 계층을 설계하는 것이므로, 언제나 클래스가 아니라 타입에 집중해야 한다.
```

### 추상 클래스를 이용하는 타입 계층의 구현
* 추상 클래스는 상속을 이용하여 구현을 공유하면서도 결합도로 인한 부작용을 회피하기 위해 제공되는 방법이다.
* 구체 클래스로 타입을 정의하여 상속하는 것과 추상 클래스로 타입을 정의하여 상속받는 방법은 다음과 같은 주요한 차이점이 존재한다.
  1. 추상화의 정도: 의존하는 대상의 추상화 정도가 다르다.
  2. 상속을 사용하는 의도: 구체 클래스는 상속을 염두에 두고 설계되지 않았을 가능성이 높으므로, 확장으로 인한 변경에 취약할 수 있다.
     * 반면 추상 클래스는 애초에 상속을 염두에 두고 설계된 클래스이므로, 추상 메소드를 제공하여 상속 계층을 쉽게 확장하고 결합도로 인한 부작용을 방지한다. 
* 의존 대상이 추상적일수록 결합도와 변경으로 인한 영향도는 줄기에, 모든 구체 클래스의 부모 클래스를 항상 추상 클래스로 만들기 위해 노력하는 것이 바람직하다.

### 추상 클래스와 인터페이스의 결합
* 대부분의 객체지향 언어는 다중상속을 허용하지 않으므로, 필요한 경우에는 타입 계층을 오묘하게 비틀어 사용해야 한다.
* 예를 들어 **인터페이스만을 사용하여 다중상속 요구를 충족시킬 수도 있지만, 이러한 방법은 중복 코드를 제거하기 어려운 단점을 수반**한다.
* **효과적인 접근법은 인터페이스를 이용하여 타입을 정의하고, 특정 상속 계층에 국한된 코드를 공유할 필요가 있는 경우에는 추상 클래스를 활용하는 방법**이다.
  * 이러한 방식으로 추상 클래스를 활용하는 방식을 골격 구현 추상 클래스라고 한다.
  * 이를 통해 인터페이스와 추상 클래스의 장점을 결합하며, 인터페이스는 여전히 타입을 정의하지만 골격 구현 클래스는 그것을 구현하는 역할을 수행한다.
* 예를 들어 추상 클래스만으로 구현되는 경우, 자식 클래스들은 모두 하나의 상속 계층에 묶이는 제약을 갖는다.
  * **인터페이스를 결합하는 경우, 상속 계층에 대한 제약을 완화하여 객체들이 서로 다른 상속 계층에 속하도록 변경할 수 있다**.
  * 예를 들어 기존의 추상 클래스를 인터페이스로 변경하고, 중복되는 코드들은 인터페이스를 구현하는 추상 클래스를 정의하여 작성한다.
  * 실제 구현 객체들은 인터페이스를 구현하는 추상 클래스를 상속 받는 식으로 작성하여 문제를 해결할 수 있다.
* 인터페이스와 추상 클래스를 함께 사용하는 방식은 추상 클래스만 사용하는 방식에 비해 다음과 같은 장점을 갖는다.
  1. **다양한 구현 방법이 필요한 경우, 새로운 추상 클래스를 추가하는 것으로 쉽게 대응**할 수 있다.
  2. **이미 부모 클래스가 존재하는 클래스더라도 인터페이스를추가하는 것으로 새로운 타입으로 쉽게 확장이 가능**하다.
* 상술한 내용을 토대로 타입 계층을 정의하기 위해 다음과 같은 방식을 고려할 수 있다.
  1. 설계가 상속 계층에 얽매이지 않는 타입 계층을 요구하는 경우, 인터페이스로 타입을 정의하고 추상 클래스로 기본 구현을 제공하여 중복 코드를 제거한다.
  2. 이러한 복잡성이 필요하지 않은 경우, 인터페이스나 추상 클래스 둘 중 하나만 사용한다.
     1. 타입의 구현 방법이 단 하나 뿐이거나, 단일 상속 계층만으로도 타입 계층을 구현할 수 있다면 클래스나 추상 클래스를 활용하여 타입을 정의한다.
     2. 그 이외의 상황에는 인터페이스의 활용을 고려한다.

### 덕 타이핑의 사용
* 덕 타이핑이란 주로 동적 타입 언어에서 사용하는 방법이며, 덕 테스트를 프로그래밍 언어에 적용한 것이다.
* **덕 테스트란, 어떤 대상의 행동이 오리와 같다면 이를 오리 타입으로 취급해도 무방하다는 의미**를 갖는다.
  * 즉, 객체가 어떤 인터페이스에 정의된 행동을 그대로 수행할 수 있다면 해당 객체는 그 타입으로 분류할 수 있다.
* Java와 같은 대부분의 정적 타입 언어에서는 덕 타이핑을 지원하지 않는다.
* 반면 동적 타입 언어는 특정 클래스를 상속받거나 인터페이스를 구현하지 않고도 객체가 수신할 수 있는 메시지 집합으로 객체 타입을 결정할 수 있다.
  * 이는 동적 타입 언어가 런타임에 타입을 결정하기 때문이다.
  * 즉, 명시적으로 동일한 클래스나 인터페이스를 상속받거나 구현하지 않더라도 동일한 메소드 시그니쳐를 갖는 클래스는 같은 타입으로 취급할 수 있다. 
* **덕 타이핑은 타입이 행동에 대한 것이라는 사실을 강조하며, 타입 관점에서 두 객체가 동일하게 행동한다면 내부 구현과 관계 없이 동일한 타입으로 취급**한다.
* 반면, 덕 타이핑에는 다음과 같은 단점도 존재한다.
  * 컴파일 시점에 발견할 수 있는 오류를 런타임으로 미루게 된다.
  * 즉, **덕 타이핑은 설계의 유연성을 얻는 대신 코드의 안전성을 약화시키는 기법**이다.

### 덕 타이핑과 컨텍스트 독립성
* 인터페이스가 클래스보다 유연한 설계를 가능케하는 이유는 클래스가 정의하는 구현이라는 컨텍스트에 독립적인 코드를 작성할 수 있기 때문이다.
* **덕 타이핑은 한 걸음 나아가며, 단지 메소드의 시그니쳐만 동일하면 명시적인 타입 선언이라는 컨텍스트 조차 제거**할 수 있다.
  * 이렇듯 **덕 타이핑은 클래스나 인터페이스에 대한 의존성을 메시지에 대한 의존성으로 대체**한다.
  * 결과, 코드는 낮은 결합도를 유지하며 변경에 유연하게 대응할 수 있게 된다.
```
> 덕 타입은 특정 클래스에 종속되지 않는 퍼블릭 인터페이스이다.
> 여러 클래스를 가로지르는 이러한 인터페이스는 클래스에 대한 값비싼 의존을 메시지에 대한 부드러운 의존으로 대체하여 애플리케이션의 유연성을 높인다.
```

### 믹스인과 타입 계층
* 믹스인은 객체를 생성할 때 코드의 일부를 섞어 넣을 수 있도록 만들어진 일종의 추상 서브클래스이다.
  * **언어마다 구현에 차이는 있으나, 믹스인을 사용하는 목적은 다양한 객체 구현 안에서 동일한 행동을 중복 코드 없이 재사용할 수 있도록 만드는 것**이다.
* 믹스인을 통해 코드를 재사용하는 객체들은 동일한 행동을 공유하게 된다.
  * 즉, 공통의 행동이 믹스인된 객체들은 동일한 메시지를 수신할 수 있는 퍼블릭 인터페이스를 공유하게 된다.
  * **타입은 퍼블릭 인터페이스와 관련이 있으므로, 대부분의 믹스인을 구현하는 기법들은 타입을 정의하는 것**과 같다.
* **믹스인은 간결한 인터페이스를 갖는 클래스를 풍부한 인터페이스를 갖는 클래스로 만들기 위해 사용**될 수 있다.
  * 이 과정에서 풍부한 인터페이스를 정의한 트레이트의 서브타입으로 해당 클래스를 만드는 부수적인 효과도 얻을 수 있다.

### 믹스인과 디폴트 메소드
* **Java의 경우 8에서 추가된 디폴트 메소드를 활용하여 인터페이스에 메소드의 기본 구현을 추가하는 것으로 믹스인을 구현**할 수 있다.
  * **디폴트 메소드를 통해 추상 클래스가 제공하는 코드 재사용 헤택을 누리면서도 특정한 상속 계층에 얽매이지 않는 인터페이스의 장점을 유지**할 수 있다.
  * 디폴트 메소드를 활용하는 것으로 간결한 인터페이스를 갖는 클래스를 풍부한 인터페이스를 갖는 클래스로 변경할 수 있다.
  * 즉, **디폴트 메소드를 구현하면 더 이상 기본 구현 골격을 제공하기 위해 인터페이스를 구현하는 추상 클래스를 추가할 필요가 없다**.
* 반면, **디폴트 메소드가 제공하는 혜택을 누리면서 설계를 견고하게 유지하려면 디폴트 메소드의 한계를 명확히 인식해야 한다**.
  * 예를 들어 **디폴트 메소드를 사용하여 추상 클래스를 대체하는 경우, 인터페이스는 불필요하게 비대해지고 캡슐화가 약해질 수 있다**.
  * 또한, 해당 방식은 **경우에 따라 클래스 사이의 코드 중복을 완벽히 제거하지 못할 수도 있다**.
* 이러한 **디폴트 메소드의 한계는 디폴트 메소드가 추가된 이유가 추상 클래스의 역할을 대체하기 위함이 아니었기 때문에 발생**한다.
  * **디폴트 메소드의 목적은 기존에 널리 사용되던 인터페이스에 새로운 오퍼레이션을 추가할 경우 발생하는 하위 호환성 문제를 해결하기 위함**이다.
* 즉, 타입을 정의하기 위해 디폴트 메소드를 사용하는 경우에는 용도 차이에서 발생하는 한계를 명확히 인식해야 한다.

### 타입 계층 구현의 결론
* 타입을 정의하는 기준은 객체가 외부에 제공하는 퍼블릭 인터페이스이다.
  * 때문에 타입의 개념을 코드로 옮길 수 있는 다양한 방법이 존재한다.
* 중요한 것은 **어떤 방법으로든 타입 계층을 구현했다고 해서, 내부에 포함되는 모든 타입 구현체들이 서브타입과 슈퍼타입을 만족시키는 것은 아니라는 점**이다.
  * **어떤 타입이 다른 타입의 서브타입이 되기 위해서는 구현시 리스코프 치환 원칙을 반드시 준수**해야 한다.
  * 따라서 **상술한 방법 중 하나를 통해 타입 계층을 구현하였더라도 리스코프 치환 원칙에 위배된다면 올바른 타입 계층을 구현한 것이 아니다**.
  * 이러한 경우에는 코드 재사용과 서브타이핑 개념을 혼동한 것은 아닌지 다시 한 번 확인해볼 필요가 있다.
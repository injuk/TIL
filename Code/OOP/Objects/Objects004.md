# Objects
## 2022-03-28 Mon

## 설계의 품질과 트레이드오프
* 앞서 다룬 바와 같이 객체지향 설계의 핵심은 협력, 책임, 그리고 역할이며, 이 중 **가장 중요한 것은 책임**이다.
  1. 협력: 애플리케이션의 기능을 구현하기 위해 메시지를 주고받는 객체들의 상호작용 전반을 말한다.
  2. 책임: 객체가 또 다른 객체와 협력하기 위해 수행하는 행동을 말한다.
  3. 역할: 대체 가능한 책임의 집합을 말한다.
* 적절한 책임 없이는 원활한 협력을 기대할 수 없으며, 역할 역시 협력과 조합될 수 없다.
  * 때문에 **애플리케이션 전체의 품질을 결정하는 것은 언제나 책임**이다.
* 앞서 다룬 바와 같이, 객체지향 설계의 의미는 다음과 같이 요약할 수 있다.
  1. 적절한 객체에게 적절한 책임을 할당한다.
     * 이는 객체지향 설계의 핵심이 책임이라는 점을 시사한다.
  2. 낮은 결합도와 높은 응집도를 갖는 구조를 만든다.
     * 이는 책임을 할당하는 작업이 응집도 또는 결합도와 같은 설계 품질과 밀접한 연관이 있음을 시사한다.
* 설계는 변경을 위해 존재하며, 변경에는 어떤 형식으로든 비용이 발생한다.
  * 따라서 **훌륭한 설게는 합리적인 비용으로 변경을 수용할 수 있는 구조를 만드는 것**으로 볼 수 있다.
  * 납득할 수 있는 비용에서 쉽게 변경할 수 있는 설계는 대체로 응집도가 높고 느슨하게 결합된 요소로 구성된다.
* **객체의 상태가 아닌 행동에 집중하는 것은 결합도와 응집도를 합리적인 수준으로 유지할 수 있는 중요한 원칙**이다.
  * 즉, 객체의 책임에 초점을 맞추는 방식이다.
  * 책임에 집중하는 것은 객체의 상태에서 행동으로, 나아가 객체 간의 상호작용으로 설계의 중심을 이동시킨다.
  * 이를 통해 결합도가 낮은 동시에 응집도가 높으며, 구현을 효과적으로 캡슐화하는 객체를 만들어낼 수 있게 된다.

### 객체지향 설계에서의 시스템 분할
* 객체지향 설게에서는 다음의 두 방식을 통해 시스템을 객체로 분할할 수 있다.
  1. 상태를 분할의 기준으로 삼는 방식
  2. 책임을 분할의 기준으로 삼는 방식
* **상태, 즉 데이터를 중심으로 하는 관점은 객체가 자신이 포함하는 데이터를 조작하기 위해 필요한 행동을 정의**한다.
  * 이 경우, 객체는 하나의 독립적인 데이터 덩어리에 지나지 않는다.
* **책임을 중심으로 하는 관점은 객체가 다른 객체로부터 요청받을 수 있는 행동을 위해 필요한 데이터를 보관**한다.
  * 이 경우, 객체는 협력하는 공동체의 일원이다.
* **훌륭한 객체지향 설계는 상태가 아닌 책임에 초점**을 맞추어야 하며, 그 이유는 변경과 관련이 있다.
  1. 상태는 기본적으로 객체의 구현에 속한다.
  2. **데이터 중심의 관점은 상태를 기반으로 데이터를 조작하는 행동을 정의하므로, 구현이 퍼블릭 인터페이스에 영향을 주기 쉽다**.
  3. 결국 **상태의 변경은 인터페이스의 변경을 반드시 수반하게 되며, 해당 퍼블릭 인터페이스에 의존하는 모든 객체에 영향**을 끼치게 된다.
* 반면 객체의 책임은 애당초 인터페이스에 속하며, 구현은 인터페이스 뒤로 캡슐화된다.
  * 따라서 책임에 초점을 맞추는 것은 상대적으로 변경에 안정적인 설계를 얻을 수 있게 한다.

## 설계의 품질을 판단하는 기준
* 좋은 설계의 특징을 판단할 수 있는 기준 중 하나로 캡슐화와 응집도, 결합도를 비교해볼 수 있다.

### 캡슐화
* **상태와 행동을 하나의 객체 안에 모으는 이유는 변경될 가능성이 높은 내부 구현을 외부로부터 감추기 위해서**이다.
  * 객체를 활용하는 것으로 변경 가능성이 높은 구현은 내부에 숨기고, 외부에는 상대적으로 안정된 퍼블릭 인터페이스만을 공개하여 변경 범위를 통제할 수 있다.
* 갹체 설계의 가장 기본적인 아이디어는 변경 가능성에 따라 구현과 인터페이스를 분리하고, 외부에서는 인터페이스에만 의존하도록 설계하는 것이다.
* 객체지향에서 가장 중요한 원리는 불안정한 세부사항을 안정적인 인터페이스 뒤로 숨기는 캡슐화이다.
  * 이런 측면에서, **캡술화는 외부에서 알 필요가 없는 부분을 숨겨 대상을 단순화하는 추상화의 한 종류**로 볼 수 있다.
* 설계가 필요한 이유는 요구사항은 반드시 변경될 것이기 때문이다. 
* 반면, 캡슐화는 불안정한 부분과 안정적인 부분을 분리함으로써 변경의 영향을 통제할 수 있기 때문에 중요하다.
  * 즉, **변경의 관점에서 설계의 품질을 판단하려면 캡슐화를 기준으로 삼을 수 있게 된다**.
```
> 캡슐화란 변경 가능성이 높은 부분을 객체 내부로 숨기는 추상화 기법이며, 변할 가능성이 있는 모든 것을 캡슐화하는 것이 객체지향 설계의 핵심이다.
```

### 응집도와 결합도
* 응집도는 모듈에 포함된 내부 요소들이 연관된 정보이며, 요소들이 같은 목적을 위해 긴밀하게 협력할수록 응집도는 높다.
  * 응집도는 객체 또는 클래스에 얼마나 관련 높은 책임들을 할당했는지를 나타내는 척도이다.
* 결합도는 의존성의 정도이며, 다른 모듈에 대해 얼마나 자세히 알고있는지 나타내는 척도이다.
  * 결합도는 객체 또는 클래스가 협력을 위해 필요한 적절한 관계만을 유지하고 있는지의 여부를 나타낸다.
* 일반적으로 **좋은 설계는 응집도가 높고 결합도가 낮은 모듈로 구성된 설계이므로, 두 개념은 모두 설계와 관련**이 있다.
  * 또한 **좋은 설계란 오늘의 기능은 충실히 수행하면서 내일의 변경은 얼마든지 수용할 수 있는 설계**이다.
  * 상술했듯 좋은 설계는 변경과 관련이 있고, 응집도와 결합도가 설계의 품질을 결정한다는 말은 곧 응집도와 결합도과 변경과 관련이 있음을 시사한다.
* 변경의 관점에서,
  1. **응집도는 변경이 발생할 때 모듈 내부에서 발생하는 변경의 정도로 측정**된다.
     * 응집도가 높은 모듈은 모듈 내부에서만 변경이 발생하며, 응집도가 낮은 모듈은 변경 사항을 반영하기 위해 여러 모듈을 수정해야 한다.
     * 반면 하나의 변경을 수용하기 위해 모듈 이곳 저곳을 수정해야 하는 경우, 모듈의 응집도가 낮다는 증거가 된다.
     * 즉, 응집도가 높을수록 변경의 대상과 범위는 명확해지므로 코드의 변경은 쉬워진다.
  2. **결합도는 한 모듈이 변경되기 위해 다른 모듈을 변경이 필요한 정도로 측정**된다.
     * 하나의 모듈을 수정할 때 얼마나 많은 모듈을 함께 수정해야하는지를 말하며, 결합도가 높을수록 함께 변경해야하는 모듈의 수는 많아진다.
     * 예를 들어 객체의 인터페이스가 아닌 구현을 수정하는 경우에도 의존되는 객체를 모두 변경해야 하는 경우, 객체 간의 결합도가 높음을 의미한다.
* 내부 구현을 변경했을 때 다른 모듈에 영향을 미치는 경우 두 모듈 사이의 결합도는 높다.
* 그러나 퍼블릭 인터페이스를 수정한 경우에만 다른 모듈에 영향이 미쳐진다면 결합도는 낮다.
  * 따라서 **클래스의 구현보다 인터페이스에만 의존하는 코드를 작성해야 낮은 결합도를 얻을 수 있게 된다**.
* 반면 **변경될 가능성이 없거나 매우 낮은 String, ArrayList 등의 표준 라이브러리와는 결합도가 높아도 아무런 상관이 없다**.
  * 그러나 직접 작성한 코드라면 불안정하고 언제나 변경될 수 있으므로, 반드시 낮은 결합도를 유지하려 노력해야 한다.
* **응집도와 결합도는 변경과 관련이 깊으며, 이상적인 응집도와 결합도를 유지한다면 변경 사항을 반영하기 쉽다는 사실을 반드시 기억**해야 한다.
  * 응집도와 결합도를 변경의 관점에서 바라보는 것은 설계에 대한 시각을 한 층 넓혀줄 수 있다.
* 캡슐화의 정도 역시 응집도와 결합도에 영향을 미친다.
  * 캡슐화를 준수할 경우 자연스럽게 모듈 내부의 응집도는 높아지고, 모듈 간의 결합도는 낮아진다.
  * 캡슐화는 위반할 경우 모듈 내부의 응집도는 낮아지고, 결합도는 높아진다.
* **따라서 응집도와 결합도를 고려하기 전에 우선 캡슐화의 정도를 향상시킬 수 있도록 노력하는 것이 바람직**하다.

### 데이터 중심 설계의 한계
* 데이터 중심의 설계는 캡슐화를 위반하고, 객체의 내부 구현을 인터페이스의 일부로 취급한다.
* 반면 책임 중심의 설계는 객체의 내부 구현을 안정적인 인터페이스 뒤로 캡슐화한다.
* 캡슐화의 정도는 객체의 응집도와 결합도를 결정하므로, 자연스레 데이터 중심의 설계는 응집도가 낮고 결합도가 높은 설계를 낳게 된다.
* **객체에게 중요한 것은 책임이며, 구현을 캡슐화할 수 있게하는 적절한 책임은 협력이라는 문맥을 고려했을 때만 얻어낼 수 있다**.
  * 협력을 고려하지 않는 경우 개발자는 문맥을 추측할 수 밖에 없으며, 때문에 어떤 상황에서도 대응이 가능한 객체를 만들기 위해 많은 접근자를 양산하게 된다.
* 이러한 추측에 의한 설계 전략은 접근자와 수정자에 과하게 의존하며, 객체가 사용될 문맥을 고려하지 않으므로 많은 접근자 메소드를 작성하게 된다.
  * **결과 생성된 수많은 접근자 메소드에 의해 대부분의 내부 구현은 퍼블릭 인터페이스에 그대로 노출**된다.
  * 이는 캡슐화의 원칙을 위반하는 대표적인 흐름이며, 이에 따라 변경에 취약한 설계를 얻게 된다.
* 객체 내부의 구현이 객체 인터페이스에 드러나는 것은 클라이언트가 구현에 강하게 결함되는 높은 결합도를 의미한다.
  * 데이터 중심의 설계는 전체 시스템을 하나의 거대한 의존성 덩어리로 만들게 되므로, 어떠한 변경 사항도 시스템 전체에 영향을 끼치게 된다.
* 서로 다른 이유에 의해 변경되는 코드가 하나의 모듈에 공존하는 경우 모듈의 응집도는 낮다.
  * 데이터 중심의 설계는 변경의 이유가다른 코드들을 하나의 모듈 안으로 모아두기 쉬우므로, 자연스레 응집도는 낮아진다.
* **단일 책임 원칙에 따르면 클래스는 단 하나의 변경의 이유만을 가져야 하며, 단일 책임 원칙은 클래스의 응집도를 높여주는 설계의 원칙**이다.
  * 이 때, 책임은 앞서 다룬 협력, 책임, 역할의 그것과는 다른 변경과 관련된 더 큰 개념을 가리키는 표현이다.

### 자율적인 객체 만들기
```
> 캡슐화는 객체지향 설계의 제 1 원칙이다.
```
* **데이터 중심의 설계가 낮은 응집도와 높은 결합도를 갖게되는 근본적인 원인은 캡슐화를 위반하기 때문**이다.
* 객체는 자신이 갖는 데이터를 내부에 캡슐화하며, 외부에 공개해서는 안된다.
  * 즉, 자율적인 객체는 자신의 상태를 책임지고 퍼블릭 인터페이스에 정의된 메소드로만 상태에 접근할 수 있어야 한다.
  * 이 때, **메소드는 단순한 접근자가 아닌 객체가 책임지고 무언가를 수행하는 행동**을 말한다.
* 상태와 행동을 객체라는 단위로 묶는 이유는 객체 스스로 자신의 상태를 책임지고 처리하기 위해서이다.
  * **객체는 단순한 데이터 제공자가 아니며, 객체 내부의 데이터보다 객체가 협력에 참여하면서 수행해야할 책임을 정의하는 오퍼레이션이 더 중요**하다.
* 객체를 설계할 때 곧잘 하는 '이 객체가 어떤 데이터를 포함해야 하는가?'는 다음과 같은 두 가지 질문으로 분리되어야 한다.
  1. 이 객체가 어떤 데이터를 포함해야 하는가?
  2. 이 객체가 데이터에 대해 수행해야 하는 오퍼레이션은 무엇인가?
* 두 질문을 조합하여 객체의 내부 상태 저장 방식과, 저장된 상태에 대해 호출할 수 있는 오퍼레이션의 집합을 얻어낼 수 있다.

### 캡슐화 II
* 캡슐화는 단순히 내부의 데이터를 외부로부터 숨기는 것 이상의 의미를 갖는다.
  * 예를 들어, 메소드 시그니쳐를 통해 내부 데이터 구조를 간접적으로 알리는 객체 역시 캡슐화를 위반하는 예시이다.
  * 또는 객체 내부의 변경이 외부로 퍼져나가 어떤 식으로든 외부를 수정해야한다면, 이 역시 캡슐화가 부족하다는 명백한 증거이다.
* 진정한 의미의 캡슐화는 객체 내부에서 변경될 수 있는 것은 무엇이든 객체 내부로 숨기는 것이며, 내부 속성만을 감추는 것은 데이터 캡슐화에 지나지 않는다.
* **설계에서는 변하는 것이 무엇인지 고려하고, 변할 수 있는 개념이 구현과 관련이 있다면 반드시 모두 캡슐화**해야 한다.
* 객체지향 설계의 응집도, 결합도와 관련한 문제는 모두 캡슐화 원칙을 위배함으로써 비롯된다.
  * 따라서, **유연한 설계를 만들기 위해서는 반드시 캡슐화를 설계의 제 1 목표로 삼아야 한다**.

### 데이터 중심 설계의 문제점
```
> 데이터 중심의 설계는 너무 이른 시기에 데이터에 대해 고민하게되므로, 결과적으로 캡슐화에 실패하게 된다.
```
* 데이터 중심 설계가 변경에 취약한 이유는 다음과 같다.
  1. 본질적으로 너무 이른 시기에 데이터와 관련된 결정이 강제된다.
  2. 협력이라는 문맥을 고려하지 않고 객체를 고립한 상태에서 오퍼레이션을 결정하게 된다.
* 데이터는 엄연히 구현의 일부이므로, 데이터 주도 설계는 설계를 시작하는 시점부터 데이터에 관한 결정을 강요한다.
  * 즉, 너무 빠른 시점에 내부 구현에 초점을 맞춰버리게 된다.
* 데이터 중심 설계에 익숙한 개발자들은 데이터와 기능을 분리하는 절차적 방식을 따르기 쉽다.
  * 이는 상태와 행동을 하나의 단위인 객체로 캡슐화하는 객체지향 패러다임에 반하는 방식이다.
  * 이러한 과정에서 데이터 객체는 과도한 접근자와 수정자를 갖게 되고, 이는 사실상 public한 데이터와 다를 바가 없게 되어 캡슐화가 무너진다.
* 비록 데이터를 처리하는 작업과 데이터를 같은 객체에 두었더라도, 데이터에 초점을 맞춘 설계는 만족스럽게 캡슐화하기 어렵다.
  * **데이터를 먼저 결정한 후 데이터와 관련된 오퍼레이션을 정의하므로, 데이터와 관련된 지식은 퍼블릭 인터페이스에 고스란히 드러나게 된다**.
  * 결과, 객체의 인터페이스는 구현을 캡슐화하지 못하고 코드는 변경에 취약해지게 된다.
* 결국 **데이터 중심 설계는 객체의 내부 구현이 인터페이스를 어지럽히고, 객체의 응집도와 결합도에 악영향을 미쳐 변경에 취약**하게 된다.

### 데이터 중심 설계의 문제점 II
* 객체지향 애플리케이션을 구축하는 것은 곧 협력하는 객체들의 공동체를 구축하는 것과 같다.
  * 때문에 **협력이라는 문맥 안에서 필요한 책임을 결정하고, 이를 수행할 적절한 객체를 결정하는 흐름을 갖는 것이 이상적**이다.
* 이렇듯 **올바른 객체지향 설계의 초점은 항상 객체의 내부가 아닌 외부를 향하며, 객체 내부의 세부사항은 부가적인 문제**이다.
  * 중요한 것은 객체가 다른 객체와 협력하는 방법 그 자체이다.
* 반면 데이터 중심 설계의 초점은 너무 이른 시기에 외부가 아닌 내부로 맞춰지므로, 객체가 관리할 데이터의 세부사항을 우선 결정하게 된다.
* 결과, **객체의 구현을 이미 결정한 후 협력을 고민하므로, 구현된 객체의 인터페이스에 끼워맞추는 개발을 진행할 수 밖에 없게 된다**.
  * 이러한 문제는 객체의 인터페이스에 내부의 구현이 노출되는 형식으로 나타난다.
  * 결국 객체 간의 협력이 구현 세부사항에 종속되므로, 객체 내부의 구현에 대한 변경도 협력하는 모든 객체에게 영향을 주게 된다.
# Objects
## 2022-04-04 Mon

## 합성과 유연한 설계
* 상속과 합성은 널리 사용되는 코드 재사용 기법이지만, 코드를 재사용하기 위한 목적을 제외하면 큰 차이를 보인다.

### 상속과 합성의 차이
* 상속은 부모 클래스와 자식 클래스를 연결하여 부모 클래스의 코드를 재사용한다.
   * 합성은 전체를 표현하는 객체가 부분을 표현하는 객체를 포함하여 호출하는 것으로 부분 객체의 코드를 재사용한다.
* 상속은 부모 클래스와 자식 클래스 사이의 의존성이 컴파일타임에 연결된다.
  * 합성은 두 객체 사이의 의존성이 런타임에 해결된다.
* 상속 관계는 is - a 관계이다.
  * 합성은 has - a 관계이다.
* 상속은 자식 클래스가 부모 클래스의 내부 구현에 대해 상세하게 알아야 하므로 상속 계층도 내의 클래스들의 결합도가 높아진다.
  * 합성은 부분 객체의 구현에 의존하지 않으며, 대신 퍼블릭 인터페이스에 의존한다.
  * **합성을 사용하는 경우, 포함된 객체의 내부 구현이 변경되더라도 영향을 최소화할 수 있기 때문에 변경에 안정적인 코드를 얻을 수 있다**.
* 상속 관계는 클래스 사이의 정적인 관계이며, 코드 작성 시점에 결정된 관계를 이후에 변경할 수 없다.
  * **합성 관계는 객체 사이의 동적인 관계이며, 런타임에 동적으로 관계를 변경**할 수 있다.
  * 때문에 합성 관계는 상속보다 변경에 대응하기 쉽고 유연한 설계를 얻을 수 있게 한다.
* 상속은 부모 클래스 내부에 구현된 코드 자체를 재사용하므로, 구현에 대해 의존한다.
  * **합성은 부분 객체의 퍼블릭 인터페이스를 재사용하므로, 구현에 대한 의존 대신 퍼블릭 인터페이스에 대한 의존으로 대체**할 수 있다.
  * 즉, 클래스 간의 높은 결합도를 객체 간의 낮은 결합도로 대체할 수 있다.
```
> 변경에 유연하게 대처할 수 있는 설계는 대부분의 경우에 정답이므로, 상속보다 객체 합성이 더 좋은 방법이다.
```

### 상속 관계를 합성 관계로 변경하기
* 상속을 합성으로 바꾸기 위해, 다음과 같은 절차를 따르도록 한다.
  1. 자식 클래스에 선언된 상속 관계를 제거한다.
  2. 부모 클래스의 인스턴스를 자식 클래스의 인스턴스 변수로 선언한다.
* **상속을 남용하는 경우 발생할 수 있는 아래와 같은 문제점은 합성 관계로 변경하는 것으로 모두 해결**된다.
  1. 자식 클래스의 용도에 적절하지 않은 부모 클래스의 오퍼레이션을 상속받을 수 있다.
  2. 자식 클래스가 부모 클래스의 메소드를 오버라이딩하는 경우, 자식 클래스가 부모 클래스의 메소드 호출 방법에 영향을 받을 수 있다.
  3. 자식 클래스와 부모 클래스 사이의 개념적 결합으로 인해 부모 클래스를 수정할 때 자식 클래스도 함께 수정해야할 수 있다.

### 구현 결합도를 제거하면서 퍼블릭 인터페이스를 상속받기
* 어떤 클래스의 모든 메소드를 상속받되, 구현에 대한 결합도는 제거하고 싶은 경우가 있을 수 있다.
  * 예를 들어, ArrayList의 모든 메소드를 상속받되 내부 구현과 결합되고 싶지 않은 경우이다.
* 이 경우, **인터페이스인 List를 구현하되 내부에 ArrayList의 인스턴스를 합성하는 것으로 구현 결합도를 제거하고 퍼블릭 인터페이스를 유지**할 수 있다.
* 해당 방식으로 필요한 메소드의 구현을 수정하되, 재정의하는 모든 인터페이스는 합성된 부분 객체에게 전달한다.
  * 이렇듯 **동일한 메소드의 호출을 그대로 전달하기 위해 추가되는 메소드를 포워딩 메소드라고 하며, 전달 과정 자체는 포워딩**이라고 한다.
```
> 포워딩은 기존 클래스의 인터페이스를 그대로 외부에 제공하되, 구현에 대한 결합 없이 일부 작동 방식을 변경하고 싶은 경우에 유용하게 사용할 수 있는 기법이다.
```

### 상속으로 인한 조합의 폭발적인 증가
* 상속으로 인해 결합도가 높아지면 코드를 수정하기 위해 필요한 작업의 양이 과도하게 많아지는 경향이 있다.
  * 대표적으로 작은 기능들을 조합하여 큰 기능을 수행하는 객체를 만드는 경우가 있다.
* 상술한 경우, 일반적으로 다음과 같은 문제점이 발생한다.
  1. 클래스 폭발 문제: 하나의 기능을 추가하거나 수정하기 위해 불필요하게 많은 수의 클래스를 추가하거나, 수정해야 한다.
     * 예를 들어, 추상 부모 클래스를 여러 자식 클래스가 상속받은 경우, 부모 클래스에 추상 메소드를 추가하는 경우가 있다. 
  2. 단일 상속만 지원하는 언어에서는 상속으로 인해 오히려 중복 코드의 양이 많아질 수 있다.
* **합성을 사용하는 것으로 상술한 상속으로 인해 발생할 수 있는 클래스의 증가와 코드 중복 문제를 간단하게 해결**할 수 있다.

### 클래스 폭발 문제
* 클래스 폭발, 또는 조합의 폭발 문제는 상속의 남용으로 인해 하나의 기능을 추가하기 위해 필요 이상으로 많은 수의 클래스를 추가해야하는 경우를 가리킨다.
* **클래스 폭발 문제는 자식 클래스가 부모 클래스에 강하게 결합되어야하는 상속의 근본적인 한계로 인해 발생**한다.
  * 컴파일타임에 결정된 자식 클래스와 부모 클래스 사이의 관계는 변경될 수 없다.
  * 따라서, 자식 클래스와 부모 클래스의 다양한 조합이 필요한 경우에는 조합의 수만큼 새로운 클래스를 작성하는 수 밖에 없다.
* 클래스 폭발 문제는 새로운 기능을 추가할 때 뿐만 아니라 기능을 수정할 때에도 문제가 될 수 있다.
* **상술한 모든 문제를 해결하는 최선의 방법은 상속을 포기하는 것**이다!

### 합성 관계로 변경하기
* 상속 관계는 컴파일타임에 결정되고 고정되므로, 코드를 실행하는 도중에 변경할 수 없다.
  * **컴파일타임 의존성과 런타임 의존성 간의 거리가 멀수록 설계는 유연해지지만, 상속 관계에서는 둘이 동일**하다.
  * 때문에 여러 기능을 조합해야하는 설게에 상속을 활용하면 모든 조합 가능한 경우에 대해 클래스를 추가하게 된다.
* 반면, 합성 관계는 컴파일타임 관계를 런타임 관계로 변경하여 문제를 해결한다.
  * 상속과 달리 합성을 사용하면 구현이 아닌 퍼블릭 인터페이스에만 의존할 수 있으므로, 런타임에 객체 관계를 동적으로 변경할 수 있다.
* **유연한 설계를 만들기 위한 대부분의 의존성 관리 기법은 상속이 아닌 합성을 기반**으로 한다.
* **컴파일타임 의존성과 런타임 의존성 간의 거리가 멀어질수록 설계의 복잡도는 상승하므로 코드를 이해하기 어려워진다**.
  * 그러나 설계는 변경과 유지보수를 위해 존대하며, 언제나 트레이드오프의 산물이다.
* 대부분의 경우 단순한 설계가 정답이지만, 변경에 따르는 고통이 복잡성으로 인한 혼란을 뛰어넘는 경우 유연성의 손을 들어주는 것이 바람직하다.

### 객체의 합성이 클래스의 상속보다 좋다
* 객체지향에서 코드를 재사용하기 위해 널리 사용되는 방법은 상속이지만, 우아한 해결책은 아니다.
* 상속은 부모 클래스의 세부적인 구현 사항에 자식 클래스를 강하게 결합시키므로 코드의 진화를 방해한다.
* **코드를 재사용하면서도 결합도를 느슨하게 유지할 수 있는 더 좋은 방법은 합성을 이용하는 것**이다.
  * 상속은 구현을 재사용하지만, 합성은 객체의 인터페이스 를 재사용한다.

### 믹스인
* 우리가 원하는 것은 코드를 재사용하면서도 납득할 수 있는 수준의 결합도를 유지하는 것이다.
* 상속과 클래스를 기반으로 하는 재사용 방법은 클래스의 확장과 수정을 일관성 있게 표현할 수 있는 추상화의 부족으로 인해 변경이 어려운 코드를 얻게 된다.
  * 따라서, **구체적인 코드를 재사용하면서도 낮은 결합도를 유지할 수 있는 유일한 방법은 재사용에 적합한 추상화를 도입하는 것**이다.
* 믹스인은 객체를 생성할 때 코드의 일부를 클래스 안에 섞어 넣어 재사용하는 기법이다.
  * 합성이 런타임 시점에 객체를 조합하는 재사용 방법이라면, 믹스인은 컴파일 시점에 필요한 코드 조각을 조합한다.
* 상속은 자식 클래스와 부모 클래스를 동일한 범주로 묶어 is a 관계를 만드는데에 진정한 목적이 있다.
  * 반면, 믹스인은 말 그대로 코드를 다른 코드 안에 섞어 넣는데에 존재 의의가 있다.
* **상속은 클래스와 클래스 간의 관계를 고정시키지만, 믹스인은 유연하게 관계를 재구성할 수 있도록 한다**.
* 전통적으로 믹스인은 특정한 클래스의 메소드를 재사용하고 기능을 확장하기 위해 사용되어 왔다.
* 믹스인은 상속 계층 안에서 확장한 클래스보다 더 하위에 위치한다.
  * 즉, 믹스인은 대상 클래스의 자식 클래스처럼 사용될 용도로 만들어진다.
  * 이러한 특징 덕분에 **믹스인은 추상 서브클래스로 불리우기도 한다**.
* 믹스인을 사용하면 특정 클래스에 대한 변경 또는 확장을 독립적으로 구현하고, 필요한 시점에 차례대로 추가해나갈 수 있다.
  * 믹스인의 이러한 특징은 쌓을 수 있는 변경이라고 부를 수 있다.
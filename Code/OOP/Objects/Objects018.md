# Objects
## 2022-04-10 Sun

## 동적인 협력, 정적인 코드
* 협력을 구성하기 위해 필요한 객체는 살아 움직이며, 동적이다.
  * 즉, 객체는 시간에 따라 다른 객체와 협력하며 계속해서 변화한다.
* 객체의 움직임과 변화를 표현하기 위해 사용하는 프로그래밍 언어는 텍스트로 구성되며, 정적이다.
* 때문에 프로그램은 고정된 텍스트라는 형식을 사용하면서도 객체의 모든 변화 가능성을 담을 수 있어야 한다.
* 즉, 개발자는 객체지향 프로그램을 작성하기 위해 두 가지 모델을 동시에 그릴 수 있어야 한다.
  1. 동적 모델: 프로그램의 실행 구조를 표현하는 움직이는 모델
  2. 정적 모델: 코드의 구조를 담는 고정된 모델
* 훌륭한 객체지향 프로그램을 작성하려면 동적 모델과 정적 모델을 조화롭게 구성할 수 있어야 한다.
  * 객체지향의 세계에서 동적 모델은 객체와 협력으로 구성되고, 객체는 다른 객체와 협력하며 애플리케이션의 기능을 수행한다.
  * 객체지향의 세계에저 정적 모델은 타입과 관계로 구성되며, 타입은 객체를 분류하는 틀로서 동일한 타입에 속하는 객체들이 수행할 수 있는 모든 행동을 표현한다.
    * 클래스 기반의 객체지향 언어에서 타입을 구현하는 대표적인 방법은 클래스이므로, 일반적인 정적 모델은 클래스로 구성된 모델을 의미한다.
* **핵심은 코드 안에 담겨지는 정적 모델이 객체 간의 협력에 기반하는 동적 모델에 기반해야 한다는 사실**이다.
  * **정적 모델은 반드시 동적 모델의 의해 주도외어야 하며, 동적 모델이라는 토대 위에 정의**되어야 한다.
* 동적 모델을 기반으로 정적 모델을 구상할 때 고려해야 하는 중요한 요소는 변경이다.
  * 설계가 필요한 이유는 변경을 수용할 수 있는 코드를 만들기 위해서이기 때문이다.
* 변경을 수용할 수 있는 코드란, 다음과 같은 특징을 갖는다.
  1. 단순하다.
  2. 결합도가 낮다.
  3. 중복된 코드가 없다.
* 수정이 용이한 코드란 응집도가 높고, 결합도는 낮으며, 단순하여 쉽게 이해할 수 있는 코드이다.
* 유연한 코드란 동일한 코드를 이용하여 다양한 컨텍스트에서 동작 가능한 협력을 만들 수 있는 코드이다.
  * **수정이 용이한 코드와 유연한 코드에 대한 욕구는 중복된 코드를 제거하게 하는 가장 큰 압력**이다.
* 이러한 **목적을 달성하기 위해서는 정적인 코드가 아닌 객체 간의 협력에 초점을 맞추어야 한다**.
```
> 좋은 설계는 객체 사이의 협력과 행동을 표현하는 동적 모델을 기반으로 해야 한다.
> 정적 모델은 동적 모델이 그려둔 윤곽을 따라야 한다.
```

### 행동은 코드를 결정한다
* 협력에 참여하는 객체의 행동이 객체의 정적 모델을 결정해야 한다.
  * 이 때, 행동이 코드의 구조에 영향을 미치는 대표적인 예시는 상속 계층을 구성하는 방식이다.
* **객체의 행동을 고려하지 않을 경우 인스턴스들이 예상과는 다르게 행동하거나, 개방 폐쇄 원칙을 위한하는 코드가 양산되기 쉽다**.
  * 객체의 정적 모델은 동적 모델이라는 토대가 있어야만 완전해질 수 있다.
* **중요한 것은 객체가 외부에 제공하는 행동이며, 정적 모델을 설게하는 이유는 단지 행동과 변경을 적절히 수용할 수 있는 코드 구조를 찾는 것이어야만 한다**.
* 정적 모델을 미리 결정하고 객체의 행동을 정적 모델에 맞추지 말아야 한다.
  * **동적 모델이 정적 모델을 결정해야 하며, 정적 모델이 협력에 적합하지 않은 경우에는 정적 모델을 지속적으로 개선**해야 한다.
  * 이 과정에서 다소 어색한 이름의 클래스가 작성되어도 상관 없다!

### 변경을 고려하기
* **객체가 제공하는 행동의 측면에서 적절하게 정적 모델을 고려했더라도, 변경을 고려하지 않았다면 유지보수하기 어려운 코드가 만들어지기 쉽다**.
* **동일한 행동을 제공하는 정적 모델은 여럿일 수 있으며, 이 경우에는 현재의 설계에서 요구되는 변경을 부드럽게 수용할 수 있는 설계를 선택**하도록 한다.

### 도메인 모델의 허와 실
* 도메인 모델이란 사용자가 프로그램을 사용하는 대상 영역에 대한 지식을 선택적으로 단순화하고 의식적으로 구조화한 형태이다.
* 객체지향 분석 설계에서 제안하는 지침 중 하나는 소프트웨어의 도메인에 대해 고민하고, 도메인 모델을 기반으로 소프트웨어를 구축하는 것이다.
  * 이를 통해 개념과 소프트웨어 사이의 표현적인 차이를 줄일 수 있으므로, 이해하고 수정하기 쉬운 소프트웨어를 만들 수 있다.
* 중요한 것은 도메인 모델을 작성하는 것이 목표가 아닌 출발점이라는 사실이다.
  * 소프트웨어를 만들기 위해 수행하는 모든 활동의 궁극적인 목표는 동작하는 소프트웨어를 만드는 것이다.
  * **도메인 모델의 역할은 소프트웨어를 만드는 데에 필요한 개념의 이름과 의미, 나아가 관계에 대한 힌트를 제공하는 것으로 끝나야 한다**. 
* 문제는 도메인 개념이 제공하는 틀에 맞추어 소프트웨어를 제작해야한다고 생각할 때부터 발생한다.
  * 또한, 도메인 모델이 클래스 다이어그램 같은 정적인 모델에 기반해야 한다는 오해 역시 문제를 불러일으킬 수 있다.
* 도메인 모델은 어떠한 형태로 표현해도 상관이 없으며, **중요한 것은 소프트웨어의 기능과 객체의 책임**이다.
* 도메인 안의 개념을 기반으로 출발하되, 객체들의 협력 구조가 도메인 모델에 맞지 않는다면 필요한 몇 가지 개념만 남기고 도메인 모델을 과감히 수정해야 한다.
* **중요한 것은 객체들의 협력을 지원하는 코드 구조를 만드는 것이며, 도메인의 개념을 충실히 따르는 코드를 만드는 것이 아니다**.
  * **코드의 구조를 주도하는 것은 구조 그 자체가 아닌 행동이라는 사실을 반드시 기억**해야 한다.
* 도메인 모델에 지나치게 집착하거나, 도메인 모델의 초기 구조를 맹목적으로 따르는 코드를 작성하고 있다면 변경하기 어려운 소프트웨어가 만들어질 확률이 높다.

### 행동과 변경을 고려하는 도메인 모델
* 도메인 모델은 작업을 시작하기 위한 거친 아이디어 덩어리에 불과하므로, 도메인 모델을 그대로 담아내려 하지 말아야 한다.
  * 프로젝트가 성숙함에 따라 더 많은 시직이 쌓이고 요구사항이 분명해지면 초기의 아이디어에 대한 미련은 버리고 더 좋은 판단을 내릴 수 있어야 한다.
* 초기에 고안한 도메인 모델은 좋은 출발점이 될 수 있지만, 객체의 행동과 변경이라는 요소를 고려하면 그 가치는 빠르게 떨어져간다.
* 따라서 **구현하거나 변경하기 쉬운 모델이 구성된다면 초기 아이디어는 과감하게 버려져야 한다**.
  * 객체지향의 핵심은 객체 사이의 협력이며, 설계는 변경을 위한 것이다.
  * 때문에 **행동과 변경을 고려하지 않은 채로 도메인 모델을 그대로 따르는 설계는 오히려 코드의 유지보수를 방해**한다.
* **도메인 모델은 단순히 클래스 다이어그램이 아니며, 도메인의 핵심을 간략하게 단순화하여 표현할 수 있는 모든 것이 도메인 모델이 될 수 있다**.
  * 나아가 이렇게 작성된 개념이 코드에 대한 구조와 행동을 잘 드러낸다면 더할 나위 없이 훌륭한 도메인 모델이다.
  * 형식은 중요하지 않으며, 중요한 것은 전달하려는 의미이므로 심지어 JSON 문서 역시 도메인 모델이 될 수 있다.
* **도메인 모델은 코드를 위한 것이므로 단순히 정적 모델의 형태를 띌 필요가 없으며, 도메인 모델의 구조는 코드와 다를 필요도 없다**.
  * 도메인 모델은 도메인 안에 존재하는 개념과 관계를 표현해야 하지만, 최종 모습은 객체의 행동과 변경에 기반하여 코드의 구조를 반영해야 한다.
  * **중요한 것은 도메인 모델을 봤을 때 도메인의 개념은 물론 코드도 함께 이해될 수 있는 구조를 찾는 것**이다.

### 분석 모델, 설계 모델, 구현 모델
* 분석 모델은 해결 방법 없이 문제 도메인을 설명하며, 기술적인 해결을 언급하지 않는다.
* 설계 모델은 분석 모델을 바탕으로 기술적인 관점에서 솔루션을 서술하는 모델이다.
* 개발자는 이렇게 만들어진 청사진을 기반으로 구현 모델을 만들고 프로그램을 작성한다.
* 그러나 **모델을 세 종류로 명확히 구분하는 것은 가능하지도 않고, 소프트웨어 품질에는 오히려 악영향**을 미친다.
  * 우리에게 필요한 것은 분석, 설계, 구현 기간 동안 동일한 모델을 유지하는 것이다.
* 상술했듯 도메인 모델이 코드와 동일한 형태를 가진다는 것은 모든 단계에 걸쳐 동일한 모델을 사용할 수 있다는 것을 의미한다.
  * **객체지향이 다른 패러다임과 구별되는 가장 큰 차이점은 소프트웨어 개발 주기 동안 동일한 설계 기법과 모델링 방법을 사용할 수 있다는 점**이다.
* 만약 설계 모델의 일부가 적용 기술 내에서 구현할 수 없다면 설계 모델은 변경되어야 한다.
  * 개발 작업 동안 설계의 실현 가능성과 정확성은 검증되고 테스트되어야 한다.
  * 그 결과, 잘못된 설계는 수정되거나 새로운 설계로 대체되어야 하므로 프로그래밍은 설계의 한 과정이며, 설계는 프로그래밍을 통해 개선된다.
* 따라서 프로젝트 내에서 분석 모델을 설계 모델로 변환하는 작업에 많은 시간을 소비한다면, 설계 모델에 도메인이 반영되도록 수정하고 분석 모델은 폐기한다.
  * 이러한 프로젝트는 소프트웨어 자체가 아닌 프로세스를 위한 맹목적인 작업에 구성원들의 시간과 체력을 낭비하게 만든다.
* 코드와 모델의 차이를 줄이기 위해서는 도메인과 코드 간의 차이가 적어야 한다.
  * **객체지향의 가장 큰 힘은 도메인을 표현하는 방법과 프로그램 코드를 표현하는 방법이 동일하다는 점**이다.
* 또한, 분석 모델과 설계, 구현 모델이 모두 다르다는 생각이나 별개의 활동이라는 생각 역시 버려야 한다.
  * 객체지향 언어는 도메인을 바라보는 관점을 소프트웨어에 투영할 수 있는 다양한 기법을 제공한다.
  * 도메인의 개념과 객체 간 협력을 조화시키고 코드에 반영하기 위해 고민하거나, 실제로 개발하는 시간은 분석과 설계, 구현에 대해 동시에 고민하고 있는 것이다.
```
> 설계 또는 설계의 주된 부분이 도메인 모델과 대응되지 않는다면, 해당 모델은 가치가 없으며 소프트웨어의 정확성도 의심스러워질 수 있다.
> 모델이 구현에 비해 비현실적이거나, 도메인의 핵심 개념을 충실히 반영하지 않는다면 새로운 모델을 찾아 대체하도록 한다.
> 이러한 과정을 통해서야만 모델링과 설계 프로세스는 하나의 반복 고리를 형성할 수 있다.
```

### 동적인 협력과 정적인 코드의 결론
* 코드는 도메인의 개념적인 분류 체계가 아닌 객체의 행동과 변경에 영향을 받는다.
* 객체지향 패러다임에서 분석 모델과 설계 모델, 그리고 구현 모델 사이에는 어떠한 차이점도 존재하지 않는다.
  * 이러한 세 모델은 모두 행동과 변경이라는 요소에 영향을 받고, 전체 개발 주기 동안 동일한 모양을 지녀야만 한다.
* **객체지향 패러다임의 강력함은 전체 개발 주기에 걸쳐 동일한 기법과 표현력을 유지할 수 있다는 점에서 기인**한다.
```
> 분석, 설계, 구현 단계 사이의 세부적인 내용은 달라질 수 있지만, 모든 단계에서 설계의 초점은 객체의 행동과 변경에 동일하게 유지되어야 한다.
```
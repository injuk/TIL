# Objects
## 2022-04-03 Sun

## 상속과 코드 재사용
* 코드를 쉽게 재사용할 수 있는 특징은 객체지향 프로그래밍의 장점 중 하나이다.
* 객체지향에서는 클래스에 코드를 작성하므로, 클래스를 재사용하기 위해서는 새로운 클래스를 추가하는 방식을 사용한다.
* 재사용 관점에서의 상속은 클래스 내부에 정의된 인스턴스 변수와 메소드를 자동으로 새로운 클래스에 추가하는 기법이다.

### DRY 원칙
* **중복 코드를 제거해야하는 가장 큰 이유는 중복 코드가 변경을 방해하기 때문**이다.
* 프로그램의 본질은 비즈니스와 관련된 지식을 코드로 변환하는 데에 있으며, 이러한 지식은 항상 변하기 마련이다.
  * 때문에 **지식을 표현하는 코드 역시 항상 변경될 것이라고 생각하는 것이 좋다**.
  * 일단 새로운 코드를 추가했다면, 해당 코드는 언젠간 변경될 것이다.
* **코드는 언젠가 수정되기 마련인 특징에 기반하여, 중복 코드는 코드를 수정하기 위해 필요한 노력을 몇 배로 증가**시킨다.
* **코드의 중복을 판단하는 기준은 코드 모양의 유사성이 아닌 변경**이다.
  * 예를 들어, 요구사항이 변경되었을 때 함께 수정되어야 하는 코드는 중복이다.
  * 반면, 함께 수정될 필요가 없는 코드는 단지 로직이 유사한 것일 뿐 중복은 아니다.
  * 코드의 중복 여부를 결정하는 기준은 코드가 변경에 반응하는 방식이다.
* DRY 원칙은 프로그래머들이 마땅히 따라야하는 원칙이며, 동일한 지식을 중복하지 말 것을 강조한다.
  * DRY는 Don't Repeat Yourself의 약자이다.
  * 신뢰할 수 있고 수정하기 쉬운 소프트웨어를 만들기 위한 효과적인 방법으로서 DRY 원칙을 준수하고, 중복을 제거할 수 있다.
* **DRY 원칙은 다른 여러 이름으로도 불리우지만, 언제나 핵심은 코드 안에서 중복된 지식이 존재하지 않아야한다는 점**이다.

### 중복과 변경
* 중복 코드는 항상 함께 수정되므로, 수정 과정에서 누락된 것이 하나라도 존재한다면 바로 버그로 이어지게 된다.
  * 더 큰 문제는 중복 코드는 서로 다르게 수정하기가 쉽다는 점이다.
* **중복 코드를 제거하지 않고 코드를 수정하는 유일한 방법은 새로운 중복 코드를 추가하는 것이므로, 중복 코드는 항상 새로운 중복 코드를 부른다**.
* 나아가 새로운 중복 코드를 추가하는 과정에서는 항상 코드의 일관성이 무너질 위험이 수반된다.
* 결과, 중복 코드가 늘어날수록 애플리케이션은 변경에 취약해지고 새로운 버그가 발생할 가능성이 높아진다.
  * **중복 코드의 양이 많아질수록 버그는 늘어나는 반면, 코드를 변경하는 속도는 느려진다**.
* **이를 해결하기 위해서는 중복 코드를 추가하는 대신에 중복을 제거해야 하며, 기회가 생길 때마다 코드에 DRY 원칙을 적용**해야 한다.

### 타입 코드의 사용
* 두 클래스의 중복을 제거하는 방법 중 하나는 두 클래스를 단일 클래스로 합치고, 내부의 enum을 통해 타입을 구분하는 것이다.
  * 이 경우, 클래스의 타입 코드로 적용된 enum에 따라 실제 로직을 if - else 분기로 구분하게 된다.
* 그러나 **타입 변수를 활용하는 이러한 클래스는 앞서 다룬 바와 같이 낮은 응집도와 높은 결합도라는 또 다른 문제에 직면**하게 된다.
* **객체지향 프로그래밍 언어는 타입 코드를 사용하지 않고도 중복 코드를 관리할 수 있는 방법인 상속을 제공**한다.

### 상속을 활용한 중복 코드의 제거
* 상속의 기본적인 아이디어는 이미 존재하는 클래스와 유사한 클래스가 필요한 경우, 코드를 복사하지 말고 상속을 활용하여 코드를 재사용하라는 것이다.
* 그러나 **잘못 사용된 상속은 요구사항과 실제 구현의 차이를 크게 벌려 코드를 이해하기 어렵게 만든다**.
  * 특히 상속을 염두에 두고 설계되지 않은 클래스를 상속에 활용하는 경우, 이러한 현상은 더욱 두드러지게 나타난다.
* **상속을 통해 코드를 재사용하는 경우는 개발자의 가정을 이해하기 전에는 코드를 이해하기도 어려운 문제**가 있다.
  * 다시 말해, 상속을 이용하여 코드를 재사용하려면 부모 클래스의 개발자가 세운 과정이나 추론 과정을 정확히 이해해야 한다.
* 앞서 다룬 바와 같이 **하나의 모듈이 다른 모듈에 대해 많은 지식을 갖고 있을수록 결합도는 높아지며 변경은 어려워진다**.
* 때문에 **상속은 결합도를 높이며, 상속이 초래하는 부모 클래스와 자식 클래스 사이의 강한 결합은 코드를 수정하기 어렵게 만드는 요인**이 된다.
* 또한 부모 클래스의 메소드를 과도하게 재사용하는 경우, 부모 클래스가 수정되었을 때 자식 클래스에는 새로운 중복 코드가 추가될 가능성이 있다.

### 상속을 위한 경고
```
> 자식 클래스의 메소드에서 super 참조를 활용하여 부모 클래스의 메소드를 직접 호출하는 경우, 두 클래스는 강하게 결합된다.
> super 참조를 활용한 호출을 제거할 수 있는 방법을 찾아 불필요한 결합을 제거해야 한다.
```
* 상속을 활용하면 적은 노력으로 새로운 기능을 쉽고, 빠르게 추가할 수 있다.
  * **그러나 이로 인해 커다란 대가를 치뤄야할 수도 있다**.
* 상술한 바와 같이, **상속 관계로 연결된 자식 클래스가 부모 클래스의 변경에 취약해지는 현상은 취약한 기반 클래스 문제라는 용어로 정의**된다.
  * **취약한 기반 클래스 문제는 단순히 코드 재사용을 목적으로 상속을 사용한 경우에 발생하는 가장 대표적인 문제**이다. 

### 취약한 기반 클래스 문제
* 상속은 자식과 부모의 결합도를 높이며, 부모 클래스의 작은 변경에도 자식 클래스는 오류에 시달릴 수 있다.
* 취약한 기반 클래스 문제는 상속이라는 문맥 안에서 결합도가 초래하는 문제를 표현한다.
  * 상속 관계를 추가할수록 전체 시스템의 결합도는 높아지며 캡슐화는 약화된다.
  * 상속은 자식 클래스를 점진적으로 추가하여 기능을 확장하는 데에는 용이하지만, 높은 결합도로 인해 부모 클래스를 점차 개선하는 것은 어렵게 만든다.
* 객체를 사용하는 이유는 구현과 관련된 세부사항을 퍼블릭 인터페이스 뒤로 캡슐화할 수 있기 때문이다.
  * **캡슐화는 변경에 의한 파급 효과를 제어할 수 있기에 가치가 있으며, 변경될 수 있는 불안정한 요소를 캡슐화하여 내부를 자유롭게 변경할 수 있도록 한다**.
* **객체지향의 기반은 캡슐화를 활용한 변경의 통제이나, 상속은 코드의 재사용성을 높이기 위해 구현에 대한 결합도를 높여 객체지향의 강력함을 반감**시킨다.
  * **결합도란 다른 대상에 대해 알고 있는 지식의 양으로 결정되며, 상속은 기본적으로 부모의 내부 구현을 자식 클래스가 속속들이 알고 있도록 강요**한다.
* 객체지향의 핵심은 객체들의 협력이므로, 단순히 코드를 재사용하기 위해 불필요한 오퍼레이션이 자식 클래스의 인터페이스에 스며들도록 방치하지 않아야 한다.
  * 이는 Vector를 상속받는 Stack의 예시와 같이, 상속받은 부모 클래스의 메소드가 자식 클래스의 내부 구조에 대한 규칙을 깨트릴 수 있기 때문이다.
```
> 코드 재사용을 위한 상속은 부모 클래스와 자식 클래스를 매우 강하게 결합시킨다.
> 때문에 부모 클래스의 수정사항이 자식 클래스에도 반영되도록, 상속 계층도의 모든 클래스를 함께 수정해야 하는 상황이 빈번하게 발생한다.
> 클래스를 상속하면 결합도로 인해 상속 계층도의 모든 클래스의 구현을 영원히 변경하지 않거나, 매 번 함께 변경하는 수 밖에 없다.
```

### 추상화에 의존하기
* 상술한 **상속으로 인한 문제를 최소화하기 위해 사용되는 가장 일반적인 방법은 부모 클래스와 자식 클래스 모두가 추상화에 의존하도록 만드는 것**이다.
* 코드의 중복을 제거하기 위해 상속을 도입하려는 경우, 다음과 같은 두 가지 원칙을 따를 수 있다.
  1. 두 메소드가 유사하게 보인다면, 차이점을 별도의 메소드로 추출한다.
  2. 부모 클래스의 메소드를 하위로 내리는 것보다 자식 클래스의 추상적인 메소드를 상위로 올리도록 한다.

### 메소드의 차이를 별도의 메소드로 추출하기
* **중복 코드 안에서의 차이점을 별도의 메소드로 추출하는 것은 변하는 것으로부터 변하지 않는 것을 분리하는 원칙을 메소드 수준에서 적용한 것**이다.
  * 또는 변하는 부분을 찾아 캡슐화하는 원칙을 메소드 수준에서 적용한다.
* 각 클래스의 유사한 메소드의 내용 중 다른 동작을 수행하는 부분을 메소드로 추출하되, 각 클래스에 동일한 이름을 적용하도록 한다.

### 중복 코드를 부모 클래스로 올리기
* 상술한 과정에서 메소드의 차이를 동명의 메소드로 추출하는 데에 성공하였다면, 추상 부모 클래스를 추가하도록 한다.
  * **이 과정에서, 목표는 모든 클래스들이 추상화에 의존하도록 만드는 것**이다.
  * 또한, 코드의 중복이 존재하는 각 클래스가 새로 만든 추상 부모 클래스를 상속하도록 수정한다.
* 각 클래스의 공통 부분을 부모 클래스로 이동시키되, 인스턴스 변수보다 메소드를 먼저 이동하도록 한다.
  * 각 메소드에 필요한 인스턴스 변수는 컴파일 에러를 통해 자연스럽게 알 수 있으며, 이를 통해 불필요한 부분은 자식 클래스에 둔 상태를 유지할 수 있다.
* **각 클래스로부터 추출한 동명의 메소드는 메소드의 시그니쳐는 동일하지만 구현이 다르므로 부모 클래스의 protected 추상 메소드로 정의**한다.
* 이러한 과정을 통해 자식 클래스들 사이의 공통점을 부모 클래스로 옮길 수 있으며, 설계는 추상화에 의존하게 된다.

### 추상화를 통해 얻어지는 장점
* 공통 코드를 추상 부모 클래스에 성공적으로 옮긴 클래스들은 서로 다른 변경의 이유를 가지며, 단일 책임 원칙을 준수하게 되므로 응집도가 높다.
* 부모 클래스 역시 자신의 내부에 구현된 추상 메소드를 호출하므로 추상화에 의존하며, 자식 클래스는 추상 부모 클래스에 의존하므로 의존성 역전 원칙도 준수한다.
* 또한 추상 부모 클래스를 상속하는 자식 클래스를 추가하는 것으로 새로운 기능을 간단하게 추가할 수 있으므로, 개방 폐쇄 원칙도 준수한다.
* **상술한 모든 장점은 클래스들이 추상화에 의존하는 덕분이며, 상속 계층에서 추상화를 찾아내고 상속 계층의 모든 클래스가 추상화에 의존하도록 리팩토링** 한다.
```
> 코드 재사용을 위해 상속을 사용하는 대신, 클래스 별 차이점을 메소드로 추출하되 공통 부분을 추상 부모 클래스로 이동시키는 것이 바람직하다.
> 좋은 상속 계층을 구성하기 위해서는 상속 계층 안에 속한 클래스들이 구현보다는 추상화에 의존하도록 정의해야 한다.
```

### 인스턴스 변수를 추가하는 수정사항
* 클래스는 메소드 뿐만 아니라 인스턴스 변수도 포함하며, 수정사항에 따라서는 새로운 인스턴스 변수가 추상 부모 클래스에 추가될 수도 있다.
* 자식 클래스는 자신의 인스턴스를 생성하는 과정에서 부모 클래스에 정의된 인스턴스 변수를 초기화한다.
  * 따라서, 이 경우에는 부모 클래스에 추가된 공통의 인스턴스 변수가 자식 클래스의 초기화 로직에 영향을 주게 된다.
* **책임을 아무리 잘 분리했더라도 인스턴스 변수의 추가는 상속 계층 전반에 걸친 변경을 유발할 가능성이 있다**.
  * 그러나 각 클래스에 동일한 코드를 작성하는 것보다 인스턴스 초기화 로직을 일괄 변경하는 것이 더 현명한 선택이다.
* **객체 생성 로직의 변경은 유연하게 대응할 수 있으므로, 객체 생성 로직에 대한 변경을 덮어놓고 막기보다는 핵심 로직의 중복을 막는 데에 집중**한다.
* 즉, **상속으로 인한 클래스 사이의 결합을 완전히 피할 수 있는 방법은 없다**.
  * 상속은 어떤 방식으로든 부모와 자식을 결합시킨다.
  * **메소드 구현에 대한 결합은 추상 메소드를 활용하여 완화할 수 있으나, 인스턴스 변수에 대한 결합을 제거하는 방법은 없다**.
```
> 상속을 사용하는 개발자가 원하는 것은 수정사항을 반영하기 위해 인스턴스 변수를 추가하더라도 상속 계층 전반에 부작용이 퍼지지 않도록 하는 것이다.
```

### 차이에 의한 프로그래밍
* 상속을 활용하면 이미 작성된 클래스의 코드를 기반으로 다른 부분을 구현하여 새로운 기능을 쉽고 빠르게 추가할 수 있다.
* 차이에 의한 프로그래밍이란, 이렇듯 기존 코드와 다른 부분만을 추가하여 기능을 확장하는 방법이다.
* 차이에 의한 프로그래밍의 목표는 중복 코드를 제거하고 코드를 재사용하는 데에 있다.
  * 프로그래밍 분야에서, 중복 코드는 악의 근원이므로 중복 코드를 제거하기 위해 최대한 코드를 재사용해야 한다.
  * 즉, **중복 코드의 제거와 코드 재사용은 동일한 행동을 가리키는 서로 다른 단어**이다.
* 코드의 재사용은 단순히 귀찮음을 덜어주는 문제가 아니며, 안정적인 코드를 재사용하는 것으로 코드의 품질을 유지하는 동시에 노력과 테스트를 줄여준다.
* **객체지향의 세계에서 중복 코드를 제거하는 가장 간단하고 강력한 방법은 상속이지만, 강력한 만큼 오용됐을 경우에 돌아오는 피해도 크다**.
* 상속의 오용과 남용은 애플리케이션을 복잡하게 하고, 확장을 어렵게 하는 걸림돌이 된다.
* **상속은 코드 재사용과 관련된 대부분의 경우에 가장 좋은 해결 방법이 될 수 없다**.
  * 상속은 반드시 필요한 경우에만 숙고한 후 적용하도록 한다.
```
> 상속의 단점을 피하고 코드를 쉽게 재사용하는 더 좋은 방법은 바로 합성이다.
```
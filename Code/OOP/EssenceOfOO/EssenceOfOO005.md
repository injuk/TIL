# EssenceOfObject-Orientation
## 2022-12-20 Tue

### 책임과 자율적인 객체
```
> 훌륭한 객체지향의 세계는 명확하게 정의된 역할과 책임을 지닌 객체들이 상호 협력하는 세계이다.
```
* **객체지향 애플리케이션 속의 공동체를 구성하는 기본적인 단위는 `자율적인 객체`**이다.
  * 이러한 객체들은 애플리케이션의 기능 구현을 위해 협력하고, 협력 과정에서 각자의 책임을 다하기 위해 자율적으로 판단하고 행동해야 한다.
* 이 때, **중요한 것은 자율성으로 자율적인 객체는 스스로 정한 원칙에 따라 판단하고 스스로의 의지를 기반으로 행동**한다.
* 앞서 다룬 바와 같이, **객체가 어떠한 행동을 시작하는 유일한 이유는 다른 객체로부터 요청을 수신한 경우뿐**이다.
  * 이렇듯 **다른 객체로부터의 요청을 처리하기 위해 각각의 객체가 수행하는 행동은 책임이라고 지칭**할 수 있다.
  * 즉, **자율적인 객체는 스스로의 의지와 판단에 따라 자신이 맡은 바 책임을 수행하는 객체를 의미**한다.
* 객체지향 애플리케이션의 설계 과정에서, 아름다움은 다음과 같이 적절한 책임을 올바른 객체에게 할당하는 과정에서 나타난다.
  1. 임의의 객체에게 협력에 참여하기 위해 필수적인 적절한 책임을 할당한다.
  2. 이렇게 **할당된 적절한 책임은 객체를 자율적인 객체로 발돋움**할 수 있도록 돕는다.
  3. 결과적으로, 이러한 **자율적인 객체들이 모여 유연하고 단순화된 협력**을 낳게 된다.
* 상술한 내용을 토대로, **애플리케이션의 품질은 협력에 참여하는 객체의 자율성에 따라 결정되는 것을 이해**할 수 있다.

### 자율적인 책임
```
> 객체가 책임을 자율적으로 수행하기 위해서는 우선 객체에게 할당된 책임 자체가 자율적이어야 한다.
```
* 임의의 객체가 다른 객체에게 무언가를 요청하는 경우, 요청 자체가 책임을 암시하므로 수신 객체는 책임을 지게 된다.
* 이 때, 요청자 객체의 요청은 다음과 같이 분류될 수 있다.
  1. 추상적인 요청: **요청에 응답할 수만 있으면 세부 사항을 신경쓰지 않으며, 결과를 얻을 수만 있다면 나머지는 수신 객체의 의지와 판단**에 맡긴다.
  2. 구체적인 요청: **수신 객체가 요청에 응답하는 절차를 세세하게 지시하므로, 수신 객체는 요청 객체에게 의존**하게 된다.
* 이렇듯 **지나치게 구체적인 요청은 비록 협력의 결과는 도출할 수 있을지 몰라도 수신 객체의 자유를 지나치게 제한하게 된다는 단점이 존재**한다.
  * 반면, **추상적인 요청은 수신 객체가 요청을 처리하는 과정에서 무한에 가까운 자유를 보장**한다.
* **요청으로 암시되는 책임은 그 자체로 수신 객체의 자율성을 충분히 보장할 수 있을 정도로 포괄적이면서도 추상적인 것이 바람직**하다.
  * 예를 들어, 이러한 **요청은 수신 객체가 해야할 일을 명확히 지시하면서도 그 세부 사항에는 자율성을 보장할 수 있어야 한다**.
* **이상적인 객체지향 세계는 자율적인 객체들의 공동체로 구성되며, 자율적인 객체를 만들기 위해 객체에게 할당되는 책임의 수준 역시 자율적인 것이 바람직**하다.
* 또한, **자율적인 책임은 수신 객체가 요청을 어떻게 처리하는 지가 아닌 무엇을 해야하는지 설명**한다.

### 과도하게 추상적인 책임
* **포괄적이고 추상적인 책임이 항상 좋은 것은 아니며, 오히려 책임은 협력의 의도를 명확하게 표현할 수 있는 것이 전제**되어야 한다.
* 구체적인 책임에 비해 추상적이고 포괄적인 책임은 협력을 다양한 환경에서 재사용할 수 있도록 유연성을 부여한다.
  * 그러나 **책임은 객체가 협력에 참여하는 의도를 명확히 설명할 수 있는 수준에서 추상적일 수 있어야 한다**.
  * 즉, **좋은 책임은 수신 객체의 자율성을 보장할 수 있을 정도로 추상적이면서도 협력의 의도를 뚜렷하게 표현할 수 있을 정도로 구체적**이어야 한다.
* **어떤 책임이 가장 적절한가는 설계 중인 협력에 따라 달라질 수 있으며**, 이러한 모호함은 객체지향 애플리케이션의 설계를 난해하면서도 매력적으로 만든다.
  * 이러한 모호함을 해결하기 위해서는 성급한 일반화의 오류를 지양하고, 현재 문맥에 가장 적절한 책임을 선택하는 안목을 기를 수 있어야 한다.

### 책임과 메시지의 관계
* **책임이라는 말 속에는 어떠한 행동을 수행한다는 의미가 포함**된다.
  * 반면, **객체지향의 세계에서 객체는 반드시 어떠한 요청을 수신하는 경우에만 행동을 시작**할 수 있다.
  * 또한, **객체가 다른 객체에게 접근할 수 있는 유일한 방법은 메시지를 전송하는 것 뿐**이다. 
* 상술한 내용을 토대로, 객체가 자신에게 할당된 책임을 수행하도록 유발하는 것은 오로지 외부에서부터 전달되는 요청인 메시지가 된다.
  * 이렇듯 **메시지는 객체로 하여금 책임, 즉 행동을 수행하도록 요청하는 유일한 방법에 해당**한다.

### 메시지란?
```
> 메시지 송신자는 메시지를 통해서만 다른 객체의 책임을 요청할 수 있고, 수신자는 메시지 수신을 통해서만 자신의 책임을 수행할 수 있다.
```
* 하나의 객체는 메시지를 전송하는 것으로 다른 객체와 협력할 수 있으며, 이렇듯 객체의 행동을 유발하는 행위를 메시지 전송이라고 지칭한다.
* 이 때, 메시지는 다음과 같은 구성 요소로 이루어진다.
  1. 메시지 이름: `이동하라`와 같이, 메시지 자체를 가리킨다.
  2. 메시지 인자: 메시지를 전송할 때 추가적인 정보를 인자의 형태로 제공할 수 있으며, 수신자는 메시지를 처리하기 위해 인자를 사용할 수 있다.
* **메시지를 수신하는 수신자까지 포함할 경우, 메시지 전송은 결국 수신자와 메시지의 조합**이 된다.
  * 이러한 **수신자와 메시지 이름, 그리고 인자를 `객체.이동하라(마당)`과 같이 나열할 경우 메시지 전송**이 된다.
  * 물론 **메시지 전송의에 형태는 사용하는 언어에 따라 달라질 수 있으나, 중요한 것은 메시지 전송이 수신자와 메시지 이름 및 인자로 구성된다는 사실**이다.
* **메시지를 수신하는 객체는 우선 자신이 해당 메시지를 처리할 수 있는지 확인하며, 메시지를 처리할 수 있다는 것은 곧 행동을 수행할 책임과 연결**된다.
  * 즉, 어떤 객체가 임의의 메시지를 처리할 수 있다면 해당 객체는 그 메시지에 걸맞는 행동을 수행할 책임이 있다.
  * 이렇듯 **근본적으로 메시지의 개념은 책임의 개념과 직접적으로 연결되며, 객체가 수신할 수 있는 메시지의 형태는 객체가 수행할 책임의 형태를 결정**한다.
* 이렇듯 메시지는 객체들이 협력하기 위해 사용할 수 있는 유일한 의사소통 수단이며, 메시지를 수신한다는 것은 곧 객체가 해당 책임을 수행할 수 있음을 의미한다.
  * 이 때, 객체는 메시지를 처리하는 방법을 자율적으로 선택할 수 있다.

### 메시지를 활용한 객체의 외부 및 내부 분리
* 객체가 메시지의 형태를 변경하지 않는 경우, 책임을 수행하는 방법을 변경하더라도 메시지 송신자는 이를 알 수 없다.
  * 이는 **즉 객체의 외부와 내부는 메시지를 기준으로 분리된다는 것을 암시**한다.
  * **객체가 제공하는 메시지는 외부의 다른 객체가 볼 수 있는 공적인 영역인 반면, 객체가 메시지 처리를 위해 책임을 수행하는 방법은 사적인 영역**에 속한다.
* 이렇듯 **어떤 객체에 대해 외부의 객체는 오로지 공적으로 공개된 메시지만 확인할 수 있는 반면, 내부 영역은 볼 수 없으므로 객체의 외부와 내부는 분리**된다. 

## 2022-12-21 Wed
### 메소드란?
* 상술했듯, **객체가 외부로부터 수신할 수 있는 메시지와 메시지를 처리하기 위해 객체가 자율적으로 선택하는 방법은 별개의 개념**으로 볼 수 있다.
  * 이 때, **객체가 메시지를 처리하기 위해 내부적으로 선택하는 방법을 가리켜 메소드라고 지칭**한다.
* 객체는 메시지를 수신할 경우, 다음과 같은 흐름에 따라 요청을 처리한다.
  1. **메시지를 수신한 객체는 우선 자신이 해당 메시지를 처리할 수 있는지 확인**한다.
  2. **메시지를 처리할 수 있는 경우, 책임을 다하기 위해 메시지를 처리할 수 있는 방법인 메소드를 선택**한다.
  3. 객체지향 프로그래밍 언어에서 클래스 안에 포함된 함수 또는 프로시저인 메소드를 실행하여 요청을 처리한다.
* **메시지는 외부로부터 수신되지만 메소드는 내부적으로 선택된다는 점에서 차이가 있기 때문에, 메시지는 어떻게 요청을 수행해야할지 명시하지 않는다**.
  * **메시지는 단지 무엇이 실행되기 원하는지만을 명시하며, 요청을 어떤 방식으로(= 메소드로) 처리할지 결정하는 것은 전적으로 수신 객체의 결정에 따른다**.
* 이렇듯 **메시지를 수신한 객체가 런타임에서 메소드를 선택할 수 있다는 것은 다른 프로그래밍 언어와 객체지향 언어를 구분하는 핵심적인 특징 중 하나**가 된다.
  * 반면, 절차적 언어의 경우 프로시저 호출에 대한 실행 코드를 컴파일 타임에 결정한다. 

### 책임, 메시지, 메소드
* 객체지향 언어에서, 행동은 대응되는 책임을 갖는 객체에게 전송된 메시지로 유발된다.
* 메시지는 행동에 대한 요청만을 표현하며, 행동에 필요할만한 추가 정보는 인자로 전달하되 어떻게 수행할지 서술하지는 않는다.
* **메시지를 수신하는 수신 객체는 해당 메시지를 수신하는 것으로 해당 행동에 대한 책임을 인정하며, 이를 수행하기 위해 적절한 메소드를 선택하여 실행**한다.

### 다형성이란?
```
> 다형성이란, 서로 다른 유형의 객체가 동일한 메시지에 대해 서로 다른 방식으로 요청을 처리하는 것을 의미한다.
> 더 구체적으로, 서로 다른 타입에 속한 객체가 동일한 메시지를 수신할 경우 해당 메시지를 저마다 다른 메소드를 활용하여 처리할 수 있는 메커니즘을 의미한다.
```
* 메시지와 메소드의 차이에서 보았을 때, 메시지 처리 방식에는 어떠한 제약도 존재하지 않으므로 동일한 메시지에 대해 서로 다른 방식의 메소드를 적용할 수 있다.
  * 이렇듯 **다형성은 하나의 메시지와 하나 이상의 메소드 간의 관계로 이해**할 수 있다.
  * 즉, **다형성은 동일한 메시지를 처리하는 방법은 메시지를 수신하는 수신 객체의 종류에 따라 달라질 수 있는 기반**이 된다.

### 메시지 송신자와 다형성
```
> 수신 객체가 어떤 메소드를 통해서 메시지를 처리했던 간에, 메시지 송신자의 관점에서는 수신자가 책임을 수행했다는 점에서 동일하다.
```
* **다형성은 역할과 책임 및 협력과 깊은 관련이 있으며, 서로 다른 객체들이 다형성을 만족시키는 것은 곧 객체들이 동일한 책임을 공유하는 것을 의미**한다.
* **다형성에서 중요한 것은 송신자의 관점이며, 메시지 수신자들이 동일한 오퍼레이션을 서로 다른 방식으로 처리했더라도 이들은 동일한 책임을 수행한 것**과 같다.
  * 즉, 송신자 관점에서는 다형적인 수신자들이 자신의 요청을 수행할 책임을 지닌다는 점만 알면 이들을 굳이 구별할 필요가 없다.
  * 이렇듯 **다형성은 송신자 관점에서 동일한 역할을 수행하는 다양한 타입의 객체와 유연하게 협력할 수도록 하는 근간**이 된다.
  * 송신자 객체의 입장에서, 수신 객체의 실제 타입이 무엇이 되었던 간에 자신의 메시지를 처리할 수만 있다는 사실만이 중요하다.
  * 나아가, **송신자 관점에서 같은 역할을 수행하는 수신 객체는 모두 동일하게 취급**될 수 있다.
* **다형성은 동일한 역할을 수행하는 객체들 사이의 대체 가능성을 의미하며, 이들은 모두 동일한 송신자 메시지를 처리할 수 있기 때문에 대체 가능**하다.
* 이렇듯 **다형성은 수신자의 종류를 캡슐화하면서도 대체 가능성을 활용하여 설계의 유연성과 재사용성을 높여줄 수 있다**.
  * 때문에 메시지 송신자 객체는 자신에게 필요한 역할을 수행할 수 있는 객체라면 누구와도 협력이 가능하며, 심지어 미래에 추가될 객체도 예외가 아니다.

### 다형성과 객체지향의 강력함
```
> 다형성은 수신자와 송신자 간의 객체 타입 결합도를 메시지 수준의 결합도로 낮춤으로써 달성된다.
```
* 상술한 바와 같이, **객제지향이 유연하고 확장 가능하면서도 재사용성이 높은 배경에는 다형성이라는 개념이 존재**한다.
* 다형성을 통해 메시지를 이해할 수 있는 어떤 객체와도 협력할 수 있는 유연하고 확장성 있는 구조를 설계할 수 있으며, 이는 곧 객체지향이 강력한 이유이기도 하다.

### 유연하고 확장성 있으면서도 재사용성이 높은 협력
* 다형성을 활용하면 메시지 송신자 객체는 오직 수신자 객체가 메시지를 이해할 수 있다는 사실만 알고 있는 상태에서 협력에 참여하게 된다.
  * 즉, **송신자가 수신자에 대해 적은 정보만 알고 있는 상태에서도 상호 협력이 가능**하다.
* 이렇듯 적은 정보만으로 상호 협력이 가능한 환경은 다음과 같이 설계 품질에 큰 영향을 준다.
  1. 유연한 협력: 송신자는 수신자에 대해 어떠한 가정도 하지 않으므로, 수신자를 다른 객체로 변경해도 송신자는 이를 알아챌 수 없어 쉽게 변경이 가능하다.
  2. 높은 확장성: 송신자에게 아무런 영향을 주지 않은 상태에서 수신자를 교체할 수 있으므로, 협력의 세부적인 수행 방식을 쉽게 변경할 수 있다.
  3. 높은 재사용성: 협력에 영향을 주지 않는 선에서 다양한 객체들이 수신 객체를 대체할 수 있으므로, 다양한 문맥에서 협력을 재사용할 수 있다.
* **객체지향 애플리케이션은 동적으로 협력하는 객체들의 연결망으로서 필요한 객체를 생성하고, 상호 간 메시지를 송수신할 수 있도록 조합하는 것으로 구축**된다.
  * 때문에 **애플리케이션의 행위는 객체들의 조합을 선택하는 것으로 창발되는 속성**이 된다.
  * 이러한 **객체의 조합은 변경을 통해 시스템의 행위를 변경하도록 하며, 객체가 어떻게 할 것인가보다 무엇을 해야하는지에 초점을 맞출수록 변경은 쉽다**.

### 메시지를 활용한 송신자와 수신자 간의 느슨한 결합
```
> 설계의 유연성과 확장 가능성 및 재사용성을 높이는 비결은 메시지로 인한 낮은 결합도이므로, 설계의 품질을 높이기 위해서는 좋은 메시지를 선택해야 한다.
```
* 상술한 **다형성의 축복은 기본적으로 메시지가 존재하기 때문에 주어진 것으로, 메시지는 송신자와 수신자 간의 결합도를 낮춰주는 중요한 역할을 수행**한다.
  * 또한, 이렇게 낮춰진 결합도는 자연스레 유연한 설계와 확장 가능성 및 높은 재사용성으로 이어진다.
* **송신자는 오직 메시지만을 바라보며, 수신자 객체의 정확한 타입을 모르더라도 단지 수신자가 메시지를 이해하고 처리해줄 것이라는 사실만 알아도 무방**하다.
  * 반면, **수신자는 메시지를 처리하기 위한 메소드를 자율적으로 선택하지만 메소드 자체를 송신자에게 노출하지는 않는다**.
* 이렇듯 **송신자와 수신자는 메시지를 기반으로 느슨하게 결합되며, 이러한 낮은 결합도가 곧 설계의 유연성과 확장 가능성 및 재사용성을 높이는 비결**이다.

## 2022-12-22 Thu
### 객체지향의 핵심으로서의 메시지
```
> 객체지향으로의 전환은 애플리케이션을 정적인 클래스 집합이 아닌 메시지를 주고 받는 동적인 객체들의 집합으로 바라보는 것에서 시작한다.
```
* 객체지향의 기본 개념은 책임을 수행하는 자율적인 객체들의 협력으로 애플리케이션을 구축하는 것인 반면, 객체들이 협력할 유일한 수단은 메시지 전송이다.
  * 객체가 메시지를 수신하여 책임을 수행하고, 이 과정에서 다른 객체의 행위를 유발하는 연쇄적인 메시지 전송이 객체들 간의 협력 관계를 이끌어낸다.
  * 또한, **객체지향 애플리케이션의 핵심 사상은 이렇듯 연쇄적인 메시지 전송을 통해 사용자에게 유용한 기능을 제공하는 데에 있다**.
* **객체지향의 강력함은 클래스가 아닌 객체들 간의 메시지에서 나오며, 이러한 메시지는 객체들의 윤곽을 결정**한다.
  * 반면, 클래스에 초점을 맞추는 설계는 유연성과 확장성이 떨어지며 중요한 것은 객체이다.
  * 때문에 **클래스를 정의하는 것에 앞서 객체들의 속성과 행위를 식별하는 것이 반드시 우선**되어야 한다.
  * 이렇듯 **클래스에 담겨야 할 객체들의 공통 행위와 속성을 포착해내기 위해서는 우선 애플리케이션을 협력하는 객체들의 관점으로 바라볼 수 있어야 한다**.
* 또한, **진정한 객체지향 패러다임으로의 도약은 메시지를 주고 받는 객체들 사이의 소통에 초점을 맞출 때 시작**될 수 있다.
  * **가장 범하기 쉬운 실수는 객체 자체에 초점을 맞추어 협력이라는 문맥을 배제한 채 객체 내부의 데이터를 먼저 결정한 후에 오퍼레이션을 추가하는 것**이다.
  * 이렇듯 데이터를 중심으로 객체를 설계할 경우, 내부로 캡슐화되어야 할 내부 구조가 객체의 정의에 공개된다.
  * 때문에 **다른 객체가 객체의 내부 구조에 마음대로 간섭할 수 있게 되며, 결과 객체의 자율성은 떨어지게 된다**.

### 메시지에 초점을 둔 객체지향 설계
* **중요한 것은 데이터에 대한 결정을 최대한 미루면서 객체의 행위를 고려하기 위해 객체를 협력이라는 문맥 안에서 생각하는 것**이다.
  * **객체가 사용되는 주된 이유는 어디까지나 객체가 다른 객체에게 필요한 행위를 제공하기 때문**일 수 밖에 없다.
  * 때문에 **협력 내에서 객체가 다른 객체에게 무엇을 제공하고 무엇을 얻어야하는지에 대한 관점에서 접근하는 경우에만 좋은 책임을 얻어낼 수 있게 된다**. 
  * 즉, **독립된 객체의 상태와 행위에 대해 고민하기보다 애플리케이션의 기능을 구현하기 위해 객체가 다른 객체에게 제공할 메시지를 고민하는 것이 바람직**하다.
* **좋은 객체지향 설계는 어떤 객체가 어떤 메시지를 전송할 수 있는지와, 어떤 객체가 어떤 메시지를 이해할 수 있는가에 초점을 두어 협력을 구성하는 것**이다.
  * 반면, 협력이라는 문맥을 배제하고 독립적인 객체에 대해 고민하는 것은 정적인 클래스에 초점을 두는 것과 다를 바가 없다.
* **객체지향 설계의 중심에는 언제나 메시지가 위치해야 하며, 객체가 메시지를 선택하는 것이 아니라 메시지가 객체를 선택하도록 해야 한다**.
  * 나아가, 메시지가 객체를 선택하도록 만들려면 반드시 메시지를 중심으로 협력을 설계해야 한다.

### 책임 주도 설계 돌아보기
* 상술한 바와 같이 객체는 자신에게 할당된 책임을 수행하기 위해 다른 객체와 협력하며, 이 과정에서 메시지를 전송한다.
* 때문에 객체지향 설계는 적절한 책임을 적절한 객체에게 할당해나가며 메시지를 기반으로 협력하는 객체들의 관계를 발견하는 과정이다.
  * 이 때, 책임을 완수하기 위해 협력하는 객체들을 통해 애플리케이션을 설계해나가는 방법을 책임 주도 설계라고 지칭한다.
  * 또한, 책임 주도 설계의 기본 아이디어는 객체들 간에 주고받는 메시지를 기반으로 적절한 역할과 책임 및 협력을 발견해내는 데에 있다.
* 책임 주도 설계는 크게 다음과 같은 흐름으로 진행된다.
  1. 애플리케이션의 기능을 하나의 커다란 책임으로 바라보는 것에서 시작한다.
  2. 애플리케이션의 책임을 수행하기 위해 협력 관계를 시작할 적절한 객체를 찾고, 이에 애플리케이션의 책임을 할당한다.
  3. **객체가 책임을 완수하기 위해 다른 객체의 도움이 필요해 보일 경우, 도움을 요청하기 위해 어떠한 메시지가 적절할지 결정**한다.
  4. 메시지를 결정한 후, 메시지를 수신하기에 적절한 객체를 선택한다.
  5. **애플리케이션의 책임이 완전히 달성될 때까지 메시지를 주고받는 협력을 지속**한다.
* 이 때, 메시지 수신 객체는 송신자의 기대를 충족시키기 위해서 수신한 메시지를 처리할 책임이 있다.
  * 때문에 **결과적으로는 메시지가 수신자의 책임을 결정하게 되며, 이 과정에서 자신의 책임을 완수하기 위해 다른 객체에게 도움을 요청**할 수 있다.

### what / who 사이클
```
> 객체가 어떤 메시지를 수신하고 처리할 수 있는지에 따라 객체의 책임이 결정된다.
> 또한, 책임 주도 설계에서는 what / who 사이클에 따라 협력에 필요한 메시지를 결정한 후에 이에 적합한 객체를 결정한다.
```
* 책임 주도 설계의 핵심은 어떤 행위가 필요한지 결정한 후에 행위를 수행하는 객체를 결정하는 것이며, 이를 what / who 사이클이라고 지칭할 수 있다.
  * 해당 사이클의 의미에서 알 수 있듯, 객체 간의 협력을 설계하기 위해서는 어떤 행위를 결정할지 우선 결정한 후에 누가 그 행위를 수행할지 결정한다.
  * 이 때, 수행할 **어떤 행위 자체가 객체들이 서로 주고 받는 메시지**가 된다.
* 이렇듯 객체의 행위를 결정하는 것은 객체가 갖는 속성이 아니며, 항상 행위를 우선 식별한 후에 이에 적합한 객체를 찾는 방식으로 책임 주도 설계가 진행된다.
  * 때문에 **책임 주도 설계에서는 항상 협력이라는 문맥 안에서 필요한 메시지를 우선 결정한 후에 메시지를 수신하기에 적합한 객체를 찾게 된다**.
  * 즉, **결론적으로 협력이라는 문맥 안에서 객체의 책임을 결정하는 것은 메시지**가 된다.
  * 책임이 먼저 결정된 후에 객체가 책임을 따르게 되며, 이러한 과정에서 애플리케이션이 수행해야 할 전체 행위는 협력하는 객체들의 책임으로 분할된다.
* 각 **객체가 수신할 수 있는 메시지가 모여 객체의 인터페이스를 구성하게 되므로, 메시지를 먼저 결정하는 것으로 객체의 인터페이스를 발견**할 수 있게 된다.
  * 이러한 메시지를 활용한 인터페이스의 발견은 테스트 주도 설계 방법론을 활용하여 객체를 설계할 때의 핵심 아이디어가 되기도 한다. 

## 2022-12-23 Fri
### 묻지 말고 시키기
```
> 묻지 않고 시키는 방식은 객체를 자율적으로 만들면서도 캡슐화를 보장하고, 나아가 결합도를 낮게 유지시키기에 설계를 유연하게 한다.
```
* 메시지를 우선 결정하고 객체가 결정된 메시지를 따르도록 하는 설계 방식은 객체가 외부에 제공하는 인터페이스가 독특한 스타일을 따르도록 한다.
  * 이 때, 이러한 스타일을 묻지 말고 시키기 스타일 또는 디미터 법칙이라고 지칭한다.
* **책임 주도 설계는 객체들이 아닌 객체들이 주고받는 메시지에 초점을 맞추는 것으로 객체지향의 강점을 극대화**한다.
  * 예를 들어, 메시지를 결정하는 시점에는 어떤 객체가 메시지를 처리할지 알 수 없으므로 메시지 송신자는 수신자의 내부를 알 수 없다.
  * 때문에 **메시지 중심 설계는 메시지 수신자의 캡슐화를 강화하며, 송신자와 수신자를 느슨하게 결합시키는 효과**가 있다.
* 송신자는 수신자가 어떤 객체인지 알 수 없으므로 세부 사항을 캐물을 수 없으며, 단지 수신자가 메시지를 잘 처리할 것이라고 믿고 전송할 수 밖에 없다.
  * 정확히 이러한 스타일의 협력 패턴을 묻지 말고 시키기 라는 이름으로 지칭한다.
* 또한, **묻지 말고 시키기 스타일은 객체지향 애플리케이션이 자율적인 객체들의 공동체라는 사실을 강조**한다.
  * **객체는 다른 객체의 결정에 간섭하지 않아야 하며, 모든 객체는 오로지 자신의 상태를 기반으로 해서만 결정을 내리는 것이 바람직**하다.
  * 이러한 스타일은 **객체 자체가 아닌 메시지에 초점을 맞추는 것으로 수신 객체의 내부를 가정할 수 없도록 하며, 이로 인해 객체의 자율성을 보장**한다.
  * 때문에 **객체는 단지 필요한 메시지를 전송하기만 하고, 나머지의 메시지 처리 방법은 메시지를 수신하는 객체가 직접 결정할 수 있어야 한다**.

### 어떻게보다는 무엇을 강조하기
* **묻지 말고 시키기 스타일은 메시지가 어떻게 하는지 지시하는 것보다 무엇을 해야하는지 요청할 것을 강조하며, 이는 객체 인터페이스의 크기를 크게 줄인다**.
  * 이 때, **인터페이스의 크기가 작다는 것은 곧 외부에서 해당 객체에 의존할만한 포인트가 적어진다는 것**과 같다.
  * 이로 인해 **메시지 송신자와 수신자의 결합도는 낮아질 수 있으며, 나아가 설계를 더 유연하게 만들면서도 의도를 명확히 드러낼 수 있게 된다**.
* **중요한 것은 객체가 자신이 수신할 메시지를 결정하는 것보다 메시지가 협력에 필요한 객체를 발견하도록 만드는 것**이다.

### 메시지를 신뢰하기
```
> 메시지를 중심으로 설계된 구조는 유연하고 확장성이 높으며, 재사용 가능한 성향을 띈다.
```
* 객체지향 애플리케이션은 협력하는 객체들의 연결망이며, 전체는 메시지 송신 객체와 수신 객체를 연관시키는 과정을 통해 구축된다.
* **메시지를 전송하는 객체의 관점에서, 자신의 메시지를 수신하고 처리할 수만 있다면 수신 객체의 실체는 사실 중요하지 않다**.
  * 중요한 것은 메시지를 수신하는 객체가 메시지를 이해하고, 의도대로 요청을 처리할 수 있는지의 여부에 달린다.
  * 이렇듯 객체의 구체 타입과는 무관하게 전송된 메시질르 이해할 수 있는 객체들을 연결짓고 협력시키는 것은 유연하고 재사용성이 높은 설계로 이어진다.
* **수신 객체가 메시지를 이해할 수만 있다면, 다양한 타입의 객체를 협력 대상으로 자유롭게 교체할 수 있으므로 설계는 유연**해진다.
  * 이렇듯 **다양한 타입의 객체들이 동일한 협력에 참여할 수 있게 된다면, 보다 다양한 상황에서 협력을 재사용**할 수 있다.
* **재사용성과 확장성이 높은 객체지향 설계를 구축하는 핵심인 다형성은 개별 객체가 아닌 그들이 주고 받는 메시지에 초점을 맞출 때 그 위력을 발휘**한다.

### 인터페이스란?
```
> 일반적으로, 인터페이스란 어떠한 두 사물이 마주하는 경계에서 서로 상호작용할 수 있도록 이어주는 방법 또는 장치를 의미한다.
```
* 인터페이스는 둘 이상의 사물이 상호작용하는 경우라면 세상 어느 곳에나 존재한다.
  * 때문에 사람이건 사물이건 어떠한 대상과 상호작용하기 위해서는 그 대상이 제공하는 인터페이스의 사용 방법을 이해해야 한다.
* 또한, 일반적인 인터페이스는 다음과 같은 세 가지 특징을 갖는다.
  1. **인터페이스의 사용법을 익힌다면 내부 구조나 동작 방식을 모르더라도 쉽게 대상을 조작하거나 정보를 전달**할 수 있다.
  2. **인터페이스 자체는 변경하지 않더라도 단순히 내부 구성이나 동작 방식을 변경하는 것은 인터페이스 사용자에게 영향을 주지 않는다**.
  3. **인터페이스 너머의 실제 대상이 변경되었더라도 동일한 인터페이스를 제공한다면 아무런 문제 없이 상호작용을 이어나갈 수 있다**.
* 협력에 참여하는 객체 역시 이와 마찬가지이며, 인터페이스를 통해 다른 객체와 상호작용하므로 상술한 모든 특징을 갖는다.

### 메시지와 인터페이스의 관계
* **객체가 다른 객체와 상호작용할 수 있는 유일한 방법은 메시지 전송이므로, 객체의 인터페이스는 객체가 수신할 수 있는 메시지 목록으로 구성**된다.
* 때문에 **객체가 어떠한 메시지를 수신할 수 있는지가 객체가 제공하는 인터페이스 형태를 결정**하게 된다.

### 공용 인터페이스
```
> 객체지향의 세계에서 모든 상호작용은 메시지를 통해서만 진행되어야 하며, 이는 객체 자신과의 상호작용 역시 예외가 아니다.
```
* 인터페이스는 실제로는 외부에서 접근 가능하도록 공개된 인터페이스와, 객체 내부에서만 접근할 수 있는 숨겨진 인터페이스로 구분된다.
  * 이 때, **내부에서만 접근 가능한 인터페이스를 따로 구분할 수 있도록 외부에 공개된 인터페이스는 공용 인터페이스라고 지칭**한다.
* **공용 인터페이스와 내부 인터페이스는 모두 메시지 전송을 통해서만 접근할 수 있지만, 메시지 송신자가 다른 객체인지 객체 자신인지에 차이점**이 있다.
  * 이렇듯 **객체지향 패러다임 안에서는 객체 자신에게 스스로 뭔가를 요청하는 경우에도 메시지를 전송**해야 한다.
  * 상술한 바에 따라, **객체는 인터페이스를 통해 메시지가 수신되었을 때 필요한 책임을 자율적으로 수행**하게 된다.
* 객체는 요청에 응답하기 위한 인터페이스를 외부에 공개하므로, 객체가 협력에 참여하기 위해 수행하는 메시지는 객체의 공용 인터페이스 형태를 결정한다.
  * 이는 what / who 사이클과도 연관이 깊으며, **메시지를 우선 결정하고 적절한 객체를 결정하는 경우 메시지가 수신자의 인터페이스를 결정**할 수 밖에 없다.
* 이렇듯 **공용 인터페이스를 자극하여 책임을 수행하도록 하는 것은 객체에 전송되는 메시지이며, 책임은 곧 메시지 수신 객체가 수행해야 할 행동**이다.
  * 때문에 객체의 공용 인터페이스를 구성하는 것은 객체가 외부로부터 수신할 수 있는 메시지의 목록이 된다.

## 2022-12-24 Sat
### 중간 정리
```
> 객체지향의 강력함은 대부분 객체의 내부와 외부를 구분하는 데에서 나온다.
```
1. 협력에 참여하는 객체의 책임은 자율적이어야 하며, 객체는 자신의 의지와 판단으로 책임을 수행할 방법을 스스로 결정할 수 있어야 한다.
2. 객체의 인터페이스는 객체가 수신할 수 있는 메시지의 목록으로 구성되며, 객체가 메시지를 수신했을 때 객체의 책임이 수행된다.
3. 메소드는 메시지를 수신 시 책임을 수행하는 방법이며, 둘을 구분하는 것은 객체의 내부 및 외부를 명확하게 분리하면서도 다형성을 활용하는 유연성을 부과한다.
4. 인터페이스는 객체가 다른 객체와 협력하기 위한 접점에 해당하며, 메시지로 구성되는 공용 인터페이스는 객체의 내부 및 외부를 명확하게 분리한다.

### 객체지향적인 사고를 위한 세 가지 원칙
* 객체지향적인 사고 방식을 이해하기 위해서는 다음과 같은 세 원칙이 중요하다.
  1. 더 추상적인 인터페이스를 지향하기
  2. 최소 인터페이스를 지향하기
  3. **인터페이스와 구현 간에는 차이가 있다는 점을 인식**하기
* 첫 번째 원칙은 객체의 자율적인 책임과 연관이 있으며, 객체의 자율성을 위해 구체적인 인터페이스보다는 추상적인 인터페이스를 설계하는 것이 바람직하다.
* 두 번째 원칙은 **외부에서 사용할 필요 없는 인터페이스는 노출하지 않을 것을 강조하며, 이를 통해 객체 외부에 노출되는 내부 관련 정보를 최소화**할 수 있다.
  * 이 때, **최소 인터페이스 원칙은 메시지를 우선 결정하고 객체를 이후에 결정하는 책임 주도 설계 방식을 따르는 것으로 쉽게 달성**할 수 있다.
  * 이 경우, 객체는 실제로 협력에 사용할 메시지 이외의 불필요한 메시지를 공용 인터페이스에 포함하지 않게 된다.
  * 반면, **협력이라는 문맥을 고려하지 않고 객체에만 초점을 맞추는 방식은 불필요한 메시지가 공용 인터페이스에 포함되는 것을 방지할 수 없다**.

### 구현이란?
* 객체지향적인 사고를 위한 세 번째 원칙에서, **객체의 외부에 드러나는 책임 목록을 공용 인터페이스라고 한다면 이외의 모든 것을 구현이라고 지칭**할 수 있다.
  * 예를 들어, 객체의 상태를 표현하는 방법 또는 메시지를 수신했을 때 실행할 메시지 처리 방법인 행동은 객체의 구현에 포함된다.
  * 특히, 메시지 처리 방법을 메소드라고 지칭할 때 메소드를 구성하는 코드 자체는 외부에 노출되는 공용 인터페이스의 일부가 아니므로 구현에 포함된다.
* 이러한 이유에서, **객체의 외부와 내부를 분리하는 것은 곧 객체의 공용 인터페이스와 구현을 명확하게 분리하는 것**과 같다.

### 인터페이스와 구현의 분리
```
> 좋은 객체는 구현을 알지 못해도 인터페이스만으로 쉽게 상호작용할 수 있는 객체이다.
```
* **객체를 설계하는 경우, 객체의 외부에 노출되는 인터페이스와 객체의 내부에 숨겨질 구현은 명확히 분리되도록 고려**해야 한다.
  * 이 때, 이를 인터페이스와 구현 분리 원칙이라고 지칭할 수 있다.
* 즉, **객체 설계의 핵심은 객체를 외부에 공개되는 인터페이스와 내부에 감춰지는 구현이라는 두 개의 분리된 요소로 나누어 설계**하는 데에 있다.
  * 소프트웨어는 항상 변경되기 마련이므로, 변경에 대비하기 위한 생존 전략은 변경해도 좋은 안전 지대와 외부에 영향을 주는 위험 지대를 구분하는 것이다.
  * 이 때, 내부의 구현은 안전 지대에 해당하는 반면 외부의 공용 인터페이스는 위험 지대가 된다.
* 또한, **변경에 대한 안전 지대를 구분하는 것은 객체의 자율성을 높이는 데에도 기여**할 수 있다.
  * 자율적인 객체는 외부에 공개된 인터페이스와 관계 없이 메시지를 처리하기 위한 메소드를 직접 선택할 수 있어야 한다.
  * 즉, **외부에 영향을 주지 않으면서도 메소드를 자유로이 변경할 수 있어야 하므로 구현을 인터페이스 뒤로 숨기는 것은 객체의 자율성을 향상**시킬 수 있다.
* 객체가 가져야하는 상태와 메소드의 구현은 객체의 내부에 속하며, 이를 수정하더라도 객체의 외부에 영향을 주는 일이 생기지 않아야 한다.
  * 이에 따라 **객체의 외부에 영향을 줄 수 있는 변경은 객체의 공용 인터페이스를 수정할 때 뿐**이어야만 한다.
* **인터페이스와 구현 분리 원칙은 변경을 관리하기 위한 규칙이며, 송신자와 수신자가 구체적인 구현 대신 느슨한 인터페이스에 대해서만 결합될 것을 강조**한다.
  * 다시 말해 **변경될 만한 부분은 객체의 내부에 숨겨두어야 하며, 이 원칙을 수행하기 위한 설계 방법이 캡슐화에 해당**한다.

### 캡슐화란?
```
> 캡슐화란, 객체의 자율성을 온전히 보존하기 위해 구현을 외부로부터 숨기는 것이다.
```
* **객체는 상태와 행위를 함께 캡슐화하는 것으로 충분히 협력적이면서도 자율적인 존재가 될 수 있다**.
* 캡슐화는 또한 정보 은닉이라는 용어로 불리기도 하며, 객체지향의 세계에서 캡슐화는 다음과 같은 두 관점으로 사용될 수 있다.
  1. 상태와 행위의 캡슐화
  2. 사적 비밀의 캡슐화

### 상태와 행위를 캡슐화하기
* 객체는 상태와 행위의 조합이므로, 스스로 자신의 상태를 관리하면서 상태를 변경하고 외부 요청에 대해 응답할 수 있는 행동도 내부에서 함께 관리한다.
  * 즉, 객체는 상태와 행동을 하나의 단위로 묶어주는 자율적인 실체이다.
  * **이러한 관점에서의 캡슐화가 데이터 캡슐화에 해당**한다.
* **객체는 상태와 행위를 묶은 후 외부에서 접근될 행위만을 공용 인터페이스로 노출하므로, 데이터 캡슐화는 인터페이스와 구현을 분리하기 위한 전제 조건**이다.
  * 반면, **객체가 자율적이기 위해서는 상태를 스스로 관리할 수 있어야 하므로 데이터 캡슐화는 자율적인 객체를 만들기 위한 전제이기도 하다**.
* 프로그래밍 관점에서, 일반적으로 상태는 데이터로 구현되는 반면 행동은 프로세스로 구현된다.
  * **전통적인 개발 방법은 데이터와 프로세스를 엄격히 구분하지만, 객체지향의 세계에서는 둘을 객체라는 하나의 틀 안으로 묶어 객체 자율성을 보장**한다.
  * 즉, **데이터 캡슐화는 전통적인 개발 방법론과 객체지향 패러다임을 구분하는 가장 주요한 차이**가 된다.

## 2022-12-25 Sun
### 사적인 내용을 캡슐화하기
* 사람과 마찬가지로 객체 역시 개인적인 비밀이 노출되는 것을 꺼리므로, 외부 객체와 소통할 수 있는 고정된 경로인 공용 인터페이스만을 노출하는 것이 바람직하다.
  * 이러한 **캡슐화를 통해 상대적으로 변경이 빈번한 내부 구현과 관련된 세부 사항을 안정된 인터페이스 뒤로 숨길 수 있다**.
  * 즉, **객체의 공용 인터페이스는 외부에서 전송 가능한 메시지의 집합이며 오직 공용 인터페이스에 정의된 메시지를 통해서만 객체에 접근**할 수 있다.
  * 이렇듯 **객체는 캡슐화를 통해 공용 인터페이스를 경계로 최대한의 자율성을 보장받을 수 있게 된다**.
* 자율적인 객체는 공용 인터페이스를 수정하지 않는 이상 협력하는 객체들에게 영향을 주지 않고서도 내부의 구현을 자유롭게 수정할 수 있다.
  * 이는 인터페이스와 구현 분리 원칙과도 관련이 있으며, 구현을 변경할 때 외부 영향을 최소화하기 위해서는 외부 객체가 내부 구현에 의존하지 않아야 한다.
  * 즉, **외부 객체는 공용 인터페이스에만 의존해야 하고 세부 사항인 내부 구현에는 의존하지 않아야 한다**.

### 자율적인 객체 만들기
```
> 결국 객체를 자율적인 존재로 바라보는 것은 객체의 외부와 내부를 엄격하게 분리하는 것과 같다.
```
* **객체는 자신의 의지에 따라 변경하거나 조작할 수 있는 비밀인 객체의 내부와, 외부 객체가 의지하고 접근할 수 있는 공용 인터페이스인 외부를 갖는다**.
  * 때문에 어떠한 개념도 객체의 내부와 외부에 동시에 포함될 수는 없다.
* **객체지향이란 내부와 외부를 명확하게 구분하는 자율적인 객체들로 구성된 협력 공동체이며, 이러한 명확한 구분으로 인해 유연성과 재사용성이 높다**.
  * 이는 객체지향이 전통적인 개발 방법론에 비해 유연한 이유이기도 하므로, 객체의 외부와 내부를 명확히 구분할수록 설계는 단순해져 유연성이 높아진다.

### 협력의 품질과 책임의 자율성
```
> 객체지향의 강력함을 누리기 위한 출발은 책임을 자율적으로 만드는 것이며, 이는 전적으로 선택하는 메시지에 따라 결정된다.
```
* **다른 협력에 비해 이해하기 쉽고 변경에 유연한 경우, 그 협력의 설계가 더 좋다**고 볼 수 있다.
  * 이 때, **객체의 책임이 자율적일수록 협력은 이해하기 쉬워지면서도 유연하게 변경할 수 있으므로 책임의 자율성이 전체적인 협력의 설계 품질을 결정**한다.
* 자율적인 책임은 다음과 같은 이유에서 협력의 설계 품질을 높일 수 있다.
  1. 자율적인 책임은 협력을 단순화한다.
  2. 자율적인 책임은 객체의 외부와 내부를 명확하게 분리한다.
  3. 책임이 자율적일수록 책임을 수행하기 위한 구현이 변경되더라도 외부에는 영향을 주지 않는다.
  4. 자율적인 책임은 협력의 대상을 다양하게 선택할 수 있는 유연성을 제공한다.
  5. 자율적인 책임은 객체의 역할을 이해하기 쉽게 만들어줄 수 있다.
* **자율적인 책임은 세부적인 사항을 무시하면서 의도를 명확하게 한 문장으로 표현함으로써 협력을 단순화하여 책임을 적절히 추상화**한다.
* **객체의 외부와 내부가 분리될 경우 요청 객체가 알 필요 없는 세부 사항이 캡슐화되므로, 인터페이스와 구현은 분리**될 수 있다.
* **책임이 자율적일수록 변경에 의해 수정해야 할 범위가 좁고 명확해지며, 변경의 파급 효과는 객체 내부로 캡슐화되어 협력하는 객체 간의 결합도를 낮춘다**.
* **책임이 자율적일수록 협력은 더 유연해지고 다양한 문맥에서 재활용 가능해지므로, 설계의 유연성과 재사용성은 높아진다**.
* **책임이 자율적일수록 객체의 존재 의의를 명확히 표현할 수 있으며, 객체는 동일한 목적을 달성하기 위해 강하게 연관된 책임만을 가져 응집도가 높아진다**.
* 결국 자율적인 책임은 다음과 같은 효과를 누릴 수 있게 하는 것으로 객체지향을 다른 패러다임보다 우월하게 만들어준다.
  1. 책임은 적절히 추상화된다.
  2. 객체의 응집도는 높아지고, 객체 간 결합도는 낮아진다.
  3. 객체의 캡슐화가 증진되어 인터페이스와 구현이 명확하게 분리된다.
  4. 결과적으로 협력의 설계가 갖는 유연성과 재사용성은 높아진다.
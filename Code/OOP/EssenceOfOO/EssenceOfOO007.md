# EssenceOfObject-Orientation
## 2022-12-30 Fri

### 객체지향 설계와 관련된 세 관점
* 객체지향 설계 안에는 다음과 같은 세 가지 상호 연관된 관점이 존재한다고 볼 수 있다.
  1. 개념 관점: **사용자가 도메인을 바라보는 관점을 반영하며, 때문에 실제 도메인의 규칙과 제약을 최대한 유사하게 반영하는 것이 핵심**이다.
  2. 명세 관점: **개발자의 영역으로서 도메인이 아닌 소프트웨어 안에서 살아있는 객체들의 책임에 초점을 맞춘다**.
  3. 구현 관점: **개발자에게 가장 익숙한 관점이며, 객체의 책임을 어떻게 수행할지에 초점을 맞춘다**.
* 특히 **명세 관점의 경우, 개발자는 객체가 협력을 위해 무엇을 할 수 있는지에 초점을 맞추며 인터페이스와 구현을 분리**하게 된다.
  * 때문에 구현이 아닌 인터페이스에 대해 프로그래밍하라는 원칙은 우선 명세 관점과 구현 관점을 명확히 분리하는 데에서 시작한다.
* 구현 관점의 경우, 객체들이 책임을 수행하기 위해 필요한 동작하는 코드를 작성하며 인터페이스 구현을 위해 필요한 메소드를 클래스에 추가하게 된다.
* 이 때, **세 관점은 순차대로 진행되는 것은 전혀 아니며 오히려 동일한 클래스를 서로 다른 세 가지 관점으로부터 바라본다는 점을 의미**한다.
  * 이렇듯 클래스는 세 관점을 통해 설계와 관련된 다양한 측면을 드러낼 수 있다.
  * 예를 들어 **클래스 자체가 은유하는 개념은 도메인 관점을 반영하는 반면, 공용 인터페이스는 명세 관점을 반영하고 속성과 메소드가 구현 관점을 반영**한다.
* **이상적인 것은 클래스가 세 관점을 모두 수용할 수 있도록 개념과 인터페이스 및 구현을 함께 드러내는 데에 있다**.
  * 또한, **이와 동시에 코드 상에서는 세 관점이 쉽게 식별되도록 깔끔하게 분리되는 것이 바람직**하다.

### 명세 관점으로 객체를 바라보기
* 앞서 다룬 바와 같이, 역할과 책임 및 협력을 활용한 객체 인터페이스의 식별은 크게 다음과 같은 흐름으로 진행된다.
  1. 우선 협력에 참여할 객체가 수신해야만 할 메시지를 결정한다.
  2. 이러한 과정에서 **메시지들이 모여 객체의 인터페이스를 구성**한다.
  3. 결과적으로 메시지를 결정한 후에 이를 처리할 객체를 선택하게 된다.
* 나아가 **이러한 관점은 객체의 인터페이스, 즉 명세 관점에서 객체를 바라보는 데에 중점을 두는 것**과 같다.

### 도메인 분석하기
* 개발을 진행하기에 앞서, 우선 도메인을 구성하는 요소들을 분류하는 것은 큰 도움이 될 수 있다.
  * 이 때, 객체지향 패러다임의 주요한 도구는 객체이므로 우선 해당 도메인의 개념들을 객체들로 구성된 세상으로 바라보게 된다.
* 분류된 각 객체는 다른 객체와의 사이에서 크게 다음과 같은 관계를 가질 수 있다.
  1. 합성 관계: **임의의 객체가 다른 객체를 포함하여 하나의 단위로 취급되는 경우, 포함 관계 또는 합성 관계라고 지칭**한다.
  2. 연관 관계: **두 객체가 서로의 존재를 알고 있지만 서로를 포함하지 않는 관계를 의미**한다.
* 이 때, 합성 관계는 머리가 속이 꽉 찬 마름모로 표현된 실선으로 표현되는 반면 연관 관계는 일반적인 실선으로 표시된다.
  * 각 객체와 객체 간의 관계를 이러한 방식으로 표현할 경우, 객체들의 관계를 추상화하는 일종의 모델을 작성할 수 있다.
  * 이렇듯 **소프트웨어가 사용되는 영역인 도메인을 단순화하여 표현한 모델을 도메인 모델이라고 지칭**할 수 있다.
* 그러나 실제로는 도메인 모델을 작성하는 시점에서 반드시 모든 관계를 합성 또는 연관 관계로 분류할 필요는 없다.
  * 오히려 **핵심은 어떤 타입들이 도메인을 구성하고, 타입 간에 어떠한 관계가 존재하는지 파악하여 도메인을 이해하는 데에 있다**.
* 상술한 과정을 통해 도메인을 단순화하여 이해하는 데에 성공했다면, 협력하는 자율적인 객체들의 공동체를 창조하기 위해 협력을 설계하게 된다.
  * 이 때, 협력하는 객체들의 공동체를 만드는 과정에서는 적절한 객체에게 적절한 책임을 할당하는 것에 초점을 맞추게 된다.

## 2022-12-31 Sat
### 적절한 협력을 설계하기
```
> 객체지향의 첫 번째 목표는 훌륭한 객체를 설계하는 것이 아닌, 훌륭한 협력을 설계하는 데에 있다.
```
* **좋은 객체는 좋은 협력을 설계한 경우에만 얻을 수 있으며, 협력을 설계하는 과정에서는 메시지가 객체를 선택하는 것이 바람직**하다.
  * 즉, 메시지를 우선 선택한 후에 메시지를 수신하여 처리하기에 적합한 객체를 찾아나가는 순서로 설계하는 것은 양질의 협력을 얻을 수 있도록 하는 기반이 된다.
  * 이를 통해 **메시지 수신 객체는 메시지를 처리하기 위한 책임을 맡으며, 이러한 수신 메시지 목록은 객체가 외부에 제공하는 공용 인터페이스에 포함**된다.
* **메시지를 찾는 데에 성공한 경우, 그제서야 비로소 메시지를 처리하기에 적합한 객체를 도메인 모델 안에서 찾을 수 있다**.
  * 소프트웨어 상의 객체는 현실 객체의 은유로서 기능하는 반면, 은유에 적절한 소프트웨어 객체는 도메인 모델 안에서 찾을 수 있다.
  * 때문에 **적절한 객체를 찾기 위해서는 우선 도메인 모델 안에서 책임을 수행하기에 적절한 타입이 존재하는지 확인하는 것이 바람직**하다.
* 또한 **도메인 모델 안에서 책임을 수행하는 데에 적합한 타입을 발견한 경우, 객체는 해당 타입의 인스턴스로 정의**되어야 한다.
  * 이 과정에서 소프트웨어 객체가 현실 객체와 동일할 수는 없으나, 적어도 유사한 이름을 명명하는 것으로 소프트웨어 객체의 책임과 상태를 쉽게 추측할 수 있다.

### 협력 설계의 이상적인 흐름
1. 훌륭한 협력을 설계하는 것을 목표로 삼는다.
2. 요구사항을 만족하기 위한 첫 번째 메시지를 선택한다.
   * 이 과정에서 **선택된 메시지에는 인자와 반환 값을 미리 고려하여 별도로 표시해두어도 무방**하다.
3. 메시지를 처리하기에 적합한 타입을 도메인 모델에서 선택한다.
   * 이 때, 객체지향 세계의 모든 객체는 능동적이고 자율적인 존재이므로, 현실에서는 수동적인 객체도 객체지향의 세계에서는 능동적으로 판단하고 행동할 수 있다.
   * 결국 **소프트웨어 객체는 현실 객체를 은유하면서도 더 많은 일을 능동적으로 수행할 수 있는 반면, 은유를 통해 해당 객체의 행동을 쉽게 유추**할 수 있다.
   * 즉, **소프트웨어 객체는 현실의 객체를 모방하거나 추상화하는 것이 아니며 단지 의미를 유추하기 쉽도록 은유할 뿐**이다.
4. 3.의 과정에서 발견해낸 적절한 타입의 인스턴스인 객체를 선택한다.
   * **이 시점에 해당 객체는 메시지에 대한 책임을 할당**받게 된다.
5. **객체가 메시지를 처리하는 과정에서 혼자서는 할 수 없는 일이 있는지 확인하고, 다른 객체에게 이를 요청할지 결정**한다.
   * 이 경우에 **선택된 외부의 객체는 해당 작업에 대한 전문가이며, 요청을 처리하기 위해 필요한 지식과 행위를 각각 상태와 행동의 형태로 갖는다**.
6. 5.에서 **결정된 요청은 객체가 외부로 전송하는 메시지가 되며, 해당 메시지를 토대로 2. - 5.의 과정을 반복하며 협력을 완성해나간다**.
7. 6.까지의 과정을 통해 **협력에 필요한 객체의 종류와 책임 및 주고받는 모든 메시지에 대한 윤곽이 드러난 경우, 메시지를 가능한 한 상세하게 정제**한다.
   * 이렇듯 **메시지를 상세하게 정제하는 작업을 통해 각 객체의 인터페이스를 구현 가능할 정도로 이끌어낼 수 있다**.

### 객체의 인터페이스
* **객체가 수신하는 메시지는 곧 객체의 인터페이스를 결정하며, 메시지가 객체를 선택하는 과정에서 선택된 객체는 메시지를 자신의 인터페이스에 받아들인다**.
  * 즉, 객체가 메시지를 수신할 수 있다는 사실은 곧 객체의 인터페이스 안에 메시지에 대응되는 오퍼레이션이 존재한다는 것과 같다.
  * 이렇듯 **객체들이 수신하는 메시지는 결론적으로 객체의 인터페이스를 구성**하게 된다.
* **객체의 협력은 런타임에 소프트웨어에서 발생하는 상황을 동적으로 묘사한 모델인 반면, 소프트웨어의 실제 구현은 동적인 객체가 아닌 정적인 타입을 활용**한다.
  * 때문에 **객체들을 포괄하는 타입을 우선 정의한 후에 메시지를 통해 식별된 오퍼레이션을 타입 인터페이스에 추가**해주어야 한다.
* 예를 들어, 객체의 타입을 구현하는 일반적인 방법은 클래스를 활용하며 인터페이스에 포함된 오퍼레이션은 `public`으로 선언한다.
  * 이 과정에서 클래스의 인터페이스를 식별할 수 있으며, 이후에는 오퍼레이션의 수행 방법을 메소드로 정의하게 된다.

### 빠르게 구현을 시작하기
```
> 구현 없이 머릿 속에서만 구상한 설계는 대부분의 경우에 코드 구현 단계에서 변경된다.
```
* 설계 작업은 구현을 위한 스케치이며, 구현 그 자체일수는 없으므로 중요한 것은 설계보다는 코드일 수 있다.
* 때문에 **협력을 구상하는 단계에 너무 오랜 시간을 들이는 것보다는 최대한 빠르게 코드를 구현하고, 설계의 이상과 구현 가능성을 판단하는 것이 바람직**하다.
  * 즉, 코드를 활용한 피드백 없이는 깔끔한 설계를 얻을 수 없다!
* 예를 들어 객체의 속성은 구현 단계에 결정되는 경우가 많으며, 객체의 내부에 캡슐화되므로 인터페이스에는 객체의 내부에 대한 힌트가 제공되지 않아야 한다.
  * 이를 위해서 가장 **이상적인 방법은 인터페이스를 결정하는 단계에서는 객체의 속성 또는 속성이 사용하는 자료 구조를 전혀 고려하지 않는 것**이다.
  * 이렇듯 객체에게 책임을 할당하며 인터페이스를 결정하는 과정에서는 객체의 내부 구현에 대한 가정을 하지 않아야 하며, 책임을 결정한 후에 속성을 결정한다.
* 또한, **인터페이스는 객체들이 상호작용하는 통로이므로 실제 상호작용을 구현하기 전까지는 인터페이스를 정확히 예측하는 것은 불가능에 가깝다**.
  * 때문에 **설계는 최대한 간단히 끝낸 후 빠르게 구현에 돌입해야 하며, 설계가 잘 그려지지 않더라도 우선 코드를 작성하며 협력의 밑그림**을 다질 수 있다.

### 코드의 작성과 세 가지 관점
```
> 바람직한 코드는 개념과 명세, 구현 관점을 모두 포함하면서도 각 관점에 대응되는 요소를 명확하게 드러내야 한다.
```
* 개념 관점에서는 클래스가 도메인 개념의 특성을 최대한 수용하는 것으로 변경에 대한 유연성과 유지보수성을 향상시킬 수 있다.
  * 예를 들어, **소프트웨어 클래스와 도메인 클래스 사시의 간격이 좁을수록 기능을 변경하기 위해 살펴보아야 하는 코드의 양도 줄어들 수 있다**.
* **명세 관점은 클래스의 인터페이스를 바라보며, 객체의 인터페이스는 협력하는 모든 객체에게 영향을 주므로 수정이 어렵다는 사실에 주의하는 것이 바람직**하다.
  * 때문에 변화에 안정적인 인터페이스를 작성하기 위해서는 인터페이스에 구현과 관련된 세부 사항이 드러나지 않도록 해야 한다.
* 구현 관점은 클래스의 내부 구현을 바라보며, 메소드와 속성은 클래스 내부의 비밀로 캡슐화되어야 한다.
  * 메소드와 속성은 구현에 속하지 공용 인터페이스의 일부가 아니므로, 원칙적으로 메소드의 구현과 속성의 변경은 외부 객체에 영향을 주지 않아야 한다.
* 상술한 세 관점은 같은 코드를 바라보는 서로 다른 관점이며, 좋은 객체지향 개발자는 하나의 클래스 안에 세 관점을 모두 포함하면서도 각 요소를 명확히 드러낸다.
  * 바꿔 말해, **다른 개발자가 자신의 코드로부터 세 관점을 명확히 포착하지 못한다면 세 관점이 명확히 드러나도록 코드를 개선해야 한다**.
  * 또한, 이는 변경에 유연하게 대응할 수 있는 객체지향 코드를 작성하는 가장 빠른 길이기도 하다.

### 변경에 쉽게 대응하는 코드
```
> 설계는 변경을 위해 존재한다.
```
* **어떠한 메시지가 있을 때, 해당 메시지를 수신하는 객체는 개념의 관점에서 바라보기 쉽도록 도메인 개념 중 가장 적절한 것을 선택하는 것이 이상적**이다.
  * 도메인 개념 안에서 적절한 객체를 선택할 경우, 도메인에 대한 지식을 기반으로 코드의 구조와 의미를 쉽게 유추할 수 있어 애플리케이션의 유지보수성을 높인다.
* **소프트웨어는 항상 변해 가며, 여러 클래스로 코드를 분할하고 클래스 안에서 인터페이스와 구현을 분리하는 것은 곧 변경에 대응하기 쉽게 만들기 위함**과 같다.
  * 이 때, 소프트웨어 상의 클래스가 도메인 개념을 따른다면 변화에 쉽게 대응할 수 있다.

### 인터페이스와 구현은 반드시 분리하기
```
> 인터페이스와 구현은 분리되어야 한다.
```
* **명세 관점은 클래스의 안정적인 측면을 드러내는 반면, 구현 관점은 클래스의 불안정한 측면을 드러낸다**.
* **개념 관점과 명세 관점의 사이의 관계는 차치하더라도, 명세 관점과 구현 관점은 반드시 분리되어야 한다**.
  * 반면, 인터페이스가 구현의 세부 사항을 노출할수록 아주 작은 변동에도 전체 협력을 수정해야 하는 취약한 설계가 만들어지게 된다.
* **개발자의 입장에서 가장 많이 접하는 것은 구현 관점이지만, 실제로 훌륭한 설계를 결정하는 측면은 명세 관점인 객체의 인터페이스에 해당**한다.
  * 때문에 **명세 관점이 설계를 주도하게 할수록 설계의 품질은 향상**될 수 있다. 
* 또한 **중요한 것은 자신이 작성한 클래스로부터 명세 관점과 구현 관점이 명확히 드러나야한다는 점**에 있다.
  * 즉, 캡슐화를 위반하여 구현을 인터페이스 밖으로 노출하거나 두 개념을 명확하게 분리하지 않고 섞어두지 않아야 한다.
  * 결국, 세 관점 모두에서 클래스를 바라보기 위해서는 반드시 훌륭한 설계가 뒷받침되어야 한다.
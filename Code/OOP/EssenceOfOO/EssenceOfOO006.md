# EssenceOfObject-Orientation
## 2022-12-26 Mon

### 설계의 두 가지 측면
```
> 기능보다는 구조를 기반으로 모델을 구축하는 것이 더 범용적이면서도 이해하기 쉽고, 변경에 안정적이다.
```
* 모든 소프트웨어 제품의 설계는 기능 측면의 설계와 구조 측면의 설계가 존재한다.
  1. 기능 측면의 설계: 제품이 사용자를 위해 무엇을 할 수 있는지에 초점을 둔다.
  2. 구조 측면의 설계: 제품의 형태가 어떠해야하는지에 초점을 둔다.
* 이 때, **설계의 가장 큰 도전은 기능과 구조라는 두 측면을 하나로 녹여 조화를 이루도록 하는 데에 있다**.
* 일반적으로 소프트웨어가 사용자에게 가치 있는 이유는 사용자가 필요로 하는 기능을 제공하기 때문이므로, 개발 초기에는 사용자의 니즈에 초점을 두어야 한다. 
* 반면 **훌륭한 기능이 훌륭한 소프트웨어를 만드는 충분 조건이라면, 훌륭한 구조는 필요 조건에 해당**한다.
  * 성공적인 소프트웨어들은 공통적으로 훌륭한 기능을 제공하면서도, 사용자가 원하는 새로운 기능을 안정적으로 추가할 수 있다.
  * 때문에 **단순하고 깔끔하면서도 유지보수성이 높은 설계는 사용자의 변하는 요구사항을 반영할 수 있도록 확장성 높은 소프트웨어를 위한 기반이 되어준다**.

### 설계의 중요성
* **요구사항이 '절대로' 변하지 않는다면 설계는 중요하지 않고 나아가 개발자의 삶은 더 단순했을테지만, 변함 없는 것은 요구사항이 항상 변경된다는 사실**이다.
  * 즉, 설계 자체를 중요하게 만드는 것은 언젠가 다가올 변경에 대한 필요성이므로 변경에서 살아남을 수 있기 위해서는 좋은 설계를 이끌어내야 한다.
* 때문에 **좋은 설계자는 사용자가 만족할 훌륭한 기능을 제공하는 동시에 변경에 유연하게 대처할 수 있는 안정적인 구조를 제공할 수 있어야 한다**.
* 반면, **설계는 어제 결정된 기능을 제공하는 동시에 내일 변경될 가능성이 있는 요구사항을 수용할 수 있는 코드를 창조해야하기 때문에 어렵다**.
* 그러나 **개발자는 미래의 변경에 대비할 수는 있어도 에측할 수는 없으며, 불확실한 변경을 설계에 반영하는 것은 불필요하게 복잡한 설계만을 낳는다**.
  * 때문에 **미래에 대비하는 가장 좋은 방법은 변경을 예측하는 것이 아닌, 변경을 수용할 수 있는 여지를 설계에 반영하는 것**이다.
  * 좋은 설계자는 구체적으로 어떤 변경이 발생할지 감히 예측하지 않으며, 언젠가는 변경이 발생할 것이며 현재로서는 이를 알 수 없다는 사실을 받아들인다.

### 좋은 설계
```
> 좋은 설게는 미래에 다가올 변경사항에 대처할 수 있도록 변경될 수 있는 여지를 남겨두는 설계다.
```
* **설계의 목적은 나중에 설계하는 것 역시도 허용하는 것이며, 일차적인 목표는 변경에 소요되는 비용을 낮추는 데에 있다**.
  * 이 때, **변경의 여지를 남기는 가장 좋은 방법은 자주 변경되는 기능이 아닌 안정적인 구조를 중심으로 설계하는 것**이다.
* 전통적인 기능 분해 방법은 자주 변경되는 기능을 중심으로 설계한 후, 구조가 기능에 따르게 하므로 변경에 취약하다.
  * 반면, **객체지향 패러다임은 자주 변경되지 않는 안정적인 객체 구조를 바탕으로 시스템의 기능을 객체 간의 책임으로 분배**한다.
  * 즉, **객체지향은 객체의 구조에 집중한 후 기능이 객체 구조를 따르게 하므로 기능이 변경되더라도 객체 간의 구조는 유지**된다.
  * 이는 곧 객체를 기반으로 책임과 역할을 식별한 후 메시지를 기반으로 객체 간의 협력 관계를 구축하는 이유가 된다.
* 객체지향 패러다임에서, **안정적인 객체 구조는 변경을 수용할 수 있는 유연한 소프트웨어를 창조하기 위한 기반을 제공**할 수 있다.
  * 때문에 객체를 활용하여 구조를 한 번 견고히 해둔다면, 기능은 객체 간의 구조에 따라 자연스레 흘러갈 수 있게 된다. 
  
### 유즈케이스와 도메인
* 객체지향 세계를 구축하기 위해서는 다음과 같은 두 재료가 반드시 준비되어 있어야 한다.
  1. 기능: 사용자에게 제공할 기능이며, 사용자가 자신의 목표를 달성하기 위해 사용할 수 있는 애플리케이션의 서비스
  2. 구조: 기능을 담기 위해 존재하며, 애플리케이션의 기능을 구현하기 위한 기반으로서 기능 변경을 수용할 수 있을 정도로 안정적이어야 한다.
* 이 때, 기능과 구조라는 두 재료는 다음과 같은 방식을 통해 효과적으로 표현할 수 있다.
  1. **기능은 사용자의 목표를 만족시키기 위해 책임을 수행하는 애플리케이션의 행위로 표현**한다.
  2. **구조는 사용자 또는 이해관계자들이 도메인에 관해 생각하는 개념과, 개념 간의 관계로 표현**한다.
* 일반적으로 **기능을 수집하고 표현하는 기법은 유즈케이스 모델링에 해당하는 반면, 구조를 수집하고 표현하는 기법은 도메인 모델링이라고 지칭**한다.
  * 또한, 각각의 모델링 활동의 결과물은 유즈케이스 모델과 도메인 모델이 된다.

## 2022-12-27 Tue
### 도메인과 도메인 모델
* **모든 소프트웨어는 사용자의 필요성을 충족시키기 위해 존재하며, 이렇듯 사용자가 애플리케이션을 사용하는 대상 분야를 도메인이라고 지칭**한다.
* 반면, 모델은 지식과 같은 대상의 중요한 부분만을 선택적으로 단순화하고 의식적으로 구조화한 형태를 의미한다.
  * 즉, **모델은 필요한 지식만을 재구성하기 위해 대상을 추상화하고 단순화하는 것으로 복잡성을 관리하기 위한 기본적인 도구에 해당**한다.
* 이에 따라 **도메인 모델은 사용자가 애플리케이션을 사용하는 대상 영역에 대한 지식을 선택적으로 단순화하고 의식적으로 구조화한 형태를 의미**하게 된다.
  * 다시 말해 **도메인 모델은 소프트웨어가 목표로 하는 영역의 개념이나 개념 간의 관계, 또는 다양한 규칙이나 제약 등을 추상화한 것에 해당**한다.
  * 결국 도메인 모델은 소프트웨어 개발과 관련된 이해 관계자들이 도메인에 대해 생각하는 관점과도 같다.
* 예를 들어 은행이라는 분야, 즉 도메인에 종사하는 업무 유관련자들은 은행 도메인을 고객과 계좌 사이에 흐르는 돈으로 이해한다.
  * 이렇듯 **애플리케이션의 도메인이 무엇이건 간에 언제나 도메인과 관련된 사람들이 도메인을 바라보는 도메인 모델이 존재**하게 된다.

### 멘탈 모델로서의 도메인 모델
```
> 도메인 모델은 단순한 다이어그램이 아니며, 오히려 이해관계자들이 바라보는 멘탈 모델이다.
```
* **멘탈 모델은 사람들이 자기 자신을 비롯하여 주위의 다른 사람이나 환경 등 자신이 상호작용하는 사물에 대해 갖는 모형을 의미**한다.
  * 이 때, 사람은 세상에서 발생하는 현상을 이해하고 이에 반응하기 위해 마음 속에 멘탈 모델을 구축한다.
  * **소프트웨어 사용자들 역시 도메인에 존재하는 현상을 이해하고 이에 반응하기 위해 도메인과 관련된 멘탈 모델을 형성**하게 된다.
* 이상적인 것은 제품을 설계하는 과정에서 제품과 관련된 모든 것이 사용자들이 제품에 대해 갖는 멘탈 모델과 정확하게 일치하는 것이다.
  * 이러한 관점에서, 훌륭한 디자인은 사용자가 예상하는 방식에 따라 정확하게 반응하는 제품을 만드는 것과 같다.
* 멘탈 모델은 또한 다음과 같은 세 가지로 분류될 수 있다.
  1. 사용자 모델: 사용자가 제품에 대해 갖는 개념들의 모습을 의미한다.
  2. 디자인 모델: 설계자가 마음 속에 갖는 시스템에 대한 개념화를 의미한다.
  3. 시스템 이미지: 최종적으로 개발된 제품을 의미한다.
* 이 때, **사용자 모델과 디자인 모델이 동일한 것이 가장 이상적이지만 안타깝게도 사용자는 설계자와 직접적으로 상호작용할 수 없다**.
  * 대신 최종 제품인 시스템 그 자체를 통해서만 의사소통이 가능하다.
  * 때문에 **설계자는 디자인 모델을 기반으로 제작된 시스템 이미지가 가능한 한 사용자 모델을 정확하게 반영하도록 주의를 기울이는 것이 바람직**하다.
* 반면, **도메인 모델은 도메인에 대한 사용자 모델과 디자인 모델 및 시스템 이미지를 포괄하도록 추상화한 소프트웨어 모델**과 같다.
  * 이러한 이유에서 도메인 모델은 소프트웨어에 대한 멘탈 모델이 된다.

### 도메인 모델링을 위한 패러다임
```
> 객체지향은 사용자의 관점은 물론이고 설계자의 관점과 코드의 모습을 모두 유사한 형태로 유지할 수 있도록 하는 유용한 사고 도구와 프로그래밍 기법을 제공한다.
```
* 상술한 바에 따라, 최종적으로 제작된 제품은 사용자의 관점을 반영할 수 있어야 한다.
  * 이는 **소프트웨어 개발에도 동일하게 적용되는 것으로, 최종적인 코드는 사용자가 도메인을 바라보는 관점을 반영하는 것이 바람직**하다.
  * 즉, **도메인 모델은 사용자가 도메인을 바라보는 관점이자 설계자가 시스템 구조를 바라보는 관점이면서도 소프트웨어에 구현된 코드의 모습 그 자체**가 된다.
  * 때문에 애플리케이션은 가능한 한 도메인 모델을 기반으로 설계되어야 한다.
* 결국 상술한 **세 측면을 모두 모델링할 수 있는 패러다임을 사용할수록 개발은 쉬워질 수 있으며, 객체지향은 이러한 요구사항을 가장 범용적으로 만족**시킨다.
  * 예를 들어, **객제지향을 사용하는 것으로 사용자들이 이해하는 도메인의 구조와 최대한 유사하도록 코드를 구조화**할 수 있다.
  * 이 때, 객체지향의 이러한 특징을 연결완전성 또는 표현적 차이라고 지칭할 수 있다.

### 표현적 차이와 은유의 대상
```
> 우리가 소프트웨어 객체로 은유하여 투영할 대상은 사용자가 도메인에 대해 생각하는 개념들이다.
```
* **소프트웨어 세상의 객체는 현실 객체에 대한 추상화가 아니며, 오히려 현실 객체에 대한 은유를 기반으로 재창조된 것으로 이해하는 것이 바람직**하다.
  * 이 경우, 소프트웨어 객체는 현실 객체가 갖지 못한 특성을 갖는 등 의도적으로 왜곡될 수 있으나 여전히 현실 객체의 특성을 토대로 구축된다.
  * 이렇듯 소프트웨어 객체와 현실 객체 사이의 의미적 거리를 가리켜 표현적 차이 또는 의미적 차이라고 지칭할 수 있다.
  * 그러나 결국 **중요한 것은 은유를 기반으로 현실 객체와 소프트웨어 객체 사이의 차이를 최대한 줄이는 데**에 있다.
* 그러나 대부분의 소프트웨어 도메인은 현실에 존재하지 않는 가상의 세계를 기반으로 하므로, 현실 객체를 은유하라는 것이 현실적이지 못한 것으로 다가올 수 있다.
  * 때문에 **개발자로서의 우리가 대부분의 경우에 은유를 통해 투영할 대상은 사용자가 도메인에 대해 생각하는 개념들인 도메인 모델**이 된다.
* **소프트웨어 객체는 대상의 현실성 여부는 차치하고서라도 도메인 모델을 통해 표현된 도메인 객체들을 은유해낼 수 있어야 한다**.
  * 이는 **도메인 모델이 중요한 이유이며, 도메인 모델을 기반으로 설계하고 구현하는 것은 도메인에 대한 사용자의 관점을 그대로 코드에 담을 수 있도록 한다**.
  * 이를 통해 **표현적인 차이는 줄어들고, 사용자의 멘탈 모델은 코드에 그대로 스며들게 될 수 있다**.
* 또한, 표현적 차이는 소프트웨어를 이해하고 수정하기 쉽도록 만들어줄 수 있다는 점에서도 중요하다.
  * 이는 **코드의 구조가 도메인 구조를 반영하기 때문이며, 도메인을 이해하는 것으로 코드를 이해하기 쉬워질 수 있기 때문**이다.
  * 이렇듯 도메인 모델은 코드 안에 존재하는 복잡성을 이해하고 헤쳐나가기 위한 지도로서의 역할을 겸임할 수 있다.

## 2022-12-28 Wed
### 안정적인 도메인 모델
```
> 도메인 모델을 기반으로 코드를 작성하는 것이 바람직한 이유 중 하나는, 도메인 모델이 제공하는 구조가 상대적으로 안정적이라는 사실이다.
```
* **도메인 모델의 핵심은 사용자가 도메인을 바라보는 관점을 소프트웨어의 설계와 구현에 반영하는 데에 있다**.
  * 이 때, **사용자들은 도메인을 구성하는 개념이나 개념 간의 관계와 같은 도메인의 본질적인 측면을 다른 누구보다도 잘 이해하고 있기에 의미가 깊다**.
  * 또한 본질적이므로, 소프트웨어 개발의 가장 큰 적인 변경 자체가 적게 발생한다는 특징 역시 존재한다.
  * 이렇듯 **사용자 모델에 포함되는 개념과 규칙은 비교적 변경될 확률이 적기에 사용자 모델을 기반으로 설계할 경우 변경에 쉽게 대처할 수 있다**.
* 상술한 바와 같이 **도메인 모델은 불안정한 기능을 담을 수 있는 안정적인 구조를 제공할 수 있으며, 이로 인해 소프트웨어 구조의 기반**이 될 수 있다.
  * 나아가 안정적인 구조를 기반으로 자주 변경될만한 기능을 배치하는 것으로 기능의 변경에 대해 안정적이고 탄력적인 소프트웨어를 제작할 수 있게 된다.

### 유즈케이스란?
* 비록 **도메인 모델이 도메인에 관련된 본질적인 개념을 담아낸다고 하지만, 그럼에도 사용자에게 중요한 것은 소프트웨어가 제공하는 기능**이다.
  * 소프트웨어의 존재 의의는 사용자가 원하는 목표를 달성할 수 있는 다양한 기능을 제공하는 것이므로, 사용자에게 제공할 기능을 기술할 정보 역시 필요하다.
* 반면, **기능적 요구사항이란 애플리케이션이 사용자에게 제공해야만 하는 기능 목록을 정리한 것을 의미**한다. 
  * 나아가 좋은 기능적 요구사항을 얻기 위해서는 목표를 갖는 사용자와 사용자의 목표를 만족시키기 위한 애플리케이션 간의 상호작용 관점에서 바라볼 필요가 있다.
  * 사용자는 자신의 목표를 달성하기 위해 애플리케이션과 상호작용을 시작하며, 더 이상 상호작용이 불가능할 때까지 요청과 응답을 주고 받는다.
* 이렇듯 **사용자의 목표를 달성하기 위해 사용자와 애플리케이션 간에 발생하는 상호작용의 흐름을 문자로 정리한 것을 유즈케이스라고 지칭**한다.
  * 즉, 유즈케이스는 소프트웨어가 제공하는 기능을 기술하기 위한 일종의 기법에 해당한다.
* **유즈케이스의 가치는 사용자의 목표를 중심으로 애플리케이션의 기능적 요구사항들을 이야기 형태로 묶을 수 있다는 점**에 있다.
  * 즉, 유즈케이스는 애플리케이션 여기 저기에 흩어진 기능에 사용자 목표라는 문맥을 제공하는 것으로 각 기능이 유기적인 관계를 갖는 체계를 이루도록 한다.

### 유즈케이스의 중요한 특징들
* 첫째로, **유즈케이스는 다이어그램이 아닌 사용자와 애플리케이션 간의 상호작용을 보여주는 텍스트**이다.
  * 즉, **중요한 것은 유즈케이스 안에 포함된 상호작용의 흐름**이므로 다이어그램에 노력을 기울일 필요가 없다.
* 둘째로, **유즈케이스는 단일 시나리오가 아닌 연관된 여러 시나리오들의 집합**이다.
  * 예를 들어, **유즈케이스는 특정한 사용자 목표와 관련된 모든 시나리오의 집합**이다.
* 셋째로, 유즈케이스는 단순한 피쳐 목록이 아니다.
  * 이 때, 피쳐란 애플리케이션이 수행해야하는 기능 목록을 단순하게 나열한 것을 의미한다.
  * 피쳐는 각각의 피쳐가 서로 연관이 없는 독립적인 기능처럼 보이게 만든다는 단점이 존재한다.
  * 그러나 **유즈케이스는 단순히 기능을 나열하지 않고, 이야기를 통해 연관된 기능들을 하나로 묶는 역할을 수행**한다.
* 넷째로, **유즈케이스는 사용자 인터페이스와 같이 변경이 잦은 내용에 대한 세부 정보를 포함하지 않아야한다** .
  * 즉, 유즈케이스는 사용자 인터페이스와 같은 요소를 배제한 채 오직 사용자 관점에서 애플리케이션의 행위에만 초점을 맞추어야 한다.
* 다섯째로, **유즈케이스는 내부적인 설계와 관련된 정보를 포함하지 않아야한다**.
  * **유즈케이스의 목적은 서로 관련된 애플리케이션의 기능을 이야기 형식으로 모으는 데에 있으며, 내부 설계를 설명하는 것은 이와 관련이 없다**.

### 애플리케이션의 외부 관점만을 묘사하는 유즈케이스
* **유즈케이스는 단지 사용자가 바라보는 애플리케이션의 외부 관점만을 표현하며, 내부 구조를 유추할 수 있는 방법은 전혀 제공하지 않는다**.
  * 대신 유즈케이스는 단지 사용자가 애플리케이션을 통해 무엇을 얻을 수 있고 어떻게 상호작용할 수 있을지와 관련된 정보만을 기술한다.
* 또한 **유즈케이스는 단지 기능적 요구사항을 사용자 목표라는 문맥으로 묶는 정리 기법에 불과하므로, 객체지향 패러다임과도 큰 관계가 없다**.
  * 때문에 유즈케이스를 토대로 객체의 구조를 쉽게 추출할 수 있다는 말은 거짓이며, 유즈케이스는 객체 구조나 책임과 같은 정보를 제공할 수 없다.
* 이렇듯 **유즈케이스만으로는 도메인 모델을 구축하기 위한 모든 정보를 얻을 수 없으며, 단지 도메인 모델에 대한 약간의 힌트만을 얻어갈 수 있을 뿐**이다.
# Basics
## 2023-06-06 Tue
### 깃 브랜치란?
* 대부분의 버전 관리 시스템이 브랜치 개념을 지원하듯 깃 역시 브랜치를 지원한다.
  * 예를 들어, 깃 역시 브랜치를 활용하여 코드를 전부 복사한 후 기존 코드와는 관계 없는 독립적인 개발을 진행해나갈 수 있다.
  * 나아가 깃의 브랜치는 다른 버전 관리 시스템과 비교하여 훨씬 가볍기에 깃은 브랜치를 만들어 작업한 후 머지하는 방법을 적극적으로 권장한다.
* 앞서 다룬 바와 같이, **깃은 데이터를 변경 사항으로 기록하는 대신 일련의 스냅샷을 기록하는 방식으로 구현**된다.

## 2023-06-07 Wed
### 커밋 오브젝트란?
* **커밋이 발생할 경우 깃은 다음과 같은 내용을 포함한 새로운 커밋 오브젝트를 저장**한다.
  1. Staging area의 데이터 스냅샷에 대한 포인터
  2. 저자, 또는 커밋 메시지와 같은 메타데이터
  3. 이전 커밋에 대한 포인터
* 특히 이전 커밋에 대한 포인터를 갖는 커밋 개체는 이를 기준으로 무엇이 변경되었는지 알 수 있으며, 머지 커밋의 경우 이전 커밋 포인터를 여럿 가질 수도 있다.

## 2023-06-08 Thu
### 커밋 과정과 브랜치
* **임의의 파일을 Staging area에 저장한 경우, 깃 저장소에는 각 파일에 대한 blob 파일과 체크섬이 저장**된다.
* 이렇게 Staging area에 파일을 삽입한 후 커밋할 경우, 다음과 같은 흐름으로 두 분류의 데이터 객체들이 생성된다.
  1. 커밋될 파일들이 위치한 디렉토리 구조를 의미하는 트리 객체가 생성되고, 체크섬과 함께 저장소에 저장된다.
  2. 트리 객체가 생성된 후, 메타데이터와 트리 객체를 참조하는 포인터가 포함된 커밋 객체가 저장된다.
* 이렇듯 커밋 객체는 필요한 정보를 모두 포함하므로 필요시 언제든지 스냅샷을 새로 생성할 수 있으며, 이로 인해 깃 저장소에는 다음과 같은 파일들이 저장된다.
  1. 커밋된 **각 파일에 대한 개별 blob 파일**
  2. 파일과 디렉토리 구조가 저장된 **하나의 트리 객체**
  3. 커밋 메타데이터와, 트리 객체를 참조하는 포인터가 포함된 **하나의 커밋 객체**
* 이러한 관점에서, 깃 브랜치는 각 커밋 사이를 가볍게 이동할 수 있는 일종의 포인터와 같다.
* 또한, 깃은 기본적으로 master 브랜치를 생성하며 최초의 커밋은 master 브랜치가 생성된 커밋을 가리킨다.
  * 엄밀히 말해 master 브랜치는 특별한 브랜치가 아니며, 그저 `git init` 명령을 통해 자동 생성된 master 브랜치의 이름을 구태여 수정하지 않을 뿐이다.
  * 또한, 이후에 **새로운 커밋을 저장할 때마다 각각의 브랜치는 자동으로 가장 마지막의 커밋을 참조**한다.

## 2023-06-09 Fri
### 브랜치 생성하기
* `git branch [브랜치명]` 명령어를 활용하여 새로운 브랜치를 생성할 수 있으며, 생성된 브랜치 역시 방금 작업 중이던 마지막 커밋을 가리킨다.
* 깃은 **현재 작업 중인 브랜치를 확인하기 위한 특수한 포인터인 `HEAD`를 제공하며, `HEAD`는 항상 현재 작업 중인 로컬 브랜치를 가리킨다**.
  * 이 때, `git branch` 명령은 새로운 브랜치를 생성하지만 브랜치를 옮기지 않으므로 `HEAD`는 변하지 않는다.
  * 즉, 깃에서 **임의의 브랜치는 특정한 커밋을 가리키며 현재 작업 중인 브랜치는 `HEAD` 포인터가 가리키는 구조**를 갖는다.
* 예를 들여 `git log --decorate --oneline` 명령을 입력하여 임의의 커밋 체크섬을 가리키는 브랜치와 브랜치를 가리키는`HEAD` 정보를 확인할 수 있다.
```shell
5326c5f (HEAD -> master, origin/master, origin/HEAD) [TIL] Add 2023-05-21.Sun TIL.
53a279f [TIL] Add 2023-05-20.Sat TIL.
c58c1f0 [TIL] Add 2023-05-19.Fri TIL.
: 
```

## 2023-06-10 Sat
### 브랜치의 이동
* **`git checkout` 명령은 다른 브랜치로 이동하기 위해 사용되며, 크게 다음과 같은 역할을 수행한다.
  1. 임의의 브랜치가 가리키는 커밋을 `HEAD` 포인터가 가리키도록 한다.
  2. 워킹 디렉토리의 파일을 해당 시점으로 되돌린다.
* 이러한 `git checkout` 명령의 특징에 따라, 깃을 활용하는 프로젝트의 작업 내용은 개별 브랜치에 독립적으로 존재할 수 있다.
  * 이로 인해 브랜치와 체크아웃, 커밋 명령을 활용하여 각 커밋 사이를 자유로이 이동하며 작업을 진행해나갈 수 있다.
* 내부적으로 **깃의 브랜치는 임의의 커밋을 가리키는 40 바이트의 SHA-1 체크섬 파일에 불과하므로, 생성하거나 삭제하기 쉽다**.
  * 줄바꿈 문자를 포함하면 새로운 브랜치를 생성하는 것이 그저 41바이트 크기의 파일을 하나 만드는 데에 지나지 않는다.
  * 반면, 다른 버전 관리 도구들은 기본적으로 브랜치 별로 프로젝트를 전부 복사하므로 브랜치의 생성이 부담스럽다.
* 이렇듯 깃은 브랜치의 생성이 쉽고 빠르며, 커밋마다 이전 커밋의 정보를 저장하기에 어느 시점부터 머지해야할지를 의미하는 `merge base`를 찾기도 쉽다.
  * 이로 인해 깃은 수시로 브랜치를 생성하여 작업하되, 작업이 완료되었을 때 머지하는 방식을 권장한다.
* 이 때, **브랜치를 이동하는 경우 아직 커밋하지 않은 파일은 체크아웃 대상 브랜치와 충돌이 발생하는 경우 브랜치 변경은 불가능**하다.
  * 때문에 브랜치를 이동하기 전에는 우선 워킹 디렉토리를 정리해야 하며, 이를 위해 `git stash` 등의 명령을 활용할 수 있다.
* **브랜치를 성공적으로 이동한 경우, 깃은 자동으로 해당 브랜치가 가리키는 커밋의 환경에 맞추어 워킹 디렉토리의 파일들을 스냅샷 시점으로 되돌린다**.

## 2023-06-11 Sun
### 브랜치 머지와 Fast-forward
* 핫픽스용 브랜치에서 작업한 내용을 마스터 브랜치에 병합하고자 하는 경우, `git merge [병합_대상_브랜치명]` 명령을 다음과 같이 활용할 수 있다.
  * 이 경우, 합쳐질 브랜치에 이동하여 병합할 브랜치에 대해 `git merge [병합_대상_브랜치명]` 명령을 적용하게 된다.
```shell
[~] git checkout master
[~] git merge hotfix
Updating f42c576..3a1245c
Fast-forward
 index.js | 2 ++
 1 file changed, 2 insertions(+)
[~]
```
* **머지 방식 중 `Fast-forward`의 경우, 단순히 병합 대상 브랜치가 가리키는 커밋이 현재 브랜치 커밋의 Upstream인 경우에 적용**될 수 있다.
  * 이 경우, **병합 전 커밋을 가리키던 마스터 브랜치 포인터는 별도의 머지 과정을 거치지 않고 최신 커밋으로 이동**한다.
  * 쉽게 말해 **병합 대상 브랜치가 단순히 병합될 브랜치 이후의 커밋을 가리키는 경우, 단순히 병합될 브랜치가 해당 커밋을 참조하도록 이동하는 것**과 같다.
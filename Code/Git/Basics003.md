# Basics
## 2023-06-06 Tue
### 깃 브랜치란?
* 대부분의 버전 관리 시스템이 브랜치 개념을 지원하듯 깃 역시 브랜치를 지원한다.
  * 예를 들어, 깃 역시 브랜치를 활용하여 코드를 전부 복사한 후 기존 코드와는 관계 없는 독립적인 개발을 진행해나갈 수 있다.
  * 나아가 깃의 브랜치는 다른 버전 관리 시스템과 비교하여 훨씬 가볍기에 깃은 브랜치를 만들어 작업한 후 머지하는 방법을 적극적으로 권장한다.
* 앞서 다룬 바와 같이, **깃은 데이터를 변경 사항으로 기록하는 대신 일련의 스냅샷을 기록하는 방식으로 구현**된다.

## 2023-06-07 Wed
### 커밋 오브젝트란?
* **커밋이 발생할 경우 깃은 다음과 같은 내용을 포함한 새로운 커밋 오브젝트를 저장**한다.
  1. Staging area의 데이터 스냅샷에 대한 포인터
  2. 저자, 또는 커밋 메시지와 같은 메타데이터
  3. 이전 커밋에 대한 포인터
* 특히 이전 커밋에 대한 포인터를 갖는 커밋 개체는 이를 기준으로 무엇이 변경되었는지 알 수 있으며, 머지 커밋의 경우 이전 커밋 포인터를 여럿 가질 수도 있다.

## 2023-06-08 Thu
### 커밋 과정과 브랜치
* **임의의 파일을 Staging area에 저장한 경우, 깃 저장소에는 각 파일에 대한 blob 파일과 체크섬이 저장**된다.
* 이렇게 Staging area에 파일을 삽입한 후 커밋할 경우, 다음과 같은 흐름으로 두 분류의 데이터 객체들이 생성된다.
  1. 커밋될 파일들이 위치한 디렉토리 구조를 의미하는 트리 객체가 생성되고, 체크섬과 함께 저장소에 저장된다.
  2. 트리 객체가 생성된 후, 메타데이터와 트리 객체를 참조하는 포인터가 포함된 커밋 객체가 저장된다.
* 이렇듯 커밋 객체는 필요한 정보를 모두 포함하므로 필요시 언제든지 스냅샷을 새로 생성할 수 있으며, 이로 인해 깃 저장소에는 다음과 같은 파일들이 저장된다.
  1. 커밋된 **각 파일에 대한 개별 blob 파일**
  2. 파일과 디렉토리 구조가 저장된 **하나의 트리 객체**
  3. 커밋 메타데이터와, 트리 객체를 참조하는 포인터가 포함된 **하나의 커밋 객체**
* 이러한 관점에서, 깃 브랜치는 각 커밋 사이를 가볍게 이동할 수 있는 일종의 포인터와 같다.
* 또한, 깃은 기본적으로 master 브랜치를 생성하며 최초의 커밋은 master 브랜치가 생성된 커밋을 가리킨다.
  * 엄밀히 말해 master 브랜치는 특별한 브랜치가 아니며, 그저 `git init` 명령을 통해 자동 생성된 master 브랜치의 이름을 구태여 수정하지 않을 뿐이다.
  * 또한, 이후에 **새로운 커밋을 저장할 때마다 각각의 브랜치는 자동으로 가장 마지막의 커밋을 참조**한다.

## 2023-06-09 Fri
### 브랜치 생성하기
* `git branch [브랜치명]` 명령어를 활용하여 새로운 브랜치를 생성할 수 있으며, 생성된 브랜치 역시 방금 작업 중이던 마지막 커밋을 가리킨다.
* 깃은 **현재 작업 중인 브랜치를 확인하기 위한 특수한 포인터인 `HEAD`를 제공하며, `HEAD`는 항상 현재 작업 중인 로컬 브랜치를 가리킨다**.
  * 이 때, `git branch` 명령은 새로운 브랜치를 생성하지만 브랜치를 옮기지 않으므로 `HEAD`는 변하지 않는다.
  * 즉, 깃에서 **임의의 브랜치는 특정한 커밋을 가리키며 현재 작업 중인 브랜치는 `HEAD` 포인터가 가리키는 구조**를 갖는다.
* 예를 들여 `git log --decorate --oneline` 명령을 입력하여 임의의 커밋 체크섬을 가리키는 브랜치와 브랜치를 가리키는`HEAD` 정보를 확인할 수 있다.
```shell
5326c5f (HEAD -> master, origin/master, origin/HEAD) [TIL] Add 2023-05-21.Sun TIL.
53a279f [TIL] Add 2023-05-20.Sat TIL.
c58c1f0 [TIL] Add 2023-05-19.Fri TIL.
: 
```

## 2023-06-10 Sat
### 브랜치의 이동
* **`git checkout` 명령은 다른 브랜치로 이동하기 위해 사용되며, 크게 다음과 같은 역할을 수행한다.
  1. 임의의 브랜치가 가리키는 커밋을 `HEAD` 포인터가 가리키도록 한다.
  2. 워킹 디렉토리의 파일을 해당 시점으로 되돌린다.
* 이러한 `git checkout` 명령의 특징에 따라, 깃을 활용하는 프로젝트의 작업 내용은 개별 브랜치에 독립적으로 존재할 수 있다.
  * 이로 인해 브랜치와 체크아웃, 커밋 명령을 활용하여 각 커밋 사이를 자유로이 이동하며 작업을 진행해나갈 수 있다.
* 내부적으로 **깃의 브랜치는 임의의 커밋을 가리키는 40 바이트의 SHA-1 체크섬 파일에 불과하므로, 생성하거나 삭제하기 쉽다**.
  * 줄바꿈 문자를 포함하면 새로운 브랜치를 생성하는 것이 그저 41바이트 크기의 파일을 하나 만드는 데에 지나지 않는다.
  * 반면, 다른 버전 관리 도구들은 기본적으로 브랜치 별로 프로젝트를 전부 복사하므로 브랜치의 생성이 부담스럽다.
* 이렇듯 깃은 브랜치의 생성이 쉽고 빠르며, 커밋마다 이전 커밋의 정보를 저장하기에 어느 시점부터 머지해야할지를 의미하는 `merge base`를 찾기도 쉽다.
  * 이로 인해 깃은 수시로 브랜치를 생성하여 작업하되, 작업이 완료되었을 때 머지하는 방식을 권장한다.
* 이 때, **브랜치를 이동하는 경우 아직 커밋하지 않은 파일은 체크아웃 대상 브랜치와 충돌이 발생하는 경우 브랜치 변경은 불가능**하다.
  * 때문에 브랜치를 이동하기 전에는 우선 워킹 디렉토리를 정리해야 하며, 이를 위해 `git stash` 등의 명령을 활용할 수 있다.
* **브랜치를 성공적으로 이동한 경우, 깃은 자동으로 해당 브랜치가 가리키는 커밋의 환경에 맞추어 워킹 디렉토리의 파일들을 스냅샷 시점으로 되돌린다**.

## 2023-06-11 Sun
### 브랜치 머지와 Fast-forward
* 핫픽스용 브랜치에서 작업한 내용을 마스터 브랜치에 병합하고자 하는 경우, `git merge [병합_대상_브랜치명]` 명령을 다음과 같이 활용할 수 있다.
  * 이 경우, 합쳐질 브랜치에 이동하여 병합할 브랜치에 대해 `git merge [병합_대상_브랜치명]` 명령을 적용하게 된다.
```shell
[~] git checkout master
[~] git merge hotfix
Updating f42c576..3a1245c
Fast-forward
 index.js | 2 ++
 1 file changed, 2 insertions(+)
[~]
```
* **머지 방식 중 `Fast-forward`의 경우, 단순히 병합 대상 브랜치가 가리키는 커밋이 현재 브랜치 커밋의 Upstream인 경우에 적용**될 수 있다.
  * 이 경우, **병합 전 커밋을 가리키던 마스터 브랜치 포인터는 별도의 머지 과정을 거치지 않고 최신 커밋으로 이동**한다.
  * 쉽게 말해 **병합 대상 브랜치가 단순히 병합될 브랜치 이후의 커밋을 가리키는 경우, 단순히 병합될 브랜치가 해당 커밋을 참조하도록 이동하는 것**과 같다.

## 2023-06-12 Mon
### 3-way 머지란?
```
> Fast-forward와 같이 단순히 커밋을 이동시킬 수 없는 경우, 깃은 병합에 사용될 두 브랜치의 공통 조상 커밋을 생성하여 3-way 머지를 적용한다.
```
* 상술한 경우와 달리, **병합 대상 브랜치가 병합될 브랜치의 조상 커밋을 가리키지 않는다면 깃은 3-way 머지를 적용**한다.
  * 이 경우 단순히 브랜치 참조를 이동시킬 수 없으므로, **3-way 머지의 결과로 두 브랜치의 공통 조상이 될 커밋을 생성한 후 브랜치의 참조를 이동**시킨다.
  * 때문에 이러한 결과로 생성된 머지 커밋은 여러 개의 부모 커밋을 가질 수 있다.
* 또한, **깃은 다른 버전 관리 도구와 달리 머지에 필요한 최적의 공통 조상을 자동으로 탐색하므로 쉽게 머지를 적용할 수 있다는 장점 역시 존재**한다.

## 2023-06-13 Tue
### 머지 충돌이란?
* 3-way 머지를 시도했으나, 머지 대상 두 브랜치에서 같은 파일의 동일한 부분을 수정했다면 깃은 이를 머지할 수 없어 새 커밋을 만들지 않는다.
  * 때문에 이러한 변경사항을 개발자가 직접 해결하지 않는 이상 머지 과정을 더 이상 진행할 수 없다.
* **어떤 파일로 인해 머지할 수 없었는지 확인하고자 하는 경우에는 `git status` 명령을 사용**할 수 있으며 충돌이 발생한 파일은 unmerged로 표시된다.
* 깃은 충돌이 발생한 부분을 다음과 같은 표준 형식에 따라 표시하므로, 개발자는 해당되는 부분의 충돌을 수동으로 해결해주어야 한다.
  * 아래와 같은 **표준 형식에서, `=======` 위쪽의 내용은 병합을 시도한 master 브랜치의 내용인 반면 아래에는 병합 대상 브랜치의 내용을 의미**한다.
```shell
<<<<<<< HEAD:index.html
<div>hello</div>
=======
<div>bye</div>
>>>>>> hotfix:index.html
```
* 상술한 경우와 같이 **충돌이 발생한 경우, 위 또는 아래의 내용 중 하나를 고르거나 새로 작성하여 다시 머지**해줄 필요가 있다.
  * 이 때, `git add` 명령으로 깃에 다시 저장하되 `<` 또는 `=`나 `>`가 포함된 행은 반드시 제거되어야 한다.
* **충돌을 해결한 후에도 `git status` 명령으로 상태를 확인할 수 있으나, 해당 파일은 아직 Staging area에 위치함에 주의**해야 한다.
  * 때문에 **충돌이 완료된 후에는 `git commit` 명령을 활용하여 머지된 내용을 커밋하여 작업을 마무리**해야 한다.

## 2023-06-14 Wed
### 브랜치 관리하기
* 아무런 옵션 없이 실행된 `git branch` 명령은 단순히 브랜치의 목록을 출력하며, `*` 표시를 통해 현재 작업중인 브랜치를 확인할 수 있다.
* `git branch --merged` 옵션을 활용할 경우, 현재 체크아웃된 브랜치를 기준으로 머지된 브랜치만을 필터링할 수 있다.
  * 이 경우, **해당 목록에 나타나는 브랜치 중 `*` 표시가 할당되지 않은 브랜치는 이미 작업을 머지했으므로 삭제해도 무방한 것**으로 이해할 수 있다.
  * 이 때, 임의의 브랜치를 삭제하고자 하는 경우 `git branch -d [삭제_대상_브랜치명]` 옵션을 활용할 수 있다.
* 반면, `--no-merged` 옵션을 활용할 경우 현재 체크아웃된 브랜치에 머지되지 않은 브랜치만을 필터링할 수 있다.
  * 이러한 브랜치는 머지되지 않은 커밋이 포함되므로 일반적인 방법으로는 삭제할 수 없으며, 강제로 제거하고자 하는 경우에만 `-D` 옵션을 명시할 수 있다.

## 2023-06-15 Thu
### 브랜치 워크플로우 - long running 브랜치
```
> long running 브랜치는 프로젝트의 규모가 크고 복잡할수록 빛을 발한다.
```
* 해당 워크플로우는 가장 안정된 버전의 코드만 master 브랜치에 두고, 필요에 따라 아래와 같은 브랜치를 추가로 생성하여 관리한다.
  1. next 또는 develop: 신규 기능에 대한 개발을 진행하며 점차 안정화해나가기 위한 브랜치에 해당한다.
  2. topic: 임의의 이슈를 해결하기 위한 짧은 호흡의 개발 과정을 위한 브랜치에 해당한다.
* 이 때, 해당 워크플로우는 테스트를 거쳐 안정화된 코드만을 topic > develop > master 순으로 점차 머지해나가며 관리하는 방식을 의미한다.
  * 즉, 개발 브랜치는 공격적으로 히스토리를 만들어 앞서가되 안정된 브랜치는 이미 만들어진 히스토리를 뒤따라나가는 식으로 진행된다.
* 프로젝트의 규모가 충분히 큰 경우, master와 develop 사이에 proposal과 같은 완충 단계를 추가할 수도 있다.

## 2023-06-16 Fri
### 브랜치 워크플로우 - 토픽 브랜치
```
> 토픽 브랜치는 임의의 주제나 작업을 위해 생성된 짧은 호흡의 브랜치이며, 프로젝트 크기에 관계 없이 유용하다.
```
* 다른 버전 관리 도구와 달리, 깃은 브랜치 관리에 드는 비용이 크지 않으므로 일상적으로 브랜치를 생성해볼 수 있다.
* 이에 따라, **해당 워크플로우는 각 작업을 하루 또는 한 달 등 짧은 호훕으로 유지하되 머지할 준비가 된 시점에 master 브랜치에 병합하는 방식을 의미**한다.

## 2023-06-17 Sat
### 원격 브랜치 관리하기
* 리모트 Refs는 원격 저장소에 위치한 포인터 레퍼런스이며, 원격 저장소 상의 브랜치나 태그 등등을 의미한다.
  * 이러한 리모트 Refs는 `git ls-remote` 명령으로 조회할 수 있다.
* **리모트 트래킹 브랜치는 원격 브랜치를 추적하는 브랜치이며, 로컬에 위치하지만 움직일 수는 없는 브랜치를 의미**한다.
  * 이러한 브랜치는 원격지에 연결할 때마다 원격 브랜치가 어떤 커밋을 가리키고 있었는지 자동으로 업데이트 되는 일종의 북마크 역할을 수행한다.
* 원격 브랜치의 이름은 `[원격_저장소명]/[브랜치명]` 형태로 명명되므로, 예를 들어 `origin/master`는 원격 저장소 상의 master 브랜치를 의미한다.
  * 이 때, **`origin/master` 브랜치가 리모트 트래킹 브랜치**가 된다.
* 원격 저장소의 프로젝트를 클론하는 경우, 깃은 크게 다음과 같은 순서로 동작한다.
  1. 원격 저장소를 클론하는 과정에서 깃은 원격 저장소에 자동으로 origin이라는 이름을 할당한다.
  2. origin의 프로젝트를 모두 다운로드한 후, 원격 저장소의 master 브랜치를 가리키는 `origin/master` 포인터를 생성한다.
  3. 로컬의 master 브랜치가 `origin/master` 브랜치를 가리키도록 한다.
  4. 개발자는 이 시점에서 master 브랜치로부터 작업을 시작한다.
* 이 때, 상술한 과정에서 생성된 포인터인 `origin/master`는 로컬 환경에서 원하는대로 조종하는 것이 불가능하다.
  * **브랜치명으로 자주 사용되는 `master`가 특별한 의미가 아니듯, `origin` 역시 특별한 저장소명이 아니다**.
  * **오히려 이는 `git clone` 명령이 자동으로 할당하는 원격 저장소명에 불가하며, 클론 과정에서 원하는대로 원격 저장소명을 수정하는 것 역시 가능**하다.
* 협업자 역시 master 브랜치에서 작업하는 경우, 협업자가 자신의 변경 사항을 push하여 master 브랜치를 업데이트한다면 팀원 간 히스토리는 달라질 수 있다.
  * 그러나 이 경우에도 서버에 데이터를 요청하지 않았다면 자신의 로컬 환경에 위치한 `origin/master` 의 참조는 변경되지 않는다.
* 반면, **`git fetch origin` 명령을 활용하여 원격 저장소의 정보를 동기화를 시도하는 경우 로컬 저장소에 포함되지 않은 모든 수정 사항이 업데이트**된다.
  * 이 때에 와서야 **원격 저장소의 새로운 수정 사항을 모두 로컬 저장소로 다운로드한 후 `origin/master` 포인터의 참조는 최신 커밋으로 이동**하게 된다.
  * 반면, 리모트 트래킹 브랜치를 내려받는다고 하더라도 로컬 저장소에 동일한 브랜치가 생성되는 것은 아니며 단순히 수정 불가한 브랜치 포인터만 생성된다.
* 리모트 트래킹 브랜치로부터 새로운 브랜치를 생성하고자 하는 경우, `git checkout -b [브랜치명] [리모트_트래킹_브랜치명]` 명령을 활용할 수 있다.

## 2023-06-18 Sun
### 브랜치 푸시하기
* 로컬 환경에서 생성한 브랜치는 쓰기 권한이 있는 원격 저장소에 푸시할 수 있으며, 이러한 과정은 반드시 명시적으로 진행되어야 한다.
* 이 때, 브랜치를 푸시하기 위해서는 `git push [원격_저장소_단축명] [로컬_브랜치명]` 명령을 활용한다.
  * 이 경우 원격 저장소에는 푸시한 로컬 브랜치와 동일한 이름의 브랜치가 생성된다.
  * 반면, 브랜치의 이름을 변경하여 푸시하고자 하는 경우 `git push [원격_저장소_단축명] [로컬_브랜치명]:[원격_브랜치명]` 명령을 활용해야 한다.

## 2023-06-19 Mon
### 브랜치 추적하기
* 리모트 트래킹 브랜치를 로컬 브랜치로 체크아웃할 경우, 자동으로 트래킹 브랜치가 생성된다.
  * 이러한 **트래킹 브랜치는 업스트림 브랜치로도 지칭할 수 있으며, 원격 저장소 상의 브랜치와 직접적으로 연결되는 로컬 브랜치 역할을 수행**한다.
  * 예를 들어 `git pull` 명령을 입력할 경우, 원격 저장소로부터 필요한 데이터를 받아 연결된 원격 브랜치와 자동으로 머지한다.
* 임의의 프로젝트를 최초로 클론한 경우, 깃은 자동으로 `master` 브랜치를 `origin/master` 브랜치의 트래킹 브랜치로 생성한다.
* 이 때, 트래킹 브랜치는 크게 다음과 같은 두 가지 방식으로 생성할 수 있다.
  1. 이미 존재하는 리모트 브랜치를 추적하고자 하는 경우, `git checkout -b [브랜치명] [원격_저장소명/브랜치명]` 명령을 활용할 수 있다.
  2. 또는 로컬 브랜치가 임의의 원격 브랜치를 추적하고자 하는 경우, `git branch -u [원격_저장소명/브랜치명]` 명령을 활용할 수 있다.
* 프로젝트에 설정된 추적 브랜치를 확인하고자 하는 경우, `git branch -vv` 명령을 활용할 수 있다.
  * 이를 통해 로컬 브랜치 목록과, 로컬 브랜치 각각이 추적하는 원격 브랜치 및 로컬 브랜치와 원격 브랜치 간의 커밋 간격을 확인할 수 있다.
  * 이 때, **해당 명령을 실행했을 때 출력되는 결과는 항상 `git fetch` 명령을 마지막으로 실행한 시점을 기준으로 계산된다는 점에 주의**를 기울여야 한다.

## 2023-06-20 Tue
### git pull 명령이란?
* 상술한 `git fetch` 명령은 서버에는 존재하지만 로컬에는 없는 데이터를 받아와 저장하지만, 실제 워킹 디렉토리에는 영향을 주지 않는다.
  * 즉, 해당 명령은 단지 데이터를 가져와 저장한 후 개발자가 직접 머지할 수 있도록 기반 작업만을 진행하는 것과 같다.
* 반면, 일반적으로 `git pull` 명령은 대부분의 경우 `git fetch` 명령을 실행한 후 자동으로 `git merge` 명령을 실행하는 것과 같다.
  * 예를 들어, 해당 명령을 사용할 경우 서버로부터 데이터를 가져와 현재의 로컬 브랜치와 서버의 추적 브랜치를 머지한다.
* **대부분의 경우에는 `git pull` 명령을 활용하기보다는 `git fetch`와 `git merge`를 명시적으로 사용하는 것이 권장**된다.

## 2023-06-21 Wed
### 원격 브랜치 삭제하기
* 작업을 마무리한 후 결과물을 `master` 브랜치로 머지한 경우, `git push origin --delete [브랜치명]` 명령을 활용하여 원격 브랜치를 제거할 수 있다.
  * 해당 명령을 활용할 경우 서버의 브랜치가 제거되는 반면, 브랜치는 단지 커밋을 가리키는 포인터에 불과하므로 커밋 자체가 삭제되지는 않아 안전하다.

### git rebase란?
```
> 깃에서 하나의 브랜치를 다른 브랜치와 합치는 방법은 크게 머지와 리베이스로 나뉜다.
> 나아가 두 방식은 최종 결과물이 같으며, 단지 커밋 히스토리가 다르다는 차이만이 존재한다.
```
* 예를 들어 머지가 공통 조상과 두 브랜치의 마지막 커밋 두 개를 활용한다면, **리베이스는 하나의 브랜치의 변경 사항을 패치로서 다른 브랜치에 적용**한다.
  * 때문에 `git rebase` 명령을 활용할 경우, 임의의 브랜치에서 발생한 변경 사항을 다른 브랜치에 적용하는 것이 가능하다.
* 예를 들어, 다음과 같은 흐름으로 리베이스할 경우 `develop` 브랜치에 적용된 변경 사항은 `master`에도 적용된다.
```shell
[~] git checkout develop
[~] git rebase master
# ...생략
[~]
```
* 상술한 예시에서, 리베이스는 크게 다음과 같은 흐름으로 진행된다.
  1. 우선 `develop`과 `master`의 공통 조상 커밋으로 이동한다.
  2. 공통 조상 커밋으로부터 따져, `develop` 브랜치가 가리키고 있는 커밋까지의 diff를 차례로 생성한 후 임시로 저장한다.
  3. 이제 **리베이스할 브랜치인 `develop`이 참조할 새로운 커밋을 생성하여 합칠 대상 브랜치인 `master` 브랜치가 참조하는 커밋을 가리키도록 한다**.
  4. **2.의 과정에서 적용해두었던 변경 사항을 3.에서 생성된 커밋에 차례대로 적용**한다.
  5. **3.에서 생성된 커밋에 모든 변경 사항이 적용되었으므로, `master` 브랜치를 해당 커밋까지 `Fast-forward`** 한다.
* **머지와 리베이스 모두 최종 커밋에 변경 사항이 합쳐지는 관점에서는 서로 다를 바가 없으나, 리베이스는 더 깔끔한 히스토리 관리를 가능**케 한다.
  * 예를 들어, 리베이스로 관리된 브랜치의 커밋 로그는 병렬로 작업을 진행하더라도 머지 방식과는 달리 마치 순차적으로 작업을 진행한 것처럼 보여진다.
  * 때문에 **리베이스는 일반적으로 원격 브랜치에 커밋을 깔끔하게 적용하고자 하는 경우에 사용**된다.
* 머지 방식은 두 브랜치의 최종 결과물 커밋을 바로 합치는 반면, 리베이스 방식은 한 쪽의 변경 사항을 다른 브랜치에 순차적으로 적용하며 합쳐나간다.

## 2023-06-22 Thu
### 리베이스 활용하기
* 예를 들어 `master` 브랜치의 도중에서 `server` 브랜치가 갈라져 나오고, `server` 브랜치의 도중에서 `client` 브랜치가 갈라져나올 수 있다.
  * 이 때, `client` 브랜치의 작업이 완료되었으나 아직 `server` 브랜치가 개발 중인 경우에는 `--onto` 옵션을 활용하여 리베이스할 수 있다.
* 이러한 상황에서는 `git rebase --onto master server client` 옵션을 활용할 수 있으며, 이는 다음과 같은 의미를 갖는다.
  1. 우선 `client` 브랜치에 체크아웃한핟.
  2. `server`와 `client` 브랜치의 공통 조상을 찾는다.
  3. 이후의 패치 내용을 찾아 `master` 브랜치에 적용하므로, `client` 브랜치의 변경 사항이 `master` 브랜치에 합쳐진다.
* 상술한 과정을 거쳐 `master` 브랜치에 체크아웃하면 `Fast-forward`가 가능한 상황이 되므로, `git merge` 명령을 쉽게 적용할 수 있게 된다.
  * 반면, 아직 합쳐지지 않은 `server` 브랜치의 작업이 완료되면 `git rebase master server` 명령을 활용할 수 있다.
  * 해당 명령을 사용한 경우에도 `server` 브랜치의 변경 사항이 모두 `master` 브랜치에 적용되므로, 손쉽게 머지할 수 있는 환경이 구성된다.

## 2023-06-23 Fri
### 리베이스의 위험성
```
> 이미 공개된 저장소에 푸시한 커밋은 절대 리베이스 하지 않아야 한다.
> 리베이스를 적절히 활용하고자하는 경우, 반드시 서버에 데이터를 푸시하기 전에 리베이스로 커밋을 정리하는 것이 바람직하다.
```
* **리베이스는 많은 장점을 갖지만, 남용할 경우 협업자들에게 큰 불편을 줄 수 있는 위험성이 수반됨을 명심**해야 한다.
* **리베이스는 기존의 커밋을 그대로 재사용하지 않으며, 대신 내용이 같은 새로운 커밋을 생성하는 식으로 동작**한다.
  * 때문에 내가 이미 커밋하여 푸시한 내용을 리베이스할 경우, 협업하는 동료의 코드가 엉망이 되기 쉽다.
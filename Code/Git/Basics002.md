# Basics
## 2023-05-14 Sun
### 깃 저장소 만들기
* 깃 저장소를 만드는 방법은 크게 기존 프로젝트 또는 디렉토리를 깃 저장소로 만드는 방법과, 원격지에 존재하는 저장소를 클론하는 방법으로 분류된다.
* 예를 들어, 기존 프로젝트를 깃으로 관리하고자 하는 경우에는 `git init` 명령어를 사용한다.
    * **해당 명령은 `.git`이라는 하위 디렉토리를 생성하며, 해당 디렉토리에는 저장소에 필요한 모든 뼈대가 포함**된다.
    * 이 경우, 초기화 직후에는 프로젝트의 어떤 파일도 관리되지 않으므로 add 명령으로 저장소에 파일을 추가하거나 commit 명령으로 커밋하는 작업이 필요하다.
* 반면 다른 프로젝트에 참여하거나 이미 존재하는 깃 저장소를 복제하려는 경우, `git clone [저장소_url]` 명령을 활용한다.
    * 이를 통해 이미 존재하던 프로젝트의 모든 히스토리를 받아오며, 저장소와 같은 이름의 디렉토리를 만든 후 해당 위치에 `.git` 디렉토리를 생성한다.
    * 이 과정에서 **클론한 프로젝트에는 원격 저장소의 모든 데이터가 포함되며, 자동으로 가장 최신 버전으로 체크아웃되어 즉시 작업을 시작**할 수 있다.
    * 이 경우 깃은 https나 git, ssh 등 여러 프로토콜을 지원하므로 적절한 방법을 선택하여 저장소를 클론할 수 있다.

## 2023-05-15 Mon
### 수정 내역을 깃 저장소에 반영하기
* 프로젝트의 **파일을 수정한 후, 수정 내역을 저장하고 싶은 경우에는 반드시 스냅샷을 커밋**해야 한다.
* 이 때, 워킹 디렉토리의 모든 파일은 크게 Tracked 상태와 Untracked 상태로 분류될 수 있다.
  1. Tracked: 관리 대상이며, 다시 Unmodified와 Modified 및 Staged 상태 중 하나를 갖는다.
  2. Untracked: 관리 대상이 아니며, Tracked 상태가 포함하는 하위 상태를 제외한 모든 파일을 지칭한다.
* 특히, **Untracked 파일은 워킹 디렉토리 상의 파일 중 스냅샷이나 Staging area 양 쪽 모두에 포함되지 않은 파일을 의미**한다.
  * 반면, 원격 저장소를 처음 클론한 직후에는 모든 파일이 Tracked이자 Unmodified 상태를 갖는다.
* 마지막 커밋 이후에 파일을 수정할 경우 깃은 자동으로 수정된 파일을 Modified 상태로 인식한다.
  * 그러나 이러한 **수정 사항을 커밋하기 위해서는 Modified 상태의 파일을 Staged 상태로 전이시킨 후, 이를 커밋시키는 과정을 거쳐야 한다**.

## 2023-05-16 Tue
### 파일의 상태 확인하기, 그리고 임의의 파일을 추적하기
* 워킹 디렉토리의 파일 상태를 확인하고자 하는 경우, `git status` 명령을 아래와 같이 활용할 수 있다.
  * 이 경우, `추적하지 않는 파일`은 스냅샷에 삽입되지 않은 파일로 판단하며 Tracked 상태가 되기 전까지 깃은 절대 해당 파일을 커밋하지 않는다.
```shell
[~] git status
현재 브랜치 master
브랜치가 'origin/master'에 맞게 업데이트된 상태입니다.

추적하지 않는 파일:
  (커밋할 사항에 포함하려면 "git add <파일>..."을 사용하십시오)
        temp.md

커밋할 사항을 추가하지 않았지만 추적하지 않는 파일이 있습니다 (추적하려면 "git add"를 사용하십시오)

[~]
```
* 나아가 `git add [파일명]` 명령을 통해 새로운 파일을 추적할 수 있으며, 해당 명령은 신규 파일에 대해 실행되었을 때 Staged 상태로 전이시킨다.
  * **이러한 명령을 통해 디렉토리 내부의 파일이나 디렉토리를 추적하고 관리하도록 하며, 디렉토리의 경우 하위의 모든 파일까지 재귀적으로 관리**한다.

## 2023-05-17 Wed
### Modified 상태의 파일을 Stage 상태로 전이시키기
* 이미 추적 중인 파일을 수정한 경우, `git status` 명령을 통해 아래와 같이 `수정함` 상태를 확인할 수 있다.
  * 이는 **수정된 파일이 Tracked 상태이나 아직 Staged 상태는 아님을 의미하므로, `git add` 명령을 통해 Staged 상태로 전이시킬 필요**가 있다.
```shell
[~] git status
현재 브랜치 master
브랜치가 'origin/master'에 맞게 업데이트된 상태입니다.

커밋하도록 정하지 않은 변경 사항:
  (무엇을 커밋할지 바꾸려면 "git add <파일>..."을 사용하십시오)
  (use "git restore <file>..." to discard changes in working directory)
        수정함:        Code/Git/Basics001.md
        
[~]
```
* 이 때, **`git add` 명령은 앞서 다룬 바와 같이 파일을 새로 추적하거나 이미 수정된 파일을 Staged 상태로 만들고자 하는 경우 모두에 사용**할 수 있다.
  * 이러한 관점에서, **`git add` 명령은 프로젝트에 새로운 파일을 추가한다기보다는 다음 커밋에 추가한다고 보는 것이 바람직**하다.
* 깃의 특성 상 이미 Staged 상태가 된 파일 A를 추가로 수정할 경우, 해당 파일은 Staged이면서 Unstaged 상태를 동시에 가질 수도 있다.
  * 때문에 **이러한 시점에 커밋을 할 경우, 커밋 시점의 모든 수정 내역이 반영되는 대신 마지막 `git add` 명령 실행 시점의 버전이 커밋**된다.
  * 따라서 이러한 상황에서는 추가로 `git add` 명령을 실행하여 최신 버전의 수정 내역을 Staged 상태로 만들어줄 필요가 있다.

## 2023-05-18 Thu
### Staged 또는 Unstaged 상태의 변경 내용을 확인하기
* 일반적으로 개발자는 수정했으나 아직 Staged 상태가 아닌 것이나, 어떤 파일이 Staged 상태인지 궁금해하므로 `git status` 명령을 사용한다.
  * 반면, 실제로 어떤 라인을 수정하거나 추가했는지가 궁금한 경우에는 `git diff` 명령을 활용해야 한다.
* **`git diff` 명령은 워킹 디렉토리 상의 파일과 Staging area의 파일을 비교하므로, 수정하였지만 아직 Staged 상태는 아닌 파일을 분석**한다.
  * 때문에 커밋하기 위한 Staged 상태의 파일에 대한 변경 부분을 확인하고자 하는 경우, `git diff --staged` 옵션을 활용해야 한다.
  * 같은 용도로 `git diff --cached` 옵션도 활용할 수 있으며, 이는 `--staged` 옵션과 같은 역할을 수행한다.
* 이 때, **`git diff` 명령은 마지막으로 커밋한 이후의 모든 수정 내역을 보여주지 않음에 주의**해야 한다.
  * 해당 명령은 오히려 Unstaged 상태인 수정 사항만을 보여주며, 수정 내역을 모두 Staging area에 삽입했다면 해당 명령은 아무 것도 출력하지 않는다.

## 2023-05-19 Fri
### 변경 사항을 커밋하기
```
> 깃은 Staging area에 속한 스냅샷을 커밋하며, 수정은 했지만 Staging area에 추가하지 않은 파일은 다음 번 커밋에 추가해야 한다.
```
* Unstaged 상태의 파일은 커밋되지 않으므로, 수정된 내역을 커밋하기 위해서는 반드시 Staging area에 추가해야 한다.
  * 예를 들어 깃은 생성되거나 수정된 파일이더라도 `git add` 명령을 사용하지 않은 파일은 커밋하지 않는다.
* `git commit` 명령을 활용할 경우 깃 설정에 정의된 편집기가 실행되며, 커밋 메시지를 입력한 후 저장하는 것으로 새로운 커밋을 추가할 수 있다.

### Staging area의 생략
* **Staging area는 커밋한 파일을 모아둔다는 점에서 유용하지만, 때로는 복잡성만 높이며 필요하지 않은 경우**도 있다.
* 이 경우, `git commit -a` 옵션을 명시하는 것으로 Tracked 상태의 모든 파일을 자동으로 Staging area에 삽입한 후 새로운 커밋을 생성할 수 있다.
  * 즉, 이러한 옵션을 적절히 활용하는 것으로 수정된 파일을 굳이 `git add` 명령을 활용하여 Staging area에 삽입하는 수고를 덜어낼 수 있다.

## 2023-05-20 Sat
### 깃으로부터 파일을 제거하기
* 깃에서 파일을 제거하기 위해서는 `git rm` 명령을 활용할 수 있으며, 이는 Tracked 상태의 파일을 삭제한다.
  * 또한, 해당 명령을 적용할 경우 실제 물리 파일 역시 삭제된다.
  * 때문에 **물리 파일은 제거하지 않고자 하지만 깃이 추적하지 않게 하고 싶은 경우, `git rm --cached` 옵션을 활용**해야 한다.
* **`git rm` 명령을 적용할 경우 삭제한 파일은 Staged 상태가 되며, 이러한 변경 사항을 커밋했을 때 파일은 삭제되고 깃은 이를 더 이상 추적하지 않는다**.
  * 반면, **파일이 수정되었거나 수정된 파일이 Staging area에 추가되었다면 `git rm -f` 옵션을 활용하여 파일을 강제로 삭제**해야 한다.

## 2023-05-21 Sun
### 파일의 이름을 변경하기
```
> 깃은 다른 툴과는 달리 파일 이름 변경에 대한 정보를 별도로 저장하지 않는 대신, 파일 이름의 변경을 알아채기 위한 깃만의 방법을 제공한다.
```
* 깃이 제공하는 `git mv` 명령은 일종의 단축 명령으로, 아래와 같은 일련의 명령어를 입력했을 때와 비교하여 완전히 같은 동작을 수행한다.
  1. mv file file-bk
  2. git rm file
  3. git add file-bk
* 즉, 깃이 추적하는 파일의 이름을 변경하기 위해서는 `git mv` 명령이나 일반적인 mv 명령 중 무엇을 사용해도 무방하다.
  * 그러나 **`git mv` 명령은 필수적인 세 동작을 암시적으로 실행해줄 뿐이며, 이렇듯 이름이 변경된 경우에는 반드시 rm과 add 명령이 수반**되어야 한다.

## 2023-05-22 Mon
### 커밋 내역 조회하기
* 새로운 저장소에 수 차례 커밋했거나, 이미 커밋 히스토리가 있는 저장소를 클론한 경우 저장소의 커밋 내역을 확인하고 싶은 경우가 발생할 수 있다.
  * 이 때, 간단하게 `git log` 명령을 입력하는 것으로 깃의 커밋 내역인 히스토리를 조회할 수 있다.
* 별도의 인자 없이 `git log` 명령을 입력한 경우 시간 순으로 정렬된 커밋 히스토리와 함께 다음의 내용을 확인할 수 있다.
  1. 각 커밋에 대한 SHA-1 체크섬
  2. 커밋 저자
  3. 커밋 날짜
  4. 커밋 메시지
* 또한, `git log` 명령은 원하는 히스토리를 쉽게 검색할 수 있도록 많은 옵션을 제공하며 대표적으로는 다음과 같은 옵션을 사용할 수 있다.
  1. `git log -p -2`: 최근 두 개의 커밋에 대한 diff 결과를 보여준다.
  2. `git log --stat`: 각 커밋에 몇 개의 파일이 수정되거나 추가, 삭제되었는지 등에 대한 통계 정보를 보여준다.
  3. `git log --pretty=oneline`: 각각의 커밋을 한 줄로 표현하며, oneline 대신 short이나 full 등 다양한 옵션을 적용할 수 있다.
* 이 때, 커밋 내역은 커밋의 저자와 커미터를 다음과 같이 구분하여 표기하는 특성이 있다.
  1. 저자: 커밋 대상 작업을 실제로 수행한 원작자를 의미한다.
  2. 커미터: 마지막으로 해당 작업을 저장소에 커밋한 사람을 의미한다.

## 2023-05-23 Tue
### 커밋 내역 제한 조건
* 상술한 출력 형식 관련 옵션 뿐만 아니라, `git log` 명령은 조회 범위를 제한하는 다음과 같은 조건들도 제공한다.
  1. `git log -n`: 최근 n 개의 커밋만을 조회한다.
  2. `git log --since=2.weeks`: --since나 --until과 같은 옵션을 토대로 커밋 시점을 기준으로 조회할 수 있다.
  3. `git log --grep=something`: 커밋 메시지에 포함된 단어를 기준으로 조회할 수 있다.
  4. `git log -- path1`: 임의의 경로에 위치한 파일들의 커밋 내역을 조회할 수 있다.
  5. `git log --Ssomething`: --S 옵션을 활용하여 임의의 단어가 포함된 수정 내역을 조회할 수 있다.

## 2023-05-24 Wed
### amend 옵션 활용하기
```
> 깃을 사용하면 저질러버린 실수 대부분을 복구할 수 있으나, 되돌린 것은 복구할 수 없다.
```
* 이미 **완료한 커밋에 파일을 빠트렸거나, 커밋 메시지를 수정하고자 하는 경우 `git commit --amend` 옵션을 활용**할 수 있다.
  * **해당 명령은 Staging area를 활용하여 커밋을 덮어 쓰므로, 마지막 커밋 이후에 수정한 내역이 없다면 커밋 메시지만을 수정**한다.
  * 이 때, 해당 옵션을 활용한 커밋은 메시지를 수정하지 않더라도 기존 커밋을 덮어 쓴다는 점에 주의를 기울여야 한다.
* `git commit --amend` 옵션은 크게 다음과 같은 용도로 사용될 수 있다.
  1. 마지막 커밋 이후에 수정 내역이 없음에도 해당 명령을 사용할 경우, 커밋 메시지만을 수정한 새로운 커밋으로 마지막 커밋을 덮어 쓴다.
  2. 커밋을 했으나, 해당 커밋에 빠트린 파일이 있을 경우 `git add [빠트린_파일]` 명령을 입력한 후 `git commit --amend` 옵션을 연이어 입력한다.
* 이 때, 빠트린 파일로 인해 --amend 옵션을 활용했다면 이전 커밋과 누락된 파일에 대한 `git add`을 포함한 세 명령은 하나의 커밋으로 기록된다.
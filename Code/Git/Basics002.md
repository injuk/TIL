# Basics
## 2023-05-14 Sun
### 깃 저장소 만들기
* 깃 저장소를 만드는 방법은 크게 기존 프로젝트 또는 디렉토리를 깃 저장소로 만드는 방법과, 원격지에 존재하는 저장소를 클론하는 방법으로 분류된다.
* 예를 들어, 기존 프로젝트를 깃으로 관리하고자 하는 경우에는 `git init` 명령어를 사용한다.
    * **해당 명령은 `.git`이라는 하위 디렉토리를 생성하며, 해당 디렉토리에는 저장소에 필요한 모든 뼈대가 포함**된다.
    * 이 경우, 초기화 직후에는 프로젝트의 어떤 파일도 관리되지 않으므로 add 명령으로 저장소에 파일을 추가하거나 commit 명령으로 커밋하는 작업이 필요하다.
* 반면 다른 프로젝트에 참여하거나 이미 존재하는 깃 저장소를 복제하려는 경우, `git clone [저장소_url]` 명령을 활용한다.
    * 이를 통해 이미 존재하던 프로젝트의 모든 히스토리를 받아오며, 저장소와 같은 이름의 디렉토리를 만든 후 해당 위치에 `.git` 디렉토리를 생성한다.
    * 이 과정에서 **클론한 프로젝트에는 원격 저장소의 모든 데이터가 포함되며, 자동으로 가장 최신 버전으로 체크아웃되어 즉시 작업을 시작**할 수 있다.
    * 이 경우 깃은 https나 git, ssh 등 여러 프로토콜을 지원하므로 적절한 방법을 선택하여 저장소를 클론할 수 있다.

## 2023-05-15 Mon
### 수정 내역을 깃 저장소에 반영하기
* 프로젝트의 **파일을 수정한 후, 수정 내역을 저장하고 싶은 경우에는 반드시 스냅샷을 커밋**해야 한다.
* 이 때, 워킹 디렉토리의 모든 파일은 크게 Tracked 상태와 Untracked 상태로 분류될 수 있다.
  1. Tracked: 관리 대상이며, 다시 Unmodified와 Modified 및 Staged 상태 중 하나를 갖는다.
  2. Untracked: 관리 대상이 아니며, Tracked 상태가 포함하는 하위 상태를 제외한 모든 파일을 지칭한다.
* 특히, **Untracked 파일은 워킹 디렉토리 상의 파일 중 스냅샷이나 Staging area 양 쪽 모두에 포함되지 않은 파일을 의미**한다.
  * 반면, 원격 저장소를 처음 클론한 직후에는 모든 파일이 Tracked이자 Unmodified 상태를 갖는다.
* 마지막 커밋 이후에 파일을 수정할 경우 깃은 자동으로 수정된 파일을 Modified 상태로 인식한다.
  * 그러나 이러한 **수정 사항을 커밋하기 위해서는 Modified 상태의 파일을 Staged 상태로 전이시킨 후, 이를 커밋시키는 과정을 거쳐야 한다**.

## 2023-05-16 Tue
### 파일의 상태 확인하기, 그리고 임의의 파일을 추적하기
* 워킹 디렉토리의 파일 상태를 확인하고자 하는 경우, `git status` 명령을 아래와 같이 활용할 수 있다.
  * 이 경우, `추적하지 않는 파일`은 스냅샷에 삽입되지 않은 파일로 판단하며 Tracked 상태가 되기 전까지 깃은 절대 해당 파일을 커밋하지 않는다.
```shell
[~] git status
현재 브랜치 master
브랜치가 'origin/master'에 맞게 업데이트된 상태입니다.

추적하지 않는 파일:
  (커밋할 사항에 포함하려면 "git add <파일>..."을 사용하십시오)
        temp.md

커밋할 사항을 추가하지 않았지만 추적하지 않는 파일이 있습니다 (추적하려면 "git add"를 사용하십시오)

[~]
```
* 나아가 `git add [파일명]` 명령을 통해 새로운 파일을 추적할 수 있으며, 해당 명령은 신규 파일에 대해 실행되었을 때 Staged 상태로 전이시킨다.
  * **이러한 명령을 통해 디렉토리 내부의 파일이나 디렉토리를 추적하고 관리하도록 하며, 디렉토리의 경우 하위의 모든 파일까지 재귀적으로 관리**한다.

## 2023-05-17 Wed
### Modified 상태의 파일을 Stage 상태로 전이시키기
* 이미 추적 중인 파일을 수정한 경우, `git status` 명령을 통해 아래와 같이 `수정함` 상태를 확인할 수 있다.
  * 이는 **수정된 파일이 Tracked 상태이나 아직 Staged 상태는 아님을 의미하므로, `git add` 명령을 통해 Staged 상태로 전이시킬 필요**가 있다.
```shell
[~] git status
현재 브랜치 master
브랜치가 'origin/master'에 맞게 업데이트된 상태입니다.

커밋하도록 정하지 않은 변경 사항:
  (무엇을 커밋할지 바꾸려면 "git add <파일>..."을 사용하십시오)
  (use "git restore <file>..." to discard changes in working directory)
        수정함:        Code/Git/Basics001.md
        
[~]
```
* 이 때, **`git add` 명령은 앞서 다룬 바와 같이 파일을 새로 추적하거나 이미 수정된 파일을 Staged 상태로 만들고자 하는 경우 모두에 사용**할 수 있다.
  * 이러한 관점에서, **`git add` 명령은 프로젝트에 새로운 파일을 추가한다기보다는 다음 커밋에 추가한다고 보는 것이 바람직**하다.
* 깃의 특성 상 이미 Staged 상태가 된 파일 A를 추가로 수정할 경우, 해당 파일은 Staged이면서 Unstaged 상태를 동시에 가질 수도 있다.
  * 때문에 **이러한 시점에 커밋을 할 경우, 커밋 시점의 모든 수정 내역이 반영되는 대신 마지막 `git add` 명령 실행 시점의 버전이 커밋**된다.
  * 따라서 이러한 상황에서는 추가로 `git add` 명령을 실행하여 최신 버전의 수정 내역을 Staged 상태로 만들어줄 필요가 있다.
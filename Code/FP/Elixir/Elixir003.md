# Elixir
## 2025-10-15 Wed
### 모듈 활용하기
* **모듈은 모듈 내에 정의된 내용에 대한 네임 스페이스로서 기능하며, 함수 뿐만 아니라 매크로나 구조체 또는 다른 모듈까지도 포함이 가능**하다.
    * 이 때, 모듈 내에 정의된 함수를 모듈 밖에서 참조하기 위해서는 함수명 앞에 모듈 이름을 명시해줄 필요가 있다.
    * 반면, 동일한 모듈 내에 위치한 함수를 호출하는 경우에는 모듈 이름을 명시해줄 필요가 없다.
* **엘릭서의 경우 코드 가독성 및 재사용성을 위해 중첩 모듈을 정의할 수 있으나, 실제로는 모든 모듈이 최상위에 정의**된다.
    * 즉, 코드 상에서는 모듈이 중첩된 것처럼 보이더라도 엘릭서 내부적으로는 그저 모듈 이름들을 온점(.)으로 연결한 것에 지나지 않는다.

## 2025-10-16 Thu
### 모듈의 세 가지 지시자
* **엘릭서에서는 다른 모듈을 참조하기 위해 다음과 같은 세 가지 지시자 중 하나를 고려할 수 있으며, 이들은 모두 프로그램 시작 시점부터 함께 실행**된다.
    1. `import`: 다른 모듈의 함수나 매크로를 현재 스코프로 가져오며, 원하는 함수만 가져오거나 원하지 원하지 않는 함수를 빼고 동작시킬 수 있다.
    2. `alias`: 임의의 모듈에 별칭을 생성하므로 타이핑의 수고를 덜 수 있다.
    3. `require`: 주로 다른 모듈에 정의된 매크로를 호출하기 위해 사용된다.
* 이러한 **지시자의 효과는 지시자가 명시된 지점부터 코드를 감싼 블록이 유효한 동안 렉시컬 스코프로서 기능**한다.
    * 다시 말해 **지시자를 모듈 내에 정의한 경우 해당 모듈의 정의가 끝나기 전까지, 함수에 정의한 경우 함수 정의가 끝날 때까지만 유지**된다.
* 이 때, **`import` 지시자는 가능한 한 작은 스코프에서 `only`나 `except`를 활용하여 필요한 함수만 가져올 것이 권장**된다.
* `alias [모듈명], as: MyModule` 형태로 작성할 경우, `as:` 뒤에 작성된 `MyModule`이라는 단어로 해당 모듈을 참조할 수 있게 된다.
    * 반면, **여러 모듈에 대한 별칭을 생성하는 경우 `alias My.Module.{Parser, Runner}`와 같은 형태의 참조를 작성해도 무방**하다.

## 2025-10-17 Fri
### 모듈 속성이란?
```
> 모듈 속성은 일반 변수와 달리 컴파일 시점에 값이 결정되며, 상수보다는 설정이나 메타데이터 용도로만 사용되어야 한다.
```
* 엘릭서의 각 모듈은 메타데이터를 가질 수 있으며, 이 때 메타데이터를 이루는 각 항목을 모듈 속성이라는 용어로 지칭한다.
    * **속성은 `@author "John Wick"`과 같이 이름과 값을 갖는, 일종의 키-값 쌍으로 이해**할 수 있다.
* **모듈 속성은 모듈의 최상위에서만 사용 가능하며, 모듈에 포함된 기명 함수 정의 내에서는 모듈 속성의 값을 읽을 수는 있으나 쓸 수는 없다**.
* 반면, 동일한 모듈 이름에 대해 값을 여러 번 설정할 수도 있으며 함수는 함수가 정의된 시점의 모듈 속성 값으로 설정된다.

## 2025-10-18 Sat
### 모듈의 내부적인 이름 설정
* **엘릭서 모듈은 대부분 `PascalCase`로 작성되며, 내부적으로 모듈의 이름은 항상 아톰으로 처리**된다.
    * 같은 이유에서, **대문자로 시작하는 모듈 이름은 엘릭서 내부적으로 `:"Elixir.[모듈명]"`과 같은 아톰으로 변경**된다.
    * 예를 들어, `IO` 모듈은 내부적으로 `:"Elixir.IO"` 와 같은 아톰으로 변경된다.
* 즉, 모듈 안에 있는 함수를 호출하는 일련의 코드는 실제로는 아톰 뒤에 온점('.')을 출력한 후 함수 이름을 이어 붙인 형태로 이해할 수 있다.
    * 예를 들어, `IO.puts 42`는 아톰을 활용한 `:"Elixir.IO".puts 42`과 같은 형태의 함수 호출로 동일한 기능을 수행할 수 있다.

## 2025-10-19 Sun
### 얼랭 라이브러리와 통합하기
```text
> 엘릭서는 기본적으로 얼랭 라이브러리와 잘 통합되지만, 얼랭 라이브러리의 문서는 얼랭 컨벤션을 따름에 주의할 필요가 있다.
```
* **얼랭의 명명 규칙은 엘릭서와 다른 부분이 있으며, 예를 들어 얼랭은 변수 이름은 대문자로 시작하되 아톰은 소문자로 시작**한다.
    * 즉, **얼랭에서 `tomato`라는 문자열을 작성할 경우 엘릭서 상에서는 `:tomato`와 같은 아톰으로 표기해주어야 한다**.
    * 때문에 **얼랭의 경우 `timer` 모듈은 `timer`라는 아톰을 그대로 사용할 수 있으나, 엘릭서에서는 `:timer`와 같은 아톰으로 호출**해줄 필요가 있다.
    * 같은 이유에서 얼랭의 `format` 모듈을 엘릭서에서 호출할 경우 코드를 다음과 같이 작성할 수 있다.
```elixir
:io.format("The number is ~3.1f~n", [5.678])
# The number is 5.7
# :ok
```

## 2025-10-20 Mon
### 리스트의 구성 요소와 파이프 연산자
```
> 전통적인 언어에서는 리스트를 순회 대상으로 여겼지만, 문제를 올바른 방식으로 바라본다면 재귀야말로 링크드 리스트를 다루는 최적의 도구임을 알 수 있다.
```
* 앞서 다룬 바와 같이, 리스트는 비어있거나 머리와 꼬리로 구성된 두 가지 형태를 가질 수 있다.
    * 이 때, **머리는 값을 담는 반면 꼬리는 머리를 제외한 나머지 값을 포함하는 리스트를 지칭**하며 이 자체로 리스트를 재귀적으로 정의한 것이 된다.
* 기본적인 리스트는 `[1, 2]`의 형태를 띄지만, 머리와 꼬리를 명시적으로 `|` 연산자로 구분하는 `[1 | [2]]` 형태 역시 올바른 리스트 리터럴에 해당한다.
    * 이 때, `|` 뒤의 `[2]`는 꼬리 부분을 의미하게 된다.
    * 이렇듯 **파이프 연산자는 함수의 출력을 다음 함수의 입력으로 전달하는 것 뿐만 아니라 리스트의 머리와 꼬리를 구분하는 용도로도 사용**할 수 있다.
```elixir
Enum.map [1 | [2]], &(&1 * 2) # [2, 4]가 반환된다.
```
* 또한, 길이가 1인 리스트를 예로 들었을 때 해당 리스트는 머리에 값이 저장되고 꼬리가 빈 리스트로 구성되어 있기에 다음과 같은 표기가 가능하다.
```elixir
inspect [1 | []] # [1]이 출력된다.
```
* 리스트의 머리와 꼬리를 구분하는 용도로 사용되는 파이프 연산자는 다음과 같이 패턴 매칭에도 적용이 가능하다.
```elixir
[head | tail] = [1,2,3,4,5]
IO.puts "#{inspect head}" # 1이 출력된다.
IO.puts "#{inspect tail}" # [2,3,4,5]가 출력된다.
```

## 2025-10-21 Tue
### 머리와 꼬리를 활용한 리스트의 처리
* **리스트를 머리와 꼬리로 나눌 수 있다면, 이렇게 나누어진 값과 리스트를 각각 활용하여 새로운 리스트를 생성할 수 있게 된다**.
* 엘릭서 상에서 리스트와 재귀 함수는 뗼 수 없는 관계에 있으며, 둘을 조합하여 다음과 같이 리스트를 순회하는 연산을 손쉽게 구현하는 것이 가능하다.
```elixir
defmodule MyListV1 do
  def len([]), do: 0
  def len([_head|tail]), do: 1 + len(tail)
end
```
* 상술한 `len` 함수의 경우 비어 있는 리스트와 그렇지 않은 리스트 각각에 매칭되는 본문을 가지며, 리스트의 꼬리를 다음 재귀에 전달하는 방식으로 동작한다.
* 이렇듯 머리와 꼬리를 기반으로 동작하는 재귀 함수의 경우, 함수의 반환 값에 `|` 연산자를 적절히 활용하는 것으로 마치 `Enum.map` 같은 효과를 낼 수 있다.
    * 아래의 코드는 임의의 리스트를 받아 이를 재귀적으로 연산한 결과를 다시 리스트로 반환하는 예시에 해당한다.
```elixir
defmodule MyListV2 do
  def square([]), do: []
  def square([head|tail]), do: [head * head | square(tail)]
end
```

## 2025-10-22 Wed
### 재귀를 활용한 나만의 map 함수 작성하기
* 상술한 `len`과 `square`는 머리와 꼬리를 나누어 재귀적인 연산을 적용한다는 점에서 공통점이 있으며, 이는 다음과 같이 추상화할 수 있다.
```elixir
defmodule MyListV3 do
  def my_map([], _func), do: []
  def my_map([head|tail], func), do: [func.(head) | my_map(tail, func)]
end
```
* 첫 번째 구현의 경우 빈 리스트를 반환하므로 두번째 인자인 `func`를 버리기 위해 `_` 기호를 명시하는 반면, 두 번째 구현은 상술했던 구현 방식을 추상화한다.
    * 이 때, 두 번째 인자에는 익명 함수가 전달되므로 `fn (x) -> x * x end` 또는 `&(&1 * &1)` 등을 전달할 수 있다.

## 2025-10-23 Thu
### 리스트에서 조인 연산자를 사용하는 또 다른 방법
* 조인 연산자인 `|`는 연산자 왼쪽에 `head`를 두는 방법 외에도 여러 값을 둘 수 있도록 하며, 이로 인해 다음과 같은 표기 역시 유효하다.
```elixir
list = [ 1, 2, 3 | [ 4, 5, 6 ] ]
 IO.puts "#{inspect list}" # [1, 2, 3, 4, 5, 6]이 출력된다.
```
* 이는 패턴 매칭에서도 동일하게 동작하며, 조인 연산자의 앞 부분에 여러 값을 한 번에 매칭하기 위해서는 다음과 같은 함수를 예로 들 수 있다.
    * 특히 함수의 두 번쨰 구현은 여러 값을 한 번에 매칭하는 방식으로 동작한다.
```elixir
defmodule Swapper do
  def swap([]), do: []
  def swap([a, b|tail]), do: [b, a | swap(tail)] # 패턴 매칭을 활용하여 한 번에 여러 값을 매칭한다.
  def swap([_]), do: raise "list contains odd number of elements"
end
```

## 2025-10-24 Fri
### 패턴 내에서 패턴 매칭을 활용하기
* 아래와 같은 모듈이 있다고 가정했을 때, `test_data`는 데이터 그 자체를 의미하는 반면 `for_location`은 두 번째 인자를 기준으로 필터링한다.
```elixir
defmodule WeatherHistory do
  def test_data do
    [
      [1366225622, 26, 15, 0.125],
      [1366225622, 27, 15, 0.45],
      [1366225622, 28, 21, 0.25],
      [1366229222, 26, 19, 0.081],
      [1366229222, 27, 17, 0.468],
      [1366229222, 28, 15, 0.60],
      [1366232822, 26, 22, 0.095],
      [1366232822, 27, 21, 0.05],
      [1366232822, 28, 24, 0.03],
      [1366236422, 26, 17, 0.025],
    ]
  end

  def for_location([], _location_number), do: []
  def for_location([[time, location_number, temp, rain]|tail], location_number), do: [[time, location_number, temp, rain]|for_location(tail, location_number)]
  def for_location([_|tail], location_number), do: for_location(tail, location_number)
end
```
* 반면, `for_location`의 두 번째 구현은 `location_number` 이외의 세 값을 불필요하게 패턴 매칭하므로 이를 아래와 같이 개선할 수 있다.
```elixir
defmodule WeatherHistory do
  # ...생략
  def for_location([], _location_number), do: []
  def for_location([head = [_, location_number, _, _]|tail], location_number), do: [head|for_location(tail, location_number)]
  def for_location([_|tail], location_number), do: for_location(tail, location_number)
end
```
* 이는 **엘릭서의 패턴 매칭이 재귀적이기 떄문에 가능한 것으로, 패턴 내에서도 패턴 매칭을 수행하는 것으로 상술한 리팩토링을 적용**할 수 있다.
    * 즉, 해당 패턴 매칭은 복합 리스트에서 두 번째 값을 기준으로 매칭하되 리스트의 머리는 전부 `head`라는 변수에 매칭한 것으로 해석할 수 있다. 

## 2025-10-25 Sat
### Elixir와 딕셔너리
* 딕셔너리는 키-값 쌍 형태로 구성되는 데이터 자료형을 지칭하며, 엘릭서의 경우 다음과 같은 예시들이 딕셔너리에 해당한다.
    1. 맵
    2. 키워드 리스트
    3. 구조체
* 이 때, 여러 딕셔너리 중 다음과 같은 기준에 따라 용도에 맞는 딕셔너리를 선택하는 것이 바람직하다.
    1. 내용을 기준으로 패턴 매칭하고자 하는 경우, 맵을 사용한다.
    2. 같은 키로 여러 항목을 저장해야 하거나, 요소들의 순서가 중요한 경우에는 키워드 리스트를 사용한다.
    3. 데이터의 구조가 항상 동일하여 매 번 같은 필드 목록을 사용하게 되는 경우, 구조체를 사용한다.
* 반면, **위 세 가지 기준 중 어느 것도 만족하지 않는 요구사항의 경우에는 기본적으로 맵을 고려**한다.

## 2025-10-26 Sun
### Keyword 모듈을 활용한 키워드 리스트 접근
* 일반적으로 함수에 옵션을 전달하기 위해 사용되는 키워드 리스트는 `키워드_리스트[:키_이름]` 형태의 문법으로 데이터에 쉽게 접근할 수 있다.
* 반면, 엘릭서는 키워드 리스트의 데이터를 손쉽게 활용할 수 있도록 `Keyword` 모듈을 제공하며 예를 들어 다음과 같은 기능들을 사용할 수 있다.
    1. `Keyword.merge`: 두 키워드 리스트를 인자로 받아 합치되, 첫번째 인자의 리스트와 두번째 인자의 리스트에 겹치는 값이 있을 경우 덮어쓴다.
    2. `Keyword.get`: 첫 번째 인자로 전달된 리스트에서 두 번째 인자로 전달된 키 값을 찾아 반환한다.
    3. `Keywor.get_values`: 키워드 리스트는 동일한 키에 대해 여러 항목을 허용하므로, 임의의 키에 대응되는 모든 값을 리스트 형태로 반환한다.
* 이 때, `Keyword.get`의 경우 해당하는 값이 없다면 `nil`이 반환되는 반면 세 번째 인자에 기본 값을 적용할 수도 있다.
    * 이 경우, 대응되는 키에 해당하는 값이 없을 때 `nil` 대신 기본값이 반환된다.
* 또한, **키워드 리스트에 동일한 키를 갖는 데이터가 여럿 있을 경우 `키워드_리스트[:키_이름]` 형태의 접근은 첫 번째로 대응되는 값 하나만을 반환**한다.
    * 이는 `Keyword.get` 역시 마찬가지이며, 여러 값을 리스트 형태로 반환받기 위해서는 상술한 `Keyword.get_values`를 사용해야 한다.

## 2025-10-27 Mon
### Elixir와 맵의 구현체
* 엘릭서의 경우, 맵은 크기와 관계 없이 좋은 성능을 내는 자료 구조이며 `Map` 모듈의 API를 통해 데이터에 대한 손쉬운 접근이 가능하다.
* **엘릭서의 맵은 저장된 키의 개수에 대해 32 개를 기준으로 작은 맵과 큰 맵을 구분하여 서로 다른 구현을 제공하고, 자동으로 전환**하기도 한다.
    * 이 때, 작은 맵은 정렬된 배열처럼 저장하는 `Flat Map`을 사용하는 반면 큰 맵은 트리 구조를 활용하는 `Hash Array Mapped Trie`를 적용한다.
    * 성능적으로 보았을 때 두 자료 구조는 각각 `O(n)`과 `O(log32n)`의 성능을 제공하지만, `Flat Map`의 경우 `n`이 매우 작아 좋은 성능을 보장한다.
    * 반면, 이러한 내용은 어디까지나 추후에 변경될 수 있는 세부 구현에 해당하므로 32라는 숫자에 의존적으로 코드를 작성하는 것은 권장되지 않는다.

## 2025-10-28 Tue
### Map 모듈을 활용한 맵 접근
* 맵의 경우, 키워드 리스트와 유사한 `맵[:키_이름]` 형태의 문법뿐만 아니라 `맵.키_이름` 형태의 데이터 접근을 허용한다.
    * 반면, **존재하지 않는 키에 대해서 전자는 `nil`을 반환하는 반면 후자는 `KeyError`가 발생하는 점에 유의**해야 한다.
* 키워드 리스트가 `Keywork` 모듈과 함께 사용될 수 있는 것처럼 맵은 `Map` 모듈의 다음과 같은 여러 기능과 함께 활용될 수 있다.
    1. `Map.keys`: 맵에 할당된 모든 키 목록을 리스트 형태로 반환한다.
    2. `Map.values`: 맵에 할당된 모든 값 목록을 리스트 형태로 반환한다.
    3. `Map.drop`: 맵의 키를 하나 이상 제거한 새로운 맵을 반환한다.
    4. `Map.put`: 맵에 임의의 키-값 쌍을 추가한 새로운 맵을 반환한다.
    5. `Map.has_key?`: 맵에 임의의 키가 존재하는지 여부를 반환한다.
    6. `Map.pop`: 맵으로부터 임의의 키를 `pop`하고, 해당 키-값 쌍이 제거된 새로운 맵을 반환한다.
    7. `Map.equal?`: 두 맵이 동등한지 여부를 반환한다.

## 2025-10-29 Wed
### 엘릭서 코드 컨벤션 - 접미사로 사용된 ?와 !
* 엘릭서 모듈이 제공하는 대부분의 함수는 `lower_snake_case`로 작성된 것 이외에는 별다른 특징이 없으나, 몇몇 함수는 `?` 또는 `!` 접미사를 갖는다.
* 이러한 두 기호는 함수 명의 일부인 점에서 공통점이 있지만, 각각 다음과 같은 의미를 갖는다는 점에서 차이가 있다.
    1. `?` 접미사: 함수가 `boolean`을 반환한다는 점을 명시한다.
    2. `!` 접미사: 함수가 예외를 발생시킬 수 있다는 점을 명시한다.
* 이는 **엘릭서 생태계에서 통용되는 일종의 커뮤니티 컨벤션으로, 엘릭서 문법 차원의 제약은 아니지만 함수의 용도에 따라 준수하는 것이 강력히 권장**된다.
    * 즉, 준수하지 않더라도 엘릭서 컴파일러는 문제라고 판단하지 않지만 커뮤니티에 속한 개발자들 입장에서는 코드 리뷰의 대상이 될 수 있다.

## 2025-10-30 Thu
### 맵과 패턴 매칭
* 맵에 임의의 키가 존재하는지 확인하는 것은 `Map` 모듈을 활용할 수도 있으나, 엘릭서의 핵심인 패턴 매칭을 활용할 수도 있다.
```elixir
map = %{ name: "Dave", age: 42 }
%{ name: a_name } = map
IO.puts a_name # Dave가 출력된다.
```
* 반면, 맵의 패턴 매칭은 다음과 같은 점에서 앞서 다루었던 패턴 매칭과는 약간의 차이를 갖는다.
    1. 맵의 전체 데이터를 패턴 매칭할 필요가 없다.
    2. 패턴 매칭에 명시한 키는 AND 조건으로 매칭된다.
* 예를 들어, 다음과 같이 리스트와 맵의 패턴 매칭 코드를 작성하여 실행 결과를 비교했을 때 맵의 패턴 매칭의 특징을 확인해볼 수 있다.
```elixir
list = [1, 2]
[a] = list # (MatchError) no match of right hand side value: [1, 2], 리스트의 일부만을 패턴 매칭할 수 없다.

map = %{ name: "Dave", age: 42 }
%{ name: a_name } = map # 맵의 일부 데이터만으로도 매칭이 가능하다.

%{ name: a_name, age: _ } = map # 여러 키의 경우 AND 조건으로 매칭하므로 name과 age 모두가 존재하는 경우에만 매칭된다.

%{ name: a_name, height: _ } = map # (MatchError) no match of right hand side value: %{name: "Dave", age: 42}, height는 존재하지 않는 키이므로 매칭되지 않는다.
```

## 2025-10-31 Fri
### 맵과 구조 분해 문법
* 다음과 같은 코드에서 확인할 수 있듯, 구조 분해 문법을 활용하면 맵에 저장된 임의의 키에 대응되는 값을 추출할 수 있다.
```elixir
map = %{ name: "Dave", age: 42 }
%{ name: name } = ma
IO.puts name # Dave가 출력된다.
```
* 이는 `:name`에 대응되는 값인 `Dave`를 구조 분해한 것인 반면, 다음과 같이 **값에 대응되는 키를 구조 분해할 수는 없음에 주의**해야 한다.
    * 에러 메시지에서 알 수 있듯, 맵의 패턴 매칭 과정에서 키에 대해 패턴을 적용할 수 없다.
    * 또한, 아래의 코드와 같이 **맵을 정의하는 과정에서는 키에 변수를 적용할 수 있으나 패턴 매칭 시에는 키에 패턴을 적용할 수 없다는 점을 기억**해야 한다.
```elixir
%{ something => "Dave" } = map # error: cannot use variable something as map key inside a pattern.

name = "name"
age = "age"
map2 = %{ name => "Dave", age => 42 }
IO.puts "#{inspect map2}" # %{"age" => 42, "name" => "Dave"} 가 출력된다.
```

## 2025-11-01 Sat
### 핀 연산자를 활용한 키 매칭
* **핀 연산자는 매칭시 패턴을 의미하는 좌항에 변수가 존재하는 경우, 그 변수에 매칭된 값을 이번 매칭에 사용하도록 지원**한다.
    * 이를 활용할 경우, 다음과 같이 패턴 매칭에 변수의 값을 사용하는 코드를 작성해볼 수 있다.
```elixir
defmodule Playground do
  def data do
    %{ name: "Dave", state: "TX", like: "Elixir" }
  end

  def show() do
    for key <- [:name, :like] do
      %{ ^key => value } = Playground.data # 핀 연산자가 없다면 키에 대한 패턴 매칭으로 취급되므로 컴파일 에러가 발생한다.
      value
    end
  end
end
```

## 2025-11-02 Sun
### 맵에 저장된 값을 수정하기
* 맵은 다음과 같이 `|`과 같은 파이프 기호를 사용하거나, `Map.put/3`과 같은 함수를 통해 수정할 수 있다.
    * 반면, 엘릭서의 다른 모든 것들이 그렇듯 맵 역시 불변 데이터이기에 상술한 모든 방식의 결과는 새로운 맵이 된다.
```elixir
map1 = %{ a: 1, b: 2, c: 3 }
IO.puts "#{inspect map1}" # %{c: 3, a: 1, b: 2}가 출력된다.

map2 = %{ map1 | b: 42 }
IO.puts "#{inspect map1}" # 여전히 %{c: 3, a: 1, b: 2}가 출력된다.
IO.puts "#{inspect map2}" # %{c: 3, a: 1, b: 42}가 출력된다.

map3 = Map.put map1, :a, 42
IO.puts "#{inspect map1}" # 여전히 %{c: 3, a: 1, b: 2}가 출력된다.
IO.puts "#{inspect map3}" # %{c: 3, a: 42, b: 2가 출력된다.
```
* 이 때, 파이프 기호를 활용한 방식은 수정이기 때문에 신규 키-값 쌍을 추가할 수 없다.
* 반면, `Map.put/3` 함수는 삽입과 수정에 모두 사용될 수 있다는 점에서 파이프 기호를 활용하는 방식과는 차이가 있다.
  * 유사한 함수로 `Map.put_new/3` 함수가 있으나, 이는 새로운 값은 추가하되 이미 존재하지 않는 값은 덮어 쓰지 않는다는 점에서 `Map.put/3`과 다르다.

## 2025-11-03 Mon
### 구조체란?
* 엘릭서의 맵은 키-값 형태의 자료를 담는 자료 구조이지만, 때로는 다음과 같은 구현이 필요한 경우가 있을 수 있다.
    1. 항상 같은 구조를 보장해야 하는 경우
    2. 또는 임의의 자료 구조에 맞는 로직을 작성하고자 하는 경우
    3. 또는 맵 그 자체로 패턴 매칭하고자 하는 경우
* 이 경우에는 **구조체를 고려할 수 있으나, 엘릭서의 구조체는 별도의 타입이 아닌 조금 더 제한적인 형태의 맵을 모듈로 감싼 것을 의미**한다.
    * 예를 들어, 모든 타입의 값을 키로 삼을 수 있는 맵과 달리 아톰만을 키로 사용할 수 있다.
    * 이러한 구조체는 다음과 같이 모듈과 `defstruct` 매크로를 활용하여 다음과 같이 활용하는 것이 가능하다.
```elixir
defmodule Subscriber do
  defstruct name: "", paid: false, over_18: true
end

s1 = %Subscriber{ name: "Dave" }
IO.puts s1.name # Dave가 출력된다.

%{ name: name } = s1
IO.puts name # Dave가 출력된다.
%Subscriber{ name: name } = s1
IO.puts name # Dave가 출력된다.

IO.puts "#{inspect s1}" # %Subscriber{name: "ingnoh", paid: false, over_18: true} 가 출력된다.

s2 = %Subscriber{ s1 | paid: true }
IO.puts "#{inspect s2}" # %Subscriber{name: "ingnoh", paid: true, over_18: true} 가 출력된다.
```
* 상술한 코드를 통해 엘릭서의 구조체 활용법을 정리해보았을 때, 구조체는 맵과 다음과 같은 차이점을 보인다.
    1. 생성시 `%{}` 형태가 아닌 `%모듈명{}` 형태로 작성한다.
* 반면, 구조체와 맵은 사용성 측면에서 다음과 같은 공통점을 갖는다.
    1. 구조 분해가 가능하며, 이 경우 모듈명은 명시하거나 하지 않더라도 모두 사용 가능하다.
    2. 필드에는 `.`과 같은 온점 연산자로 접근이 가능하다.
    3. 수정 시에도 맵과 동일하게 파이프 기호를 활용할 수 있다.

## 2025-11-04 Tue
### 구조체와 Map 모듈
* 앞서 다룬 바와 같이, 구조체는 제한적인 형태임에도 엄연한 맵이므로 엘릭서의 빌트인 모듈인 `Map`을 활용할 수 있다.
    * 예를 들어, `Map.keys`나 `Map.values`와 같은 읽기 전용 작업들은 사실상 문제를 일으키지 않는다.
* 그러나 **맵의 형태를 변경하는 함수를 구조체에 적용할 경우, 필드 변동으로 인해 구조체 형태가 깨져 일반 맵이 될 수 있음에 주의**해야 한다.
    * 예를 들어, `Map.merge`나 `Map.delete`와 같이 맵에 필드를 추가하거나 제거하는 함수들이 그 예시에 해당한다.
* 이렇듯 **구조체의 타입 안정성을 유지하기 위해서는 구조체에 별도의 함수를 정의하는 식으로 안전하게 조작하는 방법을 제공하는 것이 바람직**하다.

## 2025-11-05 Wed
### 구조체와 함수
* 객체지향 프로그래밍 언어에서, 임의의 클래스가 제공하는 멤버 메소드 내에서 자신의 멤버 변수에 접근해야하는 경우에는 `this` 키워드를 사용한다.
* 그러나 **엘릭서는 `this` 참조와 같은 기능이 없으므로, 구조체 전용 모듈에서 메소드같은 함수를 제공하더라도 항상 인자에 구조체를 전달받아야** 한다.
* 이는 **불변성과 패턴 매칭을 사용하기 위한 언어 설계이므로, 구조체 설계시에는 객체지향 프로그래밍 방식으로 사고하는 습관에서 벗어나는 것이 바람직**하다.
    * 즉, **이러한 방식은 엘릭서가 데이터와 동작을 분리하고 이를 명시적으로 다루기 위한 방법에 해당**한다.

## 2025-11-06 Thu
### Elixir와 딕셔너리
* 딕셔너리는 키-값 쌍 형태로 구성되는 데이터 자료형을 지칭하며, 엘릭서의 경우 다음과 같은 예시들이 딕셔너리에 해당한다.
    1. 맵
    2. 키워드 리스트
    3. 구조체
* 이 때, 여러 딕셔너리 중 다음과 같은 기준에 따라 용도에 맞는 딕셔너리를 선택하는 것이 바람직하다.
    1. 내용을 기준으로 패턴 매칭하고자 하는 경우, 맵을 사용한다.
    2. 같은 키로 여러 항목을 저장해야 하거나, 요소들의 순서가 중요한 경우에는 키워드 리스트를 사용한다.
    3. 데이터의 구조가 항상 동일하여 매 번 같은 필드 목록을 사용하게 되는 경우, 구조체를 사용한다.
* 반면, **위 세 가지 기준 중 어느 것도 만족하지 않는 요구사항의 경우에는 기본적으로 맵을 고려**한다.

## 2025-11-07 Fri
### Keyword 모듈을 활용한 키워드 리스트 접근
* 일반적으로 함수에 옵션을 전달하기 위해 사용되는 키워드 리스트는 `키워드_리스트[:키_이름]` 형태의 문법으로 데이터에 쉽게 접근할 수 있다.
* 반면, 엘릭서는 키워드 리스트의 데이터를 손쉽게 활용할 수 있도록 `Keyword` 모듈을 제공하며 예를 들어 다음과 같은 기능들을 사용할 수 있다.
    1. `Keyword.merge`: 두 키워드 리스트를 인자로 받아 합치되, 첫번째 인자의 리스트와 두번째 인자의 리스트에 겹치는 값이 있을 경우 덮어쓴다.
    2. `Keyword.get`: 첫 번째 인자로 전달된 리스트에서 두 번째 인자로 전달된 키 값을 찾아 반환한다.
    3. `Keywor.get_values`: 키워드 리스트는 동일한 키에 대해 여러 항목을 허용하므로, 임의의 키에 대응되는 모든 값을 리스트 형태로 반환한다.
* 이 때, `Keyword.get`의 경우 해당하는 값이 없다면 `nil`이 반환되는 반면 세 번째 인자에 기본 값을 적용할 수도 있다.
    * 이 경우, 대응되는 키에 해당하는 값이 없을 때 `nil` 대신 기본값이 반환된다.
* 또한, **키워드 리스트에 동일한 키를 갖는 데이터가 여럿 있을 경우 `키워드_리스트[:키_이름]` 형태의 접근은 첫 번째로 대응되는 값 하나만을 반환**한다.
    * 이는 `Keyword.get` 역시 마찬가지이며, 여러 값을 리스트 형태로 반환받기 위해서는 상술한 `Keyword.get_values`를 사용해야 한다.
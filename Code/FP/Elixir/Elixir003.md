# Elixir
## 2025-10-15 Wed
### 모듈 활용하기
* **모듈은 모듈 내에 정의된 내용에 대한 네임 스페이스로서 기능하며, 함수 뿐만 아니라 매크로나 구조체 또는 다른 모듈까지도 포함이 가능**하다.
    * 이 때, 모듈 내에 정의된 함수를 모듈 밖에서 참조하기 위해서는 함수명 앞에 모듈 이름을 명시해줄 필요가 있다.
    * 반면, 동일한 모듈 내에 위치한 함수를 호출하는 경우에는 모듈 이름을 명시해줄 필요가 없다.
* **엘릭서의 경우 코드 가독성 및 재사용성을 위해 중첩 모듈을 정의할 수 있으나, 실제로는 모든 모듈이 최상위에 정의**된다.
    * 즉, 코드 상에서는 모듈이 중첩된 것처럼 보이더라도 엘릭서 내부적으로는 그저 모듈 이름들을 온점(.)으로 연결한 것에 지나지 않는다.

## 2025-10-16 Thu
### 모듈의 세 가지 지시자
* **엘릭서에서는 다른 모듈을 참조하기 위해 다음과 같은 세 가지 지시자 중 하나를 고려할 수 있으며, 이들은 모두 프로그램 시작 시점부터 함께 실행**된다.
    1. `import`: 다른 모듈의 함수나 매크로를 현재 스코프로 가져오며, 원하는 함수만 가져오거나 원하지 원하지 않는 함수를 빼고 동작시킬 수 있다.
    2. `alias`: 임의의 모듈에 별칭을 생성하므로 타이핑의 수고를 덜 수 있다.
    3. `require`: 주로 다른 모듈에 정의된 매크로를 호출하기 위해 사용된다.
* 이러한 **지시자의 효과는 지시자가 명시된 지점부터 코드를 감싼 블록이 유효한 동안 렉시컬 스코프로서 기능**한다.
    * 다시 말해 **지시자를 모듈 내에 정의한 경우 해당 모듈의 정의가 끝나기 전까지, 함수에 정의한 경우 함수 정의가 끝날 때까지만 유지**된다.
* 이 때, **`import` 지시자는 가능한 한 작은 스코프에서 `only`나 `except`를 활용하여 필요한 함수만 가져올 것이 권장**된다.
* `alias [모듈명], as: MyModule` 형태로 작성할 경우, `as:` 뒤에 작성된 `MyModule`이라는 단어로 해당 모듈을 참조할 수 있게 된다.
    * 반면, **여러 모듈에 대한 별칭을 생성하는 경우 `alias My.Module.{Parser, Runner}`와 같은 형태의 참조를 작성해도 무방**하다.

## 2025-10-17 Fri
### 모듈 속성이란?
```
> 모듈 속성은 일반 변수와 달리 컴파일 시점에 값이 결정되며, 상수보다는 설정이나 메타데이터 용도로만 사용되어야 한다.
```
* 엘릭서의 각 모듈은 메타데이터를 가질 수 있으며, 이 때 메타데이터를 이루는 각 항목을 모듈 속성이라는 용어로 지칭한다.
    * **속성은 `@author "John Wick"`과 같이 이름과 값을 갖는, 일종의 키-값 쌍으로 이해**할 수 있다.
* **모듈 속성은 모듈의 최상위에서만 사용 가능하며, 모듈에 포함된 기명 함수 정의 내에서는 모듈 속성의 값을 읽을 수는 있으나 쓸 수는 없다**.
* 반면, 동일한 모듈 이름에 대해 값을 여러 번 설정할 수도 있으며 함수는 함수가 정의된 시점의 모듈 속성 값으로 설정된다.

## 2025-10-18 Sat
### 모듈의 내부적인 이름 설정
* **엘릭서 모듈은 대부분 `PascalCase`로 작성되며, 내부적으로 모듈의 이름은 항상 아톰으로 처리**된다.
    * 같은 이유에서, **대문자로 시작하는 모듈 이름은 엘릭서 내부적으로 `:"Elixir.[모듈명]"`과 같은 아톰으로 변경**된다.
    * 예를 들어, `IO` 모듈은 내부적으로 `:"Elixir.IO"` 와 같은 아톰으로 변경된다.
* 즉, 모듈 안에 있는 함수를 호출하는 일련의 코드는 실제로는 아톰 뒤에 온점('.')을 출력한 후 함수 이름을 이어 붙인 형태로 이해할 수 있다.
    * 예를 들어, `IO.puts 42`는 아톰을 활용한 `:"Elixir.IO".puts 42`과 같은 형태의 함수 호출로 동일한 기능을 수행할 수 있다.

## 2025-10-19 Sun
### 얼랭 라이브러리와 통합하기
```text
> 엘릭서는 기본적으로 얼랭 라이브러리와 잘 통합되지만, 얼랭 라이브러리의 문서는 얼랭 컨벤션을 따름에 주의할 필요가 있다.
```
* **얼랭의 명명 규칙은 엘릭서와 다른 부분이 있으며, 예를 들어 얼랭은 변수 이름은 대문자로 시작하되 아톰은 소문자로 시작**한다.
    * 즉, **얼랭에서 `tomato`라는 문자열을 작성할 경우 엘릭서 상에서는 `:tomato`와 같은 아톰으로 표기해주어야 한다**.
    * 때문에 **얼랭의 경우 `timer` 모듈은 `timer`라는 아톰을 그대로 사용할 수 있으나, 엘릭서에서는 `:timer`와 같은 아톰으로 호출**해줄 필요가 있다.
    * 같은 이유에서 얼랭의 `format` 모듈을 엘릭서에서 호출할 경우 코드를 다음과 같이 작성할 수 있다.
```elixir
:io.format("The number is ~3.1f~n", [5.678])
# The number is 5.7
# :ok
```

## 2025-10-20 Mon
### 리스트의 구성 요소와 파이프 연산자
```
> 전통적인 언어에서는 리스트를 순회 대상으로 여겼지만, 문제를 올바른 방식으로 바라본다면 재귀야말로 링크드 리스트를 다루는 최적의 도구임을 알 수 있다.
```
* 앞서 다룬 바와 같이, 리스트는 비어있거나 머리와 꼬리로 구성된 두 가지 형태를 가질 수 있다.
    * 이 때, **머리는 값을 담는 반면 꼬리는 머리를 제외한 나머지 값을 포함하는 리스트를 지칭**하며 이 자체로 리스트를 재귀적으로 정의한 것이 된다.
* 기본적인 리스트는 `[1, 2]`의 형태를 띄지만, 머리와 꼬리를 명시적으로 `|` 연산자로 구분하는 `[1 | [2]]` 형태 역시 올바른 리스트 리터럴에 해당한다.
    * 이 때, `|` 뒤의 `[2]`는 꼬리 부분을 의미하게 된다.
    * 이렇듯 **파이프 연산자는 함수의 출력을 다음 함수의 입력으로 전달하는 것 뿐만 아니라 리스트의 머리와 꼬리를 구분하는 용도로도 사용**할 수 있다.
```elixir
Enum.map [1 | [2]], &(&1 * 2) # [2, 4]가 반환된다.
```
* 또한, 길이가 1인 리스트를 예로 들었을 때 해당 리스트는 머리에 값이 저장되고 꼬리가 빈 리스트로 구성되어 있기에 다음과 같은 표기가 가능하다.
```elixir
inspect [1 | []] # [1]이 출력된다.
```
* 리스트의 머리와 꼬리를 구분하는 용도로 사용되는 파이프 연산자는 다음과 같이 패턴 매칭에도 적용이 가능하다.
```elixir
[head | tail] = [1,2,3,4,5]
IO.puts "#{inspect head}" # 1이 출력된다.
IO.puts "#{inspect tail}" # [2,3,4,5]가 출력된다.
```

## 2025-10-21 Tue
### 머리와 꼬리를 활용한 리스트의 처리
* **리스트를 머리와 꼬리로 나눌 수 있다면, 이렇게 나누어진 값과 리스트를 각각 활용하여 새로운 리스트를 생성할 수 있게 된다**.
* 엘릭서 상에서 리스트와 재귀 함수는 뗼 수 없는 관계에 있으며, 둘을 조합하여 다음과 같이 리스트를 순회하는 연산을 손쉽게 구현하는 것이 가능하다.
```elixir
defmodule MyListV1 do
  def len([]), do: 0
  def len([_head|tail]), do: 1 + len(tail)
end
```
* 상술한 `len` 함수의 경우 비어 있는 리스트와 그렇지 않은 리스트 각각에 매칭되는 본문을 가지며, 리스트의 꼬리를 다음 재귀에 전달하는 방식으로 동작한다.
* 이렇듯 머리와 꼬리를 기반으로 동작하는 재귀 함수의 경우, 함수의 반환 값에 `|` 연산자를 적절히 활용하는 것으로 마치 `Enum.map` 같은 효과를 낼 수 있다.
    * 아래의 코드는 임의의 리스트를 받아 이를 재귀적으로 연산한 결과를 다시 리스트로 반환하는 예시에 해당한다.
```elixir
defmodule MyListV2 do
  def square([]), do: []
  def square([head|tail]), do: [head * head | square(tail)]
end
```

## 2025-10-22 Wed
### 재귀를 활용한 나만의 map 함수 작성하기
* 상술한 `len`과 `square`는 머리와 꼬리를 나누어 재귀적인 연산을 적용한다는 점에서 공통점이 있으며, 이는 다음과 같이 추상화할 수 있다.
```elixir
defmodule MyListV3 do
  def my_map([], _func), do: []
  def my_map([head|tail], func), do: [func.(head) | my_map(tail, func)]
end
```
* 첫 번째 구현의 경우 빈 리스트를 반환하므로 두번째 인자인 `func`를 버리기 위해 `_` 기호를 명시하는 반면, 두 번째 구현은 상술했던 구현 방식을 추상화한다.
    * 이 때, 두 번째 인자에는 익명 함수가 전달되므로 `fn (x) -> x * x end` 또는 `&(&1 * &1)` 등을 전달할 수 있다.

## 2025-10-23 Thu
### 리스트에서 조인 연산자를 사용하는 또 다른 방법
* 조인 연산자인 `|`는 연산자 왼쪽에 `head`를 두는 방법 외에도 여러 값을 둘 수 있도록 하며, 이로 인해 다음과 같은 표기 역시 유효하다.
```elixir
list = [ 1, 2, 3 | [ 4, 5, 6 ] ]
 IO.puts "#{inspect list}" # [1, 2, 3, 4, 5, 6]이 출력된다.
```
* 이는 패턴 매칭에서도 동일하게 동작하며, 조인 연산자의 앞 부분에 여러 값을 한 번에 매칭하기 위해서는 다음과 같은 함수를 예로 들 수 있다.
    * 특히 함수의 두 번쨰 구현은 여러 값을 한 번에 매칭하는 방식으로 동작한다.
```elixir
defmodule Swapper do
  def swap([]), do: []
  def swap([a, b|tail]), do: [b, a | swap(tail)] # 패턴 매칭을 활용하여 한 번에 여러 값을 매칭한다.
  def swap([_]), do: raise "list contains odd number of elements"
end
```

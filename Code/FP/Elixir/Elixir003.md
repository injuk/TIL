# Elixir
## 2025-10-15 Wed
### 모듈 활용하기
* **모듈은 모듈 내에 정의된 내용에 대한 네임 스페이스로서 기능하며, 함수 뿐만 아니라 매크로나 구조체 또는 다른 모듈까지도 포함이 가능**하다.
    * 이 때, 모듈 내에 정의된 함수를 모듈 밖에서 참조하기 위해서는 함수명 앞에 모듈 이름을 명시해줄 필요가 있다.
    * 반면, 동일한 모듈 내에 위치한 함수를 호출하는 경우에는 모듈 이름을 명시해줄 필요가 없다.
* **엘릭서의 경우 코드 가독성 및 재사용성을 위해 중첩 모듈을 정의할 수 있으나, 실제로는 모든 모듈이 최상위에 정의**된다.
    * 즉, 코드 상에서는 모듈이 중첩된 것처럼 보이더라도 엘릭서 내부적으로는 그저 모듈 이름들을 온점(.)으로 연결한 것에 지나지 않는다.

## 2025-10-16 Thu
### 모듈의 세 가지 지시자
* **엘릭서에서는 다른 모듈을 참조하기 위해 다음과 같은 세 가지 지시자 중 하나를 고려할 수 있으며, 이들은 모두 프로그램 시작 시점부터 함께 실행**된다.
    1. `import`: 다른 모듈의 함수나 매크로를 현재 스코프로 가져오며, 원하는 함수만 가져오거나 원하지 원하지 않는 함수를 빼고 동작시킬 수 있다.
    2. `alias`: 임의의 모듈에 별칭을 생성하므로 타이핑의 수고를 덜 수 있다.
    3. `require`: 주로 다른 모듈에 정의된 매크로를 호출하기 위해 사용된다.
* 이러한 **지시자의 효과는 지시자가 명시된 지점부터 코드를 감싼 블록이 유효한 동안 렉시컬 스코프로서 기능**한다.
    * 다시 말해 **지시자를 모듈 내에 정의한 경우 해당 모듈의 정의가 끝나기 전까지, 함수에 정의한 경우 함수 정의가 끝날 때까지만 유지**된다.
* 이 때, **`import` 지시자는 가능한 한 작은 스코프에서 `only`나 `except`를 활용하여 필요한 함수만 가져올 것이 권장**된다.
* `alias [모듈명], as: MyModule` 형태로 작성할 경우, `as:` 뒤에 작성된 `MyModule`이라는 단어로 해당 모듈을 참조할 수 있게 된다.
    * 반면, **여러 모듈에 대한 별칭을 생성하는 경우 `alias My.Module.{Parser, Runner}`와 같은 형태의 참조를 작성해도 무방**하다.

## 2025-10-17 Fri
### 모듈 속성이란?
```
> 모듈 속성은 일반 변수와 달리 컴파일 시점에 값이 결정되며, 상수보다는 설정이나 메타데이터 용도로만 사용되어야 한다.
```
* 엘릭서의 각 모듈은 메타데이터를 가질 수 있으며, 이 때 메타데이터를 이루는 각 항목을 모듈 속성이라는 용어로 지칭한다.
    * **속성은 `@author "John Wick"`과 같이 이름과 값을 갖는, 일종의 키-값 쌍으로 이해**할 수 있다.
* **모듈 속성은 모듈의 최상위에서만 사용 가능하며, 모듈에 포함된 기명 함수 정의 내에서는 모듈 속성의 값을 읽을 수는 있으나 쓸 수는 없다**.
* 반면, 동일한 모듈 이름에 대해 값을 여러 번 설정할 수도 있으며 함수는 함수가 정의된 시점의 모듈 속성 값으로 설정된다.

## 2025-10-18 Sat
### 모듈의 내부적인 이름 설정
* **엘릭서 모듈은 대부분 `PascalCase`로 작성되며, 내부적으로 모듈의 이름은 항상 아톰으로 처리**된다.
    * 같은 이유에서, **대문자로 시작하는 모듈 이름은 엘릭서 내부적으로 `:"Elixir.[모듈명]"`과 같은 아톰으로 변경**된다.
    * 예를 들어, `IO` 모듈은 내부적으로 `:"Elixir.IO"` 와 같은 아톰으로 변경된다.
* 즉, 모듈 안에 있는 함수를 호출하는 일련의 코드는 실제로는 아톰 뒤에 온점('.')을 출력한 후 함수 이름을 이어 붙인 형태로 이해할 수 있다.
    * 예를 들어, `IO.puts 42`는 아톰을 활용한 `:"Elixir.IO".puts 42`과 같은 형태의 함수 호출로 동일한 기능을 수행할 수 있다.

## 2025-10-19 Sun
### 얼랭 라이브러리와 통합하기
```text
> 엘릭서는 기본적으로 얼랭 라이브러리와 잘 통합되지만, 얼랭 라이브러리의 문서는 얼랭 컨벤션을 따름에 주의할 필요가 있다.
```
* **얼랭의 명명 규칙은 엘릭서와 다른 부분이 있으며, 예를 들어 얼랭은 변수 이름은 대문자로 시작하되 아톰은 소문자로 시작**한다.
    * 즉, **얼랭에서 `tomato`라는 문자열을 작성할 경우 엘릭서 상에서는 `:tomato`와 같은 아톰으로 표기해주어야 한다**.
    * 때문에 **얼랭의 경우 `timer` 모듈은 `timer`라는 아톰을 그대로 사용할 수 있으나, 엘릭서에서는 `:timer`와 같은 아톰으로 호출**해줄 필요가 있다.
    * 같은 이유에서 얼랭의 `format` 모듈을 엘릭서에서 호출할 경우 코드를 다음과 같이 작성할 수 있다.
```elixir
:io.format("The number is ~3.1f~n", [5.678])
# The number is 5.7
# :ok
```

## 2025-10-20 Mon
### 리스트의 구성 요소와 파이프 연산자
```
> 전통적인 언어에서는 리스트를 순회 대상으로 여겼지만, 문제를 올바른 방식으로 바라본다면 재귀야말로 링크드 리스트를 다루는 최적의 도구임을 알 수 있다.
```
* 앞서 다룬 바와 같이, 리스트는 비어있거나 머리와 꼬리로 구성된 두 가지 형태를 가질 수 있다.
    * 이 때, **머리는 값을 담는 반면 꼬리는 머리를 제외한 나머지 값을 포함하는 리스트를 지칭**하며 이 자체로 리스트를 재귀적으로 정의한 것이 된다.
* 기본적인 리스트는 `[1, 2]`의 형태를 띄지만, 머리와 꼬리를 명시적으로 `|` 연산자로 구분하는 `[1 | [2]]` 형태 역시 올바른 리스트 리터럴에 해당한다.
    * 이 때, `|` 뒤의 `[2]`는 꼬리 부분을 의미하게 된다.
    * 이렇듯 **파이프 연산자는 함수의 출력을 다음 함수의 입력으로 전달하는 것 뿐만 아니라 리스트의 머리와 꼬리를 구분하는 용도로도 사용**할 수 있다.
```elixir
Enum.map [1 | [2]], &(&1 * 2) # [2, 4]가 반환된다.
```
* 또한, 길이가 1인 리스트를 예로 들었을 때 해당 리스트는 머리에 값이 저장되고 꼬리가 빈 리스트로 구성되어 있기에 다음과 같은 표기가 가능하다.
```elixir
inspect [1 | []] # [1]이 출력된다.
```
* 리스트의 머리와 꼬리를 구분하는 용도로 사용되는 파이프 연산자는 다음과 같이 패턴 매칭에도 적용이 가능하다.
```elixir
[head | tail] = [1,2,3,4,5]
IO.puts "#{inspect head}" # 1이 출력된다.
IO.puts "#{inspect tail}" # [2,3,4,5]가 출력된다.
```

## 2025-10-21 Tue
### 머리와 꼬리를 활용한 리스트의 처리
* **리스트를 머리와 꼬리로 나눌 수 있다면, 이렇게 나누어진 값과 리스트를 각각 활용하여 새로운 리스트를 생성할 수 있게 된다**.
* 엘릭서 상에서 리스트와 재귀 함수는 뗼 수 없는 관계에 있으며, 둘을 조합하여 다음과 같이 리스트를 순회하는 연산을 손쉽게 구현하는 것이 가능하다.
```elixir
defmodule MyListV1 do
  def len([]), do: 0
  def len([_head|tail]), do: 1 + len(tail)
end
```
* 상술한 `len` 함수의 경우 비어 있는 리스트와 그렇지 않은 리스트 각각에 매칭되는 본문을 가지며, 리스트의 꼬리를 다음 재귀에 전달하는 방식으로 동작한다.
* 이렇듯 머리와 꼬리를 기반으로 동작하는 재귀 함수의 경우, 함수의 반환 값에 `|` 연산자를 적절히 활용하는 것으로 마치 `Enum.map` 같은 효과를 낼 수 있다.
    * 아래의 코드는 임의의 리스트를 받아 이를 재귀적으로 연산한 결과를 다시 리스트로 반환하는 예시에 해당한다.
```elixir
defmodule MyListV2 do
  def square([]), do: []
  def square([head|tail]), do: [head * head | square(tail)]
end
```

## 2025-10-22 Wed
### 재귀를 활용한 나만의 map 함수 작성하기
* 상술한 `len`과 `square`는 머리와 꼬리를 나누어 재귀적인 연산을 적용한다는 점에서 공통점이 있으며, 이는 다음과 같이 추상화할 수 있다.
```elixir
defmodule MyListV3 do
  def my_map([], _func), do: []
  def my_map([head|tail], func), do: [func.(head) | my_map(tail, func)]
end
```
* 첫 번째 구현의 경우 빈 리스트를 반환하므로 두번째 인자인 `func`를 버리기 위해 `_` 기호를 명시하는 반면, 두 번째 구현은 상술했던 구현 방식을 추상화한다.
    * 이 때, 두 번째 인자에는 익명 함수가 전달되므로 `fn (x) -> x * x end` 또는 `&(&1 * &1)` 등을 전달할 수 있다.

## 2025-10-23 Thu
### 리스트에서 조인 연산자를 사용하는 또 다른 방법
* 조인 연산자인 `|`는 연산자 왼쪽에 `head`를 두는 방법 외에도 여러 값을 둘 수 있도록 하며, 이로 인해 다음과 같은 표기 역시 유효하다.
```elixir
list = [ 1, 2, 3 | [ 4, 5, 6 ] ]
 IO.puts "#{inspect list}" # [1, 2, 3, 4, 5, 6]이 출력된다.
```
* 이는 패턴 매칭에서도 동일하게 동작하며, 조인 연산자의 앞 부분에 여러 값을 한 번에 매칭하기 위해서는 다음과 같은 함수를 예로 들 수 있다.
    * 특히 함수의 두 번쨰 구현은 여러 값을 한 번에 매칭하는 방식으로 동작한다.
```elixir
defmodule Swapper do
  def swap([]), do: []
  def swap([a, b|tail]), do: [b, a | swap(tail)] # 패턴 매칭을 활용하여 한 번에 여러 값을 매칭한다.
  def swap([_]), do: raise "list contains odd number of elements"
end
```

## 2025-10-24 Fri
### 패턴 내에서 패턴 매칭을 활용하기
* 아래와 같은 모듈이 있다고 가정했을 때, `test_data`는 데이터 그 자체를 의미하는 반면 `for_location`은 두 번째 인자를 기준으로 필터링한다.
```elixir
defmodule WeatherHistory do
  def test_data do
    [
      [1366225622, 26, 15, 0.125],
      [1366225622, 27, 15, 0.45],
      [1366225622, 28, 21, 0.25],
      [1366229222, 26, 19, 0.081],
      [1366229222, 27, 17, 0.468],
      [1366229222, 28, 15, 0.60],
      [1366232822, 26, 22, 0.095],
      [1366232822, 27, 21, 0.05],
      [1366232822, 28, 24, 0.03],
      [1366236422, 26, 17, 0.025],
    ]
  end

  def for_location([], _location_number), do: []
  def for_location([[time, location_number, temp, rain]|tail], location_number), do: [[time, location_number, temp, rain]|for_location(tail, location_number)]
  def for_location([_|tail], location_number), do: for_location(tail, location_number)
end
```
* 반면, `for_location`의 두 번째 구현은 `location_number` 이외의 세 값을 불필요하게 패턴 매칭하므로 이를 아래와 같이 개선할 수 있다.
```elixir
defmodule WeatherHistory do
  # ...생략
  def for_location([], _location_number), do: []
  def for_location([head = [_, location_number, _, _]|tail], location_number), do: [head|for_location(tail, location_number)]
  def for_location([_|tail], location_number), do: for_location(tail, location_number)
end
```
* 이는 **엘릭서의 패턴 매칭이 재귀적이기 떄문에 가능한 것으로, 패턴 내에서도 패턴 매칭을 수행하는 것으로 상술한 리팩토링을 적용**할 수 있다.
    * 즉, 해당 패턴 매칭은 복합 리스트에서 두 번째 값을 기준으로 매칭하되 리스트의 머리는 전부 `head`라는 변수에 매칭한 것으로 해석할 수 있다. 

## 2025-10-25 Sat
### Elixir와 딕셔너리
* 딕셔너리는 키-값 쌍 형태로 구성되는 데이터 자료형을 지칭하며, 엘릭서의 경우 다음과 같은 예시들이 딕셔너리에 해당한다.
    1. 맵
    2. 키워드 리스트
    3. 구조체
* 이 때, 여러 딕셔너리 중 다음과 같은 기준에 따라 용도에 맞는 딕셔너리를 선택하는 것이 바람직하다.
    1. 내용을 기준으로 패턴 매칭하고자 하는 경우, 맵을 사용한다.
    2. 같은 키로 여러 항목을 저장해야 하거나, 요소들의 순서가 중요한 경우에는 키워드 리스트를 사용한다.
    3. 데이터의 구조가 항상 동일하여 매 번 같은 필드 목록을 사용하게 되는 경우, 구조체를 사용한다.
* 반면, **위 세 가지 기준 중 어느 것도 만족하지 않는 요구사항의 경우에는 기본적으로 맵을 고려**한다.

## 2025-10-26 Sun
### Keyword 모듈을 활용한 키워드 리스트 접근
* 일반적으로 함수에 옵션을 전달하기 위해 사용되는 키워드 리스트는 `키워드_리스트[:키_이름]` 형태의 문법으로 데이터에 쉽게 접근할 수 있다.
* 반면, 엘릭서는 키워드 리스트의 데이터를 손쉽게 활용할 수 있도록 `Keyword` 모듈을 제공하며 예를 들어 다음과 같은 기능들을 사용할 수 있다.
    1. `Keyword.merge`: 두 키워드 리스트를 인자로 받아 합치되, 첫번째 인자의 리스트와 두번째 인자의 리스트에 겹치는 값이 있을 경우 덮어쓴다.
    2. `Keyword.get`: 첫 번째 인자로 전달된 리스트에서 두 번째 인자로 전달된 키 값을 찾아 반환한다.
    3. `Keywor.get_values`: 키워드 리스트는 동일한 키에 대해 여러 항목을 허용하므로, 임의의 키에 대응되는 모든 값을 리스트 형태로 반환한다.
* 이 때, `Keyword.get`의 경우 해당하는 값이 없다면 `nil`이 반환되는 반면 세 번째 인자에 기본 값을 적용할 수도 있다.
    * 이 경우, 대응되는 키에 해당하는 값이 없을 때 `nil` 대신 기본값이 반환된다.
* 또한, **키워드 리스트에 동일한 키를 갖는 데이터가 여럿 있을 경우 `키워드_리스트[:키_이름]` 형태의 접근은 첫 번째로 대응되는 값 하나만을 반환**한다.
    * 이는 `Keyword.get` 역시 마찬가지이며, 여러 값을 리스트 형태로 반환받기 위해서는 상술한 `Keyword.get_values`를 사용해야 한다.

## 2025-10-27 Mon
### Elixir와 맵의 구현체
* 엘릭서의 경우, 맵은 크기와 관계 없이 좋은 성능을 내는 자료 구조이며 `Map` 모듈의 API를 통해 데이터에 대한 손쉬운 접근이 가능하다.
* **엘릭서의 맵은 저장된 키의 개수에 대해 32 개를 기준으로 작은 맵과 큰 맵을 구분하여 서로 다른 구현을 제공하고, 자동으로 전환**하기도 한다.
    * 이 때, 작은 맵은 정렬된 배열처럼 저장하는 `Flat Map`을 사용하는 반면 큰 맵은 트리 구조를 활용하는 `Hash Array Mapped Trie`를 적용한다.
    * 성능적으로 보았을 때 두 자료 구조는 각각 `O(n)`과 `O(log32n)`의 성능을 제공하지만, `Flat Map`의 경우 `n`이 매우 작아 좋은 성능을 보장한다.
    * 반면, 이러한 내용은 어디까지나 추후에 변경될 수 있는 세부 구현에 해당하므로 32라는 숫자에 의존적으로 코드를 작성하는 것은 권장되지 않는다.
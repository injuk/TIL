# Elixir
## 2025-09-27 Sat
### 익명 함수 정의하기
```
> 프로그래밍의 기본은 데이터를 변형하는 것이며, 함수는 변형을 수행하는 작은 엔진으로서 엘릭서의 핵심에 위치한다.
```
* 엘릭서는 함수형 프로그래밍 언어이므로 함수는 기본 타입에 속하며, `fn` 키워드를 사용하여 익명 함수를 정의할 수 있다.
* 이러한 익명 함수는 변수에 할당하거나 다른 함수의 인자로 전달할 수 있으며, `fn_name.()` 형태로 호출할 수 있다.
```elixir
sum = fn (a, b) -> a + b end
IO.puts sum.(1, 2) # 3이 출력된다.
```
* 이 때, **익명 함수와 기명 함수는 각각 호출 방식이 다른 점에 주의**해야 한다.
    * 이는 **엘릭서의 내부적인 동작 방식이 변수는 변수 네임스페이스를, 함수는 함수 네임스페이스를 사용하며 이를 명시적으로 구분하기 위함**이다.
* 엘릭서의 함수는 인자 목록과 함수 본문으로 구성되며, 두 요소는 `->` 기호로 구분된다.
    * 또한, **엘릭서 함수의 인자 역시 할당이 아닌 패턴 매칭 개념을 사용하므로 언제나 이를 적절히 활용할 방법을 모색하는 것이 바람직**하다.
* 반면, 인자를 받지 않는 익명 함수는 다음과 같이 인자 목록을 누락시킨 구현을 사용한다.
```elixir
temp = fn -> IO.puts "Hello world!" end # Hello world!가 출력된다.
# temp = fn () -> IO.puts "Hello world!" end # 이렇게 빈 괄호를 명시적으로 작성하는 것도 가능하다.
```

## 2025-09-28 Sun
### 본문을 여럿 갖는 함수 정의하기
```
> 엘릭서 함수를 하나 정의할 때, 인자의 타입이나 내용에 따라 여러 구현을 정의하는 것이 가능하다.
```
* **엘릭서 함수를 하나 정의할 때, 인자의 타입이나 내용에 따라 여러 구현을 정의하는 것이 가능하다.**를 가져야 한다.
* 이 경우 어떠한 구현을 실행할지는 기본적으로 패턴 매칭을 통해 결정하며, 이는 다음과 같은 코드 예시로 확인할 수 있다.
```elixir
handle_open = fn
  {:ok, file} -> "First line: #{IO.read(file, :line)}"
  {_, error} -> "Error: #{:file.format_error(error)}" # atom인 :error를 명시하는 것이 아님에 주의한다!
end

IO.puts handle_open.(File.open("./hello.txt")) # 존재하는 파일에 대해서는 첫 번째 구현이 실행된다.
IO.puts handle_open.(File.open("./none.txt")) # 존재하지 않는 파일에 대해서는 두 번째 구현이 실행된다.
```
* `handle_open` 함수는 모두 튜플을 인자로 받아 동작하지만, 첫 번째 구현의 경우 튜플을 구성하는 첫 인자가 `:ok`인 경우에만 실행된다.
    * 반면, 두 번째 구현은 `_`를 활용하여 첫 번째 인자가 `:ok`가 아닌 모든 경우에 대해 동작하도록 정의된다.

## 2025-09-29 Mon
### 일급 시민으로서의 함수
* 엘릭서에서는 함수 역시 값인 일급 시민으로 취급되므로, 함수를 변수에 할당하거나 다른 함수의 인자로 전달하는 것이 가능하다.
* 이를 대표적으로 활용하는 것이 엘릭서의 빌트인 모듈인 `Enum`의 내장 함수들로, 예를 들어 `map`은 다른 언어와 유사하게 다음과 같이 동작한다.
```elixir
list = [1, 3, 5, 7, 9]
result = Enum.map list, fn elem -> elem * 2 end # [2, 6, 10, 14, 18]
```

## 2025-09-30 Tue
### 핀 연산자를 활용한 함수 인자의 고정
* 패턴 매칭에서도 사용한 핀 연산자 `^`는 패턴의 변수에 현재 변수 값을 사용하도록 고정하므로, 이를 함수 인자에도 활용하는 것이 가능하다.
```elixir
fn_for = fn (name, greeting) ->
  fn
    (^name) -> "#{greeting} #{name}"
    (_) -> "I don't know you"
  end
end

mr_valim = fn_for.("Jose", "Oi")
IO.puts mr_valim.("Jose") # Oi Jose가 출력된다.
IO.puts mr_valim.("Dave") # I don't know you가 출력된다.
```
* 상술한 함수의 경우, 핀 연산자에 의해 외부 함수인 `fn_for`에 전달된 `name`과 내부 함수에 전달된 `name`이 동일한 경우에만 첫 번째 구현이 실행된다.

## 2025-10-01 Wed
### 익명 함수의 단축 문법 활용하기 - I
* 익명 함수는 짤막한 헬퍼 함수를 정의하기 위해 자주 사용되는 문법이므로, 엘릭서는 이를 위한 단축 문법을 `&(&1 + 1)` 형태로 제공한다.
    * 이는 첫 번째 인자에 1을 던한 값을 반환하는 익명 함수인 `fn (x) -> x + 1 end`와 동일하게 동작한다.
```elixir
list = [1,2,3]
Enum.map list, &(&1 * 2) # [2,4,6]
```
* `&`로 표기되는 함수 캡쳐 연산자는 뒤의 표현식을 함수로 변환하며, `&1`, `&2` 등으로 인자를 참조한다.
    * 이 경우 `&1`은 익명 함수에 전달된 첫 번째 인자를 참조하며, `&2`는 두 번째 인자를 참조한다.

## 2025-10-02 Thu
### 단축 문법과 함수 참조
* `iex`를 실행하여 다음과 같이 단축 문법을 활용한 다양한 형태의 함수 정의를 실행하여 그 결과를 확인해볼 필요가 있다.
```shell
my_sum_with_42 = &(&1 + 42)
# #Function<42.113135111/1 in :erl_eval.expr/6> 와 유사하게 출력된다.

my_sum = &(&1 + &2)
# 항상 &:erlang.+/2 가 출력된다.

my_puts = &(IO.puts &1)
# 항상 &IO.puts/1 이 출력된다.
```
* `my_sum`의 경우 함수에 전달된 인자의 개수와 타입에서 미루어보았을 때 `IO.puts/1`과 같은 시그니쳐를 갖는다.
    * 이 경우, **엘릭서는 내부적으로 새로운 함수를 정의하는 대신 `IO.puts/1` 자체를 참조하도록 최적화하는 방식으로 동작**한다.
    * 이렇게 **최적화되기 위해서는 참조 대상 함수와 동일한 개수의 인자를 정해진 순서대로 전달해줄 필요**가 있다.
* 반면, `my_sum` 정의시 반환되는 결과에서도 확인할 수 있듯 엘릭서는 함수 호출을 `erlang` 라이브러리에 직접 매핑하기도 한다.
    * 이는 곧 **엘릭서가 `erlang` VM 위에서 동작하는 언어임을 확인할 수 있는 증거이기도 하다는 점에서 큰 의미**를 갖는다.

## 2025-10-03 Fri
### 익명 함수의 단축 문법 활용하기 - II
* 엘릭서에서 `[]`와 `{}`과 같은 기호는 모두 연산자에 해당하므로, 리스트와 튜플 리터럴 역시 함수처럼 동작할 수 있다.
    * 유사한 원리로, `&`와 같은 캡쳐 연산자는 문자열 리터럴에 대해서도 동작할 수 있다.
```elixir
divrem = &{ div(&1, &2), rem(&1, &2)}
divrem.(13, 5) # {2, 3}이 출력된다.

suffix = &"Mr. #{&1}"
suffix.("John") # Mr. John이 출력된다.
```
* 함수 캡쳐 연산자 `&`는 기명 함수의 이름과 인자 개수를 전달하는 것으로 기명 함수를 참조하는 새로운 익명 함수를 반환하도록 구현하기 위해 사용할 수도 있다.
    * 예를 들어 `l = &length/1`은 빌트인 함수인 `length`에 대한 참조를 반환하므로 `l.([1,2,3])`은 `3`을 반환한다.
```elixir
Enum.map [[1], [1,2], [1,2,3], [1,2,3,4]], &length/1 # [1, 2, 3, 4]가 출력된다.

# Enum.map [[1], [1,2], [1,2,3], [1,2,3,4]], length/1 # 이 경우 error: undefined variable "length"와 같은 오류가 발생한다. 
```
* 이렇듯 **캡쳐 연산자인 `&`를 활용한 표기법은 함수를 다른 함수에 전달하는 상황에 유용**하다.

## 2025-10-04 Sat
### 엘릭서와 모듈
* 프로그램을 작성하는 과정에서, 산출물의 규모가 커질수록 코드를 일정한 구조로 정리하고 싶을 수 있다.
* 엘릭서 역시 여타 언어와 유사하게 명명된 함수인 기명 함수들로 로직을 구분하고, 이들을 모듈로 묶어 정리하는 방식을 적용할 수 있다.
* 이 때, **엘릭서의 모든 기명 함수는 다음과 같이 항상 모듈 내에서만 정의가 가능하다는 점에 주의**를 기울여야 한다.
```elixir
defmodule Times do
  def double(n) do
    n * 2
  end
end
```
* 해당 기명 함수는 엘릭서 상에서 `double/1`로 식별되며, 필요한 경우 인자의 갯수를 늘린 `double/2` 등을 정의할 수도 있다.
    * 그러나 이름이 같은 함수는 관련성이 높은 것으로 취급되기 쉬우므로, 정말 관련이 있는 경우가 아니라면 동일한 이름의 기명 함수는 지양하는 것이 바람직하다.

## 2025-10-05 Sun
### 함수의 본문
* `do...end` 블록은 여러 줄의 표현식을 묶어 다른 코드로 전달하는 방법이며, 모듈과 기명 함수의 정의 뿐만 아니라 제어 구조 등에서도 사용된다.
* 그러나 **`do...end`는 엘릭서의 빌트인 문법이 아니며, 실제로는 `, do: (...)` 형태의 키워드 리스트에 의해 구현된 문법 설탕**이다.
    * 컴파일 과정에서 `do...end` 문법은 `do: (...)` 형태로 치환된다.
    * 반면, 실무의 경우 한 줄로 작성되는 표현식에 대해서는 `, do: (...)` 형태로 작성하되 여러 줄로 작성되는 표현식에 대해서는 `do...end`를 적용한다.

## 2025-10-06 Mon
### 함수 호출과 패턴 매칭
* 기명 함수에서도 인자에 대한 패턴 매칭이 적용되며, 하나의 함수 정의에 대해 여러 개의 구현을 작성할 수 있다.
```elixir
defmodule Factorial do
  def of(0), do: 1
  def of(n), do: n * of(n - 1)
end
```
* 위 예시에서 `of/1` 함수는 인자가 `0`인 경우와 그 외의 경우로 나누어 구현되었으며, 엘릭서는 인자의 값에 따라 적절한 구현을 선택하여 호출한다.
    * 물론, **이를 위해서는 각 구현이 받아들이는 인자의 개수가 모두 같아야** 한다.
* 이 때, **적절한 구현을 선택하기 위한 과정은 항상 위에서부터 아래로 진행되기 때문에 가장 먼저 고려되는 구현은 `of(n)`이 아닌 `of(0)`**이 된다.
    * **엘릭서는 이러한 과정을 매칭되는 함수가 나타나거나, 매칭 대상 함수가 더 이상 없을 때까지 반복하는 방식으로 동작**한다.
    * 같은 이유에서, `Factorial.of(2)`를 실행할 경우 `of(0)`의 패턴에 매칭되지 않아 `of(n)`이 호출되게 된다.

## 2025-10-07 Tue
### 함수형 프로그래밍과 재귀 호출
* 상술한 코드는 재귀 호출로 작성되어 있으며, 이렇듯 **재귀를 활용하여 설계하고 코딩하는 패턴은 엘릭서 뿐만 아니라 많은 FP 언어에서 매우 일반적**이다.
    * 반면, 엘릭서는 꼬리 최적화를 적용하지만 상술한 코드의 경우 `of(n)`의 구현에서 마지막 동작이 재귀 호출이 아니므로 최적화를 적용할 수 없다.
* 엘릭서에서 재귀 방식의 접근을 위해서는 우선 정해진 답을 반환하는 가장 간단한 경우를 하나 찾아 모듈에 포함된 기명 함수의 첫 번째 구현에 작성한다.
    * 이는 일종의 기준으로서 동작하며, 나머지 구현은 재귀 호출을 반복하다가 이러한 기준점에서 호출을 종료하기 위한 재귀적인 답으로 작성할 수 있다.
* 반면, 상술한 바와 같이 엘릭서는 기명 함수가 포함된 모듈에서 위에서부터 순서대로 패턴 매칭을 처리하므로 구현 순서에 주의를 기울여야 한다.

## 2025-10-08 Wed
### 엘릭서의 가드 조건절
* **가드 조건절은 임의의 함수가 특정한 인자의 타입이나 조건을 만족한 경우에만 실행되도록 구현하기 위한 기능을 의미**한다.
    * 예를 들어 임의의 인자가 문자열이거나, 양수인 경우 등등 특정한 조건을 만족한 경우에만 함수가 실행되도록 구현할 수 있다.
* **가드 조건절은 `when` 키워드를 활용하며, 기본적으로 함수 인자에 대한 전통적인 매칭을 수행한 후에 검증**된다.
* 가드 조건절에는 `==`나 `!=`와 같은 비교 연산자에 더해 다음과 같은 연산자들을 사용할 수 있다.
    1. `or`나 `and`, `not`과 같은 이진 및 부정 연산자
    2. `+`, `-`, `*`, `/`과 같은 산술 연산자
    3. `<>`, `++`과 같은 연결 연산자
    4. 임의의 컬렉션이나 범위에 어떠한 값이 포함되는지 확인하기 위한 `in` 연산자
    5. `is_integer/1`나 `is_atom/1`과 같은 타입 확인 함수

## 2025-10-09 Thu
### 가드 조건절을 코드에 적용하기
* 앞서 다룬 내용을 토대로, 임의의 인자 `x`의 타입을 확인하기 위한 `Guard` 모듈을 다음과 같이 작성해볼 수 있다.
```elixir
defmodule Guard do
  def what_is(x) when is_number(x) do
    IO.puts "#{x} is a number"
  end
  def what_is(x) when is_list(x) do
    IO.puts "#{inspect x} is a list"
  end
  def what_is(x) when is_atom(x) do
    IO.puts "#{x} is an atom"
  end
  # 가장 마지막에 실행되며, 상술한 가드 조건절에서 걸러내지 못한 경우에만 실행된다.
  def what_is(x) do
    IO.puts "#{inspect x} is something else... idk"
  end
end
```
* 이를 활용할 경우, 앞서 다루었던 `Factorial` 모듈도 다음과 같이 개선할 수 있다.
```elixir
defmodule Factorial do
  def of(0), do: 1
  
  # 가드 조건절을 추가한다.
  def of(n) when is_integer(n) and n > 0, do: n * of(n - 1)
  
  # 어디에도 매칭되지 않은 경우, 예외를 던지도록 한다.
  def of(n) do
    raise "Factorial is only defined for non-negative integers, got: #{inspect n}"
  end
end
```

## 2025-10-10 Fri
### 함수의 정의역을 고려한 모듈 설계
* 상술한 팩토리얼 모듈을 예로 들어, 다음과 같은 형태의 구현도 생각해볼 수 있다.
```elixir
defmodule Factorial do
  def of(0), do: 1
  def of(n) when is_integer(n) and n > 0, do: n * of(n - 1)
  
  # 이 모듈은 n이 음수인 경우를 처리할 수 없다.
end
```
* 이 경우 `-1`을 인자로 전달할 경우 매칭 가능한 함수가 없어 `FunctionClauseError`가 발생하게 되며, 이는 언뜻 좋지 않은 설계처럼 보일 수 있다.
* 그러나 **이 방식은 `Factorial.of/1`의 정의역이 음수가 아닌 정수임을 명시하므로, 오히려 의도를 명확히 표현한다고 이해하는 것이 바람직**하다.

## 2025-10-11 Sat
### 기본 파라미터 적용하기
* **기명 함수에 정의한 임의의 인자에 대해 `[인자명] \\ [기본값]` 형태로 작성하는 것으로 인자의 기본값을 지정**할 수 있다.
* 이렇듯 기본값이 지정된 인자를 포함하는 함수를 호출할 경우, 엘릭서는 전달 받은 인자의 개수와 함수의 필수 인자 개수를 비교하는 방식으로 동작한다.
    * 이 때, **기본값이 정의되지 않은 인자를 필수 인자라고 지칭**한다.
* 기본 파라미터가 적용된 기명 함수를 호출할 경우, 다음과 같은 다소 특이한 동작들을 기억할 필요가 있다.
    1. 전달된 인자의 개수가 필수 인자의 개수보다 적은 경우, 함수에 매칭되지 않는다.
    2. 전달된 인자의 개수와 필수 인자의 개수가 정확히 같은 경우, 인자는 모두 필수 인자의 자리에 순서대로 매칭된다.
    3. **전달된 인자의 개수가 필수 인자의 개수보다 많은 경우, 순서대로 적용하되 매칭되지 못한 필수 인자가 없도록 기본값이 지정된 인자를 건너뛸 수 있다**.
* 예를 들어, 다음과 같은 모듈로 상술한 세 가지 동작을 확인할 수 있다.
```elixir
defmodule Example do
  def func(p1, p2 \\ 2, p3 \\ 3, p4) do
    IO.inspect [p1, p2, p3, p4]
  end
end

Example.func("a") # **(UndefinedFunctionError)**, func/1이 존재하지 않는다는 예외 메시지가 출력된다. 
Example.func("a", "b") # ["a", 2, 3, "b"], 필수 인자부터 적용한다.
Example.func("a", "b", "c") # ["a", "b", 3, "c"], 총 인자 개수 4, 필수 인자 개수 2, 전달된 인자 개수 3이므로 순서대로 적용하되 기본값이 지정된 p3를 건너뛴다.
Example.func("a", "b", "c", "d") # ["a", "b", "c", "d"], 모든 인자가 적용된다.
```

## 2025-10-12 Sun
### 기본 파라미터가 적용된 함수의 시그니쳐
* 상술한 `Example.func`의 경우, **두 개의 필수 인자에 더해 기본값이 지정된 두 인자를 포함하므로 `func/2`부터 `func/4`까지 세 형태**를 갖는다.
    * 이로 인해 **`def func(p1, p2), do: ...`와 같은 `func/2` 함수를 다시 정의할 수 없음에 주의**해야 한다.
* 그럼에도 동일한 인자 수를 갖는 함수와 가드 조건절을 조합한 여러 정의가 필요할 수 있으며, 기본값까지 적용하고자 하는 경우에는 다음과 같이 작성해야 한다.
```elixir
defmodule Params do
  # do...end 블록을 명시할 필요 없이, 최상단에 기본값이 적용된 함수 시그니쳐만을 작성한다.
  def func(p1, p2 \\ 123)

  # 이후로는 가드 조건절에 따라 순서대로 매칭을 시도한다.
  def func(p1, p2) when is_list(p1) do
    "You said #{p2} with a list"
  end

  def func(p1, p2) do
    "You passed in #{p1} and #{p2}"
  end
end
```

## 2025-10-13 Mon
### 프라이빗 함수 정의하기
* `def` 키워드 대신 `defp` 키워드를 적용하는 것으로 임의의 기명 함수를 모듈의 프라이빗 함수로 정의할 수 있다.
    * 이 경우, 어디서든 호출 가능한 퍼블릭 함수와 달리 모듈 내에서만 호출이 가능하다.
* **프라이빗 함수 역시 동일한 함수를 여러 번 정의할 수 있으나, 다음과 같이 동일한 함수의 일부만을 프라이빗으로 적용할 수는 없다**.
```elixir
defmodule Invalid do
  def fun(a) when is_list(a), do: true
  defp fun(a), do: false
end
```

## 2025-10-14 Tue
### 파이프 연산자 활용하기
```
> 프로그래밍은 데이터를 변형하는 작업이며, 파이프 연산자는 변형을 명시적으로 드러내는 좋은 방법이다.
```
* 절차지향적인 프로그래밍을 진행할 경우, 다음과 같은 코드를 작성하는 상황이 발생하기 쉽다.
    * 이는 즉 일련의 함수 호출 흐름에서, 직전 함수 호출의 출력이 다음 함수 호출의 입력으로 사용되는 경우를 의미한다.
```javascript
const TARGET_YEAR = 2025;
const people = await getPeople();
const orders = await getOrder(people);
const tax = await salesTax(orders, TARGET_YEAR);
const filing = await prepareFiling(tax);

// 또는 아래와 같은 끔찍한 시간을 보낼 수도 있다!
// const filing = await prepareFiling(
//     await salesTax(
//         await getOrder(
//             await getPeople(),
//         ), TARGET_YEAR
//     ),
// );
```
* **엘릭서는 이러한 경우에 사용할 수 있는 강력한 연산자인 파이프 연산자(`|>`)를 제공하며, 이는 왼쪽 표현식의 결과를 오른쪽 함수의 첫 인자로 전달**한다.
    * 아래의 `sales_tax(2025)`예시의 경우 언뜻 첫 인자로 정수 리터럴이, 두 번째 인자로 `get_order`의 출력이 전달되는 것처럼 보일 수 있다.
    * 그러나 **파이프 연산자는 항상 다음 함수의 첫 번째 인자로 출력을 전달하므로, 실제로는 `sales_tax`의 두 번째 인자가 정수 리터럴**임을 알 수 있다.
    * 때문에 기본적으로는 **파이프 연산자로 표기된 `val |> f(a, b)`와 같은 표현식은 `f(val, a, b)`와 같다고 이해해도 무방**하다.
```elixir
filing = DB.get_people
  |> Orders.get_order # 모두 앞 연산의 결과를 받아 동작하며, 출력을 다음 연산의 첫번째 입력으로 전달한다!
  |> sales_tax(2025)
  |> prepare_filing
```
* 반면, **파이프라인 내에서 함수를 호출하기 위해서는 반드시 괄호를 표기해야 함에 주의**를 기울여야 한다.
# Elixir
## 2025-09-07 Sun
### 프로그래밍을 다시 생각해보기
> 프로그래밍은 데이터를 변형하는 과정이다.
* 객체지향 개발자는 클래스와 인스턴스를 기준으로 생각하는 데에 익숙하며, 이로 인해 문제를 풀기 위해 복잡한 계층 구조 모델링에 많은 시간을 쏟는다.
  * 예를 들어 클래스는 행위를 정의하고, 객체는 상태를 저장하지만 때로는 모델링 과정 자체가 필요 이상으로 복잡해지곤 한다.
* 객체를 활용한 코딩은 상태에 대해 생각하게 하며, 객체의 데이터를 은닉하는 데에 큰 노력을 기울이게 된다.
* 그러나 **이러한 개발 방식은 실세계와는 동떨어진 방법이며, 개발자는 문제를 해결해야할 뿐 상태를 관리하는 것 자체가 주목적이라고 볼 수는 없다**.
* 일반적으로, **문제를 해결하기 위해서는 데이터를 감추는 것이 아닌 그저 변형하는 것만이 필요할 수 있다**.

## 2025-09-08 Mon
### 파이프라인의 유용성과 엘릭서
* 유닉스의 도구들은 하나의 기능에 집중되며, 사용자의 의도에 따라 임의로 조합될 수 있다.
  * 이를 통해 최초로 전달된 입력은 값을 변형하고, 다음 도구나 사용자가 요구하는 출력으로 변환된다.
  * 이러한 방식은 매우 유연하고 재사용성이 높으며, 각 유닉스 도구는 자연스레 서로의 잠재력을 향상시킨다.
* 파이프라인에서 활용되는 작은 도구들은 각자 자신의 일에만 집중하면 되며, 이는 곧 테스트 역시 간편하게 작성할 수 있음을 의미한다.
* **`Elixir`(이하 엘릭서)는 유닉스의 셸과 유사한 방식으로 문제를 해결하며, 단지 명령줄 도구 대신에 작고 응집된 함수들을 활용**한다.
  * 때문에 **원하는 만큼 함수를 연결하여 사용할 수 있으며, 작고 하나의 일만 잘하는 함수일수록 더욱 유연한 활용이 가능**하다.

## 2025-09-09 Tue
### 함수형 프로그래밍의 재미
* **`변형`은 함수형 프로그래밍(이하 FP)의 핵심으로, 단지 입력을 출력으로 변형한다는 함수의 특징 그 자체에 초점**을 맞춘다.
* 극단적으로 보았을 때, FP를 학습하기 위해서는 기존의 직관을 버리고 완전히 새로운 마음으로 시작하는 것이 권장된다.
    * 즉, 객체지향 프로그래밍(이하 OOP)의 전문가가 하룻밤 사이에 함수형 프로그래밍의 전문가로 탈바꿈될 수는 없다.
* FP을 통해 OOP에서 말하는 '책임'의 관점보다 더 실용적으로 생각하는 방법을 익힐 수 있으며, FP를 학습하는 개발자는 이를 통해 시각을 더 넓힐 수 있다.

## 2025-09-10 Wed
### 엘릭서 프로그램 명명하기
* 엘릭서 소스 코드 파일은 `.ex`와 `.exs` 확장자를 사용하며, 각 확장자는 관례적으로 다음과 같은 용도로 사용된다.
    1. `.ex`: 컴파일된 엘릭서 코드 파일에 사용되며, 컴파일된 상태로 배포된다.
    2. `.exs`: 스크립트 파일에 사용되며, 인터프리터 모드로 실행되므로 간단한 스크립트 작성이나 테스트 코드 작성에 적합하다.
* 예를 들어 컴파일된 결과물을 관리할 필요가 있다면 `.ex` 확장자를 명시하는 반면, 테스트 코드는 컴파일할 필요가 없으므로 `.exs` 확장자를 사용한다.
* **엘릭서 소스 코드 파일은 영문 소문자와 `_`를 조합하여 명명하며, 코드 작성 시에는 공백(space)을 활용한 두 칸 들여쓰기를 사용**한다.

## 2025-09-11 Thu
### FP를 위한 다른 관점 지향하기
* 엘릭서를 통해 FP를 학습할 경우, 여지껏 프로그래밍에 대해 배워왔던 것이 다음과 같은 내용에 대해 새로운 관점을 지닐 수 있게 된다.
    1. OOP가 유일한 코드 설계 기법은 아니다.
    2. FP는 복잡하거나 수학적이지 않더라도 유용하게 사용될 수 있다.
    3. 프로그래밍에 `if`문이나 반복문, 할당문이 필수적인 것은 아니다.
    4. 동시성 프로그래밍에 락이나 세마포어 등이 반드시 필요한 것은 아니다.
    5. 프로세스는 반드시 비싼 자원이라고 볼 수는 없다.
* 엘릭서 역시 코딩을 위한 단 하나의 정답은 아니며, 오히려 FP를 학습하는 과정에서 프로그래밍을 바라보는 시야를 넓히고 마음을 열게 된다는 점을 기억해야 한다.

## 2025-09-12 Fri
### 엘릭서의 매치 연산자
* 엘릭서에서 등호는 할당이 아닌 단언문처럼 도착하며, **좌항의 값을 우항의 값과 같게 만들 방법이 있다면 실행에 성공**한다.
    * 이렇듯 **할당의 의미보다는 동일성을 판단하는 의미가 강하며, 때문에 `=` 연산자를 매치 연산자라고 지칭**한다.
* 엘릭서는 변수가 좌항에 있을 때에만 값을 변경할 수 있으며, 우항의 변수는 값으로 대체된다.
    * 엘릭서의 이러한 특징은 다음과 같은 코드를 통해 확인할 수 있다.
```elixir
a = 1 # 성공
1 = a # 성공, 1과 a는 같음.
2 = a # 예외 발생, a에 설정된 값인 1과 다르다. 즉, 2 = 1이 아니므로 실패한다.
```

## 2025-09-13 Sat
### 패턴 매칭이란?
* **엘릭서는 등호를 기준으로 좌항과 우항을 같게 만들 방법을 찾으며, 임의의 변수에 적절한 값을 바인딩하는 방식으로 동작**한다.
    * **이러한 과정을 `패턴 매칭`이라는 용어로 지칭하며, 좌항인 `패턴`과 우항인 `값`의 구조가 같고 각 요소를 짝지을 수 있다면 매칭에 성공**한다.
* 이러한 패턴 매칭 규칙은 다음과 같이 대괄호를 사용하는 리스트를 사용할 경우 더욱 명확히 이해할 수 있다.
```elixir
a = [1,2,3] # 성공
[1,2,3] = b # 실패, b가 정의되지 않았다
[a,b] = [1,2] # 성공
[a] = [1,2] # 실패, 리스트의 길이가 다르다.
```
* 반면, 다음과 같이 동일한 패턴 매칭에서 하나의 변수는 서로 다른 값으로 매칭될 수 없다.
```elixir
[a,a]=[1,1] # 성공, a는 1로 매칭된다.
[b,b]=[1,2] # 실패, b는 1과 2에 동시에 매칭될 수 없다.
```
* 서로 다른 매칭 과정에서는 동일한 변수에 새로운 값이 매핑될 수 있으며, 이를 방지하고자 하는 경우에는 `^a = 1` 형태의 핀 연산자를 사용해야 한다.
    * 이 경우, 변수 `a`에 1이 아닌 다른 값이 할당되어 있다면 핀 연산자에 의해 매칭에 실패한다.

## 2025-09-14 Sun
### 엘릭서와 언더스코어 변수
* 리스트를 사용하는 예시에서 알 수 있듯, **매칭은 하되 값은 변수에 담고 싶지 않은 경우가 발생할 수 있으며 이 경우에는 `_`와 같은 특수 변수를 활용**한다.
```elixir
[a] = [1,2,3] # 실패, 리스트의 길이가 다르다.
[a,_,_] = [1,2,3] # 성공, _ 변수는 무시된다.
```
* 이러한 언더스코어(`_`) 변수는 명시적으로 호출될 수는 없으며, 패턴 매칭 과정에서 모든 값을 받아들이는 와일드카드로서 사용된다.
    * 이 때, **언더스코어 변수는 마치 변수처럼 동작하지만 매칭되는 값을 즉시 버리는 식으로 동작**한다.
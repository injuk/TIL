# Elixir
## 2025-09-07 Sun
### 프로그래밍을 다시 생각해보기
> 프로그래밍은 데이터를 변형하는 과정이다.
* 객체지향 개발자는 클래스와 인스턴스를 기준으로 생각하는 데에 익숙하며, 이로 인해 문제를 풀기 위해 복잡한 계층 구조 모델링에 많은 시간을 쏟는다.
  * 예를 들어 클래스는 행위를 정의하고, 객체는 상태를 저장하지만 때로는 모델링 과정 자체가 필요 이상으로 복잡해지곤 한다.
* 객체를 활용한 코딩은 상태에 대해 생각하게 하며, 객체의 데이터를 은닉하는 데에 큰 노력을 기울이게 된다.
* 그러나 **이러한 개발 방식은 실세계와는 동떨어진 방법이며, 개발자는 문제를 해결해야할 뿐 상태를 관리하는 것 자체가 주목적이라고 볼 수는 없다**.
* 일반적으로, **문제를 해결하기 위해서는 데이터를 감추는 것이 아닌 그저 변형하는 것만이 필요할 수 있다**.

## 2025-09-08 Mon
### 파이프라인의 유용성과 엘릭서
* 유닉스의 도구들은 하나의 기능에 집중되며, 사용자의 의도에 따라 임의로 조합될 수 있다.
  * 이를 통해 최초로 전달된 입력은 값을 변형하고, 다음 도구나 사용자가 요구하는 출력으로 변환된다.
  * 이러한 방식은 매우 유연하고 재사용성이 높으며, 각 유닉스 도구는 자연스레 서로의 잠재력을 향상시킨다.
* 파이프라인에서 활용되는 작은 도구들은 각자 자신의 일에만 집중하면 되며, 이는 곧 테스트 역시 간편하게 작성할 수 있음을 의미한다.
* **`Elixir`(이하 엘릭서)는 유닉스의 셸과 유사한 방식으로 문제를 해결하며, 단지 명령줄 도구 대신에 작고 응집된 함수들을 활용**한다.
  * 때문에 **원하는 만큼 함수를 연결하여 사용할 수 있으며, 작고 하나의 일만 잘하는 함수일수록 더욱 유연한 활용이 가능**하다.

## 2025-09-09 Tue
### 함수형 프로그래밍의 재미
* **`변형`은 함수형 프로그래밍(이하 FP)의 핵심으로, 단지 입력을 출력으로 변형한다는 함수의 특징 그 자체에 초점**을 맞춘다.
* 극단적으로 보았을 때, FP를 학습하기 위해서는 기존의 직관을 버리고 완전히 새로운 마음으로 시작하는 것이 권장된다.
    * 즉, 객체지향 프로그래밍(이하 OOP)의 전문가가 하룻밤 사이에 함수형 프로그래밍의 전문가로 탈바꿈될 수는 없다.
* FP을 통해 OOP에서 말하는 '책임'의 관점보다 더 실용적으로 생각하는 방법을 익힐 수 있으며, FP를 학습하는 개발자는 이를 통해 시각을 더 넓힐 수 있다.

## 2025-09-10 Wed
### 엘릭서 프로그램 명명하기
* 엘릭서 소스 코드 파일은 `.ex`와 `.exs` 확장자를 사용하며, 각 확장자는 관례적으로 다음과 같은 용도로 사용된다.
    1. `.ex`: 컴파일된 엘릭서 코드 파일에 사용되며, 컴파일된 상태로 배포된다.
    2. `.exs`: 스크립트 파일에 사용되며, 인터프리터 모드로 실행되므로 간단한 스크립트 작성이나 테스트 코드 작성에 적합하다.
* 예를 들어 컴파일된 결과물을 관리할 필요가 있다면 `.ex` 확장자를 명시하는 반면, 테스트 코드는 컴파일할 필요가 없으므로 `.exs` 확장자를 사용한다.
* **엘릭서 소스 코드 파일은 영문 소문자와 `_`를 조합하여 명명하며, 코드 작성 시에는 공백(space)을 활용한 두 칸 들여쓰기를 사용**한다.

## 2025-09-11 Thu
### FP를 위한 다른 관점 지향하기
* 엘릭서를 통해 FP를 학습할 경우, 여지껏 프로그래밍에 대해 배워왔던 것이 다음과 같은 내용에 대해 새로운 관점을 지닐 수 있게 된다.
    1. OOP가 유일한 코드 설계 기법은 아니다.
    2. FP는 복잡하거나 수학적이지 않더라도 유용하게 사용될 수 있다.
    3. 프로그래밍에 `if`문이나 반복문, 할당문이 필수적인 것은 아니다.
    4. 동시성 프로그래밍에 락이나 세마포어 등이 반드시 필요한 것은 아니다.
    5. 프로세스는 반드시 비싼 자원이라고 볼 수는 없다.
* 엘릭서 역시 코딩을 위한 단 하나의 정답은 아니며, 오히려 FP를 학습하는 과정에서 프로그래밍을 바라보는 시야를 넓히고 마음을 열게 된다는 점을 기억해야 한다.

## 2025-09-12 Fri
### 엘릭서의 매치 연산자
* 엘릭서에서 등호는 할당이 아닌 단언문처럼 도착하며, **좌항의 값을 우항의 값과 같게 만들 방법이 있다면 실행에 성공**한다.
    * 이렇듯 **할당의 의미보다는 동일성을 판단하는 의미가 강하며, 때문에 `=` 연산자를 매치 연산자라고 지칭**한다.
* 엘릭서는 변수가 좌항에 있을 때에만 값을 변경할 수 있으며, 우항의 변수는 값으로 대체된다.
    * 엘릭서의 이러한 특징은 다음과 같은 코드를 통해 확인할 수 있다.
```elixir
a = 1 # 성공
1 = a # 성공, 1과 a는 같음.
2 = a # 예외 발생, a에 설정된 값인 1과 다르다. 즉, 2 = 1이 아니므로 실패한다.
```

## 2025-09-13 Sat
### 패턴 매칭이란?
* **엘릭서는 등호를 기준으로 좌항과 우항을 같게 만들 방법을 찾으며, 임의의 변수에 적절한 값을 바인딩하는 방식으로 동작**한다.
    * **이러한 과정을 `패턴 매칭`이라는 용어로 지칭하며, 좌항인 `패턴`과 우항인 `값`의 구조가 같고 각 요소를 짝지을 수 있다면 매칭에 성공**한다.
* 이러한 패턴 매칭 규칙은 다음과 같이 대괄호를 사용하는 리스트를 사용할 경우 더욱 명확히 이해할 수 있다.
```elixir
a = [1,2,3] # 성공
[1,2,3] = b # 실패, b가 정의되지 않았다
[a,b] = [1,2] # 성공
[a] = [1,2] # 실패, 리스트의 길이가 다르다.
```
* 반면, 다음과 같이 동일한 패턴 매칭에서 하나의 변수는 서로 다른 값으로 매칭될 수 없다.
```elixir
[a,a]=[1,1] # 성공, a는 1로 매칭된다.
[b,b]=[1,2] # 실패, b는 1과 2에 동시에 매칭될 수 없다.
```
* 서로 다른 매칭 과정에서는 동일한 변수에 새로운 값이 매핑될 수 있으며, 이를 방지하고자 하는 경우에는 `^a = 1` 형태의 핀 연산자를 사용해야 한다.
    * 이 경우, 변수 `a`에 1이 아닌 다른 값이 할당되어 있다면 핀 연산자에 의해 매칭에 실패한다.

## 2025-09-14 Sun
### 엘릭서와 언더스코어 변수
* 리스트를 사용하는 예시에서 알 수 있듯, **매칭은 하되 값은 변수에 담고 싶지 않은 경우가 발생할 수 있으며 이 경우에는 `_`와 같은 특수 변수를 활용**한다.
```elixir
[a] = [1,2,3] # 실패, 리스트의 길이가 다르다.
[a,_,_] = [1,2,3] # 성공, _ 변수는 무시된다.
```
* 이러한 언더스코어(`_`) 변수는 명시적으로 호출될 수는 없으며, 패턴 매칭 과정에서 모든 값을 받아들이는 와일드카드로서 사용된다.
    * 이 때, **언더스코어 변수는 마치 변수처럼 동작하지만 매칭되는 값을 즉시 버리는 식으로 동작**한다.

## 2025-09-15 Mon
### 등호의 개념을 재정립하기
```
> 대수학의 경우, `x = a + 1`이라는 식을 보았을 때 `x`에 `a + 1`의 값을 '할당'한다고 생각하지 않는다.
```
* 우리가 처음 수학을 배웠을 때, `x = a + 1`라는 식은 그저 변수 `x`의 값은 `a + 1`이 갖는 값과 같다는 사실만을 의미한다고 배웠다.
    * 떄문에 하나의 변수 값을 알고 있을 경우, 자연스레 다른 변수의 값도 알 수 있게 된다.
    * 그러나 이러한 개념은 처음 프로그래밍을 배울 때 프로그래밍적인 관점으로 덮어씌워져 초기의 의미를 잃게 된다.
* FP를 배우는 과정에서 우리가 원래 알던 지식으로 돌아가야할 필요가 있으며, 패턴 매칭 역시 그러한 개념 중 하나에 포함된다.
    * 이렇듯 **엘릭서의 핵심 개념의 일부는 여지껏 배워왔던 개발 관점에서의 `당연한 사실`과는 많은 차이가 있으며, 패턴 매칭 역시 그 중 하나**에 속한다.

## 2025-09-16 Tue
### FP와 불변성, 그리고 성능
```
> GOTO 문은 어떻게 현재 흐름에 도달했는지 의문을 남기게 하기에 악이었다. 반면, 가변성은 어떻게 현재 상태에 이르게 되었는지에 대한 의문을 남기게 한다.
```
* 많은 FP 언어가 그렇듯 **엘릭서는 간단한 값부터 시작해서 가장 복잡한 데이터베이스 레코드까지 모두 불변성이 보장**된다.
    * 이는 상술한 **`프로그래밍은 데이터를 변형하는 과정`이라는 점과도 잘 어울리며, 엘릭서는 임의의 데이터 원본에 대해서는 그 어떠한 변형도 가하지 않는다**.
    * 대신, 원본에 대해 변형을 가한 새로운 데이터를 생성한 후 이를 활용한다.
    * 이렇듯 **FP에서는 항상 데이터를 변형하며, 그 자리에서 데이터를 수정하는 식으로 원본에 영향을 주는 일이 없음을 기억하는 것이 바람직**하다.
* 이러한 불변 데이터의 사용은 데이터를 복사하기 위한 오버헤드와 GC 성능 저하와 같은 단점을 유발할 것처럼 보이지만, 이는 각각 다음과 같이 반박될 수 있다.
    1. 일반적으로 데이터 복사가 비효율적으로 여겨질 수 있으나, 존재하는 모든 데이터가 불변임이 보장될 경우 실제로는 그 반대로 효율성이 높다.
    2. 새로운 값을 만들 때마다 오래된 값들이 남아 많은 힙 메모리를 차지할 것 같으나, 엘릭서는 여러 프로세스를 활용하므로 오히려 메모리를 깔끔하게 정리한다.
* **데이터를 복사하여 새로운 자료 구조를 생성하는 경우 이전에 존재하는 데이터의 일부 또는 전부를 재사용할 수 있으므로 복사에 따른 오버헤드가 크지 않다**.
* 또한, **각 프로세스는 각자의 힙 메모리를 갖고 프로세스 종료 시점에 이를 모두 삭제하므로 프로세스를 잘 활용하는 엘릭서 앱은 오히려 GC 오버헤드가 낮다**.

## 2025-09-17 Wed
### 아톰이란?
* 아톰은 엘릭서의 핵심 데이터 타입 중 하나로, `:[이름]` 형태의 리터럴을 갖는다.
* 아톰의 값은 아톰에 할당된 이름과 같으며, 같은 이름을 갖는 두 아톰은 언제나 동일함이 보장된다.
    * **비교 연산에서 문자 하나하나를 비교하고, 매번 서로 다른 메모리 주소를 사용하는 문자열과 달리 아톰은 한 번만 저장되어 훨씬 좋은 성능**을 보인다.
* 아톰은 다른 프로그래밍 언어 사용자들에게는 다소 생소한 개념이나, 그 용도를 다음과 같이 정리해볼 수 있다.
    1. 상태값: `:pending`이나 `:active`, `:draft`와 같은 상태값을 나타낼 수 있다.
    2. 타입 구분: `:error`, `:ok`와 같은 타입 구분을 위해 사용될 수 있다.
    3. 설정 옵션: `:timeout`, `:max_retry`와 같은 설정 옵션에 사용될 수 있다.
* 아톰은 엘릭서의 또 다른 타입 중 맵의 키로 사용되며, `map[:key_name]` 또는 간단히 `map.key_name` 형태로 접근이 가능하다.

## 2025-09-18 Thu
### 엘릭서 컬렉션 I - 튜플과 리스트
```
> 강타입 언어의 컬렉션과 달리, 엘릭서의 컬렉션들은 서로 다른 타입의 값을 포함할 수 있다.
```
* 튜플은 여러 값은 순서 있게 모으는 컬렉션을 의미하며, 다른 엘릭서 자료구조와 마찬가지로 한 번 생성된 후에는 수정이 불가능하다.
    * **`{}`로 감싸 표현하는 튜플은 일반적으로 둘에서 넷 정도의 값을 포함하며, 그 이상의 경우 튜플보다는 맵이나 구조체를 활용하는 것이 권장**된다.
* **엘릭서의 경우, 일반적으로 함수 실행에 성공할 경우 첫 번째 값으로 `:ok`라는 아톰을 포함하는 튜플을 반환**한다.
* **엘릭서의 리스트는 링크드 리스트에 해당하며, 그 특성상 n번째 값에 접근하는 비용은 큰 반면 첫 값과 나머지를 분리하는 연산의 비용은 항상 작다**.
    * 리스트 역시 불변성을 갖기에 한 번 생성된 후에는 절대 변경되지 않는다.

## 2025-09-19 Fri
### 키워드 리스트란?
* 때로는 키-값 쌍의 리스트가 필요할 수 있으며, 엘릭서는 이를 위한 문법 설탕을 다음과 같이 지원한다.
```elixir
keyword_list = [name: "John", alias: "Wick", age: 40]
```
* 이 때, 엘릭서는 내부적으로 키워드 리스트를 `[{:name, "John"}, {:alias, "Wick"}, ...]` 형태의 2-튜플 리스트로 변환한다.
    * 즉, **키워드 리스트는 `{아톰, 값}` 형태의 2-튜플로 이루어진 리스트이며 키는 반드시 아톰**이어야 한다.
* 또한, **함수 호출 시 마지막 인지가 키워드 리스트인 경우 다음과 같이 대괄호를 생략할 수 있다**.
    * 뿐만 아니라, 엘릭서에서는 여러 값을 전달할 수 있는 모든 상황에서 마지막 값이 키워드 리스트라면 대괄호를 생략할 수 있다.
```elixir
# 아래와 같은 코드를 문법 설탕을 통해 리팩토링해보자.
# DB.save(records, [{:use_transaction: true}, {:logging: "TRACE"}])
DB.save(records, use_transaction: true, logging: "TRACE")
```

## 2025-09-20 Sat
### 엘릭서 컬렉션 II - 맵
* **맵은 `%{키 => 값}` 형태의 리터럴을 갖는 키-값 쌍 형태의 자료 구조이며, 키로는 문자열과 아톰을 비롯한 다양한 데이터 타입을 사용**할 수 있다.
    * 심지어는 `String.downcase("Name")`과 같은 표현식 까지도 키로 사용하는 것이 가능하다.
    * 일반적으로 하나의 맵에서는 모든 키를 같은 타입으로 구성하지만, 이는 반드시 따라야하는 문법적인 제약으로 볼 수는 없다.
* 반면, 키가 아톰인 경우라면 상술한 키워드 리스트와 유사한 방식으로 단축 문법을 다음과 같이 사용할 수 있다.
```elixir
map = %{name: "John", age: 40, alias: "Wick"}
```

## 2025-09-21 Sun
### 키워드 리스트와 맵의 차이점
* 키워드 리스트와 맵은 언뜻 유사해보이지만, 크게 다음과 같은 특징에서 큰 차이를 보인다.
    1. **키워드 리스트에서는 동일한 키를 여러 번 사용할 수 있지만, 맵의 경우 임의의 키는 유일**해야 한다.
    2. **맵은 크기가 커질수록 효율적이고 패턴 매칭이 가능하지만, 키워드 리스트는 그러한 성질을 갖지 않는다**.
* 이러한 차이에서, **일반적으로 명령줄 인자나 옵션 전달 시에만 키워드 리스트를 사용하고 키-값 쌍 형태의 자료구조를 위해서는 맵을 사용**한다.

## 2025-09-22 Mon
### 엘릭서의 기본 코딩 컨벤션
* 엘릭서에서 명명되는 식별자는 영문 소문자나 언더스코어(`_`)로 시작하며, 그 뒤에 영문 소문자와 숫자 및 언더스코어가 따라붙을 수 있다.
    * 즉, Python의 방식과 유사하게 단어를 언더스코어로 구분하는 스네이크 케이스(snake_case)를 따른다.
    * 이 때, 식별자는 물음표나 느낌표 문자로 끝날 수도 있다.
* 반면 **모듈이나 레코드 및 프로토콜, 비헤이비어 등은 모두 영문 대문자로 시작하여 단어를 영어 대문자로 구분하는 카멜 케이스(CamelCase)**를 따른다.
* 패턴 매칭이나 함수 인자에서 사용되지 않는 변수가 있는 경우 컴파일 과정에서 경고가 표시되나, 언더스코어로 시작하는 식별자에 대해서는 경고가 노출되지 않는다.
* 일반적으로 소스 코드의 들여쓰기는 탭 대신 두 개의 공백 문자를 사용하며, 주석에는 `#` 문자를 사용한다.

## 2025-09-23 Tue
### 엘릭서의 논리 연산 용 값
* 엘릭서에는 논리 연산에 사용하는 `true`와 `false`에 더해 특수한 값인 `nil`이 존재한다.
* 이 때, **`nil`은 논리 연산 상 거짓으로 간주되므로 `false`와 `nil`을 제외한 모든 값은 참으로 판정**된다.
    * 즉, 이는 JavaScript 진영의 `truthy` / `falsy` 개념과 유사하다.
* 반면, 상술한 세 가지 값은 동명의 아톰에 대한 별칭이므로 다음과 같이 `true`는 `:true`와 동일하다.
```elixir
true === :true # true
```

## 2025-09-24 Wed
### 엘릭서의 비교 연산
* 다른 프로그래밍 언어와 유사하게 엘릭서는 `==`과 `===` 비교 연산자를 구분하므로, 이를 다음과 같이 정리해볼 수 있다.
    1. `===`: 타입과 값이 모두 동일한 경우에만 참을 반환한다.
    2. `==`: 타입과 무관하게 값이 동일한 경우 참을 반환한다.
    3. `!==`: 타입이나 값이 하나라도 다른 경우 참을 반환한다.
    4. `!=`: 타입과 무관하게 값이 다른 경우 참을 반환한다.
* **엘릭서는 값 사이의 비교가 비교적 너그러운 언어에 속하며, 이로 인해 다른 자료형 간의 비교 연산이 허용**된다.
    * 이 때, 비교 연산의 피연산자가 모두 같거나 비교 가능한 타입에 속한 경우 일반적인 순서로 비교한다.
* 이 때, 피연산자들이 비교 가능한 타입이 아닌 경우 다음과 같이 정해진 규칙에 따라 정렬한다.
    * 이렇듯 아톰이 숫자보다 크고, `nil`은 `:nil`이라는 이름의 아톰과 동일하기에 `nil`은 항상 숫자보다 크다.
```text
숫자 < 아톰 < 레퍼런스 < 함수 < 포트 < 프로세스 Id < 튜플 < 맵 < 리스트 < 바이너리
```

## 2025-09-25 Thu
### Do 블록 스코프란?
* 대부분의 프로그래밍 언어에서 지원하는 블록 스코프(`{}`)는 엘릭서에서 지원되지 않으며, 대신 Do 블록 스코프를 활용할 수 있다.
```elixir
# if 절에 맞으면 do - end 문이 실행된다. 이 때, 엘릭서에서 if 문은 표현식이므로 값을 반환한다.
success = if (true) do
    42
  end

IO.puts success # 42가 출력된다.

failure = if (false) do
    42
  end

IO.puts failure # failure는 nil이 되며, nil을 출력하고자 하는 경우 콘솔에는 빈 줄이 출력된다.
```
* 또한, **Do 블록 스코프는 다음과 같은 단축 문법을 지원**한다.
```elixir
success = if (true),
do: 42

IO.puts success # 42가 출력된다.

failure = if (false),
  do: 42

IO.puts failure # failure는 nil이 되며, nil을 출력하고자 하는 경우 콘솔에는 빈 줄이 출력된다.
```

## 2025-09-26 Fri
### with 표현식이란?
* with 표현식은 변수의 스코프를 정의하고, 패턴 매칭에 실패한 경우 대응할 수 있도록 지원하는 기능을 제공하며, 이는 다음과 같은 예제로 확인할 수 있다.
```elixir
result = with [a | _] = [1, 2], do: a
# IO.puts a # error: undefined variable "a"
# a는 with 블록 스코프 밖에서 접근할 수 없으므로 컴파일 에러가 발생한다.

# result = with [a | _] = nil, do: a # (MatchError) no match of right hand side value: nil
# nil은 [a | _] 패턴과 매칭되지 않으므로 MatchError가 발생한다.

result = with [a | _] <- nil, do: a
# nil은 [a | _] 패턴과 매칭되지 않으나, <- 기호를 사용했기에 with 표현식은 매칭되지 않은 대상인 nil을 반환한다.
# 같은 이유에서, nil 대신 매칭되지 않는 값인 42를 반환하도록 수정하면 result는 42가 된다.
IO.puts result # nil을 출력할 경우, 콘솔에는 아무 것도 출력되지 않는다.
```
* 반면, **with 표현식은 내부적으로 함수 호출과 유사하게 처리되므로 첫 번째 인자에 대해 개행을 적용하지 않아야 하는 점에 주의**해야 한다.

## 2025-09-27 Sat
### 익명 함수 정의하기
```
> 프로그래밍의 기본은 데이터를 변형하는 것이며, 함수는 변형을 수행하는 작은 엔진으로서 엘릭서의 핵심에 위치한다.
```
* 엘릭서는 함수형 프로그래밍 언어이므로 함수는 기본 타입에 속하며, `fn` 키워드를 사용하여 익명 함수를 정의할 수 있다.
* 이러한 익명 함수는 변수에 할당하거나 다른 함수의 인자로 전달할 수 있으며, `fn_name.()` 형태로 호출할 수 있다.
```elixir
sum = fn (a, b) -> a + b end
IO.puts sum.(1, 2) # 3이 출력된다.
```
* 이 때, **익명 함수와 기명 함수는 각각 호출 방식이 다른 점에 주의**해야 한다.
    * 이는 **엘릭서의 내부적인 동작 방식이 변수는 변수 네임스페이스를, 함수는 함수 네임스페이스를 사용하며 이를 명시적으로 구분하기 위함**이다.
* 엘릭서의 함수는 인자 목록과 함수 본문으로 구성되며, 두 요소는 `->` 기호로 구분된다.
    * 또한, **엘릭서 함수의 인자 역시 할당이 아닌 패턴 매칭 개념을 사용하므로 언제나 이를 적절히 활용할 방법을 모색하는 것이 바람직**하다.
* 반면, 인자를 받지 않는 익명 함수는 다음과 같이 인자 목록을 누락시킨 구현을 사용한다.
```elixir
temp = fn -> IO.puts "Hello world!" end # Hello world!가 출력된다.
# temp = fn () -> IO.puts "Hello world!" end # 이렇게 빈 괄호를 명시적으로 작성하는 것도 가능하다.
```

## 2025-09-28 Sun
### 본문을 여럿 갖는 함수 정의하기
```
> 엘릭서 함수를 하나 정의할 때, 인자의 타입이나 내용에 따라 여러 구현을 정의하는 것이 가능하다.
```
* **엘릭서 함수를 하나 정의할 때, 인자의 타입이나 내용에 따라 여러 구현을 정의하는 것이 가능하다.**를 가져야 한다.
* 이 경우 어떠한 구현을 실행할지는 기본적으로 패턴 매칭을 통해 결정하며, 이는 다음과 같은 코드 예시로 확인할 수 있다.
```elixir
handle_open = fn
  {:ok, file} -> "First line: #{IO.read(file, :line)}"
  {_, error} -> "Error: #{:file.format_error(error)}" # atom인 :error를 명시하는 것이 아님에 주의한다!
end

IO.puts handle_open.(File.open("./hello.txt")) # 존재하는 파일에 대해서는 첫 번째 구현이 실행된다.
IO.puts handle_open.(File.open("./none.txt")) # 존재하지 않는 파일에 대해서는 두 번째 구현이 실행된다.
```
* `handle_open` 함수는 모두 튜플을 인자로 받아 동작하지만, 첫 번째 구현의 경우 튜플을 구성하는 첫 인자가 `:ok`인 경우에만 실행된다.
    * 반면, 두 번째 구현은 `_`를 활용하여 첫 번째 인자가 `:ok`가 아닌 모든 경우에 대해 동작하도록 정의된다.

## 2025-09-29 Mon
### 일급 시민으로서의 함수
* 엘릭서에서는 함수 역시 값인 일급 시민으로 취급되므로, 함수를 변수에 할당하거나 다른 함수의 인자로 전달하는 것이 가능하다.
* 이를 대표적으로 활용하는 것이 엘릭서의 빌트인 모듈인 `Enum`의 내장 함수들로, 예를 들어 `map`은 다른 언어와 유사하게 다음과 같이 동작한다.
```elixir
list = [1, 3, 5, 7, 9]
result = Enum.map list, fn elem -> elem * 2 end # [2, 6, 10, 14, 18]
```

## 2025-09-30 Tue
### 핀 연산자를 활용한 함수 인자의 고정
* 패턴 매칭에서도 사용한 핀 연산자 `^`는 패턴의 변수에 현재 변수 값을 사용하도록 고정하므로, 이를 함수 인자에도 활용하는 것이 가능하다.
```elixir
fn_for = fn (name, greeting) ->
  fn
    (^name) -> "#{greeting} #{name}"
    (_) -> "I don't know you"
  end
end

mr_valim = fn_for.("Jose", "Oi")
IO.puts mr_valim.("Jose") # Oi Jose가 출력된다.
IO.puts mr_valim.("Dave") # I don't know you가 출력된다.
```
* 상술한 함수의 경우, 핀 연산자에 의해 외부 함수인 `fn_for`에 전달된 `name`과 내부 함수에 전달된 `name`이 동일한 경우에만 첫 번째 구현이 실행된다.

## 2025-10-01 Wed
### 익명 함수의 단축 문법 활용하기 - I
* 익명 함수는 짤막한 헬퍼 함수를 정의하기 위해 자주 사용되는 문법이므로, 엘릭서는 이를 위한 단축 문법을 `&(&1 + 1)` 형태로 제공한다.
    * 이는 첫 번째 인자에 1을 던한 값을 반환하는 익명 함수인 `fn (x) -> x + 1 end`와 동일하게 동작한다.
```elixir
list = [1,2,3]
Enum.map list, &(&1 * 2) # [2,4,6]
```
* `&`로 표기되는 함수 캡쳐 연산자는 뒤의 표현식을 함수로 변환하며, `&1`, `&2` 등으로 인자를 참조한다.
    * 이 경우 `&1`은 익명 함수에 전달된 첫 번째 인자를 참조하며, `&2`는 두 번째 인자를 참조한다.

## 2025-10-02 Thu
### 단축 문법과 함수 참조
* `iex`를 실행하여 다음과 같이 단축 문법을 활용한 다양한 형태의 함수 정의를 실행하여 그 결과를 확인해볼 필요가 있다.
```shell
my_sum_with_42 = &(&1 + 42)
# #Function<42.113135111/1 in :erl_eval.expr/6> 와 유사하게 출력된다.

my_sum = &(&1 + &2)
# 항상 &:erlang.+/2 가 출력된다.

my_puts = &(IO.puts &1)
# 항상 &IO.puts/1 이 출력된다.
```
* `my_sum`의 경우 함수에 전달된 인자의 개수와 타입에서 미루어보았을 때 `IO.puts/1`과 같은 시그니쳐를 갖는다.
    * 이 경우, **엘릭서는 내부적으로 새로운 함수를 정의하는 대신 `IO.puts/1` 자체를 참조하도록 최적화하는 방식으로 동작**한다.
    * 이렇게 **최적화되기 위해서는 참조 대상 함수와 동일한 개수의 인자를 정해진 순서대로 전달해줄 필요**가 있다.
* 반면, `my_sum` 정의시 반환되는 결과에서도 확인할 수 있듯 엘릭서는 함수 호출을 `erlang` 라이브러리에 직접 매핑하기도 한다.
    * 이는 곧 **엘릭서가 `erlang` VM 위에서 동작하는 언어임을 확인할 수 있는 증거이기도 하다는 점에서 큰 의미**를 갖는다.

## 2025-10-03 Fri
### 익명 함수의 단축 문법 활용하기 - II
* 엘릭서에서 `[]`와 `{}`과 같은 기호는 모두 연산자에 해당하므로, 리스트와 튜플 리터럴 역시 함수처럼 동작할 수 있다.
    * 유사한 원리로, `&`와 같은 캡쳐 연산자는 문자열 리터럴에 대해서도 동작할 수 있다.
```elixir
divrem = &{ div(&1, &2), rem(&1, &2)}
divrem.(13, 5) # {2, 3}이 출력된다.

suffix = &"Mr. #{&1}"
suffix.("John") # Mr. John이 출력된다.
```
* 함수 캡쳐 연산자 `&`는 기명 함수의 이름과 인자 개수를 전달하는 것으로 기명 함수를 참조하는 새로운 익명 함수를 반환하도록 구현하기 위해 사용할 수도 있다.
    * 예를 들어 `l = &length/1`은 빌트인 함수인 `length`에 대한 참조를 반환하므로 `l.([1,2,3])`은 `3`을 반환한다.
```elixir
Enum.map [[1], [1,2], [1,2,3], [1,2,3,4]], &length/1 # [1, 2, 3, 4]가 출력된다.

# Enum.map [[1], [1,2], [1,2,3], [1,2,3,4]], length/1 # 이 경우 error: undefined variable "length"와 같은 오류가 발생한다. 
```
* 이렇듯 **캡쳐 연산자인 `&`를 활용한 표기법은 함수를 다른 함수에 전달하는 상황에 유용**하다.

## 2025-10-04 Sat
### 엘릭서와 모듈
* 프로그램을 작성하는 과정에서, 산출물의 규모가 커질수록 코드를 일정한 구조로 정리하고 싶을 수 있다.
* 엘릭서 역시 여타 언어와 유사하게 명명된 함수인 기명 함수들로 로직을 구분하고, 이들을 모듈로 묶어 정리하는 방식을 적용할 수 있다.
* 이 때, **엘릭서의 모든 기명 함수는 다음과 같이 항상 모듈 내에서만 정의가 가능하다는 점에 주의**를 기울여야 한다.
```elixir
defmodule Times do
  def double(n) do
    n * 2
  end
end
```
* 해당 기명 함수는 엘릭서 상에서 `double/1`로 식별되며, 필요한 경우 인자의 갯수를 늘린 `double/2` 등을 정의할 수도 있다.
    * 그러나 이름이 같은 함수는 관련성이 높은 것으로 취급되기 쉬우므로, 정말 관련이 있는 경우가 아니라면 동일한 이름의 기명 함수는 지양하는 것이 바람직하다.

## 2025-10-05 Sun
### 함수의 본문
* `do...end` 블록은 여러 줄의 표현식을 묶어 다른 코드로 전달하는 방법이며, 모듈과 기명 함수의 정의 뿐만 아니라 제어 구조 등에서도 사용된다.
* 그러나 **`do...end`는 엘릭서의 빌트인 문법이 아니며, 실제로는 `, do: (...)` 형태의 키워드 리스트에 의해 구현된 문법 설탕**이다.
    * 컴파일 과정에서 `do...end` 문법은 `do: (...)` 형태로 치환된다.
    * 반면, 실무의 경우 한 줄로 작성되는 표현식에 대해서는 `, do: (...)` 형태로 작성하되 여러 줄로 작성되는 표현식에 대해서는 `do...end`를 적용한다.

## 2025-10-06 Mon
### 함수 호출과 패턴 매칭
* 기명 함수에서도 인자에 대한 패턴 매칭이 적용되며, 하나의 함수 정의에 대해 여러 개의 구현을 작성할 수 있다.
```elixir
defmodule Factorial do
  def of(0), do: 1
  def of(n), do: n * of(n - 1)
end
```
* 위 예시에서 `of/1` 함수는 인자가 `0`인 경우와 그 외의 경우로 나누어 구현되었으며, 엘릭서는 인자의 값에 따라 적절한 구현을 선택하여 호출한다.
    * 물론, **이를 위해서는 각 구현이 받아들이는 인자의 개수가 모두 같아야** 한다.
* 이 때, **적절한 구현을 선택하기 위한 과정은 항상 위에서부터 아래로 진행되기 때문에 가장 먼저 고려되는 구현은 `of(n)`이 아닌 `of(0)`**이 된다.
    * **엘릭서는 이러한 과정을 매칭되는 함수가 나타나거나, 매칭 대상 함수가 더 이상 없을 때까지 반복하는 방식으로 동작**한다.
    * 같은 이유에서, `Factorial.of(2)`를 실행할 경우 `of(0)`의 패턴에 매칭되지 않아 `of(n)`이 호출되게 된다.

## 2025-10-07 Tue
### 함수형 프로그래밍과 재귀 호출
* 상술한 코드는 재귀 호출로 작성되어 있으며, 이렇듯 **재귀를 활용하여 설계하고 코딩하는 패턴은 엘릭서 뿐만 아니라 많은 FP 언어에서 매우 일반적**이다.
    * 반면, 엘릭서는 꼬리 최적화를 적용하지만 상술한 코드의 경우 `of(n)`의 구현에서 마지막 동작이 재귀 호출이 아니므로 최적화를 적용할 수 없다.
* 엘릭서에서 재귀 방식의 접근을 위해서는 우선 정해진 답을 반환하는 가장 간단한 경우를 하나 찾아 모듈에 포함된 기명 함수의 첫 번째 구현에 작성한다.
    * 이는 일종의 기준으로서 동작하며, 나머지 구현은 재귀 호출을 반복하다가 이러한 기준점에서 호출을 종료하기 위한 재귀적인 답으로 작성할 수 있다.
* 반면, 상술한 바와 같이 엘릭서는 기명 함수가 포함된 모듈에서 위에서부터 순서대로 패턴 매칭을 처리하므로 구현 순서에 주의를 기울여야 한다. 

## 2025-10-08 Wed
### 엘릭서의 가드 조건절
* **가드 조건절은 임의의 함수가 특정한 인자의 타입이나 조건을 만족한 경우에만 실행되도록 구현하기 위한 기능을 의미**한다.
    * 예를 들어 임의의 인자가 문자열이거나, 양수인 경우 등등 특정한 조건을 만족한 경우에만 함수가 실행되도록 구현할 수 있다.
* **가드 조건절은 `when` 키워드를 활용하며, 기본적으로 함수 인자에 대한 전통적인 매칭을 수행한 후에 검증**된다.
* 가드 조건절에는 `==`나 `!=`와 같은 비교 연산자에 더해 다음과 같은 연산자들을 사용할 수 있다.
    1. `or`나 `and`, `not`과 같은 이진 및 부정 연산자
    2. `+`, `-`, `*`, `/`과 같은 산술 연산자
    3. `<>`, `++`과 같은 연결 연산자
    4. 임의의 컬렉션이나 범위에 어떠한 값이 포함되는지 확인하기 위한 `in` 연산자
    5. `is_integer/1`나 `is_atom/1`과 같은 타입 확인 함수

## 2025-10-09 Thu
### 가드 조건절을 코드에 적용하기
* 앞서 다룬 내용을 토대로, 임의의 인자 `x`의 타입을 확인하기 위한 `Guard` 모듈을 다음과 같이 작성해볼 수 있다.
```elixir
defmodule Guard do
  def what_is(x) when is_number(x) do
    IO.puts "#{x} is a number"
  end
  def what_is(x) when is_list(x) do
    IO.puts "#{inspect x} is a list"
  end
  def what_is(x) when is_atom(x) do
    IO.puts "#{x} is an atom"
  end
  # 가장 마지막에 실행되며, 상술한 가드 조건절에서 걸러내지 못한 경우에만 실행된다.
  def what_is(x) do
    IO.puts "#{inspect x} is something else... idk"
  end
end
```
* 이를 활용할 경우, 앞서 다루었던 `Factorial` 모듈도 다음과 같이 개선할 수 있다.
```elixir
defmodule Factorial do
  def of(0), do: 1
  
  # 가드 조건절을 추가한다.
  def of(n) when is_integer(n) and n > 0, do: n * of(n - 1)
  
  # 어디에도 매칭되지 않은 경우, 예외를 던지도록 한다.
  def of(n) do
    raise "Factorial is only defined for non-negative integers, got: #{inspect n}"
  end
end
```

## 2025-10-10 Fri
### 함수의 정의역을 고려한 모듈 설계
* 상술한 팩토리얼 모듈을 예로 들어, 다음과 같은 형태의 구현도 생각해볼 수 있다.
```elixir
defmodule Factorial do
  def of(0), do: 1
  def of(n) when is_integer(n) and n > 0, do: n * of(n - 1)
  
  # 이 모듈은 n이 음수인 경우를 처리할 수 없다.
end
```
* 이 경우 `-1`을 인자로 전달할 경우 매칭 가능한 함수가 없어 `FunctionClauseError`가 발생하게 되며, 이는 언뜻 좋지 않은 설계처럼 보일 수 있다.
* 그러나 **이 방식은 `Factorial.of/1`의 정의역이 음수가 아닌 정수임을 명시하므로, 오히려 의도를 명확히 표현한다고 이해하는 것이 바람직**하다.
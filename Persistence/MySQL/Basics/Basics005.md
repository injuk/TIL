# Basics
## 2022-09-10 Sat

## 트랜잭션과 잠금
```
> 트랜잭션과 잠금은 서로 유사해보이지만, 잠금은 동시성을 제어하기 위한 기능인 반면 트랜잭션은 데이터의 정합성을 보장하기 위한 기능이라는 점이 다르다.
```
* **트랜잭션은 작업의 완전성을 보장하기 위해 존재**한다.
  * 즉, **논리적인 작업 세트를 모두 완벽하게 완료하거나 그렇지 못한 경우에는 원복하여 작업의 일부만이 적용되는 Partial Update를 미연에 방지**한다.
* 반면 **잠금은 여러 커넥션으로부터 동시에 동일한 레코드 또는 테이블과 같은 자원을 요청하는 경우, 이를 제어하기 위해 존재**한다.
  * 잠금이 없다면 단일 자원을 여러 커넥션에서 동시에 변경하게 되므로, 해당 레코드의 값을 예측할 수 없게 된다.
  * 그러나 **잠금 개념이 도입됨으로써 순서대로 한 시점에는 단 하나의 커넥션만 대상 자원을 변경할 수 있게 된다**.
* 나아가 **트랜잭션 격리 수준이란, 단일 트랜잭션 내에서 또는 여러 트랜잭션 간의 작업 내용을 어떻게 공유하고 차단할지 결정하는 레벨**을 의미한다.

### MySQL과 트랜잭션
```
> 트랜잭션은 반드시 여러 변경 작업을 수행하는 쿼리가 조합된 경우에만 의미가 있는 것은 아니다.
> 대신, 트랜잭션은 논리적인 작업 세트 내부에 쿼리가 몇 개가 있든 간에 해당 작업 세트 결과의 원자성을 보장하는 데에 의의가 있다.
```
* 몇몇 개발자는 트랜잭션 자체를 골치 아픈 기능으로 생각하곤 하며, 트랜잭션이 선택적인 MySQL 서버 환경에서는 특히 더 그렇다. 
  * 그러나 **트랜잭션은 애플리케이션 개발에서 반드시 고민해야 할 문제를 줄여주는 필수적인 DBMS의 기능**이다.
* 예를 들어, PK가 3인 컬럼이 이미 존재하는 테이블에 대해 각각 PK가 1, 2, 3인 레코드를 추가한다면 스토리지 엔진의 종류에 따라 결과는 다음과 같다.
  1. MyISAM, MEMORY: 트랜잭션이 없으므로, 1과 2의 추가에는 성공하나 3의 추가에 실패하여 결과는 `1, 2, 3` 세 개의 레코드를 남긴 채 쿼리를 종료한다.
  2. InnoDB: 트랜잭션을 지원하므로, 마찬가지로 3의 추가에서만 실패하지만 트랜잭션 처리를 위해 1과 2의 추가를 롤백하여 `3` 하나의 레코드만 남게 된다.
* 이렇듯 트랜잭션을 지원하지 않는 MyISAM 스토리지 엔진 환경에서는 부분 업데이트가 발생하기 쉽기 때문에 그만큼 테이블 데이터의 정합성을 맞추기 어렵다.
  * 부분 업데이트 현상이 발생한 경우, 실패한 쿼리로 인해 남은 불필요한 레코드를 다시 확인하여 삭제하는 재처리 작업이 필요할 수 있다.
  * 이러한 작업은 **단일 쿼리에서는 복잡하지 않을 수 있으나, 둘 이상의 쿼리가 실행되는 경우라면 재처리 작업 자체가 고되질 수 밖에 없다**.
  * **반면, InnoDB의 경우 쿼리 내용 중 일부라도 오류가 발생하면 상태를 되돌려야 한다는 트랜잭션의 원칙을 준수하므로 원자성이 보장**된다.
* **트랜잭션이 지원되지 않는 환경에서 작성된 코드는 이러한 재처리 로직을 추가하게 되어 코드의 퀄리티와 유지보수성이 크게 떨어지게 된다**.
  * 그렇다고 해서 재처리 로직을 추가하지 않는다면 쿼리 실행 실패 시 부분 업데이트의 결과로 쓰레기 데이터가 테이블에 남게 된다.
* 그러나 **트랜잭션을 지원하는 환경에서 작성한 코드는 이러한 재처리 로직을 작성할 필요 없이도 훨씬 간단한 코드로 완벽한 구현이 가능**하다.

## 2022-09-11 Sun
### 트랜잭션 주의사항
```
> 트랜잭션 역시 DBMS의 커넥션과 마찬가지로 반드시 필요한 최소한의 코드에만 적용하는 것이 바람직하다.
```
* 애플리케이션 코드 상에서 트랜잭션의 범위는 최소화되어야 하며, 불필요하게 광범위하게 적용된 트랜잭션은 좋지 않은 영향을 미칠 수 있다.
* **일반적으로 데이터베이스 커넥션은 개수가 제한적이나, 애플리케이션의 일부가 커넥션을 소유하는 시간이 길어질수록 가용한 여유 커넥션의 개수는 줄게 된다**.
  * 이러한 **상황이 악화될 경우, 애플리케이션의 일부가 커넥션을 가져가기 위해 대기해야하는 상황이 발생하기 쉽다**.
* 트랜잭션 범위 안에서 불필요한 네트워크 IO는 포함되지 않아야 한다.
  * 예를 들어, 트랜잭션 안에서 메일 등을 송신하여 사용자에게 알리는 방식의 구현은 지양해야 한다.
  * 이러한 실수로 인해 DBMS 서버가 예상치 못한 높은 부하 상태에 빠지는 등 위험 상황이 발생하기 쉽다.
  * **외부 IO는 트랜잭션 내부로부터 반드시 제거해야 하며, 외부 서비스가 가용하지 못한 경우 애플리케이션 뿐만 아니라 DBMS까지 위험해질 수 있다**.
* **반면, 단순한 데이터 확인 및 조회 쿼리의 경우 굳이 트랜잭션에 포함할 필요는 없다**.
* 이렇듯 **불필요한 작업을 많이 포함하는 광범위한 트랜잭션을 생성하기보다는 작업 단위 별로 성격에 따라 별도의 트랜잭션으로 분리하는 것이 바람직**하다.

### 트랜잭션 주의사항 - 정리
* **애플리케이션 코드 상에서, 코드가 트랜잭션을 활설화하고 있는 범위는 반드시 최소화**되어야 한다.
  * 이는 **코드 상에서 데이터베이스 커넥션을 갖는 범위는 반드시 최소화되어야 하는 것과 상통**한다.
* **외부 서비스와 상호작용하는 등의 IO 코드는 설령 그 코드 수가 한 두 줄 정도로 짧더라도 반드시 트랜잭션에서 제외**해야 한다.

### MySQL 서버 상의 잠금 분류
* MySQL에서 사용되는 잠금은 크게 다음과 같은 레벨로 분류할 수 있다.
  1. MySQL 엔진 레벨의 잠금
  2. 스토리지 엔진 레벨의 잠금
* 이 때, **MySQL 엔진은 MySQL 서버 상에서 스토리지 엔진을 제외하는 나머지 부분을 의미**한다. 
  * 이러한 **MySQL 엔진 레벨의 잠금은 모든 스토리지 엔진에 영향**을 미친다.
  * **반면, 스토리지 엔진 레벨의 잠금은 스토리지 엔진 간에는 상호적으로 영향을 주지 못한다**.
* 특히, MySQL 엔진에서는 다음과 같은 잠금 기능을 제공한다.
  1. 테이블 락: **테이블 데이터 동기화를 위해 사용**된다.
  2. 메타데이터 락: **테이블의 구조 자체를 잠그기 위해 사용**된다.
  3. 네임드 락: 사용자의 필요에 따라 사용할 수 있도록 제공되는 잠금 기능에 해당한다.

### 글로벌 락
* **글로벌 락은 `FLUSH TABLES WITH READ LOCK` 명령으로 획득할 수 있으며, MySQL이 제공하는 잠금 종류 중 가장 범위가 크다**.
  * 해당 명령은 실행과 동시에 MySQL 서버 상의 모든 테이블을 닫고 잠근다.
  * 해당 명령이 실행되기 전에 테이블 또는 레코드에 쓰기 잠금을 거는 SQL이 실행된 경우, 해당 명령은 읽기 잠금을 걸기 위해 앞선 SQL의 완료되기까지 대기한다.
* 일단 하나의 세션에서 글로벌 락을 획득했다면, 다른 세션에서는 SELECT 문을 제외한 대부분의 DDL과 DML을 실행할 수 없게 된다.
  * **정확히는 실행은 가능하나, 글로벌 락이 해제될 때까지 해당 문장은 대기 상태로 남게 된다**.
* **글로벌 락은 MySQL 서버 전체에 영향을 주며, 작업 대상 테이블이나 데이터베이스가 다르더라도 동일하게 영향을 준다**.
* 주로 여러 데이터베이스에 존재하는 MyISAM 또는 MEMORY 테이블에 대해 `mysqldump`로 일관된 백업을 받아야하는 경우에 사용한다.
* **글로벌 락은 MySQL 서버의 모든 테이블에 큰 영향을 주므로, 웹 서비스용으로 사용되는 MySQL 서버에는 가급적 사용하지 않는 것이 바람직**하다.

### 백업 락
* MySQL 서버가 업그레이드되면서 InnoDB 스토리지 엔진이 일반화되었으며, 이는 트랜잭션을 지원하므로 일관된 상태 보장을 위해 모든 변경을 멈출 필요는 없다.
* 무엇보다도 MySQL 8.0부터 InnoDB 엔진이 기본 스토리지 엔진으로 선정되었으므로, 조금 더 가벼운 글로벌 락의 필요성이 대두되었다.
  * 때문에 **MySQL 8.0 버전부터는 여러 백업 툴의 안정적인 실행을 위한 백업 락 개념이 도입**되었다.
* **임의의 세션에서 백업 락을 획득한 경우, 모든 세션에서 다음과 같은 변경이 불가능**하게 된다.
  1. 데이터베이스 또는 테이블 등의 모든 객체 생성 및 변경, 또는 삭제
  2. REPAIR TABLE과 OPTIMIZE TABLE 등의 명령
  3. 사용자 관리 및 비밀번호의 변경
* 반면, **백업 락의 경우 일반적인 테이블의 데이터 변경은 허용**한다.
* 백업 락은 긴 백업 과정이 단지 DDL 명령 하나만으로 실패하는 경우를 방지하기 위해 도입되었다.
  * 때문에 백업 락을 사용하더라도 복제는 정상적으로 진행되나, 백업의 실패를 막기 위해서 DDL 명령이 실행되는 경우 복제를 일시 중지하는 역할을 맡는다.

### 테이블 락
* 테이블 락은 개별 테이블 단위로 설정되는 잠금이며, 명시적 또는 암시적인 방식으로 임의의 테이블 락을 획득할 수 있다.
  * 예를 들어 **명시적으로는 `LOCK TABLES 테이블_이름 [ READ | WRITE ]` 명령으로 획득**할 수 있다.
  * 반면, `UNLOCK TABLES` 명령으로 획득한 잠금을 반납할 수 있다.
* 테이블 락은 MyISAM 뿐만 아니라 InnoDB 엔진을 사용하는 테이블에서도 동일한 설정이 가능하다.
* **명시적인 테이블 락 역시 글로벌 락과 동일하게 온라인 작업에 큰 영향을 주므로, 특수한 상황이 아니라면 애플리케이션에서 사용할 필요가 거의 없다**.
* **암시적인 테이블 락은 MyISAM 또는 MEMORY 테이블에서 데이터를 변경하는 쿼리를 실행한 경우에 발생**한다.
  * MySQL 서버는 데이터가 변경되는 테이블에 대해 잠금을 설정하고 나서 데이터를 변경하고, 그 이후에 즉시 잠금을 해제한다.
  * 이렇듯 **암시적인 테이블 락은 쿼리가 실행되는 과정에서 자동으로 획득되거나, 쿼리가 완료된 후에 반환**된다.
* 반면, **InnoDB의 경우 스토리지 엔진 차원에서 레코드 기반 잠금을 제공하므로 단순한 데이터 변경 쿼리로 인해 암시적인 테이블 락이 영향을 주지는 않는다**.
  * 정확히는 **InnoDB에서도 테이블 락이 설정되나, 대부분의 DML 쿼리에서는 무시**된다.
  * 그러나 **스키마를 변경하는 DDL 쿼리의 경우에는 테이블 락이 영향을 미친다**.

## 2022-09-12 Mon
### 네임드 락
* **네임드 락은 `GET_LOCK()` 함수를 활용하여 임의의 문자열에 대한 잠금을 획득하거나 반납**할 수 있다.
  * 이렇듯 네임드 락은 잠금 대상이 테이블이나 레코드, 또는 AUTO_INCREMENT와 같은 데이터베이스 객체가 아니다.
  * 대신 **단순히 사용자가 인자로 전달한 문자열에 대해 잠금을 획득하거나 반납하기 위해 사용**할 수 있다.
  * 이로 인해 네임드 락은 자주 사용되는 개념은 아니다.
* 예를 들어 1 대의 데이터베이스 서버에 여러 대의 웹 서버가 접근하는 경우, 어떠한 정보를 동기화해야할 필요성이 발생할 수 있다.
  * 이렇듯 **여러 클라이언트에 대한 상호 동기화를 처리해야하는 경우에 네임드 락을 활용하면 문제를 쉽게 해결**할 수 있다.
* 네임드 락과 관련하여 사용할 수 있는 MySQL 내장 함수는 다음과 같다.
  1. GET_LOCK(문자열, 대기시간): 첫 번째 인자로 전달한 문자열에 대해 두 번째 인자로 전달한 대기시간 초만큼 잠금을 획득하여 대기한다.
  2. IS_FREE_LOCK(문자열): 인자로 전달한 문자열에 대해 잠금이 설정되어 있는지 확인한다.
  3. RELEASE_LOCK(문자열): 인자로 전달한 문자열에 대해 잠금을 해제한다.
* 이 때, **상술한 내장 함수는 모두 정상적으로 잠금을 획득하거나 해제한 경우에는 1을 반환하며 그렇지 못한 경우에는 NULL 또는 0을 반환**한다.
* MySQL 8.0부터는 네임드 락과 관련하여 다음과 같은 기능이 신규 지원된다.
  1. 서로 다른 여러 문자열에 대해 네임드 락을 여러 번 중첩해서 사용할 수 있게 되었다.
     * 예를 들어, lock_1에 대한 작업과 lock_2에 대한 작업을 실행해야하는 경우를 가정한다.
     * 이 경우, 우선 GET_LOCK('lock_1', 10)을 실행한 후 lock_1에 대한 작업을 처리한다.
     * 그 후에 GET_LOCK('lock_2', 10)을 실행한 후 lock_2에 대한 작업을 처리한다.
     * 여기까지 현재 세션에서는 lock_1과 lock_2에 대한 잠금이 중첩되어 획득되었으며, 작업을 완료하기 전에 두 잠금을 모두 해제할 필요가 있다.
  2. 현재 세션에서 획득한 네임드 락을 `RELEASE_ALL_LOCKS()` 함수를 통해 한 번에 모두 해제할 수 있게 되었다.

### 네임드 락의 용도
* **네임드 락은 여러 레코드에 대해 복잡한 조건으로 레코드를 변경해야 하는 트랜잭션에 유용하게 사용**될 수 있다.
* 예를 들어, 배치 애플리케이션과 같이 한 번에 여러 레코드를 변경하는 쿼리는 자주 데드락을 발생시킨다.
  * 이 경우 **각 애플리케이션의 실행 시간을 분산하거나 코드를 수정하여 데드락을 최소화할 수는 있지만, 이 방식은 간단하지도 않고 완전하지도 않다**.
  * **대신 동일한 데이터를 변경하거나 참조해야만 하는 애플리케이션끼리 분류한 후, 네임드 락을 통해 쿼리를 실행하도록 하면 문제를 간단히 해결**할 수 있다.
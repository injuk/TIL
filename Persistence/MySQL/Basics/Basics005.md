# Basics
## 2022-09-10 Sat

## 트랜잭션과 잠금
```
> 트랜잭션과 잠금은 서로 유사해보이지만, 잠금은 동시성을 제어하기 위한 기능인 반면 트랜잭션은 데이터의 정합성을 보장하기 위한 기능이라는 점이 다르다.
```
* **트랜잭션은 작업의 완전성을 보장하기 위해 존재**한다.
  * 즉, **논리적인 작업 세트를 모두 완벽하게 완료하거나 그렇지 못한 경우에는 원복하여 작업의 일부만이 적용되는 Partial Update를 미연에 방지**한다.
* 반면 **잠금은 여러 커넥션으로부터 동시에 동일한 레코드 또는 테이블과 같은 자원을 요청하는 경우, 이를 제어하기 위해 존재**한다.
  * 잠금이 없다면 단일 자원을 여러 커넥션에서 동시에 변경하게 되므로, 해당 레코드의 값을 예측할 수 없게 된다.
  * 그러나 **잠금 개념이 도입됨으로써 순서대로 한 시점에는 단 하나의 커넥션만 대상 자원을 변경할 수 있게 된다**.
* 나아가 **트랜잭션 격리 수준이란, 단일 트랜잭션 내에서 또는 여러 트랜잭션 간의 작업 내용을 어떻게 공유하고 차단할지 결정하는 레벨**을 의미한다.

### MySQL과 트랜잭션
```
> 트랜잭션은 반드시 여러 변경 작업을 수행하는 쿼리가 조합된 경우에만 의미가 있는 것은 아니다.
> 대신, 트랜잭션은 논리적인 작업 세트 내부에 쿼리가 몇 개가 있든 간에 해당 작업 세트 결과의 원자성을 보장하는 데에 의의가 있다.
```
* 몇몇 개발자는 트랜잭션 자체를 골치 아픈 기능으로 생각하곤 하며, 트랜잭션이 선택적인 MySQL 서버 환경에서는 특히 더 그렇다. 
  * 그러나 **트랜잭션은 애플리케이션 개발에서 반드시 고민해야 할 문제를 줄여주는 필수적인 DBMS의 기능**이다.
* 예를 들어, PK가 3인 컬럼이 이미 존재하는 테이블에 대해 각각 PK가 1, 2, 3인 레코드를 추가한다면 스토리지 엔진의 종류에 따라 결과는 다음과 같다.
  1. MyISAM, MEMORY: 트랜잭션이 없으므로, 1과 2의 추가에는 성공하나 3의 추가에 실패하여 결과는 `1, 2, 3` 세 개의 레코드를 남긴 채 쿼리를 종료한다.
  2. InnoDB: 트랜잭션을 지원하므로, 마찬가지로 3의 추가에서만 실패하지만 트랜잭션 처리를 위해 1과 2의 추가를 롤백하여 `3` 하나의 레코드만 남게 된다.
* 이렇듯 트랜잭션을 지원하지 않는 MyISAM 스토리지 엔진 환경에서는 부분 업데이트가 발생하기 쉽기 때문에 그만큼 테이블 데이터의 정합성을 맞추기 어렵다.
  * 부분 업데이트 현상이 발생한 경우, 실패한 쿼리로 인해 남은 불필요한 레코드를 다시 확인하여 삭제하는 재처리 작업이 필요할 수 있다.
  * 이러한 작업은 **단일 쿼리에서는 복잡하지 않을 수 있으나, 둘 이상의 쿼리가 실행되는 경우라면 재처리 작업 자체가 고되질 수 밖에 없다**.
  * **반면, InnoDB의 경우 쿼리 내용 중 일부라도 오류가 발생하면 상태를 되돌려야 한다는 트랜잭션의 원칙을 준수하므로 원자성이 보장**된다.
* **트랜잭션이 지원되지 않는 환경에서 작성된 코드는 이러한 재처리 로직을 추가하게 되어 코드의 퀄리티와 유지보수성이 크게 떨어지게 된다**.
  * 그렇다고 해서 재처리 로직을 추가하지 않는다면 쿼리 실행 실패 시 부분 업데이트의 결과로 쓰레기 데이터가 테이블에 남게 된다.
* 그러나 **트랜잭션을 지원하는 환경에서 작성한 코드는 이러한 재처리 로직을 작성할 필요 없이도 훨씬 간단한 코드로 완벽한 구현이 가능**하다.
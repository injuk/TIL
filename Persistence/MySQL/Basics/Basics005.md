# Basics
## 2022-09-10 Sat

## 트랜잭션과 잠금
```
> 트랜잭션과 잠금은 서로 유사해보이지만, 잠금은 동시성을 제어하기 위한 기능인 반면 트랜잭션은 데이터의 정합성을 보장하기 위한 기능이라는 점이 다르다.
```
* **트랜잭션은 작업의 완전성을 보장하기 위해 존재**한다.
  * 즉, **논리적인 작업 세트를 모두 완벽하게 완료하거나 그렇지 못한 경우에는 원복하여 작업의 일부만이 적용되는 Partial Update를 미연에 방지**한다.
* 반면 **잠금은 여러 커넥션으로부터 동시에 동일한 레코드 또는 테이블과 같은 자원을 요청하는 경우, 이를 제어하기 위해 존재**한다.
  * 잠금이 없다면 단일 자원을 여러 커넥션에서 동시에 변경하게 되므로, 해당 레코드의 값을 예측할 수 없게 된다.
  * 그러나 **잠금 개념이 도입됨으로써 순서대로 한 시점에는 단 하나의 커넥션만 대상 자원을 변경할 수 있게 된다**.
* 나아가 **트랜잭션 격리 수준이란, 단일 트랜잭션 내에서 또는 여러 트랜잭션 간의 작업 내용을 어떻게 공유하고 차단할지 결정하는 레벨**을 의미한다.

### MySQL과 트랜잭션
```
> 트랜잭션은 반드시 여러 변경 작업을 수행하는 쿼리가 조합된 경우에만 의미가 있는 것은 아니다.
> 대신, 트랜잭션은 논리적인 작업 세트 내부에 쿼리가 몇 개가 있든 간에 해당 작업 세트 결과의 원자성을 보장하는 데에 의의가 있다.
```
* 몇몇 개발자는 트랜잭션 자체를 골치 아픈 기능으로 생각하곤 하며, 트랜잭션이 선택적인 MySQL 서버 환경에서는 특히 더 그렇다. 
  * 그러나 **트랜잭션은 애플리케이션 개발에서 반드시 고민해야 할 문제를 줄여주는 필수적인 DBMS의 기능**이다.
* 예를 들어, PK가 3인 컬럼이 이미 존재하는 테이블에 대해 각각 PK가 1, 2, 3인 레코드를 추가한다면 스토리지 엔진의 종류에 따라 결과는 다음과 같다.
  1. MyISAM, MEMORY: 트랜잭션이 없으므로, 1과 2의 추가에는 성공하나 3의 추가에 실패하여 결과는 `1, 2, 3` 세 개의 레코드를 남긴 채 쿼리를 종료한다.
  2. InnoDB: 트랜잭션을 지원하므로, 마찬가지로 3의 추가에서만 실패하지만 트랜잭션 처리를 위해 1과 2의 추가를 롤백하여 `3` 하나의 레코드만 남게 된다.
* 이렇듯 트랜잭션을 지원하지 않는 MyISAM 스토리지 엔진 환경에서는 부분 업데이트가 발생하기 쉽기 때문에 그만큼 테이블 데이터의 정합성을 맞추기 어렵다.
  * 부분 업데이트 현상이 발생한 경우, 실패한 쿼리로 인해 남은 불필요한 레코드를 다시 확인하여 삭제하는 재처리 작업이 필요할 수 있다.
  * 이러한 작업은 **단일 쿼리에서는 복잡하지 않을 수 있으나, 둘 이상의 쿼리가 실행되는 경우라면 재처리 작업 자체가 고되질 수 밖에 없다**.
  * **반면, InnoDB의 경우 쿼리 내용 중 일부라도 오류가 발생하면 상태를 되돌려야 한다는 트랜잭션의 원칙을 준수하므로 원자성이 보장**된다.
* **트랜잭션이 지원되지 않는 환경에서 작성된 코드는 이러한 재처리 로직을 추가하게 되어 코드의 퀄리티와 유지보수성이 크게 떨어지게 된다**.
  * 그렇다고 해서 재처리 로직을 추가하지 않는다면 쿼리 실행 실패 시 부분 업데이트의 결과로 쓰레기 데이터가 테이블에 남게 된다.
* 그러나 **트랜잭션을 지원하는 환경에서 작성한 코드는 이러한 재처리 로직을 작성할 필요 없이도 훨씬 간단한 코드로 완벽한 구현이 가능**하다.

## 2022-09-11 Sun
### 트랜잭션 주의사항
```
> 트랜잭션 역시 DBMS의 커넥션과 마찬가지로 반드시 필요한 최소한의 코드에만 적용하는 것이 바람직하다.
```
* 애플리케이션 코드 상에서 트랜잭션의 범위는 최소화되어야 하며, 불필요하게 광범위하게 적용된 트랜잭션은 좋지 않은 영향을 미칠 수 있다.
* **일반적으로 데이터베이스 커넥션은 개수가 제한적이나, 애플리케이션의 일부가 커넥션을 소유하는 시간이 길어질수록 가용한 여유 커넥션의 개수는 줄게 된다**.
  * 이러한 **상황이 악화될 경우, 애플리케이션의 일부가 커넥션을 가져가기 위해 대기해야하는 상황이 발생하기 쉽다**.
* 트랜잭션 범위 안에서 불필요한 네트워크 IO는 포함되지 않아야 한다.
  * 예를 들어, 트랜잭션 안에서 메일 등을 송신하여 사용자에게 알리는 방식의 구현은 지양해야 한다.
  * 이러한 실수로 인해 DBMS 서버가 예상치 못한 높은 부하 상태에 빠지는 등 위험 상황이 발생하기 쉽다.
  * **외부 IO는 트랜잭션 내부로부터 반드시 제거해야 하며, 외부 서비스가 가용하지 못한 경우 애플리케이션 뿐만 아니라 DBMS까지 위험해질 수 있다**.
* **반면, 단순한 데이터 확인 및 조회 쿼리의 경우 굳이 트랜잭션에 포함할 필요는 없다**.
* 이렇듯 **불필요한 작업을 많이 포함하는 광범위한 트랜잭션을 생성하기보다는 작업 단위 별로 성격에 따라 별도의 트랜잭션으로 분리하는 것이 바람직**하다.

### 트랜잭션 주의사항 - 정리
* **애플리케이션 코드 상에서, 코드가 트랜잭션을 활설화하고 있는 범위는 반드시 최소화**되어야 한다.
  * 이는 **코드 상에서 데이터베이스 커넥션을 갖는 범위는 반드시 최소화되어야 하는 것과 상통**한다.
* **외부 서비스와 상호작용하는 등의 IO 코드는 설령 그 코드 수가 한 두 줄 정도로 짧더라도 반드시 트랜잭션에서 제외**해야 한다.

### MySQL 서버 상의 잠금 분류
* MySQL에서 사용되는 잠금은 크게 다음과 같은 레벨로 분류할 수 있다.
  1. MySQL 엔진 레벨의 잠금
  2. 스토리지 엔진 레벨의 잠금
* 이 때, **MySQL 엔진은 MySQL 서버 상에서 스토리지 엔진을 제외하는 나머지 부분을 의미**한다. 
  * 이러한 **MySQL 엔진 레벨의 잠금은 모든 스토리지 엔진에 영향**을 미친다.
  * **반면, 스토리지 엔진 레벨의 잠금은 스토리지 엔진 간에는 상호적으로 영향을 주지 못한다**.
* 특히, MySQL 엔진에서는 다음과 같은 잠금 기능을 제공한다.
  1. 테이블 락: **테이블 데이터 동기화를 위해 사용**된다.
  2. 메타데이터 락: **테이블의 구조 자체를 잠그기 위해 사용**된다.
  3. 네임드 락: 사용자의 필요에 따라 사용할 수 있도록 제공되는 잠금 기능에 해당한다.
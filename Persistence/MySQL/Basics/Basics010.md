# Basics
## 2022-10-06 Thu

### 실행 계획이란?
* 대부분의 DBMS는 다음과 같은 주요한 목적을 갖고 설계된다.
  1. 많은 데이터를 안전하게 저장하고 관리한다.
  2. 사용자가 원하는 데이터를 빠르게 조회할 수 있도록 한다.
* 이를 위해서는 **옵티마이저가 사용자의 쿼리를 최적으로 처리할 수 있도록하는 쿼리 실행 계획을 수립할 수 있어야 한다**.
  * 그러나 옵티마이저는 외부 개입 없이 항상 최적의 실행 계획을 수립할 수 있는 것은 아니다.
  * 때문에 **DBMS 서버는 이를 DBA나 개발자가 보완할 수 있도록 옵티마이저가 수립한 실행 계획을 확인할 수 있도록 EXPLAIN 명령을 제공**한다.
* 이 때, MySQL 서버가 실행 계획에 가장 큰 영향을 주는 것은 통계 정보에 해당한다.

### 통계 정보란?
* DB가 수집하는 통계 정보는 크게 다음과 같이 분류된다.
  1. 테이블 및 인덱스에 대한 통계 정보: **테이블과 인덱스에 대한 개괄적인 정보를 의미하며, MySQL 5.7 버전까지는 해당 통계 정보에 의존**한다.
  2. 히스토그램 정보: **인덱스되지 않은 컬럼들에 대해서도 수집한 데이터 분포도를 저장한 것을 의미하며, 8.0 버전부터는 해당 정보도 함께 사용**한다.
* **5.7 버전까지는 테이블 컬럼의 값들이 실제로 어떻게 분포되어 있는지에 대한 정보를 수집하지 않으므로, 실행 계획의 정확도가 떨어지곤 했다**.
  * 이로 인해 8.0부터는 히스토그램 정보를 함께 수집한다.
* 이 때, **히스토그램이 도입되었다고 해서 8.0 버전 이후의 MySQL이 테이블 또는 인덱스의 통계 정보를 사용하지 않는 것은 아니다**.

### 테이블과 인덱스의 통계 정보
* **통계 정보가 잘못된 경우 전혀 엉뚱한 쿼리 실행 계획을 수립할 수 있으므로, 비용 기반 최적화에서 가장 중요한 것은 통계 정보**이다.
* **MySQL 역시 다른 DBMS와 마찬가지로 비용 기반의 최적화를 사용하지만, 다른 DBMS 보다 통계 정보의 휘발성이 높고 정확도는 떨어지는 단점이 존재**했다.
  * 때문에 MySQL은 쿼리 실행 계획을 수립하는 경우, 실제 테이블의 데이터를 일부분 분석하여 통계 정보를 보완하는 식으로 동작했다.
  * MySQL 5.6 버전 이후부터는 통계 정보의 정확성을 높일 수 있는 여러 방법이 도입되기 시작했으나, 여러 사용자는 이를 간과하고 기존 방식을 사용하곤 한다.

## 2022-10-07 Fri
### MySQL 서버의 통계 정보 저장
* **MySQL 5.6 버전부터는 InnoDB 스토리지 엔진을 사용하는 테이블에 대한 통계 정보를 영구적으로 저장하여 관리**할 수 있다.
  * 반면, 5.5 버전까지는 각 테이블의 통계 정보를 메모리에서만 관리할 수 있었다.
  * 이렇듯 **메모리에 관리되는 통계 정보는 당연하게도 MySQL 서버가 재시작되는 경우에 모두 휘발될 수 밖에 없다**.
  * 때문에 재시작된 MySQL 서버는 반드시 모든 테이블의 통계 정보를 다시 수집해야 할 필요가 있었다.
* 그러나 **5.6 버전부터는 각 테이블의 통계 정보를 다음과 같은 mysql DB 테이블에 관리할 수 있도록 개선되어 서버의 재시작에도 통계 정보를 잃지 않는다**.
  1. `innodb_index_stats`
  2. `innodb_table_stats`
* **5.6 버전부터는 테이블 생성시 `STATS_PERSISTENT` 옵션을 설정할 수 있으며, 해당 값에 따라 테이블 단위로 영구적인 통계 정보를 저장**할 수 있다.
  1. STATS_PERSISTENT=0: 테이블의 통계 정보를 MySQL 5.5 이전 방식대로 관리하며, 상술한 두 테이블을 사용하지 않는다.
  2. STATS_PERSISTENT=1: 테이블의 통계 정보를 상술한 두 테이블에 저장한다.
  3. STATS_PERSISTENT=DEFAULT: 이는 별도로 옵션을 설정하지 않은 것과 동일하며, `innodb_statas_persistent` 시스템 변수의 값에 따른다.
* 이 때, **`innodb_statas_persistent` 시스템 변수는 기본적으로 ON으로 설정되므로 상술한 옵션을 사용하지 않은 경우 영구적인 통계 정보를 저장**한다.
* 또한, **영구적으로 테이블의 통계 정보를 저장하지 않는 경우에도 ALTER TABLE 명령을 통해 언제든지 통계 정보의 저장 설정을 자유로이 변경**할 수 있다.

### 자동 통계 정보 갱신
* MySQL 5.5 버전까지는 테이블의 통계 정보가 메모리에 저장되었으며, 서버 재시작 시 통계 정보는 초기화되었다.
  * 이 경우, 모든 테이블의 통계 정보는 다시 수집되어야 한다.
* 또한 사용자가 인지하지 못하는 순간에도 다음과 같은 이벤트가 발생할 경우 자동으로 통계 정보를 갱신한다.
  1. 테이블이 새로 오픈되는 경우
  2. 테이블의 전체 레코드 중 1/16 이상의 레코드가 대량으로 변경되는 경우
  3. ANALYZE TABLE 명령이 실행된 경우
  4. SHOW TABLE STATUS 또는 SHOW INDEX FROM 명령이 실행된 경우
  5. InnoDB 모니터가 활성화된 경우
  6. `innodb_stats_on_metadata` 설정이 ON인 상태에서 SHOW TABLE STATUS 명령이 실행되는 경우
* 이렇듯 **통계 정보가 자주 갱신되는 경우, 쿼리를 인덱스 레인지 스캔으로 잘 처리하던 MySQL 서버가 어느 순간부터는 풀 테이블 스캔을 적용**할 수도 있다.
* 그러나 이러한 **의도치 않은 통계 정보의 변경은 영구적인 통계 정보의 도입으로 미연에 방지할 수 있게 되었다**.
  * 예를 들어, `innodb_stats_auto_recalc` 시스템 설정의 값을 OFF로 설정하여 통계 정보의 자동 갱신을 막을 수도 있다.
  * **해당 시스템 설정의 기본 값은 ON이므로, 영구적인 통계 정보를 사용하는 경우에는 해당 설정을 OFF로 변경하는 것이 바람직**하다.
* 이 때, 통계 정보를 자동으로 수집할 지의 여부 역시 테이블 생성시 `STATUS_AUTO_RECALC` 옵션을 통해 테이블 단위로 명시할 수 있다.
  1. STATUS_AUTO_RECALC=1: 5.5 버전 이전의 방식대로 자동으로 수집한다.
  2. STATUS_AUTO_RECALC=0: ANALYZE TABLE 명령이 실행되었을 때만 수집한다.
  3. STATUS_AUTO_RECALC=DEFAULT: `innodb_stats_auto_recalc` 시스템 설정 변수의 값에 따라 테이블의 통계 정보 수집 여부를 결정한다.

### 테이블 블록 샘플링 옵션
* MySQL 5.5 버전에서는 테이블의 통계 정보를 수집하는 경우, 몇 개의 InnoDB 테이블 블록을 샘플링할지 결정할 수 있었다.
  * **이러한 기능을 수행하는 옵션은 `innodb_stats_sample_pages` 시스템 설정 변수였으나, 5.6 버전부터는 해당 옵션이 제거**되었다.
* 5.6 버전 이후로부터는 대신 다음과 같은 시스템 변수가 제공된다.
  1. `innodb_stats_transient_sample_pages`: 기본 값은 8이며, 자동 통계 정보 수집 시 8개 페이지만 샘플링하여 분석된 결과를 통계 정보로 활용한다. 
  2. `innodb_stats_persistent_sample_pages`: 기본 값은 20이며, ANALYZE TABLE 실행 시 이를 샘플링 및 분석하여 통계 정보 테이블에 저장한다.

### 더 정확한 통계 정보 수집하기
* **영구적인 통계 정보를 사용하는 경우 MySQL 서버의 점검 또는 사용량이 적은 시간에 더 정확한 통계 정보를 수집하도록 유도**할 수 있다.
  * 이 때, 더 정확한 통계 정보의 수집에는 당연히 더욱 많은 시간이 소모된다.
  * 그러나 **이로 인한 통계 정보의 정확성으로 쿼리의 성능이 향상되므로 시간을 투자할 가치는 충분**하다.
* 이렇듯 **더 정확한 통계 정보를 수집하고자 하는 경우, `innodb_stats_persistent_sample_pages` 시스템 변수에 큰 값을 설정**할 수 있다.
  * 이 역시 **값을 너무 큰 값으로 설정할 경우 통계 정보 수집에 그만큼 더 많은 시간을 허비하게 되므로 충분히 주의를 기울이는 것이 바람직**하다.

### 히스토그램이란?
* MySQL 5.7 버전까지의 통계 정보는 단순히 인덱스된 컬럼의 유니크한 값의 개수 정도 뿐이었다.
  * 이는 당연히 옵티마이저가 최적의 실행 계획을 수립하기엔 부족한 정보였으므로, 옵티마이저는 인덱스의 일부 페이지를 무작위로 가져와 참조하였다.
* **MySQL 8.0 버전에서는 컬럼의 데이터 분포도를 참조할 수 있게 되었으며, 이러한 컬럼의 데이터 분포도를 히스토그램이라고 지칭**한다.
* 히스토그램 정보는 컬럼 단위로 관리되며, 자동으로 수집되지 않고 `ANALYZE TABLE ... UPDATE HISTOGRAM` 명령어로 수동으로 수집 및 관리된다.
  * 이렇게 수집된 히스토그램 정보는 시스템 딕셔너리에 저장된다.
* 이 때, 히스토그램은 크게 다음과 같은 두 종류의 타입이 지원된다.
  1. 싱글톤: 컬럼 값 개별로 레코드 수를 관리하는 히스토그램이며, Value-based 또는 도수 분포라고 지칭한다.
  2. 높이 균형 히스토그램: 컬럼 값의 범위를 균등한 수로 구분하여 관리하는 히스토그램이며, Height-based 히스토그램이라고도 지칭한다.
* **히스토그램은 버킷 단위로 구분되어 레코드 수 또는 컬럼 값의 범위를 관리하며, 히스토그램의 종류에 따라 관리 방식이 달라진다**.

### 싱글톤 히스토그램
* 싱글톤 히스토그램은 컬럼이 가지는 값 별로 버킷이 할당된다.
* 싱글톤 히스토그램은 각 버킷이 컬럼 값과 발생 빈도의 비율, 두 가지 값을 갖는다.

### 높이 균형 히스토그램
* 높이 균형 히스토그램은 개수가 균등한 컬럼 값의 범위 별로 하나의 버킷이 할당된다.
* 높이 균형 히스토그램은 각 버킷이 범위의 시작 값과 끝 값, 그리고 발생 빈도율과 버킷 별 유니크한 값의 개수 등 네 가지 값을 갖는다.

### column_statistics 테이블
* **수집된 히스토그램 정보는 시스템 딕셔너리에 저장되고, MySQL 서버가 시작될 때 딕녀서리의 히스토그램 정보가 로드**된다.
  * 정확히는 `information_scheam.column_statistics` 테이블로 로드된다.
* 해당 테이블의 HISTOGRAM 컬럼이 갖는 나머지 필드들은 다음과 같은 의미를 갖는다.
  1. sampling-rate: 히스토그램 정보를 수집하는 과정에서 스캔하는 페이지의 비율을 의미하며, 0.35의 경우 35%를 샘플링한 셈이 된다.
     * 샘플링 비율이 높아질수록 정확한 히스토그램이 되지만, 점차 테이블을 전부 스캔하게 되므로 부하가 높고 시스템 자원을 많이 소모하게 된다.
  2. histogram-type: 히스토그램의 종류를 설정한다.
  3. number-of-buckets-specified: 히스토그램 생성 시 설정한 버킷의 개수를 설정한다.
     * **8.0.19 미만의 버전에서 히스토그램은 상술한 시스템 변수와 관계 없이 푸 ㄹ 스캔을 통해서만 데이터 페이지를 샘플링하여 히스토그램을 생성**했다.
     * 때문에 자신이 사용 중인 버전이 8.0.19 미만인 경우, 히스토그램 수집 시 반드시 주의를 기울여야 한다.

### 히스토그램의 삭제
* 히스토그램은 다음과 같은 쿼리로 삭제할 수 있으며, **해당 작업은 테이블의 데이터를 참조하지 않고 딕셔너리의 내용만을 삭제**한다.
  * 때문에 **다른 쿼리 처리 성능에는 영향을 주지 않은 채 즉시 완료할 수 있는 반면, 히스토그램이 삭제된 경우에는 쿼리 실행 계획이 달라질 수 있다**.
```
ANALYZE TABLE employees.employees DROP HISTOGRAM ON gender, hire_date;
```
* 또한, `optimizer_switch` 시스템 변수의 값을 변경하는 것으로 히스토그램을 삭제하지 않고도 옵티마이저가 히스토그램을 사용하지 않도록 할 수 있다.
  * 예를 들어, `SET GLOBAL optimizer_switch='condition_fanout_filter=off';` 명령어를 사용할 수 있다.
  * 이는 GLOBAL 스코프에 적용되므로 MySQL 서버의 모든 쿼리가 히스토그램을 사용하지 않게 되며, 당연히 특정 커넥션 또는 특정 쿼리에만 적용할 수도 있다.
  * 그러나 **condition_fanout_filter 옵션에 의해 영향 받는 최적화 기능들이 사용되지 않을 가능성 역시 존재**한다.  

## 2022-10-08 Sat
### 히스토그램의 용도
```
> 히스토그램은 데이터가 특정 범위에 많고 적음을 식별할 수 있게하며, 특히 조인 시에 성능 향상을 기대할 수 있다.
```
* 히스토그램이 도입되기 전에도 테이블과 인덱스에 대한 통계 정보는 존재했으나, 이는 전체 레코드 개수와 인덱스된 컬럼의 유니크한 값의 수 정도에 불과했다.
  * **옵티마이저는 이를 통해 실행 게획을 예측하여 수립하였으나, 실제 응용 프로그램의 데이터는 항상 균등한 분포도를 가질 수는 없으므로 한계가 분명**했다.
  * 이러한 **단점을 보완하기 위해 도입된 것이 히스토그램으로, 버킷 별로 레코드 수와 유니크한 값의 수 정보를 갖기에 훨씬 정확한 예측이 가능**하다.
* 즉, **히스토그램 정보가 없는 경우 옵티마이저는 데이터가 균등하게 분포되어 있을 것으로 예측**한다.
  * 그러나 **히스토그램이 존재한다면 특정 범위에 있는 데이터가 많거나 적음을 식별할 수 있게 되어 쿼리의 성능에 지대한 영향**을 줄 수 있게 된다.
* 예를 들어, 조인 쿼리 실행 시 옵티마이저는 테이블의 전체 레코드 수나 크기 등의 단순한 정보만으로 드라이빙 테이블을 결정하게 된다.
  * 이는 **곧 상황에 따라 어떤 테이블이든 조인 드라이빙 테이블이 될 수 있다는 뜻이므로, 쿼리의 성능은 최악의 경우에 엄청난 차이를 보이게 된다**.
  * 반면, **각 컬럼에 대한 히스토그램 정보가 존재하는 경우 어떠한 테이블을 먼저 읽어들여 조인의 횟수를 줄일지 옵티마이저가 더 정확하게 판단**할 수 있다.

### 히스토그램과 인덱스
```
> 히스토그램과 인덱스는 완전히 다른 객체이므로, 일반적으로 비교 대상이 될 수는 없다.
> 그러나 MySQL의 경우 인덱스가 부족한 통계 정보를 수집하기 위해 사용된다는 측면에서 미루어 보았을 때에는 어느 정도의 공통점을 발견할 수 있다.
> 인덱스 다이브와 히스토그램을 모두 사용할 수 있는 경우, 옵티마이저는 기본적으로 실제 샘플링 결과인 인덱스 다이브를 우선적으로 활용한다.
```
* 옵티마이저는 쿼리 실행 계획 수립 시 대략적으로 다음과 같은 절차를 따른다.
  1. 사용 가능한 인덱스들을 선정한다.
  2. 조건 절에 일치하는 레코드 건수를 대략적으로 파악한다.
  3. 최종적으로 가장 좋은 실행 계획을 선택한다.
* 이 때, **2.의 과정에서 조건 절에 일치하는 레코드 수를 예측하기 위해서 옵티마이저는 실제 인덱스의 B-Tree를 샘플링하여 확인**한다.
  * 이러한 작업은 인덱스 다이브라는 용어로 지칭한다.
* **MySQL 8.0의 경우, 인덱스된 컬럼을 조건 절로 사용한다면 해당 컬럼의 히스토그램은 사용하지 않고 대신 인덱스 다이브를 통해 수집한 정보를 활용**한다.
  * 즉, **실제 검색 조건 대상 값에 대한 샘플링을 진행하므로 항상 히스토그램보다 정확한 결과를 기대**할 수 있다. 
* 상술한 이유에서, **히스토그램은 주로 인덱스되지 않은 컬럼에 대한 데이터 분포를 참조하는 용도로 사용**된다. 
  * 그러나 **인덱스 다이브는 어느 정도의 비용을 소모하며, IN 절에 값이 많이 명시된 경우 등에는 실행 계획 수립만으로도 상당한 비용을 사용**하기도 한다. 

### 코스트 모델
```
> 코스트 모델이란, 전체 쿼리의 비용을 계산하기 위해 필요한 단위 작업들의 비용을 의미한다.
```
* MySQL 서버가 쿼리를 처리하는 경우, 다음과 같은 다양한 작업은 필수적이다.
  1. 디스크 또는 메모리 상의 InnoDB 버퍼 풀로부터 데이터 페이지 읽기
  2. 인덱스 키 비교하기
  3. 레코드 평가하기
  4. 메모리 또는 디스크 상의 임시 테이블 작업하기
* **MySQL은 사용자의 쿼리에 대해 상술한 다양한 작업이 얼마나 필요할지 예측하고, 전체 작업 비용을 계산하여 최적의 실행 계획을 수립**한다.
  * 이 때, MySQL 5.7 이전까지는 이러한 작업들의 비용을 소스 코드 상에 상수화해두었다.
  * 그러나 **각 작업 비용은 MySQL 서버의 HW에도 영향을 받을 수 있으므로 일률적으로 상수화된 비용을 적용하는 것은 한계가 분명**했다.
* 이를 보완하기 위해 5.7 버전부터 상수화되어 있던 각 단위 작업 비용을 관리자가 조절할 수 있도록 개선되었다.
  * 그러나 **5.7 역시 인덱스되지 않은 컬럼의 데이터 분포인 히스토그램이나 메모리에 상의 페이지의 비율 등, 비용과 관련된 정보가 부족한 것은 마찬가지**이다.
* MySQL 8.0 버전에 와서야 히스토그램과 각 인덱스 별로 메모리에 적재된 페이지의 비율이 관리되기 시작하였으며, 이를 옵티마이저의 실행 계획 수립에 반영한다.
* **코스트 모델에서 중요한 것은 각각의 단위 작업에 설정된 값이 변경되었을 때, 어떤 실행 계획이 고비용 또는 저비용으로 바뀌는지 파악하는 것**이다.

### MySQL 8.0의 코스트 모델 관련 테이블
* MySQL 8.0 서버의 코스트 모델은 다음과 같은 두 개의 테이블에 저장된 설정 값을 사용하며, 이들은 모두 mysql DB에 존재한다.
  1. server_cost: 인덱스를 찾거나 레코드를 비교하거나 임시 테이블을 처리하는 등에 대한 비용을 관리한다.
  2. engine_cost: 레코드를 가진 데이터 페이지를 가져오는 데에 필요한 비용을 관리한다.
* 이 때, 상술한 **각각의 테이블에 저장된 여러 단위 작업의 비용을 변경하는 것으로 옵티마이저가 수립하는 실행 계획에 영향**을 줄 수 있다.
  * 그러나 **코스트 모델은 MySQL 서버의 HW와 내부적인 처리 방식에 대한 깊이 있는 지식을 필요로 하므로, 각 비용을 반드시 수정해야 하는 것은 아니다**.
  * 때문에 **MySQL의 처리 방식에 대한 전문적인 지식을 갖고 있지 않다면 두 테이블에 기본으로 설정된 값을 변경하지 않는 것이 바람직**하다.
  * 무엇보다, MySQL 서버에 적용된 기본 값만으로도 MySQL 서버는 20년 이상 수 많은 환경에서 잘 사용되어 왔다.

## 2022-10-09 Sun
### 실행 계획 확인하기
* **MySQL의 경우, DESC 또는 EXPLAIN 명령을 통해 실행 계획을 확인**할 수 있다.
* 또한, MySQL 8.0 버전 이후로는 EXPLAIN 명령에 더해 표시 형식을 트리 형태나 JSON 또는 테이블 형태로 선택할 수도 있다.
  * 각 포맷에 따라 보여지는 정보에 다소의 차이가 있을 수 있으나, 옵티마이저가 수립한 실행 계획의 큰 결을 보여준다는 점에서는 차이가 없다.
  * 반면, 8.0 버전에 들어서는 이전 버전에서 사용되던 `EXPLAIN EXTENDED` 또는 `EXPLAIN PARTITIONS` 문법은 제거되었다.

### 쿼리의 실행 시간 확인하기
* MySQL 8.0.18 버전부터는 쿼리 실행 계획에 단계 별 소요 시간 정보를 확인할 수 있는 `EXPLAIN ANALYZE` 명령이 추가되었다.
  * 물론 **`SHOW PROFILE`로도 소요 시간을 확인할 수 있으나, 이는 실행 계획의 단계 별로 소요된 시간 정보를 보여주지는 않는다**.
* 이 때, `EXPLAIN ANALYZE` 명령의 결과로는 다음과 같은 정보가 표시된다.
  1. actual time: 단계 별로 실제 소요된 시간
  2. rows: 처리한 레코드의 수
  3. loops: 반복 횟수
* 이 때, actual time과 rows 는 loops의 값이 1보다 큰 경우에 평균 시간과 평균 레코드 수를 의미하게 된다.
* **EXPLAIN ANALYZE는 실제로 쿼리를 실행하는 과정에서 사용된 실행 계획과 소요 시간을 보여주므로, 쿼리가 반드시 완료되어야 결과를 확인**할 수 있다.
  * 즉, 쿼리 실행 시간이 많이 걸리더라도 완료가 되어야 결과를 확인할 수 있으며 이는 단순히 실행 계획만 추출하여 반환하는 EXPLAIN 명령의 특징과 상반된다.
* 때문에 **쿼리의 실행 계획 자체가 아주 나쁜 경우에는 우선 EXPLAIN 명령으로 확인한 실행 계획을 토대로 쿼리를 우선 튜닝하는 것이 바람직**하다.
  * 이렇듯 EXPLAIN에서 확인한 실행 계획을 기반으로 '나쁜 쿼리'를 어느 정도 튜닝한 후에야 비로소 EXPLAIN ANALYZE 명령을 실행하는 것이 바람직하다.

### 기초적인 실행 계획 분석
* 아무런 옵션 없이 EXPLAIN 명령을 실행한 경우, 쿼리에 따라 한 줄 이상의 결과가 테이블 형태로 표시된다.
  * 이 때, **표의 각 라인은 쿼리 문장에서 사용한 테이블의 개수만큼 표시되며 서브쿼리로부터 생성된 임시 테이블 역시 포함**된다.
* **실행 순서는 일반적으로 위에서부터 아래로 표시되며, 위쪽에 출력되었거나 id 컬럼이 작을수록 쿼리의 바깥 부분이거나 먼저 접근된 테이블을 의미**한다.
  * 당연히 아래쪽에 출력되었거나 id 컬럼의 값이 클수록 쿼리의 안쪽 부분 또는 나중에 접근된 테이블을 의미한다.
  * 반면, UNION 또는 상관 서브쿼리의 경우 순서대로 표시되지 않을 수도 있다.

### 실행 계획 - id 컬럼
* 하나의 SELECT 문은 또 다른 하나 이상의 서브 SELECT 문을 포함할 수 있다.
  * 이 때, 이렇듯 SELECT 키워드 단위로 구분한 것을 단위 SELECT 쿼리라고 지칭할 수 있다.
* **id 컬럼은 실행 계획의 가장 왼 편에 표시되며, 각 단위 SELECT 쿼리 별로 부여되는 식별자에 해당**한다.
  * 반면, **단일 SELECT 문에서 여러 테이블이 조인되는 경우에는 테이블 개수만큼의 실행 계획 레코드가 출력되지만 같은 id를 사용**한다.
  * 이 경우, **실행 계획에서 더 위에 표시되는 row에 명시된 테이블이 조인의 드라이빙 테이블이며 나머지는 드리븐 테이블이 된다**. 
* **중요한 것은 실행 계획의 id 컬럼이 반드시 테이블의 접근 순서를 의미하지는 않는다는 사실**이다.

### 실행 계획 - select_type 컬럼
* 해당 컬럼은 각 단위 SELECT 쿼리가 어떤 타입의 쿼리인지 표시하며, 다음과 같은 값을 가질 수 있다.
  1. SIMPLE: **UNION 또는 서브쿼리를 사용하지 않는 단순 SELECT 쿼리 또는 조인을 포함하는 경우에 해당**한다.
     * 쿼리가 아무리 복잡해지더라도 SIMPLE 타입의 단위 쿼리는 단 하나만 존재하며, 일반적으로는 가장 바깥 단위 SELECT 쿼리가 된다.
  2. PRIMARY: UNION이나 서브쿼리를 갖는 경우 가장 바깥에 있는 단위 쿼리를 의미한다.
     * SIMPLE과 마찬가지로 PRIMARY 단위 SELECT 쿼리는 단 하나만 존재할 수 있으며, 쿼리의 가장 바깥에 위치한다.
  3. UNION: UNION으로 결합하는 단위 SELECT 쿼리 중 첫 번째를 제외한 두 번째 이후 단위 SELECT 쿼리이다.
     * **UNION의 첫 단위 SELECT 쿼리는 UNION되는 결과를 모아 저장하는 임시 테이블을 포함하므로 DERIVED**가 된다.
  4. DEPENDENT UNION: UNION과 마찬가지로 UNION 또는 UNION ALL로 결합되는 쿼리에서 표시되는 반면, 결합된 단위 쿼리가 외부 쿼리에 영향을 받는다.
     * 즉, **DEPENDENT 키워드는 UNION 또는 UNION ALL로 결합되는 내부 쿼리가 외부 쿼리의 값을 참조하여 처리되는 경우에 표시**된다.
  5. UNION RESULT: UNION의 결과를 담기 위해 버퍼링 용도로 사용되는 임시 테이블이며, 실제 단위 쿼리는 아니므로 id 값은 부여되지 않는다.
     * MySQL 8.0 이전에는 UNION ALL과 UNION 결과는 모두 임시 테이블로 생성되었으나, 8.0에서는 UNION ALL의 결과는 임시 테이블을 사용하지 않는다.
     * 그러나 여전히 UNION의 결과는 임시 테이블에 버퍼되어야 하며, 이는 실행 계획 상 UNION RESULT로 명시된다.
  6. SUBQUERY: 일반적인 서브쿼리는 여러가지를 통틀어 표현하는 용어이나, **실행 계획에서는 FROM 절 이외에서 사용되는 서브쿼리만을 의미**한다.
     * 이렇듯 **FROM 절 외에 사용된 서브쿼리의 select_type은 전부 SUBQUERY로 표시되지만, FROM 절에 사용되는 서브쿼리는 DERIVED로 표시**된다.
     * 서브쿼리는 위치에 따라 다음과 같은 이름을 가질 수 있다.
       1. 중첩된 쿼리: SELECT되는 컬럼에 사용된 서브쿼리를 의미한다.
       2. 서브쿼리: WHERE 절에서 사용되는 경우이며, 일반적인 서브쿼리에 해당한다.
       3. 파생 테이블: FROM 절에 사용된 서브쿼리를 MySQL에서 지칭하는 용어이며, 일반적인 RDBMS에서는 인라인 뷰 또는 서브 셀렉트라고 표현한다.
  7. DEPENDENT SUBQUERY: 서브쿼리가 바깥 SELECT문에 정의된 컬럼을 사용하는 경우이며, 안쪽 서브쿼리 결과는 바깥 SELECT 쿼리의 컬럼에 의존한다.
     * **DEPENDENT UNION과 마찬가지로 외부 쿼리가 먼저 수행된 후에 내부 서브쿼리가 실행되므로, 일반적인 서브쿼리보다 처리 속도가 느린 경우가 많다**. 
  8. DERIVED: 단위 SELECT 쿼리의 실행 결과로 메모리나 디스크에 임시 테이블인 파생 테이블을 생성하는 경우를 의미한다.
  9. DEPENDENT DERIVED: MySQL 8.0부터 래터럴 조인으로 FROM 절의 서브쿼리에서 외부 컬럼을 참조할 수 있으며, 해당 select_type은 이를 의미한다.
     * 반면, 그 이전 버전에서는 FROM 절의 서브쿼리에서 외부 컬럼을 사용할 수 없었다.
  10. UNCACHEABLE SUBQUERY: 서브쿼리에 포함된 요소에 의해 서브쿼리 캐시 자체가 불가능한 경우에 표시되는 select_type에 해당한다.
      * 기본적으로 하나의 쿼리 문장에 서브쿼리가 하나만 존재하더라도, 해당 항상 서브쿼리가 한 번만 실행되지는 않는다.
      * 그러나 **조건이 같은 서브쿼리가 실행되는 경우, 이전의 실행 결과를 내부적인 캐시 공간에 캐시하여 재사용**한다.
        * SUBQUERY의 경우 외부 쿼리에 영향을 받지 않으므로, 최초 한 번만 실행 후 캐싱하여 이후에는 해당 정보를 재사용한다.
        * DEPENDENT SUBQUERY의 경우 외부 쿼리의 컬럼 값 단위로 캐싱하여 재사용한다.
      * 예를 들어, 다음과 같은 경우에 서브쿼리 캐싱은 불가능하다.
        1. 사용자 변수가 서브쿼리에 사용된 경우
        2. NOT-DETERMINISTIC 속성의 스토어드 루틴이 서브쿼리에서 사용된 경우
        3. UUID() 또는 RAND() 등 호출할 때마다 결과값이 달라지는 함수가 서브쿼리에 사용된 경우
  11. UNCACHEABLE UNION: UNION과 UNCACHEABLE 키워드의 속성이 혼합된 경우를 의미한다.
  12. MATERIALIZED: DERIVED와 유사하게 쿼리 내용을 임시 테이블로 생성하는 것을 의미한다.
      * 해당 select_type은 주로 FROM 절이나 IN(subquery) 형태로 사용된 서브쿼리를 최적화하기 위해 사용된다.
      * 이 경우, **서브쿼리의 내용은 임시 테이블로 구체화된 후에 이를 서브쿼리의 외부 쿼리와 조인하는 형태로 최적화하여 처리**된다.
      * 이 때, **우선 처리되어 임시 테이블로 구체화되는 서브쿼리는 실행 계획의 select_type 컬럼이 MATERIALIZED로 표시**된다.

## 2022-10-10 Mon  
### 서브쿼리 주의사항
* **쿼리를 튜닝할 경우, 실행 계획에서 가장 먼저 확인해야하는 것은 DERIVED로 처리되는 작업을 확인하는 것**이다.
* **서브쿼리를 조인으로 해결할 수 있는 경우, 항상 서브쿼리보다 조인을 사용하는 것이 권장**된다.
  * 서브쿼리를 사용하는 것이 편하고 생산성이 높을 수는 있으나, 쿼리의 성능은 조인보다 떨어진다.
  * 때문에 **서브쿼리로 최초 쿼리를 작성했더라도, 조인으로 풀어 쓸 수 있는 경우라면 조인으로 고치는 습관을 들이는 것이 바람직**하다.

### 실행 계획 - table 컬럼
* **MySQL 서버의 실행 계획은 단위 SELECT 쿼리 기준이 아닌 테이블 기준으로 표시**된다.
  * 이 떄, `SELECT NOW();`와 같이 별도의 테이블을 사용하지 않는 SELECT 문은 실행 계획에서 해당 컬럼이 NULL로 표시된다.
* **table 컬럼에는 `<derivedN>` 또는 `<union M,N>`과 같이 꺾쇠를 사용하는 이름이 명시되는 경우가 있으며, 이는 임시 테이블을 의미**한다.
  * 이 때, **꺾쇠 안에 표시되는 숫자는 SELECT 쿼리의 실행 계획에서 적용된 id 컬럼 값을 의미**한다.
  * 예를 들어, 해당 컬럼이 `<derived2>`로 표시되었다면 해당 테이블은 단위 SELECT 쿼리의 식별자가 2인 실행 계획으로부터 생성된 파생 테이블이 된다.
* **table 컬럼은 상술한 id 및 select_type 컬럼과 함께 실행 계획의 각 라인에 명시된 테이블이 어떤 순서로 실행되는지 판단할 수 있는 근거를 제공**한다.
* MySQL 8.0부터는 서브쿼리에 대한 최적화가 많이 개선되었으며, 예를 들어 select_type이 MATERIALIZED로 표시되는 경우가 있다.
  * 이 때, **select_type이 MATERIALIZED로 표시되는 실행 계획에는 `<subqueryN>`과 같은 형태의 table 컬럼이 표시**된다.
  * 이는 서브쿼리 결과를 구체화하여 임시 테이블로 생성했다는 의미이며, 해석 자체는 `<derivedN>`와 다를 것이 없다.

### 실행 계획 - partitions 컬럼
* MySQL 5.7 버전까지는 옵티마이저가 사용하는 파티션 목록을 EXPLAIN PARTITION 명령으로 확인할 수 있었다.
  * 반면, 8.0 부터는 EXPLAIN 명령에 파티션 관련 실행 계획이 모두 표시되도록 개선되었다.
* 옵티마이저는 실행 계획을 수립하는 과정에서 특정한 파티션에만 접근하여 결과를 생성할 수 있을 것으로 판단한 경우, 나머지 파티션은 분석하지 않는다.
  * 예를 들어, 임의의 파티션 하나로 결과를 생성할 수 있는 경우 나머지 파티션에 대한 접근 방식 또는 데이터 분포 분석을 실행하지 않는다.
  * 이렇듯 **여러 파티션을 갖는 테이블에서 불필요한 파티션을 제외하고 쿼리를 수행하기 위해 접근할 파티션만 골라내는 과정을 파티션 프루닝이라고 표현**한다.
* 임의의 쿼리가 파티션 키 컬럼을 WHERE 조건으로 지정하는 등 파티션을 참조할 수 있는 경우, 옵티마이저는 partitions 컬럼에 필요한 파티션 목록을 표시한다.
  * 해당 정보를 토대로 사용자는 쿼리의 튜닝을 진행할 수 있게 된다.
* **일반적인 RDBMS에서 파티션은 물리적으로 마치 개별 테이블처럼 별도의 저장 공간을 가지므로, 실행 계획이 ALL로 수립되더라도 실제 테이블을 읽지 않는다**.
  * 대신 물리적인 별도 공간에 저장된 파티션을 대상으로 풀 테이블 스캔을 진행하여 레코드를 읽어들이게 된다.

### 실행 계획 - type 컬럼
* 수립된 **쿼리 실행 계획에서, type 이후의 컬럼은 MySQL 서버가 각 테이블의 레코드를 어떤 방식으로 조회했는지를 의미**한다.
  * 이 때, 방식이란 인덱스를 사용하여 레코드를 읽었는지 또는 테이블을 처음부터 모두 읽어들이는 풀 테이블 스캔을 적용하였는지 등을 의미한다.
* **일반적으로 쿼리를 튜닝하는 경우, 인덱스를 효율적으로 사용하는지 확인하는 것이 중요하기에 실행 계획에서 type 컬럼은 반드시 체크하는 것이 바람직**하다.
* MySQL에서는 type 컬럼을 조인 타입으로도 소개하며, 이는 MySQL이 하나의 테이블로부터 레코드를 읽는 작업까지도 조인처럼 처리하는 데에서 기인한다.
  * 때문에 SELECT 쿼리의 테이블 개수와 관계 없이 type 컬럼은 항상 조인 타입으로 명시된다.
  * **그렇다고 해서 type 컬럼의 값을 조인과 직접 연관지어 생각하는 것보다는 항상 각 테이블에 대한 접근 방법 정도로 해석하는 것이 바람직**하다.

### type 컬럼의 종류
* 실행 계획의 **type 컬럼에는 다음과 같은 값이 표시될 수 있으며, 아래로 갈수록 처리 성능은 느려진다**.
  1. system
  2. const
  3. eq_ref
  4. ref
  5. fulltext
  6. ref_or_null
  7. unique_subquery
  8. index_subquery
  9. range
  10. index_merge
  11. index
  12. ALL
* **이 중 ALL을 제외한 모든 방식은 인덱스를 사용하는 접근 방식인 반면, ALL은 인덱스를 사용하지 않고 테이블 전체를 조회하는 풀 테이블 스캔을 의미**한다.
* 이 때, **단일 SELECT 쿼리는 상술한 12가지 방법 중 하나만을 사용할 수 있으며, index_merge를 제외한 나머지 방식은 하나의 인덱스만을 사용**한다.
  * 때문에 실행 계획에서도 각 라인에 접근 방법은 둘 이상 표시되지 않고, index_merge 이외의 방식은 인덱스 항목에도 하나의 인덱스만 표시된다.
* 이렇듯 **옵티마이저는 상술한 방식들의 접근 방법과 비용을 함께 고려하여 최소의 비용이 소모되는 접근 방법을 선택하여 쿼리를 처리**한다.
# Basics
## 2022-10-06 Thu

### 실행 계획이란?
* 대부분의 DBMS는 다음과 같은 주요한 목적을 갖고 설계된다.
  1. 많은 데이터를 안전하게 저장하고 관리한다.
  2. 사용자가 원하는 데이터를 빠르게 조회할 수 있도록 한다.
* 이를 위해서는 **옵티마이저가 사용자의 쿼리를 최적으로 처리할 수 있도록하는 쿼리 실행 계획을 수립할 수 있어야 한다**.
  * 그러나 옵티마이저는 외부 개입 없이 항상 최적의 실행 계획을 수립할 수 있는 것은 아니다.
  * 때문에 **DBMS 서버는 이를 DBA나 개발자가 보완할 수 있도록 옵티마이저가 수립한 실행 계획을 확인할 수 있도록 EXPLAIN 명령을 제공**한다.
* 이 때, MySQL 서버가 실행 계획에 가장 큰 영향을 주는 것은 통계 정보에 해당한다.

### 통계 정보란?
* DB가 수집하는 통계 정보는 크게 다음과 같이 분류된다.
  1. 테이블 및 인덱스에 대한 통계 정보: **테이블과 인덱스에 대한 개괄적인 정보를 의미하며, MySQL 5.7 버전까지는 해당 통계 정보에 의존**한다.
  2. 히스토그램 정보: **인덱스되지 않은 컬럼들에 대해서도 수집한 데이터 분포도를 저장한 것을 의미하며, 8.0 버전부터는 해당 정보도 함께 사용**한다.
* **5.7 버전까지는 테이블 컬럼의 값들이 실제로 어떻게 분포되어 있는지에 대한 정보를 수집하지 않으므로, 실행 계획의 정확도가 떨어지곤 했다**.
  * 이로 인해 8.0부터는 히스토그램 정보를 함께 수집한다.
* 이 때, **히스토그램이 도입되었다고 해서 8.0 버전 이후의 MySQL이 테이블 또는 인덱스의 통계 정보를 사용하지 않는 것은 아니다**.

### 테이블과 인덱스의 통계 정보
* **통계 정보가 잘못된 경우 전혀 엉뚱한 쿼리 실행 계획을 수립할 수 있으므로, 비용 기반 최적화에서 가장 중요한 것은 통계 정보**이다.
* **MySQL 역시 다른 DBMS와 마찬가지로 비용 기반의 최적화를 사용하지만, 다른 DBMS 보다 통계 정보의 휘발성이 높고 정확도는 떨어지는 단점이 존재**했다.
  * 때문에 MySQL은 쿼리 실행 계획을 수립하는 경우, 실제 테이블의 데이터를 일부분 분석하여 통계 정보를 보완하는 식으로 동작했다.
  * MySQL 5.6 버전 이후부터는 통계 정보의 정확성을 높일 수 있는 여러 방법이 도입되기 시작했으나, 여러 사용자는 이를 간과하고 기존 방식을 사용하곤 한다.

## 2022-10-07 Fri
### MySQL 서버의 통계 정보 저장
* **MySQL 5.6 버전부터는 InnoDB 스토리지 엔진을 사용하는 테이블에 대한 통계 정보를 영구적으로 저장하여 관리**할 수 있다.
  * 반면, 5.5 버전까지는 각 테이블의 통계 정보를 메모리에서만 관리할 수 있었다.
  * 이렇듯 **메모리에 관리되는 통계 정보는 당연하게도 MySQL 서버가 재시작되는 경우에 모두 휘발될 수 밖에 없다**.
  * 때문에 재시작된 MySQL 서버는 반드시 모든 테이블의 통계 정보를 다시 수집해야 할 필요가 있었다.
* 그러나 **5.6 버전부터는 각 테이블의 통계 정보를 다음과 같은 mysql DB 테이블에 관리할 수 있도록 개선되어 서버의 재시작에도 통계 정보를 잃지 않는다**.
  1. `innodb_index_stats`
  2. `innodb_table_stats`
* **5.6 버전부터는 테이블 생성시 `STATS_PERSISTENT` 옵션을 설정할 수 있으며, 해당 값에 따라 테이블 단위로 영구적인 통계 정보를 저장**할 수 있다.
  1. STATS_PERSISTENT=0: 테이블의 통계 정보를 MySQL 5.5 이전 방식대로 관리하며, 상술한 두 테이블을 사용하지 않는다.
  2. STATS_PERSISTENT=1: 테이블의 통계 정보를 상술한 두 테이블에 저장한다.
  3. STATS_PERSISTENT=DEFAULT: 이는 별도로 옵션을 설정하지 않은 것과 동일하며, `innodb_statas_persistent` 시스템 변수의 값에 따른다.
* 이 때, **`innodb_statas_persistent` 시스템 변수는 기본적으로 ON으로 설정되므로 상술한 옵션을 사용하지 않은 경우 영구적인 통계 정보를 저장**한다.
* 또한, **영구적으로 테이블의 통계 정보를 저장하지 않는 경우에도 ALTER TABLE 명령을 통해 언제든지 통계 정보의 저장 설정을 자유로이 변경**할 수 있다.

### 자동 통계 정보 갱신
* MySQL 5.5 버전까지는 테이블의 통계 정보가 메모리에 저장되었으며, 서버 재시작 시 통계 정보는 초기화되었다.
  * 이 경우, 모든 테이블의 통계 정보는 다시 수집되어야 한다.
* 또한 사용자가 인지하지 못하는 순간에도 다음과 같은 이벤트가 발생할 경우 자동으로 통계 정보를 갱신한다.
  1. 테이블이 새로 오픈되는 경우
  2. 테이블의 전체 레코드 중 1/16 이상의 레코드가 대량으로 변경되는 경우
  3. ANALYZE TABLE 명령이 실행된 경우
  4. SHOW TABLE STATUS 또는 SHOW INDEX FROM 명령이 실행된 경우
  5. InnoDB 모니터가 활성화된 경우
  6. `innodb_stats_on_metadata` 설정이 ON인 상태에서 SHOW TABLE STATUS 명령이 실행되는 경우
* 이렇듯 **통계 정보가 자주 갱신되는 경우, 쿼리를 인덱스 레인지 스캔으로 잘 처리하던 MySQL 서버가 어느 순간부터는 풀 테이블 스캔을 적용**할 수도 있다.
* 그러나 이러한 **의도치 않은 통계 정보의 변경은 영구적인 통계 정보의 도입으로 미연에 방지할 수 있게 되었다**.
  * 예를 들어, `innodb_stats_auto_recalc` 시스템 설정의 값을 OFF로 설정하여 통계 정보의 자동 갱신을 막을 수도 있다.
  * **해당 시스템 설정의 기본 값은 ON이므로, 영구적인 통계 정보를 사용하는 경우에는 해당 설정을 OFF로 변경하는 것이 바람직**하다.
* 이 때, 통계 정보를 자동으로 수집할 지의 여부 역시 테이블 생성시 `STATUS_AUTO_RECALC` 옵션을 통해 테이블 단위로 명시할 수 있다.
  1. STATUS_AUTO_RECALC=1: 5.5 버전 이전의 방식대로 자동으로 수집한다.
  2. STATUS_AUTO_RECALC=0: ANALYZE TABLE 명령이 실행되었을 때만 수집한다.
  3. STATUS_AUTO_RECALC=DEFAULT: `innodb_stats_auto_recalc` 시스템 설정 변수의 값에 따라 테이블의 통계 정보 수집 여부를 결정한다.

### 테이블 블록 샘플링 옵션
* MySQL 5.5 버전에서는 테이블의 통계 정보를 수집하는 경우, 몇 개의 InnoDB 테이블 블록을 샘플링할지 결정할 수 있었다.
  * **이러한 기능을 수행하는 옵션은 `innodb_stats_sample_pages` 시스템 설정 변수였으나, 5.6 버전부터는 해당 옵션이 제거**되었다.
* 5.6 버전 이후로부터는 대신 다음과 같은 시스템 변수가 제공된다.
  1. `innodb_stats_transient_sample_pages`: 기본 값은 8이며, 자동 통계 정보 수집 시 8개 페이지만 샘플링하여 분석된 결과를 통계 정보로 활용한다. 
  2. `innodb_stats_persistent_sample_pages`: 기본 값은 20이며, ANALYZE TABLE 실행 시 이를 샘플링 및 분석하여 통계 정보 테이블에 저장한다.

### 더 정확한 통계 정보 수집하기
* **영구적인 통계 정보를 사용하는 경우 MySQL 서버의 점검 또는 사용량이 적은 시간에 더 정확한 통계 정보를 수집하도록 유도**할 수 있다.
  * 이 때, 더 정확한 통계 정보의 수집에는 당연히 더욱 많은 시간이 소모된다.
  * 그러나 **이로 인한 통계 정보의 정확성으로 쿼리의 성능이 향상되므로 시간을 투자할 가치는 충분**하다.
* 이렇듯 **더 정확한 통계 정보를 수집하고자 하는 경우, `innodb_stats_persistent_sample_pages` 시스템 변수에 큰 값을 설정**할 수 있다.
  * 이 역시 **값을 너무 큰 값으로 설정할 경우 통계 정보 수집에 그만큼 더 많은 시간을 허비하게 되므로 충분히 주의를 기울이는 것이 바람직**하다.

### 히스토그램이란?
* MySQL 5.7 버전까지의 통계 정보는 단순히 인덱스된 컬럼의 유니크한 값의 개수 정도 뿐이었다.
  * 이는 당연히 옵티마이저가 최적의 실행 계획을 수립하기엔 부족한 정보였으므로, 옵티마이저는 인덱스의 일부 페이지를 무작위로 가져와 참조하였다.
* **MySQL 8.0 버전에서는 컬럼의 데이터 분포도를 참조할 수 있게 되었으며, 이러한 컬럼의 데이터 분포도를 히스토그램이라고 지칭**한다.
* 히스토그램 정보는 컬럼 단위로 관리되며, 자동으로 수집되지 않고 `ANALYZE TABLE ... UPDATE HISTOGRAM` 명령어로 수동으로 수집 및 관리된다.
  * 이렇게 수집된 히스토그램 정보는 시스템 딕셔너리에 저장된다.
* 이 때, 히스토그램은 크게 다음과 같은 두 종류의 타입이 지원된다.
  1. 싱글톤: 컬럼 값 개별로 레코드 수를 관리하는 히스토그램이며, Value-based 또는 도수 분포라고 지칭한다.
  2. 높이 균형 히스토그램: 컬럼 값의 범위를 균등한 수로 구분하여 관리하는 히스토그램이며, Height-based 히스토그램이라고도 지칭한다.
* **히스토그램은 버킷 단위로 구분되어 레코드 수 또는 컬럼 값의 범위를 관리하며, 히스토그램의 종류에 따라 관리 방식이 달라진다**.

### 싱글톤 히스토그램
* 싱글톤 히스토그램은 컬럼이 가지는 값 별로 버킷이 할당된다.
* 싱글톤 히스토그램은 각 버킷이 컬럼 값과 발생 빈도의 비율, 두 가지 값을 갖는다.

### 높이 균형 히스토그램
* 높이 균형 히스토그램은 개수가 균등한 컬럼 값의 범위 별로 하나의 버킷이 할당된다.
* 높이 균형 히스토그램은 각 버킷이 범위의 시작 값과 끝 값, 그리고 발생 빈도율과 버킷 별 유니크한 값의 개수 등 네 가지 값을 갖는다.

### column_statistics 테이블
* **수집된 히스토그램 정보는 시스템 딕셔너리에 저장되고, MySQL 서버가 시작될 때 딕녀서리의 히스토그램 정보가 로드**된다.
  * 정확히는 `information_scheam.column_statistics` 테이블로 로드된다.
* 해당 테이블의 HISTOGRAM 컬럼이 갖는 나머지 필드들은 다음과 같은 의미를 갖는다.
  1. sampling-rate: 히스토그램 정보를 수집하는 과정에서 스캔하는 페이지의 비율을 의미하며, 0.35의 경우 35%를 샘플링한 셈이 된다.
     * 샘플링 비율이 높아질수록 정확한 히스토그램이 되지만, 점차 테이블을 전부 스캔하게 되므로 부하가 높고 시스템 자원을 많이 소모하게 된다.
  2. histogram-type: 히스토그램의 종류를 설정한다.
  3. number-of-buckets-specified: 히스토그램 생성 시 설정한 버킷의 개수를 설정한다.
     * **8.0.19 미만의 버전에서 히스토그램은 상술한 시스템 변수와 관계 없이 푸 ㄹ 스캔을 통해서만 데이터 페이지를 샘플링하여 히스토그램을 생성**했다.
     * 때문에 자신이 사용 중인 버전이 8.0.19 미만인 경우, 히스토그램 수집 시 반드시 주의를 기울여야 한다.

### 히스토그램의 삭제
* 히스토그램은 다음과 같은 쿼리로 삭제할 수 있으며, **해당 작업은 테이블의 데이터를 참조하지 않고 딕셔너리의 내용만을 삭제**한다.
  * 때문에 **다른 쿼리 처리 성능에는 영향을 주지 않은 채 즉시 완료할 수 있는 반면, 히스토그램이 삭제된 경우에는 쿼리 실행 계획이 달라질 수 있다**.
```
ANALYZE TABLE employees.employees DROP HISTOGRAM ON gender, hire_date;
```
* 또한, `optimizer_switch` 시스템 변수의 값을 변경하는 것으로 히스토그램을 삭제하지 않고도 옵티마이저가 히스토그램을 사용하지 않도록 할 수 있다.
  * 예를 들어, `SET GLOBAL optimizer_switch='condition_fanout_filter=off';` 명령어를 사용할 수 있다.
  * 이는 GLOBAL 스코프에 적용되므로 MySQL 서버의 모든 쿼리가 히스토그램을 사용하지 않게 되며, 당연히 특정 커넥션 또는 특정 쿼리에만 적용할 수도 있다.
  * 그러나 **condition_fanout_filter 옵션에 의해 영향 받는 최적화 기능들이 사용되지 않을 가능성 역시 존재**한다.  
# Basics
## 2022-10-06 Thu

### 실행 계획이란?
* 대부분의 DBMS는 다음과 같은 주요한 목적을 갖고 설계된다.
  1. 많은 데이터를 안전하게 저장하고 관리한다.
  2. 사용자가 원하는 데이터를 빠르게 조회할 수 있도록 한다.
* 이를 위해서는 **옵티마이저가 사용자의 쿼리를 최적으로 처리할 수 있도록하는 쿼리 실행 계획을 수립할 수 있어야 한다**.
  * 그러나 옵티마이저는 외부 개입 없이 항상 최적의 실행 계획을 수립할 수 있는 것은 아니다.
  * 때문에 **DBMS 서버는 이를 DBA나 개발자가 보완할 수 있도록 옵티마이저가 수립한 실행 계획을 확인할 수 있도록 EXPLAIN 명령을 제공**한다.
* 이 때, MySQL 서버가 실행 계획에 가장 큰 영향을 주는 것은 통계 정보에 해당한다.

### 통계 정보란?
* DB가 수집하는 통계 정보는 크게 다음과 같이 분류된다.
  1. 테이블 및 인덱스에 대한 통계 정보: **테이블과 인덱스에 대한 개괄적인 정보를 의미하며, MySQL 5.7 버전까지는 해당 통계 정보에 의존**한다.
  2. 히스토그램 정보: **인덱스되지 않은 컬럼들에 대해서도 수집한 데이터 분포도를 저장한 것을 의미하며, 8.0 버전부터는 해당 정보도 함께 사용**한다.
* **5.7 버전까지는 테이블 컬럼의 값들이 실제로 어떻게 분포되어 있는지에 대한 정보를 수집하지 않으므로, 실행 계획의 정확도가 떨어지곤 했다**.
  * 이로 인해 8.0부터는 히스토그램 정보를 함께 수집한다.
* 이 때, **히스토그램이 도입되었다고 해서 8.0 버전 이후의 MySQL이 테이블 또는 인덱스의 통계 정보를 사용하지 않는 것은 아니다**.

### 테이블과 인덱스의 통계 정보
* **통계 정보가 잘못된 경우 전혀 엉뚱한 쿼리 실행 계획을 수립할 수 있으므로, 비용 기반 최적화에서 가장 중요한 것은 통계 정보**이다.
* **MySQL 역시 다른 DBMS와 마찬가지로 비용 기반의 최적화를 사용하지만, 다른 DBMS 보다 통계 정보의 휘발성이 높고 정확도는 떨어지는 단점이 존재**했다.
  * 때문에 MySQL은 쿼리 실행 계획을 수립하는 경우, 실제 테이블의 데이터를 일부분 분석하여 통계 정보를 보완하는 식으로 동작했다.
  * MySQL 5.6 버전 이후부터는 통계 정보의 정확성을 높일 수 있는 여러 방법이 도입되기 시작했으나, 여러 사용자는 이를 간과하고 기존 방식을 사용하곤 한다.

## 2022-10-07 Fri
### MySQL 서버의 통계 정보 저장
* **MySQL 5.6 버전부터는 InnoDB 스토리지 엔진을 사용하는 테이블에 대한 통계 정보를 영구적으로 저장하여 관리**할 수 있다.
  * 반면, 5.5 버전까지는 각 테이블의 통계 정보를 메모리에서만 관리할 수 있었다.
  * 이렇듯 **메모리에 관리되는 통계 정보는 당연하게도 MySQL 서버가 재시작되는 경우에 모두 휘발될 수 밖에 없다**.
  * 때문에 재시작된 MySQL 서버는 반드시 모든 테이블의 통계 정보를 다시 수집해야 할 필요가 있었다.
* 그러나 **5.6 버전부터는 각 테이블의 통계 정보를 다음과 같은 mysql DB 테이블에 관리할 수 있도록 개선되어 서버의 재시작에도 통계 정보를 잃지 않는다**.
  1. `innodb_index_stats`
  2. `innodb_table_stats`
* **5.6 버전부터는 테이블 생성시 `STATS_PERSISTENT` 옵션을 설정할 수 있으며, 해당 값에 따라 테이블 단위로 영구적인 통계 정보를 저장**할 수 있다.
  1. STATS_PERSISTENT=0: 테이블의 통계 정보를 MySQL 5.5 이전 방식대로 관리하며, 상술한 두 테이블을 사용하지 않는다.
  2. STATS_PERSISTENT=1: 테이블의 통계 정보를 상술한 두 테이블에 저장한다.
  3. STATS_PERSISTENT=DEFAULT: 이는 별도로 옵션을 설정하지 않은 것과 동일하며, `innodb_statas_persistent` 시스템 변수의 값에 따른다.
* 이 때, **`innodb_statas_persistent` 시스템 변수는 기본적으로 ON으로 설정되므로 상술한 옵션을 사용하지 않은 경우 영구적인 통계 정보를 저장**한다.
* 또한, **영구적으로 테이블의 통계 정보를 저장하지 않는 경우에도 ALTER TABLE 명령을 통해 언제든지 통계 정보의 저장 설정을 자유로이 변경**할 수 있다.

### 자동 통계 정보 갱신
* MySQL 5.5 버전까지는 테이블의 통계 정보가 메모리에 저장되었으며, 서버 재시작 시 통계 정보는 초기화되었다.
  * 이 경우, 모든 테이블의 통계 정보는 다시 수집되어야 한다.
* 또한 사용자가 인지하지 못하는 순간에도 다음과 같은 이벤트가 발생할 경우 자동으로 통계 정보를 갱신한다.
  1. 테이블이 새로 오픈되는 경우
  2. 테이블의 전체 레코드 중 1/16 이상의 레코드가 대량으로 변경되는 경우
  3. ANALYZE TABLE 명령이 실행된 경우
  4. SHOW TABLE STATUS 또는 SHOW INDEX FROM 명령이 실행된 경우
  5. InnoDB 모니터가 활성화된 경우
  6. `innodb_stats_on_metadata` 설정이 ON인 상태에서 SHOW TABLE STATUS 명령이 실행되는 경우
* 이렇듯 **통계 정보가 자주 갱신되는 경우, 쿼리를 인덱스 레인지 스캔으로 잘 처리하던 MySQL 서버가 어느 순간부터는 풀 테이블 스캔을 적용**할 수도 있다.
* 그러나 이러한 **의도치 않은 통계 정보의 변경은 영구적인 통계 정보의 도입으로 미연에 방지할 수 있게 되었다**.
  * 예를 들어, `innodb_stats_auto_recalc` 시스템 설정의 값을 OFF로 설정하여 통계 정보의 자동 갱신을 막을 수도 있다.
  * **해당 시스템 설정의 기본 값은 ON이므로, 영구적인 통계 정보를 사용하는 경우에는 해당 설정을 OFF로 변경하는 것이 바람직**하다.
* 이 때, 통계 정보를 자동으로 수집할 지의 여부 역시 테이블 생성시 `STATUS_AUTO_RECALC` 옵션을 통해 테이블 단위로 명시할 수 있다.
  1. STATUS_AUTO_RECALC=1: 5.5 버전 이전의 방식대로 자동으로 수집한다.
  2. STATUS_AUTO_RECALC=0: ANALYZE TABLE 명령이 실행되었을 때만 수집한다.
  3. STATUS_AUTO_RECALC=DEFAULT: `innodb_stats_auto_recalc` 시스템 설정 변수의 값에 따라 테이블의 통계 정보 수집 여부를 결정한다.

### 테이블 블록 샘플링 옵션
* MySQL 5.5 버전에서는 테이블의 통계 정보를 수집하는 경우, 몇 개의 InnoDB 테이블 블록을 샘플링할지 결정할 수 있었다.
  * **이러한 기능을 수행하는 옵션은 `innodb_stats_sample_pages` 시스템 설정 변수였으나, 5.6 버전부터는 해당 옵션이 제거**되었다.
* 5.6 버전 이후로부터는 대신 다음과 같은 시스템 변수가 제공된다.
  1. `innodb_stats_transient_sample_pages`: 기본 값은 8이며, 자동 통계 정보 수집 시 8개 페이지만 샘플링하여 분석된 결과를 통계 정보로 활용한다. 
  2. `innodb_stats_persistent_sample_pages`: 기본 값은 20이며, ANALYZE TABLE 실행 시 이를 샘플링 및 분석하여 통계 정보 테이블에 저장한다.

### 더 정확한 통계 정보 수집하기
* **영구적인 통계 정보를 사용하는 경우 MySQL 서버의 점검 또는 사용량이 적은 시간에 더 정확한 통계 정보를 수집하도록 유도**할 수 있다.
  * 이 때, 더 정확한 통계 정보의 수집에는 당연히 더욱 많은 시간이 소모된다.
  * 그러나 **이로 인한 통계 정보의 정확성으로 쿼리의 성능이 향상되므로 시간을 투자할 가치는 충분**하다.
* 이렇듯 **더 정확한 통계 정보를 수집하고자 하는 경우, `innodb_stats_persistent_sample_pages` 시스템 변수에 큰 값을 설정**할 수 있다.
  * 이 역시 **값을 너무 큰 값으로 설정할 경우 통계 정보 수집에 그만큼 더 많은 시간을 허비하게 되므로 충분히 주의를 기울이는 것이 바람직**하다.

### 히스토그램이란?
* MySQL 5.7 버전까지의 통계 정보는 단순히 인덱스된 컬럼의 유니크한 값의 개수 정도 뿐이었다.
  * 이는 당연히 옵티마이저가 최적의 실행 계획을 수립하기엔 부족한 정보였으므로, 옵티마이저는 인덱스의 일부 페이지를 무작위로 가져와 참조하였다.
* **MySQL 8.0 버전에서는 컬럼의 데이터 분포도를 참조할 수 있게 되었으며, 이러한 컬럼의 데이터 분포도를 히스토그램이라고 지칭**한다.
* 히스토그램 정보는 컬럼 단위로 관리되며, 자동으로 수집되지 않고 `ANALYZE TABLE ... UPDATE HISTOGRAM` 명령어로 수동으로 수집 및 관리된다.
  * 이렇게 수집된 히스토그램 정보는 시스템 딕셔너리에 저장된다.
* 이 때, 히스토그램은 크게 다음과 같은 두 종류의 타입이 지원된다.
  1. 싱글톤: 컬럼 값 개별로 레코드 수를 관리하는 히스토그램이며, Value-based 또는 도수 분포라고 지칭한다.
  2. 높이 균형 히스토그램: 컬럼 값의 범위를 균등한 수로 구분하여 관리하는 히스토그램이며, Height-based 히스토그램이라고도 지칭한다.
* **히스토그램은 버킷 단위로 구분되어 레코드 수 또는 컬럼 값의 범위를 관리하며, 히스토그램의 종류에 따라 관리 방식이 달라진다**.

### 싱글톤 히스토그램
* 싱글톤 히스토그램은 컬럼이 가지는 값 별로 버킷이 할당된다.
* 싱글톤 히스토그램은 각 버킷이 컬럼 값과 발생 빈도의 비율, 두 가지 값을 갖는다.

### 높이 균형 히스토그램
* 높이 균형 히스토그램은 개수가 균등한 컬럼 값의 범위 별로 하나의 버킷이 할당된다.
* 높이 균형 히스토그램은 각 버킷이 범위의 시작 값과 끝 값, 그리고 발생 빈도율과 버킷 별 유니크한 값의 개수 등 네 가지 값을 갖는다.

### column_statistics 테이블
* **수집된 히스토그램 정보는 시스템 딕셔너리에 저장되고, MySQL 서버가 시작될 때 딕녀서리의 히스토그램 정보가 로드**된다.
  * 정확히는 `information_scheam.column_statistics` 테이블로 로드된다.
* 해당 테이블의 HISTOGRAM 컬럼이 갖는 나머지 필드들은 다음과 같은 의미를 갖는다.
  1. sampling-rate: 히스토그램 정보를 수집하는 과정에서 스캔하는 페이지의 비율을 의미하며, 0.35의 경우 35%를 샘플링한 셈이 된다.
     * 샘플링 비율이 높아질수록 정확한 히스토그램이 되지만, 점차 테이블을 전부 스캔하게 되므로 부하가 높고 시스템 자원을 많이 소모하게 된다.
  2. histogram-type: 히스토그램의 종류를 설정한다.
  3. number-of-buckets-specified: 히스토그램 생성 시 설정한 버킷의 개수를 설정한다.
     * **8.0.19 미만의 버전에서 히스토그램은 상술한 시스템 변수와 관계 없이 푸 ㄹ 스캔을 통해서만 데이터 페이지를 샘플링하여 히스토그램을 생성**했다.
     * 때문에 자신이 사용 중인 버전이 8.0.19 미만인 경우, 히스토그램 수집 시 반드시 주의를 기울여야 한다.

### 히스토그램의 삭제
* 히스토그램은 다음과 같은 쿼리로 삭제할 수 있으며, **해당 작업은 테이블의 데이터를 참조하지 않고 딕셔너리의 내용만을 삭제**한다.
  * 때문에 **다른 쿼리 처리 성능에는 영향을 주지 않은 채 즉시 완료할 수 있는 반면, 히스토그램이 삭제된 경우에는 쿼리 실행 계획이 달라질 수 있다**.
```
ANALYZE TABLE employees.employees DROP HISTOGRAM ON gender, hire_date;
```
* 또한, `optimizer_switch` 시스템 변수의 값을 변경하는 것으로 히스토그램을 삭제하지 않고도 옵티마이저가 히스토그램을 사용하지 않도록 할 수 있다.
  * 예를 들어, `SET GLOBAL optimizer_switch='condition_fanout_filter=off';` 명령어를 사용할 수 있다.
  * 이는 GLOBAL 스코프에 적용되므로 MySQL 서버의 모든 쿼리가 히스토그램을 사용하지 않게 되며, 당연히 특정 커넥션 또는 특정 쿼리에만 적용할 수도 있다.
  * 그러나 **condition_fanout_filter 옵션에 의해 영향 받는 최적화 기능들이 사용되지 않을 가능성 역시 존재**한다.  

## 2022-10-08 Sat
### 히스토그램의 용도
```
> 히스토그램은 데이터가 특정 범위에 많고 적음을 식별할 수 있게하며, 특히 조인 시에 성능 향상을 기대할 수 있다.
```
* 히스토그램이 도입되기 전에도 테이블과 인덱스에 대한 통계 정보는 존재했으나, 이는 전체 레코드 개수와 인덱스된 컬럼의 유니크한 값의 수 정도에 불과했다.
  * **옵티마이저는 이를 통해 실행 게획을 예측하여 수립하였으나, 실제 응용 프로그램의 데이터는 항상 균등한 분포도를 가질 수는 없으므로 한계가 분명**했다.
  * 이러한 **단점을 보완하기 위해 도입된 것이 히스토그램으로, 버킷 별로 레코드 수와 유니크한 값의 수 정보를 갖기에 훨씬 정확한 예측이 가능**하다.
* 즉, **히스토그램 정보가 없는 경우 옵티마이저는 데이터가 균등하게 분포되어 있을 것으로 예측**한다.
  * 그러나 **히스토그램이 존재한다면 특정 범위에 있는 데이터가 많거나 적음을 식별할 수 있게 되어 쿼리의 성능에 지대한 영향**을 줄 수 있게 된다.
* 예를 들어, 조인 쿼리 실행 시 옵티마이저는 테이블의 전체 레코드 수나 크기 등의 단순한 정보만으로 드라이빙 테이블을 결정하게 된다.
  * 이는 **곧 상황에 따라 어떤 테이블이든 조인 드라이빙 테이블이 될 수 있다는 뜻이므로, 쿼리의 성능은 최악의 경우에 엄청난 차이를 보이게 된다**.
  * 반면, **각 컬럼에 대한 히스토그램 정보가 존재하는 경우 어떠한 테이블을 먼저 읽어들여 조인의 횟수를 줄일지 옵티마이저가 더 정확하게 판단**할 수 있다.

### 히스토그램과 인덱스
```
> 히스토그램과 인덱스는 완전히 다른 객체이므로, 일반적으로 비교 대상이 될 수는 없다.
> 그러나 MySQL의 경우 인덱스가 부족한 통계 정보를 수집하기 위해 사용된다는 측면에서 미루어 보았을 때에는 어느 정도의 공통점을 발견할 수 있다.
> 인덱스 다이브와 히스토그램을 모두 사용할 수 있는 경우, 옵티마이저는 기본적으로 실제 샘플링 결과인 인덱스 다이브를 우선적으로 활용한다.
```
* 옵티마이저는 쿼리 실행 계획 수립 시 대략적으로 다음과 같은 절차를 따른다.
  1. 사용 가능한 인덱스들을 선정한다.
  2. 조건 절에 일치하는 레코드 건수를 대략적으로 파악한다.
  3. 최종적으로 가장 좋은 실행 계획을 선택한다.
* 이 때, **2.의 과정에서 조건 절에 일치하는 레코드 수를 예측하기 위해서 옵티마이저는 실제 인덱스의 B-Tree를 샘플링하여 확인**한다.
  * 이러한 작업은 인덱스 다이브라는 용어로 지칭한다.
* **MySQL 8.0의 경우, 인덱스된 컬럼을 조건 절로 사용한다면 해당 컬럼의 히스토그램은 사용하지 않고 대신 인덱스 다이브를 통해 수집한 정보를 활용**한다.
  * 즉, **실제 검색 조건 대상 값에 대한 샘플링을 진행하므로 항상 히스토그램보다 정확한 결과를 기대**할 수 있다. 
* 상술한 이유에서, **히스토그램은 주로 인덱스되지 않은 컬럼에 대한 데이터 분포를 참조하는 용도로 사용**된다. 
  * 그러나 **인덱스 다이브는 어느 정도의 비용을 소모하며, IN 절에 값이 많이 명시된 경우 등에는 실행 계획 수립만으로도 상당한 비용을 사용**하기도 한다. 

### 코스트 모델
```
> 코스트 모델이란, 전체 쿼리의 비용을 계산하기 위해 필요한 단위 작업들의 비용을 의미한다.
```
* MySQL 서버가 쿼리를 처리하는 경우, 다음과 같은 다양한 작업은 필수적이다.
  1. 디스크 또는 메모리 상의 InnoDB 버퍼 풀로부터 데이터 페이지 읽기
  2. 인덱스 키 비교하기
  3. 레코드 평가하기
  4. 메모리 또는 디스크 상의 임시 테이블 작업하기
* **MySQL은 사용자의 쿼리에 대해 상술한 다양한 작업이 얼마나 필요할지 예측하고, 전체 작업 비용을 계산하여 최적의 실행 계획을 수립**한다.
  * 이 때, MySQL 5.7 이전까지는 이러한 작업들의 비용을 소스 코드 상에 상수화해두었다.
  * 그러나 **각 작업 비용은 MySQL 서버의 HW에도 영향을 받을 수 있으므로 일률적으로 상수화된 비용을 적용하는 것은 한계가 분명**했다.
* 이를 보완하기 위해 5.7 버전부터 상수화되어 있던 각 단위 작업 비용을 관리자가 조절할 수 있도록 개선되었다.
  * 그러나 **5.7 역시 인덱스되지 않은 컬럼의 데이터 분포인 히스토그램이나 메모리에 상의 페이지의 비율 등, 비용과 관련된 정보가 부족한 것은 마찬가지**이다.
* MySQL 8.0 버전에 와서야 히스토그램과 각 인덱스 별로 메모리에 적재된 페이지의 비율이 관리되기 시작하였으며, 이를 옵티마이저의 실행 계획 수립에 반영한다.
* **코스트 모델에서 중요한 것은 각각의 단위 작업에 설정된 값이 변경되었을 때, 어떤 실행 계획이 고비용 또는 저비용으로 바뀌는지 파악하는 것**이다.

### MySQL 8.0의 코스트 모델 관련 테이블
* MySQL 8.0 서버의 코스트 모델은 다음과 같은 두 개의 테이블에 저장된 설정 값을 사용하며, 이들은 모두 mysql DB에 존재한다.
  1. server_cost: 인덱스를 찾거나 레코드를 비교하거나 임시 테이블을 처리하는 등에 대한 비용을 관리한다.
  2. engine_cost: 레코드를 가진 데이터 페이지를 가져오는 데에 필요한 비용을 관리한다.
* 이 때, 상술한 **각각의 테이블에 저장된 여러 단위 작업의 비용을 변경하는 것으로 옵티마이저가 수립하는 실행 계획에 영향**을 줄 수 있다.
  * 그러나 **코스트 모델은 MySQL 서버의 HW와 내부적인 처리 방식에 대한 깊이 있는 지식을 필요로 하므로, 각 비용을 반드시 수정해야 하는 것은 아니다**.
  * 때문에 **MySQL의 처리 방식에 대한 전문적인 지식을 갖고 있지 않다면 두 테이블에 기본으로 설정된 값을 변경하지 않는 것이 바람직**하다.
  * 무엇보다, MySQL 서버에 적용된 기본 값만으로도 MySQL 서버는 20년 이상 수 많은 환경에서 잘 사용되어 왔다.

## 2022-10-09 Sun
### 실행 계획 확인하기
* **MySQL의 경우, DESC 또는 EXPLAIN 명령을 통해 실행 계획을 확인**할 수 있다.
* 또한, MySQL 8.0 버전 이후로는 EXPLAIN 명령에 더해 표시 형식을 트리 형태나 JSON 또는 테이블 형태로 선택할 수도 있다.
  * 각 포맷에 따라 보여지는 정보에 다소의 차이가 있을 수 있으나, 옵티마이저가 수립한 실행 계획의 큰 결을 보여준다는 점에서는 차이가 없다.
  * 반면, 8.0 버전에 들어서는 이전 버전에서 사용되던 `EXPLAIN EXTENDED` 또는 `EXPLAIN PARTITIONS` 문법은 제거되었다.

### 쿼리의 실행 시간 확인하기
* MySQL 8.0.18 버전부터는 쿼리 실행 계획에 단계 별 소요 시간 정보를 확인할 수 있는 `EXPLAIN ANALYZE` 명령이 추가되었다.
  * 물론 **`SHOW PROFILE`로도 소요 시간을 확인할 수 있으나, 이는 실행 계획의 단계 별로 소요된 시간 정보를 보여주지는 않는다**.
* 이 때, `EXPLAIN ANALYZE` 명령의 결과로는 다음과 같은 정보가 표시된다.
  1. actual time: 단계 별로 실제 소요된 시간
  2. rows: 처리한 레코드의 수
  3. loops: 반복 횟수
* 이 때, actual time과 rows 는 loops의 값이 1보다 큰 경우에 평균 시간과 평균 레코드 수를 의미하게 된다.
* **EXPLAIN ANALYZE는 실제로 쿼리를 실행하는 과정에서 사용된 실행 계획과 소요 시간을 보여주므로, 쿼리가 반드시 완료되어야 결과를 확인**할 수 있다.
  * 즉, 쿼리 실행 시간이 많이 걸리더라도 완료가 되어야 결과를 확인할 수 있으며 이는 단순히 실행 계획만 추출하여 반환하는 EXPLAIN 명령의 특징과 상반된다.
* 때문에 **쿼리의 실행 계획 자체가 아주 나쁜 경우에는 우선 EXPLAIN 명령으로 확인한 실행 계획을 토대로 쿼리를 우선 튜닝하는 것이 바람직**하다.
  * 이렇듯 EXPLAIN에서 확인한 실행 계획을 기반으로 '나쁜 쿼리'를 어느 정도 튜닝한 후에야 비로소 EXPLAIN ANALYZE 명령을 실행하는 것이 바람직하다.

### 기초적인 실행 계획 분석
* 아무런 옵션 없이 EXPLAIN 명령을 실행한 경우, 쿼리에 따라 한 줄 이상의 결과가 테이블 형태로 표시된다.
  * 이 때, **표의 각 라인은 쿼리 문장에서 사용한 테이블의 개수만큼 표시되며 서브쿼리로부터 생성된 임시 테이블 역시 포함**된다.
* **실행 순서는 일반적으로 위에서부터 아래로 표시되며, 위쪽에 출력되었거나 id 컬럼이 작을수록 쿼리의 바깥 부분이거나 먼저 접근된 테이블을 의미**한다.
  * 당연히 아래쪽에 출력되었거나 id 컬럼의 값이 클수록 쿼리의 안쪽 부분 또는 나중에 접근된 테이블을 의미한다.
  * 반면, UNION 또는 상관 서브쿼리의 경우 순서대로 표시되지 않을 수도 있다.

### 실행 계획 - id 컬럼
* 하나의 SELECT 문은 또 다른 하나 이상의 서브 SELECT 문을 포함할 수 있다.
  * 이 때, 이렇듯 SELECT 키워드 단위로 구분한 것을 단위 SELECT 쿼리라고 지칭할 수 있다.
* **id 컬럼은 실행 계획의 가장 왼 편에 표시되며, 각 단위 SELECT 쿼리 별로 부여되는 식별자에 해당**한다.
  * 반면, **단일 SELECT 문에서 여러 테이블이 조인되는 경우에는 테이블 개수만큼의 실행 계획 레코드가 출력되지만 같은 id를 사용**한다.
  * 이 경우, **실행 계획에서 더 위에 표시되는 row에 명시된 테이블이 조인의 드라이빙 테이블이며 나머지는 드리븐 테이블이 된다**. 
* **중요한 것은 실행 계획의 id 컬럼이 반드시 테이블의 접근 순서를 의미하지는 않는다는 사실**이다.

### 실행 계획 - select_type 컬럼
* 해당 컬럼은 각 단위 SELECT 쿼리가 어떤 타입의 쿼리인지 표시하며, 다음과 같은 값을 가질 수 있다.
  1. SIMPLE: **UNION 또는 서브쿼리를 사용하지 않는 단순 SELECT 쿼리 또는 조인을 포함하는 경우에 해당**한다.
     * 쿼리가 아무리 복잡해지더라도 SIMPLE 타입의 단위 쿼리는 단 하나만 존재하며, 일반적으로는 가장 바깥 단위 SELECT 쿼리가 된다.
  2. PRIMARY: UNION이나 서브쿼리를 갖는 경우 가장 바깥에 있는 단위 쿼리를 의미한다.
     * SIMPLE과 마찬가지로 PRIMARY 단위 SELECT 쿼리는 단 하나만 존재할 수 있으며, 쿼리의 가장 바깥에 위치한다.
  3. UNION: UNION으로 결합하는 단위 SELECT 쿼리 중 첫 번째를 제외한 두 번째 이후 단위 SELECT 쿼리이다.
     * **UNION의 첫 단위 SELECT 쿼리는 UNION되는 결과를 모아 저장하는 임시 테이블을 포함하므로 DERIVED**가 된다.
  4. DEPENDENT UNION: UNION과 마찬가지로 UNION 또는 UNION ALL로 결합되는 쿼리에서 표시되는 반면, 결합된 단위 쿼리가 외부 쿼리에 영향을 받는다.
     * 즉, **DEPENDENT 키워드는 UNION 또는 UNION ALL로 결합되는 내부 쿼리가 외부 쿼리의 값을 참조하여 처리되는 경우에 표시**된다.
  5. UNION RESULT: UNION의 결과를 담기 위해 버퍼링 용도로 사용되는 임시 테이블이며, 실제 단위 쿼리는 아니므로 id 값은 부여되지 않는다.
     * MySQL 8.0 이전에는 UNION ALL과 UNION 결과는 모두 임시 테이블로 생성되었으나, 8.0에서는 UNION ALL의 결과는 임시 테이블을 사용하지 않는다.
     * 그러나 여전히 UNION의 결과는 임시 테이블에 버퍼되어야 하며, 이는 실행 계획 상 UNION RESULT로 명시된다.
  6. SUBQUERY: 일반적인 서브쿼리는 여러가지를 통틀어 표현하는 용어이나, **실행 계획에서는 FROM 절 이외에서 사용되는 서브쿼리만을 의미**한다.
     * 이렇듯 **FROM 절 외에 사용된 서브쿼리의 select_type은 전부 SUBQUERY로 표시되지만, FROM 절에 사용되는 서브쿼리는 DERIVED로 표시**된다.
     * 서브쿼리는 위치에 따라 다음과 같은 이름을 가질 수 있다.
       1. 중첩된 쿼리: SELECT되는 컬럼에 사용된 서브쿼리를 의미한다.
       2. 서브쿼리: WHERE 절에서 사용되는 경우이며, 일반적인 서브쿼리에 해당한다.
       3. 파생 테이블: FROM 절에 사용된 서브쿼리를 MySQL에서 지칭하는 용어이며, 일반적인 RDBMS에서는 인라인 뷰 또는 서브 셀렉트라고 표현한다.
  7. DEPENDENT SUBQUERY: 서브쿼리가 바깥 SELECT문에 정의된 컬럼을 사용하는 경우이며, 안쪽 서브쿼리 결과는 바깥 SELECT 쿼리의 컬럼에 의존한다.
     * **DEPENDENT UNION과 마찬가지로 외부 쿼리가 먼저 수행된 후에 내부 서브쿼리가 실행되므로, 일반적인 서브쿼리보다 처리 속도가 느린 경우가 많다**. 
  8. DERIVED: 단위 SELECT 쿼리의 실행 결과로 메모리나 디스크에 임시 테이블인 파생 테이블을 생성하는 경우를 의미한다.
  9. DEPENDENT DERIVED: MySQL 8.0부터 래터럴 조인으로 FROM 절의 서브쿼리에서 외부 컬럼을 참조할 수 있으며, 해당 select_type은 이를 의미한다.
     * 반면, 그 이전 버전에서는 FROM 절의 서브쿼리에서 외부 컬럼을 사용할 수 없었다.
  10. UNCACHEABLE SUBQUERY: 서브쿼리에 포함된 요소에 의해 서브쿼리 캐시 자체가 불가능한 경우에 표시되는 select_type에 해당한다.
      * 기본적으로 하나의 쿼리 문장에 서브쿼리가 하나만 존재하더라도, 해당 항상 서브쿼리가 한 번만 실행되지는 않는다.
      * 그러나 **조건이 같은 서브쿼리가 실행되는 경우, 이전의 실행 결과를 내부적인 캐시 공간에 캐시하여 재사용**한다.
        * SUBQUERY의 경우 외부 쿼리에 영향을 받지 않으므로, 최초 한 번만 실행 후 캐싱하여 이후에는 해당 정보를 재사용한다.
        * DEPENDENT SUBQUERY의 경우 외부 쿼리의 컬럼 값 단위로 캐싱하여 재사용한다.
      * 예를 들어, 다음과 같은 경우에 서브쿼리 캐싱은 불가능하다.
        1. 사용자 변수가 서브쿼리에 사용된 경우
        2. NOT-DETERMINISTIC 속성의 스토어드 루틴이 서브쿼리에서 사용된 경우
        3. UUID() 또는 RAND() 등 호출할 때마다 결과값이 달라지는 함수가 서브쿼리에 사용된 경우
  11. UNCACHEABLE UNION: UNION과 UNCACHEABLE 키워드의 속성이 혼합된 경우를 의미한다.
  12. MATERIALIZED: DERIVED와 유사하게 쿼리 내용을 임시 테이블로 생성하는 것을 의미한다.
      * 해당 select_type은 주로 FROM 절이나 IN(subquery) 형태로 사용된 서브쿼리를 최적화하기 위해 사용된다.
      * 이 경우, **서브쿼리의 내용은 임시 테이블로 구체화된 후에 이를 서브쿼리의 외부 쿼리와 조인하는 형태로 최적화하여 처리**된다.
      * 이 때, **우선 처리되어 임시 테이블로 구체화되는 서브쿼리는 실행 계획의 select_type 컬럼이 MATERIALIZED로 표시**된다.

## 2022-10-10 Mon  
### 서브쿼리 주의사항
* **쿼리를 튜닝할 경우, 실행 계획에서 가장 먼저 확인해야하는 것은 DERIVED로 처리되는 작업을 확인하는 것**이다.
* **서브쿼리를 조인으로 해결할 수 있는 경우, 항상 서브쿼리보다 조인을 사용하는 것이 권장**된다.
  * 서브쿼리를 사용하는 것이 편하고 생산성이 높을 수는 있으나, 쿼리의 성능은 조인보다 떨어진다.
  * 때문에 **서브쿼리로 최초 쿼리를 작성했더라도, 조인으로 풀어 쓸 수 있는 경우라면 조인으로 고치는 습관을 들이는 것이 바람직**하다.

### 실행 계획 - table 컬럼
* **MySQL 서버의 실행 계획은 단위 SELECT 쿼리 기준이 아닌 테이블 기준으로 표시**된다.
  * 이 떄, `SELECT NOW();`와 같이 별도의 테이블을 사용하지 않는 SELECT 문은 실행 계획에서 해당 컬럼이 NULL로 표시된다.
* **table 컬럼에는 `<derivedN>` 또는 `<union M,N>`과 같이 꺾쇠를 사용하는 이름이 명시되는 경우가 있으며, 이는 임시 테이블을 의미**한다.
  * 이 때, **꺾쇠 안에 표시되는 숫자는 SELECT 쿼리의 실행 계획에서 적용된 id 컬럼 값을 의미**한다.
  * 예를 들어, 해당 컬럼이 `<derived2>`로 표시되었다면 해당 테이블은 단위 SELECT 쿼리의 식별자가 2인 실행 계획으로부터 생성된 파생 테이블이 된다.
* **table 컬럼은 상술한 id 및 select_type 컬럼과 함께 실행 계획의 각 라인에 명시된 테이블이 어떤 순서로 실행되는지 판단할 수 있는 근거를 제공**한다.
* MySQL 8.0부터는 서브쿼리에 대한 최적화가 많이 개선되었으며, 예를 들어 select_type이 MATERIALIZED로 표시되는 경우가 있다.
  * 이 때, **select_type이 MATERIALIZED로 표시되는 실행 계획에는 `<subqueryN>`과 같은 형태의 table 컬럼이 표시**된다.
  * 이는 서브쿼리 결과를 구체화하여 임시 테이블로 생성했다는 의미이며, 해석 자체는 `<derivedN>`와 다를 것이 없다.

### 실행 계획 - partitions 컬럼
* MySQL 5.7 버전까지는 옵티마이저가 사용하는 파티션 목록을 EXPLAIN PARTITION 명령으로 확인할 수 있었다.
  * 반면, 8.0 부터는 EXPLAIN 명령에 파티션 관련 실행 계획이 모두 표시되도록 개선되었다.
* 옵티마이저는 실행 계획을 수립하는 과정에서 특정한 파티션에만 접근하여 결과를 생성할 수 있을 것으로 판단한 경우, 나머지 파티션은 분석하지 않는다.
  * 예를 들어, 임의의 파티션 하나로 결과를 생성할 수 있는 경우 나머지 파티션에 대한 접근 방식 또는 데이터 분포 분석을 실행하지 않는다.
  * 이렇듯 **여러 파티션을 갖는 테이블에서 불필요한 파티션을 제외하고 쿼리를 수행하기 위해 접근할 파티션만 골라내는 과정을 파티션 프루닝이라고 표현**한다.
* 임의의 쿼리가 파티션 키 컬럼을 WHERE 조건으로 지정하는 등 파티션을 참조할 수 있는 경우, 옵티마이저는 partitions 컬럼에 필요한 파티션 목록을 표시한다.
  * 해당 정보를 토대로 사용자는 쿼리의 튜닝을 진행할 수 있게 된다.
* **일반적인 RDBMS에서 파티션은 물리적으로 마치 개별 테이블처럼 별도의 저장 공간을 가지므로, 실행 계획이 ALL로 수립되더라도 실제 테이블을 읽지 않는다**.
  * 대신 물리적인 별도 공간에 저장된 파티션을 대상으로 풀 테이블 스캔을 진행하여 레코드를 읽어들이게 된다.

### 실행 계획 - type 컬럼
* 수립된 **쿼리 실행 계획에서, type 이후의 컬럼은 MySQL 서버가 각 테이블의 레코드를 어떤 방식으로 조회했는지를 의미**한다.
  * 이 때, 방식이란 인덱스를 사용하여 레코드를 읽었는지 또는 테이블을 처음부터 모두 읽어들이는 풀 테이블 스캔을 적용하였는지 등을 의미한다.
* **일반적으로 쿼리를 튜닝하는 경우, 인덱스를 효율적으로 사용하는지 확인하는 것이 중요하기에 실행 계획에서 type 컬럼은 반드시 체크하는 것이 바람직**하다.
* MySQL에서는 type 컬럼을 조인 타입으로도 소개하며, 이는 MySQL이 하나의 테이블로부터 레코드를 읽는 작업까지도 조인처럼 처리하는 데에서 기인한다.
  * 때문에 SELECT 쿼리의 테이블 개수와 관계 없이 type 컬럼은 항상 조인 타입으로 명시된다.
  * **그렇다고 해서 type 컬럼의 값을 조인과 직접 연관지어 생각하는 것보다는 항상 각 테이블에 대한 접근 방법 정도로 해석하는 것이 바람직**하다.

### type 컬럼의 종류
* 실행 계획의 **type 컬럼에는 다음과 같은 값이 표시될 수 있으며, 아래로 갈수록 처리 성능은 느려진다**.
  1. system
  2. const
  3. eq_ref
  4. ref
  5. fulltext
  6. ref_or_null
  7. unique_subquery
  8. index_subquery
  9. range
  10. index_merge
  11. index
  12. ALL
* **이 중 ALL을 제외한 모든 방식은 인덱스를 사용하는 접근 방식인 반면, ALL은 인덱스를 사용하지 않고 테이블 전체를 조회하는 풀 테이블 스캔을 의미**한다.
* 이 때, **단일 SELECT 쿼리는 상술한 12가지 방법 중 하나만을 사용할 수 있으며, index_merge를 제외한 나머지 방식은 하나의 인덱스만을 사용**한다.
  * 때문에 실행 계획에서도 각 라인에 접근 방법은 둘 이상 표시되지 않고, index_merge 이외의 방식은 인덱스 항목에도 하나의 인덱스만 표시된다.
* 이렇듯 **옵티마이저는 상술한 방식들의 접근 방법과 비용을 함께 고려하여 최소의 비용이 소모되는 접근 방법을 선택하여 쿼리를 처리**한다.

## 2022-10-11 Tue
### type 컬럼 - system 접근 방법
* system은 MyISAM 또는 MEMORY 테이블에서만 나타나는 접근 방법이며, 레코드가 1건 이하인 테이블을 참조하는 형태의 접근 방법에 해당한다.
  * 때문에 실제 애플리케이션에서 사용하는 쿼리에서는 system 접근 방법을 거의 확인할 수 없다.

### type 컬럼 - const 접근 방법
* **테이블의 레코드 수와 관계 없이 쿼리가 PK 또는 UQ 키 컬럼을 사용하는 WHERE 조건을 갖고, 반드시 1건을 반환하는 경우를 의미**한다.
  * 다른 DBMS에서 이러한 접근 방식을 UQ 인덱스 스캔이라고도 표현한다.
* 반면, **다중 컬럼으로 구성된 PK 또는 UQ 키에서 인덱스의 컬럼 중 일부만을 WHERE 절에서 사용하는 경우, const 접근 방식은 사용할 수 없다**.
  * 이 경우, 인덱스 별 후행 컬럼의 존재로 인해 MySQL 엔진은 데이터를 실제로 조회하지 않고서는 반드시 1건의 레코드만 존재하는 것을 확신할 수 없다.
  * 이렇듯 **PK의 일부만 조건 절에서 사용하는 경우, type 컬럼에는 const가 아닌 ref 접근 방식이 표현**된다.
* 반면, **PK 또는 UQ 인덱스에 명시된 모든 컬럼을 동등 조건으로 WHERE 절에 명시하면 다시 const 접근 방법을 사용**할 수 있다.

### const와 상수화
* **실행 계획에서 type 컬럼이 const로 표현되는 실행 계획은 옵티마이저가 쿼리를 최적화하는 단계에서 해당 쿼리를 우선 실행하여 상수화**한다.
  * 예를 들어 const를 사용할 수 있는 서브쿼리가 WHERE절의 동등 조건으로 사용된 경우, 우선 해당 서브쿼리를 실행하여 결과 상수를 원본 쿼리에 반영한다.
  * 다시 말해 **const 접근 방법을 사용하는 실행 계획을 포함하는 쿼리의 경우, 해당 쿼리는 옵티마이저에 의해 쿼리 최적화 시점에 상수로 변환**된다.
  * 이렇듯 쿼리는 우선 옵티마이저에 의해 상수화된 후에 쿼리 실행기로 전달되기 때문에 상수라는 의미를 갖는 const로 표시된다.

### type 컬럼 - eq_ref 접근 방법
```
> eq_ref 접근 방법은 두 번째 이후에 읽어들이는 테이블의 type 컬럼에 표시될 수 있다.
> eq_ref 접근 방법은 두 번째 이후에 읽어들이는 테이블에서 레코드가 반드시 1건만 존재한다는 보장이 전제되어야 한다.
```
* 해당 접근 방법은 여러 테이블이 조인되는 쿼리의 실행 계획에서만 표시될 수 있다.
  * **정확히는 처음 읽은 테이블의 컬럼 값을 그 다음에 읽어들일 테이블에서 PK 또는 UQ 키 컬럼을 사용하는 검색 조건에 사용할 수 있어야 한다**.
* 이 밖에도 eq_ref 접근 방법을 사용하기 위해서는 다음과 같은 조건을 만족해야 한다. 
  1. **두 번째 이후로 읽어들이는 테이블의 UQ 인덱스로 검색할 때 해당 UQ 인덱스는 NOT NULL**이어야 한다.
  2. **다중 컬럼으로 정의된 PK 또는 UQ 인덱스의 경우, 모든 컬럼이 비교 조건에서 사용**되어야 한다. 
* **이렇듯 eq_ref 접근 방법이 사용되기 위해서는 조인에서 두 번째 이후에 읽어들이는 테이블에서 반드시 1건만 존재한다는 보장이 전제**되어야 한다.

### type 컬럼 - ref 접근 방법
```
> ref 접근 방법은 인덱스 종류와 관계 없이 동등 조건으로 검색할 때에만 사용될 수 있다.
> ref 접근 방법은 인덱스를 사용할 수 있는 컬럼을 동등 조건으로 검색한 경우에 레코드가 1건 뿐이라는 보장이 없는 경우에 사용된다.
```
* **ref 접근 방법은 eq_ref와 달리 조인의 순서나 PK 또는 UQ 제약 조건 없이 사용**될 수 있다.
* **ref 접근 방법은 반드시 레코드가 1 건만 존재한다는 보장이 없으므로 const 또는 eq_ref보다 빠를 수 없다**.
  * 반면, **동등 조건으로만 비교를 수행하므로 매우 빠르게 레코드를 조회할 수 있는 방법에 해당**한다.
* ref 접근 방법이 활용된 경우, 실행 계획의 ref 컬럼에는 const가 명시된다.
  * 이 때, **ref 컬럼에 명시된 const는 상수화 접근 방법이 아닌 값 비교에 사용된 입력이 상수임을 의미**한다.

### const와 eq_ref, ref 접근 방법 비교하기
```
> const와 eq_ref, ref 접근 방법은 모두 매우 좋은 접근 방법이다.
> 인덱스의 분포도가 적절한 경우, 상술한 세 접근 방법은 성능 상의 문제를 일으키지 않는다.
> 때문에 쿼리를 튜닝하는 경우에도 세 접근 방법에 대해서는 크게 신경 쓰지 않아도 무방하다.
```
* **const의 경우, 조인의 순서와 관계 없이 PK 또는 UQ 인덱스에 포함되는 모든 컬럼에 대해 동등 조건으로 검색한 경우에 해당**한다.
  * 즉, 반드시 1건의 레코드만 반환되는 것이 보장된다.
* **eq_ref의 경우, 조인에서 첫 번째 읽은 테이블의 컬럼 값을 활용하여 두 번째 테이블의 PK 또는 UQ 인덱스에 대해 동등 조건으로 검색한 경우에 해당**한다.
  * 즉, 두 번째 테이블부터는 반드시 1건의 레코드만 반환하는 것이 보장된다.
* **ref의 경우, 조인의 순서나 인덱스 종류와 관계 없이 동등 조건으로 검색한 경우에 해당**한다.
  * 이 경우, 반드시 1건의 레코드만 반환한다는 보장이 없다.
* 세 가지 접근 방법 모두 WHERE 절에서 사용하는 비교 연산자는 다음과 같은 동등 비교 연산자여야 한다.
  1. = 연산자
  2. <=> 연산자: **NULL에 대한 비교 방식만 다를 뿐 기본적으로 = 연산자와 같은 연산자에 해당**한다.

### type 컬럼 - fulltext 접근 방법
* 해당 접근 방법은 MySQL 서버가 제공하는 전문 검색 인덱스를 사용하여 레코드를 읽는 방식을 의미한다.
  * 전문 검색 인덱스는 통계 정보가 관리되지 않고, 전문 검색 인덱스를 사용하기 위해서는 전혀 다른 SQL 문법을 사용해야 한다.
  * 또한, MySQL 서버 상 전문 검색 조건은 우선 순위가 상당히 높다.
* 쿼리에서 전문 인덱스를 사용하는 조건과 그 이외의 일반 인덱스를 사용하는 조건을 함께 명시한 경우, MySQL은 다음과 같은 방식으로 인덱스를 선택한다.
  1. 일반 인덱스의 접근 방법이 const나 eq_ref 또는 ref인 경우, 해당 인덱스를 사용한다.
  2. 일반 인덱스의 접근 방법이 상술한 세 종류가 아닌 경우, MySQL은 전문 인덱스를 사용하는 조건으로 처리한다.
* 이렇듯 일반적으로 `MATCH ... AGAINST ...`와 같이 쿼리에 전문 검색 조건을 사용한 경우 MySQL 서버는 fulltext 접근 방법을 사용한다.
  * 그러나 **대부분의 경우 fulltext보다 일반 인덱스를 사용하는 range 접근 방법이 더 빠르게 처리**되곤 한다.
  * 때문에 전문 검색 쿼리를 사용하는 경우에는 반드시 조건 별로 성능을 확인해야 한다.

### type 컬럼 - ref_or_null 접근 방법
* **해당 접근 방법은 ref 접근 방법과 유사하지만 NULL 비교를 추가한 형태에 해당**한다.
  * 즉, 말 그대로 ref 접근 방법 또는 IS NULL과 같은 NULL 비교 접근 방법을 의미한다.
* **실무에서 해당 접근 방법을 자주 확인할 수는 없으나, 사용된다고 하더라도 성능은 좋은 축에 속한다**.

### type 컬럼 - unique_subquery 접근 방법
* **해당 접근 방법은 WHERE 조건절에서 사용될 수 있는 `IN(subquery)` 형태의 쿼리를 위해 사용**된다.
  * 이 때, 접근 방법의 의미 그대로 서브쿼리에서 중복되지 않는 유니크한 값만을 반환하는 경우에 해당 접근 방법을 사용할 수 있다.
  * MySQL 8.0 부터는 이렇듯 WHERE 조건절에 사용된 `IN(subquery)` 형태의 세미 조인을 최적화하기 위한 많은 기능이 도입되었다.

### type 컬럼 - index_subquery 접근 방법
* **IN 연산자는 `IN(subquery)` 형태 또는 `IN(상수의 나열)` 형태를 사용할 수 있으며, 반드시 괄호 안에 중복된 값이 제거된 목록이 전달되어야 한다**.
* **서브쿼리의 특성 상 `IN(subquery)`에서 중복된 값이 반환될 수 있는 경우, 서브쿼리의 중복된 값을 인덱스로 제거할 수 있다면 해당 접근 방법이 사용**된다.
  * 반면, **unique_subquery 접근 방법은 subquery 자체가 중복된 값을 반환하지 않는다는 보장이 있기에 별도의 중복 제거 작업이 필요가 없다**.

### unique_subquery와 index_subquery 접근 방법 비교하기
* **unique_subquery의 경우, IN 연산자에 전달된 서브쿼리의 반환 값에 중복된 값이 없으므로 별도의 중복 제거 작업이 필요하지 않다**.
* **index_subquery의 경우, IN 연산자에 전달된 서브쿼리의 반환 값에 중복된 값이 있을 수도 있지만 이를 인덱스로 제거**할 수 있다.

### type 컬럼 - range 접근 방법
* **range 접근 방법은 일반적인 인덱스 레인지 스캔에서 사용되는 접근 방법에 해당하며, 인덱스를 하나의 값이 아닌 범위로 검색하는 경우를 의미**한다.
  * 예를 들어 **<, >, IS NULL, BETWEEN, IN, LIKE 등의 연산자로 인덱스를 검색하는 경우에 사용**된다.
* 이러한 **인덱스 범위 검색은 일반적으로 애플리케이션에서 가장 자주 사용하는 접근 방법이지만, 접근 방법 중에서 우선 순위는 낮은 축**에 속한다.
  * **레코드의 개수에 따라 차이가 있을 수 있으나, 일반적으로 range 접근 방법 자체도 상당히 빠르게 처리**될 수 있다.
  * 때문에 **애플리케이션에서 사용하는 모든 쿼리가 해당 접근 방법만 사용한다고 하더라고 최적의 성능이 보장**된다고 할 수 있다.

### 실무에서의 인덱스 레인지 스캔
* **일반적으로 인덱스 레인지 스캔, 또는 레인지 스캔은 const와 ref 및 range 접근 방법을 통칭하는 의미로 사용**된다.
* 또한, **인덱스를 효율적으로 사용한다는 표현이나 작업 범위 결정 조건으로 인덱스를 사용한다는 것은 모두 상술한 세 접근 방법을 사용하는 것을 의미**한다.
  * 일반적으로 DBA와 개발자 역시 세 접근 방법을 명확히 구분하는 경우는 많지 않으며, 대부분의 경우에 인덱스 레인지 스캔이라는 표현을 사용한다. 

## 2022-10-12 Wed
### type 컬럼 - index_merge 접근 방법
* 해당 접근 방법은 상술한 방식들과는 다르게 2개 이상의 인덱스를 이용하여 우선 각각의 검색 결과를 만들고, 이를 병합하여 처리하는 식으로 동작한다.
* 또한, **해당 접근 방법은 다음과 같은 이유에서 효율성은 떨어진다**.
  1. 여러 인덱스를 읽어들이므로, range 접근 방법보다 효율성이 떨어진다.
  2. 전문 검색 인덱스를 사용하는 쿼리에서는 적용되지 않는다.
  3. 해당 접근 방법을 통해 처리된 결과는 항상 둘 이상의 집합이므로, 이들의 교집합 또는 합집합 및 중복 제거와 같은 추가 작업이 필요하다.

### type 컬럼 - index 접근 방법 (인덱스 풀 스캔)
```
> index 접근 방법은 그 이름에서 언뜻 효율적으로 인덱스를 활용하는 것처럼 보여지지만, 실상은 인덱스를 처음부터 끝까지 조회하는 인덱스 풀 스캔을 의미한다.
```
* **해당 접근 방법은 range 접근 방법과 같이 인덱스를 필요한 만큼만 효율적으로 조회하지 못한다**.
* 해당 접근 방법은 **풀 테이블 스캔과 비교하여 조회하는 레코드 수는 같으나, 일반적으로 인덱스의 크기는 데이터 파일 전체보다 작으므로 더 빠르게 처리**된다.
  * 또한, 쿼리의 내용에 따라서는 정렬된 인덱스의 특징을 활용할 수도 있다.
* **해당 접근 방법은 range나 const 또는 ref 등의 접근 방법을 사용할 수 없는 경우, 다음 중 하나의 조건을 충족하는 쿼리에서 사용**된다.
  1. **인덱스에 포함된 컬럼만으로 처리할 수 있는 쿼리로, 데이터 파일을 실제로 읽을 필요가 없는 경우**
  2. **또는 인덱스를 활용하여 정렬이나 그루핑이 가능하여 별도의 정렬 작업을 처리하지 않아도 되는 경우**

### type 컬럼 - ALL 접근 방법 (풀 테이블 스캔)
```
> ALL 접근 방법은 상술한 접근 방법 중 어떠한 것도 적용할 수 없는 경우, 마지막에 선택하는 가장 비효율적인 접근 방법이다. 
```
* 해당 접근 방법은 **흔히 알고 있는 풀 테이블 스캔을 의미하며, 테이블을 처음부터 끝까지 전부 읽어들여 결과를 반환**한다.
  * 이 때, 쿼리의 WHERE절 등에 체크 조건이 존재하는 경우 불필요한 레코드를 제거하고 반환한다.

### OLTP 환경에서의 index 접근 방법, 또는 ALL 접근 방법
* **일반적으로 빠른 응답을 사용자에게 반환해야 하는 웹 서비스 등, OLTP 환경에서는 작업 범위를 제한하지 못하는 index와 ALL 접근 방법을 지양**해야 한다.
* 때문에 **테이블이 매우 작을 수 밖에 없는 경우가 아니라면 반드시 테이블에 데이터를 어느 정도 저장한 후에 쿼리의 성능을 우선 확인해보는 것이 바람직**하다.

### 대량의 디스크 IO가 필요한 작업과 쿼리 튜닝
```
> 쿼리 튜닝은 항상 인덱스 풀 스캔 또는 테이블 풀 스캔을 회피하도록 만드는 작업은 아니다.
> DW 또는 배치성 작업의 경우, 오히려 ALL 접근 방법을 사용하는 것이 좋은 결과를 만들 수 있다.
```
* InnoDB는 풀 테이블 스캔 또는 인덱스 풀 스캔 등 대량의 디스크 IO를 유발하는 작업을 위해 한 번에 많은 페이지를 읽어들이는 리드 어헤드 기능을 제공한다.
  * 이를 통해 한 번에 여러 페이지를 읽어들여 처리할 수 있게 된다.
* **DW 또는 배치 프로그램 등, 대용량 레코드를 처리하는 경우 억지로 인덱스를 사용하도록 잘못 튜닝된 쿼리보다는 ALL 접근 방법을 사용하는 것이 바람직**하다.

### 리드 어헤드란?
* MySQL 서버는 인접한 페이지가 연속하여 특정 횟수 이상 조회된 경우, 백그라운드의 읽기 스레드가 최대 64개의 페이지씩 한 번에 읽어들이도록 최적화한다.
  * **이러한 기능을 리드 어헤드라고 하며, 이를 통해 한 번에 페이지를 하나씩만 읽어들이는 경우에 비해서 훨씬 빠르게 레코드를 조회**할 수 있다.
  * 또한, MySQL의 경우 시스템 변수를 적절히 조절하는 것으로 리드 어헤드 기능을 언제 실행할지 제어할 수 있다.

### MySQL 8.0의 병렬 쿼리
* **8.0 버전에서는 병렬 쿼리 기능이 도입되었으나, 아직은 도입 초기이기 때문에 조건 절 없이 전체 테이블 레코드를 조회하는 경우에만 병렬 실행이 가능**하다.
  * 이 때, 관련된 시스템 변수를 조절하는 것으로 병렬 쿼리를 처리하는 과정에서 동시에 몇 개의 스레드를 사용할지 설정할 수 있다.

### 실행 계획 - possible_keys 컬럼
```
> 일반적으로 실행 계획의 possible_keys 컬럼은 무시해도 무방하다.
```
* **해당 컬럼은 그저 옵티마이저가 실행 계획을 수립하는 과정에서 고려했던 인덱스의 목록을 의미**하며, 그 이름으로 인해 사용자의 오해를 자주 불러일으킨다.
  * 옵티마이저는 기본적으로 쿼리를 처리하기 위해 여러 방법을 고려하며, 그 중 가장 비용이 낮을 것으로 예상되는 실행 계획을 선택하여 쿼리를 실행한다.
  * 이 과정에서 **고려되었던 모든 인덱스 목록을 해당 컬럼이 표시하므로, 사실상 해당 컬럼은 쿼리 튜닝에 그다지 도움이 되지 않는다**.
* **해당 컬럼은 아주 특별한 경우를 제외하고는 무시해도 무방하며, 절대 해당 컬럼에 나열된 인덱스를 실제로도 사용한다고 판단하지 않아야 한다**.

### 실행 계획 - key 컬럼
```
> 쿼리를 튜닝하는 경우, 실행 계획의 key 컬럼에 의도한 인덱스가 표시되었는지 반드시 확인해야 한다. 
```
* **인덱스 후보를 모두 명시하는 possible_keys 컬럼과 달리, 해당 컬럼에 표시되는 인덱스는 최종적으로 선택되어 실행 계획에서 사용된 인덱스를 의미**한다.
* 이 때, **실행 계획의 type 컬럼이 index_merge가 아닌 경우에는 반드시 테이블 당 하나의 인덱스만 사용**될 수 있다.
  * 반면, index_merge 타입의 실행 계획이 사용되는 경우 쉼표로 구분되는 둘 이상의 인덱스가 사용된다.
* **풀 테이블 스캔을 수행하는 ALL 타입의 실행 계획에서는 key 컬럼이 NULL로 표시**된다.

### 실행 계획 - key_len 컬럼
* **해당 컬럼은 쉽게 무시되곤 하지만, 실제로는 인덱스를 구성하는 컬럼 중 몇 개의 컬럼이 유효하게 사용되었는지 알려주는 중요한 정보에 해당**한다.
  * 더 정확히는 해당 컬럼을 통해 인덱스의 각 레코드에서 몇 바이트까지 사용되었는지 알 수 있다.
* 예를 들어, INTEGER 타입의 컬럼을 포함하는 다중 컬럼 인덱스를 활용하는 쿼리가 해당 컬럼만으로 처리된 경우, key_len은 정수 타입에 할당되는 4로 표시된다.
* 반면, **MySQL에서는 NULLABLE 컬럼에서 해당 컬럼의 NULL 여부를 저장하기 위해 1바이트를 추가로 사용**한다.
  * 이러한 이유에서, **key_len 필드의 값은 데이터 타입의 길이보다 다소 길게 표시되는 경우가 발생**할 수 있다.

## 2022-10-13 Thu
### 실행 계획 - ref 컬럼
* type에 명시된 **접근 방법이 ref인 경우, ref 컬럼은 참조 조건(또는 Equal 비교 조건)으로 어떤 값이 제공됬는지 표시**한다.
  * 예를 들어, 임의의 상수가 지정된 경우 ref 컬럼의 값은 const이며 다른 테이블의 컬럼인 경우 해당 테이블 이름과 컬럼 명이 표시된다.
* **일반적으로 해당 컬럼의 값은 크게 신경 쓰지 않아도 무방하나, func로 표시된 경우 주의할 필요**가 있다.
  * 이는 참조용으로 사용된 값을 그대로 적용한 것이 아니라 콜레이션 변환 또는 값 자체의 연산을 거쳤음을 의미한다.
* **func는 사용자가 명시적으로 값을 변환하는 경우 뿐만 아니라 MySQL 자체적으로 내부에서 값을 변환하는 경우에도 출력**된다.
  * **예를 들어, 문자 집합이 일치하지 않는 두 문자열 컬럼을 조인하거나 숫자 타입의 컬럼과 문자 타입의 컬럼을 조인하는 경우**가 있다.
  * **가능한 한 MySQL 서버가 내부적인 변환 처리를 적용할 필요 없도록 조인 컬럼의 타입을 일치시키는 것이 바람직**하다.

### 실행 계획 - rows 컬럼
* 옵티마이저는 각 조건을 처리할 수 있는 처리 방식을 나열한 후, 각 처리 방식의 비용을 비교하여 최종적으로 하나의 실행 계획을 수립한다.
  * 이 때, 각 처리 방식이 얼마나 많은 레코드를 읽고 비교할 필요가 있는지 예측하여 비용을 산정한다.
  * 예를 들어 **각 인덱스 값의 분포도가 어떤 형태인지, 또는 대상 테이블에 얼마나 많은 레코드가 포함되어 있는지 통계 정보를 기준으로 조사하여 예측**한다.
* **rows 컬럼은 실행 계획의 효율성 판단을 위해 예측한 레코드 건수를 표시하며, 이는 스토리지 엔진 별 통계 정보를 토대로 옵티마이저가 산출한 예상 값**이다.
  * 이 때, **표시되는 값은 반환하는 레코드의 예측치가 아닌 쿼리를 처리하기 위해 레코드를 얼마나 읽고 비교해야하는지를 의미**한다.
* 옵티마이저가 산출한 예측 값은 당연히 틀릴 가능성이 높으며, 이는 대략적인 값을 측정하기 위함이지 정확한 값을 산출하기 위한 기능이 아니다.
  * 그러나 최대한 정확한 실행 계획을 수립하기 위해서는 대략적으로나마 실제 수치에 근사할 필요는 있으며, 이를 위해 8.0 버전부터는 히스토그램이 도입되었다.

### 실행 계획 - filtered 컬럼
* 상술한 바와 같이 옵티마이저는 각 테이블로부터 일치하는 레코드 수를 가능한 한 정확히 파악해야 효율적인 실행 계획을 수립할 수 있다.
  * 반면, rows 컬럼의 값은 인덱스를 사용할 수 있는 조건에만 일치하는 레코드 수를 예측한다.
  * 그러나 대부분의 쿼리에서 WHERE 절에 사용되는 조건이 모두 인덱스를 사용할 수 있는 것은 아니다.
  * **조인 쿼리의 경우, WHERE 절에서 인덱스를 사용할 수 있는 조건 만큼 인덱스를 사용하지 못하는 조건에 일치하는 레코드 수를 파악하는 것도 중요**하다.
* **filtered 컬럼의 값은 필터링된 후에 남은 레코드의 비율을 의미하며, 필터링되어 버려지는 레코드의 비율을 의미하지는 않는다**.
* 옵티마이저는 래코드 수 뿐만 아니라 다른 요소들을 고려하여 실행 계획을 수립하며, 조인의 경우 대상 건수가 적은 테이블을 선행 테이블로 선택하려는 경향이 있다.
  * 이렇듯 **대상 건수가 적은 테이블을 선행 테이블로 선택하는 것은 조인 횟수를 줄이고 그 과정에서 조회한 데이터를 저장할 메모리 용량을 낮추기 위함**이다.
* 상술한 이유에서, **filtered 컬럼에 표시되는 값이 정확히 예측될수록 조인의 성능은 높아질 수 있다**.
  * 또한, MySQL 8.0 부터는 이러한 filtered 컬럼의 값을 더욱 정확히 예측할 수 있도록 히스토그램 기능이 도입되었다.

### 실행 계획 - Extra 컬럼
* 해당 컬럼에는 이름과는 달리 실행 계획에서 성능과 관련된 중요한 내용이 2 ~ 3개씩 함께 표시된다.
  * 즉, **해당 컬럼은 기본적으로 내부적인 처리 알고리즘에 대해 더 깊이 있는 내용르 표시하는 경우가 많다**.
* 일반적으로 MySQL 서버 버전이 업그레이드되고 최적화될수록 새로운 내용이 Extra 컬럼에 나타난다.

### Extra 컬럼 - const row not found
* 쿼리 실행 계획에서 const 접근 방법이 사용되었으나, **실제 대상 테이블에는 레코드가 전혀 없는 경우가 표시되는 내용**이다.
  * 해당 메시지가 표시된 경우, 테이블에 적절한 더미 데이터를 쌓아둔 상태에서 다시 쿼리를 실행하는 방식으로 대처할 수 있다.

### Extra 컬럼 - Deleting all rows
* 해당 내용은 MyISAM과 같이 스토리지 엔진의 핸들러 차원에서 테이블의 모든 레코드를 한 번에 삭제하는 기능을 제공하는 엔진의 테이블인 경우 표시될 수 있다.
* 주로 **WHERE 절이 없는 DELETE 문에서 표시되곤 하며, 이는 모든 레코드를 한 번에 삭제하는 핸들러 기능을 한 번만 호출했음을 의미**한다.
  * 즉, 테이블에 레코드가 100건이라고 해서 레코드를 삭제하는 핸들러 함수를 100번 호출하는 것과는 달리 한 번의 핸들러 함수 호출로 작업을 완료한다.
* MySQL 8.0 버전부터는 InnoDB 및 MyISAM 엔진 모두 실행 계획에 해당 최적화 방식이 표시되지 않는다.
  * 때문에 **테이블의 레코드를 모두 삭제하고자 하는 경우, WHERE 조건 절이 없는 DELETE 쿼리보다는 TRUNCATE TABLE 명령이 권장**된다.

### Extra 컬럼 - Distinct
* 해당 내용은 **두 테이블을 조인히는 과정에서 임의의 컬럼을 기준으로 레코드의 중복을 제거하고자 하는 경우에 표시**된다.
  * 이 과정에서 **쿼리의 DISTINCT를 처리하기 위해 조인이 필요 없는 항목은 조회하지 않고 모두 무시되며, 꼭 필요한 레코드만 조회된 후에 조인**된다.

## 2022-10-14 Fri
### Extra 컬럼 - FirstMatch
* 해당 내용은 세미 조인 최적화 기법 중 FirstMatch 전략이 사용된 경우에 표시되며, `FirstMatch(테이블명)` 형태로 출력된다.
  * 이 때 함께 표시되는 테이블 명은 기준 테이블을 의미하며 해당 테이블을 기준으로 비교 테이블로부터 첫 번째로 일치하는 한 건만 검색한다.

### Extra 컬럼 - Full scan on NULL key
* **해당 내용은 `col1 IN (SELECT col2 FROM ...)`과 조건을 가진 쿼리에서 자주 발생**한다.
  * 이 때, col1의 값이 NULL인 경우 상술한 조건은 `NULL IN (SELECT col2 FROM ...)`과 같다.
* **SQL 표준에서는 NULL을 알 수 없는 값으로 정의하며, NULL에 대한 연산 규칙은 다음과 같이 정의**된다.
  1. **서브쿼리가 단 1건이라도 결과 레코드를 갖는 경우, 최종 비교 결과는 NULL**이다.
  2. **서브쿼리가 1건도 결과 레코드를 갖지 않는 경우, 최종 비교 결과는 FALSE**이다.
* 이 때, **col1이 NULL이 되는 경우 서브쿼리에 사용되는 테이블에 대해서는 풀 테이블 스캔을 적용해야만 결과가 NULL인지 FALSE인지 알 수 있다**.
  * **Extra 컬럼에 표시된 Full scan on NULL key는 MySQL 서버가 쿼리를 처리하던 도중 col1이 NULL인 경우를 만났음을 의미**한다.
  * 그 내용과 마찬가지로, 이 경우 차선책으로 서브쿼리 테이블에 대해 풀 테이블 스캔을 적용하게 된다.
* 반면, **col1이 NOT NULL로 정의된 컬럼이라면 이러한 서브쿼리 테이블의 풀 스캔은 사용될 일이 없으며 Extra 컬럼에 해당 메시지도 표시되지 않는다**.
* **컬럼이 NULLABLE이지만 상술한 NULL 비교 규칙을 무시해도 되는 경우, col1이 절대 NULL이 될 수 없다는 사실을 옵티마이저에게 알려주어야 한다**.
  * 예를 들어, 쿼리의 조건 절에 `col1 IS NOT NULL` 조건을 명시한다.
  * 이 경우, col1이 NULL이라면 NOT NULL 조건이 FALSE이므로 후속 조건인 `col1 IN (SELECT col2 FROM ...)`는 실행되지 않는다.
* **해당 내용이 표시되더라도 IN 또는 NOT IN 연산자의 왼 쪽 값이 실제로 NULL이 될 수 없다면 서브쿼리 테이블에 대한 풀 스캔은 발생하지 않는다**.
  * 즉, 이러한 경우에는 풀 테이블 스캔으로부터 기인하는 성능 저하를 걱정할 필요가 없다.
  * **그러나 IN 또는 NOT IN 연산자의 왼쪽 값이 NULL인 레코드가 존재하며 서브쿼리에 개별적인 WHERE 조건이 존재한다면 성능은 상당히 저하될 수 있다**.

### Extra 컬럼 - Impossible HAVING
* 해당 내용은 쿼리에 사용된 HAVING 절의 조건을 만족하는 레코드가 없는 경우에 표시된다.
  * **애플리케이션에서 사용하는 쿼리 중 실행 계획에 해당 내용이 표시되는 경우, 쿼리 자체가 잘못된 경우가 대부분이므로 이를 점검하는 것이 바람직**하다.

### Extra 컬럼 - Impossible WHERE
* **상술한 Impossible HAVING과 유사하며, WHERE 절의 조건이 항상 FALSE일 수 밖에 없는 경우에 해당 내용이 표시**된다.
  * 즉, 해당 내용은 불가능한 WHERE 조건 절이 명시되었음을 의미한다.

### Extra 컬럼 - LooseScan
* 세미 조인 최적화 기법 중 LooseScan 최적화 기법이 사용된 경우, Extra 컬럼에는 해당 내용이 표시된다.

### Extra 컬럼 - No matching min/max row
* 쿼리의 WHERE 절을 만족하는 레코드가 한 건도 없는 경우 `Impossible WHERE`가 표시된다.
  * 반면, MIN() 또는 MAX()와 같은 집합 함수가 존재하는 쿼리의 조건 절에 일치하는 레코드가 없는 경우에는 해당 메시지가 출력된다.
  * 또한, **MIN() 또는 MAX()의 결과로는 NULL이 반환**된다.

### Impossible...과 No matching... 메시지
* 이러한 휴의 메시지는 **쿼리 자체의 오류처럼 보일 수 있으나, 단지 실행 계획을 산출하기 위한 자료가 존재하지 않음을 의미**한다.
  * 즉, 상술한 메시지가 출력된다고 해서 반드시 쿼리 자체에 문법적인 오류가 있는 것은 아니다.
  * 그러나 **쿼리 처리를 위한 데이터가 전혀 없다는 것을 의미하므로, 쿼리 자체가 비즈니스적인 오류를 갖는지 다시 한 번 확인하는 것이 바람직**하다.

### Extra 컬럼 - no matching row in const table
* 조인을 사용하는 쿼리에서 조인에 사용된 테이블에 const 방식으로 접근하는 경우, 일치하는 레코드가 존재하지 않는 경우 해당 메시지가 표시된다.
  * 이러한 메시지 역시 상술한 종류와 같은 부류이며, 단지 실행 계획을 산출하기 위한 레코드가 없음을 의미한다.

### Extra 컬럼 - No matching rows after partition pruning
* **해당 메시지는 파티션된 테이블에 대한 UPDATE 또는 DELETE를 시도하지만, 해당 파티션에 적절한 대상 레코드가 없는 경우 실행 계획에 표시**된다.
  * 산출된 실행 계획의 partitions 컬럼이 NULL로 표시된 동시에 해당 내용을 확인한 경우, 이는 대상 파티션 자체가 존재하지 않음을 의미할 수 있다.

### Extra 컬럼 - No tables used
* MySQL 서버는 다른 DBMS와 달리 FROM 절이 없는 쿼리를 허용하며, 다음과 같은 방식으로 사용할 수 있다.
  1. FROM 절 자체가 없는 쿼리
  2. FROM 절에 컬럼과 레코드를 각각 하나씩만 갖는 가상의 상수 테이블인 DUAL을 명시한 쿼리
* 이 때, **FROM 절이 없거나 `... FROM DUAL` 형태의 쿼리에 대해 산출된 실행 계획의 Extra 컬엄에서 `No tables used` 메시지를 확인**할 수 있다.

## 2022-10-15 Sat
### Extra 컬럼 - Not exists
* 앱을 개발하는 과정에서 A 테이블에는 존재하나 B 테이블에는 존재하지 않는 값을 조회하는 경우, 주로 NOT IN(subquery) 또는 NOT EXISTS를 사용한다.
  * 이러한 형태의 조인을 안티 조인이라고 하며, 이는 곧 일반 조인에서 나오지 않는 결과만은 조회하는 방법이다.
* 반면, **안티 조인과 같은 처리를 아우터 조인으로도 구현할 수 있으며 이는 레코드 수가 많을 때 더 효율적인 방식**이다.
* **해당 내용은 아우터 조인을 활용하여 안티 조인을 수행하는 쿼리의 실행 계획에서 확인**할 수 있다.
  * 이는 또한 옵티마이저가 드라이빙 테이블의 레코드를 활용하여 드리븐 테이블을 조인할 때 드리븐 테이블 레코드가 존재하는지 아닌지만 판단하는 것을 의미한다.
  * 때문에 드리븐 테이블에 조인 조건에 일치하는 레코드가 여럿이 존재하더라도 옵티마이저는 단 1 건만 조회하여 처리를 완료하는 식으로 최적화를 적용한다.

### Extra 컬럼 - Plan isn't ready yet
* MySQL 8.0 버전에서는 `SHOW PROCESSLIT` 와 `EXPLAIN FOR CONNECTION` 명령어를 조합하여 다른 커넥션이 실행한 쿼리의 실행 계획을 볼 수 있다.
  * 이러한 명령은 옵티마이저가 의도한 인덱스를 사용하지 못하고 풀 스캔을 적용한 등 잘못된 실행 계획의 선택한 것은 아닌지 확인하는 데에 유용하다.
* **이러한 명령어를 사용했을 때 실행 계획에서 해당 내용이 표시된 경우, 이는 아직 대상 커넥션에서 쿼리 실행 계획을 미처 수립하지 못했음을 의미**한다.
  * 때문에 약간의 여유 시간을 조금 더 준 상태에서 다시 명령어를 실행하는 것으로 대상 커넥션의 쿼리 실행 계획을 정상적으로 확인할 수 있다.

### Extra 컬럼 - Range checked for each record(index map:N)
* 조인 조건에 상수 없이 변수만 존재하는 조인 쿼리에서 옵티마이저는 드리븐 테이블을 읽을 때 인덱스 레인지 스캔과 풀 테이블 스캔 중 무엇을 선택할지 알 수 없다.
  * 즉, 드라이빙 테이블의 레코드를 하나씩 조회할 때마다 드라이빙 테이블의 변수 값이 변경되므로 쿼리 비용 계산을 위한 기준 값은 계속해서 변경된다.
* 예를 들어 emp_no가 1부터 1억까지 존재하는 테이블에 대해 다음과 같은 쿼리가 존재한다고 가정한다.
```
SELECT * FROM employees e1, employees e2
WHERE e2.emp_no >= e1.emp_no;
```
* 이 경우, **e1의 초기에는 풀 테이블 스캔을 적용하고 e1의 후기에는 인덱스 레인지 스캔을 선택하는 것이 최적의 방법**이 된다.
  * 이는 어차피 e1은 풀 테이블 스캔을 진행해야 하며, 첫 번째 사번에서는 e2를 1억 건 조회하고 마지막 사번에서는 1건만 조회하기 때문이다. 
* **해당 내용은 이러한 경우에 표시되며, 각 레코드마다 인덱스 레인지 스캔을 적용할지 여부를 체크함을 의미**한다.
  * 즉, **각 레코드마다 range 접근 방법과 ALL 접근 방법 중 무엇을 적용할지 체크**한다.
* 이 때, Extra 컬럼에는 실제로는 `Range checked for each record (index map: 0x1)`과 같은 내용이 표시된다.
  * 이 중 index map은 후보 인덱스의 순번을 16진수로 표현한 것을 의미한다.
  * 때문에 **e2의 각 레코드를 조회할 때 e2 테이블의 첫 번째(0x1) 인덱스를 사용할지 풀 테이블 스캔을 적용할지 결정하는 식으로 처리**된다.
* 또한, **Extra 컬럼에 해당 내용이 표시된 경우 type 컬럼은 항상 ALL로 표시**된다.
  * **이는 항상 풀 테이블 스캔을 적용하는 것을 의미하지 않고, index map에 표시된 인덱스를 사용하지 않을 경우 풀 테이블 스캔을 적용함을 의미**한다.
* 이러한 실행 계획을 사용하는 쿼리가 많이 사용되는 MySQL 서버의 경우, `SHOW GLOBAL STATUS`의 값 중 `Select_range_check` 값은 크게 나타난다.

### index map 해석하기
* `index map: 0x19`로 표시되는 경우, 이는 다음과 같은 순서로 해석한다.
  1. 0x19를 2진수로 변환한다.
  2. 대상 테이블의 DDL을 확인하여 적용된 인덱스들의 순서를 확인한다.
  3. 1.에서 변환된 2진수의 각 자릿수가 작은 쪽부터 세어 2.의 인덱스를 매핑한다.
  4. 이 때, **1.에서 변환된 2진수의 각 자릿수 별 값이 1인 경우 3.에서 매핑한 인덱스는 후보가 됨을 의미**한다.
* **예를 들어 16진수 0x19는 10진수로 25, 2진수로 0b11001이 되므로 DDL 상 명시된 첫 번째, 네 번째, 다섯 번째 인덱스가 후보임을 의미**한다.
* 이 때, **Extra 컬럼에 `Range checked for each record`가 명시된 실행 계획에서는 각 레코드 별로 후보 인덱스 중 어떤 것을 적용할지 결정**된다.
  * 그러나 **각 레코드마다 실제로 어떤 인덱스가 사용되었는지는 알 수 없으며, index map 정보를 토대로 사용된 인덱스의 후보만을 알 수 있다**. 

### Extra 컬럼 - Recursive
* 해당 내용은 MySQL 8.0 버전부터 지원되는 Common Table Expression을 활용하는 재귀 쿼리를 사용하는 경우에 확인할 수 있다.
  * MySQL 서버의 경우, 재귀 쿼리는 WITH 구문을 사용하여 CTE를 활용하는 식으로 작성할 수 있다.
* 이 때, WITH 절 다음의 SELECT 등의 쿼리에서는 WITH 절에서 생성된 내부 임시 테이블을 활용하여 결과를 반환한다.
* 그러나 WITH 구문을 사용하는 CTE에서 항상 해당 내용을 확인할 수 있는 것은 아니며, WITH 구문이 재귀 CTE로 사용된 경우에만 해당 내용을 확인할 수 있다.

### Extra 컬럼 - Rematerialize
* MySQL 8.0 버전부터는 래터럴 조인 기능이 추가되었으며, 이 경우에 래터럴로 조인되는 테이블은 선행 테이블의 레코드 별로 서브쿼리를 실행한다.
  * 이 때, 서브쿼리를 실행하여 얻은 결과는 모두 임시 테이블에 저장되며 이러한 과정은 Rematerializing이라고 표현한다.
* 래터럴 조인을 통해 드라이빙 테이블의 매 레코드마다 임시 테이블을 새로 생성하여 조인하는 경우에 실행 계획의 Extra 컬럼에서 해당 내용을 확인할 수 있다.

### Extra 컬럼 - Select tables optimized away
* 해당 내용은 다음과 같은 최적화가 적용되는 경우에 확인할 수 있다.
  1. **MIN() 또는 MAX() 만 SELECT 절에 사용되는 쿼리가 인덱스를 오름차순 또는 내림차순으로 1건만 조회**하는 경우
  2. **GROUP BY로 MIN() 또는 MAX()를 사용하는 쿼리가 인덱스를 오름차순 도는 내림차순으로 1건만 조회**하는 경우
  3. MyISAM 테이블에서 GROUP BY 없이 COUNT(*)만 SELECT하는 경우
* 특히 MyISAM 테이블은 전체 레코드 수를 별도로 관리하므로 인덱스나 데이터를 조회하지 않고도 전체 레코드 수를 빠르게 조회할 수 있다.
  * 그러나 MyISAM 테이블에서 WHERE 절을 사용하는 쿼리는 이러한 최적화를 적용할 수 없다.

### Extra 컬럼 - Start temporary, End temporary
* 세미 조인 최적화 기법 중 Duplicate Weed-out 최적화 전략이 사용된 경우, 옵티마이저는 해당 내용을 표시한다.
  * 해당 최적화 전략은 불필요한 중복을 제거하기 위해 내부 임시 테이블을 사용한다.
  * 이 때, 조인되어 내부 임시 테이블에 저장될 테이블을 식별할 수 있도록 조인의 첫 테이블에 Start temporary 메시지가 표시된다.
  * 반면, 조인이 끝나는 부분에는 End temporary 문구를 표시한다.

### Extra 컬럼 - unique row not found
* 이는 **두 테이블이 각각 PK를 포함하는 유니크 컬럼으로 아우터 조인을 실행하는 쿼리에서, 아우터 테이블에 일치하는 레코드가 존재하지 않을 때 표시**된다.
  * 즉, 아우터 조인을 실행하는 쿼리의 드리븐 테이블에 해당하는 실행 계획에서 Extra 컬럼에 해당 내용이 표시된다. 

### Extra 컬럼 - Using filesort
```
> Using filesort 문구는 ORDER BY가 사용되는 쿼리의 실행 계획에서만 나타날 수 있다.
> 이 때, ORDER BY 처리가 적절한 인덱스가 없는 등의 이유에서 인덱스를 사용하지 못하는 경우 실행 계획의 Extra 컬럼에 해당 내용이 표시된다. 
> 실행 계획에서 Using filesort가 출력되는 쿼리는 많은 부하를 일으키므로, 가능한 한 쿼리를 튜닝하거나 인덱스를 생성하는 것이 바람직하다.
```
* **ORDER BY를 처리하기 위해 인덱스를 사용하는 것은 바람직**하지만, 쿼리가 적절한 인덱스를 사용하지 못하는 형태일 수도 있다.
  * 이 경우, **MySQL 서버는 조회된 레코드를 반드시 다시 정렬하기 위해 조회된 레코드를 정렬용 메모리 버퍼에 복사하여 퀵 소트 또는 힙 소트로 정렬**한다.
* ORDER BY 처리에 인덱스를 사용하는 것이 불가능한 경우, 옵티마이저는 다음과 같이 ORDER BY를 포함하는 쿼리를 처리한다.
  1. 대상 테이블로부터 레코드를 조회한다.
  2. 조회한 레코드를 정렬 버퍼에 복사한다.
  3. 정렬 버퍼로부터 레코드를 정렬하여 그 결과를 반환한다.
# Basics
## 2022-10-06 Thu

### 실행 계획이란?
* 대부분의 DBMS는 다음과 같은 주요한 목적을 갖고 설계된다.
  1. 많은 데이터를 안전하게 저장하고 관리한다.
  2. 사용자가 원하는 데이터를 빠르게 조회할 수 있도록 한다.
* 이를 위해서는 **옵티마이저가 사용자의 쿼리를 최적으로 처리할 수 있도록하는 쿼리 실행 계획을 수립할 수 있어야 한다**.
  * 그러나 옵티마이저는 외부 개입 없이 항상 최적의 실행 계획을 수립할 수 있는 것은 아니다.
  * 때문에 **DBMS 서버는 이를 DBA나 개발자가 보완할 수 있도록 옵티마이저가 수립한 실행 계획을 확인할 수 있도록 EXPLAIN 명령을 제공**한다.
* 이 때, MySQL 서버가 실행 계획에 가장 큰 영향을 주는 것은 통계 정보에 해당한다.

### 통계 정보란?
* DB가 수집하는 통계 정보는 크게 다음과 같이 분류된다.
  1. 테이블 및 인덱스에 대한 통계 정보: **테이블과 인덱스에 대한 개괄적인 정보를 의미하며, MySQL 5.7 버전까지는 해당 통계 정보에 의존**한다.
  2. 히스토그램 정보: **인덱스되지 않은 컬럼들에 대해서도 수집한 데이터 분포도를 저장한 것을 의미하며, 8.0 버전부터는 해당 정보도 함께 사용**한다.
* **5.7 버전까지는 테이블 컬럼의 값들이 실제로 어떻게 분포되어 있는지에 대한 정보를 수집하지 않으므로, 실행 계획의 정확도가 떨어지곤 했다**.
  * 이로 인해 8.0부터는 히스토그램 정보를 함께 수집한다.
* 이 때, **히스토그램이 도입되었다고 해서 8.0 버전 이후의 MySQL이 테이블 또는 인덱스의 통계 정보를 사용하지 않는 것은 아니다**.

### 테이블과 인덱스의 통계 정보
* **통계 정보가 잘못된 경우 전혀 엉뚱한 쿼리 실행 계획을 수립할 수 있으므로, 비용 기반 최적화에서 가장 중요한 것은 통계 정보**이다.
* **MySQL 역시 다른 DBMS와 마찬가지로 비용 기반의 최적화를 사용하지만, 다른 DBMS 보다 통계 정보의 휘발성이 높고 정확도는 떨어지는 단점이 존재**했다.
  * 때문에 MySQL은 쿼리 실행 계획을 수립하는 경우, 실제 테이블의 데이터를 일부분 분석하여 통계 정보를 보완하는 식으로 동작했다.
  * MySQL 5.6 버전 이후부터는 통계 정보의 정확성을 높일 수 있는 여러 방법이 도입되기 시작했으나, 여러 사용자는 이를 간과하고 기존 방식을 사용하곤 한다.

## 2022-10-07 Fri
### MySQL 서버의 통계 정보 저장
* **MySQL 5.6 버전부터는 InnoDB 스토리지 엔진을 사용하는 테이블에 대한 통계 정보를 영구적으로 저장하여 관리**할 수 있다.
  * 반면, 5.5 버전까지는 각 테이블의 통계 정보를 메모리에서만 관리할 수 있었다.
  * 이렇듯 **메모리에 관리되는 통계 정보는 당연하게도 MySQL 서버가 재시작되는 경우에 모두 휘발될 수 밖에 없다**.
  * 때문에 재시작된 MySQL 서버는 반드시 모든 테이블의 통계 정보를 다시 수집해야 할 필요가 있었다.
* 그러나 **5.6 버전부터는 각 테이블의 통계 정보를 다음과 같은 mysql DB 테이블에 관리할 수 있도록 개선되어 서버의 재시작에도 통계 정보를 잃지 않는다**.
  1. `innodb_index_stats`
  2. `innodb_table_stats`
* **5.6 버전부터는 테이블 생성시 `STATS_PERSISTENT` 옵션을 설정할 수 있으며, 해당 값에 따라 테이블 단위로 영구적인 통계 정보를 저장**할 수 있다.
  1. STATS_PERSISTENT=0: 테이블의 통계 정보를 MySQL 5.5 이전 방식대로 관리하며, 상술한 두 테이블을 사용하지 않는다.
  2. STATS_PERSISTENT=1: 테이블의 통계 정보를 상술한 두 테이블에 저장한다.
  3. STATS_PERSISTENT=DEFAULT: 이는 별도로 옵션을 설정하지 않은 것과 동일하며, `innodb_statas_persistent` 시스템 변수의 값에 따른다.
* 이 때, **`innodb_statas_persistent` 시스템 변수는 기본적으로 ON으로 설정되므로 상술한 옵션을 사용하지 않은 경우 영구적인 통계 정보를 저장**한다.
* 또한, **영구적으로 테이블의 통계 정보를 저장하지 않는 경우에도 ALTER TABLE 명령을 통해 언제든지 통계 정보의 저장 설정을 자유로이 변경**할 수 있다.

### 자동 통계 정보 갱신
* MySQL 5.5 버전까지는 테이블의 통계 정보가 메모리에 저장되었으며, 서버 재시작 시 통계 정보는 초기화되었다.
  * 이 경우, 모든 테이블의 통계 정보는 다시 수집되어야 한다.
* 또한 사용자가 인지하지 못하는 순간에도 다음과 같은 이벤트가 발생할 경우 자동으로 통계 정보를 갱신한다.
  1. 테이블이 새로 오픈되는 경우
  2. 테이블의 전체 레코드 중 1/16 이상의 레코드가 대량으로 변경되는 경우
  3. ANALYZE TABLE 명령이 실행된 경우
  4. SHOW TABLE STATUS 또는 SHOW INDEX FROM 명령이 실행된 경우
  5. InnoDB 모니터가 활성화된 경우
  6. `innodb_stats_on_metadata` 설정이 ON인 상태에서 SHOW TABLE STATUS 명령이 실행되는 경우
* 이렇듯 **통계 정보가 자주 갱신되는 경우, 쿼리를 인덱스 레인지 스캔으로 잘 처리하던 MySQL 서버가 어느 순간부터는 풀 테이블 스캔을 적용**할 수도 있다.
* 그러나 이러한 **의도치 않은 통계 정보의 변경은 영구적인 통계 정보의 도입으로 미연에 방지할 수 있게 되었다**.
  * 예를 들어, `innodb_stats_auto_recalc` 시스템 설정의 값을 OFF로 설정하여 통계 정보의 자동 갱신을 막을 수도 있다.
  * **해당 시스템 설정의 기본 값은 ON이므로, 영구적인 통계 정보를 사용하는 경우에는 해당 설정을 OFF로 변경하는 것이 바람직**하다.
* 이 때, 통계 정보를 자동으로 수집할 지의 여부 역시 테이블 생성시 `STATUS_AUTO_RECALC` 옵션을 통해 테이블 단위로 명시할 수 있다.
  1. STATUS_AUTO_RECALC=1: 5.5 버전 이전의 방식대로 자동으로 수집한다.
  2. STATUS_AUTO_RECALC=0: ANALYZE TABLE 명령이 실행되었을 때만 수집한다.
  3. STATUS_AUTO_RECALC=DEFAULT: `innodb_stats_auto_recalc` 시스템 설정 변수의 값에 따라 테이블의 통계 정보 수집 여부를 결정한다.

### 테이블 블록 샘플링 옵션
* MySQL 5.5 버전에서는 테이블의 통계 정보를 수집하는 경우, 몇 개의 InnoDB 테이블 블록을 샘플링할지 결정할 수 있었다.
  * **이러한 기능을 수행하는 옵션은 `innodb_stats_sample_pages` 시스템 설정 변수였으나, 5.6 버전부터는 해당 옵션이 제거**되었다.
* 5.6 버전 이후로부터는 대신 다음과 같은 시스템 변수가 제공된다.
  1. `innodb_stats_transient_sample_pages`: 기본 값은 8이며, 자동 통계 정보 수집 시 8개 페이지만 샘플링하여 분석된 결과를 통계 정보로 활용한다. 
  2. `innodb_stats_persistent_sample_pages`: 기본 값은 20이며, ANALYZE TABLE 실행 시 이를 샘플링 및 분석하여 통계 정보 테이블에 저장한다.

### 더 정확한 통계 정보 수집하기
* **영구적인 통계 정보를 사용하는 경우 MySQL 서버의 점검 또는 사용량이 적은 시간에 더 정확한 통계 정보를 수집하도록 유도**할 수 있다.
  * 이 때, 더 정확한 통계 정보의 수집에는 당연히 더욱 많은 시간이 소모된다.
  * 그러나 **이로 인한 통계 정보의 정확성으로 쿼리의 성능이 향상되므로 시간을 투자할 가치는 충분**하다.
* 이렇듯 **더 정확한 통계 정보를 수집하고자 하는 경우, `innodb_stats_persistent_sample_pages` 시스템 변수에 큰 값을 설정**할 수 있다.
  * 이 역시 **값을 너무 큰 값으로 설정할 경우 통계 정보 수집에 그만큼 더 많은 시간을 허비하게 되므로 충분히 주의를 기울이는 것이 바람직**하다.
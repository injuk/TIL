# Basics
## 2022-09-24 Sat

### 옵티마이저란?
```
> 어떠한 DBMS든지 쿼리의 실행 계획을 수립하고 결정하는 옵티마이저는 가장 복잡한 부분이며, 결과로 생성되는 실행 계획 역시 이해하기 상당히 어려운 축에 속한다.
```
* MySQL 서버로 요청되는 쿼리는 결과가 동일하지만, 내부적으로 결과를 만들어내는 작업은 매우 다양하다.
  * 이 때, 이러한 **다양한 방법 중 어떠한 방법이 최적이며 최소의 비용을 소모하는지 결정할 수 있어야 한다**.
* **대부분의 DBMS는 여러 기본 데이터를 비교하여 최적의 실행 계획을 수립하는 작업을 수행하며, 이러한 기능을 담당하는 것이 옵티마이저**가 된다.
  * 기본 데이터의 예로, MySQL은 쿼리를 최적으로 실행하기 위해 각 테이블의 데이터가 어떻게 분포되어 저장되어 있는지에 대한 통계 정보를 사용한다.

### 쿼리의 실행 절차
* MySQL 서버에서 쿼리가 실행되기까지의 과정은 크게 다음과 같이 분류된다.
  1. 요청된 **SQL 문장을 필요한만큼 쪼개어 MySQL 서버가 이해할 수 있는 수준으로 분리하고, 결과로 파스 트리를 생성**한다.
  2. **파스 트리를 확인하며 어떠한 테이블로부터 어떠한 인덱스를 활용하여 읽어들인지 선택**한다.
  3. 2.의 과정에서 **결정된 테이블의 읽기 순서 또는 선택된 인덱스를 활용하여 스토리지 엔진으로부터 데이터를 가져온다**. 
* 첫 단계는 **SQL 파싱이라고도 지칭하며, MySQL 서버는 SQL 파서라는 이름의 모듈로 SQL 파스 트리를 생성**한다.
  * 이 과정에서 **SQL 문장의 문법 오류가 검증되며, 이후 MySQL 서버는 원본 SQL 문이 아닌 SQL 파스 트리를 활용하여 쿼리를 실행**한다.
* 두 번째 단계는 **최적화 및 실행 계획 수립 단계라고도 지칭하며, 파싱 단계에서 생성된 파스 트리를 참조하며 다음과 같은 내용을 처리**한다.
  1. 불필요한 조건 제거 및 복잡한 연산을 단순화
  2. 여러 테이블이 조인되는 경우, 어떠한 순서로 테이블을 읽어들일지 결정
  3. 각각의 테이블에 사용된 조건과 인덱스 통계 정보를 활용하여 사용할 인덱스를 결정
  4. 가져온 레코드들을 임시 테이블에 삽입한 후 다시 한 번 가공해야할지 여부를 결정
  5. 이외의 수많은 처리들
* 이 때 **두 번째 단계는 MySQL 서버의 옵티마이저에서 처리되며, 완료시 그 결과로 실행 계획이 만들어지게 된다**. 
* 세 번째 단계에서는 **옵티마이저에 의해 수립된 실행 계획을 토대로 스토리지 엔진으로부터 레코드 조회를 요청**한다.
  * **MySQL 엔진에서는 스토리지 엔진으로부터 전달 받은 레코드를 조인하거나 정렬하는 작업을 수행**한다.
* 이 때, **파싱과 최적화 및 실행 계획 수립 단계는 대부분 MySQL 엔진에서 처리되는 반면 세 번째 단계는 MySQL 엔진과 스토리지 엔진이 함께 처리**한다.

## 2022-09-25 Sun
### 옵티마이저의 종류
```
> 옵티마이저는 DB 서버에서는 두뇌와 같은 역할을 담당하며, 비용 기반 최적화 방식과 규칙 기반 최적화 방식으로 분류된다.
> 현재의 RDBMS는 대부분 비용 기반 최적화 방식의 옵티마이저를 채택한다.
```
* 규칙 기반 최적화 방식은 대상 테이블의 레코드 건수 또는 선택도 등의 통계 정보를 고려하지 않고, 옵티마이저에 내장된 우선 순위에 따라 실행 계획을 수립한다.
* 반면, **비용 기반 최적화 방식은 쿼리를 처리할 수 있는 여러 방법을 생성한 후 각 단위 작업의 비용과 통계 정보를 활용하여 계획 별 비용을 산출**한다.
  * 이렇게 산출된 실행 계획 별로 비용이 최소로 소모될 것으로 판단되는 처리 방식을 선택하여 최종적으로 쿼리를 실행하게 된다.

### 풀 테이블 스캔
* **MySQL 서버 등의 RDBMS는 모두 데이터를 정렬하거나 그룹화하는 기본 데이터 가공 기능을 내장**한다.
  * 그러나 결과는 동일할지언정 RDBMS 별로 결과를 생성하는 과정은 크게 달라질 수 있다.
* **풀 테이블 스캔의 경우, 인덱스를 사용하지 않고 테이블의 데이터를 처음부터 끝까지 읽어 요청된 작업을 처리**한다.
* MySQL 옵티마이저는 다음과 같은 상황에서 주로 풀 테이블 스캔 방식을 선택한다.
  1. 예를 들어 **테이블이 페이지 1개로 구성되는 등, 테이블 레코드 수가 너무 적어 인덱스를 활용한 조회보다 풀 테이블 스캔을 진행하는 편이 더 빠른 경우**
  2. WHERE 절 또는 ON 절에 인덱스를 활용할만한 적절한 조건이 명시되지 않은 경우
  3. 인덱스 레인지 스캔을 사용할 수 있는 쿼리이나, 통계 정보를 기반으로 옵티마이저가 판단한 조건 일치 레코드 수가 너무 많은 경우

### 리드 어헤드 작업
* 일반적으로, 테이블의 전체 크기는 인덱스보다 훨씬 크기에 풀 테이블 스캔 방식은 큰 랜덤 디스크 IO를 필요로 한다.
  * 때문에 **대부분의 DBMS는 풀 테이블 스캔을 지원하기 위해 한 번에 여러 블록 또는 페이지를 조회하는 기능을 내장**한다.
* **InnoDB 스토리지 엔진은 테이블의 연속된 데이터 페이지가 조회되는 경우, 백그라운드 스레드에 의헤 리드 어헤드 작업이 자동 시작**된다.
* **리드 어헤드 작업이란, 어떤 영역의 데이터가 필요할 것으로 보여지는 경우 실제 요청이 오기 전에 미리 디스크로부터 읽어 버퍼 풀에 적재하는 것을 의미**한다.
  * 때문에 **풀 테이블 스캔이 실행되는 경우, 처음 몇 페이지는 클라이언트 스레드가 조회하지만 임의의 시점부터는 백그라운드 스레드에게 읽기 작업을 위임**한다.
  * 백그라운드 스레드가 읽기 작업을 위임받은 시점부터는 점차 한 번에 읽어들이는 페이지 수를 증가시키므로, 쿼리는 상당히 빠르게 처리될 수 있다.
* MySQL 서버에서는 `innodb_read_ahead_threshold` 시스템 변수를 통해 InnoDB가 어느 시점에 리드 어헤드 작업을 시작할지 임계치를 결정할 수 있다.
  * 예를 들어 클라이언트 스레드로부터 해당 변수에 설정된 만큼 연속된 데이터 페이지가 읽혀진 경우, InnoDB 엔진은 백그라운드 스레드를 활용한다.
  * 백그라운드 스레드는 점차 많은 페이지를 한 번에 읽어들여 버퍼 풀에 적재하므로, 클라이언트 스레드를 버퍼 풀로부터 필요한 정보를 가져가기만 하면 된다.
  * 해당 시스템 변수는 일반적으로 기본값을 사용해도 무방하지만, MySQL 서버가 DW 용도로 사용되는 경우 더 낮은 값으로 설정하는 것을 고려할 수 있다.

### 풀 인덱스 스캔
```
> 풀 테이블 스캔이 테이블의 처음부터 끝까지 탐색하는 것처럼, 풀 인덱스 스캔은 인덱스를 처음부터 끝까지 스캔한다.
```
* **리드 어헤드 작업은 풀 테이블 스캔 뿐만 아니라 풀 인덱스 스캔에서도 동일하게 사용**된다.
* 일반적으로 **인덱스는 테이블의 2 ~ 3개 컬럼만으로 구성되므로, 전체 테이블 자체보다 용량이 작어 훨씬 빠른 처리가 가능**하다.
  * 때문에 **MySQL 서버는 랜덤 디스크 IO를 최대한 줄이기 위해 되도록 더 작은 용량을 갖는 인덱스를 선택**한다.
* 예를 들어 다음과 같은 두 쿼리의 경우, 각자 다른 이유에서 풀 테이블 스캔 또는 풀 인덱스 스캔이 적용된다.
  1. `SELECT COUNT(*) FROM table_name`: 단순히 레코드의 건수만을 필요로 하는 쿼리이므로, 용량이 작은 인덱스로도 처리가 가능하다. 
  2. `SELECT * FROM table_name`: **모든 컬럼을 조회하므로, 인덱스에 존재하지 않는 레코드 컬럼을 조회하기 위해 풀 테이블 스캔이 적용**된다.

### 쿼리의 병렬 처리
* MySQL 8.0 버전부터는 하나의 쿼리를 여러 스레드가 나누어 동시에 작업을 처리하는 병렬 처리가 한정적으로나마 가능하다.
  * 예를 들어 `innodb_parallel_read_threads` 시스템 변수는 단일 쿼리를 최대 몇 개의 스레드로 처리할지 변경하기 위해 사용된다.
* MySQL 서버에서는 아직까지 쿼리를 여러 스레드로 병렬 처리하도록 하는 힌트나 옵션은 존재하지 않는다.
  * 대신 **아무런 WHERE 절 없이 단순히 테이블의 전체 건수만을 가져오는 쿼리만 병렬 처리가 가능**하다.
* 병렬 처리용 스레드 개수가 늘어날수록 쿼리 처리 시간이 줄어드는 반면, 서버의 CPU 코어 개수를 넘어서는 스레드 개수는 오히려 성능이 떨어질 수도 있다.

### Using filesort
```
> MySQL 서버에서 인덱스를 활용하지 않고 별도로 정렬 처리를 수행했는지 여부는 실행 계획에서 확인할 수 있다.
> 예를 들어, 실행 계획의 Extra 컬럼에 Using filesort 메시지가 표시되는 경우 인덱스 정렬이 아닌 별도의 정렬 처리를 수행한 것이 된다.
```
* **레코드를 1 ~ 2건 조회하는 쿼리를 제외하는 경우, 대부분의 SELECT 쿼리에서 정렬은 필수적**이다.
  * DW처럼 대량의 데이터를 활용한 일괄 처리 기능이 아닌 경우, 일반적으로 레코드 정렬 조건은 대부분의 조회 쿼리에 포함된다. 
* 이 때, 정렬을 처리하는 방식은 크게 다음과 같은 두 가지 방식으로 나누어 생각할 수 있다.
  1. 인덱스를 이용하기: DML 실행 시 이미 인덱스가 정렬되어 있으므로, 빠른 반환이 가능하다.
  2. filesort 처리 이용하기: 정렬 대상 레코드가 많지 않은 경우, 메모리에서 filesort가 처리되므로 충분히 빠를 수 있다.
* 반면, 인덱스를 활용하는 경우 다음과 같은 단점이 존재한다.
  1. DML을 위한 부가적인 인덱스 추가 및 제거 작업이 필요하므로, 상대적으로 느리다.
  2. 인덱스로 인해 디스크 공간을 더 많이 사용하게 된다.
  3. 인덱스의 개수가 늘어날수록 InnoDB 버퍼 풀에 사용되는 메모리가 더 많이 필요하다.
* 또한, filesort 방식은 인덱스를 활용하는 경우의 단점을 장점으로 치환하지만 다음과 같은 단점이 존재한다.
  1. **정렬 작업이 쿼리 실행 시점에 처리되므로, 레코드 대상 건수가 많아질수록 응답 속도는 느려질 수 밖에 없다**.
* 이렇듯 **레코드를 정렬하기 위해 반드시 filesort를 사용해야하는 것은 아니며, 오히려 인덱스를 이용한 정렬을 활용**할 수도 있다.
* 그러나 다음과 같은 경우에는 인덱스만을 활용하는 정렬이 불가능할 수 있다.
  1. 정렬 기준이 너무 많아서 조건 별로 인덱스를 활용하는 것이 불가능한 경우
  2. **GROUP BY 또는 DISTINCT 처리 결과를 정렬해야 하는 경우**
  3. **UNION 결과와 같이 임시 테이블의 결과를 다시 정렬해야 하는 경우**
  4. 랜덤한 결과 레코드를 조회해야하는 경우

## 2022-09-26 Mon
### 소트 버퍼
```
> 소트 버퍼로 정렬하는 대상 레코드가 충분히 적은 경우, 메모리에서 쿼리 처리가 가능하므로 빠른 정렬이 가능하다.
> 그러나 정렬 대상 레코드 건수가 소트 버퍼의 크기보다 큰 경우, 결과를 임시 저장하기 위해 디스크를 사용하게 된다.
```
* **MySQL은 정렬을 위해 소트 버퍼라는 별도의 메모리 공간을 할당받아 사용하며, 쿼리의 실행이 완료되면 즉시 해당 메모리 공간을 반환**한다.
  * **소트 버퍼는 정렬이 필요한 경우에만 할당되며, 버퍼의 크기는 정렬해야 할 레코드의 크기에 따라 가변적으로 증가**한다.
  * 단, 소트 버퍼의 상한은 `sort_buffer_size` 시스템 변수에 의해 설정된다.
  * 여기까지, 상술한 내용은 **정렬 대상 레코드가 매우 소량인 경우 메모리에 할당된 소트 버퍼만으로 정렬이 가능하여 매우 빠르게 처리**된다.
* **소트 버퍼를 활용한 정렬이 문제가 되는 경우는 정렬 대상 레코드 건수가 소트 버퍼로 할당된 메모리 공간보다 큰 경우에 발생**한다.
  * **MySQL은 정렬 대상 레코드를 여러 조각으로 나눠 처리하며, 이 과정에서 대상 레코드 건수가 너무 많다면 임시 저장을 위해 디스크를 사용**한다. 

### 디스크를 활용하는 소트 버퍼
* **레코드 건수가 충분히 많아 정렬을 위해 디스크를 사용하는 경우, 우선 메모리 상의 소트 버퍼로부터 정렬한 후 그 결과를 임시 디스크에 저장**한다.
  * 이러한 과정은 다음 레코드를 가져와 정렬한 후, 반복적으로 디스크에 저장하는 식으로 진행된다.
* 이렇게 **버퍼 크기만큼 정렬된 레코드는 다시 병합하며 정렬이 수행되는 멀티 머지 작업이 반드시 수행**되어야 한다.
* **멀티 머지 과정은 모두 디스크 IO를 유발하며, 레코드 건수가 많아질수록 반복 작업의 횟수 역시 많아진다**.

### 적절한 소트 버퍼의 크기
* 단순히 소트 버퍼의 크기 상한을 높인다고 해도 처리 성능은 크게 빨라질 수 있으며, 오히려 악영향을 미칠 가능성이 존재한다.
  * 리눅스 기반 OS의 경우, 소트 버퍼의 크기를 너무 크게 적용하는 경우 불필요한 메모리 공간 할당으로 인해 성능이 더 떨어질 수도 있다.
* **일반적인 트랜잭션 처리용 MySQL 서버의 소트 버퍼 크기는 56KB ~ 1MB 정도가 적절**하다.
  * **MySQL 서버의 메모리는 글로벌 영역과 세션 영역으로 나뉘며, 이 중 정렬을 위한 소트 버퍼는 세션 메모리 영역**에 속한다.
  * 이는 **커넥션이 많아지거나 정렬 작업이 많아질수록 각 세션에서 소트 버퍼로 소비하는 메모리 공간이 커짐을 의미**한다.
  * 이 경우 최악의 상황에는 OS가 메모리 부족 현상을 겪을 수 있으며, OS의 OOM-Killer는 여유 메모리를 확보하기 위해 프로세스를 강제 종료한다.
  * **OOM-Killer는 일반적으로 메모리를 가장 많이 사용하는 프로세스를 강제 종료하며, 강제 종료 1순위는 일반적으로 MySQL 서버가 될 가능성**이 높다.
* **대량 데이터의 정렬이 필요한 경우, 해당 쿼리를 실행하는 세션의 소트 버퍼만 일시적으로 증가시킨 후 다시 줄이는 것도 좋은 방법에 해당**한다.

### 정렬 모드의 종류
* 레코드를 정렬하기 위해 어떤 내용을 소트 버퍼에 담을지는 크게 다음과 같이 분류될 수 있다.
  1. **싱글 패스 정렬 모드: 레코드 전체를 소트 버퍼에 담기**
  2. **투 패스 정렬 모드: 또는 정렬 기준이 되는 컬럼만 소트 버퍼에 담기**
* 정렬이 필요한 쿼리가 어떤 정렬 모드를 사용하는지는 옵티마이저 트레이스 기능을 통해 확인할 수 있으며, MySQL 서버의 정렬 방식은 크게 다음과 같이 분류된다.
  1. 투 패스: 정렬 키와 레코드의 ROW ID만을 가져와서 정렬하기
  2. 싱글 패스: 정렬 키와 레코드 전체를 가져와서 정렬하되, 레코드의 컬럼들은 고정 사이즈로 메모리에 저장하기
  3. 싱글 패스: 정렬 키와 레코드 전체를 가져와서 정렬하되, 레코드의 컬럼들은 가변 사이즈로 메모리에 저장하기
* 이 중 세 번째 방식은 MySQL 5.7 버전부터 도입되었으며, 정렬을 위한 메모리 공간을 효율적으로 사용하기 위해 추가된 기능에 해당한다.

### 싱글 패스 정렬 방식
```
> 싱글 패스 정렬 방식이란, 소트 버퍼에 정렬 기준 컬럼을 포함하여 SELECT 절의 대상 컬럼을 모두 포함하여 정렬을 수행하는 방식이다.
```
* 예를 들어 다음과 같은 쿼리가 있는 경우, **정렬 기준이 되는 컬럼 뿐만 아니라 SELECT 절의 모든 컬럼을 조회하여 소트 버퍼에 담아 정렬**한다.
  * 즉, 아래의 쿼리는 정렬 기준인 `first_name` 뿐만 아니라 `emp_no`, `last_name`을 함께 조회하여 소트 버퍼를 통해 정렬한다.
  * 또한, 정렬이 완료되면 정렬 버퍼의 내용을 그대로 클라이언트에게 반환한다.
```
SELECT emp_no, first_name, last_name
  FROM employees
  ORDER BY first_name;
```

### 투 패스 정렬 방식
```
> 투 패스 정렬 방식은 우선 정렬 대상 컬럼과 PK 값만 소트 버퍼에 담아 정렬한다.
> 정렬이 완료된 경우, 정렬된 순서대로 PK를 통해 SELECT 대상 컬럼을 조회한다.
```
* 상술한 쿼리를 처리하는 과정에서 투 패스 정렬 방식으로 정렬하는 경우, 정렬 과정은 다음과 같이 진행된다.
  1. 정렬 대상 컬럼인 `first_name`과 PK인 `emp_no` 컬럼만 조회하여 소트 버퍼로부터 정렬한다.
  2. **멀티 머지를 활용한 정렬이 완료된 후, 정렬 결과의 PK 컬럼을 토대로 `last_name`을 추가로 조회**한다. 
  3. 쿼리 결과를 반환한다.
* **투 패스 방식은 MySQL의 이전 버전에서 사용되던 정렬 방식으로, 테이블을 두 번 조회해야만 하는 단점이 존재**한다.
  * 그러나 **두 정렬 방식은 각각의 장단점이 존재하므로, MySQL 8.0에서도 특정한 조건에서는 투 패스 정렬 방식을 사용**한다.

### 싱글 패스 정렬과 투 패스 정렬 방식의 차이
* 싱글 패스 정렬 방식은 더 많은 소트 버퍼 공간을 필요로 한다.
  * 투 패스 정렬 방식은 필요한 컬럼만 사용하여 정렬하므로, 더 적은 소트 버퍼 공간을 사용한다.
* 싱글 패스 정렬 방식은 테이블을 두 번 조회해야 하는 불합리함이 존재하지 않는다.
  * 투 패스 정렬 방식은 정렬을 완료한 후 테이블로부터 필요한 컬럼을 추가로 조회해야 하는 단점이 존재한다.
* **싱글 패스 방식은 정렬 대상 레코드의 크기 또는 개수가 적은 경우 상대적으로 빠른 성능**을 보인다.
  * **투 패스 방식은 정렬 대상 레코드의 크기 또는 개수가 큰 경우 효율적인 사용이 가능**하다.
* 이러한 차이에서, **최신 버전에서는 일반적으로 싱글 패스 정렬 방식을 주로 사용하되 다음의 경우에는 투 패스 정렬 방식을 적용**한다.
  1. 레코드의 크기가 `max_length_for_sort_data` 시스템 변수의 값보다 큰 경우
  2. 또는 BLOB, TEXT 타입의 컬럼이 SELECT 절 대상에 포함되는 경우

### SELECT * 의 단점
* **SELECT 쿼리에서 `*` 키워드로 모든 컬럼을 조회하는 것은 정렬 버퍼를 적게는 수 배에서 크게는 수십 배까지 비효율적으로 사용할 가능성**이 높다.
  * 때문에 SELECT 절에서는 반드시 필요한 컬럼만 조회하도록 쿼리를 작성하는 것이 바람직하다.
  * 특히 **정렬이 필요한 경우에는 불필요한 컬럼을 SELECT 하지 않도록 작성하는 식으로 적용하는 것이 필수적**이다.

## 2022-09-27 Tue
### 정렬 처리 방법
* 쿼리에 **ORDER BY 절이 포함된 경우, 반드시 다음 세 방법중 하나로 정렬이 처리되며 일반적으로 아래에 있는 방법일수록 처리 속도가 떨어진다**.
  1. 인덱스를 사용한 정렬: Extra 컬럼에 별도로 표기되는 내용이 없다.
  2. **조인 시 드라이빙 테이블만을 정렬: Extra 컬럼에 `Using filesort` 메시지가 표시**된다.
  3. **조인 시 조인 결과를 임시 테이블로 저장한 후에 정렬: Extra 컬럼에 `Using temporary; Using filesort` 메시지가 표시**된다.
* **우선 옵티마이저는 정렬을 위해 인덱스를 사용할 수 있는지 검토하며, 가능한 경우 별도의 정렬 없이 인덱스를 순서대로 읽어 결과를 반환**한다.
* **반면 인덱스를 사용할 수 없는 경우, WHERE 절의 조건에 일치하는 레코드를 검색하여 정렬 버퍼에 저장하며 정렬을 처리**한다.
* 이 때, 옵티마이저는 정렬 대상 레코드를 최소화하기 위해 다음의 방법 중 하나를 선택한다.
  1. 정렬 후 조인: 조인의 드라이빙 테이블만 **정렬한 후에 조인을 처리**하기
  2. 조인 후 정렬: 또는 조인이 완료된 후에 일치하는 **레코드를 모두 가져온 후에 정렬을 수행**하기
* **일반적으로 조인이 수행되면 레코드의 개수 및 크기는 사실상 배로 증가하므로, 가능하다면 1.과 같이 드라이빙 테이블을 정렬한 후 조인하는 것이 바람직**하다.
  * 즉, **정렬 후 조인을 처리하는 방식이 조인 후 정렬을 처리하는 방식보다 효율적**이다.

### 인덱스를 활용하는 정렬
```
> B-Tree 인덱스는 키 값을 기반으로 이미 정렬되어 있으므로, 조건을 충족하는 경우 정렬은 인덱스를 통해 처리될 수 있다.
```
* 인덱스를 통해 정렬하기 위해서는 반드시 다음과 같은 조건을 만족해야 한다.
  1. **ORDER BY 절에 명시된 컬럼이 드라이빙 테이블에 속해야 한다**.
  2. **ORDER BY에 맞는 순서대로 생성된 인덱스가 존재해야 한다**.
  3. **WHERE 절에 드라이빙 테이블의 컬럼에 대한 조건이 존재하는 경우, 해당 조건과 ORDER BY는 같은 인덱스를 사용할 수 있어야 한다**.
  4. 여러 테이블이 조인되는 경우, Nested loop 방식의 조인에서만 해당 정렬 방식을 적용할 수 있다.
* **인덱스를 활용하여 정렬이 처리되는 경우, 실제 인덱스긔 값은 정렬되어 있으므로 인덱스 순서대로 읽기만 하면 된다**.
  * 이 경우, MySQL 엔진은 굳이 별도의 정렬을 위한 추가 작업을 수행하지 않는다.
* 인덱스를 활용하여 정렬을 처리하는 경우, ORDER BY 절을 명시하지 않더라도 자동으로 정렬된다.
  * 그러나 **MySQL 서버는 인덱스로 정렬을 처리하는 경우에는 불필요한 정렬 작업을 추가로 수행하지 않으므로, ORDER BY 절을 명시하더라도 작업량은 같다**.
  * 반면, 외부 요인으로 인해 실행 계획이 변경되는 경우 ORDER BY가 누락된 쿼리는 의도한대로 동작하지 않을 가능성이 존재한다.
  * 때문에 **인덱스로 정렬을 처리하는 경우에도 ORDER BY를 명시하는 것이 바람직**하다.

### JOIN과 정렬
* 조인을 사용하는 경우, 네스티드 루프 방식을 활용하는 조인은 조인으로 인해 드라이빙 테이블의 인덱스 읽기 순서가 흐트러질 일이 없다.
  * 반면, 조인이 사용되는 쿼리의 실행 계획에 조인 버퍼가 사용되는 경우에는 읽기 순서가 뒤바뀔 수 있으므로 주의를 기울여야 한다.

### 조인 시 드라이빙 테이블만 정렬
* 일반적으로 조인을 수행하는 경우 결과 레코드는 그 수와 레코드 별 크기가 급증하게 된다.
  * 때문에 **조인을 적용하기 전에 우선 첫 번째 테이블의 레코드를 정렬한 후 조인을 실행하는 것이 정렬에 있어서는 차악**이 된다.
* **해당 방식을 통해 정렬을 처리하기 위해서는 반드시 드라이빙 테이블의 컬럼만으로 ORDER BY 절이 작성되어야 한다**.
* 드라이빙 테이블만 정렬하는 방식은 다음과 같이 진행된다.
  1. 우선 검색 조건을 만족하는 레코드를 검색한다.
  2. 1.의 과정에서 **조회된 검색 결과를 ORDER BY 절에 명시된 컬럼을 토대로 소트 버퍼에서 정렬**한다.
  3. 2.의 과정에서 **정렬된 결과를 소트 버퍼로부터 순서대로 조회하며 드리븐 테이블과 조인하여 최종 결과를 반환**한다.

### 임시 테이블을 활용하는 정렬
* 조인하지 않고 단일 테이블로부터 SELECT하는 쿼리는 굳이 임시 테이블을 사용할 필요가 없다.
  * 그러나 **둘 이상의 테이블을 조인하여 결과를 정렬하는 경우, 임시 테이블을 사용해야만 하는 경우가 발생할 수도 있다**.
* **조인 시 드라이빙 테이블만 정렬하는 방식은 둘 이상의 테이블이 조인되며 정렬을 적용하지만, 소트 버퍼에서 정렬하므로 임시 테이블을 사용하지는 않는다**.
  * 그러나 **그 외의 경우에는 항상 조인의 결과를 임시 테이블에 저장하고, 그 결과를 다시 정렬**해야 한다.
  * 즉, **상술한 두 방법과 비교하여 가장 정렬 대상 레코드 개수가 많기 때문에 가장 느린 방식의 정렬에 해당**한다.
* 만약 **드라이빙 테이블의 컬럼만으로 정렬이 불가능하고, ORDER BY 절에 명시된 컬럼이 드리븐 테이블의 컬럼인 경우 정렬이 수행되기 전에 조인되어야 한다**.
  * 즉, 정렬 전에 드리븐 테이블을 조회하여 조인하므로 조인된 데이터를 정렬하게 되어 가장 느린 정렬 처리 속도를 갖게 된다.
* **실행 계획의 Extra 컬럼에 표시되는 `Using temporary; Using filesort`는 조인 결과를 임시 테이블에 저장하고, 이를 다시 정렬했음을 의미**한다.

### 정렬 처리 방법 - 결론
* 쿼리에 ORDER BY 절이 명시되면 반드시 다음과 같은 방법으로 정렬이 처리된다.
  1. -: 인덱스를 사용한 정렬로, 실행 계획의 Extra 컬럼에 별도로 메시지가 표기되지 않는다.
  2. Using filesort: 조인 시 드라이빙 테이블만 정렬한다.
  3. Using temporary; Using filesort: 조인 시 조인된 결과를 임시 테이블에 저장한 후에 정렬한다.
* **인덱스를 활용할 수 있는 경우, 인덱스 키 값은 이미 정렬되어 있으므로 별도의 정렬이 필요 없다**.
  * 이 경우에는 ORDER BY 절에 명시된 컬럼이 존재하지 않거나, PK와 관련이 있다.
* **조인을 실행하지 않고 정렬이 불가능한 경우, 조인을 실행하기 전에 드라이빙 테이블만 정렬한 후에 조인하는 것이 차선책**이다.
  * 이 경우에는 ORDER BY 절에 명시된 컬럼이 드라이빙 테이블에 존재하는 경우에 해당한다.
* **모든 방법이 불가능한 경우, 테이블을 조인한 결과를 임시 테이블에 저장하여 정렬하는 방식을 사용하며 이는 가장 느린 정렬 처리 방식에 해당**한다.
  * 이 경우에는 ORDER BY 절에 명시된 컬럼이 드리븐 테이블에 존재하는 경우에 해당한다.

## 2022-09-28 Wed
### LIMIT이 적용된 ORDER BY와 GROUP BY
* 일반적으로 **LIMIT 절은 ORDER BY 절과 함께 사용되는 경향이 있으며, 이는 테이블의 처리 결과 중 일부만 가져오므로 MySQL 서버의 작업량을 줄여준다**.
  * **그러나 ORDER BY 또는 GROUP BY 절은 WHERE 절의 조건을 만족하는 레코드를 LIMIT 절에 명시된 만큼만 가져와서 처리할 수는 없다**.
  * 때문에 **조건을 만족하는 레코드를 일단 모두 가져온 후에 정렬 또는 그룹화를 적용하고나서야 LIMIT 절을 활용한 개수 제한이 가능**해진다.
* 이렇듯 **WHERE 절이 아무리 인덱스를 잘 활용하도록 튜닝되었더라도 잘못 된 ORDER BY 또는 GROUP BY 절로 인해 쿼리는 느려지기 쉽다**.
* **쿼리 처리 방식은 다시 스트리밍 처리와 버퍼링 처리로 분류**될 수 있다.

### 스트리밍 처리 방식
* **스트리밍 방식은 MySQL 서버 측에서 처리할 데이터의 개수와 관계 없이 조건에 일치하는 레코드가 검색될 때마다 곧장 클라이언트로 전송**한다.
  * 스트리밍 방식에서 클라이언트는 쿼리를 요청하고 곧바로 원하는 첫 레코드를 전달 받는다.
  * 비록 마지막 레코드를 언제 전달 받을지는 알 수 없지만, 일반적으로 이는 그다지 중요하지 않다.
* 스트리밍 방식으로 쿼리가 처리되는 경우, 클라이언트는 MySQL 서버가 일치하는 레코드를 찾는 즉시 전달받으므로 동시에 데이터를 사용할 수 있다.
  * 스트리밍 방식으로 처리되는 쿼리는 쿼리가 얼마나 많은 레코드를 조회하는지와 관계 없이 빠른 응답 시간을 보장할 수 있다.
* 무엇보다도 **스트리밍 방식으로 처리되는 쿼리에서는 LIMIT 절과 같이 결과 건수를 제한하는 조건들이 쿼리의 전체 실행 시간을 크게 줄여줄 수 있다**.
  * **매우 큰 테이블을 조건절 없이 SELECT 한 것으로 인해 MySQL 서버 상에서 아직 쿼리가 실행되는 도중이더라도 첫 레코드는 매우 빠르게 가져올 수 있다**.
  * 이는 **풀 테이블 스캔의 결과가 아무런 버퍼링 또는 필터링 과정 없이 클라이언트로 즉시 스트리밍되기 때문**이다.
  * 때문에 **LIMIT 절을 쿼리에 추가하면 전체적으로 가져오는 레코드의 개수가 줄어들게 되므로, 마지막 레코드를 가져오기까지의 시간을 크게 줄일 수 있다**.

### 버퍼링 처리 방식
* **ORDER BY 또는 GROUP BY 절은 우선 WHERE 절 조건에 일치하는 모든 레코드를 조회한 후에 정렬하거나 그룹화하므로, 스트리밍 처리를 불가능하게 한다**.
  * 이 경우, **MySQL 서버에서 모든 레코드를 검색하고 정렬하는 동안 클라이언트는 아무 것도 하지 않고 기다리기에 응답 속도가 느려**진다.
* 이렇듯 **버퍼링 방식으로 처리되는 쿼리는 우선 결과를 스토리지 엔진으로부터 조회하여 모아둔 후에 MySQL 서버에서 일괄적으로 가공**한다.
  * 때문에 버퍼링 방식의 쿼리는 LIMIT 절과 같이 결과 수를 제한하는 조건이 명시되더라도 성능 향상에는 큰 도움을 줄 수 없다.
  * 이는 단지 네트워크로 전송되는 레코드의 개수만으 줄이며, 정작 MySQL 서버가 해야할 작업량에는 큰 변화를 주지 못한다.

### 스트리밍 처리와 버퍼링 처리로의 구분
* 상술한 **ORDER BY를 처리하는 세 가지 방식 중, 오로지 인덱스를 사용한 정렬 방식만이 스트리밍 형태로 처리**된다.
  * 반면, **조인 시 드라이브 테이블만 정렬하거나 임시 테이블을 활용하는 정렬 방식은 모두 버퍼링을 사용**한다.
* 때문에 **인덱스를 사용한 정렬 방식을 택하는 경우, LIMIT 절에 의해 제한된 건수만큼만 읽어 바로 클라이언트로 결과를 전송**할 수 있다.
  * 반면, 인덱스를 사용하지 못하는 경우는 필요한 모든 레코드를 디스크로부터 조회하여 정렬한 후에야 LIMIT 절에 명시된 만큼을 잘라 클라이언트애게 전송한다.
* 특히 **조인을 사용하는 경우, 어느 테이블이 드라이빙되어 조인되는지 보다는 어떤 정렬 방식을 적용하는지가 더 큰 성능 차이**를 만들 수 있다.
  1. **가능하다면 인덱스를 사용하는 정렬을 유도**한다.
  2. **그렇지 못하는 경우, 최소한 드라이빙 테이블만 정렬해도 되는 수준으로 유도**할 수 있어야 한다.
* 이렇듯 **인덱스를 사용하지 못하는 쿼리를 페이징 처리에 사용하는 경우, LIMIT 절을 명시하더라도 쿼리가 기대한 만큼 빨라지지는 않는다**.
  * 정확히는, filesort를 사용하는 작업에서도 LIMIT 절이 아무런 영향을 전혀 주지 못하는 정도는 아니다.

## 2022-09-29 Thu
### GROUP BY 절의 처리
* **GROUP BY 역시 ORDER BY 절과 마찬가지로 쿼리가 스트리밍될 수 없도록 하는 처리**이다.
  * 이 때, GROUP BY 절에서 사용할 수 있는 HAVING 절은 GROUP BY 결과에 대한 필터링 기능을 수행한다.
  * 그러나 **GROUP BY에서 사용된 조건 절은 인덱스를 사용하여 처리될 수 없으므로, HAVING 절을 튜닝하기 위한 시도는 필요가 없다**. 
* GROUP BY 절 역시 인덱스를 사용할 수 있는 경우와 그렇지 못한 경우로 다음과 같이 분류할 수 있다.
  1. 인덱스를 사용하는 경우: 인덱스를 차례대로 읽어나가는 인덱스 스캔과 인덱스를 건너 뛰어가며 조회하는 루스 인덱스 스캔이 가능하다.
  2. 인덱스를 사용하지 못하는 경우: **임시 테이블을 사용하여 처리**한다.

### 인덱스 스캔을 활용하는 GROUP BY 절 - 타이트 인덱스 스캔
* **ORDER BY 절과 마찬가지로 조인 시 드라이빙 테이블에 속한 컬럼만을 활용하여 그룹화하는 경우, 해당 컬럼에 대해 인덱스가 존재한다면 인덱스를 사용**한다.
  * 예를 들어 **해당 인덱스를 차례대로 읽어나가며 그룹화한 후에 그 결과를 통해 조인**한다.
  * 그러나 GROUP BY 절이 인덱스를 통해 처리되었다고 해도, 그룹 함수 등을 사용하는 경우 임시 테이블이 필요할 수도 있다.
* **GROUP BY 절이 인덱스를 통해 처리되는 경우, 이미 정렬된 인덱스를 읽어들이므로 쿼리 실행 시점에 별도의 정렬 또는 임시 테이블은 필요하지 않다**.
  * 때문에 쿼리의 실행 계획에서 Extra 컬럼에 별도의 코멘트는 표시되지 않는다.

### 루스 인덱스 스캔을 활용하는 GROUP BY 절
* 루스 인덱스 스캔은 인덱스의 레코드를 건너 뛰어가며 필요한 부분만 조회하는 것을 말한다.
  * 이 때, 옵티마이저가 루스 인덱스 스캔을 사용하는 경우 Extra 컬럼에 `Using index for group-by` 메시지가 표시된다.
* **MySQL의 루스 인덱스 스캔은 단일 테이블에 대해 수행되는 GROUP BY 절에 대해서만 사용될 수 있으며, 유니크한 값의 수가 적을수록 성능은 향상**된다.
  * 즉, 루스 인덱스 스캔은 분포도가 좋지 않은 인덱스일수록 더 좋은 결과를 낳을 수 있다.
  * 이는 **인덱스의 유니크한 값의 수가 많을수록 성능이 향상되는 인덱스 레인지 스캔과는 대비되는 특성**이다.
  * 또한, 컬럼의 앞 쪽 일부 값만으로 생성되는 프리픽스 인덱스로는 루스 인덱스 스캔을 사용할 수 없다.
* **루스 인덱스 스캔으로 쿼리가 처리되는 경우, 별도의 임시 테이블은 사용하지 않는다**.
* 이 때, 다음과 같은 조건은 루스 인덱스 스캔을 통한 GROUP BY 쿼리의 최적화가 불가능하다.
  1. **MIN() 또는 MAX() 이외의 SUM()과 같은 집합 함수가 사용된 경우**
  2. **GROUP BY 절에 사용된 컬럼이 인덱스 구성 컬럼의 왼쪽부터 적용된 컬럼의 순서와 일치하지 않는 경우**
  3. **SELECT 절에서 조회하는 컬럼이 GROUP BY 절과 일치하지 않는 경우** 

### 임시 테이블을 사용하는 GROUP BY 절
* **GROUP BY 절에서 명시한 대상 컬럼이 드라이빙 테이블에 있거나 그렇지 않거나, 인덱스를 전혀 사용하지 못하는 경우에는 해당 방식으로 처리**된다.
  * 이 경우, 쿼리 실행 계획의 Extra 컬럼에는 `Using temporary` 메시지가 표시되며 임시 테이블을 사용한다.
* **MySQL 8.0 이전 버전까지는 GROUP BY 절이 명시되는 경우 그룹화 대성 컬럼을 기준으로 정렬 역시 암시적으로 적용**되었다.
  * 때문에 이러한 암시적인 정렬이 필요하지 않은 경우 `ORDER BY NULL` 을 명시하였으며, 이를 통해 약간의 성능 향상을 이끌어낼 수 있었다.
  * 그러나 MySQL 8.0 버전 이후부터는 더 이상 암시적인 정렬은 적용되지 않는다.
* **MySQL 8.0 버전부터는 GROUP BY 절을 명시하는 경우, 내부적으로 그룹화 대성 컬럼들로 구성된 UQ 인덱스를 갖는 임시 테이블을 생성**하게 된다.
  * 이를 토대로 중복 제거와 집합 함수 연산을 적용하며, 기본적으로는 별도의 정렬 처리를 적용하지 않는다.
  * 정렬이 필요한 경우, ORDER BY 절을 함께 명시하는 것으로 실행 계획에서 `Using temporary; Using filesort` 메시지를 확인할 수 있다.

### DISTINCT 처리
```
> DISTINCT 절은 집합 함수 내에서 사용되는 경우와 그렇지 않은 경우에 대해 쿼리의 결과가 조금씩 다를 수 있다.
```
* DISTINCT 절은 임의 컬럼의 유니크한 값만을 조회하는 경우 SELECT 절에 명시할 수 있다.
* 또한, DISTINCT 절은 경우에 따라 크게 다음과 같이 분류할 수 있다.
  1. MIN(), MAX() 또는 COUNT()와 같은 집합 함수와 함께 사용하는 경우
  2. 또는 집합 함수와 함께 사용하지 않는 경우
* **집합 함수와 함께 사용되는 DISTINCT 절은 실행 계획에서 인덱스를 사용하지 못하는 경우 항상 임시 테이블을 사용**한다.
  * 반면, 이 경우 Extra 컬럼에 `Using temporary` 메시지가 표시되지 않는다.

### 집합 함수와 함께 사용되지 않는 DISTINCT 절
* 단순히 **SELECT 대상 레코드 중에서 유니크한 레코드만 조회하는 경우, `SELECT DISTINCT` 형태로 시작하는 쿼리를 사용**한다.
  * 이 경우에는 GROUP BY의 경우와 동일한 방식으로 처리된다.
* **SELECT 절에 사용되는 DISTINCT 절은 조회되는 모든 컬럼에 영향을 주며, 절대 SELECT 하는 여러 컬럼 중 일부 컬럼만을 유니크하게 조회하지 않는다**.
  * 이렇듯 DISTINCT는 둘 이상의 컬럼을 명시하는 것으로 컬럼의 조합이 유니크한 레코드만을 조회하는 방식으로 사용할 수 있다.

### 집합 함수와 함께 사용되는 DISTINCT 절
* **COUNT()나 MIN(), MAX()와 같은 집합 함수 내에서 사용되는 DISTINCT 절은 일반적인 `SELECT DISTINCT` 와는 다르게 해석**된다.
  * 예를 들어, **집합 함수가 없는 `SELECT DISTINCT` 절은 조회 대상 컬럼들의 유니크한 조합만을 조회**한다.
  * 반면, **집합 함수 내에서 사용된 DISTINCT 절은 해당 집합 함수의 인자로 전달된 컬럼 값이 유니크한 것만을 조회**한다.
* **일반적인 경우, 집합 함수와 함께 사용되는 DISTINCT 절은 처리를 위해 항상 임시 테이블을 사용**한다.
  * 그럼에도 실행 계획의 Extra 컬럼에는 항상 `Using temporary` 메시지를 표시하지 않는다.
  * **이러한 쿼리는 일반적으로 생성되는 임시 테이블에는 UQ 인덱스가 생성되므로, 레코드 건수가 많아질수록 상당히 느려질 수 있다**.
* **`COUNT(DISTINCT 컬럼1), COUNT(DISTINCT 컬럼2)`와 같이 집합 함수와 DISTINCT 절을 함께 사용하는 경우, 각각 임시 테이블을 생성**한다.
  * 즉, 상술한 쿼리는 컬럼1을 저장하기 위한 임시 테이블과 컬럼2를 저장하기 위한 임시 테이블을 각각 한 개씩, 총 2개 생성한다.
* 반면, **인덱스된 컬럼에 대해 DISTINCT 처리를 적용할 수 있는 경우에는 인덱스를 풀 스캔 또는 레인지 스캔하며 임시 테이블을 사용하지 않을 수 있다**.
  * 이 경우에는 임시 테이블을 사용하지 않으므로, 상대적으로 최적화된 쿼리의 처리가 가능하다.
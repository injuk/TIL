# Basics
## 2022-09-24 Sat

### 옵티마이저란?
```
> 어떠한 DBMS든지 쿼리의 실행 계획을 수립하고 결정하는 옵티마이저는 가장 복잡한 부분이며, 결과로 생성되는 실행 계획 역시 이해하기 상당히 어려운 축에 속한다.
```
* MySQL 서버로 요청되는 쿼리는 결과가 동일하지만, 내부적으로 결과를 만들어내는 작업은 매우 다양하다.
  * 이 때, 이러한 **다양한 방법 중 어떠한 방법이 최적이며 최소의 비용을 소모하는지 결정할 수 있어야 한다**.
* **대부분의 DBMS는 여러 기본 데이터를 비교하여 최적의 실행 계획을 수립하는 작업을 수행하며, 이러한 기능을 담당하는 것이 옵티마이저**가 된다.
  * 기본 데이터의 예로, MySQL은 쿼리를 최적으로 실행하기 위해 각 테이블의 데이터가 어떻게 분포되어 저장되어 있는지에 대한 통계 정보를 사용한다.

### 쿼리의 실행 절차
* MySQL 서버에서 쿼리가 실행되기까지의 과정은 크게 다음과 같이 분류된다.
  1. 요청된 **SQL 문장을 필요한만큼 쪼개어 MySQL 서버가 이해할 수 있는 수준으로 분리하고, 결과로 파스 트리를 생성**한다.
  2. **파스 트리를 확인하며 어떠한 테이블로부터 어떠한 인덱스를 활용하여 읽어들인지 선택**한다.
  3. 2.의 과정에서 **결정된 테이블의 읽기 순서 또는 선택된 인덱스를 활용하여 스토리지 엔진으로부터 데이터를 가져온다**. 
* 첫 단계는 **SQL 파싱이라고도 지칭하며, MySQL 서버는 SQL 파서라는 이름의 모듈로 SQL 파스 트리를 생성**한다.
  * 이 과정에서 **SQL 문장의 문법 오류가 검증되며, 이후 MySQL 서버는 원본 SQL 문이 아닌 SQL 파스 트리를 활용하여 쿼리를 실행**한다.
* 두 번째 단계는 **최적화 및 실행 계획 수립 단계라고도 지칭하며, 파싱 단계에서 생성된 파스 트리를 참조하며 다음과 같은 내용을 처리**한다.
  1. 불필요한 조건 제거 및 복잡한 연산을 단순화
  2. 여러 테이블이 조인되는 경우, 어떠한 순서로 테이블을 읽어들일지 결정
  3. 각각의 테이블에 사용된 조건과 인덱스 통계 정보를 활용하여 사용할 인덱스를 결정
  4. 가져온 레코드들을 임시 테이블에 삽입한 후 다시 한 번 가공해야할지 여부를 결정
  5. 이외의 수많은 처리들
* 이 때 **두 번째 단계는 MySQL 서버의 옵티마이저에서 처리되며, 완료시 그 결과로 실행 계획이 만들어지게 된다**. 
* 세 번째 단계에서는 **옵티마이저에 의해 수립된 실행 계획을 토대로 스토리지 엔진으로부터 레코드 조회를 요청**한다.
  * **MySQL 엔진에서는 스토리지 엔진으로부터 전달 받은 레코드를 조인하거나 정렬하는 작업을 수행**한다.
* 이 때, **파싱과 최적화 및 실행 계획 수립 단계는 대부분 MySQL 엔진에서 처리되는 반면 세 번째 단계는 MySQL 엔진과 스토리지 엔진이 함께 처리**한다.

## 2022-09-25 Sun
### 옵티마이저의 종류
```
> 옵티마이저는 DB 서버에서는 두뇌와 같은 역할을 담당하며, 비용 기반 최적화 방식과 규칙 기반 최적화 방식으로 분류된다.
> 현재의 RDBMS는 대부분 비용 기반 최적화 방식의 옵티마이저를 채택한다.
```
* 규칙 기반 최적화 방식은 대상 테이블의 레코드 건수 또는 선택도 등의 통계 정보를 고려하지 않고, 옵티마이저에 내장된 우선 순위에 따라 실행 계획을 수립한다.
* 반면, **비용 기반 최적화 방식은 쿼리를 처리할 수 있는 여러 방법을 생성한 후 각 단위 작업의 비용과 통계 정보를 활용하여 계획 별 비용을 산출**한다.
  * 이렇게 산출된 실행 계획 별로 비용이 최소로 소모될 것으로 판단되는 처리 방식을 선택하여 최종적으로 쿼리를 실행하게 된다.

### 풀 테이블 스캔
* **MySQL 서버 등의 RDBMS는 모두 데이터를 정렬하거나 그룹화하는 기본 데이터 가공 기능을 내장**한다.
  * 그러나 결과는 동일할지언정 RDBMS 별로 결과를 생성하는 과정은 크게 달라질 수 있다.
* **풀 테이블 스캔의 경우, 인덱스를 사용하지 않고 테이블의 데이터를 처음부터 끝까지 읽어 요청된 작업을 처리**한다.
* MySQL 옵티마이저는 다음과 같은 상황에서 주로 풀 테이블 스캔 방식을 선택한다.
  1. 예를 들어 **테이블이 페이지 1개로 구성되는 등, 테이블 레코드 수가 너무 적어 인덱스를 활용한 조회보다 풀 테이블 스캔을 진행하는 편이 더 빠른 경우**
  2. WHERE 절 또는 ON 절에 인덱스를 활용할만한 적절한 조건이 명시되지 않은 경우
  3. 인덱스 레인지 스캔을 사용할 수 있는 쿼리이나, 통계 정보를 기반으로 옵티마이저가 판단한 조건 일치 레코드 수가 너무 많은 경우

### 리드 어헤드 작업
* 일반적으로, 테이블의 전체 크기는 인덱스보다 훨씬 크기에 풀 테이블 스캔 방식은 큰 랜덤 디스크 IO를 필요로 한다.
  * 때문에 **대부분의 DBMS는 풀 테이블 스캔을 지원하기 위해 한 번에 여러 블록 또는 페이지를 조회하는 기능을 내장**한다.
* **InnoDB 스토리지 엔진은 테이블의 연속된 데이터 페이지가 조회되는 경우, 백그라운드 스레드에 의헤 리드 어헤드 작업이 자동 시작**된다.
* **리드 어헤드 작업이란, 어떤 영역의 데이터가 필요할 것으로 보여지는 경우 실제 요청이 오기 전에 미리 디스크로부터 읽어 버퍼 풀에 적재하는 것을 의미**한다.
  * 때문에 **풀 테이블 스캔이 실행되는 경우, 처음 몇 페이지는 클라이언트 스레드가 조회하지만 임의의 시점부터는 백그라운드 스레드에게 읽기 작업을 위임**한다.
  * 백그라운드 스레드가 읽기 작업을 위임받은 시점부터는 점차 한 번에 읽어들이는 페이지 수를 증가시키므로, 쿼리는 상당히 빠르게 처리될 수 있다.
* MySQL 서버에서는 `innodb_read_ahead_threshold` 시스템 변수를 통해 InnoDB가 어느 시점에 리드 어헤드 작업을 시작할지 임계치를 결정할 수 있다.
  * 예를 들어 클라이언트 스레드로부터 해당 변수에 설정된 만큼 연속된 데이터 페이지가 읽혀진 경우, InnoDB 엔진은 백그라운드 스레드를 활용한다.
  * 백그라운드 스레드는 점차 많은 페이지를 한 번에 읽어들여 버퍼 풀에 적재하므로, 클라이언트 스레드를 버퍼 풀로부터 필요한 정보를 가져가기만 하면 된다.
  * 해당 시스템 변수는 일반적으로 기본값을 사용해도 무방하지만, MySQL 서버가 DW 용도로 사용되는 경우 더 낮은 값으로 설정하는 것을 고려할 수 있다.

### 풀 인덱스 스캔
```
> 풀 테이블 스캔이 테이블의 처음부터 끝까지 탐색하는 것처럼, 풀 인덱스 스캔은 인덱스를 처음부터 끝까지 스캔한다.
```
* **리드 어헤드 작업은 풀 테이블 스캔 뿐만 아니라 풀 인덱스 스캔에서도 동일하게 사용**된다.
* 일반적으로 **인덱스는 테이블의 2 ~ 3개 컬럼만으로 구성되므로, 전체 테이블 자체보다 용량이 작어 훨씬 빠른 처리가 가능**하다.
  * 때문에 **MySQL 서버는 랜덤 디스크 IO를 최대한 줄이기 위해 되도록 더 작은 용량을 갖는 인덱스를 선택**한다.
* 예를 들어 다음과 같은 두 쿼리의 경우, 각자 다른 이유에서 풀 테이블 스캔 또는 풀 인덱스 스캔이 적용된다.
  1. `SELECT COUNT(*) FROM table_name`: 단순히 레코드의 건수만을 필요로 하는 쿼리이므로, 용량이 작은 인덱스로도 처리가 가능하다. 
  2. `SELECT * FROM table_name`: **모든 컬럼을 조회하므로, 인덱스에 존재하지 않는 레코드 컬럼을 조회하기 위해 풀 테이블 스캔이 적용**된다.

### 쿼리의 병렬 처리
* MySQL 8.0 버전부터는 하나의 쿼리를 여러 스레드가 나누어 동시에 작업을 처리하는 병렬 처리가 한정적으로나마 가능하다.
  * 예를 들어 `innodb_parallel_read_threads` 시스템 변수는 단일 쿼리를 최대 몇 개의 스레드로 처리할지 변경하기 위해 사용된다.
* MySQL 서버에서는 아직까지 쿼리를 여러 스레드로 병렬 처리하도록 하는 힌트나 옵션은 존재하지 않는다.
  * 대신 **아무런 WHERE 절 없이 단순히 테이블의 전체 건수만을 가져오는 쿼리만 병렬 처리가 가능**하다.
* 병렬 처리용 스레드 개수가 늘어날수록 쿼리 처리 시간이 줄어드는 반면, 서버의 CPU 코어 개수를 넘어서는 스레드 개수는 오히려 성능이 떨어질 수도 있다.

### Using filesort
```
> MySQL 서버에서 인덱스를 활용하지 않고 별도로 정렬 처리를 수행했는지 여부는 실행 계획에서 확인할 수 있다.
> 예를 들어, 실행 계획의 Extra 컬럼에 Using filesort 메시지가 표시되는 경우 인덱스 정렬이 아닌 별도의 정렬 처리를 수행한 것이 된다.
```
* **레코드를 1 ~ 2건 조회하는 쿼리를 제외하는 경우, 대부분의 SELECT 쿼리에서 정렬은 필수적**이다.
  * DW처럼 대량의 데이터를 활용한 일괄 처리 기능이 아닌 경우, 일반적으로 레코드 정렬 조건은 대부분의 조회 쿼리에 포함된다. 
* 이 때, 정렬을 처리하는 방식은 크게 다음과 같은 두 가지 방식으로 나누어 생각할 수 있다.
  1. 인덱스를 이용하기: DML 실행 시 이미 인덱스가 정렬되어 있으므로, 빠른 반환이 가능하다.
  2. filesort 처리 이용하기: 정렬 대상 레코드가 많지 않은 경우, 메모리에서 filesort가 처리되므로 충분히 빠를 수 있다.
* 반면, 인덱스를 활용하는 경우 다음과 같은 단점이 존재한다.
  1. DML을 위한 부가적인 인덱스 추가 및 제거 작업이 필요하므로, 상대적으로 느리다.
  2. 인덱스로 인해 디스크 공간을 더 많이 사용하게 된다.
  3. 인덱스의 개수가 늘어날수록 InnoDB 버퍼 풀에 사용되는 메모리가 더 많이 필요하다.
* 또한, filesort 방식은 인덱스를 활용하는 경우의 단점을 장점으로 치환하지만 다음과 같은 단점이 존재한다.
  1. **정렬 작업이 쿼리 실행 시점에 처리되므로, 레코드 대상 건수가 많아질수록 응답 속도는 느려질 수 밖에 없다**.
* 이렇듯 **레코드를 정렬하기 위해 반드시 filesort를 사용해야하는 것은 아니며, 오히려 인덱스를 이용한 정렬을 활용**할 수도 있다.
* 그러나 다음과 같은 경우에는 인덱스만을 활용하는 정렬이 불가능할 수 있다.
  1. 정렬 기준이 너무 많아서 조건 별로 인덱스를 활용하는 것이 불가능한 경우
  2. **GROUP BY 또는 DISTINCT 처리 결과를 정렬해야 하는 경우**
  3. **UNION 결과와 같이 임시 테이블의 결과를 다시 정렬해야 하는 경우**
  4. 랜덤한 결과 레코드를 조회해야하는 경우
# Basics
## 2022-09-24 Sat

### 옵티마이저란?
```
> 어떠한 DBMS든지 쿼리의 실행 계획을 수립하고 결정하는 옵티마이저는 가장 복잡한 부분이며, 결과로 생성되는 실행 계획 역시 이해하기 상당히 어려운 축에 속한다.
```
* MySQL 서버로 요청되는 쿼리는 결과가 동일하지만, 내부적으로 결과를 만들어내는 작업은 매우 다양하다.
  * 이 때, 이러한 **다양한 방법 중 어떠한 방법이 최적이며 최소의 비용을 소모하는지 결정할 수 있어야 한다**.
* **대부분의 DBMS는 여러 기본 데이터를 비교하여 최적의 실행 계획을 수립하는 작업을 수행하며, 이러한 기능을 담당하는 것이 옵티마이저**가 된다.
  * 기본 데이터의 예로, MySQL은 쿼리를 최적으로 실행하기 위해 각 테이블의 데이터가 어떻게 분포되어 저장되어 있는지에 대한 통계 정보를 사용한다.

### 쿼리의 실행 절차
* MySQL 서버에서 쿼리가 실행되기까지의 과정은 크게 다음과 같이 분류된다.
  1. 요청된 **SQL 문장을 필요한만큼 쪼개어 MySQL 서버가 이해할 수 있는 수준으로 분리하고, 결과로 파스 트리를 생성**한다.
  2. **파스 트리를 확인하며 어떠한 테이블로부터 어떠한 인덱스를 활용하여 읽어들인지 선택**한다.
  3. 2.의 과정에서 **결정된 테이블의 읽기 순서 또는 선택된 인덱스를 활용하여 스토리지 엔진으로부터 데이터를 가져온다**. 
* 첫 단계는 **SQL 파싱이라고도 지칭하며, MySQL 서버는 SQL 파서라는 이름의 모듈로 SQL 파스 트리를 생성**한다.
  * 이 과정에서 **SQL 문장의 문법 오류가 검증되며, 이후 MySQL 서버는 원본 SQL 문이 아닌 SQL 파스 트리를 활용하여 쿼리를 실행**한다.
* 두 번째 단계는 **최적화 및 실행 계획 수립 단계라고도 지칭하며, 파싱 단계에서 생성된 파스 트리를 참조하며 다음과 같은 내용을 처리**한다.
  1. 불필요한 조건 제거 및 복잡한 연산을 단순화
  2. 여러 테이블이 조인되는 경우, 어떠한 순서로 테이블을 읽어들일지 결정
  3. 각각의 테이블에 사용된 조건과 인덱스 통계 정보를 활용하여 사용할 인덱스를 결정
  4. 가져온 레코드들을 임시 테이블에 삽입한 후 다시 한 번 가공해야할지 여부를 결정
  5. 이외의 수많은 처리들
* 이 때 **두 번째 단계는 MySQL 서버의 옵티마이저에서 처리되며, 완료시 그 결과로 실행 계획이 만들어지게 된다**. 
* 세 번째 단계에서는 **옵티마이저에 의해 수립된 실행 계획을 토대로 스토리지 엔진으로부터 레코드 조회를 요청**한다.
  * **MySQL 엔진에서는 스토리지 엔진으로부터 전달 받은 레코드를 조인하거나 정렬하는 작업을 수행**한다.
* 이 때, **파싱과 최적화 및 실행 계획 수립 단계는 대부분 MySQL 엔진에서 처리되는 반면 세 번째 단계는 MySQL 엔진과 스토리지 엔진이 함께 처리**한다.

## 2022-09-25 Sun
### 옵티마이저의 종류
```
> 옵티마이저는 DB 서버에서는 두뇌와 같은 역할을 담당하며, 비용 기반 최적화 방식과 규칙 기반 최적화 방식으로 분류된다.
> 현재의 RDBMS는 대부분 비용 기반 최적화 방식의 옵티마이저를 채택한다.
```
* 규칙 기반 최적화 방식은 대상 테이블의 레코드 건수 또는 선택도 등의 통계 정보를 고려하지 않고, 옵티마이저에 내장된 우선 순위에 따라 실행 계획을 수립한다.
* 반면, **비용 기반 최적화 방식은 쿼리를 처리할 수 있는 여러 방법을 생성한 후 각 단위 작업의 비용과 통계 정보를 활용하여 계획 별 비용을 산출**한다.
  * 이렇게 산출된 실행 계획 별로 비용이 최소로 소모될 것으로 판단되는 처리 방식을 선택하여 최종적으로 쿼리를 실행하게 된다.

### 풀 테이블 스캔
* **MySQL 서버 등의 RDBMS는 모두 데이터를 정렬하거나 그룹화하는 기본 데이터 가공 기능을 내장**한다.
  * 그러나 결과는 동일할지언정 RDBMS 별로 결과를 생성하는 과정은 크게 달라질 수 있다.
* **풀 테이블 스캔의 경우, 인덱스를 사용하지 않고 테이블의 데이터를 처음부터 끝까지 읽어 요청된 작업을 처리**한다.
* MySQL 옵티마이저는 다음과 같은 상황에서 주로 풀 테이블 스캔 방식을 선택한다.
  1. 예를 들어 **테이블이 페이지 1개로 구성되는 등, 테이블 레코드 수가 너무 적어 인덱스를 활용한 조회보다 풀 테이블 스캔을 진행하는 편이 더 빠른 경우**
  2. WHERE 절 또는 ON 절에 인덱스를 활용할만한 적절한 조건이 명시되지 않은 경우
  3. 인덱스 레인지 스캔을 사용할 수 있는 쿼리이나, 통계 정보를 기반으로 옵티마이저가 판단한 조건 일치 레코드 수가 너무 많은 경우

### 리드 어헤드 작업
* 일반적으로, 테이블의 전체 크기는 인덱스보다 훨씬 크기에 풀 테이블 스캔 방식은 큰 랜덤 디스크 IO를 필요로 한다.
  * 때문에 **대부분의 DBMS는 풀 테이블 스캔을 지원하기 위해 한 번에 여러 블록 또는 페이지를 조회하는 기능을 내장**한다.
* **InnoDB 스토리지 엔진은 테이블의 연속된 데이터 페이지가 조회되는 경우, 백그라운드 스레드에 의헤 리드 어헤드 작업이 자동 시작**된다.
* **리드 어헤드 작업이란, 어떤 영역의 데이터가 필요할 것으로 보여지는 경우 실제 요청이 오기 전에 미리 디스크로부터 읽어 버퍼 풀에 적재하는 것을 의미**한다.
  * 때문에 **풀 테이블 스캔이 실행되는 경우, 처음 몇 페이지는 클라이언트 스레드가 조회하지만 임의의 시점부터는 백그라운드 스레드에게 읽기 작업을 위임**한다.
  * 백그라운드 스레드가 읽기 작업을 위임받은 시점부터는 점차 한 번에 읽어들이는 페이지 수를 증가시키므로, 쿼리는 상당히 빠르게 처리될 수 있다.
* MySQL 서버에서는 `innodb_read_ahead_threshold` 시스템 변수를 통해 InnoDB가 어느 시점에 리드 어헤드 작업을 시작할지 임계치를 결정할 수 있다.
  * 예를 들어 클라이언트 스레드로부터 해당 변수에 설정된 만큼 연속된 데이터 페이지가 읽혀진 경우, InnoDB 엔진은 백그라운드 스레드를 활용한다.
  * 백그라운드 스레드는 점차 많은 페이지를 한 번에 읽어들여 버퍼 풀에 적재하므로, 클라이언트 스레드를 버퍼 풀로부터 필요한 정보를 가져가기만 하면 된다.
  * 해당 시스템 변수는 일반적으로 기본값을 사용해도 무방하지만, MySQL 서버가 DW 용도로 사용되는 경우 더 낮은 값으로 설정하는 것을 고려할 수 있다.

### 풀 인덱스 스캔
```
> 풀 테이블 스캔이 테이블의 처음부터 끝까지 탐색하는 것처럼, 풀 인덱스 스캔은 인덱스를 처음부터 끝까지 스캔한다.
```
* **리드 어헤드 작업은 풀 테이블 스캔 뿐만 아니라 풀 인덱스 스캔에서도 동일하게 사용**된다.
* 일반적으로 **인덱스는 테이블의 2 ~ 3개 컬럼만으로 구성되므로, 전체 테이블 자체보다 용량이 작어 훨씬 빠른 처리가 가능**하다.
  * 때문에 **MySQL 서버는 랜덤 디스크 IO를 최대한 줄이기 위해 되도록 더 작은 용량을 갖는 인덱스를 선택**한다.
* 예를 들어 다음과 같은 두 쿼리의 경우, 각자 다른 이유에서 풀 테이블 스캔 또는 풀 인덱스 스캔이 적용된다.
  1. `SELECT COUNT(*) FROM table_name`: 단순히 레코드의 건수만을 필요로 하는 쿼리이므로, 용량이 작은 인덱스로도 처리가 가능하다. 
  2. `SELECT * FROM table_name`: **모든 컬럼을 조회하므로, 인덱스에 존재하지 않는 레코드 컬럼을 조회하기 위해 풀 테이블 스캔이 적용**된다.

### 쿼리의 병렬 처리
* MySQL 8.0 버전부터는 하나의 쿼리를 여러 스레드가 나누어 동시에 작업을 처리하는 병렬 처리가 한정적으로나마 가능하다.
  * 예를 들어 `innodb_parallel_read_threads` 시스템 변수는 단일 쿼리를 최대 몇 개의 스레드로 처리할지 변경하기 위해 사용된다.
* MySQL 서버에서는 아직까지 쿼리를 여러 스레드로 병렬 처리하도록 하는 힌트나 옵션은 존재하지 않는다.
  * 대신 **아무런 WHERE 절 없이 단순히 테이블의 전체 건수만을 가져오는 쿼리만 병렬 처리가 가능**하다.
* 병렬 처리용 스레드 개수가 늘어날수록 쿼리 처리 시간이 줄어드는 반면, 서버의 CPU 코어 개수를 넘어서는 스레드 개수는 오히려 성능이 떨어질 수도 있다.

### Using filesort
```
> MySQL 서버에서 인덱스를 활용하지 않고 별도로 정렬 처리를 수행했는지 여부는 실행 계획에서 확인할 수 있다.
> 예를 들어, 실행 계획의 Extra 컬럼에 Using filesort 메시지가 표시되는 경우 인덱스 정렬이 아닌 별도의 정렬 처리를 수행한 것이 된다.
```
* **레코드를 1 ~ 2건 조회하는 쿼리를 제외하는 경우, 대부분의 SELECT 쿼리에서 정렬은 필수적**이다.
  * DW처럼 대량의 데이터를 활용한 일괄 처리 기능이 아닌 경우, 일반적으로 레코드 정렬 조건은 대부분의 조회 쿼리에 포함된다. 
* 이 때, 정렬을 처리하는 방식은 크게 다음과 같은 두 가지 방식으로 나누어 생각할 수 있다.
  1. 인덱스를 이용하기: DML 실행 시 이미 인덱스가 정렬되어 있으므로, 빠른 반환이 가능하다.
  2. filesort 처리 이용하기: 정렬 대상 레코드가 많지 않은 경우, 메모리에서 filesort가 처리되므로 충분히 빠를 수 있다.
* 반면, 인덱스를 활용하는 경우 다음과 같은 단점이 존재한다.
  1. DML을 위한 부가적인 인덱스 추가 및 제거 작업이 필요하므로, 상대적으로 느리다.
  2. 인덱스로 인해 디스크 공간을 더 많이 사용하게 된다.
  3. 인덱스의 개수가 늘어날수록 InnoDB 버퍼 풀에 사용되는 메모리가 더 많이 필요하다.
* 또한, filesort 방식은 인덱스를 활용하는 경우의 단점을 장점으로 치환하지만 다음과 같은 단점이 존재한다.
  1. **정렬 작업이 쿼리 실행 시점에 처리되므로, 레코드 대상 건수가 많아질수록 응답 속도는 느려질 수 밖에 없다**.
* 이렇듯 **레코드를 정렬하기 위해 반드시 filesort를 사용해야하는 것은 아니며, 오히려 인덱스를 이용한 정렬을 활용**할 수도 있다.
* 그러나 다음과 같은 경우에는 인덱스만을 활용하는 정렬이 불가능할 수 있다.
  1. 정렬 기준이 너무 많아서 조건 별로 인덱스를 활용하는 것이 불가능한 경우
  2. **GROUP BY 또는 DISTINCT 처리 결과를 정렬해야 하는 경우**
  3. **UNION 결과와 같이 임시 테이블의 결과를 다시 정렬해야 하는 경우**
  4. 랜덤한 결과 레코드를 조회해야하는 경우

## 2022-09-26 Mon
### 소트 버퍼
```
> 소트 버퍼로 정렬하는 대상 레코드가 충분히 적은 경우, 메모리에서 쿼리 처리가 가능하므로 빠른 정렬이 가능하다.
> 그러나 정렬 대상 레코드 건수가 소트 버퍼의 크기보다 큰 경우, 결과를 임시 저장하기 위해 디스크를 사용하게 된다.
```
* **MySQL은 정렬을 위해 소트 버퍼라는 별도의 메모리 공간을 할당받아 사용하며, 쿼리의 실행이 완료되면 즉시 해당 메모리 공간을 반환**한다.
  * **소트 버퍼는 정렬이 필요한 경우에만 할당되며, 버퍼의 크기는 정렬해야 할 레코드의 크기에 따라 가변적으로 증가**한다.
  * 단, 소트 버퍼의 상한은 `sort_buffer_size` 시스템 변수에 의해 설정된다.
  * 여기까지, 상술한 내용은 **정렬 대상 레코드가 매우 소량인 경우 메모리에 할당된 소트 버퍼만으로 정렬이 가능하여 매우 빠르게 처리**된다.
* **소트 버퍼를 활용한 정렬이 문제가 되는 경우는 정렬 대상 레코드 건수가 소트 버퍼로 할당된 메모리 공간보다 큰 경우에 발생**한다.
  * **MySQL은 정렬 대상 레코드를 여러 조각으로 나눠 처리하며, 이 과정에서 대상 레코드 건수가 너무 많다면 임시 저장을 위해 디스크를 사용**한다. 

### 디스크를 활용하는 소트 버퍼
* **레코드 건수가 충분히 많아 정렬을 위해 디스크를 사용하는 경우, 우선 메모리 상의 소트 버퍼로부터 정렬한 후 그 결과를 임시 디스크에 저장**한다.
  * 이러한 과정은 다음 레코드를 가져와 정렬한 후, 반복적으로 디스크에 저장하는 식으로 진행된다.
* 이렇게 **버퍼 크기만큼 정렬된 레코드는 다시 병합하며 정렬이 수행되는 멀티 머지 작업이 반드시 수행**되어야 한다.
* **멀티 머지 과정은 모두 디스크 IO를 유발하며, 레코드 건수가 많아질수록 반복 작업의 횟수 역시 많아진다**.

### 적절한 소트 버퍼의 크기
* 단순히 소트 버퍼의 크기 상한을 높인다고 해도 처리 성능은 크게 빨라질 수 있으며, 오히려 악영향을 미칠 가능성이 존재한다.
  * 리눅스 기반 OS의 경우, 소트 버퍼의 크기를 너무 크게 적용하는 경우 불필요한 메모리 공간 할당으로 인해 성능이 더 떨어질 수도 있다.
* **일반적인 트랜잭션 처리용 MySQL 서버의 소트 버퍼 크기는 56KB ~ 1MB 정도가 적절**하다.
  * **MySQL 서버의 메모리는 글로벌 영역과 세션 영역으로 나뉘며, 이 중 정렬을 위한 소트 버퍼는 세션 메모리 영역**에 속한다.
  * 이는 **커넥션이 많아지거나 정렬 작업이 많아질수록 각 세션에서 소트 버퍼로 소비하는 메모리 공간이 커짐을 의미**한다.
  * 이 경우 최악의 상황에는 OS가 메모리 부족 현상을 겪을 수 있으며, OS의 OOM-Killer는 여유 메모리를 확보하기 위해 프로세스를 강제 종료한다.
  * **OOM-Killer는 일반적으로 메모리를 가장 많이 사용하는 프로세스를 강제 종료하며, 강제 종료 1순위는 일반적으로 MySQL 서버가 될 가능성**이 높다.
* **대량 데이터의 정렬이 필요한 경우, 해당 쿼리를 실행하는 세션의 소트 버퍼만 일시적으로 증가시킨 후 다시 줄이는 것도 좋은 방법에 해당**한다.

### 정렬 모드의 종류
* 레코드를 정렬하기 위해 어떤 내용을 소트 버퍼에 담을지는 크게 다음과 같이 분류될 수 있다.
  1. **싱글 패스 정렬 모드: 레코드 전체를 소트 버퍼에 담기**
  2. **투 패스 정렬 모드: 또는 정렬 기준이 되는 컬럼만 소트 버퍼에 담기**
* 정렬이 필요한 쿼리가 어떤 정렬 모드를 사용하는지는 옵티마이저 트레이스 기능을 통해 확인할 수 있으며, MySQL 서버의 정렬 방식은 크게 다음과 같이 분류된다.
  1. 투 패스: 정렬 키와 레코드의 ROW ID만을 가져와서 정렬하기
  2. 싱글 패스: 정렬 키와 레코드 전체를 가져와서 정렬하되, 레코드의 컬럼들은 고정 사이즈로 메모리에 저장하기
  3. 싱글 패스: 정렬 키와 레코드 전체를 가져와서 정렬하되, 레코드의 컬럼들은 가변 사이즈로 메모리에 저장하기
* 이 중 세 번째 방식은 MySQL 5.7 버전부터 도입되었으며, 정렬을 위한 메모리 공간을 효율적으로 사용하기 위해 추가된 기능에 해당한다.

### 싱글 패스 정렬 방식
```
> 싱글 패스 정렬 방식이란, 소트 버퍼에 정렬 기준 컬럼을 포함하여 SELECT 절의 대상 컬럼을 모두 포함하여 정렬을 수행하는 방식이다.
```
* 예를 들어 다음과 같은 쿼리가 있는 경우, **정렬 기준이 되는 컬럼 뿐만 아니라 SELECT 절의 모든 컬럼을 조회하여 소트 버퍼에 담아 정렬**한다.
  * 즉, 아래의 쿼리는 정렬 기준인 `first_name` 뿐만 아니라 `emp_no`, `last_name`을 함께 조회하여 소트 버퍼를 통해 정렬한다.
  * 또한, 정렬이 완료되면 정렬 버퍼의 내용을 그대로 클라이언트에게 반환한다.
```
SELECT emp_no, first_name, last_name
  FROM employees
  ORDER BY first_name;
```

### 투 패스 정렬 방식
```
> 투 패스 정렬 방식은 우선 정렬 대상 컬럼과 PK 값만 소트 버퍼에 담아 정렬한다.
> 정렬이 완료된 경우, 정렬된 순서대로 PK를 통해 SELECT 대상 컬럼을 조회한다.
```
* 상술한 쿼리를 처리하는 과정에서 투 패스 정렬 방식으로 정렬하는 경우, 정렬 과정은 다음과 같이 진행된다.
  1. 정렬 대상 컬럼인 `first_name`과 PK인 `emp_no` 컬럼만 조회하여 소트 버퍼로부터 정렬한다.
  2. **멀티 머지를 활용한 정렬이 완료된 후, 정렬 결과의 PK 컬럼을 토대로 `last_name`을 추가로 조회**한다. 
  3. 쿼리 결과를 반환한다.
* **투 패스 방식은 MySQL의 이전 버전에서 사용되던 정렬 방식으로, 테이블을 두 번 조회해야만 하는 단점이 존재**한다.
  * 그러나 **두 정렬 방식은 각각의 장단점이 존재하므로, MySQL 8.0에서도 특정한 조건에서는 투 패스 정렬 방식을 사용**한다.

### 싱글 패스 정렬과 투 패스 정렬 방식의 차이
* 싱글 패스 정렬 방식은 더 많은 소트 버퍼 공간을 필요로 한다.
  * 투 패스 정렬 방식은 필요한 컬럼만 사용하여 정렬하므로, 더 적은 소트 버퍼 공간을 사용한다.
* 싱글 패스 정렬 방식은 테이블을 두 번 조회해야 하는 불합리함이 존재하지 않는다.
  * 투 패스 정렬 방식은 정렬을 완료한 후 테이블로부터 필요한 컬럼을 추가로 조회해야 하는 단점이 존재한다.
* **싱글 패스 방식은 정렬 대상 레코드의 크기 또는 개수가 적은 경우 상대적으로 빠른 성능**을 보인다.
  * **투 패스 방식은 정렬 대상 레코드의 크기 또는 개수가 큰 경우 효율적인 사용이 가능**하다.
* 이러한 차이에서, **최신 버전에서는 일반적으로 싱글 패스 정렬 방식을 주로 사용하되 다음의 경우에는 투 패스 정렬 방식을 적용**한다.
  1. 레코드의 크기가 `max_length_for_sort_data` 시스템 변수의 값보다 큰 경우
  2. 또는 BLOB, TEXT 타입의 컬럼이 SELECT 절 대상에 포함되는 경우

### SELECT * 의 단점
* **SELECT 쿼리에서 `*` 키워드로 모든 컬럼을 조회하는 것은 정렬 버퍼를 적게는 수 배에서 크게는 수십 배까지 비효율적으로 사용할 가능성**이 높다.
  * 때문에 SELECT 절에서는 반드시 필요한 컬럼만 조회하도록 쿼리를 작성하는 것이 바람직하다.
  * 특히 **정렬이 필요한 경우에는 불필요한 컬럼을 SELECT 하지 않도록 작성하는 식으로 적용하는 것이 필수적**이다.

## 2022-09-27 Tue
### 정렬 처리 방법
* 쿼리에 **ORDER BY 절이 포함된 경우, 반드시 다음 세 방법중 하나로 정렬이 처리되며 일반적으로 아래에 있는 방법일수록 처리 속도가 떨어진다**.
  1. 인덱스를 사용한 정렬: Extra 컬럼에 별도로 표기되는 내용이 없다.
  2. **조인 시 드라이빙 테이블만을 정렬: Extra 컬럼에 `Using filesort` 메시지가 표시**된다.
  3. **조인 시 조인 결과를 임시 테이블로 저장한 후에 정렬: Extra 컬럼에 `Using temporary; Using filesort` 메시지가 표시**된다.
* **우선 옵티마이저는 정렬을 위해 인덱스를 사용할 수 있는지 검토하며, 가능한 경우 별도의 정렬 없이 인덱스를 순서대로 읽어 결과를 반환**한다.
* **반면 인덱스를 사용할 수 없는 경우, WHERE 절의 조건에 일치하는 레코드를 검색하여 정렬 버퍼에 저장하며 정렬을 처리**한다.
* 이 때, 옵티마이저는 정렬 대상 레코드를 최소화하기 위해 다음의 방법 중 하나를 선택한다.
  1. 정렬 후 조인: 조인의 드라이빙 테이블만 **정렬한 후에 조인을 처리**하기
  2. 조인 후 정렬: 또는 조인이 완료된 후에 일치하는 **레코드를 모두 가져온 후에 정렬을 수행**하기
* **일반적으로 조인이 수행되면 레코드의 개수 및 크기는 사실상 배로 증가하므로, 가능하다면 1.과 같이 드라이빙 테이블을 정렬한 후 조인하는 것이 바람직**하다.
  * 즉, **정렬 후 조인을 처리하는 방식이 조인 후 정렬을 처리하는 방식보다 효율적**이다.

### 인덱스를 활용하는 정렬
```
> B-Tree 인덱스는 키 값을 기반으로 이미 정렬되어 있으므로, 조건을 충족하는 경우 정렬은 인덱스를 통해 처리될 수 있다.
```
* 인덱스를 통해 정렬하기 위해서는 반드시 다음과 같은 조건을 만족해야 한다.
  1. **ORDER BY 절에 명시된 컬럼이 드라이빙 테이블에 속해야 한다**.
  2. **ORDER BY에 맞는 순서대로 생성된 인덱스가 존재해야 한다**.
  3. **WHERE 절에 드라이빙 테이블의 컬럼에 대한 조건이 존재하는 경우, 해당 조건과 ORDER BY는 같은 인덱스를 사용할 수 있어야 한다**.
  4. 여러 테이블이 조인되는 경우, Nested loop 방식의 조인에서만 해당 정렬 방식을 적용할 수 있다.
* **인덱스를 활용하여 정렬이 처리되는 경우, 실제 인덱스긔 값은 정렬되어 있으므로 인덱스 순서대로 읽기만 하면 된다**.
  * 이 경우, MySQL 엔진은 굳이 별도의 정렬을 위한 추가 작업을 수행하지 않는다.
* 인덱스를 활용하여 정렬을 처리하는 경우, ORDER BY 절을 명시하지 않더라도 자동으로 정렬된다.
  * 그러나 **MySQL 서버는 인덱스로 정렬을 처리하는 경우에는 불필요한 정렬 작업을 추가로 수행하지 않으므로, ORDER BY 절을 명시하더라도 작업량은 같다**.
  * 반면, 외부 요인으로 인해 실행 계획이 변경되는 경우 ORDER BY가 누락된 쿼리는 의도한대로 동작하지 않을 가능성이 존재한다.
  * 때문에 **인덱스로 정렬을 처리하는 경우에도 ORDER BY를 명시하는 것이 바람직**하다.

### JOIN과 정렬
* 조인을 사용하는 경우, 네스티드 루프 방식을 활용하는 조인은 조인으로 인해 드라이빙 테이블의 인덱스 읽기 순서가 흐트러질 일이 없다.
  * 반면, 조인이 사용되는 쿼리의 실행 계획에 조인 버퍼가 사용되는 경우에는 읽기 순서가 뒤바뀔 수 있으므로 주의를 기울여야 한다.

### 조인 시 드라이빙 테이블만 정렬
* 일반적으로 조인을 수행하는 경우 결과 레코드는 그 수와 레코드 별 크기가 급증하게 된다.
  * 때문에 **조인을 적용하기 전에 우선 첫 번째 테이블의 레코드를 정렬한 후 조인을 실행하는 것이 정렬에 있어서는 차악**이 된다.
* **해당 방식을 통해 정렬을 처리하기 위해서는 반드시 드라이빙 테이블의 컬럼만으로 ORDER BY 절이 작성되어야 한다**.
* 드라이빙 테이블만 정렬하는 방식은 다음과 같이 진행된다.
  1. 우선 검색 조건을 만족하는 레코드를 검색한다.
  2. 1.의 과정에서 **조회된 검색 결과를 ORDER BY 절에 명시된 컬럼을 토대로 소트 버퍼에서 정렬**한다.
  3. 2.의 과정에서 **정렬된 결과를 소트 버퍼로부터 순서대로 조회하며 드리븐 테이블과 조인하여 최종 결과를 반환**한다.

### 임시 테이블을 활용하는 정렬
* 조인하지 않고 단일 테이블로부터 SELECT하는 쿼리는 굳이 임시 테이블을 사용할 필요가 없다.
  * 그러나 **둘 이상의 테이블을 조인하여 결과를 정렬하는 경우, 임시 테이블을 사용해야만 하는 경우가 발생할 수도 있다**.
* **조인 시 드라이빙 테이블만 정렬하는 방식은 둘 이상의 테이블이 조인되며 정렬을 적용하지만, 소트 버퍼에서 정렬하므로 임시 테이블을 사용하지는 않는다**.
  * 그러나 **그 외의 경우에는 항상 조인의 결과를 임시 테이블에 저장하고, 그 결과를 다시 정렬**해야 한다.
  * 즉, **상술한 두 방법과 비교하여 가장 정렬 대상 레코드 개수가 많기 때문에 가장 느린 방식의 정렬에 해당**한다.
* 만약 **드라이빙 테이블의 컬럼만으로 정렬이 불가능하고, ORDER BY 절에 명시된 컬럼이 드리븐 테이블의 컬럼인 경우 정렬이 수행되기 전에 조인되어야 한다**.
  * 즉, 정렬 전에 드리븐 테이블을 조회하여 조인하므로 조인된 데이터를 정렬하게 되어 가장 느린 정렬 처리 속도를 갖게 된다.
* **실행 계획의 Extra 컬럼에 표시되는 `Using temporary; Using filesort`는 조인 결과를 임시 테이블에 저장하고, 이를 다시 정렬했음을 의미**한다.

### 정렬 처리 방법 - 결론
* 쿼리에 ORDER BY 절이 명시되면 반드시 다음과 같은 방법으로 정렬이 처리된다.
  1. -: 인덱스를 사용한 정렬로, 실행 계획의 Extra 컬럼에 별도로 메시지가 표기되지 않는다.
  2. Using filesort: 조인 시 드라이빙 테이블만 정렬한다.
  3. Using temporary; Using filesort: 조인 시 조인된 결과를 임시 테이블에 저장한 후에 정렬한다.
* **인덱스를 활용할 수 있는 경우, 인덱스 키 값은 이미 정렬되어 있으므로 별도의 정렬이 필요 없다**.
  * 이 경우에는 ORDER BY 절에 명시된 컬럼이 존재하지 않거나, PK와 관련이 있다.
* **조인을 실행하지 않고 정렬이 불가능한 경우, 조인을 실행하기 전에 드라이빙 테이블만 정렬한 후에 조인하는 것이 차선책**이다.
  * 이 경우에는 ORDER BY 절에 명시된 컬럼이 드라이빙 테이블에 존재하는 경우에 해당한다.
* **모든 방법이 불가능한 경우, 테이블을 조인한 결과를 임시 테이블에 저장하여 정렬하는 방식을 사용하며 이는 가장 느린 정렬 처리 방식에 해당**한다.
  * 이 경우에는 ORDER BY 절에 명시된 컬럼이 드리븐 테이블에 존재하는 경우에 해당한다.

## 2022-09-28 Wed
### LIMIT이 적용된 ORDER BY와 GROUP BY
* 일반적으로 **LIMIT 절은 ORDER BY 절과 함께 사용되는 경향이 있으며, 이는 테이블의 처리 결과 중 일부만 가져오므로 MySQL 서버의 작업량을 줄여준다**.
  * **그러나 ORDER BY 또는 GROUP BY 절은 WHERE 절의 조건을 만족하는 레코드를 LIMIT 절에 명시된 만큼만 가져와서 처리할 수는 없다**.
  * 때문에 **조건을 만족하는 레코드를 일단 모두 가져온 후에 정렬 또는 그룹화를 적용하고나서야 LIMIT 절을 활용한 개수 제한이 가능**해진다.
* 이렇듯 **WHERE 절이 아무리 인덱스를 잘 활용하도록 튜닝되었더라도 잘못 된 ORDER BY 또는 GROUP BY 절로 인해 쿼리는 느려지기 쉽다**.
* **쿼리 처리 방식은 다시 스트리밍 처리와 버퍼링 처리로 분류**될 수 있다.

### 스트리밍 처리 방식
* **스트리밍 방식은 MySQL 서버 측에서 처리할 데이터의 개수와 관계 없이 조건에 일치하는 레코드가 검색될 때마다 곧장 클라이언트로 전송**한다.
  * 스트리밍 방식에서 클라이언트는 쿼리를 요청하고 곧바로 원하는 첫 레코드를 전달 받는다.
  * 비록 마지막 레코드를 언제 전달 받을지는 알 수 없지만, 일반적으로 이는 그다지 중요하지 않다.
* 스트리밍 방식으로 쿼리가 처리되는 경우, 클라이언트는 MySQL 서버가 일치하는 레코드를 찾는 즉시 전달받으므로 동시에 데이터를 사용할 수 있다.
  * 스트리밍 방식으로 처리되는 쿼리는 쿼리가 얼마나 많은 레코드를 조회하는지와 관계 없이 빠른 응답 시간을 보장할 수 있다.
* 무엇보다도 **스트리밍 방식으로 처리되는 쿼리에서는 LIMIT 절과 같이 결과 건수를 제한하는 조건들이 쿼리의 전체 실행 시간을 크게 줄여줄 수 있다**.
  * **매우 큰 테이블을 조건절 없이 SELECT 한 것으로 인해 MySQL 서버 상에서 아직 쿼리가 실행되는 도중이더라도 첫 레코드는 매우 빠르게 가져올 수 있다**.
  * 이는 **풀 테이블 스캔의 결과가 아무런 버퍼링 또는 필터링 과정 없이 클라이언트로 즉시 스트리밍되기 때문**이다.
  * 때문에 **LIMIT 절을 쿼리에 추가하면 전체적으로 가져오는 레코드의 개수가 줄어들게 되므로, 마지막 레코드를 가져오기까지의 시간을 크게 줄일 수 있다**.

### 버퍼링 처리 방식
* **ORDER BY 또는 GROUP BY 절은 우선 WHERE 절 조건에 일치하는 모든 레코드를 조회한 후에 정렬하거나 그룹화하므로, 스트리밍 처리를 불가능하게 한다**.
  * 이 경우, **MySQL 서버에서 모든 레코드를 검색하고 정렬하는 동안 클라이언트는 아무 것도 하지 않고 기다리기에 응답 속도가 느려**진다.
* 이렇듯 **버퍼링 방식으로 처리되는 쿼리는 우선 결과를 스토리지 엔진으로부터 조회하여 모아둔 후에 MySQL 서버에서 일괄적으로 가공**한다.
  * 때문에 버퍼링 방식의 쿼리는 LIMIT 절과 같이 결과 수를 제한하는 조건이 명시되더라도 성능 향상에는 큰 도움을 줄 수 없다.
  * 이는 단지 네트워크로 전송되는 레코드의 개수만으 줄이며, 정작 MySQL 서버가 해야할 작업량에는 큰 변화를 주지 못한다.

### 스트리밍 처리와 버퍼링 처리로의 구분
* 상술한 **ORDER BY를 처리하는 세 가지 방식 중, 오로지 인덱스를 사용한 정렬 방식만이 스트리밍 형태로 처리**된다.
  * 반면, **조인 시 드라이브 테이블만 정렬하거나 임시 테이블을 활용하는 정렬 방식은 모두 버퍼링을 사용**한다.
* 때문에 **인덱스를 사용한 정렬 방식을 택하는 경우, LIMIT 절에 의해 제한된 건수만큼만 읽어 바로 클라이언트로 결과를 전송**할 수 있다.
  * 반면, 인덱스를 사용하지 못하는 경우는 필요한 모든 레코드를 디스크로부터 조회하여 정렬한 후에야 LIMIT 절에 명시된 만큼을 잘라 클라이언트애게 전송한다.
* 특히 **조인을 사용하는 경우, 어느 테이블이 드라이빙되어 조인되는지 보다는 어떤 정렬 방식을 적용하는지가 더 큰 성능 차이**를 만들 수 있다.
  1. **가능하다면 인덱스를 사용하는 정렬을 유도**한다.
  2. **그렇지 못하는 경우, 최소한 드라이빙 테이블만 정렬해도 되는 수준으로 유도**할 수 있어야 한다.
* 이렇듯 **인덱스를 사용하지 못하는 쿼리를 페이징 처리에 사용하는 경우, LIMIT 절을 명시하더라도 쿼리가 기대한 만큼 빨라지지는 않는다**.
  * 정확히는, filesort를 사용하는 작업에서도 LIMIT 절이 아무런 영향을 전혀 주지 못하는 정도는 아니다.

## 2022-09-29 Thu
### GROUP BY 절의 처리
* **GROUP BY 역시 ORDER BY 절과 마찬가지로 쿼리가 스트리밍될 수 없도록 하는 처리**이다.
  * 이 때, GROUP BY 절에서 사용할 수 있는 HAVING 절은 GROUP BY 결과에 대한 필터링 기능을 수행한다.
  * 그러나 **GROUP BY에서 사용된 조건 절은 인덱스를 사용하여 처리될 수 없으므로, HAVING 절을 튜닝하기 위한 시도는 필요가 없다**. 
* GROUP BY 절 역시 인덱스를 사용할 수 있는 경우와 그렇지 못한 경우로 다음과 같이 분류할 수 있다.
  1. 인덱스를 사용하는 경우: 인덱스를 차례대로 읽어나가는 인덱스 스캔과 인덱스를 건너 뛰어가며 조회하는 루스 인덱스 스캔이 가능하다.
  2. 인덱스를 사용하지 못하는 경우: **임시 테이블을 사용하여 처리**한다.

### 인덱스 스캔을 활용하는 GROUP BY 절 - 타이트 인덱스 스캔
* **ORDER BY 절과 마찬가지로 조인 시 드라이빙 테이블에 속한 컬럼만을 활용하여 그룹화하는 경우, 해당 컬럼에 대해 인덱스가 존재한다면 인덱스를 사용**한다.
  * 예를 들어 **해당 인덱스를 차례대로 읽어나가며 그룹화한 후에 그 결과를 통해 조인**한다.
  * 그러나 GROUP BY 절이 인덱스를 통해 처리되었다고 해도, 그룹 함수 등을 사용하는 경우 임시 테이블이 필요할 수도 있다.
* **GROUP BY 절이 인덱스를 통해 처리되는 경우, 이미 정렬된 인덱스를 읽어들이므로 쿼리 실행 시점에 별도의 정렬 또는 임시 테이블은 필요하지 않다**.
  * 때문에 쿼리의 실행 계획에서 Extra 컬럼에 별도의 코멘트는 표시되지 않는다.

### 루스 인덱스 스캔을 활용하는 GROUP BY 절
* 루스 인덱스 스캔은 인덱스의 레코드를 건너 뛰어가며 필요한 부분만 조회하는 것을 말한다.
  * 이 때, 옵티마이저가 루스 인덱스 스캔을 사용하는 경우 Extra 컬럼에 `Using index for group-by` 메시지가 표시된다.
* **MySQL의 루스 인덱스 스캔은 단일 테이블에 대해 수행되는 GROUP BY 절에 대해서만 사용될 수 있으며, 유니크한 값의 수가 적을수록 성능은 향상**된다.
  * 즉, 루스 인덱스 스캔은 분포도가 좋지 않은 인덱스일수록 더 좋은 결과를 낳을 수 있다.
  * 이는 **인덱스의 유니크한 값의 수가 많을수록 성능이 향상되는 인덱스 레인지 스캔과는 대비되는 특성**이다.
  * 또한, 컬럼의 앞 쪽 일부 값만으로 생성되는 프리픽스 인덱스로는 루스 인덱스 스캔을 사용할 수 없다.
* **루스 인덱스 스캔으로 쿼리가 처리되는 경우, 별도의 임시 테이블은 사용하지 않는다**.
* 이 때, 다음과 같은 조건은 루스 인덱스 스캔을 통한 GROUP BY 쿼리의 최적화가 불가능하다.
  1. **MIN() 또는 MAX() 이외의 SUM()과 같은 집합 함수가 사용된 경우**
  2. **GROUP BY 절에 사용된 컬럼이 인덱스 구성 컬럼의 왼쪽부터 적용된 컬럼의 순서와 일치하지 않는 경우**
  3. **SELECT 절에서 조회하는 컬럼이 GROUP BY 절과 일치하지 않는 경우** 

### 임시 테이블을 사용하는 GROUP BY 절
* **GROUP BY 절에서 명시한 대상 컬럼이 드라이빙 테이블에 있거나 그렇지 않거나, 인덱스를 전혀 사용하지 못하는 경우에는 해당 방식으로 처리**된다.
  * 이 경우, 쿼리 실행 계획의 Extra 컬럼에는 `Using temporary` 메시지가 표시되며 임시 테이블을 사용한다.
* **MySQL 8.0 이전 버전까지는 GROUP BY 절이 명시되는 경우 그룹화 대성 컬럼을 기준으로 정렬 역시 암시적으로 적용**되었다.
  * 때문에 이러한 암시적인 정렬이 필요하지 않은 경우 `ORDER BY NULL` 을 명시하였으며, 이를 통해 약간의 성능 향상을 이끌어낼 수 있었다.
  * 그러나 MySQL 8.0 버전 이후부터는 더 이상 암시적인 정렬은 적용되지 않는다.
* **MySQL 8.0 버전부터는 GROUP BY 절을 명시하는 경우, 내부적으로 그룹화 대성 컬럼들로 구성된 UQ 인덱스를 갖는 임시 테이블을 생성**하게 된다.
  * 이를 토대로 중복 제거와 집합 함수 연산을 적용하며, 기본적으로는 별도의 정렬 처리를 적용하지 않는다.
  * 정렬이 필요한 경우, ORDER BY 절을 함께 명시하는 것으로 실행 계획에서 `Using temporary; Using filesort` 메시지를 확인할 수 있다.

### DISTINCT 처리
```
> DISTINCT 절은 집합 함수 내에서 사용되는 경우와 그렇지 않은 경우에 대해 쿼리의 결과가 조금씩 다를 수 있다.
```
* DISTINCT 절은 임의 컬럼의 유니크한 값만을 조회하는 경우 SELECT 절에 명시할 수 있다.
* 또한, DISTINCT 절은 경우에 따라 크게 다음과 같이 분류할 수 있다.
  1. MIN(), MAX() 또는 COUNT()와 같은 집합 함수와 함께 사용하는 경우
  2. 또는 집합 함수와 함께 사용하지 않는 경우
* **집합 함수와 함께 사용되는 DISTINCT 절은 실행 계획에서 인덱스를 사용하지 못하는 경우 항상 임시 테이블을 사용**한다.
  * 반면, 이 경우 Extra 컬럼에 `Using temporary` 메시지가 표시되지 않는다.

### 집합 함수와 함께 사용되지 않는 DISTINCT 절
* 단순히 **SELECT 대상 레코드 중에서 유니크한 레코드만 조회하는 경우, `SELECT DISTINCT` 형태로 시작하는 쿼리를 사용**한다.
  * 이 경우에는 GROUP BY의 경우와 동일한 방식으로 처리된다.
* **SELECT 절에 사용되는 DISTINCT 절은 조회되는 모든 컬럼에 영향을 주며, 절대 SELECT 하는 여러 컬럼 중 일부 컬럼만을 유니크하게 조회하지 않는다**.
  * 이렇듯 DISTINCT는 둘 이상의 컬럼을 명시하는 것으로 컬럼의 조합이 유니크한 레코드만을 조회하는 방식으로 사용할 수 있다.

### 집합 함수와 함께 사용되는 DISTINCT 절
* **COUNT()나 MIN(), MAX()와 같은 집합 함수 내에서 사용되는 DISTINCT 절은 일반적인 `SELECT DISTINCT` 와는 다르게 해석**된다.
  * 예를 들어, **집합 함수가 없는 `SELECT DISTINCT` 절은 조회 대상 컬럼들의 유니크한 조합만을 조회**한다.
  * 반면, **집합 함수 내에서 사용된 DISTINCT 절은 해당 집합 함수의 인자로 전달된 컬럼 값이 유니크한 것만을 조회**한다.
* **일반적인 경우, 집합 함수와 함께 사용되는 DISTINCT 절은 처리를 위해 항상 임시 테이블을 사용**한다.
  * 그럼에도 실행 계획의 Extra 컬럼에는 항상 `Using temporary` 메시지를 표시하지 않는다.
  * **이러한 쿼리는 일반적으로 생성되는 임시 테이블에는 UQ 인덱스가 생성되므로, 레코드 건수가 많아질수록 상당히 느려질 수 있다**.
* **`COUNT(DISTINCT 컬럼1), COUNT(DISTINCT 컬럼2)`와 같이 집합 함수와 DISTINCT 절을 함께 사용하는 경우, 각각 임시 테이블을 생성**한다.
  * 즉, 상술한 쿼리는 컬럼1을 저장하기 위한 임시 테이블과 컬럼2를 저장하기 위한 임시 테이블을 각각 한 개씩, 총 2개 생성한다.
* 반면, **인덱스된 컬럼에 대해 DISTINCT 처리를 적용할 수 있는 경우에는 인덱스를 풀 스캔 또는 레인지 스캔하며 임시 테이블을 사용하지 않을 수 있다**.
  * 이 경우에는 임시 테이블을 사용하지 않으므로, 상대적으로 최적화된 쿼리의 처리가 가능하다.

## 2022-09-30 Fri
### MySQL 엔진의 내부 임시 테이블 활용
* MySQL 엔진은 스토리지 엔진으로부터 전달 받은 레코드를 정렬하거나 그룹화하기 위해서 내부적인 임시 테이블을 사용할 수 있다.
* 일반적으로 **MySQL 엔진이 사용하는 임시 테이블은 우선 메모리에 생성되고, 테이블의 크기가 커지면 디스크로 이동**된다.
  * 반면, 몇몇 상황에서는 메모리를 거치지 않고 바로 디스크에 생성될 수도 있다. 
* **MySQL 엔진이 데이터 가공을 위해 생성하는 임시 테이블은 사용자가 `CREATE TEMPORARY TABLE`과 같은 명령어로 생성하는 임시 테이블과는 다르다**.
  * 이러한 **임시 테이블은 다른 세션 또는 다른 쿼리에서는 상호작용이 불가능하며, 쿼리의 처리가 완료되는대로 자동 삭제**된다.

### 메모리 임시 테이블과 디스크 임시 테이블
* MySQL 8.0 이전 버전의 경우, 원본 테이블의 스토리지 엔진과는 관계 없이 임시 테이블은 다음과 같은 스토리지 엔진을 사용하였다.
  1. 메모리 임시 테이블: MEMORY
  2. 디스크 임시 테이블: MyISAM
* 반면, MySQL 8.0 버전부터는 다음과 같은 스토리지 엔진이 적용되도록 개선되었다.
  1. 메모리 임시 테이블: TempTable
  2. 디스크 임시 테이블: InnoDB

### 임시 테이블을 사용하는 쿼리
* 다음과 같은 종류의 쿼리는 MySQL 엔진에서 별도의 데이터 가공 작업이 필요하므로, 내부 임시 테이블을 생성하게 된다.
  1. ORDER BY 절과 GROUP BY 절에 명시된 컬럼이 다른 쿼리
  2. ORDER BY 절과 GROUP BY 절에 명시된 컬럼이 조인 순서상 첫 번째 테이블이 아닌 쿼리
  3. DISTINCT와 ORDER BY 절이 동시에 존재하는 경우에 DISTINCT 절이 인덱스로 처리되지 못하는 쿼리
  4. UNION 또는 UNION DISTINCT가 사용되어 select_type 컬럼이 UNION RESULT로 결정되는 쿼리
     * MySQL에서 UNION은 DISTINCT 절을 생략한 것으로 판단하므로, 결과적으로 둘은 동일한 기능이다.
     * 둘 모두 임의의 결과 집합으로부터 중복을 제거하는 작업이 필수적이므로 임시 테이블을 활용하는 중복 제거 작업을 거치게 된다.
     * UNION ALL의 경우 MySQL 8.0 이전 버전에서는 항상 내부 임시 테이블을 사용하였으나, 8.0 버전부터는 사용하지 않도록 개선되었다.
  5. 쿼리의 **실행 계획에서 select_type이 DERIVED인 쿼리**
* 이 밖에도 인덱스를 적절히 사용하지 못하는 경우에는 대부분 내부 임시 테이블을 생성하여 데이터를 가공하는 방식으로 동작한다.
* 상술한 쿼리 분류는 다시 다음과 같은 특징을 갖는다.
  1. 3., 4., 5. 패턴의 경우 Extra 컬럼에 `Using temporary` 메시지가 표시되지 않더라도 임시 테이블을 사용한다.
  2. 1., 2., 3., 4. 패턴의 경우 UQ 인덱스를 갖는 내부 임시 테이블을 생성한다.
  3. 5.의 경우 일반적으로 UQ 인덱스를 갖지 않는 내부 임시 테이블을 생성하며, 옵티마이저가 쿼리 성능 향상을 위해 인덱스를 생성하더라도 UQ 인덱스가 아니다.
* 또한, **일반적으로 UQ 인덱스를 갖는 내부 임시 테이블은 그렇지 않은 경우의 쿼리보다 처리 성능이 상당히 떨어진다**.

### 임시 테이블이 메모리에 생성되지 못하는 경우
```
> 임시 테이블은 기본적으로 메모리 기반으로 생성된다.
```
* 다음과 같은 조건을 만족하는 경우, 내부 임시 테이블은 메모리 상에 임시 테이블을 만들 수 없게 되어 디스크 기반의 임시 테이블을 사용하게 된다.
  1. UNION 또는 UNION ALL 에서 SELECT되는 **컬럼 중 길이가 512바이트 이상인 크기의 컬럼이 존재하는 경우**
  2. **GROUP BY 또는 DISTINCT 절에 명시된 컬럼에서 길이가 512바이트 이상인 크기의 컬럼이 존재하는 경우**
  3. 메모리 임시 테이블의 크기가 미리 설정된 시스템 변수의 값보다 큰 경우

### 임시 테이블과 관련된 상태 변수
* 실행 계획의 Extra 컬럼에 표시된 `Using temporary` 메시지를 통해 임시 테이블을 사용했다는 사실을 알 수 있다.
  * 그러나 **해당 정보만으로는 임시 테이블이 메모리 또는 디스크 중 어느 위치에 생성되었는지는 알 수 없으며, 사용된 임시 테이블의 개수 역시 알 수 없다**.
* 임시 테이블이 디스크 또는 메모리 중 어디에 생성되었고, 얼마나 생성되었는지 확인하고자 하는 경우 쿼리를 사용할 수 있다.
```
FLUSH STATUS; # 현재 세션의 상태 값을 초기화한다.
[확인하고자 하는 쿼리];
SHOW SESSION STATUS LIKE 'Created_tmp%'; # 쿼리 실행 직후의 상태를 조회한다.
```
* 상술한 쿼리로 인해 표시되는 정보는 각각 다음의 의미를 갖는다.
  1. `Created_tmp_tables`: **쿼리를 처리하기 위해 만들어진 내부 임시 테이블의 개수를 메모리 또는 디스크 기반 여부를 구분하지 않고 누적**한다.
  2. `Created_tmp_disk_tables`: **디스크 상에 만들어진 내부 임시 테이블의 개수만 누적**한다.

### 옵티마이저 옵션의 분류
* **MySQL 서버의 옵티마이저가 실행 계획을 수립하는 경우에는 통계 정보와 옵티마이저 옵션을 결합하여 최적의 실행 계획을 수립**한다.
  * 이 떄, **옵티마이저 옵션은 크게 조인과 관련된 옵티마이저 옵션과 옵티마이저 스위치로 구분**된다.
  * 이 중 조인과 관련된 옵티마이저 옵션은 신경쓰지 않는 경우가 많지만, 조인이 자주 사용되는 서비스에서는 유용하게 사용할 수 있다.
* **옵티마이저 스위치 옵션은 `optimizer_switch` 시스템 변수를 이용하여 제어할 수 있으며, 여러 옵션을 세트로 묶어 설정하는 방식으로 사용**된다.
  * 각 옵티마이저 스위치 옵션은 default와 on, off 중 하나를 설정할 수 있다.
  * on의 경우 옵션을 활성화하는 반면, default 옵션은 기본값을 적용한다.
* **옵티마이저 스위치 옵션은 글로벌 또는 세션 스코프에 적용할 수 있는 시스템 변수이므로, MySQL 서버 전체 또는 현재 커넥션에 대해서 설정이 가능**하다.
```
# MySQL 서버 전체에 옵티마이저 스위치를 설정하기
SET GLOBAL optimizer_switch='index_merge=on,index_merge_union=on'

# 현재 커넥션에 대해서만 옵티마이저 스위치를 설정하기
SET SESSION optimizer_switch='index_merge=on'
```
* 반면, `SET_VAR` 옵티마이저 힌트를 통해 현재 실행될 쿼리에만 설정하는 것도 가능하다.
```
SELECT SET_VAR(optimizer_switch='condition_fanout_filter=off') FROM ...
```

### 블록 네스티드 루프 조인
```
> 블록 네스티드 루프 조인은 MySQL 8.0.20 버전 이후로는 해시 조인 알고리즘으로 대체되었다. 
```
* MySQL 서버에서 사용되는 대부분의 조인은 네스티드 루프 조인이며, 이는 조인의 연결 조건이 되는 컬럼에 모두 인덱스가 있는 경우에 사용되는 방식이다.
  * 이러한 형태의 조인은 마치 중첩된 반복 명령어를 사용하는 것처럼 동작하기에 네스티드 루프 조인이라고 지칭한다.
  * **해당 방식은 레코드를 조회하여 다른 버퍼 공간에 저장하지 않고, 즉시 드리븐 테이블의 레코드를 찾아 반환**한다.
* 네스티드 루프 조인과 블록 네스티드 루프 조인의 차이는 크게 다음과 같이 분류된다.
  1. 조인 버퍼가 사용되는지 여부
  2. 조인에서 드라이빙 테이블과 드리븐 테이블이 조인되는 순서
* 이 때, **조인 쿼리의 실행 계획으로부터 Extra 컬럼의 `Using Join buffer` 라는 문구가 표시되는 것으로 조인 버퍼의 사용을 확인**할 수 있다.
* **조인은 드라이빙 테이블에서 일치하는 레코드의 건수만큼 드리븐 테이블을 검색하는 식으로 처리**된다.
  * 즉, **드라이빙 테이블은 한 번에 쭉 조회하되 드리븐 테이블은 여러 번 조회**하게 된다.
* 이 떄, 드라이빙 테이블에서 드리븐 테이블의 조인 조건이 인덱스를 사용할 수 없다면 반복적으로 풀 테이블을 스캔해야 할 수도 있다.
  * 즉, **드리븐 테이블의 검색 시 인덱스를 사용할 수 없는 쿼리는 상당히 느리므로 옵티마이저는 최대한 드리븐 테이블의 인덱스를 사용할 수 있도록 계획**한다.
* **어떠한 방식으로도 드리븐 테이블의 풀 테이블 스캔 또는 인덱스 풀 스캔을 피할 수 없는 경우, 옵티마이저는 조인 버퍼를 활용하도록 동작**한다.
  * 이 떄, **옵티마이저는 드라이빙 테이블에서 읽어들인 레코드를 우선 메모리의 조인 버퍼에 캐시한 후에 드리븐 테이블과 해당 메모리 캐시를 조인**한다.
  * 조인 버퍼는 시스템 변수로 크기를 제한할 수 있으며, 조인이 완료되는대로 조인 버퍼는 해제된다.
* 조인 버퍼를 사용하는 블록 네스티드 루프 조인은 다음과 같은 순서로 진행된다.
  1. 드라이빙 테이블의 인덱스를 활용하여 조건을 만족하는 레코드를 모두 검색한 후, 필요한 기타 컬럼을 모두 조회하여 조인 버퍼에 저장한다.
  2. 드리븐 테이블의 인덱스를 활용하여 조건을 만족하는 레코드를 검색한다.
  3. **2.의 과정에서 검색된 결과에 조인 버퍼에 캐시된 레코드를 결합하여 반환**한다.
* 이렇듯 **조인 버퍼가 사용되는 쿼리는 드리븐 테이블에서 검색된 레코드에 조인 버퍼의 드라이빙 테이블 레코드를 조인하는 식으로 처리**된다.
  * 즉, **실제 드라이빙 테이블의 결과는 우선 조인 버퍼에 캐시하고 드리븐 테이블을 읽은 후에 조인 버퍼에서 일치하는 레코드를 찾아나가는 식으로 처리**된다.
  * 때문에 조인 버퍼를 활용하는 조인은 일반적인 조인과 비교하여 조인 순서가 거꾸로된 것처럼 동작한다.
* 이로 인해 **조인이 수행된 후에 조회하는 결과는 기본적으로 드라이빙 테이블의 순서에 의해 결정되지만 조인 버퍼가 활용된 경우 정렬 순서가 바뀔 수 있다**.

## 2022-10-01 Sat
### 인덱스 컨디션 푸시다운
```
> 인덱스 컨디션 푸시다운은 쿼리의 WHERE 절 등에 포함된 조건들이 인덱스에 포함되는 경우, 이러한 조건을 모두 모아 스토리지 엔진으로 전달하는 기능이다.
> 인덱스 컨디션 푸시다운을 활용할 수 없는 경우, 인덱스에서 처리될 수 있는 조건만이 스토리지 엔진에 전달되어 불필요한 레코드를 조회할 가능성이 발생한다.
> 반면, 인덱스 컨디션 푸시다운을 활용할 경우 스토리지 엔진 차원에서 인덱스를 통해 모든 비교 조건을 필터링한 후에 레코드를 조회하여 불필요한 읽기가 최소화된다.   
```
* **인덱스 컨디션 푸시다운은 MySQL 5.6 버전부터 도입된 기능이며, 아주 복잡한 기능은 아니지만 쿼리의 성능을 수 배에서 수십 배까지 향상**시킬 수 있다.
  * **인덱스 컨디션 푸시다운이 적용되는 쿼리는 실행 계획의 Extra 컬럼에 `Using index condition` 메시지가 출력**된다.
* 우선 last_name과 first_name 순서로 인덱스가 추가된 employees 테이블에서 다음과 같은 쿼리를 실행한다고 가정한다.
```
SELECT * FROM employees WHERE last_name='Acton' AND first_name LIKE '%sal';
```
* 기본적으로 **상술한 쿼리의 WHERE 절에서 사용된 `first_name LIKE '%sal'` 조건은 인덱스 레인지 스캔으로 검색 대상 인덳스 범위를 좁힐 수 없다**.
  * 반면, last_name 조건은 인덱스 레인지 스캔을 사용할 수 있다.
  * 이로 인해 **first_name 조건은 우선 인덱스 레인지 스캔으로 읽어들인 데이터를 모두 하나씩 비교하는 식으로 활용**된다.
* **인덱스 컨디션 푸시다운을 사용할 수 없는 경우, 쿼리의 실행 계획 상 Extra 컬럼에는 `Using where` 메시지가 표시**된다.
  * 이는 **InnoDB 스토리지 엔진이 조회하여 반환해준 레코드가 인덱스를 사용할 수 없는 WHERE 조건에 부합하는지 검사하는 과정을 의미**한다.
* 이 때, **선행 조건에 부합하는 레코드가 10만 건인 반면 first_name 조건에 부합되는 레코드가 단 한 건인 경우, 대부분의 레코드 읽기는 불필요**하다.
  * 상술한 예시에서, 인덱스에서 일치하는 10만건의 레코드를 토대로 테이블로부터 모든 레코드를 읽어들인 후에 이를 하나씩 비교한다.
  * 즉, **이러한 단점은 전적으로 인덱스의 두 번째 컬럼인 first_name 컬럼을 활용하지 못하기 때문에 발생하는 문제**이다.
* **상술한 문제는 선행 조건에 부합하는 레코드를 테이블로부터 읽기 전에 후행 조건을 인덱스를 통해 우선 필터링하면 해결이 가능**하다.
  * 이 개념이 인덱스 컨디션 푸시 다운에 해당한다.

### 후행 조건의 처리 주체와 인덱스 컨디션 푸시 다운
* 상술한 문제의 경우, 후행 조건인 `first_name LIKE '%sal'` 조건을 어디에서 처리하느냐에 따라 비교 대상 컬럼의 위치가 변경된다.
  1. MySQL 엔진이 처리하는 경우: 스토리지 엔진을 통해 읽어들인 모든 레코드의 first_name 컬럼을 사용하여 비교하게 된다.
     * 때문에 **스토리지 엔진은 그저 MySQL 엔진이 요청한 모든 레코드를 조회하여 반환하는 수동적인 역할만을 수행**한다.
  2. 스토리지 엔진이 처리하는 경우: 인덱스의 first_name 컬럼을 사용하여 비교하게 된다.
     * 이 경우, **스토리지 엔진에 모든 인덱스 조건이 전달되므로 인덱스의 후행 조건을 활용하여 필요한 레코드만을 조회**할 수 있게 된다.
* MySQL 5.5 버전 이전에는 인덱스 레인지 스캔을 적용할 수 없는 first_name 조건은 MySQL 엔진이 스토리지 엔진으로 아예 전달하지 않았다.
  * 때문에 스토리지 엔진에서는 불필요한 테이블의 레코드를 조회하는 식으로 비효율적으로 동작할 수 밖에 없었다.
* **5.6 버전부터는 인덱스를 범위 제한 조건으로 사용할 수 없더라도 인덱스에 포함된 컬럼과 관련된 조건이 존재하는 경우 모두 스토리지 엔진으로 전달**한다.
  * 이렇게 핸들러 API가 개선된 것으로 스토리지 엔진은 인덱스를 활용하여 최대한 필터링까지 완료하여 꼭 필요한 레코드만 조회할 수 있다.

### 인덱스 확장
* **인덱스 확장이란, InnoDB 엔진을 사용하는 테이블에서 세컨더리 인덱스에 자동으로 추가되는 PK를 활용할지 결정하는 옵션**이다.
* InnoDB 스토리지 엔진은 PK를 클러스터링 키로 생성하므로, 모든 세컨더리 인덱스는 리프 노드에 PK 값을 갖는다.
* 때문에 임의의 테이블이 dept_no와 emp_no로 PK를 설정했다고 할 때, from_date 컬럼에 대해 추가된 인덱스는 다음과 같은 구조를 갖는 꼴이 된다.
  * **이는 완벽히 다음과 같이 생성된다는 의미가 아니며, 마치 이러한 인덱스가 생성된 것처럼 동작할 수 있다는 점을 의미**한다. 
```
> ix_fromdate(from_date, dept_no, emp_no)
```
* 이로 인해 **옵티마이저는 적절한 쿼리에 대해 `ix_fromdate` 인덱스의 끝에 dept_no와 emp_no 컬럼이 존재한다는 것을 인지하고 실행 계획을 수립**한다.
  * 적절한 쿼리의 예로, `SELECT COUNT(*) FROM dept_emp WHERE from_date='2000-01-01' AND dept_no='d001';`가 있다.
* 나아가 **InnoDB 테이블의 PK가 세컨더리 인덱스에 포함되는 점을 활용하면 ORDER BY 절을 사용하는 정렬 작업 역시 인덱스를 통해 처리**될 수 있다.
  * 이러한 **조건을 만족하는 경우, MySQL 서버는 별도의 정렬 작업 없이 인덱스 순서대로 레코드를 읽어들여 ORDER BY 절을 만족**시킬 수 있다.

### 인덱스 머지
* **인덱스를 활용하여 쿼리를 실행하는 경우, 대부분의 옵티마이저는 테이블 별로 하나의 인덱스만 사용하도록 실행 계획을 수립**한다.
  * 이렇듯 한 테이블에 대한 WHERE 조건이 여럿 존재하더라도 하나의 인덱스에 포함된 컬럼 조건만으로 인덱스를 검색하는 것이 일반적이다.
  * 이 경우, 인덱스를 통해 조회한 레코드에 대해 나머지 조건을 필터링하는 형태로 사용한다.
* **실제로도 단일 인덱스로 작업 범위를 충분하게 줄여나갈 수 있는 경우, 테이블 별로 하나의 인덱스만을 사용하는 것이 효율적**이다.
* 반면, **인덱스 머지 실행 계획은 단일 테이블에 대해 2개 이상의 인덱스를 활용하여 쿼리를 처리**하도록 한다. 
  * 쿼리의 각 조건이 별도의 인덱스를 사용할 수 있고, 조건을 만족하는 레코드 수도 많을 것으로 예상되는 경우 MySQL 서버는 인덱스 머지 실행 계획을 수립한다.
* 인덱스 머지 실행 계획은 크게 다음과 같은 세부 실행 계획으로 분류할 수 있으며, 각 방식 여러 인덱스를 통해 가져온 결과를 어떻게 병합할지에 따라 구분한다.
  1. 인덱스 머지 - 교집합
  2. 인덱스 머지 - 합집합
  3. 인덱스 머지 - 정렬 후 합집합

### 인덱스 머지 - 교집합
* 쿼리가 2개 이상의 WHERE 조건을 가질 때, 각 조건이 별도의 인덱스를 사용할 수 있는 경우를 가정한다.
* **옵티마이저는 각 인덱스 별로 쿼리를 처리했을 때 불필요한 레코드 읽기가 너무 많을 것으로 예상되는 경우, 인덱스 머지를 활용**한다.
  * 이는 **각 인덱스를 활용하여 조회한 레코드 수가 많고 적음이 아닌, 두 WHERE 조건을 모두 만족하는 레코드의 수가 적을 것으로 예상되는 경우를 의미**한다.
  * **이러한 경우, 옵티마이저는 각 인덱스를 검색하여 두 인덱스의 교집합만을 찾아 반환**한다.
* 그러나 **WHERE 절에 명시된 모든 조건을 만족하는 세컨더리 인덱스가 존재할 것으로 보이는 경우, 인덱스 머지 - 교집합 옵션을 비활성화**할 수 있다.
  * 예를 들어, WHERE 절에 두 조건이 명시되었으며 한 조건을 처리하기 위한 인덱스가 존재하고, 나머지 한 조건이 PK인 경우를 생각해볼 수 있다.
  * 상술했듯 **모든 세컨더리 인덱스는 후행 컬럼으로 PK를 암시적으로 포함하는 꼴이므로, 이러한 경우는 그냥 세컨더리 인덱스를 활용하는 것이 좋을 수 있다**.
```
# MySQL 서버 전체적으로 인덱스 머지 - 교집합 옵션을 제어하기
SET GLOBAL optimizer_switch='index_merge_intersection=off'
```
* 글로벌 옵션을 통해 MySQL 서버 전체적으로 해당 최적화 기법을 제어하는 것이 불안한 경우, 현재 커넥션 또는 현재 쿼리에 대해서만 비활성화해도 무방하다. 
```
# 현재 커넥션에 대해서만 인덱스 머지 - 교집합 옵션을 제어하기
SET SESSION optimizer_switch='index_merge_intersection=off'
# 현재 쿼리에 대해서만 인덱스 머지 - 교집합 옵션을 제어하기
SELECT SET_VAR(optimizer_switch='index_merge_intersection=off') FROM employees WHERE ...
```

## 2022-10-02 Sun
### 인덱스 머지 - 합집합
* **인덱스 머지의 합집합 최적화는 WHERE 절에서 사용된 둘 이상의 조건이 각각 인덱스를 사용하되 OR 로 연결된 경우에 사용되는 최적화 기법**이다.
  * 이 경우, 실행 계획의 Extra 컬럼에 명시되는 `Using union` 메시지가 표시된다.
  * 이는 인덱스 머지 최적화가 각 조건을 처리할 수 있는 인덱스의 검색 결과는 union 알고리즘으로 병합하는 식으로 동작한다.
* 이 때, **WHERE 절에 명시된 OR 조건을 충족하는 레코드가 있다는 것은 각 조건에 사용된 인덱스마다 중복되는 레코드가 반드시 존재함을 의미**한다.
  * 때문에 MySQL 서버는 반드시 두 결과의 합집합에서 중복을 제거하기 위해 우선 각 인덱스 별로 조회된 레코드 집합을 정렬해둘 필요가 있다.
  * 그러나 **실행 계획에는 정렬에 대한 정보가 표시되지 않으므로, 이는 MySQL 서버가 중복 제거를 위해 어떤 방법으로 이미 정렬을 해두었다는 것을 의미**한다.
* 상술했듯, **모든 세컨더리 인덱스의 리프 노드에는 반드시 PK 정보가 포함되므로 사실상 인덱스의 후행 컬럼으로는 항상 정렬된 PK가 포함되는 것**과 같다.
  * **MySQL 서버 역시 이를 알고 있으며, OR 로 연결된 각 조건을 처리하는 인덱스에 정렬된 후행 컬럼인 PK 컬럼을 활용하여 중복을 제거**한다.
* 때문에 MySQL 서버는 각 조건 별 인덱스로부터 조회한 레코드 집합을 서로 비교하며, PK가 중복되는 레코드들을 별도의 정렬 과정 없이도 제거할 수 있다.
  * 이 때, **정렬된 두 집합의 결과를 하나씩 가져와 중복 제거를 수행하기 위해 MySQL 서버는 우선순위 큐 알고리즘을 사용**한다.

### SQL 문장에서의 AND와 OR의 차이
* **두 조건이 AND 연산자로 연결되는 경우, 두 조건 중 하나라도 인덱스를 사용할 수 있는 경우에는 인덱스 레인지 스캔으로 쿼리가 처리**된다.
  * 반면, **둘 이상의 WHERE 조건이 OR 연산자로 연결되는 경우 조건 중 하나라도 인덱스를 사용하지 못하면 반드시 풀 테이블 스캔으로 처리**된다.

### 인덱스 머지 - 정렬 후 합집합
* 상술한 바와 같이, 인덱스 머지 최적화 중 합집합 알고리즘은 두 결과 집합의 중복을 제거하기 위해 정렬을 필요로 하지만 별도의 정렬 과정을 수행하지는 않는다.
* 그러나 **모든 경우에 이렇듯 이상적인 쿼리 실행이 가능한 것은 아니며, 때로는 인덱스 머지 작업을 처리하는 도중 결과의 정렬이 필요할 수 있다**.
  * 이 경우, MySQL 서버는 인덱스 머지 최적화 중 Sort union 알고리즘을 적용한다.
  * 해당 최적화 기법을 통해 처리되는 쿼리의 경우, 실행 계획의 Extra 컬럼에는 `Using sort_union` 메시지가 표시된다.
* **WHERE 절에 복합적인 조건이 명시된 경우, 각 조건을 처리하기 위한 인덱스로부터의 조회 결과의 PK 값이 정렬되어 있지 않을 수도 있다**.
  * 예를 들어 `hire_date BETWEEN '2000-01-01' AND '2020-01-01'` 조건의 경우 선행 컬럼이 우선 정렬되므로 전체 레코드의 PK는 정렬되지 않는다.
  * 이러한 경우에 **MySQL 서버는 두 집합의 결과로부터 중복을 제거하기 위해 우선 각 집합을 PK 컬럼 기준으로 정렬한 후에 중복 제거를 수행**한다.

### 파생 테이블이란?
```
> 파생 테이블, 또는 Derived Table은 FROM 절에 사용된 서브쿼리를 처리하기 위해 내부적으로 생성되는 임시 테이블이다.
```
* **이전 버전의 MySQL 서버에서는 FROM 절에 사용된 서브쿼리를 우선 실행한 후에 그 결과를 임시 테이블로 만들고, 그 후에 다음 외부 쿼리 부분을 처리**했다.
  * **MySQL 서버에서는 이렇듯 FROM 절에 사용되는 서브쿼리를 파생 테이블, 또는 `Derived Table` 이라고 지칭**한다.
  * 파생 테이블이 사용되는 경우, 우선 FROM 절에 사용된 서브쿼리를 처리하여 임시 테이블을 생성한 후에 해당 임시 테이블을 활용하여 쿼리를 처리한다.
  * 또한, **파생 테이블이 사용되는 쿼리의 실행 계획에서는 select_type 컬럼에 `DERIVED` 메시지를 확인**할 수 있다.
* 그러나 파생 테이블은 본질적으로 임시 테이블이므로, 이를 사용하는 경우 다음과 같은 문제에 직면할 수 있다.
  1. **내부적으로 임시 테이블을 생성하고, 서브쿼리를 처리한 결과를 임시 테이블에 저장하고, 외부 쿼리에서 이를 다시 읽어들이는 과정에서 오버헤드가 크다**.
  2. **내부적으로 임시 테이블은 최초에는 메모리에 생성되지만, 저장될 레코드의 수가 많아지면 결국에는 디스크로 다시 기록**된다.
* 이렇듯 **파생 테이블이 메모리에 상주할 만큼 크기가 작다면 성능에 영향을 주지 않지만, 레코드가 많아질수록 오버헤드로 인해 쿼리의 성능은 크게 저하**된다.

### 파생 테이블 머지 - derived_merge
* **MySQL 5.7 버전부터는 파생 테이블이 생성되는 서브쿼리를 내부적으로 외부 쿼리와 병합하여 서브쿼리 자체를 제거하는 최적화 기법이 도입**되었다.
  * 해당 최적화 기법을 사용하는 실행 계획에서는 select_type 컬럼에서 `DERIVED` 메시지가 표시되지 않는다.
* 이전 버전의 경우, 서브쿼리로 작성된 쿼리를 외부 쿼리로 병합하는 최적화는 DBA에 의해 수작업으로 진행되는 경우가 많았다.
  * 반면 최신 버전의 MySQL 서버에서는 상당 수의 병합 작업을 옵티마이저가 대신 처리하므로, 굳이 쿼리를 다시 작성할 필요가 없다.
  * 그러나 여전히 옵티마이저가 모든 서브쿼리를 외부 쿼리로 병합할 수 있는 것은 아니다.
* **다음과 같은 조건에서 옵티마이저는 서브쿼리를 자동으로 외부 쿼리로 병합할 수 없으므로, 이 경우에는 수작업으로 처리하여 쿼리의 성능을 향상**시킬 수 있다.
  1. SUM()이나 MIN(), MAX()와 같은 집계 함수 또는 윈도우 함수가 사용되는 서브쿼리
  2. DISTINCT가 사용되는 서브쿼리
  3. GROUP BY 또는 HAVING 절이 사용되는 서브쿼리
  4. LIMIT이 사용되는 서브쿼리
  5. UNION 또는 UNION ALL 절이 포함되는 서브쿼리
  6. SELECT 절에 사용되는 서브쿼리
  7. 값이 변경될 수 있는 사용자 변수가 사용되는 서브쿼리

### 인비저블 인덱스
```
# 옵티마이저가 ix_hiredate 인덱스를 사용할 수 없도록 한다.
ALTER TABLE employees ALTER INDEX ix_hiredate INVISIBLE;
# 옵티마이저가 ix_hiredate 인덱스를 사용할 수 있도록 한다.
ALTER TABLE employees ALTER INDEX ix_hiredate VISIBLE;
```
* MySQL 8.0 버전부터는 인덱스의 가용성을 제어할 수 있는 기능이 추가되었다.
  * 이전 버전의 경우, 인덱스가 존재한다면 옵티마이저는 실행 계획을 수립할 때 해당 인덱스를 항상 검토하고 사용 여부를 결정했다.
  * 그러나 8.0 버전부터는 인덱스를 삭제하지 않고도 해당 인덱스를 사용하지 못하도록 제어할 수 있는 기능을 제공한다.
* `use_invisible_index` 옵티마이저 옵션을 활용할 경우, 가용성이 INVISIBLE로 설정된 인덱스도 옵티마이저가 사용하도록 제어할 수 있다.
  * 해당 옵션의 기본 값은 off이며, 이를 on으로 활성화하는 것으로 옵티마이저가 INVISIBLE 상태의 인덱스도 활용할 수 있도록 설정할 수 있다.

## 2022-10-03 Mon
### 스킵 스캔
```
> B-Tree 인덱스의 핵심은 값이 정렬되어 있다는 점에 있으며, 이로 인해 인덱스를 구성하는 컬럼의 순서는 매우 중요하다.
```
* (A, B, C) 컬럼으로 구성된 인덱스의 경우, WHERE 절에서 A와 B에 대한 조건이 있다면 해당 인덱스를 사용할 수 있으나 B와 C에 대한 조건은 사용할 수 없다.
  * 이 때, 기본적으로 WHERE 절에서 B와 C에 대한 조건을 사용하는 쿼리가 인덱스를 사용하도록 하려면 해당하는 인덱스를 새로 만들어야 했다. 
  * 이렇듯 **인덱스는 정렬되는 특징으로 인해 컬럼의 순서를 신중히 결정하여야 한다**.
* MySQL 8.0 버전에서 도입된 **인덱스 스킵 스캔 최적화 기법은 제한적으로나마 이러한 인덱스의 제약을 뛰어넘도록 한다**.
  * 해당 기능은 선행 컬럼이 조건절에 사용되지 않더라도 후행 컬럼의 조건만으로 인덱스를 사용하도록 한다.
* **옵티마이저는 테이블에 존재하는 모든 선행 컬럼의 유니크한 값을 가져와 마치 후행 컬럼의 조건과 선행 컬럼의 조건이 함께 하는 것처럼 쿼리를 최적화**한다.
  * 이로 인해 **인덱스의 선행 컬럼의 분포도가 매우 중요하며, 선행 컬럼이 지나치게 다양한 값을 갖는 경우에는 해당 최적화 기법을 사용하지 않는다**.
  * 이렇듯 옵티마이저는 인덱스의 선행 컬럼이 소수의 유니크한 값을 갖는다고 판단되는 경우에만 해당 최적화 기법을 적용한다.

### 해시 조인과 네스티드 루프 조인
* 해시 조인은 MySQL 8.0.18 버전에서 도입된 기법이며, 네스티드 루프 조인과 비교하여 다음과 같은 특징을 갖는다.
  1. 네스티드 루프 조인: **마지막 레코드까지 모두 찾아내는 데에 상대적으로 오랜 시간이 걸리나, 첫 레코드를 조회하기까지의 시간은 훨씬 빠르다**.
  2. 해시 조인: **첫 레코드를 찾는 데에 시간이 오래 걸리나, 마지막 레코드를 찾아내기까지는 시간이 오래 걸리지 않는다**.
* 이러한 이유에서 **네스티드 루프 조인은 최고 응답 속도 전략에 적합한 반면, 해시 조인은 최고 스루풋 전략에 적합**하다.
  * **일반적인 웹 서비스는 OLTP 서비스이므로 스루풋보다는 응답 속도에 더 가치를 두는 것이 바람직**하다.
  * 반면, 분석 서비스는 사용자의 응답 시간보다 전체적인 처리 시간이 더 중요하므로 전체 스루풋에 가치를 두는 것이 바람직하다.
* **MySQL은 OLTP를 위한 범용 RDBMS이므로, 전체 스루풋보다는 응답 속도에 가치를 두는 것이 바람직**하다.
  * 이러한 이유에서 **MySQL 서버는 네스티드 루프 조인이 사용되기에 적합하지 않은 경우를 위한 차선책으로서 해시 조인을 사용**한다.
  * 같은 이유에서, **항상 더 좋을 것이라는 착각으로 쿼리의 실행 계획을 해시 조인으로 강제하는 것은 바람직하지 않다**.

### 블록 네스티드 루프 조인과 해시 조인
* MySQL 8.0.17 버전까지는 해시 조인이 없었으므로, 조인 조건이 좋지 않은 경우에는 블록 네스티드 루프 조인 알고리즘을 사용했다.
  * 해당 알고리즘은 쿼리의 조인 조건이 인덱스를 제대로 활용하지 못하는 경우에만 사용되었으므로, 잘 설계된 인덱스 아래에서는 거의 볼 수 없었다.
* MySQL 8.0.20 버전부터는 블록 네스티드 루프 조인을 더 이상 사용하지 않고, 네스티드 루프 조인을 사용할 수 없는 경우에는 항상 해시 조인을 사용한다.
  * 반면, 8.0.18 ~ 19 버전까지는 동등 조인에서만 해시 조인을 사용하고 안티 조인이나 세미 조인을 위해 블록 네스티드 루프 조인을 사용했다.

### 해시 조인의 동작 방식
* 일반적으로 해시 조인은 빌드 단계와 프로브 단계로 나뉘어 처리되며, 각 단계는 다음과 같이 요약할 수 있다.
  1. 빌드: **조인 대상 테이블 중 레코드 수가 적어 해시 테이블로 만들기 용이한 테이블을 골라 메모리 상의 위치하는 조인 버퍼에 해시 테이블을 빌드**한다.
  2. 프로브: **나머지 테이블의 레코드를 읽어가며 메모리 상에 생성해둔 해시 테이블로부터 일치하는 레코드를 찾아나가는 과정을 의미**한다.
* 조인 버퍼에 저장되기에는 해시 테이블의 레코드가 너무 많은 경우, MySQL 서버는 빌드 테이블과 프로브 테이블을 청크로 분리하여 디스크에 저장하여 처리한다.
  * 이렇게 **나뉘어진 청크는 각각의 청크 별로 상술한 일반적인 해시 조인의 과정과 동일한 방식으로 처리**해나간다.
* 옵티마이저는 빌드 테이블의 크기에 따라 해시 조인이 가능한 경우에는 클래식 해시 조인 알고리즘을 사용한다.
  * 반면, 해시 테이블이 조인 버퍼의 메모리보다 커 해시 조인 1차 처리를 진행하는 경우에는 그레이스 해시 조인 알고리즘을 사용한다.
  * 이렇듯 MySQL 서버는 해시 조인 과정에서 알고리즘을 하이브리드하게 사용하도록 적용되어 있다.

### 인덱스 정렬 선호
* 옵티마이저는 기본적으로 ORDER BY 또는 GROUP BY 절을 인덱스로 처리 가능한 경우, 쿼리의 실행 계획에서 해당 인덱스의 가중치를 높이 설정하였다.
* 그러나 이로 인해 옵티마이저가 종종 잘못된 실행 계획을 선택할 가능성이 있다.
  * MySQL 8.0.20 버전 이전까지는 옵티마이저의 실수를 방지하기 위해 IGNORE INDEX 힌트를 사용하였다.
  * 그러나 8.0.21 버전부터는 옵티마이저가 ORDER BY 절에서 사용하는 인덱스에 너무 가중치를 부여하지 않도록 인덱스 정렬 선호 옵티마이저 옵션이 추가되었다.
* **옵티마이저가 잦은 실수를 범하는 경우, 다음과 같이 입력하여 인덱스 정렬 선호 옵션을 비활성화**할 수 있다.
```
# 현재 커넥션에서만 인덱스 정렬 선호 기능을 비활성화
SET SESSION optimizer_switch='prefer_ordering_index=OFF';
```

### 조인 최적화 알고리즘의 종류
* MySQL은 조인 쿼리의 실행 계획 최적화를 위한 알고리즘이 다음과 같이 두 종류 존재한다.
  1. Exhaustive 검색 알고리즘
  2. Greedy 검색 알고리즘
* MySQL의 조인 최적화는 많이 개선되었으나, 테이블의 개수가 많아지면 최적화된 실행 계획을 찾는 것이 상당히 어려워질 수 있다.
  * 예를 들어, 단일 쿼리에서 조인되는 테이블의 개수가 많아지면 실행 계획을 수립하기 위한 시간이 크게 늘어날 수 있다.
  * 이러한 문제를 해결하기 위해서는 조인 최적화 알고리즘 별 특징을 이해할 필요가 있다.

### Exhaustive 검색 알고리즘
```
> Exhaustive 검색 알고리즘은 MySQL 5.0 이전 버전에서 사용되던 조인 최적화 기법이다.
```
* 해당 검색 알고리즘은 FROM 절에 명시된 모든 테이블의 조합에 따른 실행 계획의 비용을 계산하여 최적의 조합 1개를 찾아낸다.
  * 즉, 빅오 표기법으로 표기한 시간 복잡도는 `O(n!)`이 된다.
  * 때문에 **해당 검색 알고리즘을 활용하면 조인 대상 테이블이 늘어날수록 실행 계획을 수립하기 위해 필요한 시간 역시 기하급수적으로 증가**한다.

### Greedy 검색 알고리즘
* **Greedy 검색 알고리즘은 Exhaustive 검색 알고리즘의 단점을 해소하고자 MySQL 5.0 버전에서 도입된 조인 최적화 기법**이다.
  * 해당 알고리즘은 Exhaustive 검색 알고리즘보다는 더 복잡한 형태로 최적의 조인 순서를 결정한다.
* Greedy 검색 알고리즘이 동작하는 방식은 다음과 같이 정리할 수 있다.
  1. 전체 N 개의 조인 대상 테이블 중, `optimizer_search_depth` 시스템 변수에 정의된 개수로 가능한 테이블 조인 조합을 모두 생성한다.
  2. **생성된 조합 중 최소 비용의 실행 계획을 하나 선택하고, 해당 실행 계획의 첫 번째 테이블을 부분 실행 계획의 첫 테이블로 설정**한다.
  3. 전체 N 개의 조인 대상 테이블 중 2.의 과정에서 선택한 테이블을 제외한 N-1개의 테이블로 생성 가능한 조인 조합을 생성한다.
     * 해당 과정에서도 `optimizer_search_depth` 시스템 변수에 설정된 개수의 테이블로 가능한 조인 조합만을 생성한다.
  4. **생성된 조인 조합 중, 2.의 과정에서 생성한 부분 실행 계획에 대입했을 때 가장 적은 비용을 갖는 실행 계획의 첫 테이블을 부분 실행 계획에 추가**한다.
  5. **남은 테이블이 모두 제거될 때까지 3. ~ 4.의 과정을 반복하며 부분 실행 계획에 테이블의 조인 순서를 기록**해 나간다.
  6. **최종적으로 완성된 부분 실행 계획을 테이블의 조인 순서로 결정**한다.

### 조인 최적화를 위한 시스템 변수
* 또한, MySQL에서는 조인 최적화를 위해 시스템 변수로 `optimizer_prune_level`과 `optimizer_search_depth`를 제공한다.
  * `optimizer_prune_level`의 경우, MySQL 5.0부터 추가된 Heuristic 검색이 동작하는 방식을 제어한다.
  * `optimizer_search_depth`의 경우, Greedy와 Exhaustive 검색 알고리즘 중 어떠한 것을 사용할지를 결정한다.
* MySQL 8.0 버전의 경우, 조인 최적화가 많이 개선되어 `optimizer_search_depth` 변수의 값에는 크게 영향받지 않는다.
  * 그러나 `optimizer_prune_level`의 경우 0으로 설정했을 때 `optimizer_search_depth` 의 값 변화에 따라 실행 계획 수립 시간이 급증할 수 있다.
* 이전 버전에서는 조인 최적화와 관련된 휴리스틱에 문제점이 있었으나, 8.0 버전부터는 이러한 조인 최적화와 관련한 휴리스틱을 비활성화할 필요가 거의 없어졌다.
  * 또한 **`optimizer_prune_level` 변수의 기본값은 1이므로 조인과 관련된 시스템 변수의 조절은 더 이상 필요하지 않을 것으로 보여진다**. 
# Basics
## 2022-09-14 Wed

### MySQL 서버의 구조
* **MySQL 서버는 사람으로 따지면 머리 역할을 담당하는 MySQL 엔진과 손 발 역할을 수행하는 스토리지 엔진으로 구분**할 수 있다.
  * 이 때, 스토리지 엔진은 핸들러 API를 만족하기만 한다면 누구나 직접 구현하여 MySQL 서버에 추가할 수 있다.
  * 또한 **MySQL 엔진과 스토리지 엔진을 합쳐 MySQL 또는 MySQL 서버라는 용어로 지칭**한다.
* MySQL은 일반적인 상용 RDBMS와 같이 대부분의 프로그래밍 언어로부터의 접근 방법 역시 모두 지원한다.
  * 이로 인해 C는 물론 JDBC, 파이썬 등 많은 언어를 통해 MySQL 서버에서 쿼리를 사용할 수 있다.
* MySQL 서버는 MySQL 엔진에 더해 스토리지 엔진으로서 기본적으로 InnoDB와 MyISAM을 제공한다.

### MySQL 엔진의 특징
```
> MySQL 엔진은 요청된 SQL 문장을 분석하거나 최적화하는 등 DBMS의 두뇌에 해당하는 처리를 수행한다.
```
* MySQL 엔진은 클라이언트로부터 발생하는 접속 및 쿼리 요청을 처리하는 커넥션 핸들러에 더해 다음과 같은 분류를 갖는다.
  1. SQL 파서 및 전처리기
  2. 쿼리의 최적화된 실행을 위한 SQL 옵티마이저
  3. SQL 인터페이스
  4. 캐시와 버퍼
* 또한, **MySQL은 표준 SQL인 ANSI SQL 문법을 지원하므로 표준 문법에 따라 작성된 쿼리는 다른 DBMS와 호환되어 실행**될 수 있다.

### 스토리지 엔진의 특징
```
> 스토리지 엔진은 실제 데이터를 디스크에 저장하거나, 디스크로부터 데이터를 읽어오는 역할을 담당한다.
> MySQL 서버에서 MySQL 엔진의 종류는 단 하나지만, 스토리지 엔진은 여러 종류를 동시에 사용할 수 있다.
```
* **테이블 생성시 사용할 스토리지 엔진을 명시하는 경우, 이후에 해당 테이블로부터 발생하는 모든 읽기 또는 변경 작업은 정의된 스토리지 엔진에 의해 처리**된다.
  * 예를 들어, `CREATE TABLE table_name (id INT) ENGINE=InnoDB`와 같은 형태로 명시한다.
  * 상술한 쿼리에서, 이후의 모든 INSERT / UPDATE / DELETE /SELECT 등의 작업은 InnoDB 스토리지 엔진에 의해 처리된다.
* 이 때, **각각의 스토리지 엔진은 성능 향상을 위해 키 캐시 또는 버퍼 풀과 같은 기능을 내장**한다.
  1. 키 캐시: MyISAM 스토리지 엔진에서 성능 향상을 위해 사용하는 기능이다.
  2. **버퍼 풀: InnoDB 스토리지 엔진에서 성능 향상을 위해 사용하는 기능**이다.

### Handler API
* MySQL 엔진의 쿼리 실행기에서 실제 데이터를 읽거나 쓰는 경우 각각의 스토리지 엔진에 쓰기 또는 읽기 작업을 요청해야 한다.
  * 이 때, **이러한 요청을 핸들러 요청이라고 하며 각 경우에 사용되는 API를 핸들러 API**라고 한다.
  * InnoDB 스토리지 엔진 역시 이러한 핸들러 API를 활용하여 MySQL 엔진과 데이터를 주고받는다.
* 핸들러 API를 활용하여 얼마나 많은 레코드 작업이 있었는지 확인하고자 하는 경우, 다음과 같은 명령어를 활용할 수 있다.
```
SHOW GLOBAL STATUS LIKE 'Handler%';
```

## 2022-09-15 Thu
### MySQL 서버 스레딩
* **MySQL 서버는 프로세스 기반이 아닌 스레드 기반으로 동작하며, 스레드는 다시 포그라운드 스레드와 백그라운드 스레드로 구분**할 수 있다.
* 이 때, MySQL 서버에서 실행 중인 스레드의 목록은 `performance_schema` 데이터베이스의 `threads` 테이블을 통해 확인할 수 있다.
  * 이 중 백그라운드 스레드의 개수는 MySQL 서버의 설정 내용에 따라 가변적이다.
  * 또한, 여러 스레드가 동일 작업을 병렬로 처리하는 경우 동일한 이름의 스레드가 존재할 수도 있다.
* **이러한 스레드 모델은 MySQL 커뮤니티 에디션이 갖는 전통적인 스레드 모델이며, 커넥션 별로 포그라운드 스레드를 하나씩 생성하는 1:1 관계를 유지**한다.
  * 반면, MySQL 엔터프라이즈 에디션은 스레드 풀 모델을 사용하며 하나의 스레드가 여러 개의 커넥션 요청을 처리한다.

### 포그라운드 스레드
* **포그라운드 스레드는 클라이언트 스레드라고도 하며, 최소한 MySQL 서버에 접속된 클라이언트 수만큼 존재**한다.
  * 포그라운드 스레드는 주로 각각의 클라이언트 사용자가 요청하는 쿼리를 처리한다.
* **클라이언트 사용자가 작업을 마치고 커넥션을 종료할 경우, 해당 커넥션을 담당하던 스레드는 스레드 캐시로 돌아간다**.
  * 이 때, 이미 스레드 캐시에 일정한 개수 이상의 스레드가 존재하는 경우 스레드 캐시에 넣지 않고 스레드를 종료한다.
  * 이렇듯 일정 개수의 스레드만이 스레드 캐시에 존재하게 하며, 이러한 스레드의 최대 개수는 `thread_cahce_size` 시스템 변수로 설정할 수 있다.
* **포그라운드 스레드는 기본적으로 데이터를 MySQL의 데이터 버퍼나 캐시로부터 조회**한다. 
  * 만약 **버퍼나 캐시에 필요한 데이터가 없는 경우, 직접 디스크 데이터나 인덱스 파일로부터 조회하여 작업을 처리**한다.
  * 이 때, MyISAM의 경우 디스크 쓰기 작업까지 포그라운드 스레드가 처리한다.
  * 반면, **InnoDB 경우 데이터 버퍼나 캐시까지만 포그라운드 스레드가 처리하고 버퍼로부터 디스크에 기록하는 나머지 작업은 백그라운드 스레드가 처리**한다.

### 사용자 스레드와 포그라운드 스레드
* MySQL에서 사용자 스레드와 포그라운드 스레드는 같은 의미로 사용된다.
* **클라이언트가 MySQL 서버에 접속하는 경우 MySQL 서버는 해당 클라이언트의 요청을 처리할 스레드를 생성하여 해당 클라이언트에게 할당**한다.
  * **해당 스레드는 DBMS의 앞단에서 클라이언트인 사용자와 통신하므로 포그라운드 스레드라는 용어로 지칭**한다.
  * 또한, **사용자가 요청한 작업을 처리하는 스레드이기에 사용자 스레드라고도 지칭**할 수 있게 된다.

### 백그라운드 스레드
* InnoDB의 경우, 다음과 같은 작업은 백그라운드로 처리된다.
  1. 인서트 버퍼를 병합하는 스레드
  2. 로그를 디스크로 기록하는 스레드
  3. InnoDB 버퍼 풀의 데이터를 디스크에 기록하는 스레드
  4. 데이터를 버퍼로 읽어들이는 스레드
  5. 잠금 또는 데드락을 모니터링하는 스레드
* 모두 중요하지만, 이 중 **특히 중요한 것은 로그 스레드와 버퍼의 데이터를 디스크로 써내려가는 쓰기 스레드**가 된다.
* InnoDB의 경우 데이터를 읽는 작업을 주로 클라이언트 스레드에서 처리하므로, 읽기 스레드는 굳이 많이 설정할 필요가 없다.
  * 그러나 **쓰기 스레드는 많은 작업을 백그라운드에서 처리하므로 환경에 따라 디스크를 최적으로 사용할 수 있을 정도로 충분히 설정하는 것이 바람직**하다.
* 사용자의 **요청을 처리하는 도중 데이터의 쓰기 작업은 버퍼링과 같이 지연 처리될 수 있으나, 데이터의 읽기 작업은 절대로 지연되지 않아야 한다**.
  * 이로 인해 **대부분의 상용 DBMS에서는 대부분 쓰기 작업을 버퍼링하여 일괄 처리하는 기능이 탑재되어 있으며, InnoDB 역시 마찬가지 방식으로 동작**한다.

### 메모리 할당과 구조
* **MySQL에서 사용되는 메모리는 크게 글로벌 메모리 영역과 로컬 메모리 영역으로 구분되며, 둘의 차이는 많은 스레드가 공유하는 공간인지 여부**에 따른다.
  * 특히 글로벌 메모리 영역의 모든 메모리 공간은 MySQL 서버가 시작되면서 운영체제로부터 할당된다.
  * 이 때, **각각의 운영체제 별 메모리 할당 방식은 상당히 복잡하므로 MySQL 서버가 사용하는 정확한 메모리 양을 측정하는 것은 쉽지 않다**.

### 글로벌 메모리 영역
* **일반적으로 클라이언트 스레드의 수와는 관계 없이 하나의 메모리 공간만이 할당**된다.
  * 필요한 경우 2개 이상의 메모리 공간을 할당받을 수도 있지만, 이 역시도 클라이언트 스레드의 개수와는 관계가 없다.
  * 또한, **생성된 글로벌 영역이 2개 이상이라고 하더라도 항상 모든 스레드에 의해 공유**된다.
* 이 때, 글로벌 메모리 영역은 크게 다음과 같이 분류된다.
  1. 테이블 캐시
  2. InnoDB 버퍼 풀
  3. InnoDB 어댑티브 해시 인덱스
  4. InnoDB 리두 로그 버퍼

### 로컬 메모리 영역
* 로컬 메모리 영역은 MySQL 서버 상에 존재하는 클라이언트 스레드가 쿼리를 처리하기 위해 사용하는 메모리 영역이다.
  * **클라이언트가 MySQL 서버에 접속하는 경우 MySQL 서버는 클라이언트 커넥션으로부터의 요청을 처리하기 위해 스레드를 각각 할당**한다.
  * 이러한 클라이언트 스레드가 사용하는 메모리 공간이므로 클라이언트 메모리 영역이라고도 하며, 커넥션을 세션이라고 표현하여 세션 메모리 영역이라고도 한다.
* **로컬 메모리 영역은 각각의 클라이언트 스레드 별로 독립적으로 할당되며, 절대 스레드 간에 공유되어 사용되지 않는다**.
  * 로컬 메모리 영역의 크기 역시 적절히 설정되어야 하며, 그렇지 않은 경우 MySQL 서버가 메모리 부족으로 인해 멈출 가능성이 희박하게나마 존재한다.
* 또한, **로컬 메모리 영역에는 각 쿼리의 용도 별로 필요할 경우에만 공간이 할당**된다.
  * 이는 즉, **쿼리의 용도에 따라서는 MySQL 서버가 메모리 공간을 전혀 할당하지 않을 수도 있다는 점을 시사**한다.
  * 예를 들어, 소트 버퍼 또는 조인 버퍼가 이러한 경우에 해당한다.
* **로컬 메모리 영역은 커넥션이 유지되는 동안 계속 할당된 상태로 남아 있는 공간과, 쿼리가 실행되는 순간에만 할당하고 이후에 해제되는 공간도 존재**한다.
  * 예를 들어, **커넥션 버퍼와 결과 버퍼는 커넥션이 유지되는 동안 계속해서 할당된 상태**로 남아 있는다.
  * 반면, **소트 버퍼와 조인 버퍼는 쿼리를 실행하는 순간에만 할당했다가 다시 해제하는 공간에 해당**한다.
* 이 때, 로컬 메모리 영역은 크게 다음과 같이 분류된다.
  1. 소트 버퍼
  2. 조인 버퍼
  3. 바이너리 로그 캐시
  4. 네트워크 버퍼

## 2022-09-16 Fri
### 플러그인 스토리지 엔진 모델
* MySQL은 기본적으로 많은 스토리지 엔진을 갖고 있지만, 이 조차도 세상의 모든 요구 조건을 만족시킬 수는 없다.
  * 이에 따라 개발 회사 또는 사용자는 자신의 요구사항을 충족하는 스토리지 엔진을 직접 개발하여 사용할 수도 있다.
* 또한, **MySQL 서버는 스토리지 엔진 뿐만 아니라 다양한 기능을 플러그인 형태로 지원**한다.
  * 예를 들어 인증 또는 전문 검색 파서 및 쿼리 재작성과 같은 플러그인이나, 비밀번호 검증과 커넥션 제어 등과 관련된 다양한 플러그인이 존재한다.
  * 이 역시도 MySQL 서버에서 제공하는 기능들을 확장하거나 완전히 새로운 기능을 추가하기 위해 플러그인 API를 활용하여 직접 구현할 수도 있다.

### MySQL에서 쿼리가 실행되는 과정
```
> 하나의 쿼리 작업은 여러가지 하위 작업으로 분류된다.
> 이 때, 각각의 하위 작업이 MySQL 엔진 영역에서 처리되는지 스토리지 엔진 영역에서 처리되는지 구분할 수 있어야 한다. 
```
* MySQL에서 쿼리가 실행되는 과정은 크게 다음과 같이 진행된다.
  1. SQL 파서
  2. SQL 옵티마이저
  3. SQL 실행기
  4. 데이터 읽기 또는 쓰기
* 이 때, **SQL 파서와 옵티마이저 및 실행기로 이어지는 흐름은 MySQL 엔진에서 처리**된다.
  * 반면, **디스크로부터 데이터를 조회하거나 새로운 데이터를 쓰는 작업은 스토리지 엔진의 처리 영역**이 된다.
  * 이로 미루어 보았을 때, 플러그인 형태로 새로운 스토리지 엔진을 작성한다는 것은 DBMS 전체가 아닌 일부 기능만을 수행하는 엔진을 정의한다는 의미를 갖는다.
* 반면, **실질적인 GROUP BY 또는 ORDER BY 등의 복잡한 처리는 스토리지 엔진 영역이 아닌 MySQL 엔진의 쿼리 실행기에서 처리**된다.

### MySQL 핸들러
* **일반적으로 프로그래밍 언어에서 핸들러는 어떠한 기능을 호출하기 위해 사용하는 API를 갖는 객체를 의미**한다.
  * 이 때, **MySQL에서의 핸들러는 MySQL 엔진이 스토리지 엔진을 조정하기 위해 사용하는 API를 의미**한다.
  * 이렇듯 **MySQL 엔진이 각각의 스토리지 엔진으로부터 데이터를 조회하거나 저장하도록 명령하기 위해서는 반드시 핸들러를 통해야 한다**.
* MySQL 서버의 경우, `Handler_`라는 접두사로 시작하는 상태 변수가 MySQL 엔진이 스토리지 엔진에 보낸 명령의 횟수를 의미하는 상태 변수가 된다.
* **핸들러의 존재로 인해 여러 종류의 스토리지 엔진을 사용하는 테이블에 대해 실행된 쿼리 역시 MySQL의 처리 내용은 대부분 동일**해진다.
  * 정확히는 단순히 테이블 별 스토리지 엔진에 따른 데이터의 읽기 및 쓰기 영역에 대한 차이만이 존재한다.

### MySQL 서버에서 지원하는 스토리지 엔진 확인하기
* 자신이 설치한 mysqld에서 지원되는 스토리지 엔진의 종류는 `SHOW ENGINES` 명령어를 활용하여 확인할 수 있다.
* 이 때, 표시된 정보 중 Support 컬럼은 다음과 같은 값이 표시될 수 있다.
  1. YES: mysqld에 해당 스토리지 엔진이 포함되어 있고, 활성화되어 사용 가능한 상태를 의미한다.
  2. DEFAULT: YES와 동일한 상태이며, 필수 스토리지 엔진이므로 해당 엔진이 없을 경우 MySQL이 시작되지 않을 수도 있음을 의미한다.
  3. NO: 현재의 mysqld에는 포함되지 않은 상태를 의미한다.
  4. DISABLED: mysqld에 포함되어 있으나, 파라미터에 의해 비활성화된 상태를 의미한다.

### 컴포넌트란?
* MySQL 8.0 이전의 플러그인 아키텍쳐는 다음과 같은 단점을 갖는다.
  1. 플러그인은 언제나 MySQL 서버와만 통신할 수 있으며, 플러그인 끼리는 통신이 불가능하다.
  2. 플러그인은 MySQL 서버의 변수 또는 함수를 직접 호출하는 등, 충분히 캡슐화되지 않아 안전하지 않다.
  3. 플러그인은 상호 의존 관계를 명시적으로 설정할 수 없어 초기화 과정이 어렵고 번거롭다.
* 이러한 단점을 보완하기 위해 컴포넌트라는 개념이 새로 도입되었다. 
  * MySQL 8.0부터는 많은 기능을 제공하는 컴포넌트를 `INSTALL COMPONENT 컴포넌트` 명령어로 설치할 수 있다.

### 쿼리 실행 시 처리 과정
* 사용자가 요청한 SQL은 다음과 같은 여러 기능을 거쳐 결과로 반환된다.
  1. 쿼리 파서
  2. 전처리기
  3. 옵티마이저에 의한 쿼리 변환 및 비용 최적화, 실행 계획 수립
  4. 쿼리 실행기(= 실행 엔진)
  5. 스토리지 엔진에 의한 읽기 및 쓰기(= 핸들러)

### 쿼리 파서란?
* **쿼리 파서는 사용자 요청으로 전달된 SQL 문장을 MySQL이 인식할 수 있는 최소 단위의 어휘 또는 기호인 토큰으로 분리**한다.
  * 또한, 이렇게 **분리된 토큰을 토대로 쿼리 파서는 트리 형태의 구조를 만들어내는 작업을 수행**한다.
* **쿼리 자체의 오류는 토큰을 만들어내는 쿼리 파서에서 발견되며, 사용자에게 오류 메시지 형태로 전달**된다.

### 전처리기란?
* **전처리기는 쿼리 파서가 만들어낸 파서 트리를 기반으로 쿼리 문장 자체의 구조적인 문제가 있는지 확인**한다.
  * 예를 들어 **각 토큰을 테이블 이름, 칼럼 명 또는 내장 함수와 같은 객체에 매핑하여 해당 객체의 존재 여부 및 접근 권한을 확인**한다.
  * 따라서 **실제로 존재하지 않거나 권한 상 사용할 수 없는 객체 토큰은 해당 단계에서 필터링**된다.

### 옵티마이저란?
* **옵티마이저는 DBMS의 두뇌에 해당하며, 사용자의 요청으로 전달된 쿼리 문장을 가장 저렴한 비용으로 가장 빠르게 처리하는 방법을 결정**한다.
  * 당연히 옵티마이저의 역할은 매우 중요하며, 그 영향 범위 역시 매우 넓은 축에 속한다.

### 실행 엔진이란?
* 옵티마이저와 실행 엔진, 핸들러는 각각 다음과 같은 역할로 비유될 수 있다.
  1. 옵티마이저: 경영진
  2. 실행 엔진: 중간 관리직
  3. 핸들러: 업무 별 실무자
* 예를 들어 옵티마이저가 GROUP BY를 처리하기 위해 임시 테이블을 사용하기로 결정했다고 가정할 경우, 실행 엔진은 다음과 같은 역할을 수행한다.
  1. 실행 엔진은 핸들러에게 임시 테이블의 생성을 요청한다.
  2. 실행 엔진은 핸들러에게 WHERE 절과 일치하는 레코드를 조회할 것을 요청한다.
  3. 실행 엔진은 핸들러에게 2.의 과정에서 조회한 레코드들을 1.의 과정에서 생성한 임시 테이블에 저장할 것을 요청한다.
  4. 실행 엔진은 핸들러에게 3.의 과정에서 구성된 임시 테이블로부터 필요한 방식으로 데이터를 조회할 것을 요청한다.
  5. 실행 엔진은 4.까지의 과정에 의해 구성된 최종 결과를 사용자 또는 다른 모듈로 전달한다.
* 이렇듯 **실행 엔진은 옵티마이저에 의해 수립된 계획대로 각 과정을 핸들러에게 요청하며, 전달 받은 결과를 또 다른 핸들러 요청의 입력으로 연결**한다.

### 핸들러란?
```
> 핸들러는 스토리지 엔진이다.
```
* 상술했듯, **핸들러는 MySQL 서버의 최하단에서 MySQL 실행 엔진의 요청에 따라 데이터를 디스크에 쓰거나 읽어들이는 역할을 수행**한다.
  * 즉, **핸들러란 결국 스토리지 엔진 자체를 의미**한다.
  * 예를 들어 **InnoDB 스토리지 엔진을 사용하는 테이블을 조작하는 경우에 호출되는 핸들러는 InnoDB 스토리지 엔진**이 된다.

## 2022-09-17 Sat
### 쿼리 캐시
```
> 쿼리 캐시는 읽기만 제공하는 서비스와 같이 특수한 경우가 아니라면 심각한 동시 처리 성능의 저하를 유발하는 기능이었다.
> 이로 인해 쿼리 캐시는 MySQL 8.0에 들어서면서 관련된 시스템 변수와 함께 완전히 제거되었다.  
```
* 쿼리 캐시는 SQL 실행 결과를 메모리에 캐시하고, 동일한 SQL 쿼리가 실행되면 테이블을 읽지 않고 즉시 결과를 반환하여 큰 성능 향상을 제공했다.
* 그러나 쿼리 캐시는 테이블의 데이터가 변경되는 경우, 캐싱된 결과 중 변경된 테이블과 관련된 모든 것을 반드시 삭제해야 했다.
  * 이러한 특징은 심각한 동시 처리 성능 저하를 유발하였으며, 대부분의 경우에 수 많은 버그의 원인으로 지목되었다.
* 이로 인해 MySQL 8.0에서는 쿼리 캐시 기능이 완전히 제거되었다.

### 스레드 풀
```
> MySQL 서버의 스레드 풀은 Percona Server와 엔터프라이즈 에디션에서는 지원되나, 커뮤니티 에디션에는 지원되지 않는다.
```
* **스레드 풀은 내부적으로 사용자의 요청을 처리하는 스레드의 개수를 줄여 동시에 처리되는 요청이 많아지더라도 제한된 개수의 스레드 처리에만 집중하도록 한다**.
  * 즉, **스레드 풀은 MySQL 서버의 CPU가 제한된 개수의 스레드에만 집중하여 서버의 자원 소모를 줄이는 데에 목적**이 있다.
  * 이로 인해 실무에서도 스레드 풀이 서비스에서 눈에 띄는 성능 향상을 보여주는 경우는 드물다.
* 상술했듯, 스레드 풀은 동시에 실행 중인 스레드들을 CPU가 최대한 잘 처리할 수 있는 수준으로 줄여 빠르게 처리하도록 하는 기능이다.
  * 이 때, 일반적으로 CPU 코어의 개수와 스레드의 개수를 맞추는 것이 CPU 프로세서의 친화도를 높이기에 좋다.

### 트랜잭션을 지원하지 않는 파일 기반 메타데이터
* **데이터베이스 서버 상에서 테이블의 구조 정보, 또는 스토어드 프로그램 등의 정보는 데이터 딕셔너리 또는 메타데이터라고 지칭**한다.
  * 이 때, **MySQL 서버 5.7 버전까지는 이러한 테이블의 구조와 스토어드 프로그램을 모두 파일 기반으로 관리**했다.
* 그러나 이러한 **파일 기반의 메타데이터는 생성 및 변경 작업에 대한 트랜잭션을 지원하지 않는 치명적인 문제가 존재**하였다.
  * 때문에 **테이블의 생성 또는 변경 도중에 MySQL 서버가 비정상적으로 종료된 경우, 테이블은 일관되지 않는 상태로 남을 가능성이 존재**한다.
  * 이러한 현상은 대부분의 개발자에 의해 `테이블이 깨졌다`는 용어로 표현되었다.

### 시스템 테이블
* **MySQL 8.0 버전부터는 상술한 문제점을 해결하기 위해 메타데이터를 모두 InnoDB의 테이블에 저장하도록 개선**되었다.
  * 이렇듯 **MySQL 서버가 동작하는데에 기본적으로 필요한 사용자의 인증 및 권한 등에 사용되는 필수 테이블들을 묶어 시스템 테이블이라고 지칭**한다.
* **MySQL 8.0 버전부터는 시스템 테이블은 모두 InnoDB 스토리지 엔진을 사용하며, 시스템 테이블과 메타데이터 정보를 모두 모아 mysql DB에 저장**한다.
  * 이 때, mysql DB는 통채로 `mysql.ibd`라는 이름의 테이블 스페이스에 저장된다.
  * 때문에 **MySQL 서버 상의 데이터 디렉토리에 존재하는 해당 파일은 다른 `.ibd` 확장자 파일과 함께 각별히 주의를 기울여 관리**해야 한다.
* 이 때, **mysql DB에 저장된 데이터 딕셔너리 테이블은 사용자가 임의로 수정할 가능성을 제거하기 위해 사용자가 조회할 수 없도록 구성**되어 있다.
  * **대신 MySQL 서버는 데이터 딕셔너리 정보를 조회하기 위해 `information_schema` DB의 `TABLES` 또는 `COLUMNS`와 같은 뷰를 제공**한다.

### 트랜잭션을 지원하는 메타데이터
* **MySQL 8.0 버전부터는 데이터 딕셔너리와 시스템 테이블이 모두 트랜잭션 기반의 InnoDB 스토리지 엔진에 저장되도록 개선**되었다.
  * 때문에 **스키마 변경 작업 도중에 MySQL 서버가 비정상적으로 종료되더라도 스키마의 변경은 원자적으로 처리**된다.
  * 즉, 더 이상 테이블이 깨지는 등 작업 진행 중인 상태로 남아 문제를 유발하는 일은 발생하지 않는다.
* MySQL 서버에서, InnoDB 스토리지 엔진을 사용하는 테이블의 메타데이터는 InnoDB 테이블 기반의 딕셔너리에 저장된다.
  * 반면, **MyISAM 또는 CSV 등과 같은 스토리지 엔진의 메타데이터는 여전히 저장하기 위한 별도의 공간이 필요**하다.
  * MySQL 서버는 이러한 InnoDB 이외의 스토리지 엔진들을 사용하는 테이블들을 위해 `.sdi` 포맷을 지원한다.
* SDI는 직렬화를 위한 포맷이므로, InnoDB 테이블의 구조 역시 `.sdi` 확장자 파일로 전환될 수 있다.
  * 이 때, `ibd2sdi` 유틸리티를 활용하여 InnoDB 테이블 스페이스에서 스키마 정보를 추출할 수 있다.
  * 이 경우, MySQL 서버 상에서 `SHOW TABLES` 명령으로는 확인할 수 없던 `mysql.tables` 딕셔너리 데이터를 위한 테이블 구조 역시 확인이 가능하다.

### InnoDB 스토리지 엔진의 특징
* **InnoDB 스토리지 엔진은 MySQL에서 가장 자주 사용되는 스토리지 엔진**이며, 다음과 같은 특징이 존재한다.
  1. MySQL에서 사용할 수 있는 스토리지 엔진 중 거의 유일하게 레코드 기반의 잠금을 제공한다.
  2. 이로 인해 높은 동시성 처리가 가능하다.
  3. **다른 스토리지 엔진과 비교하여 안정적이며, 성능 역시 뛰어나다**.

### PK에 의한 클러스터링
* **InnoDB 엔진을 사용하는 모든 테이블은 기본적으로 PK를 기준으로 클러스터링되어 저장**된다.
  * **이는 즉 PK의 값 순서대로 디스크에 저장된다는 의미**이기도 하다.
  * **PK가 결국 클러스터링 인덱스이므로, PK를 활용한 레인지 스캔은 상당히 빠르게 처리**된다. 
  * 때문에 **쿼리 실행 계왹에서 PK는 기본적으로 다른 세컨더리 인덱스에 비해 우선 순위가 높게 설정되므로 우선적으로 선택될 확률이 상대적으로 높다**.
* InnoDB 엔진을 사용하는 경우, 모든 **세컨더리 인덱스는 레코드의 주소 대신 PK 값을 논리적인 주소로 사용**한다.

### MyISAM 엔진과 InnoDB의 차이점
* MyISAM 스토리지 엔진의 경우 클러스터링 키를 지원하지 않으므로, PK와 세컨더리 인덱스는 구조적으로 차이가 없다.
  * PK는 단지 UQ 제약 조건을 갖는 세컨더리 인덱스에 지나지 않는다.
* MyISAM 테이블의 경우, PK를 포함하는 모든 인덱스는 물리적인 레코드의 주소인 ROWID 값을 갖는다.
  * 이는 **세컨더리 인덱스에서 ROWID 대신 PK 값을 논리적인 주소로 사용하는 InnoDB 엔진과는 차이가 있다**.

### FK에 대한 지원
* **FK에 대한 지원은 InnoDB 스토리지 엔진 차원에서 제공하는 기능이므로, MyISAM 등 다른 스토리지 엔진을 사용하는 테이블에서는 사용할 수 없다**.
* FK는 DB 서버 운영의 불편함으로 인해 서비스용 DB에서는 생성하지 않는 경우가 잦다.
  * 그러나 개발 환경에서는 가이드 역할로서 유용히 사용될 수 있다.
* **InnoDB 엔진에서의 FK는 다음과 같은 이유에서 관리에 어려움이 따르므로, FK의 존재에 주의해야하는 경우가 많이 발생**한다.
  1. 부모 테이블과 자식 테이블 모두 해당 칼럼에 대한 인덱스 생성이 필수적이다.
  2. 변경 시에는 반드시 부모 테이블 또는 자식 테이블에 데이터가 존재하는지 체크하는 작업이 필요하므로 잠금은 여러 테이블로 전파된다.
  3. 상술한 이유에서, 데드락이 쉽게 발생할 수 있다.

### FK 체크 작업을 일시 중지하기
* 수동으로 데이터를 적재하거나, 스키마를 변경하는 과정은 복잡하게 얽힌 FK 관계로 인해 실패할 수 있다.
  * 물론 부모와 자식 테이블의 관계를 명확히 파악한다면 문제없을 수 있으나, FK 관계 자체가 복잡하다면 이 조차 쉽지 않다.
  * 또한, 서비스에 긴급한 문제가 있어 즉시 조치를 취해야하는 경우에도 엄격한 FK 체크 기능은 마음을 더 조급하게 만들어 실수를 불러일으킬 수 있다.
* 이러한 경우, `SET foreign_key_checks=OFF;` 형태의 명령어로 `foreign_key_checks` 시스템 변수를 변경하여 FK 체크 작업을 일시 중단할 수 있다.
  * 당연하게도 **FK 체크 작업을 일시적으로 해제했다고 해서 부모와 자식 테이블의 관계가 깨진 상태로 유지해도 무방하다는 의미는 아니다**.
  * 예를 들어, FK 체크 기능을 비활성화한 상태에서 FK를 갖는 부모 테이블의 레코드를 삭제했다면 자식 테이블에서도 반드시 일관성을 맞추어야 한다.
* 이러한 **시스템 변수는 적용 범위를 `SET SESSIOn foreign_key_cheks=OFF;`와 같이 GLOBAL 또는 SESSION으로 설정할 수 있는 종류**에 속한다.
  * 때문에 **FK 체크 기능을 일시적으로 비활성화하고자하는 경우, 반드시 현재 작업을 실행하는 세션에서만 적용하는 것이 바람직**하다.
  * 또한, **작업이 완료되는 대로 반드시 현재 세션을 종료하거나 FK 체크 기능을 다시 활성화하는 것을 잊지 않아야 한다**.

### Multi Version Concurrency Control
```
> MVCC란 DBMS 상에서 하나의 레코드에 대해 2개 이상의 버전이 각각 버퍼 풀과 데이터 파일, 언두 영역에서 관리되는 과정을 말한다.
```
* **MVCC는 일반적으로 레코드 레벨의 트랜잭션을 지원하는 DBMS가 제공하는 기능으로, 잠금을 사용하지 않는 일관된 읽기를 제공하는 데에 목적**이 있다.
  * **MVCC의 Multi Version은 하나의 레코드에 대해 여러 버전이 동시에 관리된다는 의미이며, InnoDB는 언두 로그를 활용하여 해당 기능을 구현**한다.

### MVCC 활용 시나리오
* 트랜잭션 격리 수준이 READ_COMMITTED일 때, InnoDB 엔진을 사용하는 테이블에 새로운 레코드 A를 추가하면 데이터베이스의 상태는 다음과 같이 변경된다.
  1. InnoDB 버퍼 풀: 메모리에 포함된 영역이며, 추가된 레코드 A에 대한 정보가 포함된다.
  2. 언두 로그: 메모리에 포함된 영역이지만, 지금 단계에서는 어떠한 데이터도 포함되지 않는다.
  3. 데이터 파일: 디스크 영역이며, 레코드 A에 대한 정보가 쓰여진다.
* 이 때, 레코드 A의 임의의 컬럼 값을 수정하는 UPDATE 문이 실행될 경우 데이터베이스의 상태는 다음과 같이 변경된다.
  1. InnoDB 버퍼 풀: COMMIT 여부와 관계 없이 기존 레코드의 일부 컬럼이 UPDATE 문에 맞추어 수정된다.
  2. 언두 로그: **기존 데이터인 레코드 A의 수정 전 값을 복사하여 갖게 된다**.
  3. 데이터 파일: 스레드에 의해 UPDATE 문에서 변경하는 컬럼의 수정 사항이 반영될 수도, 그렇지 않을 수도 있다.
     * 그러나 **일반적으로는 InnoDB가 ACID 특성을 보장하므로 InnoDB 버퍼 풀과 동일한 상태를 갖는다고 가정해도 무방**하다.
* **이 상태에서, 사용자가 SELECT 문을 통해 레코드 A를 조회하는 경우에는 MySQL 서버에 설정된 트랜잭션 격리 수준에 따라 조회 위치가 달라지게 된다**.
  * 이러한 트랜잭션 격리 수준은 시스템 변수인 `transaction_isolation`에 설정된다.
* 이 때, MySQL 격리 수준에 따른 조회 위치는 크게 다음과 같이 구분된다.
  1. READ_UNCOMMITTED: **InnoDB 버퍼 풀이 갖는 현재 값, 즉 COMMIT 여부와 관계 없이 변경된 현재의 상태를 반환**한다.
  2. READ_COMMITTED 및 그 이상의 격리 수준: **변경 사항이 아직 COMMIT되지 않았으므로, 변경 전 데이터인 언두 영역의 데이터를 반환**한다.
* **이렇듯 하나의 레코드에 대해 2개 이상의 버전이 각각 버퍼 풀과 데이터 파일, 언두 영역에서 관리되는 과정을 DBMS에서는 MVCC라는 용어로 표현**한다.
  * 이 때, **유지되는 2개 이상의 버전 중 필요에 따라 어떤 데이터를 반환할지는 그 때 그 때의 상황에 따라 달라지게 된다**.
* 또한 **언두 영역에서 관리되는 데이터는 상황에 따라 무한히 많아질 수 있다**.
  * 예를 들어 **트랜잭션이 필요 이상으로 길어지는 경우, 언두 영역에서 관리되는 예전 데이터가 적시에 삭제되지 못하고 오랫동안 관리**되게 된다.
  * 이러한 상황에서는 당연히 언두 영역이 저장되는 시스템 테이블 스페이스의 공간이 필요 이상으로 늘어나는 상황이 발생할 수 있다.

### COMMIT과 ROLLBACK에 따른 버퍼 풀과 언두 영역의 동작
* 상술한 시나리오에서, **UPDATE 문이 요청되는 경우 InnoDB의 버퍼 풀은 즉시 새로운 데이터로 변경되는 반면 기존 데이터는 언두 영역으로 복사**된다.
* 이 때, COMMIT 또는 ROLLBACK 중 어떤 명령을 실행하느냐에 따라 InnoDB 엔진은 다음과 같이 동작한다.
  1. **COMMIT 명령을 실행하면 InnoDB는 더 이상의 변경 작업 없이 현재의 상태를 영구적인 데이터로 영속화**한다.
  2. **ROLLBACK을 실행하는 경우 InnoDB는 언두 영역에 백업된 변경 전 데이터를 InnoDB 버퍼 풀로 다시 복구한 후에 언두 영역의 내용은 삭제**한다.
* 반면, ROLLBACK 명령이 실행된 경우와 달리 **COMMIT 명령이 실행되었다고 해서 언두 영역에 백업된 변경 전 데이터가 항상 바로 삭제되지는 않는다**.
  * **대신 해당 언두 영역을 필요로 하는 트랜잭션이 더 이상 존재하지 않는 경우에만 데이터가 삭제**된다.

## 2022-09-18 Sun
### 잠금 없는 일관된 읽기
* **InnoDB 스토리지 엔진은 MVCC 기술을 활용하여 잠금을 걸지 않고 읽기 작업을 수행**할 수 있다.
  * 이는 읽기 작업이 언두 영역에 백업된 데이터만 반환하면 되기 때문에 가능한 일이다.
* **잠금을 걸지 않으므로 InnoDB 엔진을 사용하는 테이블에서의 읽기 작업은 다른 트랜잭션이 갖는 잠금을 대기하지 않고도 읽기 작업이 가능**하다.
  * 이는 트랜잭션 격리 수준이 SERIALIZABLE이 아닌 경우에서, INSERT와 연결되지 않은 순수한 SELECT 작업에 대한 설명에 해당한다. 
  * 이러한 **조건을 충족할 경우, 순수한 SELECT 작업은 다른 트랜잭션의 변경 작업과 관계 없이 항상 잠금을 대기하지 않고 즉시 실행**된다.
* 이를 **잠금 없는 일관된 읽기라고 표현하며, InnoDB 엔진에서는 변경되기 전의 데이터를 조회하기 위해 언두 로그 영역을 사용**한다.

### 오랫동안 활성화된 트랜잭션에서 발생할 수 있는 문제
* **오랫동안 활성화된 트랜잭션으로 인해 MySQL 서버가 느려지는 등의 문제가 발생할 가능성이 존재**한다.
  * 이러한 문제는 상술한 **잠금 없는 일관된 읽기를 제공하기 위해 언두 로그를 삭제하지 못하고 계속 유지해야하기 때문에 발생하는 문제에 해당**한다.
* 따라서 **트랜잭션이 한 번 시작되었다면, 최대한 빠르게 COMMIT 또는 ROLLBACK 명령어를 적용하여 트랜잭션을 완료하는 것이 바람직**하다.

### 자동 데드락 감지 기능
* **InnoDB의 스토리지 엔진은 내부적으로 잠금이 교착 상태에 빠졌는지 확인하기 위해서 잠금 대기 목록을 Wait-for-List 형태의 그래프로 관리**한다.
* **InnoDB 엔진은 데드락 감지 용도의 스레드를 별도로 가지며, 해당 스레드는 주기적으로 잠금 대기 그래프를 검사하여 교착 상태에 빠진 트랜잭션을 찾아낸다**.
  * 이 과정에서 교착 상태에 빠진 트랜잭션을 찾아낸 경우, 해당 트랜잭션 중 하나를 강제 종료한다.
  * 이 때, **강제 종료 대상 트랜잭션을 결정하는 기준은 각 트랜잭션이 갖는 언두 로그의 양**이 된다.
* 일반적으로는 **언두 로그 영역에 레코드를 더 적게 갖는 트랜잭션이 ROLLBACK의 대상**이 된다.
  * 더 적은 언두 로그 레코드는 곧 ROLLBACK을 수행하더라도 언두 처리를 해야할 내용이 더 적다는 의미와 같다.
  * 이 경우, 당연히 트랜잭션 강제 롤백으로 인한 MySQL 서버의 부하도 덜할 수 밖에 없다.
* **InnoDB 스토리지 엔진은 보다 상위 계층인 MySQL 엔진이 관리하는 테이블 잠금 명령으로 인해 획득한 잠금은 확인할 수 없다**.
  * 예를 들어, `LOCK TABLES` 명령으로 잠긴 테이블에 대해서는 데드락 감지가 불확실할 가능성이 존재한다.
  * 이 경우 **`innodb_table_locks` 시스템 변수를 활성화하여 InnoDB 엔진 내부의 레코드 잠금 뿐만 아니라 테이블 레벨 잠금까지 확인**할 수 있다.
  * 때문에 별다른 이유가 없는 경우, `innodb_table_locks` 시스템 변수는 활성화하는 것이 바람직하다.

### 데드락 감지 스레드의 속도 저하
* 일반적인 서비스의 경우, 데드락 감지 스레드가 트랜잭션 잠금 목록을 검사하여 데드락을 찾아내는 작업은 크게 부담을 주지 않는다.
  * 그러나 **동시 처리 스레드가 너무 많아지거나, 각 트랜잭션이 갖는 잠금의 개수가 많아지게 되면 데드락 감지 스레드는 느려질 수 있다**.
* 느려진 데드락 감지 서비스는 서비스 쿼리를 처리 중인 스레드가 더 작업을 진행하지 못하고 대기하게 만들며, 이로 인해 서비스에는 악영향을 미칠 수 있다.
  * 이는 **데드락 감지 스레드가 잠금 목록을 검사하기 위해 잠금 상태가 변경되지 않도록 잠금 목록이 저장된 잠금 테이블에 새로운 잠금을 걸기 때문**이다.
  * **동시 처리 스레드가 너무 많아지는 경우, 데드락 감지 스레드는 보다 많은 CPU 자원을 소모할 가능성이 존재**한다.

### 자동 데드락 감지 기능 비활성화 고려하기
* 이를 해결하기 위해 **MySQL 서버는 `innodb_deadlock_detect` 시스템 변수를 제공하며, OFF로 설정하여 데드락 감지 스레드를 비활성화**할 수 있다.
  * 이 경우 데드락 감지 스레드가 더 이상 동작하지 않으므로, InnoDB 스토리지 엔진 내부에서 2개 이상의 트랜잭션이 데드락에 처하더라도 무한정 대기하게 된다.
* 이 때, **`innodb_lock_wait_timeout` 시스템 변수를 추가로 활성화하여 데드락이 일정 시간 후에 자동으로 요청이 실패하도록 만들 수 있다**.
  * **해당 시스템 변수는 초 단위로 설정할 수 있으며, 설정된\ 시간 동안 잠금을 획득하지 못하면 쿼리는 자동으로 실패하여 에러를 반환**한다.
  * 이렇듯 데드락 감지 스레드가 부담되어 `innodb_deadlock_detect` 를 OFF로 설정한 경우, 상술한 시스템 변수를 혼용하는 것이 바람직하다.
  * 예를 들어, **`innodb_lock_wait_timeout` 시스템 변수를 50초보다 훨씬 낮은 시간으로 변경하여 사용**할 수 있다.
* PK 또는 세컨더리 인덱스를 기반으로 매우 높은 동시성 처리를 요구하는 서비스의 경우, `innodb_deadlock_detect`를 비활성화하는 것을 고려할 수 있다.
  * 예를 들어, 해당 시스템 변수를 활성화한 경우와 비활성화한 경우에 대해 성능 비교를 진행하여 의사 결정의 지표로 삼을 수 있다.

### 자동화된 장애 복구 기능
* InnoDB 스토리지 엔진에는 손실이나 장애로부터 데이터를 보호하기 위한 여러가지 기능이 탑재되어 있다.
  * 이러한 기능을 활용하여 MySQL 서버사 시작될 때 완료하지 못했던 트랜잭션 또는 디스크에 일부만 기록된 데이터 페이지에 대한 복구 작업이 자동으로 진행된다.
* InnoDB 스토리지 엔진은 기본적으로 매우 견고하기에 데이터 파일이 손상되거나, MySQL 서버가 시작되지 못하는 경우는 거의 발생하지 않는다.
  * 그러나 MySQL 서버와 무관하게 디스크 또는 서버 이슈로 InnoDB 스토리지 엔진이 자동으로 복구하지 못하는 경우가 발생할 수 있다.
* InnoDB 데이터 파일은 기본적으로 MySQL 서버가 시작될 때 항상 자동 복구를 시도하며, 복구하지 못한 손상이 존재하는 경우 MySQL 서버는 종료된다.
  * **이 경우, MySQL 서버의 `innodb_force_recovery` 시스템 변수를 설정하여 MySQL 서버를 재시작**해야 한다.
  * 이러한 설정 값은 MySQL 서버가 시작될 때 InnoDB 엔진이 데이터 파일 또는 로그 파일의 손상 여부 검사 과정을 선별적으로 진행하도록 한다.
  * `innodb_force_recovery` 값은 1부터 6까지 설정할 수 있으며, 값이 커질수록 심각한 상황으로 데이터 손실 가능성이 커지고 복구 가능성은 적어진다.
  * 이 때, **`innodb_force_recovery` 값이 0이 아닌 복구 모드에서는 SELECT 이외의 INSERT나 UPDATE, DELETE 쿼리를 수행할 수 없다**.
* 상술한 과정을 통해서도 MySQL 서버가 시작되지 않는 경우, 백업을 활용하여 다시 구축하는 방법을 선택해야만 한다.
  * 백업이 존재하는 경우 마지막 백업으로 DB를 새로 구축한 후, 바이너리 로그를 활용하여 최대한 장애 시점까지의 데이터를 복구한다.
  * 마지막 풀 백업으로부터 장애 시점까지의 바이너리 로그가 존재하는 경우, 둘을 적절히 활용하는 것이 InnoDB의 복구 기능보다 데이터 손실은 더 적을 수 있다.
  * 백업은 존재하지만 복제의 바이너리 로그가 없거나 손실된 경우, 마지막 백업 시점까지만 복구할 수 있다.

## 2022-09-19 Mon
### InnoDB 엔진 버퍼 풀
```
> 버퍼 풀은 InnoDB 스토리지 엔진에서 가장 핵심적인 부분이다.
> 버퍼 풀은 디스크의 데이터 파일 또는 인덱스의 정보를 메모리에 캐시해두는 공간이다.
```
* **버퍼 풀은 캐시 역할 뿐만 아니라 쓰기 작업을 의도적으로 지연시켜 일괄 작업으로 처리할 수 있도록 하는 버퍼의 역할도 수행**한다.
  * 예를 들어, INSERT나 UPDATE 및 DELETE 등의 데이터 변경 쿼리는 데이터 파일의 여기 저기에 위치한 레코드를 변경한다.
  * 따라서 **랜덤 디스크 IO를 유발하지만, 버퍼 풀은 이러한 변경된 데이터를 모아서 한 번에 처리하여 랜덤 디스크 IO 발생을 줄인다**.

### 버퍼 풀의 적절한 크기
* **InnoDB의 버퍼 풀 크기를 결정하는 경우, 반드시 운영체제와 각 클라이언트 스레드가 사용할 메모리를 고려**해야 한다.
* 일반적으로 MySQL 서버에서 메모리를 필요로 하는 부분은 크게 없지만, 아주 독특한 경우에 레코드 버퍼가 상당한 메모리를 점유할 수 있다.
  * 이 때, **레코드 버퍼는 각 클라이언트 세션에서 테이블의 레코드를 읽고 쓰기 위한 버퍼로 사용되는 공간**이다. 
* 커넥션이 많고 사용 대상 테이블도 많은 경우, 레코드 버퍼 용도로 사용되는 메모리 공간이 많이 필요할 수도 있다.
  * 이러한 **레코드 버퍼 공간은 별도로 설정할 수 없으며, 단지 전체 커넥션의 개수와 각 커넥션에서 읽고 쓰는 테이블의 개수에 따라 결정**된다.
  * 또한, **레코드 버퍼 공간은 동적으로 할당되거나 해제되므로 정확히 필요한 메모리 공간의 크기를 계산할 수는 없다**.
* MySQL 5.7 버전 이후부터는 InnoDB 버퍼 풀의 크기를 동적으로 조절할 수 있다.
  * 때문에 **InnoDB 버퍼 풀의 크기를 적절히 작은 값으로 설정한 후, 점진적으로 증가시키면서 최적점을 찾는 방식이 가장 바람직**하다.
* MySQL 서버에 사용되는 메모리 크기에 따라 다음과 같은 방식으로 InnoDB 버퍼 풀의 크기를 조정할 수 있다.
  1. 8GB 미만: 절반 정도만 버퍼 풀로 설정하되, 나머지는 MySQL 서버와 OS 또는 다른 애플리케이션을 위해 남겨두는 것이 바람직하다.
  2. 그 이상: **버퍼 풀의 크기를 전체 메모리의 절반에서 시작하여 조금씩 올려가며 최적점을 찾도록 한다**.
  3. 50GB 이상: 약 20 ~ 35GB 정도를 버퍼 풀에 할당하고 나머지는 OS와 또 다른 애플리케이션을 위해 남겨두는 것이 바람직하다.

### 버퍼 풀의 크기 변경
* **버퍼 풀의 크기는 `innodb_buffer_pool_size` 시스템 변수로 설정**할 수 있다.
* 중요한 것은 **버퍼 풀의 크기 변경은 매우 크리티컬한 변경에 속하므로 가능한 한 MySQL 서버가 한가한 시점에 진행**해야 한다는 점이다.
  * 버퍼 풀의 **크기를 늘리는 것은 서비스 영향도가 크지 않지만, 크기를 줄이는 작업은 그 영향도가 매우 크므로 가능한 한 진행하지 않아야 한다**.
* **InnoDB 버퍼 풀은 내부적으로 128MB 청크 단위로 쪼개어 관리되며, 이는 버퍼 풀의 크기를 늘리거나 줄이는 기본 단위 크기**이기도 하다.
  * 즉, 버퍼 풀의 크기를 변경하는 경우에는 항상 128MB 단위로 처리된다.

### InnoDB 버퍼 풀 쪼개기
* **버퍼 풀은 전통적으로 버퍼 풀 전체를 관리하는 잠금으로 인해 내부 잠금으로 인한 경합을 많이 유발**해왔다.
* 이러한 **경합을 줄이기 위해 버퍼 풀은 여럿으로 쪼개어 관리할 수 있으며, 개별 버퍼 풀 전체를 관리하는 잠금 역시 분산되는 효과**가 있다.
* 이 때, `innodb_buffer_pool_instances` 시스템 변수를 활용하여 버퍼 풀 인스턴스를 여럿으로 분리하여 관리할 수 있다.
  * 해당 시스템 변수는 기본적으로 8로 초기화되지만, 전체 버퍼 풀을 위한 메모리 크기가 1GB 미만인 경우 버퍼 풀 인스턴스는 1개만 생성된다.
  * 버퍼 풀 메모리 공간이 40GB 이하라면 기본 값인 8 개를 유지하되, 그 이상인 경우 버퍼 풀 인스턴스 당 5GB 정도의 메모리가 할당되도록 조절한다.
  
### 버퍼 풀의 구조
* **InnoDB는 거대한 메모리 공간인 버퍼 풀을 페이지 크기에 맞개 쪼개며, InnoDB가 데이터를 필요로 할 때 해당 데이터 페이지를 읽어 각 조각에 저장**한다.
  * 이 때, 각 페이지 크기는 시스템 변수인 `innodb_page_size`에 맞추어 쪼개진다.
* **버퍼 풀은 각각의 페이지 크기 조각을 관리하기 위해 다음과 같은 3개의 자료 구조를 관리**한다.
  1. Least Recently Used 리스트
  2. Flush 리스트
  3. Free 리스트

### Free 리스트
* **프리 리스트는 InnoDB의 버퍼 풀에서 아직 사용자 데이터로 채워지지 않은, 빈 페이지의 목록을 의미**한다.
* **프리 리스트는 예를 들어 사용자의 쿼리로 인해 디스크의 데이터 페이지를 새롭게 읽어들여야 하는 경우에 사용**된다.

### LRU 리스트와 MRU 리스트
```
> LRU 리스트를 관리하는 이유는 디스크로부터 한 번 읽어들인 페이지는 최대한 오래 InnoDB 버퍼 풀의 메모리 공간에 유지하기 위함이다.
> 이렇듯 페이지가 최대한 오랫동안 버퍼 풀 메모리에 유지될 경우, 랜덤 디스크 읽기를 최소화할 수 있다.
```
* 엄밀하게 따져봤을 때, LRU 리스트는 MRU 리스트와 결합된 형태를 띈다.
* 이 때, InnoDB 스토리지 엔진에서 데이터를 조회하는 과정은 크게 다음과 같이 진행된다.
  1. 우선 필요한 레코드가 저장된 데이터 페이지가 현재 버퍼 풀에 존재하는지 검사한다.
     1. 우선 버퍼 풀에 이미 데이터 페이지가 존재하는 경우, 해당 페이지의 포인터를 MRU 방향으로 승급시킨다.
     2. 또는 InnoDB 어댑티브 해시 인덱스를 활용하여 페이지를 검색한다.
     3. 그조차 아니면 해당 테이블의 B-Tree 인덱스를 활용하여 버퍼 풀에서 페이지를 검색한다.
  2. 디스크에서 필요한 데이터 페이지를 버퍼 풀에 적재하고, 적재된 페이지에 대한 포인터는 LRU 헤더에 추가한다.
  3. 버퍼 풀의 LRU 헤더 부분에 적재된 데이터 페이지가 실제로 조회되는 경우, MRU 헤더 부분으로 이동한다.
     1. 그러나 대량 조회의 경우 디스크의 데이터 페이지가 버퍼 풀로 적재는 되지만, 실제 쿼리에서 사용되지 않을 수도 있으므로 MRU로 이동하지 않는다.
  4. 버퍼 풀에 상주하는 데이터 페이지는 사용자 쿼리가 접근한지 오래될수록 Aging된다.
     1. 버퍼 풀의 데이터 페이지가 쿼리에 의해 사용된 경우, Age는 초기화되고 MRU의 헤더 부분으로 이동된다.
     2. 버퍼 풀에 상주하는 데이터 페이지가 오랫동안 사용되지 않은 경우, 점차 Aging되다가 결국 버퍼 풀에서 제거된다.
  5. 필요한 데이터가 자주 접근된 경우, 해당 페이지의 인덱스 키를 어댑티브 해시 인덱스에 추가한다.
* 이렇듯 **버퍼 풀 내부에서, 최근에 접근되었는지 여부에 따라 데이터 페이지들은 서로 경쟁하며 MRU로 승급되거나 LRU로 강등**된다.
  * 이 때, **InnoDB 엔진은 LRU의 가장 끝으로 밀려난 데이터 페이지들을 버퍼 풀로부터 제거하여 새로운 데이터 페이지를 적재할 공간을 준비**한다.
  * 이렇듯 처음 읽힌 데이터 페이지가 계속해서 사용된다면 InnoDB 엔진 버퍼 풀의 MRU 영역에서 계속 살아남게 된다.
  * 반면 **거의 사용되지 않는 데이터 페이지는 새로이 읽어들인 데이터 페이지들에게 밀려 LRU의 끝으로 이동하고, 결국에는 버퍼 풀에서 제거**된다.

### Flush 리스트
* **플러시 리스트는 디스크로 동기화되지 않은 데이터를 갖는 데이터 페이지인 더티 페이지의 변경 시점 기준의 페이지 목록을 관리**한다.
  * 디스크에서 읽은 상태 그대로 전혀 변경이 없었다면 플러시 리스트에서 관리되지 않는다.
  * 반면, **한 번 데이터 변경이 가해진 데이터 페이지는 플러시 리스트에서 관리되어 특정 시점에 디스크에 기록되어야 한다**.
* **데이터가 변경되면 InnoDB는 해당 내용을 리두 로그에 기록하며, 버퍼 풀의 데이터 페이지에도 변경 내용을 반영**한다.
  * 이렇듯 리두 로그의 각 엔트리는 임의의 데이터 페이지와 연결된다.
* 반면, 리두 로그가 디스크에 기록되더라도 데이터 페이지가 디스크로 기록되었다는 것이 항상 보장되지는 않는다.
  * **이로 인해 InnoDB 엔진은 체크 포인트를 생성하여 디스크의 리두 로그와 데이터 페이지의 상태를 동기화**한다.
  * 이 때, 체크포인트는 MySQL 서버가 시작될 때 InnoDB 엔진이 리두 로그의 어느 부분부터 복구할지 판단하는 기준점을 생성하는 역할을 수행한다.

## 2022-09-20 Tue
### 버퍼 풀과 리두 로그의 밀접한 관계
```
> InnoDB의 버퍼 풀과 리두 로그는 매우 밀접한 관계를 갖는다.
```
* 상술한 바와 같이, **InnoDB의 버퍼 풀은 서버의 메모리를 많이 설정할수록 쿼리의 성능이 빨라진다**.
  * 극단적으로, 서버의 성능이 매우 좋아 디스킈 모든 데이터가 버퍼 풀 메모리로 적재되는 경우 성능은 가장 좋다.
* 그러나 InnoDB의 버퍼 풀은 크게 다음과 같은 두 가지 목적을 갖는다.
  1. 데이터를 캐싱한다.
  2. 디스크 쓰기 작업을 지연 처리하는 등, 버퍼 용도로 사용된다.
* 이 때, **MySQL 서버의 성능만을 높이는 것은 두 목적 중 오로지 데이터 캐시 기능만 향상시키는 것**과 같다.
  * 두 목적 중 남은 하나인 쓰기 버퍼링까지 향상시키기 위해서는 InnoDB의 버퍼 풀과 리두 로그의 관계를 이해할 필요가 있다.
* 일반적으로 리두 로그는 데이터의 변경 분만 가지고 있으면 되는 반면 버퍼 풀은 데이터 페이지를 통채로 가져야 한다.
  * 때문에 **데이터 변경이 발생하더라도, 원칙적으로 리두 로그는 훨씬 작은 공간만 할당되어도 무방**하다.

### 클린 페이지, 더티 페이지
* InnoDB의 버퍼 풀이 갖는 페이지는 그 성격에 따라 다음과 같이 분류된다.
  1. 디스크에서 읽은 상태로 전혀 변경되지 않은 클린 페이지
  2. 또는 INSERT나 UPDATE, DELETE 등의 명령으로 인해 변경된 데이터를 갖는 더티 페이지
* 이 중 **더티 페이지는 디스크와 메모리 상에 위치한 버퍼 풀 간의 데이터 상태가 다르므로, 언젠가는 반드시 디스크로 기록될 필요**가 있다.

### 리두 로그 파일의 로그 엔트리
* 리두 로그는 1개 이상의 고정된 크기를 갖는 파일을 연결하여 마치 순환 고리처럼 사용한다.
  * 예를 들어, **데이터 변경이 계속해서 발생하는 경우에 리두 로그 파일에 기록된 로그 엔트리는 언젠가는 다른 로그 엔트리로 덮어 씌워진다**.
  * 즉, 더티 페이지는 버퍼 풀에 무한정 머무를 수 없다.
* **InnoDB 스토리지 엔진은 전체 리두 로그 파일 중 당장 재사용이 불가능한 공간을 가려내며, 이를 활성 리두 로그 공간이라고 지칭**한다.
* 비록 **리두 로그 파일에 할당된 공간은 고정된 크기를 순환하며 사용하지만, 매 번 기록될 때마다 로그 포지션은 계속해서 증가**된 값을 갖는다.
  * 이 때, 증가되는 값을 Log Sequence Number라는 용어로 지칭한다.

### InnoDB 엔진의 체크포인트 이벤트
* **InnoDB 스토리지 엔진은 주기적으로 체크포인트 이벤트를 발생시켜 리두 로그와 버퍼 풀의 더티 페이지를 디스크로 동기화**한다.
  * 이 때, **발생한 체크포인트 중 가장 마지막에 발생한 체크포인트 지점의 LSN은 활성 리두 로그 공간의 시작점**이 된다.
  * 반면, 활성 리두 로그 공간 자체는 계속해서 증가해나가므로 체크포인트와 무관하다.
* 가장 **마지막 체크 포인트의 LSN과 마지막 리두 로그 엔트리의 LSN 차이를 체크포인트 에이지하고 하며, 이는 곧 활성 리두 로그 공간의 크기**와 같다.
  * 활성 리두 로그 공간의 크기이지, 리두 로그 파일 공간 자체가 아니다.
* InnoDB 버퍼 풀의 더티 페이지는 임의의 리두 로그 엔트리와 관계를 갖는다.
  * 이 때, **체크포인트 이벤트가 발생하는 경우 체크포인트 LSN보다 작은 리두 로그 엔트리와 관련된 모든 더티 페이지는 디스크로 동기화**된다.

### 적절한 리두 로그 파일 크기의 결정
* 리두 로그 파일의 크기가 너무 작은 경우, 애초에 저장할 수 있는 데이터 페이지의 크기가 너무 적을 수 밖에 없다. 
* 반면 리두 로그 파일의 크기가 너무 큰 경우, 갑작스러운 디스크 쓰기 이벤트로 인해 너무 많은 더티 페이지를 한 번에 디스크에 동기화해야할 수 있다.
* 때문에 버퍼 풀의 크기가 100GB 정도인 MySQL 서버를 기준으로, 우선 리두 로그 파일의 전체 크기는 5 ~ 10GB 수준으로 설정하는 것이 권장된다.
  * 이후에 **필요를 느낄 때마다 점진적으로 크기를 늘려가면서 리두 로그 파일의 크기를 최적화하는 것이 바람직**하다.

### 버퍼 풀과 리두 로그의 결론
* 버퍼 풀의 주 목적 중 하나는 데이터 캐싱이므로, 자주 접근되는 페이지는 기본적으로 버퍼 풀에 캐시된다.
  * 이 때, 처음으로 조회되어 버퍼 풀에 캐시된 페이지는 아직 수정이 가해지지 않은 클린 페이지에 해당한다.
* 반면 INSERT나 UPDATE, DELETE 쿼리를 활용하여 가해진 변경 사항은 버퍼 풀에 우선 적용되며, 이렇게 변경이 발생한 페이지는 더티 페이지가 된다.
* 기본적으로 InnoDB는 버퍼 풀의 어떤 페이지가 더티 페이지인지 알 수 없으므로, 더티 페이지의 정보를 리두 로그 파일에도 작성한다.
  * 리두 로그 파일은 여러 로그 엔트리로 구성되며, 각 로그 엔트리는 변경이 가해진 더티 페이지의 정보를 갖는다.
  * 리두 로그 파일은 동적으로 파일의 크기가 늘어나지 않으므로, 각각의 로그 엔트리는 언젠가는 덮어씌여질 수 밖에 없다.
  * 이를 위해 InnoDB는 이미 더티 페이지와 관계를 맺은 로그 엔트리를 구분해야 하며, 이를 활성 리두 로그 공간이라고 지칭한다.
* 각 로그 엔트리는 새로 기록될 때마다 점진적으로 증가하는 LSN 값을 가진다.
  * 이 때, LSN 값은 InnoDB에 의해 발생하는 체크포인트 이벤트에 의해 디스크에 동기화할 로그 엔트리를 결정하기 위해 사용된다.
* 즉, **리두 로그는 버퍼 풀에 가해진 변경 사항을 적시에 디스크에도 동기화하기 위해 메모리에 할당된 공간**이다.

### 버퍼 풀 플러시란?
* **InnoDB 스토리지 엔진은 버퍼 풀에서 아직 디스크로 기록되지 않은 더티 페이지들을 디스크에 동기화하기 위해 다음과 같은 기능을 백그라운드에서 실행**한다.
  1. 플러시 리스트 플러시
  2. LRU 리스트 플러시
* **이는 성능상 악영향을 주지 않으면서 디스크에 동기화하기 위한 기능이며, MySQL 5.7 이후에는 대부분의 경우 디스크 쓰기 폭증 현상이 발생하지 않는다**.
  * 때문에 서비스 운영 시 특별한 문제가 발생하지 않는다면 버퍼 풀 플러시와 관련된 시스템 변수를 손 댈 필요가 없다.
  * 반면, MySQL 5.6 버전 이전에는 더티 페이지 플러시로 인해 디스크 쓰기 작업이 폭증하여 사용자의 쿼리를 처리하는 성능에 악영향을 주곤 했다.

### 플러시 리스트 플러시
* **InnoDB 엔진은 리두 로그 공간을 재활용하기 위해 주기적으로 오래된 리두 로그 엔트리가 점유하는 공간을 비워야 할 필요가 있다**.
  * 그러나 **이를 위해서는 반드시 InnoDB 버퍼 풀에 위치한 더티 페이지가 우선 반드시 디스크로 동기화되어야** 한다.
* 때문에 **InnoDB는 주기적으로 Flush_list 플러시 함수를 호출하여 플러시 리스트로부터 오래 전에 변경된 데이터 페이지를 순서대로 디스크에 동기화**한다.
  * 이 때, 언제 얼마나 많은 더티 페이지를 한 번에 디스크에 써내려가느냐에 따라 사용자의 쿼리 처리에 악영향을 주지 않고 부드럽게 처리될 수 있다.

### 클리너 스레드
* 상술한 이유로 인해 **InnoDB 엔진에서 더티 페이지를 디스크로 동기화하는 역할을 수행하는 스레드를 클리너 스레드라고 지칭**한다.
  * 또한, 앞서 다루었듯이 InnoDB 스토리지 엔진은 여러 버퍼 풀 인스턴스를 동시에 사용할 수 있다.
  * 때문에 하나의 클리너 스레드는 설정에 따라 여러 버퍼 풀 인스턴스를 처리할 수도 있으나, 여러 클리너 스레드가 하나의 버퍼 풀 인스턴스를 처리하지는 않는다.

### 디스크 쓰기 폭발 현상
* InnoDB 버퍼 풀은 클린 페이지 이외에도 사용자의 DML로 인해 변경된 더티 페이지를 함께 가질 수 있다.
  * 그러나 버퍼 풀은 한계가 있으므로, 무한정 더티 페이지를 유지할 수는 없다.
* 기본적으로 InnoDB 엔진은 전체 버퍼 풀이 갖는 페이지의 9할까지 더티 페이지를 가질 수 있으며, 이러한 비율 역시 시스템 변수를 통해 조절할 수 있다.
  * **일반적으로는 버퍼 풀이 디스크 쓰기 작업을 버퍼링하므로, 더티 페이지를 많이 가질수록 디스크 쓰기 작업을 최소화**할 수 있다.
  * 때문에 해당 시스템 변수는 가능한 한 기본 값을 설정하는 것이 바람직하다.
* 반면, 버퍼 풀에 더티 페이지가 많을 수록 디스크 쓰기 폭발 현상이 발생할 가능성은 높아진다.
  * 디스크 쓰기 폭발 현상이란 디스크로 기록되는 더티 페이지 수보다 더 많은 더티 페이지가 발생할 때 나타날 수 있는 현상이다.
  * 더티 페이지의 비율이 버퍼 풀의 9할을 넘어서는 경우 InnoDB는 더티 페이지를 디스크로 기록해야한다고 판단하며, 이로 인해 디스크 쓰기가 폭증할 수 있다.
  * 해당 현상을 완화하기 위해 InnoDB에서는 시스템 변수를 활용하여 일정 수준 이상의 더티 페이지가 발생했을 때 이를 디스크로 기록하도록 한다.

### 어댑티브 플러시 기능
* 자신이 관리하는 MySQL 서버를 계속해서 모니터링하며 시스템 변수를 수정하는 것은 상당히 번거로운 일이다.
  * 때문에 InnoDB 스토리지 엔진은 어댑티브 플러시 기능을 제공한다.
* **어댑티브 플러시 기능을 활성화할 경우, 단순히 버퍼 풀의 더티 페이지 비율 또는 기타 몇몇 시스템 변수에 의존하지 않고 새로운 알고리즘을 사용**한다.
  * 예를 들어 **더티 페이지를 얼마나 디스크에 기록할지 결정하는 것은 다시 말해 어느 정도 속도로 더티 페이지가 증가하는지 분석하는 것**과 같다.
  * 또한, **이는 결국 리두 로그가 어느 정도 속도로 증가하고 있는지 분석하는 것**이기도 하다.
* **어댑티브 플러시 알고리즘은 리두 로그의 증가 속도를 분석하며, 이를 토대로 적절한 수준의 더티 페이지가 버퍼 풀에 유지되도록 디스크 쓰기를 수행**한다.
  * 기본적으로는 전체 리두 로그 공간에서 활성 리두 로그 공간이 1할을 넘는 경우에 어댑티브 플러시 알고리즘이 동작한다.

### LRU 리스트 플러시
* **InnoDB 엔진은 LRU 리스트로부터 사용 빈도가 낮은 데이터 페이지를 제거하여 새로운 페이지를 읽어들일 여유 공간을 만들 필요가 있다**.
  * 이를 위해서 LRU_list 플러시 함수가 사용되며, InnoDB는 LRU 리스트의 끝에서부터 시작하여 시스템 변수의 값만큼 페이지를 스캔한다.
* **InnoDB 엔진은 LRU 리스트를 스캔하면서 더티 페이지를 디스크에 동기화하도록 하며, 클린 페이지는 즉시 Free 리스트로 옮겨둔다**.

## 2022-09-21 Wed
### 버퍼 풀 워밍 업과 강제 워밍 업
```
> InnoDB 스토리지 엔진의 버퍼 풀은 쿼리의 성능과 매우 밀접한 관계를 갖는다. 
> 극단적으로, 쿼리 요청이 빈번한 서버를 재시작하는 경우 쿼리의 처리 성능은 10%꺼지 떨어질 수 있다.
```
* **버퍼 풀에는 쿼리들이 사용할 데이터가 이미 준비되어 있으며, 이로 인해 디스크로부터 데이터를 직접 읽지 않더라도 쿼리가 처리**될 수 있다.
  * 이렇듯 버퍼 풀에 디스크의 데이터가 적절히 적재되어 있는 상태를 워밍 업이라고 지칭한다.
* **버퍼 풀이 잘 워밍 업 된 상태라면, 그렇지 않은 경우에 비해 수십 배의 쿼리 성능**을 보일 수 있다.
  * 이로 인해 MySQL 5.5 버전 에서는 MySQL 서버가 재시작되는 경우, 서비스를 오픈하기 전에 강제 워밍 업을 진행하는 것이 일반적이었다.
  * 이 때, **강제 워밍 업이란 주요한 테이블과 인덱스에 대해 풀 스캔을 의도적으로 실행하는 것을 의미**한다.

### 버퍼 풀 덤프 및 적재 기능
* 상술한 불편함을 해소하기 위해, MySQL 5.6 버전부터는 버퍼 풀 덤프와 적재 기능이 각각 도입되었다.
* MySQL 서버를 재시작해야할 필요가 있는 경우, 서버를 종료하기 전에 `innodb_buffer_pool_dumb_now=ON` 명령어를 통해 버퍼 풀의 상태를 백업한다.
  * 또한, 서버를 재시작한 후에는 `innodb_buffer_pool_load_now=ON` 명령어를 통해 백업된 버퍼 풀의 상태를 복구할 수 있다.
* InnoDB 스토리지 엔진의 버퍼 풀 백업은 데이터 디렉토리에 `ib_buffer_pool` 이라는 파일로 생성되며, 일반적인 크기는 수십 MB 수준에 그친다.
  * 이는 **실제로 InnoDB 버퍼 풀이 아무리 크더라도, 버퍼 풀의 LRU 리스트에 적재된 데이터 페이지의 메타 정보만을 저장하기 때문**이다.
  * 이로 인해 버퍼 풀의 백업 자체는 매우 빠르게 완료된다.
  * 또한, **InnoDB 엔진은 해당 파일로 복구를 시동하는 경우 존재하지 않는 데이터 페이지 정보가 발견되더라도 무시하고 복구를 진행**한다. 
  * 이로 인해 실제로 존재하지 않는 데이터 페이지가 `ib_buffer_pool` 파일의 목록에 명시되어 있더라도 MySQL 서버가 비정상 종료되는 일은 발생하지 않는다. 
* **백업된 버퍼 풀의 내용을 다시 복구하는 경우, InnoDB에 할당된 버퍼 풀의 크기에 따라 상당한 시간이 소요**될 수 있다.
  * 이는 백업된 내용으로부터 각 테이블의 데이터 페이지를 다시 디스크로부터 읽어들어야 하기 때문이다.
* 버퍼 풀 적재 작업은 오랜 시간이 소요될 수 있는 반면, 버퍼 풀 복구가 실행 중인 상태에서 급히 서비스를 시작해야하는 상황이 발생할 수도 있다.
  * 이 경우 `innodb_buffer_pool_load_abort=ON` 명령어를 활용하여 복구 작업을 도중에 중단할 수 있다.
  * 이렇듯 급히 서비스를 시작할 필요가 있는 경우, 해당 시스템 변수를 활용하여 버퍼 풀의 복구를 중단하는 것이 바람직하다.

### 자동 버퍼 풀 덤프 및 적재
* 상술한 **InnoDB 스토리지 엔진 버퍼 풀의 백업과 복구 과정은 수동으로 진행하기에는 백업 또는 복구 과정을 잊는 등 휴먼 에러가 발생하기 쉽다**.
* 이로 인해 InnoDB 엔진은 MySQL 서버가 종료되기 직전에 버퍼 풀의 백업을 실행하거나, 시작될 때 자동으로 버퍼 풀을 복구하는 기능을 다음과 같이 제공한다.
  1. `innodb_buffer_pool_dump_at_shutdown`: 버퍼 풀의 백업을 자동화한다.
  2. `innodb_buffer_pool_load_at_startup`: 버퍼 풀의 복구를 자동화한다.
* 이 때, 상술한 자동 백업 및 복구 기능은 MySQL 서버의 설정 파일에 작성해야 한다.

### 버퍼 풀에 적재된 내용을 확인하기
* **MySQL 5.6 버전부터는 `information_schema` DB의 `information_buffer_page` 테이블을 활용하여 버퍼 풀을 확인**할 수 있다.
  * 예를 들어, **해당 테이블을 활용하여 InnoDB 버퍼 풀에 할당된 메모리에 어떤 테이블의 페이지들이 적재되어 있는지 확인**할 수 있다
* 그러나 **버퍼 풀이 너무 큰 경우에는 해당 테이블을 조회하는 것 자체가 상당히 큰 부하를 발생시키며, 이로 인해 서비스 쿼리가 느려질 가능성이 존재**한다.
  * 즉, 실제 서비스에서는 버퍼 풀의 상태를 확인하는 것이 사실 상 불가능에 가까웠다.
* **이러한 문제를 해결하기 위해 MySQL 8.0 버전부터는 `information_schema` DB에 `innodb_cached_indexes` 테이블이 추가**되었다.
  * **해당 테이블을 활용하는 경우, 각 테이블의 인덱스 별로 데이터 페이지가 얼마나 버퍼 풀에 적재되어 있는지 확인**할 수 있다.
  * 나아가 이러한 사실을 응용하는 경우, 인덱스와 테이블의 전체 페이지 중 몇 개의 페이지가 버퍼 풀에 적재되었는지 대략적인 비율을 확인할 수도 있다.

### Partial page 현상
* InnoDB 스토리지 엔진의 **리두 로그는 리두 로그 공간의 낭비를 방지하기 위해 페이지 전체가 아닌 페이지의 변경 내용만을 기록**한다.
* 이로 인해 InnoDB 엔진으로부터 더티 페이지를 디스크로 플러시할 때 문제가 발생하여 일부만 기록되는 경우, 해당 페이지의 내용은 복구할 수 없을 수도 있다.
* 이렇듯 **페이지가 일부만 기록되는 현상은 Partial 페이지 또는 Torn 페이지 현상이라고 지칭**한다.
  * 이러한 현상은 주로 하드웨어 이슈 또는 시스템의 비정상 종료 등으로 인해 발생할 수 있다.

### Double write buffer
```
> InnoDB 엔진은 파셜 페이지 현상을 방지하기 위해 Double write 기법을 사용한다.
```
* A ~ E까지의 더티 페이지를 디스크로 플러시하는 경우, 더블 라이트 기법이 활성화되어 있다면 InnoDB 스토리지 엔진은 다음과 같이 동작한다.
  1. 우선 실제 데이터 파일에 변경 내용을 플러시하기 전에 A ~ E 페이지를 하나로 묶는다.
  2. **1.의 과정에서 구성한 하나의 페이지 묶음을 한 번의 디스크 쓰기로 시스템 테이블 스페이스의 더블 라이트 버퍼에 기록**한다.
  3. 이후, **InnoDB 스토리지 엔진은 각각의 더티 페이지를 실제 데이터 파일의 필요한 위치에 하나씩 랜덤으로 써내려간다**.
  4. 2.의 과정에서 **더블 라이트 버퍼 공간에 기록된 변경 내용은 실제 데이터 파일에 모든 페이지가 정상적으로 기록되는 경우, 더 이상 필요가 없다**.
* 반면, 상술한 3.의 과정에서 임의의 페이지를 기록하던 도중 하드웨어 이슈 또는 OS 종료로 인해 쓰기 작업이 중단되었다면 InnoDB 엔진은 다음과 같이 동작한다.
  1. **InnoDB 스토리지 엔진은 재시작 과정에서 반드시 더블 라이트 버퍼의 내용과, 데이터 파일에서 연관된 모든 페이지를 비교**한다.
  2. 1.의 과정에서 **서로 다른 내용을 갖는 페이지가 발견된 경우, 더블 라이트 버퍼의 내용을 데이터 파일의 페이지로 복사**한다.
* 이 때, 이러한 더블 라이트 기능은 `innodb_doublewrite` 시스템 변수를 통해 활성화하거나 비활성화할 수 있다.

### HDD와 SSD에서의 Double write buffer
* 상술한 바와 같이, 더블 라이트 버퍼는 데이터의 안전성을 위해 사용된다.
* 이 때, **HDD와 같은 자기 원판 장치에서는 한 번의 순차 디스크 쓰기만을 추가하는 것과 같으므로 기능을 활성화하더라도 부담이 크지 않다**.
  * 그러나 **순차 IO와 랜덤 IO의 비용이 비슷한 SSD 장치의 경우 더블 라이트 버퍼의 활성화가 부담**이 될 수 있다.
  * 그럼에도 데이터의 무결성이 매우 중요한 서비스의 경우, 더블 라이트 버퍼 기능의 활성화를 고려하는 것이 바람직하다.
* 무결성이 중요한 서비스라면 COMMIT 시점에 더블 라이트 버퍼를 비롯하여 리두 로그와 복제를 위한 바이너리 로그 등, 동기화해야할 것이 많다.
  * 따라서 리두 로그는 동기화하지 않지만 더블 라이트 버퍼는 활성화하는 것은 바람직하지 않은 접근 방법에 해당한다.

## 2022-09-22 Thu
### 언두 로그란?
```
> 언두 영역은 INSERT나 UPDATE, DELETE 등의 문장으로 데이터를 변경했을 때 변경되기 전의 데이터를 보관하는 공간이다.
```
* **InnoDB 엔진은 트랜잭션과 격리 수준을 다음과 같이 보장하기 위해 DML로 변경되기 이전의 데이터를 별도로 백업하며, 이를 언두 로그라고 지칭**한다.
  1. 트랜잭션 보장: **트랜잭션이 롤백되면 원자성을 보장하기 위해 변경 전 데이터로 복구할 필요가 있으며, 이러한 변경 전 데이터를 언두 로그에 백업**한다.
  2. 격리 수준 보장: **트랜잭션 격리 수준에 맞게 임의의 커넥션에서 변경 중인 레코드 대신 언두 로그에 백업해둔 데이터를 반환**하기도 한다.
* 이렇듯 언두 로그는 InnoDB 스토리지 엔진에서 매우 중요하지만, 그만큼 관리 비용도 많이 필요한 축에 속한다.

### 언두 로그의 용도
* 예를 들어 UPDATE 문으로 임의의 레코드가 갖는 컬럼을 변경할 경우, 변경 내용은 다음과 같이 반영된다.
  1. 데이터와 인덱스 버퍼 등 실제 데이터 파일: 변경 내용이 적용된다.
  2. 언두 영역: 변경 이전의 값이 백언된다.
* 이 때, **변경된 내용을 사용자가 커밋할 경우 현재 상태를 그대로 유지하는 반면 롤백할 경우 언두 영역에 백업된 데이터를 실제 데이터 파일로 복구**한다.
* 이렇듯, 언두 로그의 용도는 크게 다음과 같이 분류된다.
  1. 트랜잭션의 롤백에 대비하여 원본 데이터를 백업한다.
  2. 트랜잭션의 격리 수준을 유지하면서도 높은 동시성을 제공한다.
* **트랜잭션 격리 수준이란 동시에 여러 트랜잭션이 데이터를 변경 및 조회하는 경우 해당 작업 내용이 다른 트랜잭션에 어떻게 보여질지 결정하는 기준**이다.

### 언두 로그 공간의 폭증
* MySQL 5.5 버전 이전의 경우, MySQL 서버에서 한 번 증가한 언두 로그 공간은 다시 줄어들지 않았다.
  * 예를 들어 약 100GB의 1억 개 레코드를 제거하는 경우 테이블에서는 레코드가 삭제되지만, 언두 로그의 공간 사용량은 100GB로 늘어나게 된다.
* 또한 **대용량 데이터를 처리하는 트랜잭션 외에도 트랜잭션이 오랜 시간 실행되는 경우, 언두 로그의 양은 급격히 증가**할 수 있다.
  * 무엇보다, **트랜잭션이 완료되었다고 해서 해당 트랜잭션이 생성한 언두 로그를 즉시 삭제할 수 있는 것은 아니다**.
* 예를 들어 트랜잭션 A와 B, C가 다음과 같이 요청을 처리한다고 가정한다.
  1. 트랜잭션 A가 트랜잭션을 시작한다.
  2. 트랜잭션 B가 트랜잭션을 시작한 후 UPDATE 및 DELETE 문을 실행하고, 트랜잭션을 종료한다.
  3. 트랜잭션 C가 트랜잭션을 시작한 후 UPDATE 및 DELETE 문을 실행하고, 트랜잭션을 종료한다.
* 이 경우, **트랜잭션 B와 C의 DML로 인해 변경이 적용되기 이전의 데이터는 언두 로그에 백업**된다.
  * 그러나 **트랜잭션 A가 아직 활성 상태이므로, 트랜잭션 B와 C의 완료 상태와 관계 없이 언두 로그는 삭제되지 않는다**.
  * 이러한 문제는 크게 애플리케이션의 트랜잭션 관리 자체가 잘못되거나, 사용자의 실수로부터 기인하는 경우가 잦다.

### 늘어난 언두 로그 공간이 주는 악영향
* 예를 들어 사용자가 **트랜잭션을 시작한 상태에서 하루 정도 방치된 경우, InnoDB 엔진의 언두 로그는 하루치 데이터 변경 내역을 모두 저장**하게 된다.
* 이로 인해 디스크의 언두 로그 저장 공간은 계속해서 증가하지만, 언뜻 이러한 디스크의 사용량 증가는 큰 문제처럼 보이지 않을 수도 있다.
  * 그러나 **변경된 레코드를 조회하는 쿼리가 자주 실행될 경우, InnoDB는 언두 로그의 이력을 필요한 만큼 스캔해야만 필요한 레코드를 찾을 수 있게 된다**.
  * 즉, 쿼리의 처리 성능 역시 전반적으로 떨어질 수 밖에 없어진다.
* 이렇게 **늘어난 언두 로그 공간은 디스크 사용량 뿐만 아니라 매 번 백업을 위해서도 그 만큼 더 많은 양을 복사해야하는 문제점을 수반**한다.
* 심지어 MySQL 5.5 버전까지는 한 번 늘어난 언두 로그의 사용 공간은 MySQL 서버를 새로 구축하지 않는 이상 줄일 방법이 없었다.
  * 그러나 MySQL 5.7 버전 이후로는 언두 로그 공간의 문제점이 완전히 해결되었다.
  * 예를 들어, MySQL 8.0에서는 언두 로그를 돌아가면서 순차적으로 사용하여 디스크 공간을 줄이거나 적시에 사용 공간을 자동으로 줄이기도 한다.

### 언두 로그 모니터링의 필요성
* 그러나 **여전히 MySQL 서버에서 활성 상태의 트랜잭션이 장기간 유지되는 현상은 좋지 않다**.
* 때문에 언두 로그 레코드의 양을 지속적으로 모니터링하는 것은 바람직하며, 예를 들어 `SHOW ENGINE INNODB STATUS` 명령어를 활용할 수 있다.
  * 이 때, **MySQL 서버에서 실행되는 DML이 얼마나 많은 문장을 변경하느냐에 따라 평소에 언두 로그 영역에 존재하는 레코드 수는 상이**할 수 있다.
  * 때문에 **서버 별로 안정적인 시점에 언두 로그의 레코드 건수를 확인하고, 이를 기준으로 언두 로그의 급증 여부를 모니터링하는 것이 바람직**하다.

### 언두 테이블스페이스 관리하기
* **언두 테이블스페이스란 언두 로그가 실제로 저장되는 공간이며, MySQL 5.6 버전 이전에는 `ibdata.ibd`와 같은 시스템 테이블스페이스에 저장**되었다.
  * 그러나 시스템 테이블스페이스에 저장된 언두 로그는 확장성에 한계가 있었다.
  * 이로 인해 5.6 버전에서는 별도의 시스템 변수를 두어 언두 로그를 시스템 스페이스 이외의 언두 로그 파일에 저장하는 방법을 제공하였다.
* **MySQL 8.0 버전의 경우 상술한 시스템 변수는 deprecated 처리되었으며, 언제나 시스템 테이블스페이스 외부의 별도 로그 파일에 기록하도록 개선**되었다.
* 또한, **8.0 버전 이전의 경우 한 번 생성한 언두 로그는 변경이 허용되지 않고 정적으로 사용**되었다.
  * 그러나 8.0 버전부터는 `CREATE UNDO TABLESPACE` 또는 `DROP TABLESPACE` 등의 명령을 통해 언두 테이블 스페이스를 동적으로 관리할 수도 있다. 

### 언두 테이블스페이스의 구조
* **언두 테이블 스페이스는 1개 이상 128개 이하의 롤백 세그먼트를 가지며, 각 롤백 세그먼트는 다시 1개 이상의 언두 슬롯**을 갖는다.
  * 이 때, **하나의 롤백 세그먼트는 InnoDB 페이지 크기를 16바이트로 나눈 값만큼의 언두 슬롯**을 가질 수 있다.
  * 예를 들어 InnoDB의 페이지 크기가 16KB인 경우, 하나의 롤백 세그먼트는 1024개의 언두 슬롯을 갖는다.
* **개별 트랜잭션이 필요로 하는 언두 슬롯은 트랜잭션이 실행하는 DML 문장의 특성에 따라 최대 4개까지 사용**하게 된다.
  * **일반적으로는 트랜잭션이 임시 테이블을 사용하지 않으므로, 개 별 트랜잭션은 대강 2개의 언두 슬롯을 필요로 한다고 가정**할 수 있다.
* **언두 로그 공간은 남아도 크게 문제되지 않는 반면, 언두 로그 슬롯 자체가 부족한 경우에는 트랜잭션을 시작할 수 없는 심각한 문제가 발생**할 수 있다.

### undo tablespace truncate
* Undo tablespace truncate란 언두 테이블스페이스 공간을 필요한만큼만 남기고, 불필요하거나 과도하게 할당된 공간을 반납하는 것을 의미한다.
* 해당 기능은 다음과 같이 자동 또는 수동으로 설정할 수 있으나, 두 방법 모두 MySQL 8.0 버전 이후부터 지원된다.
  1. 자동 모드: **InnoDB 스토리지 엔진의 퍼지 스레드는 주기적으로 깨어나 언두 로그 공간에서 불필요해진 언두 로그를 삭제하는 언두 퍼지를 진행**한다.
     * **트랜잭션이 데이터를 변경하면 이전 버전의 데이터를 언두 로그로 기록하며, COMMIT될 경우 더 이상 언두 로그의 값은 불필요할 것**이다.
     * 자동 모드에서 **퍼지 스레드는 주기적으로 언두 로그 파일에서 사용되지 않는 공간을 잘라내고, OS로 반납**한다.
  2. 수동 모드: 언두 테이블스페이스의 반납이 부진한 경우, 언두 테이블 스페이스를 비활성화하여 언두 테이블스페이스가 더 이상 사용되지 않도록 설정한다.
     * 수동 모드에서 **퍼지 스레드는 비활성화된 언두 테이블스페이스를 찾아내 불필요한 공간을 잘라내고, OS로 해당 공간을 반납**한다.
     * **테이블스페이스 자체가 제거되는 것이 아니므로, 불필요한 공간 반납이 완료된 경우 해당 테이블스페이스는 다시 활성화**해야 한다.
     * 이 때, 수동 모드의 Undo tablespace truncate 기능은 언두 테이블스페이스가 최소한 3 개 이상이어야 동작한다.
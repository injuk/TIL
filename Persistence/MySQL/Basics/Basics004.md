# Basics
## 2022-09-14 Wed

### MySQL 서버의 구조
* **MySQL 서버는 사람으로 따지면 머리 역할을 담당하는 MySQL 엔진과 손 발 역할을 수행하는 스토리지 엔진으로 구분**할 수 있다.
  * 이 때, 스토리지 엔진은 핸들러 API를 만족하기만 한다면 누구나 직접 구현하여 MySQL 서버에 추가할 수 있다.
  * 또한 **MySQL 엔진과 스토리지 엔진을 합쳐 MySQL 또는 MySQL 서버라는 용어로 지칭**한다.
* MySQL은 일반적인 상용 RDBMS와 같이 대부분의 프로그래밍 언어로부터의 접근 방법 역시 모두 지원한다.
  * 이로 인해 C는 물론 JDBC, 파이썬 등 많은 언어를 통해 MySQL 서버에서 쿼리를 사용할 수 있다.
* MySQL 서버는 MySQL 엔진에 더해 스토리지 엔진으로서 기본적으로 InnoDB와 MyISAM을 제공한다.

### MySQL 엔진의 특징
```
> MySQL 엔진은 요청된 SQL 문장을 분석하거나 최적화하는 등 DBMS의 두뇌에 해당하는 처리를 수행한다.
```
* MySQL 엔진은 클라이언트로부터 발생하는 접속 및 쿼리 요청을 처리하는 커넥션 핸들러에 더해 다음과 같은 분류를 갖는다.
  1. SQL 파서 및 전처리기
  2. 쿼리의 최적화된 실행을 위한 SQL 옵티마이저
  3. SQL 인터페이스
  4. 캐시와 버퍼
* 또한, **MySQL은 표준 SQL인 ANSI SQL 문법을 지원하므로 표준 문법에 따라 작성된 쿼리는 다른 DBMS와 호환되어 실행**될 수 있다.

### 스토리지 엔진의 특징
```
> 스토리지 엔진은 실제 데이터를 디스크에 저장하거나, 디스크로부터 데이터를 읽어오는 역할을 담당한다.
> MySQL 서버에서 MySQL 엔진의 종류는 단 하나지만, 스토리지 엔진은 여러 종류를 동시에 사용할 수 있다.
```
* **테이블 생성시 사용할 스토리지 엔진을 명시하는 경우, 이후에 해당 테이블로부터 발생하는 모든 읽기 또는 변경 작업은 정의된 스토리지 엔진에 의해 처리**된다.
  * 예를 들어, `CREATE TABLE table_name (id INT) ENGINE=InnoDB`와 같은 형태로 명시한다.
  * 상술한 쿼리에서, 이후의 모든 INSERT / UPDATE / DELETE /SELECT 등의 작업은 InnoDB 스토리지 엔진에 의해 처리된다.
* 이 때, **각각의 스토리지 엔진은 성능 향상을 위해 키 캐시 또는 버퍼 풀과 같은 기능을 내장**한다.
  1. 키 캐시: MyISAM 스토리지 엔진에서 성능 향상을 위해 사용하는 기능이다.
  2. **버퍼 풀: InnoDB 스토리지 엔진에서 성능 향상을 위해 사용하는 기능**이다.

### Handler API
* MySQL 엔진의 쿼리 실행기에서 실제 데이터를 읽거나 쓰는 경우 각각의 스토리지 엔진에 쓰기 또는 읽기 작업을 요청해야 한다.
  * 이 때, **이러한 요청을 핸들러 요청이라고 하며 각 경우에 사용되는 API를 핸들러 API**라고 한다.
  * InnoDB 스토리지 엔진 역시 이러한 핸들러 API를 활용하여 MySQL 엔진과 데이터를 주고받는다.
* 핸들러 API를 활용하여 얼마나 많은 레코드 작업이 있었는지 확인하고자 하는 경우, 다음과 같은 명령어를 활용할 수 있다.
```
SHOW GLOBAL STATUS LIKE 'Handler%';
```

## 2022-09-15 Thu
### MySQL 서버 스레딩
* **MySQL 서버는 프로세스 기반이 아닌 스레드 기반으로 동작하며, 스레드는 다시 포그라운드 스레드와 백그라운드 스레드로 구분**할 수 있다.
* 이 때, MySQL 서버에서 실행 중인 스레드의 목록은 `performance_schema` 데이터베이스의 `threads` 테이블을 통해 확인할 수 있다.
  * 이 중 백그라운드 스레드의 개수는 MySQL 서버의 설정 내용에 따라 가변적이다.
  * 또한, 여러 스레드가 동일 작업을 병렬로 처리하는 경우 동일한 이름의 스레드가 존재할 수도 있다.
* **이러한 스레드 모델은 MySQL 커뮤니티 에디션이 갖는 전통적인 스레드 모델이며, 커넥션 별로 포그라운드 스레드를 하나씩 생성하는 1:1 관계를 유지**한다.
  * 반면, MySQL 엔터프라이즈 에디션은 스레드 풀 모델을 사용하며 하나의 스레드가 여러 개의 커넥션 요청을 처리한다.

### 포그라운드 스레드
* **포그라운드 스레드는 클라이언트 스레드라고도 하며, 최소한 MySQL 서버에 접속된 클라이언트 수만큼 존재**한다.
  * 포그라운드 스레드는 주로 각각의 클라이언트 사용자가 요청하는 쿼리를 처리한다.
* **클라이언트 사용자가 작업을 마치고 커넥션을 종료할 경우, 해당 커넥션을 담당하던 스레드는 스레드 캐시로 돌아간다**.
  * 이 때, 이미 스레드 캐시에 일정한 개수 이상의 스레드가 존재하는 경우 스레드 캐시에 넣지 않고 스레드를 종료한다.
  * 이렇듯 일정 개수의 스레드만이 스레드 캐시에 존재하게 하며, 이러한 스레드의 최대 개수는 `thread_cahce_size` 시스템 변수로 설정할 수 있다.
* **포그라운드 스레드는 기본적으로 데이터를 MySQL의 데이터 버퍼나 캐시로부터 조회**한다. 
  * 만약 **버퍼나 캐시에 필요한 데이터가 없는 경우, 직접 디스크 데이터나 인덱스 파일로부터 조회하여 작업을 처리**한다.
  * 이 때, MyISAM의 경우 디스크 쓰기 작업까지 포그라운드 스레드가 처리한다.
  * 반면, **InnoDB 경우 데이터 버퍼나 캐시까지만 포그라운드 스레드가 처리하고 버퍼로부터 디스크에 기록하는 나머지 작업은 백그라운드 스레드가 처리**한다.

### 사용자 스레드와 포그라운드 스레드
* MySQL에서 사용자 스레드와 포그라운드 스레드는 같은 의미로 사용된다.
* **클라이언트가 MySQL 서버에 접속하는 경우 MySQL 서버는 해당 클라이언트의 요청을 처리할 스레드를 생성하여 해당 클라이언트에게 할당**한다.
  * **해당 스레드는 DBMS의 앞단에서 클라이언트인 사용자와 통신하므로 포그라운드 스레드라는 용어로 지칭**한다.
  * 또한, **사용자가 요청한 작업을 처리하는 스레드이기에 사용자 스레드라고도 지칭**할 수 있게 된다.

### 백그라운드 스레드
* InnoDB의 경우, 다음과 같은 작업은 백그라운드로 처리된다.
  1. 인서트 버퍼를 병합하는 스레드
  2. 로그를 디스크로 기록하는 스레드
  3. InnoDB 버퍼 풀의 데이터를 디스크에 기록하는 스레드
  4. 데이터를 버퍼로 읽어들이는 스레드
  5. 잠금 또는 데드락을 모니터링하는 스레드
* 모두 중요하지만, 이 중 **특히 중요한 것은 로그 스레드와 버퍼의 데이터를 디스크로 써내려가는 쓰기 스레드**가 된다.
* InnoDB의 경우 데이터를 읽는 작업을 주로 클라이언트 스레드에서 처리하므로, 읽기 스레드는 굳이 많이 설정할 필요가 없다.
  * 그러나 **쓰기 스레드는 많은 작업을 백그라운드에서 처리하므로 환경에 따라 디스크를 최적으로 사용할 수 있을 정도로 충분히 설정하는 것이 바람직**하다.
* 사용자의 **요청을 처리하는 도중 데이터의 쓰기 작업은 버퍼링과 같이 지연 처리될 수 있으나, 데이터의 읽기 작업은 절대로 지연되지 않아야 한다**.
  * 이로 인해 **대부분의 상용 DBMS에서는 대부분 쓰기 작업을 버퍼링하여 일괄 처리하는 기능이 탑재되어 있으며, InnoDB 역시 마찬가지 방식으로 동작**한다.

### 메모리 할당과 구조
* **MySQL에서 사용되는 메모리는 크게 글로벌 메모리 영역과 로컬 메모리 영역으로 구분되며, 둘의 차이는 많은 스레드가 공유하는 공간인지 여부**에 따른다.
  * 특히 글로벌 메모리 영역의 모든 메모리 공간은 MySQL 서버가 시작되면서 운영체제로부터 할당된다.
  * 이 때, **각각의 운영체제 별 메모리 할당 방식은 상당히 복잡하므로 MySQL 서버가 사용하는 정확한 메모리 양을 측정하는 것은 쉽지 않다**.

### 글로벌 메모리 영역
* **일반적으로 클라이언트 스레드의 수와는 관계 없이 하나의 메모리 공간만이 할당**된다.
  * 필요한 경우 2개 이상의 메모리 공간을 할당받을 수도 있지만, 이 역시도 클라이언트 스레드의 개수와는 관계가 없다.
  * 또한, **생성된 글로벌 영역이 2개 이상이라고 하더라도 항상 모든 스레드에 의해 공유**된다.
* 이 때, 글로벌 메모리 영역은 크게 다음과 같이 분류된다.
  1. 테이블 캐시
  2. InnoDB 버퍼 풀
  3. InnoDB 어댑티브 해시 인덱스
  4. InnoDB 리두 로그 버퍼

### 로컬 메모리 영역
* 로컬 메모리 영역은 MySQL 서버 상에 존재하는 클라이언트 스레드가 쿼리를 처리하기 위해 사용하는 메모리 영역이다.
  * **클라이언트가 MySQL 서버에 접속하는 경우 MySQL 서버는 클라이언트 커넥션으로부터의 요청을 처리하기 위해 스레드를 각각 할당**한다.
  * 이러한 클라이언트 스레드가 사용하는 메모리 공간이므로 클라이언트 메모리 영역이라고도 하며, 커넥션을 세션이라고 표현하여 세션 메모리 영역이라고도 한다.
* **로컬 메모리 영역은 각각의 클라이언트 스레드 별로 독립적으로 할당되며, 절대 스레드 간에 공유되어 사용되지 않는다**.
  * 로컬 메모리 영역의 크기 역시 적절히 설정되어야 하며, 그렇지 않은 경우 MySQL 서버가 메모리 부족으로 인해 멈출 가능성이 희박하게나마 존재한다.
* 또한, **로컬 메모리 영역에는 각 쿼리의 용도 별로 필요할 경우에만 공간이 할당**된다.
  * 이는 즉, **쿼리의 용도에 따라서는 MySQL 서버가 메모리 공간을 전혀 할당하지 않을 수도 있다는 점을 시사**한다.
  * 예를 들어, 소트 버퍼 또는 조인 버퍼가 이러한 경우에 해당한다.
* **로컬 메모리 영역은 커넥션이 유지되는 동안 계속 할당된 상태로 남아 있는 공간과, 쿼리가 실행되는 순간에만 할당하고 이후에 해제되는 공간도 존재**한다.
  * 예를 들어, **커넥션 버퍼와 결과 버퍼는 커넥션이 유지되는 동안 계속해서 할당된 상태**로 남아 있는다.
  * 반면, **소트 버퍼와 조인 버퍼는 쿼리를 실행하는 순간에만 할당했다가 다시 해제하는 공간에 해당**한다.
* 이 때, 로컬 메모리 영역은 크게 다음과 같이 분류된다.
  1. 소트 버퍼
  2. 조인 버퍼
  3. 바이너리 로그 캐시
  4. 네트워크 버퍼

## 2022-09-16 Fri
### 플러그인 스토리지 엔진 모델
* MySQL은 기본적으로 많은 스토리지 엔진을 갖고 있지만, 이 조차도 세상의 모든 요구 조건을 만족시킬 수는 없다.
  * 이에 따라 개발 회사 또는 사용자는 자신의 요구사항을 충족하는 스토리지 엔진을 직접 개발하여 사용할 수도 있다.
* 또한, **MySQL 서버는 스토리지 엔진 뿐만 아니라 다양한 기능을 플러그인 형태로 지원**한다.
  * 예를 들어 인증 또는 전문 검색 파서 및 쿼리 재작성과 같은 플러그인이나, 비밀번호 검증과 커넥션 제어 등과 관련된 다양한 플러그인이 존재한다.
  * 이 역시도 MySQL 서버에서 제공하는 기능들을 확장하거나 완전히 새로운 기능을 추가하기 위해 플러그인 API를 활용하여 직접 구현할 수도 있다.

### MySQL에서 쿼리가 실행되는 과정
```
> 하나의 쿼리 작업은 여러가지 하위 작업으로 분류된다.
> 이 때, 각각의 하위 작업이 MySQL 엔진 영역에서 처리되는지 스토리지 엔진 영역에서 처리되는지 구분할 수 있어야 한다. 
```
* MySQL에서 쿼리가 실행되는 과정은 크게 다음과 같이 진행된다.
  1. SQL 파서
  2. SQL 옵티마이저
  3. SQL 실행기
  4. 데이터 읽기 또는 쓰기
* 이 때, **SQL 파서와 옵티마이저 및 실행기로 이어지는 흐름은 MySQL 엔진에서 처리**된다.
  * 반면, **디스크로부터 데이터를 조회하거나 새로운 데이터를 쓰는 작업은 스토리지 엔진의 처리 영역**이 된다.
  * 이로 미루어 보았을 때, 플러그인 형태로 새로운 스토리지 엔진을 작성한다는 것은 DBMS 전체가 아닌 일부 기능만을 수행하는 엔진을 정의한다는 의미를 갖는다.
* 반면, **실질적인 GROUP BY 또는 ORDER BY 등의 복잡한 처리는 스토리지 엔진 영역이 아닌 MySQL 엔진의 쿼리 실행기에서 처리**된다.

### MySQL 핸들러
* **일반적으로 프로그래밍 언어에서 핸들러는 어떠한 기능을 호출하기 위해 사용하는 API를 갖는 객체를 의미**한다.
  * 이 때, **MySQL에서의 핸들러는 MySQL 엔진이 스토리지 엔진을 조정하기 위해 사용하는 API를 의미**한다.
  * 이렇듯 **MySQL 엔진이 각각의 스토리지 엔진으로부터 데이터를 조회하거나 저장하도록 명령하기 위해서는 반드시 핸들러를 통해야 한다**.
* MySQL 서버의 경우, `Handler_`라는 접두사로 시작하는 상태 변수가 MySQL 엔진이 스토리지 엔진에 보낸 명령의 횟수를 의미하는 상태 변수가 된다.
* **핸들러의 존재로 인해 여러 종류의 스토리지 엔진을 사용하는 테이블에 대해 실행된 쿼리 역시 MySQL의 처리 내용은 대부분 동일**해진다.
  * 정확히는 단순히 테이블 별 스토리지 엔진에 따른 데이터의 읽기 및 쓰기 영역에 대한 차이만이 존재한다.

### MySQL 서버에서 지원하는 스토리지 엔진 확인하기
* 자신이 설치한 mysqld에서 지원되는 스토리지 엔진의 종류는 `SHOW ENGINES` 명령어를 활용하여 확인할 수 있다.
* 이 때, 표시된 정보 중 Support 컬럼은 다음과 같은 값이 표시될 수 있다.
  1. YES: mysqld에 해당 스토리지 엔진이 포함되어 있고, 활성화되어 사용 가능한 상태를 의미한다.
  2. DEFAULT: YES와 동일한 상태이며, 필수 스토리지 엔진이므로 해당 엔진이 없을 경우 MySQL이 시작되지 않을 수도 있음을 의미한다.
  3. NO: 현재의 mysqld에는 포함되지 않은 상태를 의미한다.
  4. DISABLED: mysqld에 포함되어 있으나, 파라미터에 의해 비활성화된 상태를 의미한다.
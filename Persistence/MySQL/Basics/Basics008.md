# Basics
## 2022-09-01 Thu

### 느린 디스크 IO
* CPU나 메모리처럼 전기적인 장치의 성능은 매우 빠른 속도로 발전해왔으나, 디스크와 같은 기계식 장치는 상당히 제한적으로 발전해왔다.
  * **최근에는 자기 디스크를 사용하는 HDD가 아닌 SSD가 많이 활용되고 있으나, 여전히 데이터 저장 매체는 컴퓨터에서 가장 느린 부분을 차지**한다.
* 이러한 이유에서, **데이터베이스의 성능 튜닝은 어떻게 디스크 IO를 줄이느냐에 달려 있는 경우가 많다**.

### SSD와 HDD의 비교
* 상술했듯, **CPU나 메모리와 같은 전자식 장치와 비교하여 HDD는 기계식 장치이므로 언제나 데이터베이스 서버의 병목**이 된다.
* 때문에 기존의 기계식 장치인 HDD를 대체하기 위한 전자식 저장 매체인 SSD가 각광받게 되었으며, 빠르게 HDD의 자리를 대체하고 있다.
  * SSD는 전자식 매체이므로 기계식으로 원판을 회전시킬 필요가 없기에 HDD와 비교하여 훨씬 빠른 IO가 가능하다.
* 반면, 디스크의 헤더를 거의 움직이지 않고 한 번에 많은 데이터를 읽어들이는 순차 IO에서는 SSD와 HDD의 성능이 유사하다.
  * 그러나 **SSD는 HDD와 비교하여 랜덤 IO가 훨씬 빠르다는 장점이 존재**한다.
  * **데이터베이스 서버에서는 순차 IO보다는 작은 데이터를 읽고 쓰는 랜덤 IO 작업의 비중이 훨씬 크기에 SSD의 장점은 DBMS용 스토리지에 최적화**되어 있다.

### 랜덤 IO와 순차 IO
* 디스크의 성능은 디스크 헤더의 위치 이동 없이 얼마나 많은 데이터를 한 번에 기록하느냐에 의해 결정된다.
  * 때문에 **여러번 읽기 또는 쓰기 작업을 요청하는 랜덤 IO 작업의 부하가 훨씬 더 크다**.
  * 이는 디스크 원판을 가지지 않는 SSD에서도 마찬가지이며, 때문에 MySQL에는 그룹 커밋 또는 로그 버퍼 등의 기능이 내장되어 있다.
* 사실 **쿼리를 튜닝하여 랜덤 IO를 순차 IO로 변경하는 방법은 그렇게 많지 않다**.
  * **일반적으로 `쿼리 튜닝은 랜덤 IO 자체를 줄이는 데에 그 목적`이 있다**.
  * 이는 즉, **쿼리를 처리하기 위해 꼭 필요한 데이터만 읽도록 쿼리를 개선하는 것을 의미**한다.
* 일반적으로 **인덱스 레인지 스캔은 데이터를 읽기 위해 주로 랜덤 IO를 사용**한다.
  * 반면, **풀 테이블 스캔은 순차 IO를 사용**하므로 커다란 테이블의 레코드를 대부분 읽는 경우 풀 테이블 스캔을 유도하는 경우도 있다.
  * 이러한 유형의 상호작용은 OLTP 유형의 웹 서비스보다는 데이터 웨어하우스, 또는 통계 작업에서 활용된다.

### 인덱스란?
* DBMS 역시 데이터베이스 테이블의 모든 데이터를 검색하여 결과를 가져오기에는 시간이 많이 걸릴 수 밖에 없다.
  * 때문에 **컬럼의 값과 해당 레코드의 주소를 키 값 형태의 인덱스로 만들어둔다**.
* 또한 **책의 인덱스와 목차 페이지와 마찬가지로, DBMS 역시 인덱스를 통해 빠르게 검색할 수 있도록 데이터를 순서대로 정렬하여 보관**한다.

### 자료 구조와 인덱스
* 여러 자료 구조 중 SortedList와 ArrayList는 다음과 같은 차이가 존재한다.
  1. SortedList: 데이터를 항상 정렬된 상태로 유지한다.
  2. ArrayList: 데이터를 항상 저장된 순서 그대로 유지한다.
* 이 중 데이터를 항상 정렬하는 SortedList는 다음과 같은 특징을 갖는다.
  1. 단점: **데이터를 저장할 때마다 값을 정렬해야하므로 저장 과정이 복잡하고 느리다**.
  2. 장점: **데이터가 이미 정렬되어 있으므로, 원하는 값은 매우 빠르게 조회할 수 있다**.
* **인덱스는 SortedList 자료 구조를 따르며, 저장되는 컬럼의 값을 통해 항상 정렬된 상태를 유지**한다.
* 또한, DBMS의 인덱스 역시 SortedList 자료 구조의 장단점을 그대로 계승한다.
  1. 단점: **인덱스가 많은 테이블일수록 INSERT, UPDATE, DELETE 문의 처리는 느려진다**.
  2. 장점: **이미 정렬된 키 - 값 쌍인 인덱스를 가지고 있으므로, SELECT 문의 처리는 매우 빠르다**.

### DBMS에서의 인덱스
* 상술한 이유에서, **DBMS에서의 인덱스는 결국 데이터의 쓰기 성능을 희생하고 읽기 성능을 높이는 기능**이다.
* 때문에 **테이블에 새로운 인덱스를 추가할지 여부는 데이터의 저장 속도를 얼마나 희생하고, 읽기 속도를 얼마나 높여야 하느냐에 따라 결정**된다.
  * SELECT 문의 WHERE 절에서 사용되는 모든 컬럼을 인덱스로 생성하는 경우, 오히려 데이터의 저장 성능이 떨어지고 인덱스의 크기만 커질 수도 있다.

### 프라이머리 키와 보조 키
* 인덱스는 크게 다음과 같이 분류할 수 있다.
  1. 프라이머리 키: **해당 레코드를 대표하는 컬럼 값으로 구성된 인덱스**이다.
  2. 보조 키: **프라이머리 키를 제외한 모든 나머지 인덱스를 의미하며, 세컨더리 인덱스라고도** 한다.
* 프라이머리 키는 테이블에서 해당 레코드를 식별할 수 있는 기준 값이 되므로 식별자라고도 부를 수 있다.
  * 이 때, **프라이머리 키는 NULL과 중복을 허용하지 않는다**.
* **유니크 인덱스는 프라이머리 키와 성격이 유사하며, 프라이머리 키를 대체할 수도 있으므로 대체 키라고도** 부를 수 있다.
  * 그러나 분류에 따라 별도로 분류할 수도 있고, 때로는 보조 키로 분류되기도 한다.
* 또한, 인덱스는 데이터를 저장하는 알고리즘 또는 중복 허용 여부에 따라 분류할 수도 있다.

### 데이터 저장 방식에 따른 인덱스 분류
```
> B-Tree 알고리즘은 컬럼의 값을 변경하지 않고 원본 값으로 인덱싱한다.
> Hash 알고리즘은 컬럼의 값을 해시 값으로 계산하여 인덱싱한다.
```
* DBMS 인덱스에 적용 가능한 데이터 저장 알고리즘은 수많지만, 일반적인 RDBMS에서 적용되는 대표적인 알고리즘은 크게 다음과 같다.
  1. B-Tree: 가장 일반적으로 사용되는 인덱스 알고리즘이며, 오래 전에 도입되었기에 그만큼 성숙되었다.
     * **B-Tree 알고리즘은 컬럼의 값을 변경하지 않고 원래의 값으로 인덱싱**한다. 
  2. Hash: **컬럼의 값을 해시로 계산하여 인덱싱하며, 매우 빠른 검색을 지원**한다.
     * 그러나 **해당 알고리즘은 값을 변형하므로 전방 일치 검색과 같은 일부 검색 또는 범위 검색 기능을 제공할 수 없다**.
     * **해당 방식은 주로 메모리 기반 데이터베이스에서 사용**된다.

### 데이터 중복 허용 여부에 따른 인덱스 분류
* **중복 허용 여부로 인덱스를 구분할 경우, 유니크 인덱스와 유니크하지 않은 인덱스로 구분**된다.
  * 이는 단순히 중복되는 데이터가 1건만 존재하는지, 그 이상 존재할 수 있는지를 의미한다.
  * 그러나 **이는 동시에 DBMS의 쿼리를 수행할 책임이 있는 옵티마이저에게는 매우 커다란 문제**가 된다.
* **유니크 인덱스는 `=`와 같은 동등 조건으로 검색할 때 1건의 레코드만 찾으면 그 이상 검색할 필요가 없다는 것을 옵티마이저에게 알려주는 효과**를 갖는다.
  * 또한, 이 밖에도 유니크 인덱스로 인한 MySQL 자체의 처리 방식의 변화 또는 차이점 역시 많은 차이점을 보이게 된다. 

## 2022-09-02 Fri
### B-Tree 인덱스란?
```
> B-Tree는 전문 검색과 같은 특수한 요건이 아니라면 대부분의 경우에 사용되는 일반적인 알고리즘이다.
```
* B-Tree 인덱스는 데이터베이스 인덱싱 알고리즘 중 가장 일반적이고, 범용적이며 가장 먼저 도입된 알고리즘이다.
  * 이 때, B는 이진 트리의 Binary가 아닌 Balanced의 앞글자에서 따온 것이다.
* **B-Tree는 기본적으로 칼럼의 앞 부분 일부만을 잘라서 관리하되, 원본 값을 변형하지 않고 항상 정렬된 상태를 유지**한다.

### B-Tree의 구조
* **B-Tree는 최상위에 단일 루트 노드를 갖고, 그 하위에 자식 노드가 붙은 형태**를 갖는다.
  * 이 때, **최하위에 있는 노드는 리프 노드라고 하는 반면 중간의 노드는 브랜치 노드**라고 한다.
* 데이터베이스 상 **인덱스와 실제 데이터는 별도로 관리되지만, 인덱스의 리프 노드는 언제나 실제 데이터 레코드를 찾아낼 수 있는 주소값을 갖는다**.
* 반면, **항상 정렬된 상태를 유지하는 인덱스의 키와는 달리 데이터 파일에 저장되는 실제 레코드는 정렬되지 않고 임의의 순서대로 저장**된다. 
  * 이 때, **데이터 파일의 레코드는 INSERT 만 수행하는 경우가 아니라면 저장된 순서와 맞지 않게 저장될 수 있다**.
  * 이는 **중간 레코드가 DELETE된 경우, DBMS 자체가 빈 공간을 재활용하도록 설계되기 때문**이다.
* 인덱스는 테이블의 키 컬럼만 갖고 있으므로, 나머지 컬럼까지 읽어들이려면 데이터 파일로부터 해당 키를 갖는 컬럼을 찾을 필요가 있다.
  * 이를 위해 MyISAM 엔진의 경우 **리프 노드는 데이터 파일에 저장된 레코드의 실제 주소를 갖는다**.
* **InnoDB의 경우, B-Tree 인덱스와 동일한 구조로 프라이머리 키 인덱스를 갖지만 리프 노드에 실제 레코드가 저장된다는 점에서 차이**가 있다.
  * 이 때, **B-Tree 인덱스의 리프 노드는 프라이머리 키 인덱스의 루트 노드를 가리키는 프라이머리 키를 값으로 저장**한다. 
  * 즉, **MyISAM 엔진의 경우와 달리 InnoDB 엔진은 레코드 주소를 갖지 않는 대신 프라이머리 키 인덱스를 한 번 더 거치게 된다**.

### MyISAM과 InnoDB 인덱스의 차이
* **두 엔진의 인덱스에서 가장 큰 차이는 세컨더리 인덱스를 통해 데이터 파일에 저장된 레코드를 찾아가는 방식**에 있다.
  1. MyISAM: **세컨더리 인덱스의 리프 노드가 물리적인 레코드의 주소를 갖게 되므로, 데이터 파일은 마치 힙 메모리처럼 사용**된다.
  2. InnoDB: **세컨더리 인덱스의 리프 노드는 프라이머리 키를 마치 레코드의 주소처럼 사용하므로, 논리적인 주소**를 갖는다.
* 상술한 이유에서 InnoDB 테이블에서는 인덱스를 통해 레코드를 읽어들일 때 데이터 파일을 바로 찾아갈 수 없다.
  * **대신 B-Tree 인덱스의 리프 노드에 저장된 프라이머리 키로부터 테이블 데이터 레코드의 프라이머리 키 인덱스를 한 번 더 검색**해야 한다.
  * 이후 프라이머리 키 인덱스의 리프 노드에 저장된 레코드를 읽어들이게 된다.
* 이렇듯 **InnoDB 엔진에서는 반드시 세컨더리 인덱스 검색 후 실제 데이터 레코드에 접근하기 위한 프라이머리 키용 B-Tree 인덱스를 한 번 더 검색**한다.
  * 이로 인해 MyISAM보다 성능이 떨어질 것으로 보이지만, 각각의 구조는 서로 다른 장단점을 갖는다.
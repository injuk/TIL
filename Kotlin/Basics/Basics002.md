# Kotlin
## 2022-02-05 Sat

### Hello world
* Kotlin Hello world는 다음과 같이 작성한다. 
  1. 함수 키워드는 fun이다.
  2. class 없이 함수를 최상위 위치에 작성할 수 있다.
  3. 파라미터 이름 뒤에 파라미터의 타입을 작성한다.
  4. 배열도 일반적인 클래스처럼 처리하며, Java와 달리 Kotlin에는 배열 처리를 위한 문법이 없다.
  5. System.out.println를 println과 같이 작성한다.
     * Kotlin에는 표준 Java 라이브러리를 이토록 쉽게 사용할 수 있도록 래퍼가 제공된다.
```
package kotlinStudy

fun main(args:Array<String>) {
    println("Hello world")
}
```

### Kotlin의 함수
* Kotlin의 함수 선언 형태는 다음과 같다.
```
fun [함수이름]([매개 변수 목록]): [반환형] {
  [함수 본문]
}
```
* 함수의 **반환형이 void인 경우 반환형을 생략**하며, void가 아닌 경우 매개 변수 목록 뒤에 작성한다.
```
fun main(args:Array<String>) {
    printStr(max(3, 4).toString())
}
// 반환형이 Int인 함수
fun max(a: Int, b: Int): Int {
    return if(a>b) a else b // Kotlin에서 if는 값을 만드는 '식'이다. 
}
// 반환형이 void인 함수
fun printStr(str: String) {
    println(str)
}
```
* Kotlin의 함수는 다시 다음의 두 가지로 나뉠 수 있다.
  1. 블록이 본문인 함수
     * 상술한 함수와 같이 중괄호로 둘러 쌓인 함수이다.
     * void형이 아닌 경우, 반드시 반환 타입과 return 문이 사용되어야 한다.
  2. 식이 본문인 함수
     * 상술한 함수는 다음과 같이 간략히 작성할 수 있다.
```
// 반환형과 return문, 함수를 둘러싼 중괄호가 제거된다.
fun max(a: Int, b: Int) = if(a > b) a else b
// void형 함수도 가능하다.
fun printStr(str: String) = println(str);
```
* **식이 본문인 함수를 작성할 수 있는 이유는 Kotlin 컴파일러가 타입 추론을 지원하기 때문**이다.
  * 즉, 컴파일러가 함수 본문 식을 분석하여 함수 반환 타입을 정해주기 때문이다.
  * **타입 추론이란, 컴파일러가 타입을 분석하여 개발자 대신 프로그램 구성 요소의 타입을 지정하는 기능*이다.
* 블록이 본문인 함수는 왜 반환 정보를 강제할까?
  * 함수가 길어지는 경우 return 문은 여럿이 존재할 수 있다.
  * 이 경우, 반환 타입과 return 문을 강제함으로써 **함수가 어느 시점에 무엇을 반환하는지 쉽게 알 수 있어야 하기 때문**이다.

### Kotlin의 변수
* 변수 앞에 타입을 선언하는 Java와 달리, **Kotlin에서는 타입 지정을 생략할 수 있다**.
  * 타입으로 변수 선언을 시작하는 경우, 식과 변수의 선언을 구분할 수 없었기 때문이다.
  * 식이 본문인 함수와 마찬가지로, 타입 지정이 누락된 경우 Kotlin 컴파일러가 타입 추론을 통해 변수의 타입을 지정한다.
* 변수 선언시 다음과 같이 val [변수명]: [변수형] = [값]로 선언한다.
  * 변수 선언 후 **초기화를 생략한 경우, 타입 추론이 불가하므로 반드시 변수형을 명시**한다.
```
// 타입은 생략할 수 있다.
val maybeIAmString = "Hello world!"
val maybeIAmInteger = 3
// 타입을 생략하지 않는 경우, : 타입 형태로 작성한다.
val iAmDefinitelyInteger: Int = 15
// 변수의 선언과 초기화를 함께하지 않는 경우에는 반드시 타입을 지정한다. 
val whoAmI: Boolean
whoAmI = false
```
* 변수 선언시 사용 가능한 키워드는 다음과 같다.
  1. val: 변경 불가능한 참조를 저장한다.
     * 초기화 한 후에는 값을 변경할 수 없다.
     * Java의 final 변수에 해당한다.
     * final 변수와 달리, **초기화와 대입을 반드시 함께할 필요는 없다**.
  2. var: 변경 가능한 참조를 저장한다.
     * Java의 일반 변수에 해당한다.
```
// val로 선언된 변수는 참조를 변경할 수 없다.
val final = 10
// final = 20

// var로 선언된 변수는 참조의 변경이 가능하다.
var notFinal = 10
notFinal = 20
```
* **val로 선언된 변수는 블록을 실행할 때 정확히 한 번만 초기화되어야 한다**.
  * 반면 if 문과 같이 **오직 하나의 초기화 문장만 실행될 수 있는 경우, 조건에 따라 여러 값으로 초기화시킬 수 있다**.
```
val pleaseInitMe: String
// 선언과 초기화가 다른 문장에서 동작할 수 있다.
if(true)
    pleaseInitMe = "I am true!"
else
    pleaseInitMe = "I am false!"
```
* **val로 선언된 변수의 참조는 불변하지만, 참조된 객체의 내부는 변경될 수 있다**.
* **var로 선언된 변수의 값은 변경될 수 있지만, 타입은 고정되어 변경되지 않는다**.
  * **변수의 타입은 선언 시점의 초기화 식으로부터 컴파일러에 의해 추론**된다.
  * 이후 **변수에 다른 값을 대입할 경우, 컴파일러는 추론한 값을 기준으로 대입문의 타입을 검사**한다.
```
var iAmInteger = 10
iAmInteger = 20
// type mismatch!
// iAmInteger = "30"
```
* **기본적으로 모든 변수를 val로 선언하여 불변 변수로 선언하고, 꼭 필요할 때에만 var로 선언**한다.
  * **변경 불가능한 참조와 변경 불가능한 객체를 순수 함수와 함께 사용하여 함수형 코드에 가까워질 수 있기 때문**이다.

### 문자열 템플릿
* 여러 스크립트 언어의 기능과 유사하게, Kotlin에서도 문자열 내부에서 변수를 사용할 수 있다.
* 이러한 문자열 템플릿 기능은 문자열 내부에서 $변수 형식으로 사용한다.
  * 만약 진짜 $기호를 활용하고 싶은 경우라면 \ 기호를 통해 이스케이프 시킨다.
* **컴파일러는 모든 식을 정적으로 컴파일러 시점에 검사**하므로, 존재하지 않는 변수를 문자열 템플릿으로 사용할 수는 없다.
```
val name = "ingnoh"
print("$name has 1\$")
// 컴파일 오류: 선언되지 않은 변수는 사용할 수 없다.
// print("$name2 has 1\$")
```
* 복잡한 식을 문자열 템플릿도 사용하려는 경우, ${} 내부에 작성한다.
```
val one = 1
val two = 2
val three = 3

println("${one + two * three}") // 7
println("\${one + two * three}") // ${one + two * three}
```
* ${}로 표현된 문자열 템플릿 내부에서는 String 리터럴인 쌍따옴표를 사용할 수 있다.
```
println("${if(one > 0) one + two * three else "one is zero!"}")
```
* 기본적으로 가독성 측면에서 $만 사용하는 것보다 ${}로 작성하는 습관을 들이는 것이 바람직하다.
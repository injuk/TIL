# Kotlin
## 2022-02-11 Fri

## 람다식
* 람다식, 람다는 다른 함수에 넘길 수 있는 작은 코드 조각을 뜻한다.
* 람다를 적절히 사용하면 공통 코드 구조를 쉽게 라이브러리 함수로 빼낼 수 있으며, Kotlin 역시 표준 라이브러리에서 람다식을 많이 사용한다.
* 데이터 구조의 모든 원소에 대해 임의의 연산을 적용할 수 있도록, 일련의 동작을 변수에 저장하거나 다른 메소드에 넘겨야하는 경우가 있다.
  * 예전의 Java에서는 이를 무명 내부 클래스로 구현하였으나, 이는 번거로운 방식이다.
* 함수형 프로그래밍에서는 함수를 값처럼 다루는 접근 방법을 택함으로써 이를 구현한다.
  * 클래스를 선언하고 인스턴스를 메소드에 넘기는 방식보다 람다식을 활용하는 것이 코드가 더 간결해진다.
  * **람다 식을 활용하면 메소드를 별도로 선언할 필요도 없으며, 코드 블록을 직접 함수의 인자로 전달**할 수 있다.

### 람다와 컬렉션
* 코드에서 중복을 제거하는 것은 좋은 코드를 위한 중요한 방법이다.
* 이러한 전제와 더불어, **컬렉션에 수행하는 대부분의 작업은 몇 가지의 패턴으로 나눌 수 있다**.
  * 따라서, 이러한 패턴은 라이브러리화해야 한다.
* 람다식이 없다면 이렇듯 컬렉션을 편리하게 처리할 수 있을만한 좋은 라이브러리를 제공하기가 어렵다.
  * 실제로 Java 8 이전에는 편한 컬렉션 라이브러리가 적었고, 개발자들은 필요한 기능을 직접 구현해야 했다.
  * Kotlin에서는 이러지 말아야 한다!
* 예를 들어, 나이를 프로퍼티로 갖는 동물 목록에서 가장 나이가 많은 동물을 찾는 코드를 직접 구현하면 다음과 같다.
```
fun main(args: Array<String>) {
     val oldest = getOldest(listOf(
          Animal("Animal", 5),
          Animal("Bnimal", 15),
          Animal("Cnimal", 3),
          Animal("Dnimal", 20),
          Animal("Enimal", 12),
          Animal("Fnimal", 7),
          Animal("Gnimal", 9),
     ))
     println(oldest)
}
data class Animal(val name: String, val age: Int)
fun getOldest(animals: List<Animal>): Animal? {
     var age: Int = 0
     var oldest: Animal? = null
     for(animal in animals) {
          if(animal.age > age) {
               oldest = animal
               age = animal.age
          }
     }
     return oldest
}
```
* 간단한 로직을 구현하면서도 코드가 길어지므로, 휴먼 에러가 발생할 가능성이 높다.
* Kotlin에서는 람다식을 활용하여 다음과 같이 수정할 수 있다.
  * **메소드 정의조차 필요 없어지며, 코드 길이의 대부분은 목록화에 사용된다**.
```
fun main(args: Array<String>) {
     val animals = listOf(
          Animal("Animal", 5),
          Animal("Bnimal", 15),
          Animal("Cnimal", 3),
          Animal("Dnimal", 20),
          Animal("Enimal", 12),
          Animal("Fnimal", 7),
          Animal("Gnimal", 9),
     )
     // 메소드 정의도 필요 없다!
     println(animals.maxByOrNull { it.age })
}
data class Animal(val name: String, val age: Int)
```
* 상술한 예시의 maxBy 함수는 모든 컬렉션에 대해 호출할 수 있다.
* maxBy는 가장 큰 원소를 찾기 위해 **비교에 사용할 값을 돌려주는 함수를 인자로** 받는다.
  * 이 때, **중괄호로 둘러쌓인 { it.age }가 비교에 사용할 값을 돌려주는 함수 조각**이다.
  * **해당 코드는 컬렉션의 원소를 it이라는 인자로 받아, 비교에 사용할 값을 반환**한다.
* 상술한 예시와 같이 함수나 프로퍼티를 반환하는 역할만을 수행하는 람다는 멤버 참조로 대체할 수 있다.
```
// 멤버 참조를 활용한 예시이다.
println(animals.maxByOrNull(Animal::age))
```
* **컬렉션에 대해 수행하던 대부분의 작업은 람다 또는 멤버 참조를 인자로 취하는 라이브러리 함수로 개선할 수 있다**.

### 람다식 문법
* 상술했듯, **람다는 마치 하나의 값처럼 여기저기에 전달할 수 있는 일련의 동작**이다.
  * 때문에 람다는 별도로 선언하여 변수로 관리할 수도 있다.
  * 하지만 **대부분의 경우 함수에 인자로 넘기는 시점에 람다를 정의**한다.
* 람다식 선언의 일반적인 문법은 다음과 같다.
  * Kotlin 람다식은 중괄호로 감싼다.
  * **Kotlin 람다식은 파라미터 목록 주변에 괄호를 작성하지 않는다**.
  * -> 기호는 파라미터 목록과 람다식 본문을 구분한다.
```
fun main(args: Array<String>) {
     // { 파라미터 목록 -> 람다식 본문 }
     val lambda = { num1: Int, num2: Int -> num1 + num2 }
     // 변수에 저장한 람다식을 메소드처럼 바로 호출할 수 있다.
     println(lambda(32, 1))
}
```
* 람다식은 즉시 실행 함수 표현식을 지원한다.
  * 형태는 람다식에 뒤이어 괄호를 통해 파라미터 목록을 전달한다.
  * { 파라미터 목록 -> 람다식 본문 }(전달 파라미터 목록)
```
fun main(args: Array<String>) {
     println(
          { num1: Int, num2: Int -> num1 * num2}(3, 4)
     )
}
```
* 그러나 **이러한 방식은 가독성이 떨어지고, 쓸모도 없다**.
  * 복잡하게 람다를 호출하느니, 람다식 본문을 바로 사용하는 것이 낫다.
  * 실제로 IDE 자체가 이렇듯 불필요한 람다식의 사용을 바로잡아주려고 한다.
* 부득이하게 코드 블록을 람다식으로 호출할 필요가 있다면, 인자로 받은 람다식을 실행해주는 run 메소드를 사용한다.
```
fun main(args: Array<String>) {
     run { println("lambda!") }
}
```
* **런타임에서 Kotlin의 람다 호출은 아무런 부가 비용이 들지 않고, 프로그램의 기본 구성 요소와 비슷한 성능을 갖는다**.

### 람다식 문법 II - maxByOrNull 예제
* 앞선 maxBy 예제에서, maxByOrNull { it.age }는 실제로는 다음과 같이 작성해야 한다.
```
animals.maxByOrNull({ animal: Animal -> animal.age })
```
* 위의 식은 다음과 같은 원칙에 의해 가독성을 향상시킨다.
1. Kotlin 컴파일러가 문맥으로부터 인자의 타입을 유추할 수 있다면, 인자 타입을 생략할 수 있다.
   * **로컬 변수가 그랬듯, Kotlin 컴파일러는 람다식의 인자 타입도 추론할 수 있다**.
     * 예를 들어, maxByOrNull의 경우 인자 타입은 항상 컬렉션의 원소 타입과 같다.
   * Kotlin 컴파일러는 Animal 객체에 대해 maxByOrNull을 호출하므로, 인자 타입 역시 Animal일 것이라고 추론할 수 있다.
   * 일단 인자 타입을 생략해보고, 컴파일러가 추론하지 못하는 경우에 인자 타입을 붙이는 식으로 개발하도록 한다.
   * **람다식의 인자가 여럿인 경우, 인자 타입의 일부만 명시하고 추론 가능한 인자 타입은 생략해도 좋다**.
     * 언제나 가독성이 좋은 방향을 따르도록 한다.
```
animals.maxByOrNull({ animal -> animal.age })
```
2. **Kotlin에서는 메소드 호출 시 맨 마지막 인자가 람다식이라면, 람다식을 괄호 밖으로 뺄 수 있다는 문법**이 있다.
   * 람다를 괄호 밖으로 빼내어 람다식임을 명시할 수도 있고, 괄호 안에 두어 메소드의 인자임을 명시해도 좋다.
   * 그러나 인자가 여럿인 경우 람다식만 밖으로 빼내면 람다식의 존재 의의를 바로 알아보기 어렵다.
   * 때문에 일반적인 경우, 괄호 내부에 람다를 두어 사용하는 일반적인 호출 구문이 바람직하다.
```
animals.maxByOrNull(){ animal -> animal.age }
```
3. 람다가 어떤 함수의 유일한 인자이고, 괄호 뒤에 람다를 빼낸 경우에는 괄호가 비어 있게 되므로 이를 생략할 수 있다.
```
animals.maxByOrNull { animal -> animal.age }
```
4. **람다의 인자 명칭의 디폴트 값은 it이며, 람다의 인자 갯수가 하나이면서 컴파일러에 의해 추론될 수 있다면 it을 바로 사용할 수 있다**.
   * 람다식의 인자명을 따로 지정하지 않은 경우에만 it 이라는 이름이 자동으로 생성된다.
   * **it을 사용하는 관습은 코드를 간결하게 만들어주지만, 남용하지 않아야 한다**.
     * 예를 들어 람다식이 중첩되는 경우, 모두 it을 사용하면 각각의 it이 가리키는 대상을 유추하기 어려워진다.
     * **가독성 측면에서 도움이 되는 경우, 인자 타입 또는 인자명을 명시하도록 한다**.
```
animals.maxByOrNull { it.age }
```
* **람다식을 변수에 저장하는 경우, 인자 타입을 추론할만한 문맥이 존재하지 않으므로 인자 타입을 생략할 수 없다**.
* 람다식은 반드시 한 줄로 작성되리라는 법은 없으며, 여러 줄일 수 있다.
  * 이 때, 람다식의 결과는 다른 블록 식과 마찬가지로 마지막 식이 된다.
```
fun main(args: Array<String>) {
     val lambda = { num1: Int, num2: Int ->
          println("num1: $num1")
          println("num2: $num2")
          num1 + num2
     }
     println(lambda(4, 3))
}
```
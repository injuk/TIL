# Kotlin
## 2022-02-13 Sun

## lazy 컬렉션 연산 (지연 계산)
* map, filter와 같은 컬렉션 함수는 결과 컬렉션을 즉시 생성한다.
* **따라서 컬렉션 함수를 여럿 연쇄하면 매 단계마다 계산의 중간 결과를 새로운 컬렉션에 중간 저장하게 된다**.
* 이러한 중간 저장은 리스트의 요소가 적은 경우 큰 문제가 되지 않지만, **요소의 개수가 많아질수록 성능에 영향을 준다**.
```
fun main(args: Array<String>) {
     val upperCaseNames = animals
          .filter { it.age < 10 } // 새로운 중간 컬렉션이 생성된다.
          .map { it.name.uppercase() } // 새로운 중간 컬렉션이 생성된다.
     println(upperCaseNames)
}
```
* 컬렉션 연산을 여럿 사용해야 하는 경우, 시퀀스를 사용할 수 있다.
  * **상술한 연산이 컬렉션을 직접 사용하는 대신 시퀀스를 사용하면 더 효율적인 구현이 가능**하다.
  * **리스트를 시퀀스로 변경하고, 결과를 다시 리스트화하기 위해 asSequence()와 toList()를 활용**한다.
  * 시퀀스 역시 리스트와 같이 filter, map 함수를 사용할 수 있다.
```
fun main(args: Array<String>) {
     val upperCaseNames = animals
          .asSequence() // 리스트를 시퀀스로 변경한다.
          .filter { it.age < 10 } // 새로운 중간 컬렉션이 생성되지 않는다.
          .map { it.name.uppercase() } // 새로운 중간 컬렉션이 생성되지 않는다.
          .toList() // 시퀀스를 다시 리스트로 변경한다.
     println(upperCaseNames)
}
```
* 시퀀스를 활용하는 경우, 중간 결과를 저장하는 컬렉션이 새로 생성되지 않으므로 요소가 많을수록 성능이 좋아진다.

### Sequence 인터페이스
* Kotlin의 지연 계산 시퀀스를 아래와 같은 Sequence 인터페이스를 활용한다.
  * 해당 인터페이스는 한 번에 하나씩 열거될 수 있는 원소의 시퀀스를 표현하며, 원소 순회를 위한 메소드 하나만을 포함한다.
  * 해당 메소드인 iterator를 통해 시퀀스로부터 원소의 값을 얻어올 수 있다.
```
public interface Sequence<out T> {
    public operator fun iterator(): Iterator<T>
}
```
* Sequence 인터페이스의 강점은 인터페이스에서 구현된 연산이 계산을 수행하는 방법 때문이다.
  * **시퀀스의 원소는 필요한 시점에 계산되므로 중간 처리 결과를 저장하지 않고 효율적인 계산이 가능**하다.
* **원소를 순서대로 순회해야 하는 경우 시퀀스가 적절하지만, 인덱스를 활용한 접근 등의 경우 컬렉션을 그대로 사용하는 것이 바람직**하다.
* **커다란 컬렉션에 대한 연쇄적인 연산이 필요한 경우, 반드시 시퀀스를 활용**해야 한다.
  * **컬렉션이 일반적인 크기인 경우, 중간 컬렉션을 생성하더라도 즉시 계산을 적용하는 컬렉션의 연산이 더 효율적**이다.
* 시퀀스에 대한 연산은 지연되므로, 실제로 연산을 적용하고 싶다면 다음과 같은 마무리가 필요하다.
  1. 원소를 하나씩 순회한다.
  2. 최종 결과를 리스트로 변환한다.

### 시퀀스의 연산
* 시퀀스의 연산은 중간 연산과 최종 연산으로 나뉜다.
  1. 중간 연산: 다른 시퀀스를 반환하며, 각 시퀀스는 최초 시퀀스의 변환 방법을 알고 있다.
  2. 최종 연산: 최초 컬렉션에 대해 변환을 적용한 시퀀스로부터 일련의 연산을 통해 얻을 수 있는 컬렉션이나 원소, 숫자, 객체 등의 결과를 반환한다.
* 중간 연산은 항상 지연 계산되며, 최종 연산이 없으면 연산이 적용되지 않는다.
  * 아래와 같이 최종 연산을 주석 처리한 경우, kotlin.sequences.TransformingSequence@38af3868와 같은 의미 없는 값이 출력된다.
  * **주석을 다시 해제하면 원하는 결과가 출력되며, 이는 최종 연산을 호출해야 지연된 계산이 모두 적용됨을 의미**한다.
```
fun main(args: Array<String>) {
     val upperCaseNames = animals
          .asSequence()
          .filter { it.age < 10 } // 새로운 중간 컬렉션이 생성된다.
          .map { it.name.uppercase() } // 새로운 중간 컬렉션이 생성된다.
//          .toList()
     println(upperCaseNames)
}
```

### 컬렉션과 시퀀스 연산의 차이
* map, filter 연산을 컬렉션과 시퀀스 각각에 대해 연쇄적으로 적용하는 경우,
  1. 컬렉션은 map을 적용한 결과 컬렉션을 생성하고, 새로운 컬렉션에 대해 filter를 적용한다.
  2. **시퀀스는 모든 원소를 순차적으로 순회하며, 원소마다 map > filter를 적용**한다.
* 때문에 **시퀀스에 대한 지연 계산은 원소마다 연산을 적용하다 결과가 얻어진 시점에서 그 이후의 연산을 수행하지 않을 수도 있다**.
  * 아래의 예시에서, .asSequence()를 주석 처리하는 경우 map 연산에 의해 animals 의 모든 요소가 출력된다.
  * 주석 해제하는 경우, **find 호출에 의해 시퀀스의 모든 원소에 map > find를 각각 적용**하며 결과가 반환되는 시점 이후의 요소는 출력되지 않는다.
```
fun main(args: Array<String>) {
     val result = animals
          // .asSequence()
          .map { animal: Animal ->
               println(animal)
               animal
          }
          .find { it.age == 20 }

     println("result: $result")
}
```
* **컬렉션에 대한 중간 연산의 순서는 성능에 영향을 미친다**.
  * 예를 들어, 일반적으로 map > filter보다 filter > map이 더 적은 요소를 검사하도록 하므로 성능이 좋다.
  * 이는 filter 연산에 의해 불필요한 원소가 연산에서 제외되기 때문이다.

### 시퀀스의 생성
* 상술한 예시에서는 컬렉션에 대해 asSequence()를 호출하여 시퀀스를 생성한다.
* generateSequence() 함수를 사용하면 이전의 원소를 인자로 받아 다음 원소를 계산하는 시퀀스를 생성할 수 있다.
  * 즉, generateSequence()의 인자로 첫 번째 원소를 지정하고,
  * 시퀀스의 앞 원소로부터 다음 원소를 계산하는 방법을 제공함으로써 시퀀스를 생성한다.
* 아래의 예시는 0부터 99까지 포함된 리스트를 생성한다.
  * generateSequence(0)은 최초 원소인 0 부터 시작해서 다음 원소를 계산하기 위한 조건인 + 1을
  * takeWhile 에서 99까지 계산한다.
    * 이 시점에서, 최종 연산이 수행되지 않았으므로 각 연산은 지연된 상태이다.
  * toList()라는 최종 연산에 의해 sequence가 계산된다.
```
fun main(args: Array<String>) {
     // 최초 원소와 다음 원소를 계산하는 방법을 정의한다.
     val sequence = generateSequence(0) { it + 1 }
          // 시퀀스를 적용할 범위를 정의한다.
          .takeWhile { it < 100 }
     // 최종 연산인 toList()를 호출하여 시퀀스의 각 원소에 계산을 적용한다.
     println(sequence.toList())
}
```

### Stream vs Sequence
* Java 8에 도입된 Stream API와 Kotlin의 Sequence API는 유사하다.
  * 개념적으로는 같다!
* **Kotlin은 단순히 Stream API가 없는 Java 8 이전의 버전을 사용하는 환경을 위해 Sequence API를 제공**한다.
* Java 8 이후의 버전을 사용하고 있다면, 아직 Sequence가 제공하지 못하는 기능을 Stream API에서 누릴 수 있다.
* 즉, 개발자의 필요와 Java 버전에 따라 Sequence와 Stream 중 적절한 API를 선택하여 개발한다.

### Java 함수형 인터페이스 활용
* 개발에 사용하는 API의 상당 수는 Kotlin이 아닌 Java API이며, Kotlin 람다는 Java API에도 적용할 수 있다.
* **함수형 인터페이스를 사용하는 Java API에는 무명 클래스를 사용하던 기존 방식 대신 Kotlin 람다를 넘길 수 있다**.
  * 함수형 인터페이스: 추상 메소드가 단 하나 뿐인 인터페이스
  * SAM: Single Abstract Method, 단일 추상 메소드
* 예를 들어, Runnable, Callable, OnClickListener 등의 인터페이스처럼 하나의 메소드를 갖는 인터페이스를 가리킨다.
  * Java API에는 이러한 함수형 인터페이스를 활용하는 메소드가 많다.
* **Kotlin은 함수형 인터페이스를 인자로 취하는 Java 메소드를 호출할 때 람다를 넘길 수 있도록 한다**.
  * 때문에 Kotlin 코드는 무명 클래스의 인스턴스를 활용하지 않으므로 깔끔하고 Kotlin스러울 수 있다.
* **함수형 인터페이스를 인자로 사용하는 Java 메소드에 람다를 넘기는 경우, Kotlin 컴파일러는 람다를 적절한 인터페이스를 구현하는 인스턴스로 변환**한다.
  * Runnable을 인자로 받는 경우, Kotlin 컴파일러는 람다식 본문을 기반으로 Runnable을 구현하는 무명 클래스의 인스턴스를 생성한다.

### 함수형 인터페이스에 람다와 무몀 객체 사용
* 함수형 인터페이스에 람다식을 넘기는 대신 무명 객체를 넘길 수 있다.
* 이 때, 각 방식은 다음과 같은 차이가 있다.
  1. 무명 객체의 경우, 매 호출마다 새로운 인스턴스가 생성된다.
  2. 람다식의 경우, 주변 변수에 접근하지 않는 람다라면 한 번 생성된 무명 객체를 반복 사용한다.
  3. 람다식이 주변 변수를 포획하여 사용하는 경우, 매 호출마다 새로운 인스턴스를 생성하여 사용한다.
     * 람다식이 변수에 매 번 다른 값을 포획할 수 있기 때문이다.
* 반면 컬렉션을 확장한 함수에 람다를 넘기는 경우, 무명 클래스를 만드는 방식을 사용하지 않는다.
  * Kotlin inline 함수는 무명 클래스를 생성하지 않으며, 대부분의 Kotlin 확장 함수는 inline 함수이다.

### SAM 생성자
* 대부분의 경우 람다와 Java 함수형 인터페이스 사이의 변환은 컴파일러에 의해 자동으로 이루어진다.
  * 그러나 이를 자동으로 변환할 수 없다면, 개발자는 다음과 같이 수동으로 변환 처리를 구현해야 한다.
* **SAM 생성자는 람다를 함수형 인터페이스의 인스턴스로 변환할 수 있도록 컴파일러가 자동으로 생성하는 함수**이다.
* SAM 생성자는 컴파일러가 자동으로 람다를 함수형 인터페이스의 무명 객체로 변환하지 못하는 경우에 사용할 수 있다.
  * 예를 들어, 함수형 인터페이스의 인스턴스를 반환하는 메소드는 람다를 직접 반환할 수 없고, 이를 SAM 생성자로 감싸야 한다.
  * 또는 함수형 인터페이스를 구현하는 과정에서 오버로드한 메소드 중 넘겨줄 메소드가 모호한 경우에도 SAM 생성자 방식을 활용하여 컴파일 오류를 피할 수 있다.
* **SAM 생성자는 사용하려는 함수형 인터페이스와 같은 이름을 사용하고, 인자도 추상 메소드의 본문에 사용할 람다를 받는다**.
* SAM 생성자는 이를 활용하여 함수형 인터페이스를 구현하는 클래스의 인스턴스를 반환할 수 있다.
  * 이를 활용하여 onClickListener에 적용할 리스너를 변수에 저장하고, 많은 버튼에 같은 동작을 적용하기 위해 사용할 수 있다.
```
fun main(args: Array<String>) {
     val runnable = getRunnable("ingnoh")
     runnable.run()
}

fun getRunnable(name: String): Runnable {
     // SAM 생성자의 이름은 사용하려는 함수형 인터페이스의 이름과 같으므로, 이 경우에는 Runnable이 된다.
     return Runnable { println("name: $name") }
}
```

### 람다와 this
* 람다에는 무명 객체의 인스턴스와 달리 인스턴스 자신을 가리키는 this 키워드가 없다.
  * 즉, 람다를 변환한 무명 클래스의 인스턴스 자신을 참조할 방법이 없다.
  * 오히려 람다 안에서 this는 그 람다를 둘러싼 클래스의 인스턴스를 가리킨다.
* 컴파일러 입장에서 람다는 코드 블록일 뿐이며, 인스턴스가 아니므로 인스턴스처럼 람다를 참조할 수 없다.
  * 때문에 클릭 리스너 등에서 이벤트 리스너를 해제할 필요가 있는 경우, 람다 대신 무명 객체를 사용해야 한다.
```
fun main(args: Array<String>) {
     val runner = Runner()
     runner.run() // "This is Runner instance!"
}

class Runner {
     // 람다식 내부에서 호출한 this는 인스턴스 자신을 가리킨다.
     fun run() = Runnable { println(this) }.run()

     override fun toString() = "This is Runner instance!"
}
```

## 수신 객체 지정 람다
* Java의 람다에는 없는 Kotlin 람다만의 기능이다.
* 수신 객체 지정 람다는 수신 객체를 명시하지 않고 람다의 본문 내부에서 다른 인스턴스의 메소드를 호출할 수 있도록 한다.

### with
* 코드에서 어떤 객체의 이름이 반복되어 사용되는 경우, 이러한 이름을 생략하면 가독성이 더 높아질 수 있다.
* with 함수가 이러한 역할을 수행하며, 다음과 같은 파라미터를 두 개 받아 실행된다.
  1. 첫번째 파라미터: 람다식의 수신 객체를 지정한다.
  2. 두번째 파라미터: 람다식 자체를 지정하되, 마지막 파라미터가 람다인 경우 이를 밖으로 빼낼 수 있는 관례를 적용하여 마치 문법처럼 보이게 한다.
* with 함수는 첫 파라미터로 전달된 객체를 두번째 파라미터로 전달받은 람다의 수신 객체로 지정한다.
  * 이후 전달받은 람다 본문에서는 this 키워드를 사용하거나, this를 생략하여 해당 객체에 접근할 수 있다.
  * 만약 수신 객체외 외부 클래스가 동명의 메소드를 정의한다면, this 키워드를 활용하여 호출할 메소드를 정확히 명시할수 있다. 
* with 함수는 값을 반환할 수 있으며, 반환 값은 람다 본문의 마지막 식의 결과이다.
```
fun main(args: Array<String>) {
     // with의 첫 파라미터로 수신 객체를 지정한다.
     // 두번째 파라미터로는 람다식을 지정한다.
     val result = with(Bird("bird", 1)) {
          // 내부에서는 this 키워드 없이 수신 객체로 전달된 Bird의 메소드를 사용할 수 있다.
          sayHello()
          // this 키워드를 사용하여 수신 객체에 접근할 수도 있다.
          this.howOld()
          // 람다 본문의 마지막 결과는 with 함수의 반환 값이 된다.
          this
     }
     // with에 의해 반환된 Bird 인스턴스의 toString을 호출한다.
     println(result)
}

class Bird(val name: String, val age: Int) {
     fun sayHello() = println("Hello! I am $name")
     fun howOld() = println("$age years old")
     override fun toString() = "Bird: name($name) age($age)"
}
```
* 람다는 일반 함수와 유사하며, 동작을 정의하는 방법이다.
  * 수신 객체 지정 람다는 확장 함수와 유사하며, 동작을 임의의 객체에 정의하는 방법이다.

### apply
* **apply 함수는 with 함수와 같으며, 자신에게 전달된 수신 객체를 반환한다는 것이 유일한 차이**이다.
* apply 함수는 수신 객체.apply(람다식)의 형태로 호출한다.
  * 형태에서 알 수 있듯, apply는 확장 함수이다.
  * apply 함수의 수신 객체는 apply가 인자로 전달 받은 람다식의 수신 객체와 같다.
  * apply 함수의 반환 값은 수신 객체이다.
* 상술한 예시를 apply를 사용하도록 수정하면 다음과 같다.
```
fun main(args: Array<String>) {
     // with(Bird("bird", 1)) { /* 람다식 */ }의 형태를 다음과 같이 수정한다.
     // 반환되는 결과는 수신 객체로 지정된 Bird("bird", 1)이므로, 마지막 줄에서 this를 명시할 필요가 없다.
     val result = Bird("bird", 1).apply {
          sayHello()
          this.howOld()
          // this
     }
     println(result)
}
```
* apply 함수는 객체의 인스턴스를 생성하는 동시에 프로퍼티의 일부를 초기화해야하는 경우에 사용을 고려할 수 있다.
  * Java의 경우, 별도의 Builder 인스턴스가 이러한 역할을 수행한다.
  * apply에 전달된 람다를 실행한 후, apply는 람다에 의해 초기화가 완료된 인스턴스를 반환한다.

### 더 구체적인 라이브러리
* with와 apply는 수신 객체 지정 람다를 활용하는 일반적인 용례를 갖는다.
* **buildString과 같은 더 구체적인 함수를 활용하는 경우, 특정한 패턴에 유용하게 사용할 수 있다**.
  * 표준 라이브러리의 buildString은 StringBuilder를 생성하고, 결과로 toString을 호출한다.
  * 이 경우, 전달 받은 람다는 수신 객체 지정 람다이며, 수신 객체는 StringBuilder이다.
  * buildString 함수는 StringBuilder를 활용하여 String을 만드는 경우에 고려할 수 있는 Kotlin스러운 방식이다. 

### 결론
* 람다를 사용하면 코드 조각을 다른 함수의 파라미터로 넘길 수 있다.
* Kotlin에서, 람다의 인자가 단 하나인 경우에는 인자의 이름을 지정하지 않고도 it 이라는 디폴트 키워드로 참조할 수 있다.
* Kotlin에서, 메소드나 생성자, 프로퍼티의 이름 앞에 ::을 붙이는 것으로 각각에 대한 참조를 만들 수 있다.
  * **이렇게 생성된 참조를 람다 대신 다른 함수에 넘길 수 있다**.
* Kotlin에서, 함수형 인터페이스를 인자로 받는 Java 메소드를 호출할 때 함수형 인터페이스를 구현하지 않고로 람다를 인자로 넘길 수 있다.
* 수신 객체 지정 람다를 통해 람다식 본문에서 미리 정해둔 수신 객체의 메소드를 호출할 수 있다.
  * with 함수: 람다식 내부에서 임의의 객체의 참조를 반복해서 언급하지 않고도 객체의 메소드를 활용할 수 있다.
  * apply 함수: 임의의 **객체를 빌더 스타일의 API로 생성하고 초기화할 수 있도록 한다**.
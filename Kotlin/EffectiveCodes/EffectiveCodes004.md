# EffectiveCodes
## 2023-04-17 Mon
### 추상화의 중요성 
```
> 컴퓨터 과학에서 추상화란 복잡한 모듈이나 시스템 등으로부터 핵심적인 개념 또는 기능만을 추려내는 것을 의미한다.
> 극단적으로, 프로그래밍에서 하는 모든 일은 추상화가 될 수 있다.
```
* 추상화는 복잡성을 숨기기 위해 사용되는 단순한 형식을 의미하며, 인터페이스는 추상화를 위해 사용되는 대표적인 도구이다.
  * 이 때, 인터페이스는 복잡한 클래스를 메소드와 프로퍼티만을 추출하여 간단하게 추상화한다.
  * **어떤 객체에 대한 추상화는 여러 가지로 표현될 수 있으며, 결국 추상화를 위해서는 객체에서 무엇을 감추고 노출할지 결정**해야 한다.
* **추상화를 설계하는 것은 단순하게 모듈이나 라이브러리를 분리하는 것이 아니며, 함수를 예로 들어 구현을 시그니쳐 뒤에 숨기는 것 역시 추상화에 해당**한다.
* 나아가 **강력한 프로그래밍 언어들이 갖는 특징 중 하나는 공통적인 패턴에 이름을 붙여 추상화를 만드는 기능**에 있다고 볼 수 있다.
* 일반적으로, 프로그래밍에서는 다음과 같은 목적으로 추상화를 적용한다.
  1. 복잡성을 숨기기 위해
  2. 코드를 체계화하기 위해
  3. 개발자에게 변화의 자유를 주기 위해

### 추상화 계층이란?
* **계층이 잘 분리될수록 어떠한 계층에서 작업할 때 그 아래의 계층을 신경쓸 필요가 없으므로, 전체를 이해할 필요가 없어진다**.
  * 일반적으로 높은 레벨일수록 프로세서로부터 멀어져 제어력을 잃는 대신 걱정해야 할 세부적인 내용들은 적어진다.
  * 예를 들어 C 언어는 메모리 관리를 직접 할 수 있으나 세부적인 것들을 더 많이 신경써야 하며, Java는 메모리 최적화가 매우 어려울 수 있다.

### 코드 상에서의 추상화 계층 통일하기
* **컴퓨터 과학에서와 마찬가지로 코드 역시 추상화 계층을 정의하여 사용할 수 있으며, 함수는 이를 위한 기본적인 도구에 해당**한다.
* **컴퓨터 과학에서 높은 계층과 낮은 계층을 구분하는 것처럼, 함수 역시 높은 계층과 낮은 계층을 구분해서 사용**할 수 있어야 한다.
  * 이는 Single Level of Abstraction, 추상화 계층 통일 원칙이라고도 지칭된다.
* **함수는 최대한 간단하여 작고, 최소한의 책임을 가져야 하며 이로 인해 어떠한 함수가 복잡하다면 일부를 추출하여 추상화하는 것이 바람직**하다.
  * 또한, 이러한 형태로 함수를 추출하면 함수의 재사용과 테스트 역시 쉬워질 수 있다.

### 아키텍쳐 상의 추상화 계층
* 추상화 계층이라는 개념은 함수보다 높은 아키텍쳐 레벨에서도 적용이 가능하며, 이를 통해 문제 중심으로 프로그래밍할 수 있게 된다.
  * 이러한 개념은 모듈 시스템의 설계에도 중요하며, 모듈을 분리하는 것으로 계층 고유의 요소와 복잡성을 숨길 수 있다.
  * 예를 들어, 애플리케이션을 개발하는 과정에서 입력과 출력을 나타내는 모듈은 저수준의 모듈이며 비즈니스 로직을 나타내는 부분이 고수준의 모듈에 해당한다.
* **계층이 잘 분리된 프로젝트는 계층화가 잘 되었으므로 좋은 프로젝트이며, 어떠한 계층 위치에서 코드를 보더라도 일관된 관점**을 얻을 수 있다.

### 추상화 계층 - 결론
* 별도의 추상화 계층을 만드는 것은 프로그래밍에서 일반적으로 사용되는 개념이며, 이를 통해 knowledge를 체계화할 수 있다.
  * 나아가 서브시스템의 세부 사항을 숨겨 상호 운영성과 플랫폼 독립성을 얻을 수 있다.
* **함수나 클래스 및 모듈 등 다양한 구성 요소를 토대로 추상화를 분리할 수 있으나, 각 계층이 너무 커지는 것은 바람직하지 않다**.
  * 작고 최소한의 책임만 갖는 요소는 이해하기 쉬우며, 유지보수성 및 테스트 가능성도 높아진다.
* 추상화 계층은 구체적인 동작이나 입력 및 출력에 가까울수록 저수준에 해당하며, 낮은 계층에서는 높은 계층을 향하는 요소인 API를 정의해줄 수 있다.

## 2023-04-18 Tue
### 추상화를 통해 변경으로부터 코드를 보호하기 
```
> 함수와 클래스 같은 추상화로 코드를 숨기면 사용자는 복잡한 세부 사항을 몰라도 된다는 장점이 있다.
```
* 두 번 이상 반복되는 리터럴은 반복될수록 가독성과 유지보수성을 떨어트리므로, 상수로 추출한 후에 의미 있는 이름을 붙여주도록 한다.
  * 이를 통해 변경이 필요할 때 쉽게 변경할 수 있으며, 이름을 붙이므로 의미를 더 쉽게 이해할 수 있게 된다.
* 코드 상에서 빈번히 등장하는 알고리즘이 있다면, 간단한 확장 함수로 추출하여 상술한 상수 추출과 유사한 효과를 누릴 수 있게 된다.
  * 이러한 함수에서 중요한 것은 세부적인 동작 방식보다 그 의도에 있다.
  * 이렇듯 **함수 역시 추상화를 표현하는 수단으로, 무엇을 추상화하는지 표현하기 위해 메소드 시그니쳐를 사용하므로 좋은 이름은 매우 중요**하다.
* **함수 역시 추상화이지만 매우 단순하며, 상태를 유지할 수 없는 등의 제한이 많으므로 필요에 따라서는 더 강력한 추상화인 클래스를 고려**할 수 있다.
  * 클래스는 상태를 가질 수 있으므로 함수에 비해 강력하며, 여러 개의 메소드를 가질 수도 있다.
* 이렇듯 **클래스는 함수에 비해 더 많은 자유를 보장하지만, 더 많은 자유를 얻기 위해서는 보다 고수준의 추상화를 적용한 인터페이스를 고려**할 수 있다.
  * 예를 들어, 추상적인 인터페이스 뒤에 클래스를 두어 복잡한 세부 사항을 외부로부터 숨길 수 있게 된다.
* 나아가 보편적인 객체가 코드 이곳 저곳에 자주 등장하며, 변경 가능성이 높다면 이를 특수한 용도의 객체로 래핑하는 방식을 통해 추상화를 적용해볼 수도 있다. 

### 인터페이스를 고려하기
* 예를 들어 **공통 라이브러리를 제작하는 개발자는 내부 클래스의 가시성을 외부로부터 숨기고, 인터페이스만을 노출하는 방식을 자주 사용**한다.
  * 이를 통해 사용자는 구체적인 클래스와 결합도가 낮아지며, 라이브러리 개발자는 인터페이스만 유지하는 것으로 마음 놓고 수정을 가할 수 있게 된다.
* 한 편, **인터페이스는 선언 부와 사용 코드가 분리되므로 실제 클래스를 자유롭게 수정할 수 있는 반면 선언 부의 수정이 큰 영향을 미친다는 특징**을 갖는다.

### 과도한 추상화의 단점
```
> 추상화는 개발자에게 더 많은 자유를 주지만, 이를 정의하거나 사용하고 이해하기 위한 난이도를 높이기도 한다.
> 추상화는 단순한 중복 제거를 위한 도구에 그치지 않으며, 오히려 코드의 변경 난이도를 낮춰주는 중요한 요소이다.
```
* 어떤 방식으로든 추상화를 적용한다는 것은 코드의 난이도를 높이며, 무엇보다 추상화 역시 비용이 발생하므로 극단적으로 추상화하지는 않도록 주의해야 한다.
  * 즉, 추상화는 사실상 무한하게 적용할 수 있으나 어느 시점부터는 득보다 실이 많아질 수 있다.
* **추상화는 많은 것을 숨길 수 있는 기술이며, 이를 통해 복잡한 세부 사항을 숨길 수 있으나 너무 많이 숨기는 것으로 결과를 이해하기 어렵게 만들 수도 있다**.
  * 추상화라는 개념 자체를 잘 이해하기 위해서는 예제를 꾸준히 살펴보는 것이 좋으며, 개발 당시에도 단위 테스트와 문서를 통해 추상화를 잘 설명해야 한다.
* 결국 **추상화 역시 자유와 난이도 사이에 위치한 균형의 예술이며, 적절한 추상화의 정도는 항상 팀과 프로젝트와 같은 환경적 요소에 의해 결정**된다.
  * 예를 들어 프로젝트가 작고 실험적이라면 그다지 많은 추상화를 적용할 필요가 없으나, 규모가 클수록 변경이 어려우므로 추상화의 중요성은 높아진다.
  * 또한, 테스트 코드를 작성하거나 다른 애플리케이션을 기반으로 작성되는 애플리케이션에도 추상화를 적용하는 것이 바람직하다.
* **다른 모든 것과 마찬가지로 프로젝트 역시 변하기 마련이므로, 추상화를 사용하고 이를 위해 균형을 맞추어 가는 것은 반드시 숙달되어야 할 일에 해당**한다.

## 2023-04-19 Wed
### API 안정성에 주의하기
* 개발 분야 역시 다른 것과 마찬가지로 최대한 안정적이고 표준적인 API를 선호한다.
  * 그러나 API 개발자는 계속해서 개선해나가는 과정에서 API를 변경해나가고, API 사용자는 이에 대해 의견을 지속적으로 제시하곤 한다.
  * 이러한 과정에서 API 역시 버저닝을 적용하며, 주로 세 자리의 버전 번호를 사용하는 시멘틱 버저닝 기법이 사용된다.
* 결국 API 사용자는 API 안정성에 관심을 가져야 하며, 가능한 한 안정적인 API를 사용할 수 있도록 노력을 기울여야 한다.
  * 반면, API 개발자는 API 사용자와 꾸준히 소통하며 필요한 변경에 대해 사용자들이 적응할 시간을 충분히 제공할 수 있어야 한다.

### 불안정한 외부 API는 래핑하여 사용하기
* API의 안정성을 신뢰할 수 없는 경우, 이러한 API는 사실상 불안정한 것으로 과도하게 사용하지 않아야 한다.
* 그러나 **불안정한 외부 API를 어쩔 수 없이 사용해야 하는 경우, 최대한 비즈니스 로직과 결합되지 않도록 클래스 또는 함수 등으로 래핑**해야 한다.
  * 이러한 래핑을 통해 API의 형태를 프로젝트 스타일에 맞추어 바꿀 수 있으며, API의 변경 사항에도 쉽게 대응할 수 있게 된다.
* 반면, 외부 API를 래핑하는 경우 별도로 래퍼를 정의해야 하는 것은 물론 개발 난이도를 높일 수 있다는 단점 역시 수반된다.
  * 때문에 API 래핑의 장단점을 모두 이해해야 하며, 어떤 API를 래핑할지 신중히 결정할 수 있어야 한다.

## 2023-04-20 Thu
### 가능한 한 요소의 가시성을 제한하기
```
> 가시성이 제한될수록 API의 변경은 추적하기 쉽다.
```
* 기능이 많은 클래스보다는 기능이 적은 클래스를 이해하는 것이 쉽고, 변경할 때는 노출된 것을 숨기는 것보다 새로이 노출하는 것이 쉽다.
  * 때문에 코틀린에서는 접근자의 가시성을 제한하여 모든 프로피트를 캡슐화하는 것이 바람직하다.
  * 이렇듯 가시성을 제한할수록 클래스의 변경을 쉽게 추적할 수 있고, 나아가 상태 역시 더 쉽게 이해할 수 있게 된다.
* **작은 인터페이스를 유지하는 가장 쉬운 방법은 가시성을 제한하는 것이며, 되도록이면 가시성을 제한하여 외부로부터 접근할 수 없도록 하는 것이 바람직**하다.
  * 예를 들어 클래스 멤버의 경우 public과 private, protectd와 internal 가시성 한정자를 사용할 수 있다.
  * 반면 톱레벨 요소의 경우 public과 private 및 internal 가시성 한정자를 사용할 수 있다.
* 예를 들어 모듈이 다른 모듈에 의해 사용될 가능성이 있다면 internal을, 요소가 상속을 위해 설계되었다면 protected를 적극적으로 사용할 수 있다.
  * 그러나 애초에 데이터를 저장하기 위해 설계된 DTO에는 굳이 가시성 한정자를 적용할 필요가 없으며, 기본값인 public을 유지하는 것이 권장된다.

### API 규약은 문서로도 정의하기
```
> 요소, 특히 외부 API를 개발하는 과정에서는 반드시 규약을 잘 정의해야 한다.
> 규약은 사용자가 객체를 사용하는 방법을 해설하는 것으로 해당 요소를 더 쉽게 예측하도록 하며, 규약에 없는 부분에 대한 변경의 자유를 부여한다.
```
* 함수의 이름이나 메소드 시그니쳐만으로는 드러나지 않는 내부적인 동작을 명확히 설명하고자 하는 경우, KDoc 주석을 명시할 수 있다.
  * 이 때, KDoc이란 주석으로 요소를 문서화할 때 사용되는 공식적인 형식을 의미한다.
* 규약이란 요소가 갖는 예측 가능한 행위를 의미하며, 상술한 KDoc을 명시하는 것으로 개발자와 사용자 사이의 규약을 정의할 수 있게 된다.
  * 규약을 정의하는 것은 개발자와 사용자 모두에게 좋은 일이며, 규약을 준수하는 것으로 각각 수정의 자유와 사용 편의성을 얻게 된다.
  * 반면, 규약을 설정하지 않는 경우에는 개발자는 수정을 망설이게 되며 사용자는 구현의 세부적인 정보에 의존하게 된다.
* 또한, 이렇듯 유용한 규약을 정의하는 방법은 크게 다음과 같이 분류될 수 있다.
  1. 이름: 일반적인 개념을 해설하는 메소드는 이름만으로도 동작을 예측할 수 있다.
  2. 주석과 문서: 필요한 모든 규약을 명시할 수 있게 된다.
  3. 타입: 타입은 객체가 수행할 수 있는 행동에 대해 많은 것을 알려주며, 메소드 시그니쳐의 인자 타입과 반환형은 그 자체로도 많은 의미를 갖는다.
* 특히 주석의 경우, 이상적인 것은 코드만으로도 동작 원리를 이해할 수 있는 것이지만 주석을 토대로 더 많고 세부적인 내용의 규약을 설명할 수 있게 된다.
  * 바꿔 말해 메소드 시그니쳐만으로 요소의 목적이 표현될 수 있다면, 굳이 주석을 명시하는 것은 오히려 코드를 산만하게 만들 수 있다.
  * 또한, 함수를 추출하는 것만으로 충분히 가독성이 높아지는 경우 역시 별도로 주석을 명시할 필요가 없다.

### 타입 계층과 예측
* 타입 계층은 그 자체로 객체와 관련된 중요한 정보이며, 타입 계층이 제공하는 정보와 관련된 예시로 리스코프 치환 원칙을 들 수 있다.
  * 예를 들어 서브 클래스들은 슈퍼 클래스 객체를 언제나 대체할 수 있어야 한다.
* 그러나 클래스의 동작 방식에 대한 예측 자체에 문제가 발생하게 된다면, 해당 클래스의 상속과 관련된 다양한 문제가 발생할 수 밖에 없다.
  * 때문에 표준 라이브러리 또는 인기 있는 라이브러리에 포함되는 대부분의 클래스는 그 자신과 서브 클래스에 대한 자세한 설명 및 규약을 명시한다.

## 2023-04-21 Fri
### 추상화 규약은 준수하기
```
> 애플리케이션을 안정적으로 유지하고 싶은 경우, 가능한 한 규약을 준수하되 이를 위반할 수 밖에 없는 상황에는 내용을 잘 문서화해야 한다.
```
* 규약은 어디까지나 개발자와 사용자 간의 단순한 합의이므로, 사용자가 마음만 먹으면 얼마든지 규약을 위반할 수 있다.
  * 그러나 규약을 위반할 수 있다는 사실이 곧 규약을 위반해도 좋다는 의미가 될 수는 없다.
  * 규약은 어디까지나 보증과도 같으므로, 규약을 위반할 경우 코드가 오동작할 때 큰 문제를 일으킬 수 있게 된다.
* 클래스를 상속하거나 다른 라이브러리의 인터페이스를 구현하는 경우, 반드시 규약을 준수하는 것이 바람직하다.
# EffectiveCodes
## 2023-05-06 Sat
### 여러 개의 처리 단계를 갖는 경우에는 시퀀스를 활용하기
```
> 하나 이상의 처리 단계를 포함하는 컬렉션 처리의 경우, 시퀀스는 이터러블과 비교했을 때 일반적으로 약 20 ~ 40%의 성능 향상을 보인다.
```
* **이터러블과 시퀀스는 동일한 생김새의 인터페이스를 갖지만, 실제로는 서로 완전히 다른 목적으로 설계되었기에 서로 다른 방식으로 동작**한다.
  * 대표적으로, 매 처리 단계마다 새로운 이터러블을 반환하는 이터러블과 달리 시퀀스는 지연 처리를 위한 데코레이터를 반환한다.
  * 때문에 컬렉션 처리 연산은 호출 시마다 연산을 수행하는 반면, 시퀀스 처리 함수는 `최종 연산`이 발생하기 전까지 연산을 수행하지 않는다.
* 지연 처리를 목적으로 하는 시퀀스의 특징은 다음과 같은 장점을 갖는다.
  1. 자연스러운 처리 순서를 유지한다.
  2. 연산 횟수를 최소화한다.
  3. 무한 시퀀스 개념을 적용할 수 있다.
  4. 각 단계에서 새로운 컬렉션을 반환하지 않는다.

### 자연스러운 처리 순서란?
* **요소 전체를 대상으로 연산 단계를 진행하는 이터러블과 달리, 시퀀스는 요소 마다 지정한 연산을 한 번에 적용하는 식으로 동작**한다.
  * 덧붙여 이러한 시퀀스의 처리 방식은 lazy order로 지칭되는 반면, 이터러블의 처리 방식은 eager order 라는 표현을 사용한다.
* 컬렉션에 대한 처리를 고전적인 반복문을 통해 구현할 경우, 일반적으로 lazy order로 구현되므로 시퀀스 처리는 '자연스러운' 처리 순서를 갖는 것과 같다.
  * 나아가 단순 반복문과 조건문을 활용하는 것과 유사하게 동작하는 시퀀스 처리에는 근미래에 저수준의 최적화가 적용될 것을 기대할 수 있다.

### 최소 연산 횟수란?
* 컬렉션의 모든 요소에 대해 연산을 적용하는 이터러블과 달리, 매 요소마다 모든 처리를 적용하는 시퀀스는 항상 이터러블 이하의 연산 횟수를 갖는다.
  * 이러한 이유에서 **중간 처리 단계를 반드시 모든 요소에 적용해야할 필요가 없는 경우에는 시퀀스를 적용하는 것이 바람직**하다.

### 무한 시퀀스란?
* 코틀린에서는 `generateSequence` 또는 `sequence` 를 활용하여 무한 시퀀스를 쉽게 생성할 수 있다.
  * 이는 시퀀스가 최종 연산이 발생하기 전까지 컬렉션에 대해 어떠한 처리도 적용하지 않기 때문에 가능한 것으로 이해할 수 있다.
* 이 때, 무한 시퀀스가 종료되지 않고 계속해서 동작하는 상황을 방지하기 위해서는 실제로 몇 개의 값을 활용할지 제한하는 방식으로 구현해야 한다.
  * 실제로 무한 시퀀스가 무한 반복되는 상황은 자주 발생하므로, 실수하기 쉬운 any나 none보다 take나 first와 같은 종결 연산을 활용하는 것이 바람직하다.

## 2023-05-07 Sun
### 각 단계에서 새로운 컬렉션을 반환하지 않는 시퀀스의 특징
* 기본적인 컬렉션 처리 함수는 각 단계에서 새로운 컬렉션을 반환하지만, 크거나 무거운 컬렉션을 처리하는 경우 이러한 동작은 메모리를 많이 소비할 수 밖에 없다.
  * **각 연산 단계에서 새로운 컬렉션을 만드는 방식의 경우에는 큰 요소를 처리할수록 더 많은 시간이 걸릴 것이므로, 시퀀스는 성능 상의 이점도 제공**한다.
  * 때문에 처리 단계가 하나인 경우 컬렉션 처리와 시퀀스 처리의 차이는 크지 않지만, 처리 단계가 많아질수록 차이는 벌어지게 된다.

### 시퀀스가 더 빠르지 않은 경우
* 컬렉션 전체에 대해 연산 단계를 적용해야 하는 경우, 시퀀스를 사용한다고 해도 더 좋은 성능을 기대하기는 어렵다.
  * 대표적으로 sorted 연산의 경우 시퀀스가 더 느리며, 이외의 모든 연산 단계는 시퀀스는가 더 높은 성능을 보인다.

### Java 스트림과의 비교
* Java 8에서 도입된 스트림 역시 lazy하게 동작하는 등 시퀀스와 유사성을 보이지만, 다음과 같은 큰 차이점을 갖는다.
  1. 코틀린의 시퀀스가 더 많은 처리 함수를 지원하며, 사용하기도 쉽다.
  2. Java 스트림은 병렬 모드로 실행될 수 있으므로 멀티 코어 환경에서 더 좋은 성능을 보이나, 몇 가지 결함이 존재하므로 사용에는 주의를 기울여야 한다.
  3. 여러 모듈에서 동작할 수 있는 코틀린의 시퀀스와 달리, Java 스트림은 Java 8 버전 이상의 코틀린/JVM에서만 동작할 수 있다.
* 병렬 모드를 제외했을 때 우열을 가리기에는 어려움이 있으므로, 병렬 모드로 확실한 이득을 볼 수 있는 경우가 아니라면 시퀀스를 사용하는 것이 바람직하다.

### 코틀린 시퀀스 - 결론
* 컬렉션과 시퀀스는 같은 처리 메소드들을 지원하며, 사용하는 형태 역시 비슷하다.
* 시퀀스는 컬렉션을 시퀀스로 변환하여 처리를 마친 후에 다시 컬렉션으로 변환해야 하는 단점이 존재하나, lazy하게 처리됨으로 인해 얻을 수 있는 장점이 더 많다.
  * 따라서 **무거운 객체나 커다란 컬렉션을 여러 단계에 걸쳐 처리해야 하는 경우에는 시퀀스를 적용하는 것이 바람직**하다.

## 2023-05-08 Mon
### 가능한 한 컬렉션 처리 단계를 제한하기
```
> 일반적으로, 컬렉션 처리와 관련된 비효율적인 코드는 제공되는 처리 메소드 중 더 효율적인 것이 모르기 때문에 발생하는 경우가 더 많다.
```
* **모든 컬렉션 처리 메소드는 비용이 많이 드는 편이므로, 가능한 한 적절한 메소드를 활용하여 컬렉션 처리 단계를 제한하는 것이 바람직**하다.
  * 예를 들어 표준 컬렉션 처리는 모든 요소에 대해 처리를 반복하며, 내부적으로 새로운 컬렉션을 생성한다.
  * 반면, **시퀀스의 경우에도 시퀀스 전체를 래핑하거나 조작하기 위한 추가적인 객체를 생성하므로 큰 컬렉션에 대해서는 큰 비용이 필요할 수 밖에 없다**.
* 이렇듯 대부분의 컬렉션 처리 단계는 전체 요소에 대한 반복과 중간 컬렉션 생성에 의한 비용이 발생하므로, 반드시 적절한 컬렉션 처리 함수를 고려해야 한다.
  * 예를 들어 `.filter { it != null }.map{ it!! }` 보다는 `.filterNotNull()`을 적용하여 컬렉션 처리 비용을 줄이는 것이 더 좋다.

### 성능이 중요한 상황에는 원시 타입 배열을 고려하기
```
> 일반적으로는 배열보다 컬렉션을 사용하는 것이 옳은 선택이나, 커다란 원시 타입 컬렉션을 처리하는 경우에는 배열의 도입을 고려하는 것이 바람직하다. 
```
* 코틀린은 원시 타입을 직접 선언할 수 없으나, 최적화 과정에서 내부적으로 사용될 수 있다.
  * 이렇듯 의도적으로 원시 타입이 적용되도록 코드를 최적화할 수 있다면, 가볍고 빠른 원시 타입의 장점을 마음껏 누릴 수 있다.
* 많은 데이터를 처리하는 경우에 원시 타입을 사용할 수 있다면 큰 최적화를 이루어낼 수 있으나, 컬렉션은 제네릭 타입을 사용하므로 원시 타입을 유도할 수 없다.
  * 때문에 **성능이 중요하여 원시 타입을 사용하도록 최적화하고자 하는 경우, `IntArray`와 같은 원시 타입 배열을 고려**할 수 있다.
* **원시 타입 배열은 컬렉션과 비교하여 더 적은 메모리를 소비하며, 각 요소에 대한 처리 역시 일반적으로 약 25%의 성능 향상을 기대**할 수 있다.
  * 반면, **일반적인 경우에는 더 많은 기능을 쉬운 사용성과 함께 제공하는 컬렉션을 사용하는 것이 바람직**하다.

## 2023-05-09 Tue
### mutable 컬렉션 도입을 고려하기
```
> mutable 컬렉션은 요소를 추가하는 것이 더 빠른 반면, immutable 컬렉션은 컬렉션 변경과 관련된 처리를 세밀하게 관리할 수 있다는 장점을 갖는다.
```
* immutable 컬렉션과 비교했을 때, mutable 컬렉션은 다음과 같은 특징을 갖는다.
  1. 성능: 요소를 추가할 때 새로운 컬렉션을 생성하는 immutable 컬렉션과 달리, 요소를 추가하기만 하면 되므로 더 빠르다.
  2. 안정성: 한 번 생성된 후에는 컬렉션 내부의 내용이 조작될 수 없는 immutable 컬렉션과 비교했을 때, 더 안정적이지 못하다.
* 결국 **mutable 컬렉션은 안정성이 떨어지나, 작은 스코프 내에서 지역 변수 형태로 사용될 때에는 성능을 희생하면서까지 안정성을 고려할 필요가 없다**.
  * 따라서 **지역 스코프에서 지역 변수 형태로 사용되는 컬렉션의 경우에는 성능이 더 높은 mutable 컬렉션을 사용하는 것이 바람직**하다.
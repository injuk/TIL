# EffectiveCodes
## 2023-05-06 Sat
### 여러 개의 처리 단계를 갖는 경우에는 시퀀스를 활용하기
```
> 하나 이상의 처리 단계를 포함하는 컬렉션 처리의 경우, 시퀀스는 이터러블과 비교했을 때 일반적으로 약 20 ~ 40%의 성능 향상을 보인다.
```
* **이터러블과 시퀀스는 동일한 생김새의 인터페이스를 갖지만, 실제로는 서로 완전히 다른 목적으로 설계되었기에 서로 다른 방식으로 동작**한다.
  * 대표적으로, 매 처리 단계마다 새로운 이터러블을 반환하는 이터러블과 달리 시퀀스는 지연 처리를 위한 데코레이터를 반환한다.
  * 때문에 컬렉션 처리 연산은 호출 시마다 연산을 수행하는 반면, 시퀀스 처리 함수는 `최종 연산`이 발생하기 전까지 연산을 수행하지 않는다.
* 지연 처리를 목적으로 하는 시퀀스의 특징은 다음과 같은 장점을 갖는다.
  1. 자연스러운 처리 순서를 유지한다.
  2. 연산 횟수를 최소화한다.
  3. 무한 시퀀스 개념을 적용할 수 있다.
  4. 각 단계에서 새로운 컬렉션을 반환하지 않는다.

### 자연스러운 처리 순서란?
* **요소 전체를 대상으로 연산 단계를 진행하는 이터러블과 달리, 시퀀스는 요소 마다 지정한 연산을 한 번에 적용하는 식으로 동작**한다.
  * 덧붙여 이러한 시퀀스의 처리 방식은 lazy order로 지칭되는 반면, 이터러블의 처리 방식은 eager order 라는 표현을 사용한다.
* 컬렉션에 대한 처리를 고전적인 반복문을 통해 구현할 경우, 일반적으로 lazy order로 구현되므로 시퀀스 처리는 '자연스러운' 처리 순서를 갖는 것과 같다.
  * 나아가 단순 반복문과 조건문을 활용하는 것과 유사하게 동작하는 시퀀스 처리에는 근미래에 저수준의 최적화가 적용될 것을 기대할 수 있다.

### 최소 연산 횟수란?
* 컬렉션의 모든 요소에 대해 연산을 적용하는 이터러블과 달리, 매 요소마다 모든 처리를 적용하는 시퀀스는 항상 이터러블 이하의 연산 횟수를 갖는다.
  * 이러한 이유에서 **중간 처리 단계를 반드시 모든 요소에 적용해야할 필요가 없는 경우에는 시퀀스를 적용하는 것이 바람직**하다.

### 무한 시퀀스란?
* 코틀린에서는 `generateSequence` 또는 `sequence` 를 활용하여 무한 시퀀스를 쉽게 생성할 수 있다.
  * 이는 시퀀스가 최종 연산이 발생하기 전까지 컬렉션에 대해 어떠한 처리도 적용하지 않기 때문에 가능한 것으로 이해할 수 있다.
* 이 때, 무한 시퀀스가 종료되지 않고 계속해서 동작하는 상황을 방지하기 위해서는 실제로 몇 개의 값을 활용할지 제한하는 방식으로 구현해야 한다.
  * 실제로 무한 시퀀스가 무한 반복되는 상황은 자주 발생하므로, 실수하기 쉬운 any나 none보다 take나 first와 같은 종결 연산을 활용하는 것이 바람직하다.

## 2023-05-07 Sun
### 각 단계에서 새로운 컬렉션을 반환하지 않는 시퀀스의 특징
* 기본적인 컬렉션 처리 함수는 각 단계에서 새로운 컬렉션을 반환하지만, 크거나 무거운 컬렉션을 처리하는 경우 이러한 동작은 메모리를 많이 소비할 수 밖에 없다.
  * **각 연산 단계에서 새로운 컬렉션을 만드는 방식의 경우에는 큰 요소를 처리할수록 더 많은 시간이 걸릴 것이므로, 시퀀스는 성능 상의 이점도 제공**한다.
  * 때문에 처리 단계가 하나인 경우 컬렉션 처리와 시퀀스 처리의 차이는 크지 않지만, 처리 단계가 많아질수록 차이는 벌어지게 된다.

### 시퀀스가 더 빠르지 않은 경우
* 컬렉션 전체에 대해 연산 단계를 적용해야 하는 경우, 시퀀스를 사용한다고 해도 더 좋은 성능을 기대하기는 어렵다.
  * 대표적으로 sorted 연산의 경우 시퀀스가 더 느리며, 이외의 모든 연산 단계는 시퀀스는가 더 높은 성능을 보인다.

### Java 스트림과의 비교
* Java 8에서 도입된 스트림 역시 lazy하게 동작하는 등 시퀀스와 유사성을 보이지만, 다음과 같은 큰 차이점을 갖는다.
  1. 코틀린의 시퀀스가 더 많은 처리 함수를 지원하며, 사용하기도 쉽다.
  2. Java 스트림은 병렬 모드로 실행될 수 있으므로 멀티 코어 환경에서 더 좋은 성능을 보이나, 몇 가지 결함이 존재하므로 사용에는 주의를 기울여야 한다.
  3. 여러 모듈에서 동작할 수 있는 코틀린의 시퀀스와 달리, Java 스트림은 Java 8 버전 이상의 코틀린/JVM에서만 동작할 수 있다.
* 병렬 모드를 제외했을 때 우열을 가리기에는 어려움이 있으므로, 병렬 모드로 확실한 이득을 볼 수 있는 경우가 아니라면 시퀀스를 사용하는 것이 바람직하다.

### 코틀린 시퀀스 - 결론
* 컬렉션과 시퀀스는 같은 처리 메소드들을 지원하며, 사용하는 형태 역시 비슷하다.
* 시퀀스는 컬렉션을 시퀀스로 변환하여 처리를 마친 후에 다시 컬렉션으로 변환해야 하는 단점이 존재하나, lazy하게 처리됨으로 인해 얻을 수 있는 장점이 더 많다.
  * 따라서 **무거운 객체나 커다란 컬렉션을 여러 단계에 걸쳐 처리해야 하는 경우에는 시퀀스를 적용하는 것이 바람직**하다.

## 2023-05-08 Mon
### 가능한 한 컬렉션 처리 단계를 제한하기
```
> 일반적으로, 컬렉션 처리와 관련된 비효율적인 코드는 제공되는 처리 메소드 중 더 효율적인 것이 모르기 때문에 발생하는 경우가 더 많다.
```
* **모든 컬렉션 처리 메소드는 비용이 많이 드는 편이므로, 가능한 한 적절한 메소드를 활용하여 컬렉션 처리 단계를 제한하는 것이 바람직**하다.
  * 예를 들어 표준 컬렉션 처리는 모든 요소에 대해 처리를 반복하며, 내부적으로 새로운 컬렉션을 생성한다.
  * 반면, **시퀀스의 경우에도 시퀀스 전체를 래핑하거나 조작하기 위한 추가적인 객체를 생성하므로 큰 컬렉션에 대해서는 큰 비용이 필요할 수 밖에 없다**.
* 이렇듯 대부분의 컬렉션 처리 단계는 전체 요소에 대한 반복과 중간 컬렉션 생성에 의한 비용이 발생하므로, 반드시 적절한 컬렉션 처리 함수를 고려해야 한다.
  * 예를 들어 `.filter { it != null }.map{ it!! }` 보다는 `.filterNotNull()`을 적용하여 컬렉션 처리 비용을 줄이는 것이 더 좋다.
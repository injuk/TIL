# EffectiveCodes
## 2023-04-10 Mon
### 가독성을 목표로 설계하기
```
> 코틀린은 가독성을 높이는 데에 목표를 둔 채 설계된 언어이며, 간결성은 부가적인 효과에 불과하다.
> 코드는 기본적으로 독자의 인지 부하를 줄이는 방향으로 설계되는 것이 바람직하다.
```
* 가독성이란 우리의 뇌가 코드를 읽고 작동 방식을 얼마나 빠르게 이해할 수 있는지를 나타내는 지표에 해당한다.
  * 또한, **숙련된 개발자들만 이해할 수 있는 코드는 가독성이 높다고 생각할 수 없으며 좋은 코드도 아니다**.
  * 일반적으로 사용 빈도가 적은 관용구는 코드를 이해하기 어렵게 하며, 이러한 관용구 여럿을 한 문장에 조합한다면 복잡성은 더욱 빠르게 증가한다.
* 또한 일반적이지 않고 '창의적인' 구조는 코드의 수정에 대응하기도 쉽지 않으며, IDE의 지원을 받기도 어렵다.
* 일반적으로 **문제가 되는 경우는 정당한 이유 없이 복잡성을 추가하여 코드의 유지보수 비용을 높이는 것**에서 온다.
  * 바꿔 말해, 코드는 종종 기꺼이 지불할 만한 가치가 있는 비용을 포함할 수도 있다.

### 연산자 오버로드에는 주의를 기울이기
```
> 연산자 오버로딩은 반드시 그 의미에 맞게 사용되어야 하며, 의미가 명확해지지 않는다면 사용을 지양하는 것이 바람직하다.
> 의미가 명확하지 않은 경우, 연산자 오버로딩 대신 좋은 이름이 명시된 일반 함수 또는 infix 확장 함수나 톱레벨 함수를 고려할 수 있다.
```
* **코틀린의 모든 연산자는 각각 대응되는 함수에 대한 별칭일 뿐으로, 그 이름만으로도 연산자의 오버로딩은 크게 제한**되어야 한다.
  * 예를 들어, 팩토리얼 연산의 기호가 !라고 해서 논리 연산인 `not()` 메소드를 오버로딩하지 않아야 한다.
  * 이러한 선택은 모든 독자가 이러한 코드를 개별적으로 이해해야 하도록 강제하므로, 유지보수 비용이 높아질 수 밖에 없다.
* **연산자 오버로딩을 고려할 때, 어떻게 해도 의미가 명확해지지 않는 것 같다면 infix를 활용한 확장 함수를 적용**해볼 수 있다.
  * 또는 해당 용도에 맞는 톱레벨 함수를 정의하는 방법도 고려할 수 있다.
* 그러나 **도메인 특화 언어를 설계하는 과정에서는 상술한 연산자 오버로딩 규칙을 무시해도 무방**하다.

## 2023-04-11 Tue
### Unit? 을 반환형으로 사용하지 않기
* 반환형이 Boolean인 함수가 true 또는 false를 반환하듯, Unit?은 Unit과 null을 반환할 수 있다.
* 따라서 Unit?을 반환형으로 사용하는 함수는 Boolean을 반환하도록 수정이 가능하며, 이러한 방식이 가독성을 더 높여줄 수 있다.
  * 일반적으로 Unit?으로 Boolean을 표현하는 방식은 가독성이 낮고, 결과를 예측하는 것은 더 어렵다.

### 변수 타입이 명확해보이지 않는다면, 명확해지도록 명시하기
* 코틀린은 개발자가 일일히 타입을 지정하지 않아도 되도록 하는 수준 높은 타입 시스템을 갖는다.
* 일반적으로 이러한 특징은 코드의 가독성을 크게 향상시키지만, 다음과 같은 경우에는 타입을 숨기는 것처럼 보여질 수 있다.
```kotlin
val result = doSomething()
```
* **코드를 읽을 때 `doSomething()`의 정의를 따로 확인한다는 것 자체가 가독성이 떨어진다는 증거이며, 모든 독자가 IDE를 사용하지 않을 수도 있다**.
  * 즉, 가독성을 위해 코드를 설계한다면 컴파일러 뿐만 아니라 독자에게도 중요한 정보인 타입을 가능한 한 숨기지 않아야 한다.

### 리시버는 명시적으로 참조하기
```
> 코드를 짧게 축약할 수 있다는 사실만으로 리시버를 항상 제거하는 행위는 바람직하지 못하며, 오히려 여러 리시버가 존재하는 상황에서는 이를 명시하는 것이 좋다.
```
* 어떤 개념을 더 자세히 설명하기 위해, 의도적으로 this를 명시하는 등 명시적으로 긴 코드를 사용할 수도 있다.
* 예를 들어 **리시버의 경우, 동일한 스코프 내에 둘 이상의 리시버가 존재한다면 이를 명시적으로 나타내는 것이 바람직**하다.
  * apply나 with 및 run 함수를 사용하는 경우는 좋은 예시인 반면, nullable 값을 처리하는 경우에는 also와 let을 사용한다.
  * **중요한 것은 리시버가 명확하지 않은 코드에서 이를 명확히 명시**하는 데에 있으며, 이를 통해 어떤 리시버의 함수인지를 알 수 있어 가독성은 더 향상된다.
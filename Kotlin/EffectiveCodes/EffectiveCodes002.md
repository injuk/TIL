# EffectiveCodes
## 2023-04-10 Mon
### 가독성을 목표로 설계하기
```
> 코틀린은 가독성을 높이는 데에 목표를 둔 채 설계된 언어이며, 간결성은 부가적인 효과에 불과하다.
> 코드는 기본적으로 독자의 인지 부하를 줄이는 방향으로 설계되는 것이 바람직하다.
```
* 가독성이란 우리의 뇌가 코드를 읽고 작동 방식을 얼마나 빠르게 이해할 수 있는지를 나타내는 지표에 해당한다.
  * 또한, **숙련된 개발자들만 이해할 수 있는 코드는 가독성이 높다고 생각할 수 없으며 좋은 코드도 아니다**.
  * 일반적으로 사용 빈도가 적은 관용구는 코드를 이해하기 어렵게 하며, 이러한 관용구 여럿을 한 문장에 조합한다면 복잡성은 더욱 빠르게 증가한다.
* 또한 일반적이지 않고 '창의적인' 구조는 코드의 수정에 대응하기도 쉽지 않으며, IDE의 지원을 받기도 어렵다.
* 일반적으로 **문제가 되는 경우는 정당한 이유 없이 복잡성을 추가하여 코드의 유지보수 비용을 높이는 것**에서 온다.
  * 바꿔 말해, 코드는 종종 기꺼이 지불할 만한 가치가 있는 비용을 포함할 수도 있다.

### 연산자 오버로드에는 주의를 기울이기
```
> 연산자 오버로딩은 반드시 그 의미에 맞게 사용되어야 하며, 의미가 명확해지지 않는다면 사용을 지양하는 것이 바람직하다.
> 의미가 명확하지 않은 경우, 연산자 오버로딩 대신 좋은 이름이 명시된 일반 함수 또는 infix 확장 함수나 톱레벨 함수를 고려할 수 있다.
```
* **코틀린의 모든 연산자는 각각 대응되는 함수에 대한 별칭일 뿐으로, 그 이름만으로도 연산자의 오버로딩은 크게 제한**되어야 한다.
  * 예를 들어, 팩토리얼 연산의 기호가 !라고 해서 논리 연산인 `not()` 메소드를 오버로딩하지 않아야 한다.
  * 이러한 선택은 모든 독자가 이러한 코드를 개별적으로 이해해야 하도록 강제하므로, 유지보수 비용이 높아질 수 밖에 없다.
* **연산자 오버로딩을 고려할 때, 어떻게 해도 의미가 명확해지지 않는 것 같다면 infix를 활용한 확장 함수를 적용**해볼 수 있다.
  * 또는 해당 용도에 맞는 톱레벨 함수를 정의하는 방법도 고려할 수 있다.
* 그러나 **도메인 특화 언어를 설계하는 과정에서는 상술한 연산자 오버로딩 규칙을 무시해도 무방**하다.
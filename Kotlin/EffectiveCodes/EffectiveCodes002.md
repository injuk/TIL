# EffectiveCodes
## 2023-04-10 Mon
### 가독성을 목표로 설계하기
```
> 코틀린은 가독성을 높이는 데에 목표를 둔 채 설계된 언어이며, 간결성은 부가적인 효과에 불과하다.
> 코드는 기본적으로 독자의 인지 부하를 줄이는 방향으로 설계되는 것이 바람직하다.
```
* 가독성이란 우리의 뇌가 코드를 읽고 작동 방식을 얼마나 빠르게 이해할 수 있는지를 나타내는 지표에 해당한다.
  * 또한, **숙련된 개발자들만 이해할 수 있는 코드는 가독성이 높다고 생각할 수 없으며 좋은 코드도 아니다**.
  * 일반적으로 사용 빈도가 적은 관용구는 코드를 이해하기 어렵게 하며, 이러한 관용구 여럿을 한 문장에 조합한다면 복잡성은 더욱 빠르게 증가한다.
* 또한 일반적이지 않고 '창의적인' 구조는 코드의 수정에 대응하기도 쉽지 않으며, IDE의 지원을 받기도 어렵다.
* 일반적으로 **문제가 되는 경우는 정당한 이유 없이 복잡성을 추가하여 코드의 유지보수 비용을 높이는 것**에서 온다.
  * 바꿔 말해, 코드는 종종 기꺼이 지불할 만한 가치가 있는 비용을 포함할 수도 있다.

### 연산자 오버로드에는 주의를 기울이기
```
> 연산자 오버로딩은 반드시 그 의미에 맞게 사용되어야 하며, 의미가 명확해지지 않는다면 사용을 지양하는 것이 바람직하다.
> 의미가 명확하지 않은 경우, 연산자 오버로딩 대신 좋은 이름이 명시된 일반 함수 또는 infix 확장 함수나 톱레벨 함수를 고려할 수 있다.
```
* **코틀린의 모든 연산자는 각각 대응되는 함수에 대한 별칭일 뿐으로, 그 이름만으로도 연산자의 오버로딩은 크게 제한**되어야 한다.
  * 예를 들어, 팩토리얼 연산의 기호가 !라고 해서 논리 연산인 `not()` 메소드를 오버로딩하지 않아야 한다.
  * 이러한 선택은 모든 독자가 이러한 코드를 개별적으로 이해해야 하도록 강제하므로, 유지보수 비용이 높아질 수 밖에 없다.
* **연산자 오버로딩을 고려할 때, 어떻게 해도 의미가 명확해지지 않는 것 같다면 infix를 활용한 확장 함수를 적용**해볼 수 있다.
  * 또는 해당 용도에 맞는 톱레벨 함수를 정의하는 방법도 고려할 수 있다.
* 그러나 **도메인 특화 언어를 설계하는 과정에서는 상술한 연산자 오버로딩 규칙을 무시해도 무방**하다.

## 2023-04-11 Tue
### Unit? 을 반환형으로 사용하지 않기
* 반환형이 Boolean인 함수가 true 또는 false를 반환하듯, Unit?은 Unit과 null을 반환할 수 있다.
* 따라서 Unit?을 반환형으로 사용하는 함수는 Boolean을 반환하도록 수정이 가능하며, 이러한 방식이 가독성을 더 높여줄 수 있다.
  * 일반적으로 Unit?으로 Boolean을 표현하는 방식은 가독성이 낮고, 결과를 예측하는 것은 더 어렵다.

### 변수 타입이 명확해보이지 않는다면, 명확해지도록 명시하기
* 코틀린은 개발자가 일일히 타입을 지정하지 않아도 되도록 하는 수준 높은 타입 시스템을 갖는다.
* 일반적으로 이러한 특징은 코드의 가독성을 크게 향상시키지만, 다음과 같은 경우에는 타입을 숨기는 것처럼 보여질 수 있다.
```kotlin
val result = doSomething()
```
* **코드를 읽을 때 `doSomething()`의 정의를 따로 확인한다는 것 자체가 가독성이 떨어진다는 증거이며, 모든 독자가 IDE를 사용하지 않을 수도 있다**.
  * 즉, 가독성을 위해 코드를 설계한다면 컴파일러 뿐만 아니라 독자에게도 중요한 정보인 타입을 가능한 한 숨기지 않아야 한다.

### 리시버는 명시적으로 참조하기
```
> 코드를 짧게 축약할 수 있다는 사실만으로 리시버를 항상 제거하는 행위는 바람직하지 못하며, 오히려 여러 리시버가 존재하는 상황에서는 이를 명시하는 것이 좋다.
```
* 어떤 개념을 더 자세히 설명하기 위해, 의도적으로 this를 명시하는 등 명시적으로 긴 코드를 사용할 수도 있다.
* 예를 들어 **리시버의 경우, 동일한 스코프 내에 둘 이상의 리시버가 존재한다면 이를 명시적으로 나타내는 것이 바람직**하다.
  * apply나 with 및 run 함수를 사용하는 경우는 좋은 예시인 반면, nullable 값을 처리하는 경우에는 also와 let을 사용한다.
  * **중요한 것은 리시버가 명확하지 않은 코드에서 이를 명확히 명시**하는 데에 있으며, 이를 통해 어떤 리시버의 함수인지를 알 수 있어 가독성은 더 향상된다.

## 2023-04-12 Wed
### 프로퍼티는 상태를 나타내는 용도로만 사용하기
* 코틀린 프로퍼티는 Java의 필드와 유사해보이지만, 실제로는 서로 완전히 다른 개념이다.
  * 예를 들어 둘 다 데이터를 저장한다는 점에서는 공통점이 있으나, 프로퍼티는 더 많은 기능을 갖는다.
  * 단적으로 코틀린의 프로퍼티는 이를 활용한 자체적인 게터와 세터와 같은 파생 프로퍼티를 갖는다.
* **프로퍼티는 본질적으로 필드가 아닌 함수이나, 원칙적으로 상태를 나타내거나 설정하기 위한 용도로만 사용**되어야 한다.
  * 때문에 **어떠한 것을 프로퍼티로 결정하기 위해서는 `이 프로퍼티를 함수로 정의할 때, get 또는 set 접두사를 붙일 것인가?`를 자문**해볼 수 있다.
* 또는 구체적으로 다음과 같은 경우에 프로퍼티보다는 함수를 사용하는 것이 바람직하다.
  1. 복잡도가 O(1) 이상인 등 연산 비용이 높은 경우
  2. 비즈니스 로직을 포함하는 경우
  3. 해당 동작에 멱등성이 보장되지 않아 매 호출마다 다른 결과가 반환될 경우
  4. 데이터를 다른 형태로 변환하는 경우
  5. 구현한 게터에서 프로퍼티의 상태 변경이 유발되는 경우
* 반대로 **상태를 추출하거나 설정하는 경우에는 반드시 프로퍼티를 사용해야 하며, 함수의 사용은 지양하는 것이 바람직**하다.

### 이름 있는 인자를 적극적으로 사용하기
```
> 이름 있는 인자는 비단 디폴트 값을 생략할 때에만 유용한 것이 아니며, 가독성과 안정성 측면에서도 큰 이점을 줄 수 있다.
```
* 코드 상에서 인자의 의미가 명확하지 않은 경우가 있으며, 이 경우에는 코틀린의 이름 있는 인자를 적극적으로 활용할 수 있다.
  * 이는 인자의 의미를 명확히 하기 위해 변수로 추출한 경우에도 마찬가지이며, 기본적으로는 이름 있는 인자를 사용하는 것이 권장된다.
* 이름 있는 인자를 사용하면 코드의 길이는 길어지지만, 크게 다음과 같은 이점을 기대할 수 있다.
  1. 이름을 토대로 값이 무엇을 의미하는지 알 수 있다.
  2. 매개변수의 입력 순서와 무관하므로 안전한 코드를 작성할 수 있다.
* 또한, 이름 있는 인자는 특히 다음과 같은 경우에 큰 효과를 얻을 수 있다.
  1. 디폴트 인자: 프로퍼티가 디폴트 인자를 갖는 경우, 항상 이름을 명시하는 것이 권장된다.
  2. 같은 타입의 매개변수가 많은 경우: 매개변수가 많은 경우, 이들이 타입마저 같다면 디버깅의 난이도가 높아지므로 이름을 명시하는 것이 권장된다.
  3. 함수 타입 매개변수를 사용하는 경우: 일반적으로 함수 타입 매개변수는 마지막 위치에 배치되며, 이 때에도 이름을 명시하는 것으로 가독성을 향상시킬 수 있다.

## 2023-04-13 Thu
### 코딩 컨벤션은 반드시 준수하기
```
> 프로젝트의 모든 코드는 마치 한 사람이 작성한 것처럼 작성되는 것이 바람직하다.
```
* 코틀린은 잘 정리된 코딩 컨벤션을 가지며, 코틀린 커뮤니티에 속한 사람은 이를 최대한 준수하는 것이 바람직하다.
* 팀에 따라서는 일부 다른 규칙을 사용할 수 있으나, 어찌됐건 프로젝트의 컨벤션은 반드시 준수해야 한다.
  * **코딩 컨벤션은 어디에서나 강조되는 내용이며, 코딩 컨벤션을 확실히 숙지한 후 정적 검사기를 통해 프로젝트의 코딩 컨벤션 일관성을 유지**해야 한다.
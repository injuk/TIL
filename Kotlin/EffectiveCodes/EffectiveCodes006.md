# EffectiveCodes
## 2023-04-25 Tue
### 코틀린의 클래스 설계
* 클래스는 OOP에서 중요한 추상화 수단이듯, 코틀린에서도 중요한 개념일 수 밖에 없다.
* 또한, 코틀린은 개발에 도움이 되는 데이터 클래스나 함수 타입 등 여러 개념을 지원하므로 이를 용도에 맞게 사용하는 것이 매우 중요하다.
  * 이러한 규약을 위배할 경우 치명적인 문제가 발생할 수 있으나, 반대로 규약을 잘 준수한다면 안전하고 가독성 높은 코드를 만들어낼 수 있다.

### 상속보다는 컴포지션을 활용하기
```
> 상속은 is - a 관계를 정의하기 위한 매우 강력한 기능이지만, 명확하지 않은 관계에서는 오히려 많은 문제를 일으킬 수 있다.
```
* 단순한 코드 추출 및 중복 제거를 위해 상속을 적용하는 것은 바람직하지 않으며, 이러한 경우에는 일반적으로 컴포지션을 사용하는 것이 바람직하다.
* 단순한 코드의 추출만을 겨냥한 상속 계층도의 정의는 크게 다음과 같은 단점을 갖는다.
  1. 상속은 하나의 클래스만을 대상으로 하므로, 행위를 계속해서 추출할수록 많은 함수를 갖는 클래스를 정의하면서도 계층 구조는 깊어진다.
  2. 때문에 상속을 기반으로 할 경우 불필요한 함수를 너무 많이 갖는 클래스가 정의되므로 인터페이스 분리 원칙을 위반하기 쉽다.
  3. 이러한 종류의 상속은 일반적으로 이해하기 어려운 코드를 낳는다.
* **상속의 대표적인 대안은 컴포지션이며, 이는 객체를 프로퍼티로 가져 함수를 호출하는 형태로 재사용하는 것을 의미**한다.
  * 컴포지션은 대부분의 경우에 코드의 실행을 상속보다 명확하게 예측할 수 있는 특징을 갖는다.

### 모든 것을 물려 받는 상속의 단점
* 상속을 활용할 경우 서브클래스는 슈퍼클래스의 메소드나 제약 등을 모두 가져오게 되며, 이는 객체의 계층 구조를 표현할 때 큰 장점으로 작용한다.
    * 반면, **이러한 특징으로 인해 슈퍼클래스의 일부만을 재사용하기 위한 목적으로는 적합할 수 없다**.
* 또한, 단순한 코드 재사용만을 목적으로 한 상속은 ISP와 LSP를 위반할 가능성이 높다.

### 캡슐화를 위배하는 상속의 단점
* 상속을 활용할 경우 내부적인 구현 변경에 의해 클래스의 캡슐화가 깨질 가능성을 배제할 수 없다.
  * 또한, 라이브러리의 구현이 변경되는 일은 실제로도 빈번하게 발생하는 문제이기도 하다.
* 이러한 문제 역시 컴포지션을 통해 방지할 수 있으며, 다형성이 깨질 것이 우려되는 경우에는 인터페이스의 구현과 컴포지션을 혼용해볼 수 있다.
  * 이 경우, 인터페이스를 구현하는 클래스에 포함되는 대부분의 메소드는 컴포지션된 객체를 호출하는 포워딩 메소드 형태의 동작을 갖게 된다.
  * **이러한 방식은 일견 포워딩 메소드를 양산하는 것처럼 보여질 수 있으나, 코틀린은 컴파일 시점에 포워딩 메소드를 자동으로 생성하는 위임 문법을 제공**한다.
* 즉, 다형성이 필요하지만 상속된 메소드를 직접 호출하는 것이 위험하다면 위임 패턴을 적용할 수 있다.
  * 그러나 이러한 요구사항에 있어 다형성이 필수적인 상황은 자주 발생하지 않으므로, 컴포지션만으로 문제가 해결되는 경우가 많다.
  * 이렇듯 **컴포지션을 사용한 코드는 가독성과 유연성이 높고, 재사용성 역시 높은 특징**을 갖는다.

### 오버라이딩을 제한하기
* 개발자가 상속은 허용하지만 메소드를 재정의할 수 없도록 만들고자 하는 경우, 다음과 같은 방식으로 요구사항을 충족시킬 수 있다.
  1. 상속을 가능하게 만들 클래스에 open 키워드를 명시한다.
  2. 재정의 가능하도록 만들고자 하는 메소드에만 open 메소드를 명시한다.
* 또한, 이렇게 **클래스를 상속받아 open 메소드를 재정의하는 경우 해당 메소드에 final 키워드를 명시하는 식으로 재정의 메소드를 제한하는 것이 가능**하다.

### 상속과 컴포지션의 장단점
* 일반적으로 컴포지션은 상속에 비해:
  1. 더 안전하다: 다른 클래스의 내부 구현에 의존하지 않고, 외부에서 관찰되는 동작에만 의존하기 때문이다.
  2. 더 유연하다: 컴포지션은 여러 클래스를 대상으로 할 수 있으며, 필요한 요소만을 활용할 수 있다.
* 그러나 다음과 같은 고려사항 역시 존재한다.
  1. 더 명시적이다: 컴포지션은 상속과 달리 리시버 객체를 명시해야하므로, 코드가 더 장황해지기 쉬우나 어디에서 온 메소드인지는 명확하다.
  2. 생각보다 번거롭다: 컴포지션은 이를 위한 객체를 반드시 명시해야하므로, 대상 클래스에 기능이 추가되는 식의 상황에서 상속과 비교했을 때 수정이 더 잦다.
  3. 상속은 다형성을 사용할 수 있다: 상속 관계는 매우 강력한 반면, 코드에 is - a 관계를 준수하도록 제약을 건다는 특징을 갖는다.
* **일반적으로 객체 지향 프로그래밍에서는 상속보다 컴포지션을 활용하는 것이 바람직하다, 명화한 is - a 관게에서는 상속을 적용하는 것이 권장**된다.
  * 나아가 **상속을 활용할 경우, 상속을 위해 설계되지 않은 메소드에는 final 키워드를 명시하는 것이 바람직**하다.

## 2023-04-26 Wed
### 데이터 집합을 위한 표현에는 data 한정자를 활용하기
* 여러 데이터를 한 번에 전달해야하는 경우, 클래스 이름 앞에 data 한정자를 명시할 수 있다.
* 또한, 이러한 data 클래스에는 다음과 같은 함수가 자동으로 생성된다.
  1. toString
  2. equals와 hashCode
  3. copy
  4. componentN
* 이 때, **copy 메소드를 객체를 얕은 복사하지만 객체가 불변하다면 애초에 깊은 복사한 객체가 필요 없으므로 상관이 없다**.
* componentN 메소드는 위치를 기반으로 객체를 해제하도록 하며, 해제 과정에서 변수의 이름을 마음대로 지정할 수 있다는 편리함이 있다.
  * 그러나 순서를 혼동할 경우 객체를 잘못 해제할 가능성이 있으므로, IDE의 지원을 받을 수 있도록 해제한 변수의 이름은 원본 프로퍼티와 맞추는 것이 권장된다.

### 튜플 대신 데이터 클래스를 사용하기
```
> 코틀린에서 클래스는 큰 비용 없이 사용할 수 있는 좋은 도구이므로, 클래스를 활용하는 데에 두려움을 갖지 말고 적극적으로 활용할 수 있어야 한다.
```
* 데이터 클래스는 튜플보다 많은 것을 제공하며, 코틀린의 경우 Pair와 Triple이라는 이름의 튜플만이 남아 있다.
  * 이는 튜플이 데이터 클래스와 같은 역할을 하지만, 훨씬 가독성이 떨어지는 등 데이터 클래스로 대체되기 쉽기 때문이다.
* 이렇듯 일반적으로 튜플이 하는 역할은 데이터 클래스로 모두 대체가 가능하며, 이로 인한 추가 비용도 거의 들지 않으므로 튜플을 지양하는 것이 바람직하다.

### 연산 또는 행위를 전달할 때에는 인터페이스 대신 함수 타입을 사용하기
```
> 인터페이스를 사용해야만 하는 특별한 이유가 없는 경우, 코틀린 진영에서 이미 널리 사용되고 있는 함수 타입을 활용하는 것이 바람직하다.
```
* 대부분의 프로그래밍 언어에는 함수 타입이 존재하지 않으며, 대신 연산 또는 액션을 나타내는 하나의 메소드만을 갖는 인터페이스를 전달한다.
  * 이 때, 이러한 인터페이스를 Single Abstract Method라는 용어로 지칭한다.
  * 즉, SAM을 인자로 전달 받는 함수는 이러한 인터페이스를 구현한 객체를 전달 받는다는 의미를 갖는다.
* 함수나 메소드 등이 SAM을 인자로 전달받는 대신 함수 타입을 사용하도록 수정할 경우, 코드 상 더 많은 자유와 IDE의 지원을 얻을 수 있게 된다.
  1. 매개 변수에 람다 표현식을 전달할 수 있다.
  2. 또는 매개 변수에 익명 함수를 전달할 수 있다.
  3. 또는 매개 변수에 함수 레퍼런스를 전달할 수 있다.
  4. 또는 매개 변수에 선언된 함수 타입을 구현한 객체로 전달할 수 있다.
* SAM은 인자에 이름을 붙일 수 있다는 장점을 내세울 수 있으나, 이 역시 코틀린의 `typealias` 기능을 활용하는 것으로 대체가 가능하다.

### SAM을 사용해야만 하는 경우
* Java에서는 인터페이스가 더 명확하므로, 코틀린이 아닌 다른 언어에서 사용할 클래스를 설계하는 경우에는 SAM을 사용하는 것이 바람직하다.
  * 결국, **Java에서 사용할 API를 설계하는 경우가 아니라면 함수 타입을 사용하는 것이 합리적**이다.
* 반면, Java에서 코틀린의 함수 타입을 사용하는 경우 Unit을 명시적으로 반환하는 함수가 필요할 수도 있다.

## 2023-04-27 Thu
### 태그 클래스보다는 클래스 계층을 활용하기
```
> 코틀린에서는 태그 클래스보다 타입 계층을 활용하는 것이 바람직하다.
> 또한, 일반적으로 타입 계층은 sealed 클래스로 정의되곤 한다.
```
* 클래스는 종종 상수로 결정되는 모드를 가질 수 있으며, 이러한 상수 모드 자체를 태그라는 용어로 지칭한다.
* 그러나 이러한 상수 모드 방식은 다음과 같은 단점을 갖는다.
  1. 하나의 클래스에서 각각의 모드를 처리하기 위한 보일러플레이트 코드가 추가된다.
  2. 여러 목적에 대응할 수 있기 위해 프로퍼티는 일관성 없게 사용되며, 더 많은 프로퍼티가 필요해질 수 있다.
  3. 팩토리 메소드를 사용해야하는 경우가 많으며, 객체가 제대로 생성되었는지 확인하는 것 자체가 어려울 수 있다.
* **코틀린에서는 태그 클래스보다 sealed 클래스를 사용하는 것이 권장되며, 이는 각 모드를 여러 클래스로 분할하여 다형성을 활용**하도록 한다.
  * sealed 한정자는 서브클래스 정의를 제한하며, 책임을 분산시키므로 훨씬 깔끔한 구현이 가능하다.

### sealed 한정자란?
* sealed 한정자는 외부 파일이 클래스를 확장하는 모든 행위를 제한하며, 타입이 추가되지 않음을 보장하기 위해 사용한다.
  * 때문에 when 문법을 사용하더라도 else 브랜치를 작성할 필요가 없으며, 새로운 기능을 쉽게 추가하면서도 when 문법을 통해 이를 쉽게 처리할 수 있다.
  * 반면, sealed 클래스의 대안으로 사용되는 추상 클래스를 사용할 경우 프로젝트 외부에서 추가되는 서브클래스의 처리를 항상 대응할 수는 없다.
* sealed 한정자와 when 문법을 조합한 모드의 구분은 굉장히 편리하며, 이를 통해 각 서브클래스에 구현될 처리를 하나의 확장 함수에 정의할 수 있게 된다.
* 이렇듯 **sealed 한정자는 확장 함수를 사용하여 클래스에 새로운 함수를 추가하거나, 클래스의 다양한 변경 사항을 쉽게 처리할 수 있도록 지원**한다.
  * 반면 추상 클래스는 서브클래스가 추가될 수 있는 여지를 남기므로, 계층 구조를 제어하기 위해서라도 sealed 한정자를 사용하는 것이 권장된다.
  * 대신, 추상 클래스는 상속과 관련된 계층 구조의 설계에 사용될 수 있다.

### 태그 클래스와 상태 패턴의 구분
* 상태 패턴은 객체 내부의 상태가 변화할 때 행위 역시 함께 변하는 디자인 패턴으로, 태그 클래스와는 명확히 구분되어야 한다.
  * 상태는 태그 클래스와 비교하여 더 많은 책임을 갖는 큰 클래스이며, 런타임에서 변경이 가능해야 한다.
* 일반적으로 **구체 상태는 객체를 활용하여 표현하며, 태그 클래스보다는 sealed 클래스를 활용한 계층을 정의하는 것이 권장**된다.
  * 또한 이는 불변 객체로 만들어지며, 객체의 상태는 가변 프로퍼티로 정의하여 이를 다른 객체로 하여금 관찰시키는 식으로 행위의 변경을 전파할 수 있다.
* **타입 계층 역시 상태 패턴과는 다르며, 두 개념은 실질적으로 혼용되는 협력 관계**로 볼 수 있다.
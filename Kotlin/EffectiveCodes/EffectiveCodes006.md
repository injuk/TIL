# EffectiveCodes
## 2023-04-25 Tue
### 코틀린의 클래스 설계
* 클래스는 OOP에서 중요한 추상화 수단이듯, 코틀린에서도 중요한 개념일 수 밖에 없다.
* 또한, 코틀린은 개발에 도움이 되는 데이터 클래스나 함수 타입 등 여러 개념을 지원하므로 이를 용도에 맞게 사용하는 것이 매우 중요하다.
  * 이러한 규약을 위배할 경우 치명적인 문제가 발생할 수 있으나, 반대로 규약을 잘 준수한다면 안전하고 가독성 높은 코드를 만들어낼 수 있다.

### 상속보다는 컴포지션을 활용하기
```
> 상속은 is - a 관계를 정의하기 위한 매우 강력한 기능이지만, 명확하지 않은 관계에서는 오히려 많은 문제를 일으킬 수 있다.
```
* 단순한 코드 추출 및 중복 제거를 위해 상속을 적용하는 것은 바람직하지 않으며, 이러한 경우에는 일반적으로 컴포지션을 사용하는 것이 바람직하다.
* 단순한 코드의 추출만을 겨냥한 상속 계층도의 정의는 크게 다음과 같은 단점을 갖는다.
  1. 상속은 하나의 클래스만을 대상으로 하므로, 행위를 계속해서 추출할수록 많은 함수를 갖는 클래스를 정의하면서도 계층 구조는 깊어진다.
  2. 때문에 상속을 기반으로 할 경우 불필요한 함수를 너무 많이 갖는 클래스가 정의되므로 인터페이스 분리 원칙을 위반하기 쉽다.
  3. 이러한 종류의 상속은 일반적으로 이해하기 어려운 코드를 낳는다.
* **상속의 대표적인 대안은 컴포지션이며, 이는 객체를 프로퍼티로 가져 함수를 호출하는 형태로 재사용하는 것을 의미**한다.
  * 컴포지션은 대부분의 경우에 코드의 실행을 상속보다 명확하게 예측할 수 있는 특징을 갖는다.

### 모든 것을 물려 받는 상속의 단점
* 상속을 활용할 경우 서브클래스는 슈퍼클래스의 메소드나 제약 등을 모두 가져오게 되며, 이는 객체의 계층 구조를 표현할 때 큰 장점으로 작용한다.
    * 반면, **이러한 특징으로 인해 슈퍼클래스의 일부만을 재사용하기 위한 목적으로는 적합할 수 없다**.
* 또한, 단순한 코드 재사용만을 목적으로 한 상속은 ISP와 LSP를 위반할 가능성이 높다.

### 캡슐화를 위배하는 상속의 단점
* 상속을 활용할 경우 내부적인 구현 변경에 의해 클래스의 캡슐화가 깨질 가능성을 배제할 수 없다.
  * 또한, 라이브러리의 구현이 변경되는 일은 실제로도 빈번하게 발생하는 문제이기도 하다.
* 이러한 문제 역시 컴포지션을 통해 방지할 수 있으며, 다형성이 깨질 것이 우려되는 경우에는 인터페이스의 구현과 컴포지션을 혼용해볼 수 있다.
  * 이 경우, 인터페이스를 구현하는 클래스에 포함되는 대부분의 메소드는 컴포지션된 객체를 호출하는 포워딩 메소드 형태의 동작을 갖게 된다.
  * **이러한 방식은 일견 포워딩 메소드를 양산하는 것처럼 보여질 수 있으나, 코틀린은 컴파일 시점에 포워딩 메소드를 자동으로 생성하는 위임 문법을 제공**한다.
* 즉, 다형성이 필요하지만 상속된 메소드를 직접 호출하는 것이 위험하다면 위임 패턴을 적용할 수 있다.
  * 그러나 이러한 요구사항에 있어 다형성이 필수적인 상황은 자주 발생하지 않으므로, 컴포지션만으로 문제가 해결되는 경우가 많다.
  * 이렇듯 **컴포지션을 사용한 코드는 가독성과 유연성이 높고, 재사용성 역시 높은 특징**을 갖는다.

### 오버라이딩을 제한하기
* 개발자가 상속은 허용하지만 메소드를 재정의할 수 없도록 만들고자 하는 경우, 다음과 같은 방식으로 요구사항을 충족시킬 수 있다.
  1. 상속을 가능하게 만들 클래스에 open 키워드를 명시한다.
  2. 재정의 가능하도록 만들고자 하는 메소드에만 open 메소드를 명시한다.
* 또한, 이렇게 **클래스를 상속받아 open 메소드를 재정의하는 경우 해당 메소드에 final 키워드를 명시하는 식으로 재정의 메소드를 제한하는 것이 가능**하다.

### 상속과 컴포지션의 장단점
* 일반적으로 컴포지션은 상속에 비해:
  1. 더 안전하다: 다른 클래스의 내부 구현에 의존하지 않고, 외부에서 관찰되는 동작에만 의존하기 때문이다.
  2. 더 유연하다: 컴포지션은 여러 클래스를 대상으로 할 수 있으며, 필요한 요소만을 활용할 수 있다.
* 그러나 다음과 같은 고려사항 역시 존재한다.
  1. 더 명시적이다: 컴포지션은 상속과 달리 리시버 객체를 명시해야하므로, 코드가 더 장황해지기 쉬우나 어디에서 온 메소드인지는 명확하다.
  2. 생각보다 번거롭다: 컴포지션은 이를 위한 객체를 반드시 명시해야하므로, 대상 클래스에 기능이 추가되는 식의 상황에서 상속과 비교했을 때 수정이 더 잦다.
  3. 상속은 다형성을 사용할 수 있다: 상속 관계는 매우 강력한 반면, 코드에 is - a 관계를 준수하도록 제약을 건다는 특징을 갖는다.
* **일반적으로 객체 지향 프로그래밍에서는 상속보다 컴포지션을 활용하는 것이 바람직하다, 명화한 is - a 관게에서는 상속을 적용하는 것이 권장**된다.
  * 나아가 **상속을 활용할 경우, 상속을 위해 설계되지 않은 메소드에는 final 키워드를 명시하는 것이 바람직**하다.

## 2023-04-26 Wed
### 데이터 집합을 위한 표현에는 data 한정자를 활용하기
* 여러 데이터를 한 번에 전달해야하는 경우, 클래스 이름 앞에 data 한정자를 명시할 수 있다.
* 또한, 이러한 data 클래스에는 다음과 같은 함수가 자동으로 생성된다.
  1. toString
  2. equals와 hashCode
  3. copy
  4. componentN
* 이 때, **copy 메소드를 객체를 얕은 복사하지만 객체가 불변하다면 애초에 깊은 복사한 객체가 필요 없으므로 상관이 없다**.
* componentN 메소드는 위치를 기반으로 객체를 해제하도록 하며, 해제 과정에서 변수의 이름을 마음대로 지정할 수 있다는 편리함이 있다.
  * 그러나 순서를 혼동할 경우 객체를 잘못 해제할 가능성이 있으므로, IDE의 지원을 받을 수 있도록 해제한 변수의 이름은 원본 프로퍼티와 맞추는 것이 권장된다.

### 튜플 대신 데이터 클래스를 사용하기
```
> 코틀린에서 클래스는 큰 비용 없이 사용할 수 있는 좋은 도구이므로, 클래스를 활용하는 데에 두려움을 갖지 말고 적극적으로 활용할 수 있어야 한다.
```
* 데이터 클래스는 튜플보다 많은 것을 제공하며, 코틀린의 경우 Pair와 Triple이라는 이름의 튜플만이 남아 있다.
  * 이는 튜플이 데이터 클래스와 같은 역할을 하지만, 훨씬 가독성이 떨어지는 등 데이터 클래스로 대체되기 쉽기 때문이다.
* 이렇듯 일반적으로 튜플이 하는 역할은 데이터 클래스로 모두 대체가 가능하며, 이로 인한 추가 비용도 거의 들지 않으므로 튜플을 지양하는 것이 바람직하다.

### 연산 또는 행위를 전달할 때에는 인터페이스 대신 함수 타입을 사용하기
```
> 인터페이스를 사용해야만 하는 특별한 이유가 없는 경우, 코틀린 진영에서 이미 널리 사용되고 있는 함수 타입을 활용하는 것이 바람직하다.
```
* 대부분의 프로그래밍 언어에는 함수 타입이 존재하지 않으며, 대신 연산 또는 액션을 나타내는 하나의 메소드만을 갖는 인터페이스를 전달한다.
  * 이 때, 이러한 인터페이스를 Single Abstract Method라는 용어로 지칭한다.
  * 즉, SAM을 인자로 전달 받는 함수는 이러한 인터페이스를 구현한 객체를 전달 받는다는 의미를 갖는다.
* 함수나 메소드 등이 SAM을 인자로 전달받는 대신 함수 타입을 사용하도록 수정할 경우, 코드 상 더 많은 자유와 IDE의 지원을 얻을 수 있게 된다.
  1. 매개 변수에 람다 표현식을 전달할 수 있다.
  2. 또는 매개 변수에 익명 함수를 전달할 수 있다.
  3. 또는 매개 변수에 함수 레퍼런스를 전달할 수 있다.
  4. 또는 매개 변수에 선언된 함수 타입을 구현한 객체로 전달할 수 있다.
* SAM은 인자에 이름을 붙일 수 있다는 장점을 내세울 수 있으나, 이 역시 코틀린의 `typealias` 기능을 활용하는 것으로 대체가 가능하다.

### SAM을 사용해야만 하는 경우
* Java에서는 인터페이스가 더 명확하므로, 코틀린이 아닌 다른 언어에서 사용할 클래스를 설계하는 경우에는 SAM을 사용하는 것이 바람직하다.
  * 결국, **Java에서 사용할 API를 설계하는 경우가 아니라면 함수 타입을 사용하는 것이 합리적**이다.
* 반면, Java에서 코틀린의 함수 타입을 사용하는 경우 Unit을 명시적으로 반환하는 함수가 필요할 수도 있다.

## 2023-04-27 Thu
### 태그 클래스보다는 클래스 계층을 활용하기
```
> 코틀린에서는 태그 클래스보다 타입 계층을 활용하는 것이 바람직하다.
> 또한, 일반적으로 타입 계층은 sealed 클래스로 정의되곤 한다.
```
* 클래스는 종종 상수로 결정되는 모드를 가질 수 있으며, 이러한 상수 모드 자체를 태그라는 용어로 지칭한다.
* 그러나 이러한 상수 모드 방식은 다음과 같은 단점을 갖는다.
  1. 하나의 클래스에서 각각의 모드를 처리하기 위한 보일러플레이트 코드가 추가된다.
  2. 여러 목적에 대응할 수 있기 위해 프로퍼티는 일관성 없게 사용되며, 더 많은 프로퍼티가 필요해질 수 있다.
  3. 팩토리 메소드를 사용해야하는 경우가 많으며, 객체가 제대로 생성되었는지 확인하는 것 자체가 어려울 수 있다.
* **코틀린에서는 태그 클래스보다 sealed 클래스를 사용하는 것이 권장되며, 이는 각 모드를 여러 클래스로 분할하여 다형성을 활용**하도록 한다.
  * sealed 한정자는 서브클래스 정의를 제한하며, 책임을 분산시키므로 훨씬 깔끔한 구현이 가능하다.

### sealed 한정자란?
* sealed 한정자는 외부 파일이 클래스를 확장하는 모든 행위를 제한하며, 타입이 추가되지 않음을 보장하기 위해 사용한다.
  * 때문에 when 문법을 사용하더라도 else 브랜치를 작성할 필요가 없으며, 새로운 기능을 쉽게 추가하면서도 when 문법을 통해 이를 쉽게 처리할 수 있다.
  * 반면, sealed 클래스의 대안으로 사용되는 추상 클래스를 사용할 경우 프로젝트 외부에서 추가되는 서브클래스의 처리를 항상 대응할 수는 없다.
* sealed 한정자와 when 문법을 조합한 모드의 구분은 굉장히 편리하며, 이를 통해 각 서브클래스에 구현될 처리를 하나의 확장 함수에 정의할 수 있게 된다.
* 이렇듯 **sealed 한정자는 확장 함수를 사용하여 클래스에 새로운 함수를 추가하거나, 클래스의 다양한 변경 사항을 쉽게 처리할 수 있도록 지원**한다.
  * 반면 추상 클래스는 서브클래스가 추가될 수 있는 여지를 남기므로, 계층 구조를 제어하기 위해서라도 sealed 한정자를 사용하는 것이 권장된다.
  * 대신, 추상 클래스는 상속과 관련된 계층 구조의 설계에 사용될 수 있다.

### 태그 클래스와 상태 패턴의 구분
* 상태 패턴은 객체 내부의 상태가 변화할 때 행위 역시 함께 변하는 디자인 패턴으로, 태그 클래스와는 명확히 구분되어야 한다.
  * 상태는 태그 클래스와 비교하여 더 많은 책임을 갖는 큰 클래스이며, 런타임에서 변경이 가능해야 한다.
* 일반적으로 **구체 상태는 객체를 활용하여 표현하며, 태그 클래스보다는 sealed 클래스를 활용한 계층을 정의하는 것이 권장**된다.
  * 또한 이는 불변 객체로 만들어지며, 객체의 상태는 가변 프로퍼티로 정의하여 이를 다른 객체로 하여금 관찰시키는 식으로 행위의 변경을 전파할 수 있다.
* **타입 계층 역시 상태 패턴과는 다르며, 두 개념은 실질적으로 혼용되는 협력 관계**로 볼 수 있다.

## 2023-04-28 Fri
### Any가 갖는 규약
* 코틀린의 Any 타입은 잘 정의된 규약을 준수하는 다음의 메소드들을 갖는다.
  1. equals
  2. hashCode
  3. toString
* 이는 Java 때부터 정의되는 메소드이며, 코틀린 역시 이러한 메소드들을 중요시하므로 Any를 상속받는 모든 클래스 역시 해당 규약을 준수하는 것이 바람직하다.

### 동등성과 코틀린의 equals 메소드
* 동등성은 다음과 같은 두 종류로 구분할 수 있다.
  1. 구조적 동등성: equals 메소드와 이를 기반으로 한 `==` 연산자로 확인하는 종류에 해당한다.
  2. 레퍼런스 동등성: `===` 연산자로 확인하는 종류이며, 피연산자가 모두 같은 객체일 경우 true를 반환한다.
* 이 때, 구조적 동등성의 경우 null이 아닌 a에 대해 `a == b`는 a.equals(b)로 변환된다.
  * 또한, equals 메소드가 아닌 연산자를 활용한 다른 타입의 객체 비교는 허용되지 않는다.
* **Any에 구현된 equals 메소드는 기본적으로 `===`와 같이 레퍼런스 동등성을 비교하며, 이는 곧 모든 객체가 기본적으로 유일함을 의미**한다.
* 그러나 객체가 갖는 속성이 같다면 동일한 객체로 봐야할 수 있으며, 코틀린은 data 한정자를 명시한 클래스에 대해 자동으로 이러한 동등성 비교를 적용한다.
  * 데이터 클래스는 내부에 어떤 값이 포함되는지가 중요하므로, 이러한 동작이 매우 중요하다.
* 이러한 데이터 클래스의 동등성은 모든 프로퍼티가 아닌 일부 프로퍼티만을 비교해야 하는 경우에도 유용하게 사용될 수 있다.
  * 그러나 이렇듯 일부 프로퍼티를 비교 대상으로 삼지 않는 데이터 클래스의 경우, 기본 생성자에 선언되지 않은 프로퍼티는 copy 메소드로 복사하지 않는다.
* 이렇듯 코틀린은 data 한정자를 기반으로 equals 메소드를 자동으로 구현하므로, 일반적으로는 개발자가 직접 equals 메소드를 정의할 필요가 없다.
* 반면, 다음과 같은 상황에서는 equals 메소드를 직접 구현해주어야 한다.
  1. 기본적으로 제공되는 equals 동작과 다른 동작이 필요한 경우
  2. 또는 일부 프로퍼티만으로 비교할 필요가 있는 경우
  3. 또는 **data 한정자를 명시할 수 없거나, 비교 대상 프로퍼티가 기본 생성자에 포함되지 않는 경우**

### equals 메소드가 갖는 규약
```
> 동등성은 네트워크 상태와 같은 외부적 요인에 의존하지 않아야 한다.
```
* 코틀린의 equals 메소드는 다음과 같은 주석을 가지며, 임의의 객체가 다른 객체와의 동등성을 갖기 위해 반드시 다음과 같은 항목을 충족시켜야 함을 강조한다.
  1. 반사적 동작: x가 null이 아니라면, x.equals(x)는 항상 true이다.
  2. 대칭적 동작: x와 y가 null이 아니라면, x.equals(y)는 y.equals(x)와 동일한 결과를 반환한다.
  3. 연속적 동작: x와 y와 z가 null이 아니라면, x.equals(y)와 y.equals(z)가 true일 때 x.equals(z)도 true이다.
  4. 일관적 동작: x와 y가 null이 아니라면, 프로퍼티의 변경이 없다고 가정할 때 x.equals(y)는 여러 번 실행하더라도 항상 동일한 결과를 반환한다.
  5. null 관련 동작: x가 null이 아니라면, **null은 유일한 객체**이므로 x.equals(null)은 항상 false이다.
* 특히 대칭적 동작은 일반적으로 모든 사람이 기대하는 동작이며, 이를 위배했을 떄의 디버깅 난이도는 매우 높은 축에 속하므로 주의해야 한다.
  * 때문에 **해당 항목을 잘 준수하기 위해서는 Any 이외의 공통 조상을 갖지 않는 두 타입은 동등하지 않게 만드는 것이 바람직**하다.
* 나아가 동등성은 반드시 일관성을 가져야 하며, 두 객체를 비교한 결과는 객체를 수정하지 않는 이상 항상 같은 결과를 반환해야 한다.
  * 때문에 **불변 객체에 대한 동등성 비교는 항상 같은 결과를 반환해야 하며, equals는 반드시 비교 대상인 두 객체에만 의존하는 순수 함수**여야 한다.
* 또한, **equals사 hashCode 및 toString 메소드의 동작은 매우 빠를 것이 기대되므로 항상 빠르게 동작**해야 한다.

### equals 메소드를 직접 구현하기?
```
> 상속을 지원하면서도 완벽한 사용자 정의 equals 메소드를 정의하는 것은 불가능에 가깝다.
```
* 정말로 특별한 이유가 없다면 equals 메소드는 직접 구현할 필요가 없으며, 기본적으로 제공되는 메소드나 data 한정자를 활용하는 것이 바람직하다.
* 그러나 **직접 구현해야만 할 필요가 있다면, 반드시 상술한 항목을 모두 준수하되 데이터 클래스가 그렇듯 final 클래스로 정의**해야 한다.
  * 반면, **상속이 필요한 경우에는 서브클래스에서 equals 메소드의 동작 방식을 변경하지 않도록 제약**해야 한다.

## 2023-04-29 Sat
### hashCode 메소드가 갖는 규약
* hashCode 메소드는 여러 컬렉션에 사용되는 해시 테이블 구축을 위해 사용되며, 기본적으로 Any 메소드에 정의된다.
  * 이러한 해시 테이블은 컴퓨터 과학에서 자주 사용되며, 코틀린은 해시 코드의 생성을 위해 hashCode 함수를 사용한다.
  * 이 때, 해시와 같은 자료 구조에서는 키로 가변 객체를 사용하지 않거나 사용하더라도 변경하지 않도록 주의를 기울여야 한다.
* 코틀린의 hashCode 메소드는 다음과 같은 규약을 가지며, 개발자가 직접 해당 메소드를 구현하는 경우에도 이를 반드시 준수해야 한다.
  1. 어떠한 객체를 변경하지 않았다면, hashCode 메소드를 몇 번 호출하더라도 결과는 같아야 한다.
  2. equals 메소드를 통해 같다고 판정된 두 객체는 hashCode 메소드의 결과도 같아야 한다.
* 이렇듯 hashCode 는 equals 메소드와 긴밀한 연관을 가진 상태에서 일관된 결과를 내놓아야 하며, 같은 요소는 반드시 같은 해시 코드를 가져야 한다.
* 또한, **상술한 규약에 더해 최대한 요소를 넓게 퍼트리는 형태의 hashCode 메소드의 구현이 권장**된다.
  * 즉, 서로 다른 요소라면 최대한 다른 해시 코드를 가져 같은 버킷에 배치되지 않도록 해야 한다.

### hashCode 메소드를 직접 구현하기?
```
> hashCode 메소드를 직접 구현하기로 결정했다면, equals 메소드와 일관된 결과를 반환해야 한다.
```
* 코틀린의 경우 데이터 클래스는 자동으로 적절한 equals와 hashCode 메소드를 정의하므로, 일반적으로 hashCode 메소드 역시 직접 구현할 필요는 없다.
* 그러나 equals 메소드를 재정의하기로 결정했다면 반드시 hashCode 메소드도 함께 재정의해주어야 한다.
  * 다시 말해, equals 메소드를 재정의할 필요 없다면 일반적으로 hashCode 메소드 역시 재정의할 필요가 없다.
* **hashCode 메소드는 기본적으로 equals 메소드에서 비교에 사용하는 프로퍼티를 기반으로 한 해시 코드를 생성**해야 한다.
* 또한, 해시 코드를 구하는 로직은 일반적으로 다음과 같다.
  1. equals 메소드에 의해 비교되는 프로퍼티 목록을 확인한다.
  2. 임의의 프로퍼티에 대해 hashCode 메소드를 호출하여 해시 코드를 구한 후, 결과로 반화될 가변 변수에 할당한다.
  3. 2.의 결과가 할당된 변수에 관례적인 리터럴 값인 31을 곱한 후, 다음 프로퍼티의 해시 코드를 더한다.
  4. 모든 프로퍼티에 대해 2.와 3.의 과정을 반복한 후, 결과를 반환한다.
* 이러한 과정을 손쉽게 구현하기 위해 코틀린/JVM 플랫폼의 `Objects.hashCode()` 메소드를 활용할 수 있는 반면, 다른 플랫폼은 이를 직접 구현해야 한다.
  * **코틀린의 stdlib 역시 이를 기본적으로 제공하지 않으며, 그 이유는 사실상 hashCode 메소드를 개발자가 직접 구현할 일이 거의 없기 때문**이다.

### compareTo 메소드가 갖는 규약
* 앞선 메소드들과 달리 compareTo 메소드는 Any 클래스에 정의된 메소드가 아니며, 대신 `<`나 `>`와 같은 부등식으로 변환되어 사용되는 연산자에 해당한다.
* 또한, compareTo 메소드는 Comparable<T> 인터페이스에도 정의되어 있다.
  * 때문에 **객체가 해당 인터페이스를 구현하거나, compareTo 메소드를 갖는다면 해당 객체는 동일한 타입 간에 비교 가능한 순서를 갖는 다는 것**과 같다.
* 이 때, compareTo 메소드는 반드시 다음과 같은 항목을 충족시켜야 한다.
  1. 비대칭적 동작: a>=b 이고 b>=a라면 a==b이다.
  2. 연속적 동작: a>=b 이고 b>=c라면 a>=c이다.
  3. 코넥스적 동작: **두 요소는 반드시 어떠한 관계를 가져야 하며, 예를 들어 a>=b나 b>=a 중 하나는 반드시 true를 반환**해야 한다.

### compareTo 메소드를 직접 구현하기?
```
> compareTo 메소드는 비교 결과에 따라 0이나 양수 또는 음수를 반환해야 하며, 반드시 비대칭적 동작과 연속적 동작 및 코넥스적 동작을 만족해야 한다. 
```
* 앞선 메소드들과 마찬가지로, 코틀린에서는 compareTo 메소드를 따로 정의해야 하는 상황은 거의 발생하지 않는다.
  * 이는 **대부분의 경우에 sortedBy 메소드와 같이 요소가 갖는 어떠한 프로퍼티 하나를 기반으로 순서를 지정하는 것으로 충분하기 때문**이다.
  * 반면, 둘 이상의 프로퍼티를 기반으로 정렬해야하는 경우에는 sortedWith와 compareBy 메소드를 활용할 수 있다.
* 물론 임의의 클래스에 대해 Comparable<T>를 구현하는 형태를 적용할 수도 있으며, 이 경우에는 특정 프로퍼티를 기반으로 비교하도록 구현한다.
  * 바꿔 말해, 비교에 대한 절대적인 기준이 존재하지 않는다면 아예 비교하지 못하도록 만들 수도 있다.
* 예를 들어 **날짜나 시간과 같이 자연스러운 순서를 갖는 객체들이 있으나, 어떤 객체의 순서가 자연스러운지 확실치 않다면 Comparator를 정의**할 수 있다.
  * 나아가 이러한 **Comparator, 즉 비교기를 자주 사용한다면 해당 클래스의 companion 객체로 정의하는 것이 바람직**하다.
* 반드시 compareTo 메소드를 직접 정의해야하는 상황이라면, 다음과 같은 톱레벨 함수를 유용하게 사용할 수 있다.
  1. compareValues: **두 값을 단순하게 비교하는 경우에 유용하게 사용**될 수 있다.
  2. compareValuesBy: **둘 이상의 값을 비교하거나, selector를 활용하여 비교하고자하는 경우에 유용하게 사용**될 수 있다.
* 특히 compareValuesBy 함수는 비교기(=Comparator)를 정의할 때 도움이 될 수 있다.
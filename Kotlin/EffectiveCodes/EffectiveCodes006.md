# EffectiveCodes
## 2023-04-25 Tue
### 코틀린의 클래스 설계
* 클래스는 OOP에서 중요한 추상화 수단이듯, 코틀린에서도 중요한 개념일 수 밖에 없다.
* 또한, 코틀린은 개발에 도움이 되는 데이터 클래스나 함수 타입 등 여러 개념을 지원하므로 이를 용도에 맞게 사용하는 것이 매우 중요하다.
  * 이러한 규약을 위배할 경우 치명적인 문제가 발생할 수 있으나, 반대로 규약을 잘 준수한다면 안전하고 가독성 높은 코드를 만들어낼 수 있다.

### 상속보다는 컴포지션을 활용하기
```
> 상속은 is - a 관계를 정의하기 위한 매우 강력한 기능이지만, 명확하지 않은 관계에서는 오히려 많은 문제를 일으킬 수 있다.
```
* 단순한 코드 추출 및 중복 제거를 위해 상속을 적용하는 것은 바람직하지 않으며, 이러한 경우에는 일반적으로 컴포지션을 사용하는 것이 바람직하다.
* 단순한 코드의 추출만을 겨냥한 상속 계층도의 정의는 크게 다음과 같은 단점을 갖는다.
  1. 상속은 하나의 클래스만을 대상으로 하므로, 행위를 계속해서 추출할수록 많은 함수를 갖는 클래스를 정의하면서도 계층 구조는 깊어진다.
  2. 때문에 상속을 기반으로 할 경우 불필요한 함수를 너무 많이 갖는 클래스가 정의되므로 인터페이스 분리 원칙을 위반하기 쉽다.
  3. 이러한 종류의 상속은 일반적으로 이해하기 어려운 코드를 낳는다.
* **상속의 대표적인 대안은 컴포지션이며, 이는 객체를 프로퍼티로 가져 함수를 호출하는 형태로 재사용하는 것을 의미**한다.
  * 컴포지션은 대부분의 경우에 코드의 실행을 상속보다 명확하게 예측할 수 있는 특징을 갖는다.

### 모든 것을 물려 받는 상속의 단점
* 상속을 활용할 경우 서브클래스는 슈퍼클래스의 메소드나 제약 등을 모두 가져오게 되며, 이는 객체의 계층 구조를 표현할 때 큰 장점으로 작용한다.
    * 반면, **이러한 특징으로 인해 슈퍼클래스의 일부만을 재사용하기 위한 목적으로는 적합할 수 없다**.
* 또한, 단순한 코드 재사용만을 목적으로 한 상속은 ISP와 LSP를 위반할 가능성이 높다.

### 캡슐화를 위배하는 상속의 단점
* 상속을 활용할 경우 내부적인 구현 변경에 의해 클래스의 캡슐화가 깨질 가능성을 배제할 수 없다.
  * 또한, 라이브러리의 구현이 변경되는 일은 실제로도 빈번하게 발생하는 문제이기도 하다.
* 이러한 문제 역시 컴포지션을 통해 방지할 수 있으며, 다형성이 깨질 것이 우려되는 경우에는 인터페이스의 구현과 컴포지션을 혼용해볼 수 있다.
  * 이 경우, 인터페이스를 구현하는 클래스에 포함되는 대부분의 메소드는 컴포지션된 객체를 호출하는 포워딩 메소드 형태의 동작을 갖게 된다.
  * **이러한 방식은 일견 포워딩 메소드를 양산하는 것처럼 보여질 수 있으나, 코틀린은 컴파일 시점에 포워딩 메소드를 자동으로 생성하는 위임 문법을 제공**한다.
* 즉, 다형성이 필요하지만 상속된 메소드를 직접 호출하는 것이 위험하다면 위임 패턴을 적용할 수 있다.
  * 그러나 이러한 요구사항에 있어 다형성이 필수적인 상황은 자주 발생하지 않으므로, 컴포지션만으로 문제가 해결되는 경우가 많다.
  * 이렇듯 **컴포지션을 사용한 코드는 가독성과 유연성이 높고, 재사용성 역시 높은 특징**을 갖는다.

### 오버라이딩을 제한하기
* 개발자가 상속은 허용하지만 메소드를 재정의할 수 없도록 만들고자 하는 경우, 다음과 같은 방식으로 요구사항을 충족시킬 수 있다.
  1. 상속을 가능하게 만들 클래스에 open 키워드를 명시한다.
  2. 재정의 가능하도록 만들고자 하는 메소드에만 open 메소드를 명시한다.
* 또한, 이렇게 **클래스를 상속받아 open 메소드를 재정의하는 경우 해당 메소드에 final 키워드를 명시하는 식으로 재정의 메소드를 제한하는 것이 가능**하다.

### 상속과 컴포지션의 장단점
* 일반적으로 컴포지션은 상속에 비해:
  1. 더 안전하다: 다른 클래스의 내부 구현에 의존하지 않고, 외부에서 관찰되는 동작에만 의존하기 때문이다.
  2. 더 유연하다: 컴포지션은 여러 클래스를 대상으로 할 수 있으며, 필요한 요소만을 활용할 수 있다.
* 그러나 다음과 같은 고려사항 역시 존재한다.
  1. 더 명시적이다: 컴포지션은 상속과 달리 리시버 객체를 명시해야하므로, 코드가 더 장황해지기 쉬우나 어디에서 온 메소드인지는 명확하다.
  2. 생각보다 번거롭다: 컴포지션은 이를 위한 객체를 반드시 명시해야하므로, 대상 클래스에 기능이 추가되는 식의 상황에서 상속과 비교했을 때 수정이 더 잦다.
  3. 상속은 다형성을 사용할 수 있다: 상속 관계는 매우 강력한 반면, 코드에 is - a 관계를 준수하도록 제약을 건다는 특징을 갖는다.
* **일반적으로 객체 지향 프로그래밍에서는 상속보다 컴포지션을 활용하는 것이 바람직하다, 명화한 is - a 관게에서는 상속을 적용하는 것이 권장**된다.
  * 나아가 **상속을 활용할 경우, 상속을 위해 설계되지 않은 메소드에는 final 키워드를 명시하는 것이 바람직**하다.
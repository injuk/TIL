# EffectiveCodes
## 2023-05-01 Mon
### 코드 효율성을 바라보는 관점
* 현대에는 메모리 등 하드웨어 자원이 저렴해졌고, 개발자의 몸값은 올랐기에 코드 효율성을 관대하게 바라보곤 한다.
* 그러나 코드의 효율성은 장기적인 관점에서 중요하며, 효율성을 높이는 것으로 장기적으로는 비용을 줄이고 효율을 높일 수 있게 된다.
* 반면, **코드 최적화는 난이도가 높은 축에 속하며 프로젝트의 초기 단계에서부터 도입할 경우 잃는 것이 더 많을 수 있다**.
  * 그럼에도 **거의 잃는 것 없이도 코드의 효율성을 높일 수 있는 고정된 규칙은 존재하며, 이를 토대로 비용 없이 성능을 향상**시킬 수 있다.
* 나아가 가독성과 성능 사이에는 일종의 트레이드 오프 관계가 존재하며, 개발자는 컴포넌트에서 어떤 것이 더 중요한지 스스로 결정할 수 있어야 한다.

### 객체 생성과 비용
* **객체 생성은 언제나 크거나 작은 비용을 포함하므로, 불필요한 객체 생성을 지양하는 것은 최적화 관점에서 언제나 바람직한 일**이다.
  * **객체 생성을 최소화하는 예로, JVM은 한 번 이상 사용되는 동일한 문자열은 재사용하며 Int 역시 -128 ~ 127 범위에서 캐시**해둔다.
* 어떤 객체, 또는 래퍼 객체를 사용할 경우 크게 다음과 같은 비용을 고려할 수 있다.
  1. 원시 타입에 비해 객체 자체가 더 많은 용량을 차지하며, 64비트 JDK의 경우 객체는 최소 16바이트에서 시작하여 8의 배수만큼의 용량을 차지한다.
  2. 요소가 캡슐화되어 있다면 이에 접근하기 위한 추가적인 함수 호출이 필요하며, 함수 처리 자체는 굉장히 빠르지만 누적되기 쉽다.
  3. 객체는 사용을 위해 우선 생성될 필요가 있으므로, 생성과 메모리 영역 할당 및 레퍼런스 생성 등등의 추가 작업을 필요로 한다.
* 상술한 **세 가지 비용은 모두 자체적으로는 굉장히 적은 비용이지만, 크게 누적되기 쉬운 분류에 속한다**.
  * 때문에 객체를 제거할 경우 이러한 비용을 모두 회피할 수 있으며, 최소한 객체를 재사용하는 것으로 첫 번째와 세 번째 비용을 회피할 수 있다.

### 객체의 재사용 - 객체를 선언하기
* 매 순간 새로운 객체를 생성하는 대신 재사용하는 가장 간단한 방법은 object 한정자를 활용하는 객체 선언으로, 이는 싱글톤이라는 용어로도 지칭할 수 있다.
* **빈번히 재사용되는 객체는 싱글톤으로 정의할 수 있으며, 제네릭 타입의 경우 모든 타입의 서브타입인 `Nothing`을 유용하게 활용**할 수 있다.

### 객체의 재사용 - 팩토리에 캐시를 활용하기
* 일반적으로 객체는 생성자를 토대로 생성되지만 팩토리 메소드를 활용하는 경우도 많으며, 이 때 캐시 기능을 도입할 수 있다.
  * 예를 들어, stdlib의 `emptyList()` 메소드는 캐싱을 활용하여 항상 같은 객체를 반환하도록 구현되어 있다.
* 여러 객체를 두어 그 중 하나를 사용하는 경우에는 객체 풀의 정의를 고려할 수 있으며, 쓰레드 풀과 DB 커넥션 풀이 좋은 예시이다.
  * 이러한 **객체 풀 방식은 무거운 객체를 생성히거나, 동시에 여러 개의 mutable 객체를 사용해야 하는 경우에 유용**하다.
* 또한 모든 순수 함수에도 캐싱을 적용할 수 있으며, 이는 메모이제이션이라는 용어로 지칭된다.
* 캐시 방식은 두 번째 객체 접근부터는 좋은 성능을 보이나, 캐싱 기능 자체로 인해 더 많은 메모리를 사용하는 단점 역시 존재한다.
* 때문에 메모리 문제가 발생한다면 이를 해제할 필요가 있으며, 이 경우애는 GC가 자동으로 메모리를 해제하는 `SoftReference`를 사용하는 것이 바람직하다.
  * 이 때, `WeakReference`는 GC가 값을 정리하는 것을 막지 않으므로 다른 레퍼런스가 이를 참조하지 않으면 곧바로 제거한다.
  * 반면, `SoftReference`는 GC가 값을 정리하거나 하지 않을 수 있으며, 일반적인 JVM 구현의 경우 메모리가 부족한 경우에만 정리한다.
* 이렇듯 **캐시 기능의 구현을 위해서는 `SoftReference` 방식이 더 권장되며, 캐시는 언제나 메모리와 성능의 트레이드 오프가 발생**할 수 밖에 없다.
  * 때문에 반드시 상황을 잘 고려하여 캐싱 기능의 도입을 결정하는 것이 바람직하다.

## 2023-05-02 Tue
### 무거운 객체 또는 작업은 외부 스코프로 옮기기
```
> 무거운 객체나 무거운 작업을 외부 스코프로 옮기는 것은 성능 상 매우 유용한 트릭이다.
```
* 에를 들어 컬렉션 처리 과정에서 반복적으로 호출되는 무거운 연산은 컬렉션 처리 함수 내부가 아닌 외부로 빼내는 것이 성능 측면에서 큰 이득을 볼 수 있다.
  * 이러한 원칙은 일견 당연한 것으로 보일 수 있으나, 실제로는 많은 개발자들이 실수하거나 간과하는 부분에 해당한다.
* 또 다른 예로 **정규 표현식 패턴을 활용하는 함수의 경우, 함수 내부의 변수에 정규 표현식을 할당하는 것보다는 최상위로 끌어올리는 것이 바람직**하다.
  * **정규 표현식 패턴을 컴파일하는 과정은 복잡한 연산에 속하므로, 함수를 호출할 때마다 정규 표현식을 할당하는 것은 성능 상 득보다 실**이 더 많다.
* 나아가 **정규 표현식을 활용하는 함수가 다른 함수와 같은 파일에 존재하여 함수 자체가 잘 사용되지 않는다면, 지연 초기화를 적용하는 것이 바람직**하다.
  * 이 경우, 정규 표현식 패턴이 컴파일된다는 것 자체가 낭비이므로 `val REGEX by lazy { "some_regex".toRegex() }`와 같이 정의할 수 있다.
  * 이렇듯 프로퍼티를 지연 초기화하는 것은 무거운 클래스를 사용해야 하는 상황에서 더 유용하다.
* **해당 방식은 성능 자체를 향상시켜줄 수 있을 뿐더러, 적절한 명명을 토대로 가독성까지도 향상시킬 수 있으므로 적극적으로 고려하는 것이 권장**된다.

### 지연 초기화 활용하기
* 무거운 클래스를 생성하는 경우, 지연되게 생성하는 것은 다음과 같은 장점과 단점이 모두 존재한다.
  1. 장점: 내부에서 참조하는 인스턴스들을 지연 초기화하는 것으로 무거운 객체의 생성 자체를 가볍게할 수 있다.
  2. 단점: **클래스가 무거운 인스턴스들을 참조하지만 이를 활용한 메소드 호출은 빨라야 하는 경우에는 적절하지 못하다**.
* 일반적으로 백엔드 애플리케이션은 전체 실행 시간은 크게 중요하지 않으므로, 첫 호출 시 응답 시간에 악영향을 주는 지연 초기화는 적절하지 않을 수 있다.

### 가능한 한 원시 타입을 사용하기
* JVM은 숫자나 문자 등의 기본 요소를 표현하기 위한 기본 내장 자료형을 가지며, 이를 원시 타입이라고 지칭한다.
  * **코틀린과 JVM 컴파일러 역시 내부적으로는 최대한 원시 타입을 활용하는 식으로 동작**한다.
* 그러나 다음과 같은 두 상황에서는 래퍼 클래스가 사용되며, 원시 타입을 사용할 수 없다는 점에 주의해야 한다.
  1. nullable 타입: 원시 타입은 null일 수 없으므로, 래퍼 클래스가 사용된다.
  2. 제네릭 타입 인자: 원시 타입은 제네릭 타입 인자로 사용될 수 없으므로, 래퍼 클래스가 사용된다.
* 상술한 항목을 예로 들어, Int 형 변수는 원시 타입인 `int`를 사용하는 반면 Int?나 List<Int>는 래퍼 클래스인 `Integer`를 사용한다.
* 이를 토대로 **래퍼 클래스 대신 원시 타입을 사용하도록 코드를 최적화할 수 있으나, 일반적으로 이는 숫자에 대한 큰 작업이 반복될 때 의미**를 갖는다.
  * 기본적으로 숫저와 관련된 연산은 어떤 자료형을 사용하더라도 성능적으로 큰 차이를 보이지 않는 경향이 있다.
  * 때문에 **이러한 최적화는 굉장히 큰 컬렉션에 대한 작업을 처리할 때에서야 유효한 성능 차이를 보일 수 있으므로, 성능이 중요할 때에만 적용해도 무방**하다.

### 가능한 한 원시 타입을 사용하기?
* 이러한 최적화는 성능이 극단적으로 중요하지 않은 경우에는 큰 의미가 없는 축에 속하므로, 성능이 중요한 코드 또는 라이브러리 구현에만 적용을 고려해야 한다.
* 때문에 **해당 최적화 기법의 구현에 많은 비용이 들거나, 다른 코드에 많은 영향을 줄 수 있는 상황이라면 최적화를 미루는 선택지도 고려**할 수 있다.
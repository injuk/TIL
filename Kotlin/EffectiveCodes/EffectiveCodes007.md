# EffectiveCodes
## 2023-05-01 Sun
### 코드 효율성을 바라보는 관점
* 현대에는 메모리 등 하드웨어 자원이 저렴해졌고, 개발자의 몸값은 올랐기에 코드 효율성을 관대하게 바라보곤 한다.
* 그러나 코드의 효율성은 장기적인 관점에서 중요하며, 효율성을 높이는 것으로 장기적으로는 비용을 줄이고 효율을 높일 수 있게 된다.
* 반면, **코드 최적화는 난이도가 높은 축에 속하며 프로젝트의 초기 단계에서부터 도입할 경우 잃는 것이 더 많을 수 있다**.
  * 그럼에도 **거의 잃는 것 없이도 코드의 효율성을 높일 수 있는 고정된 규칙은 존재하며, 이를 토대로 비용 없이 성능을 향상**시킬 수 있다.
* 나아가 가독성과 성능 사이에는 일종의 트레이드 오프 관계가 존재하며, 개발자는 컴포넌트에서 어떤 것이 더 중요한지 스스로 결정할 수 있어야 한다.

### 객체 생성과 비용
* **객체 생성은 언제나 크거나 작은 비용을 포함하므로, 불필요한 객체 생성을 지양하는 것은 최적화 관점에서 언제나 바람직한 일**이다.
  * **객체 생성을 최소화하는 예로, JVM은 한 번 이상 사용되는 동일한 문자열은 재사용하며 Int 역시 -128 ~ 127 범위에서 캐시**해둔다.
* 어떤 객체, 또는 래퍼 객체를 사용할 경우 크게 다음과 같은 비용을 고려할 수 있다.
  1. 원시 타입에 비해 객체 자체가 더 많은 용량을 차지하며, 64비트 JDK의 경우 객체는 최소 16바이트에서 시작하여 8의 배수만큼의 용량을 차지한다.
  2. 요소가 캡슐화되어 있다면 이에 접근하기 위한 추가적인 함수 호출이 필요하며, 함수 처리 자체는 굉장히 빠르지만 누적되기 쉽다.
  3. 객체는 사용을 위해 우선 생성될 필요가 있으므로, 생성과 메모리 영역 할당 및 레퍼런스 생성 등등의 추가 작업을 필요로 한다.
* 상술한 **세 가지 비용은 모두 자체적으로는 굉장히 적은 비용이지만, 크게 누적되기 쉬운 분류에 속한다**.
  * 때문에 객체를 제거할 경우 이러한 비용을 모두 회피할 수 있으며, 최소한 객체를 재사용하는 것으로 첫 번째와 세 번째 비용을 회피할 수 있다.

### 객체의 재사용 - 객체를 선언하기
* 매 순간 새로운 객체를 생성하는 대신 재사용하는 가장 간단한 방법은 object 한정자를 활용하는 객체 선언으로, 이는 싱글톤이라는 용어로도 지칭할 수 있다.
* **빈번히 재사용되는 객체는 싱글톤으로 정의할 수 있으며, 제네릭 타입의 경우 모든 타입의 서브타입인 `Nothing`을 유용하게 활용**할 수 있다.

### 객체의 재사용 - 팩토리에 캐시를 활용하기
* 일반적으로 객체는 생성자를 토대로 생성되지만 팩토리 메소드를 활용하는 경우도 많으며, 이 때 캐시 기능을 도입할 수 있다.
  * 예를 들어, stdlib의 `emptyList()` 메소드는 캐싱을 활용하여 항상 같은 객체를 반환하도록 구현되어 있다.
* 여러 객체를 두어 그 중 하나를 사용하는 경우에는 객체 풀의 정의를 고려할 수 있으며, 쓰레드 풀과 DB 커넥션 풀이 좋은 예시이다.
  * 이러한 **객체 풀 방식은 무거운 객체를 생성히거나, 동시에 여러 개의 mutable 객체를 사용해야 하는 경우에 유용**하다.
* 또한 모든 순수 함수에도 캐싱을 적용할 수 있으며, 이는 메모이제이션이라는 용어로 지칭된다.
* 캐시 방식은 두 번째 객체 접근부터는 좋은 성능을 보이나, 캐싱 기능 자체로 인해 더 많은 메모리를 사용하는 단점 역시 존재한다.
* 때문에 메모리 문제가 발생한다면 이를 해제할 필요가 있으며, 이 경우애는 GC가 자동으로 메모리를 해제하는 `SoftReference`를 사용하는 것이 바람직하다.
  * 이 때, `WeakReference`는 GC가 값을 정리하는 것을 막지 않으므로 다른 레퍼런스가 이를 참조하지 않으면 곧바로 제거한다.
  * 반면, `SoftReference`는 GC가 값을 정리하거나 하지 않을 수 있으며, 일반적인 JVM 구현의 경우 메모리가 부족한 경우에만 정리한다.
* 이렇듯 **캐시 기능의 구현을 위해서는 `SoftReference` 방식이 더 권장되며, 캐시는 언제나 메모리와 성능의 트레이드 오프가 발생**할 수 밖에 없다.
  * 때문에 반드시 상황을 잘 고려하여 캐싱 기능의 도입을 결정하는 것이 바람직하다.
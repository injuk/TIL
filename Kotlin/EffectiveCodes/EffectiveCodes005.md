# EffectiveCodes
## 2023-04-21 Fri
### 코틀린으로 객체를 생성하기
* 코틀린은 순수 FP로 애플리케이션을 작성할 수도 있으나, Java와 같이 OOP 스타일로도 얼마든지 작성할 수 있다.
* **OOP는 객체를 생성하여 사용하므로 객체를 생성하는 방법을 정의할 수 있으며, 객체의 방식에 따라 각자 다른 특징**을 갖는다.
  * 그러나 **정적 팩토리 메소드를 권장하는 Java와 달리, 코틀린에서는 정적 메소드를 사용할 수 없으므로 톱레벨 함수와 companion 객체 등을 활용**한다.

### 객체 생성 패턴 - 팩토리 함수의 특징
* **디자인 패턴으로 굉장히 다양한 객체 생성 패턴이 제안되어 있으며, 일반적으로 이러한 패턴은 생성자가 아닌 별도의 함수를 사용**한다.
  * 이 때, 생성자의 역할을 대리하는 함수를 팩토리 함수로 지칭한다.
* 팩토리 함수를 사용할 경우, 다음과 같은 이점을 얻을 수 있다.
  1. 생성자와 달리, 함수에 적절한 이름을 붙여 가독성을 높일 수 있다.
  2. 생성자와 달리 함수가 원하는 형태의 타입을 반환할 수 있으며, 나아가 아직 존재하지 않는 객체까지도 반환할 수도 있다.
  3. 생성자와 달리 호출 시마다 새로운 객체를 생성할 필요가 없으며, 최적화를 위해 캐싱 메커니즘을 적용하거나 싱글톤 패턴을 활용할 수 있다.
  4. **객체 외부에 팩토리 함수를 정의하는 것으로 가시성을 자유로이 제어**할 수 있다.
  5. 생성자로는 생성하기 복잡한 객체도 손쉽게 만들어낼 수 있다.
* 이렇듯 **팩토리 함수는 강력한 객체 생성 방법 중 하나인 반면, 기본 생성자를 완전히 대체하기보다는 오히려 경쟁 관계**에 있다.
  * 또한, 팩토리 함수와 경쟁 관계를 갖는 또 다른 함수들로는 companion 객체의 함수 또는 확장 팩토리 함수와 톱레벨 팩토리 함수 등이 있다.

## 2023-04-22 Sat
### 팩토리 함수에 사용되는 명명의 예시
* Java의 정적 팩토리 함수는 자주 사용되며, 그 용도에 따라 다음과 같은 함수의 이름을 관습적으로 적용해볼 수 있다.
  1. from: **하나의 인자를 전달 받은 후, 전달 받은 인자와 동일한 타입의 인스턴스를 반환**한다.
  2. of: **여러 개의 인자를 전달 받은 후, 이러한 인자들의 정보를 토대로 새로운 인스턴스를 생성하여 반환**한다.
  3. valueOf: from이나 of와 유사한 기능을 수행할 수 있으나, 가독성을 조금이라도 더 높이기 위해 사용되곤 한다.
  4. instance, getInstance: 싱글톤 기반의 인스턴스를 하나 반환하며, 인자가 있다면 이러한 정보를 토대로 적절한 인스턴스를 찾아 반환한다.
  5. createInstance, newInstance: getInstance와 유사하지만, 싱글톤이 적용되지 않는다.
  6. get타입명: getInstance처럼 동작하지만, 팩토리 함수가 다른 클래스에 있을 때 사용할 수 있다.
  7. new타입명: newInstance처럼 동작하지만, 이 역시 팩토리 함수가 다른 클래스에 있을 때 사용할 수 있다.

### companion 객체를 활용한 팩토리 함수
```
> comapnion 객체를 잘 사용하는 곳은 코틀린 커뮤니티에서도 보기 어려우므로, 코틀린 팀 제품의 구현을 토대로 학습하는 것이 바람직하다.
```
* 팩토리 함수를 정의하는 가장 일반적인 방법이며, Java로 따지면 정적 팩토리 함수와 가장 유사한 개념에 해당한다.
  * 또한, 코틀린의 경우 인터페이스에도 이러한 방법을 적용할 수 있다.
* 경험이 적은 **개발자들은 companion 객체를 단순한 정적 멤버처럼 다루곤 하지만, 실제로는 더 많은 기능을 제공할 수 있다는 사실에 주목**해야 한다.
  * 예를 들어, companion 객체는 인터페이스를 구현하거나 클래스를 상속 받을 수 있다.
  * 또한, 추상 companion 객체 팩토리는 값을 가질 수 있으므로 캐싱을 구현하거나 테스트를 위한 fake 객체 등을 반환할 수도 있다.

### 확장 팩토리 함수
```
> 확장 팩토리 함수를 적절히 활용할 경우, 심지어 외부 라이브러리를 확장하는 것 역시 가능해진다.
```
* 해당 방식은 **임의의 클래스에 이미 companion 객체가 존재하고, 이를 수정할 수 없으나 객체의 팩토리 함수를 정의해야하는 경우에 고려**할 수 있다.
* 예를 들어, 인터페이스의 companion 객체를 수정할 수 없다면 `fun Temp.Companion.from(): Temp = //...`과 같이 구현할 수 있다.
  * 이러한 방식은 원본 클래스를 수정하지 않으면서도 완전 다른 파일에 함수를 정의할 수 있다는 이점 역시 존재한다.
  * 반면, **companion 객체를 확장하기 위해서는 반드시 대상 클래스에 적어도 빈 companion 객체가 반드시 정의되어 있어야 한다는 한계 역시 존재**한다.

## 2023-04-23 Sun
### 톱레벨 팩토리 함수
* listOf와 같이 객체를 만드는 방법으로, 그 높은 사용성에 의해 흔히 사용되는 방식이지만 반드시 다음에 주의해야 한다.
  1. public 하게 정의된 톱레벨 함수는 모든 위치에서 사용될 수 있으므로, IDE가 제공하는 팁을 복잡하게 만들 수 있다.
  2. 잘못 명명된 톱레벨 함수의 이름은 여러 혼란을 불러일으킬 수 있으므로, 반드시 적절한 명명에 신중을 기울여야 한다.

### 가짜 생성자
```
> 마칭 생성자처럼 동작하는 가짜 생성자는 톱레벨 함수로 정의되는 것이 바람직하다.
> 가짜 생성자는 기본 생성자를 정의할 수 없거나 생성자가 제공하지 않는 기능을 추가해야하는 경우에만 사용하는 것이 바람직하다. 
```
* 코틀린의 생성자는 톱레벨 함수와 같은 형태로 사용되며, 일반적인 사용자의 관점에서 대문자로 시작하는지의 여부로 일반적인 함수와 구분된다.
* stdlib에 포함된 `List()` 함수는 생성자처럼 보이지만 톱레벨 함수이며, 실제로도 생성자처럼 동작하며 팩토리 함수의 모든 장점을 제공한다.
  * 그러나 이러한 함수는 사용자가 실제로 톱레벨 함수인지 잘 모르므로, 편의상 가짜 생성자라고 지칭된다.
* **가짜 생성자는 크게 인터페이스를 위한 생성자를 정의하거나, reified 타입 인자를 갖도록 하고 싶은 경우에 사용**된다.
* 이 때, **가장 중요한 것은 가짜 생성자 역시 반드시 진짜 생성자처럼 동작해야한다는 점**에 있다.
  * 때문에 캐싱이나 nullable 타입의 반환 등 다른 기능이 필요하다면, companion 객체의 팩토리 메소드와 같은 방식을 사용하는 것이 바람직하다.
* 가짜 생성자는 invoke 연산자를 갖는 companion 객체에 의해서도 정의될 수 있으나, 이는 권장되지 않는 방법에 해당한다.
  * invoke는 호출한다는 의미를 갖기에, 이를 사용하여 객체를 생성하면 의미가 달라지게 되므로 연산자 오버로드 원칙에 위배된다.
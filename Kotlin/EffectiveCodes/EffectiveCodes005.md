# EffectiveCodes
## 2023-04-21 Fri
### 코틀린으로 객체를 생성하기
* 코틀린은 순수 FP로 애플리케이션을 작성할 수도 있으나, Java와 같이 OOP 스타일로도 얼마든지 작성할 수 있다.
* **OOP는 객체를 생성하여 사용하므로 객체를 생성하는 방법을 정의할 수 있으며, 객체의 방식에 따라 각자 다른 특징**을 갖는다.
  * 그러나 **정적 팩토리 메소드를 권장하는 Java와 달리, 코틀린에서는 정적 메소드를 사용할 수 없으므로 톱레벨 함수와 companion 객체 등을 활용**한다.

### 객체 생성 패턴 - 팩토리 함수의 특징
* **디자인 패턴으로 굉장히 다양한 객체 생성 패턴이 제안되어 있으며, 일반적으로 이러한 패턴은 생성자가 아닌 별도의 함수를 사용**한다.
  * 이 때, 생성자의 역할을 대리하는 함수를 팩토리 함수로 지칭한다.
* 팩토리 함수를 사용할 경우, 다음과 같은 이점을 얻을 수 있다.
  1. 생성자와 달리, 함수에 적절한 이름을 붙여 가독성을 높일 수 있다.
  2. 생성자와 달리 함수가 원하는 형태의 타입을 반환할 수 있으며, 나아가 아직 존재하지 않는 객체까지도 반환할 수도 있다.
  3. 생성자와 달리 호출 시마다 새로운 객체를 생성할 필요가 없으며, 최적화를 위해 캐싱 메커니즘을 적용하거나 싱글톤 패턴을 활용할 수 있다.
  4. **객체 외부에 팩토리 함수를 정의하는 것으로 가시성을 자유로이 제어**할 수 있다.
  5. 생성자로는 생성하기 복잡한 객체도 손쉽게 만들어낼 수 있다.
* 이렇듯 **팩토리 함수는 강력한 객체 생성 방법 중 하나인 반면, 기본 생성자를 완전히 대체하기보다는 오히려 경쟁 관계**에 있다.
  * 또한, 팩토리 함수와 경쟁 관계를 갖는 또 다른 함수들로는 companion 객체의 함수 또는 확장 팩토리 함수와 톱레벨 팩토리 함수 등이 있다.

## 2023-04-22 Sat
### 팩토리 함수에 사용되는 명명의 예시
* Java의 정적 팩토리 함수는 자주 사용되며, 그 용도에 따라 다음과 같은 함수의 이름을 관습적으로 적용해볼 수 있다.
  1. from: **하나의 인자를 전달 받은 후, 전달 받은 인자와 동일한 타입의 인스턴스를 반환**한다.
  2. of: **여러 개의 인자를 전달 받은 후, 이러한 인자들의 정보를 토대로 새로운 인스턴스를 생성하여 반환**한다.
  3. valueOf: from이나 of와 유사한 기능을 수행할 수 있으나, 가독성을 조금이라도 더 높이기 위해 사용되곤 한다.
  4. instance, getInstance: 싱글톤 기반의 인스턴스를 하나 반환하며, 인자가 있다면 이러한 정보를 토대로 적절한 인스턴스를 찾아 반환한다.
  5. createInstance, newInstance: getInstance와 유사하지만, 싱글톤이 적용되지 않는다.
  6. get타입명: getInstance처럼 동작하지만, 팩토리 함수가 다른 클래스에 있을 때 사용할 수 있다.
  7. new타입명: newInstance처럼 동작하지만, 이 역시 팩토리 함수가 다른 클래스에 있을 때 사용할 수 있다.

### companion 객체를 활용한 팩토리 함수
```
> comapnion 객체를 잘 사용하는 곳은 코틀린 커뮤니티에서도 보기 어려우므로, 코틀린 팀 제품의 구현을 토대로 학습하는 것이 바람직하다.
```
* 팩토리 함수를 정의하는 가장 일반적인 방법이며, Java로 따지면 정적 팩토리 함수와 가장 유사한 개념에 해당한다.
  * 또한, 코틀린의 경우 인터페이스에도 이러한 방법을 적용할 수 있다.
* 경험이 적은 **개발자들은 companion 객체를 단순한 정적 멤버처럼 다루곤 하지만, 실제로는 더 많은 기능을 제공할 수 있다는 사실에 주목**해야 한다.
  * 예를 들어, companion 객체는 인터페이스를 구현하거나 클래스를 상속 받을 수 있다.
  * 또한, 추상 companion 객체 팩토리는 값을 가질 수 있으므로 캐싱을 구현하거나 테스트를 위한 fake 객체 등을 반환할 수도 있다.

### 확장 팩토리 함수
```
> 확장 팩토리 함수를 적절히 활용할 경우, 심지어 외부 라이브러리를 확장하는 것 역시 가능해진다.
```
* 해당 방식은 **임의의 클래스에 이미 companion 객체가 존재하고, 이를 수정할 수 없으나 객체의 팩토리 함수를 정의해야하는 경우에 고려**할 수 있다.
* 예를 들어, 인터페이스의 companion 객체를 수정할 수 없다면 `fun Temp.Companion.from(): Temp = //...`과 같이 구현할 수 있다.
  * 이러한 방식은 원본 클래스를 수정하지 않으면서도 완전 다른 파일에 함수를 정의할 수 있다는 이점 역시 존재한다.
  * 반면, **companion 객체를 확장하기 위해서는 반드시 대상 클래스에 적어도 빈 companion 객체가 반드시 정의되어 있어야 한다는 한계 역시 존재**한다.

## 2023-04-23 Sun
### 톱레벨 팩토리 함수
* listOf와 같이 객체를 만드는 방법으로, 그 높은 사용성에 의해 흔히 사용되는 방식이지만 반드시 다음에 주의해야 한다.
  1. public 하게 정의된 톱레벨 함수는 모든 위치에서 사용될 수 있으므로, IDE가 제공하는 팁을 복잡하게 만들 수 있다.
  2. 잘못 명명된 톱레벨 함수의 이름은 여러 혼란을 불러일으킬 수 있으므로, 반드시 적절한 명명에 신중을 기울여야 한다.

### 가짜 생성자
```
> 마칭 생성자처럼 동작하는 가짜 생성자는 톱레벨 함수로 정의되는 것이 바람직하다.
> 가짜 생성자는 기본 생성자를 정의할 수 없거나 생성자가 제공하지 않는 기능을 추가해야하는 경우에만 사용하는 것이 바람직하다. 
```
* 코틀린의 생성자는 톱레벨 함수와 같은 형태로 사용되며, 일반적인 사용자의 관점에서 대문자로 시작하는지의 여부로 일반적인 함수와 구분된다.
* stdlib에 포함된 `List()` 함수는 생성자처럼 보이지만 톱레벨 함수이며, 실제로도 생성자처럼 동작하며 팩토리 함수의 모든 장점을 제공한다.
  * 그러나 이러한 함수는 사용자가 실제로 톱레벨 함수인지 잘 모르므로, 편의상 가짜 생성자라고 지칭된다.
* **가짜 생성자는 크게 인터페이스를 위한 생성자를 정의하거나, reified 타입 인자를 갖도록 하고 싶은 경우에 사용**된다.
* 이 때, **가장 중요한 것은 가짜 생성자 역시 반드시 진짜 생성자처럼 동작해야한다는 점**에 있다.
  * 때문에 캐싱이나 nullable 타입의 반환 등 다른 기능이 필요하다면, companion 객체의 팩토리 메소드와 같은 방식을 사용하는 것이 바람직하다.
* 가짜 생성자는 invoke 연산자를 갖는 companion 객체에 의해서도 정의될 수 있으나, 이는 권장되지 않는 방법에 해당한다.
  * invoke는 호출한다는 의미를 갖기에, 이를 사용하여 객체를 생성하면 의미가 달라지게 되므로 연산자 오버로드 원칙에 위배된다.

### 팩토리 클래스의 메소드
* 팩토리 클래스와 관련된 추상 팩토리 등 다양한 생성 패턴은 서로 다른 장점을 가지나, 그 중 일부는 코틀린에 적합하지 않은 경향이 있다.
  * 예를 들어, 코틀린에서는 점층적 생성자 패턴 또는 빌더 패턴이 의미가 없다.
* 팩토리 클래스는 상태를 가질 수 있다는 특징으로 인해 캐싱과 같이 팩토리 함수보다 다양한 기능을 가질 수 있다.

### 코틀린의 팩토리 메소드 - 결론
* 코틀린은 팩토리 함수를 만들 수 있는 다양한 방식을 제공하며, 이러한 방식들은 각각 서로 다른 특징을 가지므로 이를 파악하는 것이 중요하다.
  * 예를 들어, 가짜 생성자나 톱레벨 팩토리 함수 및 확장 팩토리 함수 등은 신중히 사용되어야 한다.
* 가장 일반적인 방법은 companion 객체를 활용하는 것이며, 또한 해당 방식은 Java의 정적 팩토리 메소드 패턴과 유사하여 개발자들에게 익숙한 방법이기도 하다.

## 2023-04-24 Mon
### 코틀린 생성자에 기본 인자 정의하기
* Java에서는 점층적 생성자 패턴과 빌더 패턴이 자주 사용되지만, 코틀린에서는 생성자에 기본 인자를 정의하는 것이 바람직하다.
  * 기본 인자를 통해 매개 변수의 값을 원하는대로 정의하거나, 인자의 순서를 마음대로 조절하면서도 가독성을 높일 수 있다.
* 특히, Java에서 자주 사용되는 빌더 패턴의 장점들 역시도 코틀린에서는 생성자의 기본 인자로 얻어내는 것이 가능하다.
  * 반면 **코틀린의 생성자 기본 인자는 더 짧고, 명확하면서도 사용 및 수정이 더 쉽다는 추가적인 장점**이 있다.
* 나아가 생성자의 기본 인자로 빌더 패턴의 장점을 완전히 대체하기 어려운 경우, DSL 정의를 고려해볼 수 있다.
* 상술한 이유로 인해 코틀린에서는 빌더 패턴을 거의 사용하지 않으며, 다음과 같은 경우에만 빌더 패턴의 적용을 고려할 수 있다.
  1. 빌더 패턴을 사용하는 다른 언어로 작성된 라이브러리를 옮겨야할 때
  2. 또는 기본 인자와 DLS을 지원하지 않는 다른 언어에서도 쉽게 사용할 수 있을만한 API를 설계해야 할 때

### 코틀린 DSL이란?
```
> DSL은 언어 내부에서 사용되는 특별한 언어이며, 복잡하고 계층적인 자료 구조를 쉽게 정의할 수 있도록 한다.
> 그러나 DSL의 정의는 이에 익숙치 않은 개발자에게는 오히려 어려움을 줄 수 있다.
> 또한 DSL 없이도 빌더나 단순 생성자만으로도 원하는 모든 것을 표현할 수 있으므로, 자주 사용되는 구조의 반복을 제거하기 위해 DSL을 고려할 수 있다.
```
* 코틀린은 DSL을 직접 정의할 수 있도록 지원하며, 이를 통해 복잡한 객체 또는 계층 구조를 정의할 때 유용하게 사용할 수 있다.
  * 물론 **좋은 DSL을 직접 정의하는 것은 어렵지만, 한 번 정의한 후에는 복잡한 보일러플레이트 코드들을 숨기면서도 의도를 명확히 표현하는 것이 가능**하다.
  * 또한, 코틀린 DSL은 DSL 내부에서도 코틀린이 제공하는 모든 것을 활용할 수 있으므로 Groovy 등과는 달리 타입 안전하게 사용하는 것이 가능하다.
* 사용자 정의 DSL을 정의하는 경우, 반드시 개발자가 함수 타입에 대해 이해하는 것이 선행되어야 한다.
* 반면, 단순한 기능에 DSL을 정의하는 것은 적절하지 않으며 주로 다음과 같은 상황에서 고려하는 것이 바람직하다.
  1. 복잡한 자료 구조를 표현해야할 때
  2. 또는 계층적인 구조를 표현해야할 때
  3. 또는 거대한 양의 데이터를 표현해야할 때
* 결국 임의의 코드가 자주 사용되지만 개발자에게 중요하지 않은 정보를 포함하고 있는 경우, 이를 간략화할만한 코틀린 기능이 없다면 DSL 정의를 검토할 수 있다.
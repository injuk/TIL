# EffectiveCodes
## 2023-04-13 Thu
### 재사용성의 위력과 위험성
* System.out.prinln과 같이, 누군가가 복잡한 내용을 한 번 만들어둔 후에는 필요할 때 이를 활용할 수 있다.
    * 이는 프로그래밍 언어의 핵심인 재사용성에 해당한다.
* 그러나 **재사용성은 커다란 이점을 가져다 주는만큼 굉장히 위험할 수도 있으며, 이를 고려하는 것은 생각보다 어렵고 많은 오류를 유발**할 수 있다.
    * 예를 들어 중복을 제거한 기능 A를 위해 수정한 것이 기능 B에서 문제가 될 수 있고, 그 반대의 경우도 언제나 발생할 수 있다.

## 2023-04-14 Fri
### knowledge를 반복하지 않기
```
> knowledge는 프로그래밍에서 표현되는 의도적인 정보이며, 코드 또는 데이터로 표현할 수 있다.
> 모든 것은 별화하므로, 일반적으로 반복되는 공통의 knowledge는 추출하여 변경에 대비하는 것이 권장된다.
> 그러나 서로 다른 액터가 사용하는 knowledge는 독립적으로 변경될 가능성이 높기에 별도로 취급하는 것이 바람직하다. 
```
* knowledge의 종류는 굉장히 다양하며, 예를 들어 알고리즘의 동작 방식이나 UI의 형태 등이 포함된다.
* 그럼에도 프로그램 상에서 중요한 knowledge를 뽑는다면 크게 다음과 같이 분류할 수 있다.
  1. 비즈니스 로직: 프로그램이 어떠한 방식으로 동작하는지를 의미한다.
  2. 공통 알고리즘: 원하는 동작을 위한 알고리즘을 의미한다.
* 이 때, **비즈니스 로직은 시간에 따라 변화해나가지만 공통 알고리즘의 동작은 크게 변화하지 않는다는 점에서 차이**가 있다.
  * UI 디자인이나 기술 표준, 또는 고객에 대한 이해가 매일 변화하듯 프로젝트의 knowledge 역시 계속해서 변화한다.
  * 이렇듯 모든 프로젝트는 변화하고, 이는 바람직한 일이므로 개발자는 언제나 변화에 대비할 수 있어야 한다.
* 다가올 변화에 있어 가장 큰 적은 knowledge가 반복되는 부분이며, 이는 프로젝트의 확장성을 낮추고 쉽게 깨지도록 만든다.
  * 예를 들어, knowledge가 반복된다면 이를 수정할 때 휴먼 에러가 발생하기 너무 쉽다.
* 반면 **동일한 knowledge처럼 보이더라도 둘이 다른 시점에 다른 방향으로 변경될 가능성이 있다면 반복으로 판단하지 말아야 하며, 추출하지도 않아야 한다**.
  * 이렇듯 knowledge가 반복되는지 판단하기 위해서는 단일 책임 원칙을 적용해볼 수 있다.
  * 예를 들어, 단일 책임 원칙은 클래스를 변경하는 이유는 단 한가지여야 함을 강조하며 두 액터가 하나의 클래스를 변경할 수 없도록 권장한다.
  * 이 때, **액터는 변화를 만들어내는 `source of change`로서 일반적으로 서로에 대해 잘 모르는 개발자들로 비유**된다.
* **두 액터가 하나의 클래스를 변경해야할 것으로 보이는 경우, 애초에 클래스를 분리하거나 각 모듈 별로 확장 함수를 배치할 것을 고려**해볼 수 있다.

### 일반적인 알고리즘을 다시 구현하지 않기
```
> 동일한 결과를 얻는 함수를 여러 번 정의하는 것은 좋지 않으며, 모든 함수는 반드시 테스트 / 기억 / 유지보수되어야 한다.
> 일반적인 알고리즘은 대부분 stdlib에 정의되어 있으므로, stdlib을 익히는 것이 바람직하다.
> stlib에 없는 일반적인 알고리즘은 프로젝트 내부에 정의하되, 되도록 확장 함수로 정의하는 것이 바람직하다.
```
* 많은 개발자들은 같은 알고리즘을 여러 번 반복해서 구현하는 경향이 있으나, 많은 기능이 이미 개발되어 표준 라이브러리에 포함된다.
* 이렇듯 이미 있는 기능을 활용할 경우, 코드가 짧아지는 것 외에도 다음과 같은 장점을 누릴 수 있다.
  1. 코드 작성 속도가 빨라진다.
  2. 함수의 구현부를 볼 필요 없이, 이름만 보고도 동작을 알 수 있다.
  3. 직접 구현하는 방식과 비교하여 휴먼 에러의 발생 가능성을 줄일 수 있으며, 성능 역시 더 최적화되어 있을 가능성이 높다.
* 예를 들어 **`stdlib`은 확장 함수를 활용한 거대한 유틸리티 라이브러리이며, 힘들더라도 이를 모두 살펴보는 것은 큰 도움**이 될 수 있다.
  * 또한 표준 라이브러리에 없지만 매우 범용적인 알고리즘이 필요하다고 해도, 이를 구현할 때는 범용 유틸리티 함수로 정의하는 것이 바람직하다.
* 자주 사용되는 알고리즘을 범용 유틸리티로 추출할 경우 확장 함수나 톱레벨 함수, 프로퍼티 위임이나 클래스를 정의할 수 있다.
* 그러나 확장 함수는 다른 방식들과 비교하여 다음과 같은 장점을 갖는다.
  1. 함수는 상태를 유지하지 않으므로 행위를 표현하기에 적합하며, 사이드 이펙트를 갖지 않는다면 더더욱 그렇다.
  2. 톱레벨 함수와 비교하여 확장 함수는 구체적인 타입을 갖는 객체로만 제한할 수 있는 이점을 갖는다.
  3. **수정 대상 객체를 인자로 받는 것보다는 확장 리시버로 사용하는 것이 가독성 측면에서 더 좋다**.
  4. **확장 함수는 자동 완성 측면에서 객체에 정의된 함수보다 더 쉽게 찾을 수 있다**.

## 2023-04-15 Sat
### 프로퍼티를 사용하는 일반적인 패턴에는 프로퍼티 위임을 적용하기
```
> 프로퍼티 위임은 프로퍼티 패턴을 추출하는 일반적인 방법이므로 자주 사용되며, 프로퍼티와 관련된 다양한 조작을 할 수 있도록 지원한다.
> 이러한 특징으로 인해 여러 프로퍼티의 동작을 추출하여 재사용할 수 있으며, lazy 역시 프로피티 위임의 대표적인 예시에 해당한다.
```
* 코틀린의 **프로퍼티 위임이란, 다른 객체의 메소드를 통해 프로퍼티의 접근자를 정의하는 방식을 의미**한다.
  * 예를 들어 프로퍼티가 사용될 때마다 로그를 남기고 싶은 경우, 선택 가능한 첫 번째 방법은 게터와 세터에 해당 동작 방식을 정의하는 것이다.
  * 그러나 이러한 방식이 여러 클래스의 프로퍼티에 반복적으로 적용되어야 하는 경우, 프로퍼티 위임을 위한 별도의 객체를 정의하는 것이 바람직하다.
* 프로퍼티 위임을 사용할 경우, 일반적인 프로퍼티의 행위를 추출하여 재사용할 수 있도록 만들 수 있다.
* 프로퍼티 위임을 위해 정의하는 객체의 경우, 게터를 위한 `getValue`와 세터를 위한 `setValue` 메소드를 정의할 수 있다.
  * 당연히 val 프로퍼티의 경우 `getValue` 연산만이 필요하며, var 프로퍼티라면 두 연산이 모두 필요하다.
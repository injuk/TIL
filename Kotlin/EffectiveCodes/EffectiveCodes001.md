# EffectiveCodes
## 2023-04-03 Mon
### 코틀린을 왜 사용하는가?
```
> 프로젝트에 코틀린을 도입하기 위한 대표적인 이유 중 하나는 안정성에 있다.
```
* 코틀린은 다양한 설계 및 지원을 토대로 안전한 언어가 되었지만, 정말 안전하게 사용하기 위해서는 개발자가 이를 뒷받침할 필요가 있다.
  * 즉, 코틀린을 토대로 애플리케이션을 제작하는 개발자는 오류가 덜 발생하는 코드를 만들고자 노력해야 한다.

### 가변성이란?
* 코틀린 애플리케이션을 구성하는 모듈은 클래스 또는 객체 및 함수 등 다양한 요소로 구성될 수 있으며, 이 중 일부는 가변적인 `상태`를 가질 수 있다.
  * 예를 들어 var 키워드로 설정된 프로퍼티 또는 mutable 객체가 그렇다.
* 이러한 가변적인 `상태`는 변화하는 요소를 표현하는 데에 유용하지만, **`상태`를 적절히 관리하는 것은 생각보다 어려운 일**이 될 수 밖에 없다.
  * 예를 들어 멀티 스레드의 경우 적절한 동기화가 필요하며, 테스트 관점에서는 가능한 모든 `상태`를 테스트하기도 어렵다.
* 이렇듯 **가변성은 시스템의 `상태`를 나타내기 위해 중요한 방법이나, 변경이 일어나는 부분은 반드시 신중하고 확실하게 결정된 후에 사용**되어야 한다.

## 2023-04-04 Tue
### 코틀린의 가변성 제한 방법
* 코틀린은 가변성을 제한할 수 있도록 설계되어 있으며, 그 중 가장 자주 사용되는 방식은 크게 다음과 같다. 
  1. val 키워드를 활용하여 읽기 전용 프로퍼티를 정의하기
  2. 가변 컬렉션과 읽기 전용 컬렉션을 구분하기
  3. data 클래스의 copy 메소드 활용하기
* 읽기 전용 프로퍼티의 경우 마치 값처럼 동작하며 일반적인 방법으로는 값이 변화하지 않는다.
  * 그러나 읽기 전용 프로퍼티가 mutable 객체를 참조하고 있는 경우, 내부적으로는 상태가 변경될 수 있다.
  * 이렇듯 코틀린의 프로퍼티는 기본적으로 캡슐화되어 있으므로 코틀린은 API를 변경하거나 정의할 때에 굉장히 유용하다.
* 코틀린에서 읽기 전용 프로퍼티와 가변 프로퍼티가 구분되듯, 컬렉션 역시 읽기 전용 컬렉션과 가변 컬렉션으로 구분될 수 있다.
  * 이 때, **읽기 전용 프로퍼티를 가변적으로 만들 수 있는 방법이 없는 것은 아니지만 반드시 읽기 전용으로만 사용하도록 강제**할 수 있어야 한다.
  * 때문에 읽기 전용 컬렉션을 가변 컬렉션으로 다운 캐스팅하지 않아야 하며, 대신 내부적으로 새로운 컬렉션을 만드는 `toMutableList()` 등을 활용한다.
* 불변 객체는 자신의 일부를 수정하는 새로운 객체를 만들어낼 수 있어야 하며, 코틀린에서 이러한 기능은 `data` 키워드를 통해 쉽게 적용할 수 있다.
  * 해당 키워드는 내부적으로 copy 메소드를 정의해주며, 이를 통해 모든 기본 생성자 프로퍼티가 같은 별개의 객체를 생성할 수 있다.
  * 또한, **해당 키워드를 토대로 정의된 데이터 모델 클래스는 불변 객체의 특성**을 갖게 된다.
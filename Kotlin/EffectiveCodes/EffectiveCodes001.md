# EffectiveCodes
## 2023-04-03 Mon
### 코틀린을 왜 사용하는가?
```
> 프로젝트에 코틀린을 도입하기 위한 대표적인 이유 중 하나는 안정성에 있다.
```
* 코틀린은 다양한 설계 및 지원을 토대로 안전한 언어가 되었지만, 정말 안전하게 사용하기 위해서는 개발자가 이를 뒷받침할 필요가 있다.
  * 즉, 코틀린을 토대로 애플리케이션을 제작하는 개발자는 오류가 덜 발생하는 코드를 만들고자 노력해야 한다.

### 가변성이란?
* 코틀린 애플리케이션을 구성하는 모듈은 클래스 또는 객체 및 함수 등 다양한 요소로 구성될 수 있으며, 이 중 일부는 가변적인 `상태`를 가질 수 있다.
  * 예를 들어 var 키워드로 설정된 프로퍼티 또는 mutable 객체가 그렇다.
* 이러한 가변적인 `상태`는 변화하는 요소를 표현하는 데에 유용하지만, **`상태`를 적절히 관리하는 것은 생각보다 어려운 일**이 될 수 밖에 없다.
  * 예를 들어 멀티 스레드의 경우 적절한 동기화가 필요하며, 테스트 관점에서는 가능한 모든 `상태`를 테스트하기도 어렵다.
* 이렇듯 **가변성은 시스템의 `상태`를 나타내기 위해 중요한 방법이나, 변경이 일어나는 부분은 반드시 신중하고 확실하게 결정된 후에 사용**되어야 한다.

## 2023-04-04 Tue
### 코틀린의 가변성 제한 방법
* 코틀린은 가변성을 제한할 수 있도록 설계되어 있으며, 그 중 가장 자주 사용되는 방식은 크게 다음과 같다. 
  1. val 키워드를 활용하여 읽기 전용 프로퍼티를 정의하기
  2. 가변 컬렉션과 읽기 전용 컬렉션을 구분하기
  3. data 클래스의 copy 메소드 활용하기
* 읽기 전용 프로퍼티의 경우 마치 값처럼 동작하며 일반적인 방법으로는 값이 변화하지 않는다.
  * 그러나 읽기 전용 프로퍼티가 mutable 객체를 참조하고 있는 경우, 내부적으로는 상태가 변경될 수 있다.
  * 이렇듯 코틀린의 프로퍼티는 기본적으로 캡슐화되어 있으므로 코틀린은 API를 변경하거나 정의할 때에 굉장히 유용하다.
* 코틀린에서 읽기 전용 프로퍼티와 가변 프로퍼티가 구분되듯, 컬렉션 역시 읽기 전용 컬렉션과 가변 컬렉션으로 구분될 수 있다.
  * 이 때, **읽기 전용 프로퍼티를 가변적으로 만들 수 있는 방법이 없는 것은 아니지만 반드시 읽기 전용으로만 사용하도록 강제**할 수 있어야 한다.
  * 때문에 읽기 전용 컬렉션을 가변 컬렉션으로 다운 캐스팅하지 않아야 하며, 대신 내부적으로 새로운 컬렉션을 만드는 `toMutableList()` 등을 활용한다.
* 불변 객체는 자신의 일부를 수정하는 새로운 객체를 만들어낼 수 있어야 하며, 코틀린에서 이러한 기능은 `data` 키워드를 통해 쉽게 적용할 수 있다.
  * 해당 키워드는 내부적으로 copy 메소드를 정의해주며, 이를 통해 모든 기본 생성자 프로퍼티가 같은 별개의 객체를 생성할 수 있다.
  * 또한, **해당 키워드를 토대로 정의된 데이터 모델 클래스는 불변 객체의 특성**을 갖게 된다.

### 변경 가능한 지점을 제어하기
```
> 변경 가능한 컬렉션보다는 변경 가능한 프로퍼티와 불변 컬렉션을 활용하는 것이 바람직하다.
```
* 변경 가능한 리스트를 정의하는 경우, 다음과 같이 두 가지 방식을 고려할 수 있다.
  1. mutable 컬렉션으로 정의하기
  2. var 키워드로 immutable 컬렉션을 정의하기
* **두 방식 모두 변경 가능한 지점이 존재하나, 전자는 컬렉션 내부에 위치하는 반면 후자는 프로퍼티 자체가 변경 가능한 지점인 차이가 존재**한다.
  * 당연히 **후자의 방식이 멀티스레드 환경에서 상대적으로 높은 안정성을 보일 것이므로, 결국 mutable 프로퍼티를 사용하는 것이 변경을 제어하기 더 쉽다**.

### 변경 가능한 지점은 노출하지 않기
* 상태를 나타내기 위한 mutable 객체를 직 / 간접적으로 public하게 공개하는 것은 매우 위험하므로 다음과 같은 방법을 활용하는 것이 바람직하다.
  1. 방어적 복제: mutable 객체를 복제하여 반환하며, 이 과정에서 `data` 키워드와 copy 메소드를 활용할 수 있다.
  2. 업캐스팅: **가변성을 제한하기 위해 컬렉션을 반환하는 시점에 읽기 전용 슈퍼타입으로 업캐스팅**한다.
* 이렇듯 **코틀린은 가변성을 제한하기 위한 다양한 선택지를 열어두므로, 상술한 여러 방법을 통해 가변 지점을 제한할 수 있도록 주의**를 기울여야 한다.
  * 예를 들어, 변경이 필요한 대상을 정의하는 경우 `data` 키워드를 적용하여 불변 데이터 클래스와 copy 메소드를 활용할 수 있다.
* 반면, 효율성을 위해 고의적으로 가변 객체를 활용할 수도 있으나 이러한 최적화 기법은 성능이 중요한 경우에만 적용하는 것이 바람직하다.
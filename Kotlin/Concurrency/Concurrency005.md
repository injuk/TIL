# Concurrency
## 2023-08-25 Fri
### 일시 중단이 가능한 시퀀스와 이터레이터
* 상술한 일시 중단 함수와 달리, 일시 중단 가능한 시퀀스 및 이터레이터를 다음과 같은 특징을 갖는다.
  1. 호출 간에 일시 중단될 수 있으나, 실행 도중에는 일시 중단될 수 없다.
  2. 코루틴 컨텍스트를 전달받지 않는 대신, 기본적으로 코드를 호출한 컨텍스트와 동일한 컨텍스트에서 실행된다.
  3. **`yield()` 또는 `yieldAll()`함수를 통해 정보가 산출된 후에만 일시 중지가 가능**하다.
* 특히 **마지막 특징에 따라, 시퀀스 또는 이터레이터는 값을 산출한 후에 다음 값을 요청받을 때까지 일시 중단**된다.
* 이 때, **일시 중단 가능한 시퀀스 및 이터레이터는 실행 도중에는 일시 중단될 수 없으므로 일시 중단 불가능한 코드에서도 호출이 가능**하다.

## 2023-08-26 Sat
### 이터레이터란?
* 이터레이터는 컬렉션을 순차 탐색하는 데에 유용하며, 특히 다음과 같은 특징을 갖는다.
  1. 인덱스를 기반으로 검색할 수는 없으며, 오로지 순차 탐색만 가능하다.
  2. 다음 요소의 존재 여부를 의미하는 `hasNext()` 메소드를 갖는다.
  3. 단방향 탐색만이 가능하며, 이전 요소로 되돌아갈 수 없다.
  4. **이터레이터는 재설정이 불가능하므로, 오로지 한 번만 반복이 가능**하다.
* 코틀린의 경우 `iterator { ... }`와 같이 람다를 전달하는 것으로 이터레이터를 생성할 수 있으며, 이 경우 반환형은 `Iterator<T>`가 된다.
  * 이 때, 당연스럽게도 타입 변수 T는 이터레이터가 생성하는 요소에 의해 결정되며 일치하지 않는 경우에는 컴파일이 불가능하다.

## 2023-08-27 Sun
### 이터레이터 사용하기
* 이터레이터는 각 요소를 한 번에 하나씩 조회하거나, 모든 요소를 한 번에 가져오는 식으로 사용이 가능하다.
* 이 때, 모든 요소를 한 번에 가져오기 위해 `iterator.forEach { ... }` 또는 `iterator.forEachRemaining()`을 사용할 수 있다.
  * 후자의 경우, 이터레이터의 앞 부분을 이미 조회한 경우 남은 요소만을 조회하기 위함임을 명시적으로 알리는데에 유용하게 활용할 수 있다.
* 반면, 하나의 요소만을 조회하기 위해서는 `next()` 메소드를 사용할 수 있으며 이는 다음 요소의 존재 여부를 의미하는 `hasNext()`와 혼용할 수 있다.
  * 그러나 다음 요소의 존재 여부를 검증하지 않고 무작정 `next()` 메소드를 호출할 경우, `NoSuchElementException`이 발생하게 된다.

## 2023-08-28 Mon
### 값을 산출하는 hasNext()
```
> hasNext() 메소드는 호출 중에 다음 값을 산출한다.
```
* `hasNext()` 메소드가 호출되면 런타임은 코루틴의 실행을 재개하며, 새로운 값이 산출되는 경우에만 `true`를 반환한다.
* 즉, **이터레이터는 `hasNext()` 메소드가 호출되면 `yield`문까지 실행을 대기하여 반환되는 값을 유지하는 식으로 동작**한다.
  * 이렇게 **유지되는 값은 다음 번 `next()` 메소드가 호출될 때 반환되며, 이터레이터는 해당 지점에서 다음 호출을 기다린다**.

## 2023-08-29 Tue
### 시퀀스란?
* 일시 중단 시퀀스는 일시 중단 이터레이터와는 상당히 다른 다음과 같은 특징을 갖는다.
  1. 인덱스를 기반으로 값을 조회할 수 있다.
  2. 상태가 저장되지 않는 대신, 상호 작용 이후에 자동으로 재설정된다.
  3. 한 번의 호출만으로 값의 그룹을 조회할 수 있다.
* 코틀린의 경우 일시 중단 시퀀스를 생성하기 위해 `sequence { ... }` 빌더를 사용할 수 있으며, 해당 빌더는 `Sequence<T>`를 반환한다.
  * 이 때, 시퀀스 내부에서도 `yiled()` 메소드를 통해 값을 산출하도록 정의할 수 있다.
  * 또한, 이터레이터와 유사하게 시퀀스 빌더 내부로부터 산출되는 값에 따라 타입 변수 `T`를 적절한 타입으로 명시할 수 있다.

## 2023-08-30 Wed
### 시퀀스 사용하기
* 기본적으로, 시퀀스의 모든 요소를 조회하기 위해서는 `forEach()` 또는 `forEachIndexed()` 메소드를 활용할 수 있다.
  * 두 메소드는 유사하게 동작하지만, `forEachIndexed()`는 값과 함께 인덱스를 반환한다는 점에서 차이가 있다.
* 반면, 모든 값이 아닌 임의의 요소를 조회하고자 하는 경우 인덱스와 `elementAt()` 또는 `elementAtOrElse()` 메소드를 활용할 수 있다.
  * 또는 `T?`를 반환하는 `elementAtOrNull()`을 활용할 수도 있다.
  * 이 때, **`elementAtOrElse()`의 경우 주어진 인덱스에 아무런 요소가 존재하지 않는 경우 두 번째 인자로 전달 받은 람다를 실행한 값을 반환**한다.
* `take()` 메소드에 조회하고자 하는 요소의 개수를 전달할 경우, 한 번에 여러 개의 요소로 구성된 값 그룹을 조회할 수 있다.
  * **`take()`는 시퀀스의 대표적인 중간 연산이므로, 호출 시점에는 값을 갖지 않는 대신 종단 연산이 호출되는 시점에 값을 갖게 된다**.
* **일시 중단 시퀀스는 일시 중단 이터레이터와 달리 상태를 갖지 않으며, 적절한 메소드를 호출할 때마다 사용된 후에 재설정된다는 특징**을 갖는다.
  * 다시 말해, **이터레이터의 경우와는 달리 시퀀스는 동일한 인스턴스에 대해서도 메소드를 호출할 때마다 시퀀스는 항상 첫 요소부터 차례로 값을 산출**한다.

## 2023-08-31 Thu
### 프로듀서란?
* **시퀀스와 이터레이터는 실행 중에 일시 중단할 수 없다는 한계가 있으며, 이는 대부분의 경우 큰 제약사항**이 된다.
* 이러한 한계를 극복하기 위해서는 프로듀서 개념을 사용해야 하며, 프로듀서는 다음과 같은 유용한 특징을 갖는다.
  1. 값이 생성된 후 일시 중단되며, 새로운 값이 요청될 때 재개된다는 점에서 일시 중단 시퀀스나 이터레이터와 유사하다.
  2. **프로듀서는 임의의 코루틴 컨텍스트로 생성될 수 있다**.
  3. **프로듀서에 전달되는 일시 중단 람다의 본문은 언제든지 일시 중단될 수 있으며, 이로 인해 프로듀서의 값은 일시 중단 연산에서만 수신 가능**하다.
  4. 프로듀서는 채널을 기반으로 동작하므로 데이터를 마치 스트림처럼 처리할 수 있으며, 이 경우 요소를 수신할 때마다 해당 요소를 스트림에서 제거된다.
* 이 때, 이러한 **프로듀서는 코루틴 빌더의 일종인 `produce { ... }`로 생성할 수 있으며 `ReceiveChannel<E>`와 같은 반환형**을 갖는다.
  * 또한, **프로듀서는 채널을 기반으로 구축되므로 요소의 산출에 `yield()`가 아닌 `send()` 함수를 사용**하게 된다.

## 2023-09-01 Fri
### 프로듀서 사용하기
```
> 프로듀서의 사용성은 기본적으로 시퀀스나 이터레이터의 사용법이 혼합된 형태를 갖는다.
```
* `launch()`나 `async()`와 마찬가지로, **`GlobalScope.produce(context) { ... }` 형태로 코루틴 컨텍스트를 명시할 수 있다**.
* 프로듀서 역시 타입 변수를 명시하여 지정할 수 있으며, 이 경우 프로듀서가 산출하는 요소는 반드시 명시된 타입을 준수해야 한다.
* 프로듀서가 산출하는 모든 요소를 조회하기 위해서는 `consumeEach()` 함수를 활용할 수 있다.
  * 반면, 단일 요소를 조회하기 위해서는 `receive()` 함수를 활용한다.
* 프로듀서에 개수를 지정하여 여러 개의 요소 그룹은 반환받고자 하는 경우, 시퀀스와 마찬가지로 `take()` 함수를 사용할 수 있다.
  * 이후 반환된 모든 요소 그룹을 조회하고자 하는 경우, `producer.take(5).consumeEach { ... }` 형태로 코드를 작성할 수 있다.
  * 이 때, **`take()` 역시 `ReceiveChannel<E>`를 반환하는 중간 연산이므로 `consumeEach()`와 같은 종단 연산을 통해 실제 값이 계산**된다.

## 2023-09-02 Sat
### 프로듀서로부터 허용된 이상의 요소를 조회하는 경우
* 이터레이터나 시퀀스는 산출 가능한 요소보다 더 많은 요소를 조회하고자 하는 경우에 `NoSuchElementException`이 발생한다.
* 그러나 프로듀서는 요소를 조회하는 방식에 따라 다음과 같이 다른 형태로 동작한다.
  1. `take().consumeEach { ... }`를 활용하는 경우, 종단 연산인 `consumeEach()`는 더 이상 요소가 없으면 중지되므로 예외는 발생하지 않는다.
  2. 모든 요소가 조회되어 종료된 프로듀서에 대해 `receive()`를 호출하는 경우, 이미 채널이 닫혔기에 `ClosedReceiveChannelException`이 발생한다.

## 2023-09-03 Sun
### 시퀀스와 이터레이터, 그리고 프로듀서 - 결론
* 시퀀스의 특징은 크게 다음과 같다.
  1. 상태를 저장하지 않으며, 각각의 호출 후에 자체적으로 리셋된다.
  2. 인덱스를 기반으로 요소를 조회하거나, 한 번에 여러 값의 그룹을 조회할 수 있다.
* 나아가 이터레이터의 특징은 크게 다음과 같다.
  1. 상태를 저장하며, 한 방향으로만 조회가 가능하여 이전 요소를 조회할 수 없다.
  2. 인덱스를 기반으로 요소를 조회할 수 없다.
* 또한, 이러한 시퀀스와 이터레이터는 공통적으로 다음과 같은 특징을 갖는다.
  1. **하나 이상의 값을 산출한 후 일시 중단될 수 있으나, 이는 실행의 일부로서의 일시 중단을 의미하지는 않는다**.
  2. 즉, **시퀀스와 이터레이터는 비중단 연산에서 호출이 가능하므로 비동기 작업이 필요 없는 데이터 소스로 사용되기에 적합**하다.
* 반면, 프로듀서는 다음과 같은 특징을 갖는다.
  1. **실행 중을 포함하여 언제든지 중단이 가능하며, 실행 중에 일시 중단이 가능하기에 일시 중단 연산 또는 코루틴에서만 호출이 가능**하다.
  2. 프로듀서는 채널을 기반으로 데이터를 출력한다.
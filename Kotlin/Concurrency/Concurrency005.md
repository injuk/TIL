# Concurrency
## 2023-08-25 Fri
### 일시 중단이 가능한 시퀀스와 이터레이터
* 상술한 일시 중단 함수와 달리, 일시 중단 가능한 시퀀스 및 이터레이터를 다음과 같은 특징을 갖는다.
  1. 호출 간에 일시 중단될 수 있으나, 실행 도중에는 일시 중단될 수 없다.
  2. 코루틴 컨텍스트를 전달받지 않는 대신, 기본적으로 코드를 호출한 컨텍스트와 동일한 컨텍스트에서 실행된다.
  3. **`yield()` 또는 `yieldAll()`함수를 통해 정보가 산출된 후에만 일시 중지가 가능**하다.
* 특히 **마지막 특징에 따라, 시퀀스 또는 이터레이터는 값을 산출한 후에 다음 값을 요청받을 때까지 일시 중단**된다.
* 이 때, **일시 중단 가능한 시퀀스 및 이터레이터는 실행 도중에는 일시 중단될 수 없으므로 일시 중단 불가능한 코드에서도 호출이 가능**하다.

## 2023-08-26 Sat
### 이터레이터란?
* 이터레이터는 컬렉션을 순차 탐색하는 데에 유용하며, 특히 다음과 같은 특징을 갖는다.
  1. 인덱스를 기반으로 검색할 수는 없으며, 오로지 순차 탐색만 가능하다.
  2. 다음 요소의 존재 여부를 의미하는 `hasNext()` 메소드를 갖는다.
  3. 단방향 탐색만이 가능하며, 이전 요소로 되돌아갈 수 없다.
  4. **이터레이터는 재설정이 불가능하므로, 오로지 한 번만 반복이 가능**하다.
* 코틀린의 경우 `iterator { ... }`와 같이 람다를 전달하는 것으로 이터레이터를 생성할 수 있으며, 이 경우 반환형은 `Iterator<T>`가 된다.
  * 이 때, 당연스럽게도 타입 변수 T는 이터레이터가 생성하는 요소에 의해 결정되며 일치하지 않는 경우에는 컴파일이 불가능하다.

## 2023-08-27 Sun
### 이터레이터 사용하기
* 이터레이터는 각 요소를 한 번에 하나씩 조회하거나, 모든 요소를 한 번에 가져오는 식으로 사용이 가능하다.
* 이 때, 모든 요소를 한 번에 가져오기 위해 `iterator.forEach { ... }` 또는 `iterator.forEachRemaining()`을 사용할 수 있다.
  * 후자의 경우, 이터레이터의 앞 부분을 이미 조회한 경우 남은 요소만을 조회하기 위함임을 명시적으로 알리는데에 유용하게 활용할 수 있다.
* 반면, 하나의 요소만을 조회하기 위해서는 `next()` 메소드를 사용할 수 있으며 이는 다음 요소의 존재 여부를 의미하는 `hasNext()`와 혼용할 수 있다.
  * 그러나 다음 요소의 존재 여부를 검증하지 않고 무작정 `next()` 메소드를 호출할 경우, `NoSuchElementException`이 발생하게 된다.

## 2023-08-28 Mon
### 값을 산출하는 hasNext()
```
> hasNext() 메소드는 호출 중에 다음 값을 산출한다.
```
* `hasNext()` 메소드가 호출되면 런타임은 코루틴의 실행을 재개하며, 새로운 값이 산출되는 경우에만 `true`를 반환한다.
* 즉, **이터레이터는 `hasNext()` 메소드가 호출되면 `yield`문까지 실행을 대기하여 반환되는 값을 유지하는 식으로 동작**한다.
  * 이렇게 **유지되는 값은 다음 번 `next()` 메소드가 호출될 때 반환되며, 이터레이터는 해당 지점에서 다음 호출을 기다린다**.
# Concurrency
## 2023-08-25 Fri
### 일시 중단이 가능한 시퀀스와 이터레이터
* 상술한 일시 중단 함수와 달리, 일시 중단 가능한 시퀀스 및 이터레이터를 다음과 같은 특징을 갖는다.
  1. 호출 간에 일시 중단될 수 있으나, 실행 도중에는 일시 중단될 수 없다.
  2. 코루틴 컨텍스트를 전달받지 않는 대신, 기본적으로 코드를 호출한 컨텍스트와 동일한 컨텍스트에서 실행된다.
  3. **`yield()` 또는 `yieldAll()`함수를 통해 정보가 산출된 후에만 일시 중지가 가능**하다.
* 특히 **마지막 특징에 따라, 시퀀스 또는 이터레이터는 값을 산출한 후에 다음 값을 요청받을 때까지 일시 중단**된다.
* 이 때, **일시 중단 가능한 시퀀스 및 이터레이터는 실행 도중에는 일시 중단될 수 없으므로 일시 중단 불가능한 코드에서도 호출이 가능**하다.

## 2023-08-26 Sat
### 이터레이터란?
* 이터레이터는 컬렉션을 순차 탐색하는 데에 유용하며, 특히 다음과 같은 특징을 갖는다.
  1. 인덱스를 기반으로 검색할 수는 없으며, 오로지 순차 탐색만 가능하다.
  2. 다음 요소의 존재 여부를 의미하는 `hasNext()` 메소드를 갖는다.
  3. 단방향 탐색만이 가능하며, 이전 요소로 되돌아갈 수 없다.
  4. **이터레이터는 재설정이 불가능하므로, 오로지 한 번만 반복이 가능**하다.
* 코틀린의 경우 `iterator { ... }`와 같이 람다를 전달하는 것으로 이터레이터를 생성할 수 있으며, 이 경우 반환형은 `Iterator<T>`가 된다.
  * 이 때, 당연스럽게도 타입 변수 T는 이터레이터가 생성하는 요소에 의해 결정되며 일치하지 않는 경우에는 컴파일이 불가능하다.

## 2023-08-27 Sun
### 이터레이터 사용하기
* 이터레이터는 각 요소를 한 번에 하나씩 조회하거나, 모든 요소를 한 번에 가져오는 식으로 사용이 가능하다.
* 이 때, 모든 요소를 한 번에 가져오기 위해 `iterator.forEach { ... }` 또는 `iterator.forEachRemaining()`을 사용할 수 있다.
  * 후자의 경우, 이터레이터의 앞 부분을 이미 조회한 경우 남은 요소만을 조회하기 위함임을 명시적으로 알리는데에 유용하게 활용할 수 있다.
* 반면, 하나의 요소만을 조회하기 위해서는 `next()` 메소드를 사용할 수 있으며 이는 다음 요소의 존재 여부를 의미하는 `hasNext()`와 혼용할 수 있다.
  * 그러나 다음 요소의 존재 여부를 검증하지 않고 무작정 `next()` 메소드를 호출할 경우, `NoSuchElementException`이 발생하게 된다.

## 2023-08-28 Mon
### 값을 산출하는 hasNext()
```
> hasNext() 메소드는 호출 중에 다음 값을 산출한다.
```
* `hasNext()` 메소드가 호출되면 런타임은 코루틴의 실행을 재개하며, 새로운 값이 산출되는 경우에만 `true`를 반환한다.
* 즉, **이터레이터는 `hasNext()` 메소드가 호출되면 `yield`문까지 실행을 대기하여 반환되는 값을 유지하는 식으로 동작**한다.
  * 이렇게 **유지되는 값은 다음 번 `next()` 메소드가 호출될 때 반환되며, 이터레이터는 해당 지점에서 다음 호출을 기다린다**.

## 2023-08-29 Tue
### 시퀀스란?
* 일시 중단 시퀀스는 일시 중단 이터레이터와는 상당히 다른 다음과 같은 특징을 갖는다.
  1. 인덱스를 기반으로 값을 조회할 수 있다.
  2. 상태가 저장되지 않는 대신, 상호 작용 이후에 자동으로 재설정된다.
  3. 한 번의 호출만으로 값의 그룹을 조회할 수 있다.
* 코틀린의 경우 일시 중단 시퀀스를 생성하기 위해 `sequence { ... }` 빌더를 사용할 수 있으며, 해당 빌더는 `Sequence<T>`를 반환한다.
  * 이 때, 시퀀스 내부에서도 `yiled()` 메소드를 통해 값을 산출하도록 정의할 수 있다.
  * 또한, 이터레이터와 유사하게 시퀀스 빌더 내부로부터 산출되는 값에 따라 타입 변수 `T`를 적절한 타입으로 명시할 수 있다.

## 2023-08-30 Wed
### 시퀀스 사용하기
* 기본적으로, 시퀀스의 모든 요소를 조회하기 위해서는 `forEach()` 또는 `forEachIndexed()` 메소드를 활용할 수 있다.
  * 두 메소드는 유사하게 동작하지만, `forEachIndexed()`는 값과 함께 인덱스를 반환한다는 점에서 차이가 있다.
* 반면, 모든 값이 아닌 임의의 요소를 조회하고자 하는 경우 인덱스와 `elementAt()` 또는 `elementAtOrElse()` 메소드를 활용할 수 있다.
  * 또는 `T?`를 반환하는 `elementAtOrNull()`을 활용할 수도 있다.
  * 이 때, **`elementAtOrElse()`의 경우 주어진 인덱스에 아무런 요소가 존재하지 않는 경우 두 번째 인자로 전달 받은 람다를 실행한 값을 반환**한다.
* `take()` 메소드에 조회하고자 하는 요소의 개수를 전달할 경우, 한 번에 여러 개의 요소로 구성된 값 그룹을 조회할 수 있다.
  * **`take()`는 시퀀스의 대표적인 중간 연산이므로, 호출 시점에는 값을 갖지 않는 대신 종단 연산이 호출되는 시점에 값을 갖게 된다**.
* **일시 중단 시퀀스는 일시 중단 이터레이터와 달리 상태를 갖지 않으며, 적절한 메소드를 호출할 때마다 사용된 후에 재설정된다는 특징**을 갖는다.
  * 다시 말해, **이터레이터의 경우와는 달리 시퀀스는 동일한 인스턴스에 대해서도 메소드를 호출할 때마다 시퀀스는 항상 첫 요소부터 차례로 값을 산출**한다.
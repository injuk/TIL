# Concurrency
## 2023-07-31 Mon
### 그래들로 코루틴 활용하기
* 그래들의 경우, 코루틴을 활용하기 위해 관련된 의존성을 다음과 같이 추가해야 한다.
```
implementation("org.jetbrains.kotlinx:kotlinx-coroutines-core:$version")
```
* 코루틴은 1.3 버전 이전에는 실험적인 기능으로 별도의 설정이 필요했으나, 현재에는 정식으로 포함되었으므로 필요한 의존성만 추가하여 사용이 가능하다.

## 2023-08-01 Tue
### CoroutineDispatcher란?
* **코틀린은 스레드 생성 과정을 단순화하였으므로 쉽고 간단하게 스레드를 생성할 수 있으나, 직접 액세스하거나 제어하지는 않을 것은 권장**한다.
    * 이는 스레드 뿐만 아니라 스레드 풀에도 완벽히 동일하게 적용되는 기본 원칙에 해당한다.
* 반면, 스레드를 적절히 사용하기 위해서는 CoroutineDispatcher를 생성할 필요가 있다.
    * 이 때, **CoroutineDispatcher는 기본적으로 가용성 및 부하와 설정을 기반으로 스레드 간에 코루틴을 분산하는 오케스트레이터 역할을 수행**한다.

## 2023-08-02 Wed
### 디스패쳐에 코루틴 연결하기
* **디스패쳐가 생성된 경우, 이를 활용하는 코루틴을 시작할 수 있게 된다**.
  * 이 때, 코루틴을 시작하는 방법은 크게 두 가지로 나뉘며 결과와 에러를 처리하기 위해서는 둘 사이의 처리를 반드시 알아야 한다.

## 2023-08-03 Thu
### async 코루틴이란?
* 결과를 처리하기 위해 시작된 코루틴은 `async()`를 활용해야 하며, 이는 `Deferred<T>`를 반환한다.
  * 이 때, 디퍼드는 취소 불가능한 논 블로킹 퓨처로서 T가 결과의 유형을 의미한다.
* `async()`의 경우 결과 처리를 잊기 쉬우나, 정상적인 처리를 위해서는 반드시 결과를 처리해주어야 한다.
* 또한, async 코루틴에서 발생한 예외를 처리하는 방법은 `join()`과 `await()`를 사용했을 때 각각 다음과 같은 차이를 보인다.
  1. join: 이 경우 **예외는 한 번 감싸지므로, `isCancelled` 등의 프로퍼티를 활용하여 결과를 직접 처리**해주어야 한다.
  2. await: **join과 달리 단지 호출하는 것만으로 예외를 전파시킨다는 차이**를 갖는다.
* 즉, **`join()`은 검증 후 임의의 오류를 처리하는 식으로 예외를 전파하지 않는 반면 `await()`을 호출하는 경우 예외가 전파된다는 차이가 존재**한다.

## 2023-08-04 Fri
### launch 코루틴이란?
* **결과를 처리할 필요 없을 경우, 결과를 반환하지 않는 코루틴을 시작하기 위해 `launch()`를 사용**할 수 있다.
  * 때문에 이는 근본적으로 이벤트나 메시지 기반 시스템에서 자주 사용되는 패턴인 `fire-and-forget` 시나리오에 적합하다.
  * 또한, `launch()`의 경우 필요시에 작업을 취소할 수도 있도록 하는 함수를 함께 제공한다.

## 2023-08-05 Sat
### 임의의 디스패쳐를 명시하기
* `async {}` 또는 `launch {}` 등의 경우, 아무런 디스패쳐를 명시하지 않기에 기본적으로 `DefaultDispatcher`를 사용한다.
* 반면, 임의의 디스패쳐를 명시하고자 하는 경우 다음과 같은 코드를 작성할 수 있다.
  * 이 경우, **코루틴 빌더를 통해 생성된 코루틴은 전달된 디스패쳐를 통해 어느 스레드에서 실행될지 결정**되게 된다.
```kotlin
fun main(args: Array<String>) = runBlocking {
  val dispatcher = newSingleThreadContext(name = "my-thread")
  val task = GlobalScope.launch(dispatcher) {
    // ...do something
  }
  task.join()
}
```
# Concurrency
## 2023-07-14 Fri
### 프로세스와 스레드
```
> 애플리케이션을 시작하면, OS는 프로세스를 생성하고 메인 스레드를 연결한 후에 이를 시작한다.
> 코틀린의 경우 기본적으로 개발자가 직접 스레드를 관리할 필요 없으며, 대신 짧은 코드로 코틀린이 스레드나 스레드 풀을 생성하여 코루틴을 실행하도록 지시한다.
```
* 프로세스란 실행 중인 애플리케이션 자체의 인스턴스이며, PID나 네트워크 연결 등의 상태를 가질 수 있다.
    * 또한, 해당 프로세스 내부에서 동작하는 스레드는 프로세스의 상태에 접근할 수 있다.
    * 나아가 브라우저를 예로 들어, 하나의 애플리케이션은 때로 여러 프로세스로 구성될 수도 있다.
* 스레드 중 **실행 스레드는 프로세스가 실행할 일련의 명령을 포함하며, 프로세스는 최소한 하나의 스레드를 포함**한다.
    * 이 때, main과 같은 애플리케이션 진입점을 실행하는 스레드를 메인 스레드라고 지칭한다.
    * 또한, 각 스레드는 프로세스의 리소스에 접근할 수 있으며 나아가 스레드 자체의 저장소도 갖는다.
* **스레드 내부의 명령은 한 번에 하나씩 실행되며, 긴 작업의 경우 스레드가 블록되므로 UI 스레드는 블로킹되지 않도록 구현해야 한다**.
    * 대신 **각각의 스레드가 서로 통신할 수 있는 점을 이용하여 별도의 스레드에 블로킹 작업을 할당하는 것이 바람직**하다.
    * 일반적으로, **스레드는 메인 스레드와 백그라운드 스레드로 나누어 지칭**할 수 있다.

## 2023-07-15 Sat
### 그리고 코루틴
```
> 코루틴은 대부분의 스레드와 마찬가지로 실행할 명령어 집합의 실행을 정의하므로 경량 스레드로도 지칭할 수 있다.
> 스레드와 코루틴의 가장 큰 차이점은 비용으로, 코루틴은 스레드보다 빠르고 적은 비용으로 생성할 수 있다.
> 스레드는 한 시점에 하나의 코루틴만을 실행할 수 있으므로, 프레임워크는 코루틴을 적절하게 스레드 간에 옮기는 역할을 수행한다.
```
* **코루틴은 스레드 안에서 실행되며, 스레드 하나에 다수의 코루틴이 존재할 수 있으나 하나의 스레드에서는 한 시점에 하나의 명령만이 실행**될 수 있다.
* **코틀린은 고정된 크기의 스레드 풀을 사용하며, 코루틴을 각 스레드에 배포하므로 많은 코루틴을 생성하더라도 실행시간은 적게 증가**한다.
* **코루틴은 일시 중단될 수 있으며, 중단된 동안 현재 실행 중인 스레드는 다른 코루틴을 실행하는데 사용**된다.
  * 이 때, 코루틴은 시작 또는 재개 가능한 상태로 전이될 수 있다.
* **코루틴은 임의의 스레드에서 시작되었더라도 해당 스레드와 결합되지는 않으며, 실행이 중지되었던 코루틴은 다른 스레드에서 재개될 수도 있다**.
  * 이는 **코틀린이 실행 가능한 스레드로 코루틴을 이동시키는 식으로 동작하기 때문에 가능**하다.

## 2023-07-16 Sun
### 프로세스와 스레드, 그리고 코루틴
* 상술한 바와 같이, 애플리케이션은 하나 이상의 프로세스로 구성되며 프로세스 역시 하나 이상의 스레드로 구성된다.
  * 이 때, 스레드가 블록될 경우 해당 스레드의 코드 실행은 일시적으로 중단된다.
* **코루틴은 기본적으로 스레드 안에 존재하는 경량 스레드이나, 스레드와 결합되지는 않으므로 필요에 따라 다른 스레드로 옮겨져 재개될 수 있다**.
  * 이 때, 동시성은 둘 이상의 스레드가 생성되었을 때 발생할 수 있으며 스레드 간의 통신 및 동기화를 필요로 한다.

## 2023-07-17 Mon
### 동시성이란?
```
> 올바른 동시성 코드는 결정론적으로, 임의의 입력에 대해 같은 과정을 거쳐 항상 같은 결과를 반환해야 하는 대신 실행 순서에서 약간의 자유로움을 주어야 한다.
```
* 순차적인 코드는 정확한 실행 순서를 예측할 수 있으나, 하드웨어 자원을 제대로 사용하지 못하는 등 성능 측면에서의 단점이 존재한다.
* 반면, 동시성을 활용하는 코드는 비동기적인 작업을 서로 다른 스레드에서 실행시켜 `마치` 여러 동작이 동시에 실행되는 것 같은 효과를 낸다.
  * 이는 **동시성의 까다로운 부분이기도 하며, 코드로부터 준독립적인 부분이 완료되는 순서에 관계 없이 결과가 결정적임을 보장**할 수 있어야 한다.

## 2023-07-18 Tue
### 동시성과 병렬성
```
> 동시성은 같은 프로세스 내에서 서로 다른 명령 집합이 실행되는 시점이 겹칠 때 발생한다. 
> 병렬성은 두 스레드가 정확히 동일한 시점에 함께 실행되고 있을 때에만 발생한다.
```
* 동시성과 병렬성은 둘 이상의 코드가 한 시점에 동시에 실행되는 것처럼 보인다는 점에서 상당히 유사하지만, 다음과 같은 결정적인 차이점이 존재한다.
  1. 동시성의 경우, 단일 처리 장치에서는 각각의 비동기 작업의 전체 일정은 겹치나 한 시점에는 하나의 작업만이 실행된다.
  2. 병렬성의 경우, 둘 이상의 처리 장치를 활용하여 각각 독립적인 스레드가 병렬적으로 실행되는 경우를 가리킨다.
* **동시성은 둘 이상의 코드의 실행 시간이 겹칠 때 발생하며, 이를 위해서는 둘 이상의 실행 스레드가 필요**하다.
  * 이 때, 각 스레드들이 단일 코어에서 실행된다면 병렬성이 아닌 동시성이 발생한다.
  * 이 경우, 단일 코어는 서로 다른 스레드의 실행 명령을 교차 배치하여 스레드들의 실행 순서를 효율적으로 겹쳐서 활용한다.
* **병렬성은 둘 이상의 코드가 정확히 동시에 실행될 때 발생하며, 둘 이상의 물리적인 코어와 둘 이상의 스레드가 필요**하다.
  * 이로 인해 **병렬성은 동시성을 의미하지만, 동시성은 병렬성 없이도 발생할 수 있다**.

## 2023-07-19 Wed
### 코드의 병목
```
> 동시성이 꼭 좋은 것은 아니지만, 코드의 병목과 스레드 및 코루틴의 동작 원리 및 병렬성과 동시성의 차이를 이해하는 것으로 이를 언제 적용할지 판단할 수 있다.
```
* 코드 병목 중 CPU 바운드 작업의 경우, CPU만 완료되면 되는 작업을 중심으로 구현되는 알고리즘이 많다.
  * 또한, 이러한 작업은 CPU의 성능에 큰 영향을 받는다.
* 코드 병목 중 IO 바운드 작업의 경우, 실행 시간은 입출력 장치의 속도에 의존하므로 곧 입출력 장치에 의존하는 알고리즘이 된다.
  * 반면, 네트워킹 또는 주변기기로부터의 입력 역시 모두 IO 작업에 해당한다.
  * **IO 바운드 알고리즘은 IO작업을 기준으로 성능에 대한 병목을 발생시키며, 이 경우 최적화는 외부의 시스템이나 장치에 의존**하게 된다.

## 2023-07-20 Thu
### CPU 바운드 작업과 동시성
```
> CPU 바운드 알고리즘은 현재 사용 중인 장치의 코어 수를 기준으로 적절한 스레드 수가 생성되도록 충분히 고려할 경우, 작업 시간을 크게 줄일 수 있다.
```
* CPU 바운드 작업을 처리하는 알고리즘의 경우, 병렬성과 동시성은 코어의 개수에 따라 다음과 같은 특징을 갖는다.
  1. **다중 코어에서 병렬성을 활용하는 경우, 성능은 향상**될 수 있다.
  2. **단일 코어에서 동시성을 구현하는 경우, 성능은 저하**될 수 있다.
  3. 단일 코어에서 다수의 스레드를 사용하는 경우, 컨텍스트 스위칭에 의해 프로세스 전체적으로 봤을 때는 오버헤드가 클 수 있다.
* 코틀린의 경우, CPU 바운드 알고리즘의 처리를 위해 머신의 코어 수보다 하나 작은 스레드를 생성하는 스레드 풀인 `CommonPool`을 사용할 수 있다.
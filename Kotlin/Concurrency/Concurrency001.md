# Concurrency
## 2023-07-14 Fri
### 프로세스와 스레드
```
> 애플리케이션을 시작하면, OS는 프로세스를 생성하고 메인 스레드를 연결한 후에 이를 시작한다.
> 코틀린의 경우 기본적으로 개발자가 직접 스레드를 관리할 필요 없으며, 대신 짧은 코드로 코틀린이 스레드나 스레드 풀을 생성하여 코루틴을 실행하도록 지시한다.
```
* 프로세스란 실행 중인 애플리케이션 자체의 인스턴스이며, PID나 네트워크 연결 등의 상태를 가질 수 있다.
    * 또한, 해당 프로세스 내부에서 동작하는 스레드는 프로세스의 상태에 접근할 수 있다.
    * 나아가 브라우저를 예로 들어, 하나의 애플리케이션은 때로 여러 프로세스로 구성될 수도 있다.
* 스레드 중 **실행 스레드는 프로세스가 실행할 일련의 명령을 포함하며, 프로세스는 최소한 하나의 스레드를 포함**한다.
    * 이 때, main과 같은 애플리케이션 진입점을 실행하는 스레드를 메인 스레드라고 지칭한다.
    * 또한, 각 스레드는 프로세스의 리소스에 접근할 수 있으며 나아가 스레드 자체의 저장소도 갖는다.
* **스레드 내부의 명령은 한 번에 하나씩 실행되며, 긴 작업의 경우 스레드가 블록되므로 UI 스레드는 블로킹되지 않도록 구현해야 한다**.
    * 대신 **각각의 스레드가 서로 통신할 수 있는 점을 이용하여 별도의 스레드에 블로킹 작업을 할당하는 것이 바람직**하다.
    * 일반적으로, **스레드는 메인 스레드와 백그라운드 스레드로 나누어 지칭**할 수 있다.

## 2023-07-15 Sat
### 그리고 코루틴
```
> 코루틴은 대부분의 스레드와 마찬가지로 실행할 명령어 집합의 실행을 정의하므로 경량 스레드로도 지칭할 수 있다.
> 스레드와 코루틴의 가장 큰 차이점은 비용으로, 코루틴은 스레드보다 빠르고 적은 비용으로 생성할 수 있다.
> 스레드는 한 시점에 하나의 코루틴만을 실행할 수 있으므로, 프레임워크는 코루틴을 적절하게 스레드 간에 옮기는 역할을 수행한다.
```
* **코루틴은 스레드 안에서 실행되며, 스레드 하나에 다수의 코루틴이 존재할 수 있으나 하나의 스레드에서는 한 시점에 하나의 명령만이 실행**될 수 있다.
* **코틀린은 고정된 크기의 스레드 풀을 사용하며, 코루틴을 각 스레드에 배포하므로 많은 코루틴을 생성하더라도 실행시간은 적게 증가**한다.
* **코루틴은 일시 중단될 수 있으며, 중단된 동안 현재 실행 중인 스레드는 다른 코루틴을 실행하는데 사용**된다.
  * 이 때, 코루틴은 시작 또는 재개 가능한 상태로 전이될 수 있다.
* **코루틴은 임의의 스레드에서 시작되었더라도 해당 스레드와 결합되지는 않으며, 실행이 중지되었던 코루틴은 다른 스레드에서 재개될 수도 있다**.
  * 이는 **코틀린이 실행 가능한 스레드로 코루틴을 이동시키는 식으로 동작하기 때문에 가능**하다.

## 2023-07-16 Sun
### 프로세스와 스레드, 그리고 코루틴
* 상술한 바와 같이, 애플리케이션은 하나 이상의 프로세스로 구성되며 프로세스 역시 하나 이상의 스레드로 구성된다.
  * 이 때, 스레드가 블록될 경우 해당 스레드의 코드 실행은 일시적으로 중단된다.
* **코루틴은 기본적으로 스레드 안에 존재하는 경량 스레드이나, 스레드와 결합되지는 않으므로 필요에 따라 다른 스레드로 옮겨져 재개될 수 있다**.
  * 이 때, 동시성은 둘 이상의 스레드가 생성되었을 때 발생할 수 있으며 스레드 간의 통신 및 동기화를 필요로 한다.

## 2023-07-17 Mon
### 동시성이란?
```
> 올바른 동시성 코드는 결정론적으로, 임의의 입력에 대해 같은 과정을 거쳐 항상 같은 결과를 반환해야 하는 대신 실행 순서에서 약간의 자유로움을 주어야 한다.
```
* 순차적인 코드는 정확한 실행 순서를 예측할 수 있으나, 하드웨어 자원을 제대로 사용하지 못하는 등 성능 측면에서의 단점이 존재한다.
* 반면, 동시성을 활용하는 코드는 비동기적인 작업을 서로 다른 스레드에서 실행시켜 `마치` 여러 동작이 동시에 실행되는 것 같은 효과를 낸다.
  * 이는 **동시성의 까다로운 부분이기도 하며, 코드로부터 준독립적인 부분이 완료되는 순서에 관계 없이 결과가 결정적임을 보장**할 수 있어야 한다.

## 2023-07-18 Tue
### 동시성과 병렬성
```
> 동시성은 같은 프로세스 내에서 서로 다른 명령 집합이 실행되는 시점이 겹칠 때 발생한다. 
> 병렬성은 두 스레드가 정확히 동일한 시점에 함께 실행되고 있을 때에만 발생한다.
```
* 동시성과 병렬성은 둘 이상의 코드가 한 시점에 동시에 실행되는 것처럼 보인다는 점에서 상당히 유사하지만, 다음과 같은 결정적인 차이점이 존재한다.
  1. 동시성의 경우, 단일 처리 장치에서는 각각의 비동기 작업의 전체 일정은 겹치나 한 시점에는 하나의 작업만이 실행된다.
  2. 병렬성의 경우, 둘 이상의 처리 장치를 활용하여 각각 독립적인 스레드가 병렬적으로 실행되는 경우를 가리킨다.
* **동시성은 둘 이상의 코드의 실행 시간이 겹칠 때 발생하며, 이를 위해서는 둘 이상의 실행 스레드가 필요**하다.
  * 이 때, 각 스레드들이 단일 코어에서 실행된다면 병렬성이 아닌 동시성이 발생한다.
  * 이 경우, 단일 코어는 서로 다른 스레드의 실행 명령을 교차 배치하여 스레드들의 실행 순서를 효율적으로 겹쳐서 활용한다.
* **병렬성은 둘 이상의 코드가 정확히 동시에 실행될 때 발생하며, 둘 이상의 물리적인 코어와 둘 이상의 스레드가 필요**하다.
  * 이로 인해 **병렬성은 동시성을 의미하지만, 동시성은 병렬성 없이도 발생할 수 있다**.

## 2023-07-19 Wed
### 코드의 병목
```
> 동시성이 꼭 좋은 것은 아니지만, 코드의 병목과 스레드 및 코루틴의 동작 원리 및 병렬성과 동시성의 차이를 이해하는 것으로 이를 언제 적용할지 판단할 수 있다.
```
* 코드 병목 중 CPU 바운드 작업의 경우, CPU만 완료되면 되는 작업을 중심으로 구현되는 알고리즘이 많다.
  * 또한, 이러한 작업은 CPU의 성능에 큰 영향을 받는다.
* 코드 병목 중 IO 바운드 작업의 경우, 실행 시간은 입출력 장치의 속도에 의존하므로 곧 입출력 장치에 의존하는 알고리즘이 된다.
  * 반면, 네트워킹 또는 주변기기로부터의 입력 역시 모두 IO 작업에 해당한다.
  * **IO 바운드 알고리즘은 IO작업을 기준으로 성능에 대한 병목을 발생시키며, 이 경우 최적화는 외부의 시스템이나 장치에 의존**하게 된다.

## 2023-07-20 Thu
### CPU 바운드 작업과 동시성
```
> CPU 바운드 알고리즘은 현재 사용 중인 장치의 코어 수를 기준으로 적절한 스레드 수가 생성되도록 충분히 고려할 경우, 작업 시간을 크게 줄일 수 있다.
```
* CPU 바운드 작업을 처리하는 알고리즘의 경우, 병렬성과 동시성은 코어의 개수에 따라 다음과 같은 특징을 갖는다.
  1. **다중 코어에서 병렬성을 활용하는 경우, 성능은 향상**될 수 있다.
  2. **단일 코어에서 동시성을 구현하는 경우, 성능은 저하**될 수 있다.
  3. 단일 코어에서 다수의 스레드를 사용하는 경우, 컨텍스트 스위칭에 의해 프로세스 전체적으로 봤을 때는 오버헤드가 클 수 있다.
* 코틀린의 경우, CPU 바운드 알고리즘의 처리를 위해 머신의 코어 수보다 하나 작은 스레드를 생성하는 스레드 풀인 `CommonPool`을 사용할 수 있다.

## 2023-07-21 Fri
### IO바운드 작업과 동시성
```
> IO 바운드 알고리즘은 순차 알고리즘에 비해 동시성 구현에서 항상 더 좋은 성능을 보일 것으로 예상할 수 있으므로, 항상 동시성을 적용하는 것이 바람직하다.
```
* IO바운드 작업을 처리하는 알고리즘은 끊임없이 작업 완료에 대해 대기하므로, 이러한 대기 시간을 기다리기보다 다른 작업을 실행하는 것이 이득이 될 수 있다.
  * 이러한 관점에서, **IO 바운드 작업을 처리하는 동시성 알고리즘은 코어의 개수에 따라 유사하게 수행**될 수 있다.

## 2023-07-22 Sat
### 동시성을 어렵게 하는 요인들
* 동시성 프로그래밍 자체가 어렵기도 하지만, 많은 언어들은 언어 자체의 특성으로 동시성을 더욱 어렵게 만들기도 한다.
  * 때문에 코틀린 팀은 동시성 프로그래밍을 더 단순화하면서도 여러 사용 사례에 맞춰 조절할 수 있도록 유연하게 만들고자 노력을 기울였다.
* 반면, 동시성 프로그래밍을 어렵게 하는 공통된 문제점들은 크게 다음과 같다.
  1. 레이스 컨디션: 동시성 코드가 항상 원하는 순서대로 실행될 것을 가정하고 오판한 경우에 발생하기 쉽다.
  2. 원자성 위반: 둘 이상의 코루틴이 동일한 데이터에 간섭하는 경우에 발생하기 쉽다.
  3. 교착 상태: 둘 이상의 스레드가 서로에 대해 대기하는 경우, 누구도 작업을 끝내지 못하는 상황에 발생한다.
  4. 라이브 락: 애플리케이션의 상태는 지속적으로 변화하나, 애플리케이션이 정상 동작할 수 없는 방향으로 상태가 변화해간다.
* 이 중, 라이브 락은 특히 교착 상태를 복구하도록 설계한 알고리즘에서 교착 상태를 복구하려는 시도로부터 기인하는 경우가 많다.

## 2023-07-23 Sun
### 코틀린과 동시성 - 논 블로킹
* 스레드는 무거우면서도 생성 비용이 크고, 제한된 수의 스레드만을 생성할 수 있도록 한다.
  * 또한, 스레드가 블로킹될 경우 이는 자원이 낭비되는 것과도 같다.
* 코틀린은 **`중단 가능한 연산`을 제공하며, 연산의 실행을 잠시 중단하는 것으로 스레드의 실행을 블로킹하지 않도록 한다**.
  * 예를 들어, 스레드 1의 작업이 끝나는 것을 스레드 2가 기다리는 대신 코드를 잠시 중단하고 스레드 2를 다른 연산에 활용한다.
* 나아가 코틀린은 채널이나 액터 및 상호 배제와 같은 기본형을 제공하여 동시성 코드들이 서로 효과적으로 통신하고 동기화할 수 있도록 지원한다.

## 2023-07-24 Mon
### 코틀린과 동시성 - 명시적인 선언과 가독성
* 동시성 프로그래밍은 난이도가 높으므로, 연산이 동시에 진행되어야 할 시점을 명시하는 것이 중요하다.
* 이러한 관점에서 **`중단 가능한 연산`은 기본적으로 순차적으로 실행되는 반면, 일시 중단된 시점에 스레드를 블로킹하지 않으므로 비용도 크지 않다**.
* 코틀린의 동시성 코드는 순차적인 코드만큼 가독성이 높으며, 이는 Java와 같이 동시성 코드를 이해하고 디버깅하기 어렵게 만드는 언어와는 큰 차별점이 된다.
  * 또한, 관례를 따라 동시에 실행될 함수는 async로 시작하거나 Async로 끝나는 이름을 명명하여 가독성을 더 끌어올릴 수 있다.
* 기본적으로 **비동기 함수를 작성하는 대신 `suspend` 함수를 작성하여 `async {}` 또는 `launch {}` 블록 안에서 호출하는 것이 바람직**하다.
  * 이는 **`suspend` 함수가 함수 호출자에게 더 많은 유연성을 제공하기 때문으로, 예를 들어 호출자는 동시적으로 실행할 시점을 결정**할 수 있다.

## 2023-07-25 Tue
### 코틀린과 동시성 - 기본형의 활용
* 스레드를 만들고 관리하는 것은 동시성 코드를 작성하는 과정에서 가장 어려운 부분 중 하나이며, 특히 언제 얼마나 많은 스레드를 만드는지 아는 것은 중요하다.
  * 나아가, **IO 바운드 작업용 스레드와 CPU 바운드 작업용 스레드를 구분하고 이들을 통신 또는 동기화시키는 것은 그 자체로 어렵다**.
* 이에 코틀린은 다음과 같이 동시성 코드를 쉽게 구현할 수 있도록 하는 고급 함수와 기본형들을 제공한다.
  1. `newSingleThreadContext`: 스레드를 생성하며, 생성된 후 필요한 만큼의 코루틴을 수행하는 데에 사용될 수 있다.
  2. `newFixedThreadPoolContext`: 크기를 매개 변수로 받아 스레드 풀을 쉽게 생성할 수 있다.
  3. `CommonPool`: CPU 바운드 작업에 최적인 스레드 풀을 생성하며, 최대 크기는 시스템 코어 개수로부터 1을 뺀 값과 같다.
* 또한 **코루틴을 다른 스레드로 이동시키는 것은 런타임이 직접 처리**하며, 이외에도 채널이나 뮤텍스 등 코루틴 통신과 동기화를 위한 많은 메커니즘을 제공한다.

## 2023-07-26 Wed
### 코틀린과 동시성 - 유연성
* 코틀린은 간단하면서도 유연하게 동시성을 사용할 수 있도록 돕는 다음과 같은 기본형을 제공한다.
  1. 채널: 코루틴 간에 데이터를 안전하게 송수신할 수 있도록 돕는 파이프를 의미한다.
  2. 워커 풀: 다수의 스레드로부터 연산 집합의 처리를 분할하기 위한 코루틴 풀을 의미한다.
  3. 액터: 채널과 코루틴을 사용하는 상태 자체를 감싸는 래퍼이며, 여러 스레드로부터 상태를 안전하게 수정하는 메커니즘을 제공한다.
  4. 뮤텍스: **크리티컬 존을 정의하여 한 번에 한 스레드만 실핼하는 동기화 매커니즘으로, 코루틴은 이전 코루틴이 존에서 나올 때까지 일시 정지**한다.
  5. 스레드 한정: 코루틴이 임의의 스레드에서만 실행되도록 제한하기 위한 기능을 의미한다.
  6. 제너레이터: **반복자 또는 시퀀스로, 필요에 따라 정보를 생성하거나 일시 중단될 수 있는 데이터 소스를 의미**한다.
* 이 때, **상술한 개념들은 코틀린에서 동시성 코드를 작성하는 과정에서 수시로 사용될 수 있으므로 동시성 구현 시 적절한 기본형을 결정하는 것이 중요**하다.
# Concurrency
## 2023-08-18 Fri
### 일시 중단 함수란?
* `launch()`나 `async()`, `runBlocking()`은 모두 코루틴 빌더이며 일시 중단 람다를 인자로 전달하는 식으로 사용된다.
* 반면, **함수 문법 앞에 `suspend` 예약어를 명시하는 것으로 함수를 일시 중단 가능케할 수도 있다**.
  * **일시 중단 함수는 `delay()`와 같은 다른 일시 중단 함수를 직접 호출할 수 있으며, 코드를 코루틴 빌더 안에 감싸지 않아도 되어 가독성을 향상**시킨다.
* **일시 중단 연산은 다른 일시 중단 연산 안에서만 호출될 수 있으며 이를 준수하지 않을 경우 컴파일조차 불가능**할 수 있다.
  * 때문에 **일시 중단 함수가 아닌 위치에서 일시 중단 함수를 호출하고자 하는 경우, 상술한 코루틴 빌더로 내부를 감싸주어야 한다**.

## 2023-08-19 Sat
### 비동기 함수와 일시 중단 함수의 비교
```
> 비동기 함수로 구현된 로직은 인터페이스가 디퍼드를 반환하도록 강제되며, 메소드 호출자가 불필요하게 일시 중단을 신경써야 한다.
> 반면, 일시 중단 함수의 경우 인터페이스가 디퍼드에 의존할 필요가 없으며 오로지 일시 중단 연산과 반환할 데이터에만 신경쓸 수 있다. 
```
* **비동기 함수의 경우, 디퍼드를 포함한 작업을 반환하므로 일시 중단을 위해서는 반드시 `join()` 또는 `await()` 메소드의 호출이 필수적**이다.
  * 때문에 비동기 함수는 항상 호출자가 이를 직관적으로 이해할 수 있도록 `Async`와 같은 키워드를 명시해야 할 필요가 있다.
  * 또한, **구현 자체가 디퍼드에 의존하게 되므로 다른 유형의 `Future`로 구현할 수 있을만한 확장성이 제한**된다.
* 반면, **일시 중단 함수를 사용할 경우 반환형에 `Deferred<T>`를 명시하지 않아도 되면서도 함수의 이름에 별도의 키워드를 명시할 필요도 없어진다**.
  * 이렇듯 일시 중단 함수는 비동기 함수에 비해 인터페이스가 간단해지며, 상세 구현을 노출하지 않아 `Future`를 지원하는 모든 라이브러리에 대응이 가능하다.
  * 예를 들어, **현재 스레드를 차단하지 않고 명시된 클래스의 인스턴스를 반환할 수 있다면 어떠한 `Future` 구현체도 사용이 가능**하다.

## 2023-08-20 Sun
### 일시 중단 함수를 사용해야하는 경우
* 일반적으로, **구현체가 디퍼드와 작업에 의존하는 것을 지양하는 것이 바람직하므로 일시 중단 함수를 사용**한다.
* 인터페이스 또는 추상 함수 등을 정의하는 경우에도 항상 일시 중단 함수를 사용한다.
* `public`과 같이 가시성이 높은 함수일수록 일시 중단 함수를 사용한다.
  * 바꿔 말해, **디퍼드나 작업에 의존하는 코드를 최대한 제한하기 위해 비동기 함수는 `internal` 또는 `private` 함수로만 정의하는 것이 바람직**하다.

## 2023-08-21 Mon
### 코루틴 컨텍스트와 디스패쳐
```
> 코루틴 컨텍스트는 코루틴이 어떻게 실행되고 동작할지 정의할 수 있도록 하는 요소'들'의 그룹이며, 모든 코루틴은 항상 코루틴 컨텍스트 안에서 실행된다.
```
* **디스패쳐는 컨텍스트의 구성 요소로서, 코루틴이 시작되거나 일시 중단 후 재개될 스레드를 결정**한다.
* 예를 들어, `CommonPool`은 CPU 바운드 작업을 위해 자동 생성되는 스레드 풀을 의미한다.
  * **기본 디스패쳐는 초기에는 `CommonPool`이었으며, 이러한 기본 디스패쳐는 코루틴 빌드시 명시적으로 디스패쳐를 전달할 필요가 없다**.
  * 반면, 그럼에도 기본 디스패쳐를 명시하고자 하는 경우 `GlobalScope.launch(Dispatchers.Default) { ... }`와 같이 명시한다.
* `Unconfined`의 경우, 첫 중단 지점에 도달할 때까지 현재 스레드의 코루틴을 실행하며 일시 중지된 후에는 기존 스레드에서 재개된다.
  * 다시 말해 호출 스레드에서 첫 번째 중단점까지는 반드시 실행하나, 일시 중단 연산이 재개되는 경우에 재개한 스레드에서 실행된다.
* `newSingleThreadContext`를 사용할 경우, 언제나 코루틴이 특정한 스레드 안에서만 실행될 것임을 보장할 수 있다.
* **`newFixedThreadPoolContext`를 사용할 경우, 스레드 풀을 가진 상태에서 시작하여 가용한 스레드에서 코루틴을 시작하거나 재개**한다.
  * 또한, **해당 디스패쳐의 경우 런타임이 가용 스레드를 결정하고 부하 분산 역시 전담하므로 개발자가 별도로 수행할 작업은 없다**.
# Concurrency
## 2023-08-18 Fri
### 일시 중단 함수란?
* `launch()`나 `async()`, `runBlocking()`은 모두 코루틴 빌더이며 일시 중단 람다를 인자로 전달하는 식으로 사용된다.
* 반면, **함수 문법 앞에 `suspend` 예약어를 명시하는 것으로 함수를 일시 중단 가능케할 수도 있다**.
  * **일시 중단 함수는 `delay()`와 같은 다른 일시 중단 함수를 직접 호출할 수 있으며, 코드를 코루틴 빌더 안에 감싸지 않아도 되어 가독성을 향상**시킨다.
* **일시 중단 연산은 다른 일시 중단 연산 안에서만 호출될 수 있으며 이를 준수하지 않을 경우 컴파일조차 불가능**할 수 있다.
  * 때문에 **일시 중단 함수가 아닌 위치에서 일시 중단 함수를 호출하고자 하는 경우, 상술한 코루틴 빌더로 내부를 감싸주어야 한다**.

## 2023-08-19 Sat
### 비동기 함수와 일시 중단 함수의 비교
```
> 비동기 함수로 구현된 로직은 인터페이스가 디퍼드를 반환하도록 강제되며, 메소드 호출자가 불필요하게 일시 중단을 신경써야 한다.
> 반면, 일시 중단 함수의 경우 인터페이스가 디퍼드에 의존할 필요가 없으며 오로지 일시 중단 연산과 반환할 데이터에만 신경쓸 수 있다. 
```
* **비동기 함수의 경우, 디퍼드를 포함한 작업을 반환하므로 일시 중단을 위해서는 반드시 `join()` 또는 `await()` 메소드의 호출이 필수적**이다.
  * 때문에 비동기 함수는 항상 호출자가 이를 직관적으로 이해할 수 있도록 `Async`와 같은 키워드를 명시해야 할 필요가 있다.
  * 또한, **구현 자체가 디퍼드에 의존하게 되므로 다른 유형의 `Future`로 구현할 수 있을만한 확장성이 제한**된다.
* 반면, **일시 중단 함수를 사용할 경우 반환형에 `Deferred<T>`를 명시하지 않아도 되면서도 함수의 이름에 별도의 키워드를 명시할 필요도 없어진다**.
  * 이렇듯 일시 중단 함수는 비동기 함수에 비해 인터페이스가 간단해지며, 상세 구현을 노출하지 않아 `Future`를 지원하는 모든 라이브러리에 대응이 가능하다.
  * 예를 들어, **현재 스레드를 차단하지 않고 명시된 클래스의 인스턴스를 반환할 수 있다면 어떠한 `Future` 구현체도 사용이 가능**하다.
# Concurrency
## 2023-09-12 Tue
### 원자성이란?
```
> 소프트웨어 실행적인 관점에서, 어떠한 연산이 단일하면서도 분할할 수 없는 경우에 원자성을 갖는다고 표현한다.
```
* 변수의 상태를 수정하는 것은 다음과 같은 여러 단계를 갖기에 원자적이지 못하다.
    1. 변수의 값을 조회한다.
    2. 변수의 값을 수정한다.
    3. 수정된 값을 변수에 저장한다.
* 예를 들어, 임의의 스레드가 현재 값을 변경하려는 도중에 다른 스레드가 변경 전의 값을 조회하는 경우 변경 사항 일부가 유실될 수 있다.
    * 나아가 이러한 동시성 오류는 식별하거나 재현하기 어려운 특정한 상황에서만 발생할 수도 있는 특징을 갖기도 한다.
* 때문에 코드 블록을 원자적으로 만들기 위해서는 일정한 블록 안에서 발생할 수 있는 어떠한 메모리 접근도 동시에 실행되지 않도록 보장할 수 있어야 한다.

## 2023-09-13 Wed
### 원자성 위반이란?
```
> 동시성 애플리케이션의 경우, 공유된 상태를 수정하는 일련의 코드가 다른 스레드의 변경 시도가 겹칠 수 있기에 원자성 위반이 발생하기 쉽다
```
* 원자성 위반이란 적절한 동기화 없이 객체의 상태를 동시에 수정하는 경우에 발생할 수 있으며, 일부 수정 사항이 유실되는 결과를 낳는다.
  * 예를 들어, 여러 다른 스레드에 위치한 코루틴이 동일한 객체의 상태를 수정하고자 하는 경우에 발생할 수 있다.
  * 즉, 공유 상태에 관한 언급에 있어 원자성 위반은 여러 스레드에서 단일 변수를 읽거나 쓰는 상황에 발생하기 쉽다.
* **코틀린 역시 이러한 원자성 위반이 발생할 수 있으나, 코틀린은 이러한 오류 상황을 회피할 수 있도록 지원하는 여러 기본형을 제공**한다.

## 2023-09-14 Thu
### 스레드 한정하기
```
> 상태가 여러 스레드에서 공유될 때 원자성 위반이 발생하므로, 이를 해결하는 가장 간단한 방법은 모든 코루틴이 단일 스레드에서 실행하도록 강제하는 것이다. 
```
* **`newSingleThreadContext()`와 같은 코루틴 컨텍스트를 통해 공유 상태에 접근하는 모든 코루틴이 단일 스레드에서 실행되도록 한정**할 수 있다.
  * 바꿔 말해 상태는 더 이상 스레드 간에 공유되지 않으며, 오직 하나의 스레드만이 상태를 수정할 수 있게 된다.
* 이 때, 스레드 한정은 모든 코루틴이 동일한 스레드에서 상태를 수정할 때 애플리케이션의 성능에 부정적인 영향을 주지 않는 경우에 유용하다.

## 2023-09-15 Fri
### 액터란?
```
> 액터는 임의의 스레드에 한정된 코루틴이므로, 모든 수정은 원자적일 수 있다.
> 액터의 경우 통신 대상 액터 인스턴스가 존재하는 이상, 애플리케이션 곳곳에서 해당 액터를 호출할 수 있다는 장점을 갖는다.
```
* 스레드 한정은 간단한 시나리오에 적합하지만, 원자 블록에 더 높은 유연성을 원하는 등 복잡한 시나리오에서는 더욱 확장될 필요가 있다.
* 이 때, **스레드 한정이라는 개념을 기반으로 동시성 기본 요소 중 하나인 채널을 혼합한 솔루션인 `액터`를 활용**할 수 있다.
  * 이러한 **두 가지 강력한 도구의 조합인 액터는 상태에 대한 접근을 단일 스레드로 한정하되, 다른 스레드는 채널로 상태 수정을 요청하는 식으로 동작**한다.
  * 때문에 이러한 액터를 활용하면 값을 안전하게 수정하면서도 강력한 상호 작용 방식을 갖출 수 있다.
* 또한 액터는 `actor<T>(코루틴_컨텍스트) { // ... }`와 같은 간단한 형태로 쉽게 생성할 수 있다.
  * 이 경우 액터는 타입 변수 `T`에 명시된 메시지 인스턴스를 채널로 전달받을 수 있다.
  * 나아가 이렇게 전달 받은 메시지는 람다 내부에서 `for (msg in channel) { //... }`과 같은 형태로 활용이 가능하다.
# Concurrency
## 2023-09-12 Tue
### 원자성이란?
```
> 소프트웨어 실행적인 관점에서, 어떠한 연산이 단일하면서도 분할할 수 없는 경우에 원자성을 갖는다고 표현한다.
```
* 변수의 상태를 수정하는 것은 다음과 같은 여러 단계를 갖기에 원자적이지 못하다.
    1. 변수의 값을 조회한다.
    2. 변수의 값을 수정한다.
    3. 수정된 값을 변수에 저장한다.
* 예를 들어, 임의의 스레드가 현재 값을 변경하려는 도중에 다른 스레드가 변경 전의 값을 조회하는 경우 변경 사항 일부가 유실될 수 있다.
    * 나아가 이러한 동시성 오류는 식별하거나 재현하기 어려운 특정한 상황에서만 발생할 수도 있는 특징을 갖기도 한다.
* 때문에 코드 블록을 원자적으로 만들기 위해서는 일정한 블록 안에서 발생할 수 있는 어떠한 메모리 접근도 동시에 실행되지 않도록 보장할 수 있어야 한다.

## 2023-09-13 Wed
### 원자성 위반이란?
```
> 동시성 애플리케이션의 경우, 공유된 상태를 수정하는 일련의 코드가 다른 스레드의 변경 시도가 겹칠 수 있기에 원자성 위반이 발생하기 쉽다
```
* 원자성 위반이란 적절한 동기화 없이 객체의 상태를 동시에 수정하는 경우에 발생할 수 있으며, 일부 수정 사항이 유실되는 결과를 낳는다.
  * 예를 들어, 여러 다른 스레드에 위치한 코루틴이 동일한 객체의 상태를 수정하고자 하는 경우에 발생할 수 있다.
  * 즉, 공유 상태에 관한 언급에 있어 원자성 위반은 여러 스레드에서 단일 변수를 읽거나 쓰는 상황에 발생하기 쉽다.
* **코틀린 역시 이러한 원자성 위반이 발생할 수 있으나, 코틀린은 이러한 오류 상황을 회피할 수 있도록 지원하는 여러 기본형을 제공**한다.

## 2023-09-14 Thu
### 스레드 한정하기
```
> 상태가 여러 스레드에서 공유될 때 원자성 위반이 발생하므로, 이를 해결하는 가장 간단한 방법은 모든 코루틴이 단일 스레드에서 실행하도록 강제하는 것이다. 
```
* **`newSingleThreadContext()`와 같은 코루틴 컨텍스트를 통해 공유 상태에 접근하는 모든 코루틴이 단일 스레드에서 실행되도록 한정**할 수 있다.
  * 바꿔 말해 상태는 더 이상 스레드 간에 공유되지 않으며, 오직 하나의 스레드만이 상태를 수정할 수 있게 된다.
* 이 때, 스레드 한정은 모든 코루틴이 동일한 스레드에서 상태를 수정할 때 애플리케이션의 성능에 부정적인 영향을 주지 않는 경우에 유용하다.

## 2023-09-15 Fri
### 액터란?
```
> 액터는 임의의 스레드에 한정된 코루틴이므로, 모든 수정은 원자적일 수 있다.
> 액터의 경우 통신 대상 액터 인스턴스가 존재하는 이상, 애플리케이션 곳곳에서 해당 액터를 호출할 수 있다는 장점을 갖는다.
```
* 스레드 한정은 간단한 시나리오에 적합하지만, 원자 블록에 더 높은 유연성을 원하는 등 복잡한 시나리오에서는 더욱 확장될 필요가 있다.
* 이 때, **스레드 한정이라는 개념을 기반으로 동시성 기본 요소 중 하나인 채널을 혼합한 솔루션인 `액터`를 활용**할 수 있다.
  * 이러한 **두 가지 강력한 도구의 조합인 액터는 상태에 대한 접근을 단일 스레드로 한정하되, 다른 스레드는 채널로 상태 수정을 요청하는 식으로 동작**한다.
  * 때문에 이러한 액터를 활용하면 값을 안전하게 수정하면서도 강력한 상호 작용 방식을 갖출 수 있다.
* 또한 액터는 `actor<T>(코루틴_컨텍스트) { // ... }`와 같은 간단한 형태로 쉽게 생성할 수 있다.
  * 이 경우 액터는 타입 변수 `T`에 명시된 메시지 인스턴스를 채널로 전달받을 수 있다.
  * 나아가 이렇게 전달 받은 메시지는 람다 내부에서 `for (msg in channel) { //... }`과 같은 형태로 활용이 가능하다.

## 2023-09-16 Sat
### 액터에 전달할 수 있는 추가 정보들
```
> 클라이언트 관점에서 액터는 단순한 송신 채널에 지나지 않지만, 구현 관점에서는 액터에 여러 정보를 전달하여 동작 방식을 세세하게 조절할 수 있다.
```
* **액터는 여타 송신 채널과 마찬가지로 버퍼링될 수 있으나, 기본적으로 모든 액터는 버퍼링되지 않는다**.
  * 때문에 **메시지가 수신될 때까지 송신자는 `send()` 메소드 호출 지점에서 일시 중단**된다.
* 반면, **`actor<T>(capacity = 10) { // ... }`과 같은 형태로 빌더에 용량 정보를 전달하는 것으로 버퍼링된 액터를 생성**할 수 있다.
* **액터는 또한 빌더에 코루틴 컨텍스트를 전달할 수 있으며, 이 경우 액터의 일시 중단 람다는 주어진 컨텍스트 하에서 실행**될 수 있다.
* 또한, `actor<T>(start = CoroutineStart.LAZY) { // ... }`와 같은 형태로 액터의 시작 시점을 조절하는 식으로 동작을 변경시킬 수도 있다.
  * **기본적으로 액터는 생성 즉시 시작되나, 상술한 경우에서의 액터는 메시지를 최초로 수신하는 시점에서야 비로소 시작**될 수 있다.

## 2023-09-17 Sun
### 상호 배제란?
```
> 스레드 한정은 코드 상의 모든 매모리 접근이 단일 스레드에서 발생하도록 보장하는 것으로 원자성 위반을 회피한다. 
> 반면, 상호 배제(=뮤텍스)는 코드 블록을 동기화하여 한 번에 하나의 코루틴만 코드 블록을 실행할 수 있도록 보장하는 동기화 메커니즘에 해당한다.
```
* **코틀린 뮤텍스는 블록되지 않으며, 실행 대기 중인 코루틴은 잠금을 획득하여 코드 블록을 실행할 수 있을 때까지 일시 중단**된다.
  * 이 때, 코루틴이 일시 중단 되지만 일시 중단 함수를 사용하지 않고서도 뮤텍스를 잠글 수 있다.
* 이러한 뮤텍스는 단지 `Mutex()`와 같은 형태로 인스턴스를 생성하여 사용할 수 있다.
  * 일반적으로, 생성된 **뮤텍스 인스턴스를 통한 잠금을 활용하여 람다를 실행하는 일시 중단 함수인 `withLock { // ... }`을 사용**한다.
  * 이를 통해 **한 번에 하나의 코루틴만 잠금을 갖고, 잠금을 시도하는 다른 코루틴은 일시 중단하여 동기화**할 수 있게 된다.
* 이러한 특징으로 인해, 상호 배제 메커니즘을 활용할 경우 스레드와 무관하게 정상적으로 동작해야하므로 코루틴 컨텍스트를 설정하지 않을 수 있다.

## 2023-09-18 Mon
### lock()과 unlock()
* 일반적으로 `withLock()`을 활용한 상호 배제로 충분하지만, 더 상세한 제어를 위해서는 `lock()`과 `unlock()`을 사용할 수 있다.
  * 이 때, `lock()`은 일시 중단 함수인 반면 `unlock()`은 일반 함수에 해당한다.
* 상술한 두 함수를 사용하여 다음과 같은 코드를 작성할 경우, `withLock()`과 유사한 메커니즘을 구현할 수 있게 된다.
```kotlin
val mutex = Mutex()
mutex.lock() // 다른 코루틴에 의해 이미 잠금이 획득된 경우, 이 시점에서 일시 중단된다.
/* 
 * ...do something
 */
mutex.unlock() // unlock은 일반 함수이므로, 이 시점에서는 일시 중단되지 않는다.
```
* 반면, 뮤텍스 인스턴스가 제공하는 `isLocked` 프로퍼티를 활용하여 인스턴스의 잠금 여부를 확인할 수 있다.
* 비슷한 논리에서, 뮤텍스에 대해 잠금을 시도한 후 성공 여부를 반환하는 일반 함수인 `tryLock()`을 사용할 수도 있다.
  * 예를 들어, `tryLock()`은 뮤텍스를 잠글 수 있는 경우에 `true`를 반환하고 그렇지 않은 경우에는 `false`를 반환한다.
* **일반적으로는 안정성으로 인해 `withLock()` 활용이 권장되며, 이를 통해 동기화가 필요한 코드 블록이 완료되었을 때 잠금이 반환됨을 보장**할 수 있다.

## 2023-09-19 Tue
### 휘발성 변수란?
```
> 휘발성 변수는 일반적인 경우에 모든 원자성 위반 문제를 해결할 수는 없으나, 특수한 시나리오에서 스레드 간의 정보 공유를 위해 간단히 사용될 수 있다.
```
* JVM의 경우, 각 스레드는 비휘발성 변수의 캐시된 사본을 가질 수 있다.
  * 이 때, 캐시는 변수의 실제 값과 항상 동기화되지는 않으므로 어떤 스레드가 공유된 상태를 변경하면 캐시에 반영될 때까지 다른 스레드는 이를 확인할 수 없다.
* 반면, **`@Volatile` 어노테이션을 임의의 공유 상태에 명시하는 경우 변수의 변경 사항을 다른 스레드에 즉시 표시**할 수 있게 된다.
  * 이러한 어노테이션을 적절히 활용하는 것으로, 다른 스레드에서 값이 변경되자마자 변경사항에 대한 가시성을 확보할 수 있게 된다.
  * 반면, 해당 어노테이션은 휘발성을 보장하는 JVM의 기능을 사용하기에 `Kotlin/JVM` 이외의 플랫폼에서는 사용이 불가능하다.

## 2023-09-20 Wed
### 휘발성 변수가 유용하지 않은 경우
* 일반적인 원자성 위반은 두 개의 스레드가 공유 상태를 의미하는 변수의 값을 간발의 차로 조회하여, 그 결과로 인해 변경 사항의 일부가 유실되기 때문에 발생한다.
* 이 때, 이러한 상황은 일반적으로 다음과 같은 이유에서 발생할 수 있으며 **결과는 모두 동기화 부족으로 인한 데이터 변경 사항의 유실**로 이어진다.
  1. 스레드 A가 공유 상태를 조회하거나 수정하는 동안 스레드 B의 조회가 발생하는 경우: 두 스레드가 같은 데이터로 시작하여 동일한 작업을 시도할 수 있다.
  2. 스레드 A가 수정한 후 스레드 B가 조회했으나, 로컬 캐시가 갱신되지 않은 경우: 즉, 작업 순서는 정상적이나 스레드 B는 오래된 값으로 작업을 시작한다.
* 상술한 두 가지 시나리오를 전제로 했을 때, 휘발성 변수는 항상 최신 값을 유지하므로 두 번째 경우에 대해 안전성을 보장한다.
  * 반면, **두 스레드가 동일한 시점에 값을 조회하는 경우인 첫 번째 상황에서는 휘발성 변수로 인한 안전성을 보장받을 수 없다**.

## 2023-09-21 Thu
### 휘발성 변수가 유용할 수 있는 경우
* 휘발성 변수를 활용하여 안전성을 보장하기 위해서는 크게 다음과 같은 조건을 모두 만족해야 하며, 둘 중 하나라도 만족하지 않는 경우 다른 방식을 고려해야 한다.
  1. **변수 값의 변경은 현재 상태에 의존하지 않아야 한다**.
  2. **휘발성 변수는 다른 변수에 의존하지 않으며, 다른 변수 역시 휘발성 변수에 의존하지 않아야 한다**.
* 특히 두 번째 조건의 경우, 휘발성 변수의 의존성으로 인해 상태의 일관성이 보장되지 않는 상황을 회피하기 위해 필수적이다.
* 상술한 두 조건을 모두 만족할 경우 휘발성 변수를 활용할 수 있으며, 대표적으로는 플래그를 예로 들 수 있다.

## 2023-09-22 Fri
### 원자적인 데이터 구조
* 상술한 원자적인 코드 블록을 작성하는 방법 이외에도, 코틀린은 기본적으로 증가 또는 감소 등에 대해 원자적인 연산을 제공하는 원자적 데이터 구조를 지원한다.
  * 예를 들어, `Integer`와 달리 원자적 데이터 구조인 `AtomicInteger`에 대한 연산은 원자적이다.
  * 이 때, 원자적 데이터 구조 역시 JVM 차원에서 제공되는 기능이므로 `Kotlin/JVM` 이외의 플랫폼에서는 사용이 불가능하다.
* **원자적 데이터 구조는 `AtomicLong` 또는 `AtomicIntegerArray`와 같이 다양하지만, 공유 상태가 복잡해질수록 확장이 잘 되지 않는 경향**을 보인다.
  * 다시 말해, 단순한 경우에는 유용히 사용될 수 있으나 공유되는 상태가 하나 이상의 여러 변수로 구성되는 경우에는 확장이 어려워질 수 있다.
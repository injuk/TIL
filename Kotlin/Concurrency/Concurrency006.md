# Concurrency
## 2023-09-04 Mon
### 동시성과 관련된 문제들
* 동시성과 관련된 수 많은 오류는 대부분 서로 다른 스레드 사이에서 메모리를 공유할 때 발생한다.
  * 예를 들어, 다른 스레드에 의해 객체의 상태가 변경되는 경우에 문제가 발생하기 쉽다.
  * 익히 알려진 데드락이나 레이스 컨디션 및 원자성 위반 등의 현상 역시 상태가 공유되는 것과 깊은 관련이 있다.
* 이러한 **메모리 공유는 방탄 동기화를 필요로 하지만, 적절한 방탄 동기화를 작성하는 것은 보기보다 매우 어려운 축**에 속한다.
* **코틀린이나 고 등의 최신 언어들은 이러한 동시성 문제를 극복하기 위해 스레드 간에 메시지를 주고 받을 수 있는 채널 개념을 제공**한다.
  * 즉, **채널은 스레드들이 서로의 상태를 공유하는 대신에 메시지를 주고 받는 통신을 하도록 유도하여 안전한 동시성 코드에 도움**을 준다.

## 2023-09-05 Tue
### 채널이란?
```
> 채널은 실행 중인 스레드와는 관계 없이, 서로 다른 코루틴이 메시지를 안전하게 보내고 수신할 수 있도록 하는 일종의 파이프라인이다.
```
* **채널은 동시성 코드 사이에서 서로 안전한 통신이 가능하도록 돕는 도구이며, 동시성 코드들이 서로에게 메시지를 보내 통신할 수 있도록 지원**한다.

## 2023-09-06 Wed
### 채널과 배압(backpressure)
```
> 배압은 임의의 구성 요소가 부하를 이겨낼 수 없다고 판단될 때, 상위 요소들에게 자신이 과부하 상태라는 것을 알리는 피드백 방식을 의미한다.
```
* 채널이 제공하는 `send()` 함수는 실제로 데이터를 수신하는 객체가 있을 때까지 전송을 일시 중지할 수 있도록 일시 중단 함수로서 제공된다.
* 이는 곧 **배압이라고도 하며, 배압을 통해 수신 객체가 실제로 처리할 수 있는 양보다 더 많은 요소들로 채널이 넘치지 않을 수 있다**.
  * 이러한 **배압을 구성하기 위해 채널에 대해 버퍼를 정의할 수 있으며, 채널에 데이터를 전송하는 코루틴은 버퍼가 가득 찰 경우에 일시 중단**된다.
  * 반면, **채널에서 요소가 제거되어 버퍼가 빌 경우 송신자는 즉지 재개되는 식으로 동작**한다.

## 2023-09-07 Thu
### 언버퍼드 채널이란?
* 언버퍼드 채널은 버퍼가 없는 채널을 의미하며, `RendezvousChannel`과 같은 구현체를 갖는다.
  * 언버퍼드 채널은 상술한 구현체의 생성자를 호출하거나, `Channel()` 함수에 아무런 인자를 전달하지 않는 식으로 인스턴스화할 수 있다.
* 이러한 **언버퍼드 채널은 말 그대로 버퍼를 전혀 갖지 않으므로, 채널에서 `send()`를 호출하면 리시버가 `receive()`를 호출하기 전까지 일시 중지**된다.

## 2023-09-08 Fri
### 버퍼드 채널이란?
* 말 그대로 **버퍼를 갖는 채널인 버퍼드 채널은 채널 안에 존재하는 요소의 수가 버퍼의 크기와 같아지는 시점에 송신자의 실행을 중지하는 식으로 동작**한다.
* 이 때, 버퍼드 채널은 크게 다음과 같은 서로 다른 구현체들을 갖는다.
  1. `LinkedListChannel`: 중단 없이 무한의 요소를 전송할 수 있도록 지원하는 채널로, 어떠한 송신자도 중단하지 않는 방식으로 동작한다.
  2. `ArrayChannel`: 버퍼의 크기를 `0 ~ (int.MAX_VALUE - 1)`까지 지정할 수 있으며, 요소의 수가 버퍼의 크기와 같아질 때 송신자를 일시 중지한다.
  3. `ConflatedChannel`: 버퍼가 하나의 요소만을 갖되, 다른 요소가 전송되면 기존 요소를 덮어 쓰는 식으로 동작하므로 송신자를 일시 중지하지 않는다.
* 이 때, `LinkedListChannel`은 그 특성상 메모리를 과하게 점유할 수 있으므로 사용을 지양하되 다른 버퍼드 채널을 선택하는 것이 바람직하다.
* 반면, `ConflatedChannel` 버퍼는 새로운 요소가 계속해서 기존 요소를 덮어 쓰는 방식으로 동작하므로 데이터가 유실되도 무방한 상황이 전제된다.

## 2023-09-09 Sat
### 채널에 요소를 전송하기
* 채널의 동작은 기본적으로 `SendChannel<T>`과 `ReceiveChannel<T>`라는 두 인터페이스로 구성되며, 채널과의 상호작용을 위해 이를 사용할 수 있다.
  * 예를 들어, 채널에 요소를 전송하기 위해 `SendChannel` 인터페이스로부터 제공되는 몇 가지 메소드를 활용해볼 수 있다.
* 채널에 요소를 전송하기 전에 채널의 상태를 검증할 수 있도록 다음과 같은 메소드를 사용할 수 있다.
  1. `isClosedForSend`: 채널의 프로퍼티로서, 채널이 닫혔는지 아닌지 그 여부를 반환한다.
  2. `isFull`: **채널의 용량이 부족한지 확인하기 위해 사용할 수 있는 프로퍼티이며, 현재 코루틴을 중단하고 싶지 않은 경우에 유용하게 사용**할 수 있다.
* 반면, 채널에 요소를 전송하고자 하는 경우 상술한 `send()` 메소드를 사용할 수 있으며 이는 기본적으로 일시 중단 함수로서 제공된다.
  * 예를 들어, 버퍼드 채널이 가득 찬 경우 송신자를 일시 중단하는 반면 `RendezvousChannel`의 경우 `receive()`가 호출되기 전까지 일시 중단된다.
  * 또한, 닫힌 채널에 대한 `send()` 요청은 `ClosedChannelException` 예외가 던져진다.
* 특수한 경우에 일시 중단 연산이 아닌 방식으로 요소를 전송하기 위해서는 `offer()`를 사용하며, 해당 메소드는 채널의 상태에 따라 다음과 같이 동작한다.
  1. 채널이 닫힌 경우: 즉, `isClosedForSend`가 `true`를 반환하고 있는 경우이며 `ClosedSendChannelException` 예외가 던져진다.
  2. 채널이 열려 있지만 가득 찬 경우: `false`를 반환한다.
  3. 채널이 열려 있고 가득 차지 않은 경우: 인자로 전달된 요소를 대기열에 추가하며, `true`를 반환한다.

## 2023-09-10 Sun
### 채널의 요소를 조회하기
* `ReciveChannel`은 채널을 조회하는 경우에 발생할 수 있는 예외를 회피할 수 있도록, 다음과 같은 유효성 검증 프로퍼티를 제공한다.
  1. `isClosedForReceive`: **수신에 대해 채널이 닫혀 있는지 여부를 확인하기 위해 사용 가능한 프로퍼티에 해당**한다.
  2. `isEmpty`: **채널이 요소를 추가적으로 수신할 수 있는지 여부를 확인하기 위해 사용 가능한 프로퍼티에 해당**한다.
* 이 때, `isClosedForReceive`가 `true`인 채널에 대해 `receive()`를 호출할 경우 `ClosedReceiveChannelException` 예외가 던져진다.
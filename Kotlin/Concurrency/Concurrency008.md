# Concurrency
## 2023-09-24 Sun
### 동시성 코드 작성의 어려움
* 동시성 코드를 작성하는 과정에서 가장 어려운 부분 중 하나는 버그를 발견하고, 이를 디버깅하는 데에 있다.
  * 이러한 버그들은 대부분 개발 과정의 후반부에 발견되곤 하며, 최악의 경우 운영 환경에서야 처음으로 발견될 수도 있다.
* 동시성과 관련된 대부분의 버그는 실제로 발생할 가능성이 없다고 생각하거나, 확률이 너무 낮은 케이스에서 발견되곤 한다.
  * 이 때, 이렇듯 발견이나 재현이 어려운 경우를 가리켜 엣지 케이스라고 지칭할 수 있다.

## 2023-09-25 Mon
### 동시성 테스트 코드 작성의 기본
* 동시성 테스트 코드를 작성할 경우, 다음과 같은 두 가지 원칙을 반드시 기억해두어야 한다.
  1. 가정을 버리기: 실제로는 **일어나지 않을 것 같은 상황이더라도, 적어도 테스트를 작성할 때만은 이를 고려하여 도전적으로 작성하는 것이 바람직**하다.
  2. 나무보다 숲을 보기: 여러 기본 단위를 검증하는 것도 좋지만, **동시성 테스트에서는 예상치 못한 상황 역시 모두 테스트하는 것이 바람직**하다.
* **상술한 원칙을 준수하기 위해서는 단위 테스트 뿐만 아니라 기능 테스트에도 집중하게 되며 각 기능 별 전체 동작을 테스트하는 코드를 작성**해야 한다.
  * 특히, 이러한 **기능 테스트는 각 기능을 전체적으로 실행하여 애플리케이션이 비동기 작업을 수행할 때 발생하는 복잡성을 테스트로 잘 표현**할 수 있다.
  * 바꿔 말해 기능 테스트를 작성하지 않은 동시성 애플리케이션은 취약점을 내포할 수 밖에 없으며, 코드를 수정할 때마다 원자성 위반 등의 현상이 발생하기 쉽다.

## 2023-09-26 Tue
### 동시성 테스트 코드 작성시 더 고려할 것들
```
> 애플리케이션의 안전성을 보장하는 유일한 방법은 정확한 테스트를 작성하고, 수행하는 것이다.
```
* 버그에 대한 수정은 해당 버그가 재현될 수 있는 시나리오를 테스트로 함께 작성해야 하며, 수정에 대한 테스트를 작성하지 않는 코드는 다시 버그를 발생시킨다.
* 버그는 일반적으로 발생한 곳 뿐만 아니라 다른 곳에서도 존재할 가능성이 있으므로, 이러한 의심이 들 때마다 테스트를 작성하여 검증하는 것이 바람직하다.
  * 설령 **아직 버그가 발생하지 않았더라도, 미래에 발생할 것으로 의심되는 버그를 방지하기 위한 테스트를 추가**해두어야 한다.
  * 특히, 동시성 버그가 발생한 경우에는 해당 버그가 애플리케이션의 다른 부분에 어떠한 형태로 영향을 줄 수 있을지도 항상 고려해야 한다.
* **동시성 작업을 테스트하는 목적은 모든 시나리오를 다루는 것은 아니며, 문제를 발생시킬 수 있는 값을 기반으로 한 도전적인 시나리오를 찾아나가는 것**이다.
* 구현에 앞서 반드시 복원력을 고려하는 것이 바람직하므로, 사후에 예외 처리를 추가하기 보다는 사전에 작성하는 것이 권장된다.
* 엣지 케이스를 찾아내기 위해서는 커버리지 보고서의 분기 분석을 활용할 수 있으며, 모든 테스트가 항상 동일한 경로로 실행되는지 확인하는 것이 바람직하다.
* 일반적으로, **기능 테스트는 단위 테스트보다 더 큰 노력을 들여야 하므로 실제로 그 가치가 있을 때에만 작성하고 수행하는 것이 바람직**하다.
* 테스트 코드 역시 인터페이스를 활용하여 종속성을 연결하는 것이 바람직하며, 이를 통해 기능 테스트를 위한 모킹이 더 쉬워질 수 있다.

## 2023-09-27 Wed
### 코루틴 디버깅하기
* 코루틴 내부에서 발생한 오류를 디버그하기 위해 `println()` 등을 활용한 원시적인 로깅을 활용해볼 수 있다.
  * 이러한 방식은 간단히 구현할 수 있으나, 코루틴이 일정 개수 이상이거나 코루틴 별로 고유한 식별자로 사용할만한 것이 없다면 식별이 어려운 단점을 갖는다.
* 이 때, 상술한 단점을 보완하기 위해 디버그 과정에서 각각의 코루틴을 식별하기 위해 JVM 플래그인 `-Dkotlinx.coroutines.debug`를 활용할 수 있다.
  * 이 경우, **코틀린은 현재 `Thread.currentThread().name`과 같은 방식으로 스레드의 이름 요청할 때 코루틴마다 고유한 식별자를 부여**한다.
  * 또한, 이러한 플래그는 개발과 테스트 실행 단계에서는 계속해서 유지하는 것이 바람직하다.
* 반면, 상술한 방식과 같이 유동적인 코루틴 식별자를 할당하는 대신 명시적인 명명 역시 가능하다.
  * 이러한 방식은 **코루틴 빌더에 `CoroutineName("이름")`를 전달하여 사용할 수 있으며, 액터나 프로듀서처럼 오래 지속되는 코루틴에 대해 유용**하다.
  * 나아가 코루틴명 역시 컨텍스트 요소이므로 `withContext(pool + CoroutineName("이름")) { // ... }`와 같이 더하기 연산자를 적용할 수 있다.
  * 또한, 이러한 **코루틴의 명명은 액터나 프로듀서와 같이 오래 지속되는 코루틴에는 항상 명시적으로 설정하는 것이 권장**된다.

## 2023-09-28 Thu
### 애플리케이션의 복원력과 안정성
* 애플리케이션의 종류와 특성에 따라서는 설령 개발자가 사전에 예상했다고 하더라도 임의의 조건을 충족하지 않는다면 프로그램의 중단을 막을 수 없다.
  * 예를 들어, 모바일 애플리케이션의 경우 어떠한 경우든지 예외를 잘 처리하여 프로그램이 잘 복구될 것이 기대된다.
* 이러한 **애플리케이션의 복원력은 프로젝트의 초기부터 고려되어야 하며, 설계 단계에서 신중히 숙고**해야 한다.
  * 바꿔 말해, **디퍼드나 작업을 작성하는 시점에는 이를 검증하기가 어렵지 않으나 모든 기능을 개발한 후에 예외 처리를 추가하는 것은 어렵고 번거롭다**.
  * 이렇듯 **동시성 애플리케이션의 복원력은 사전에 계획한 후, 예상되는 동작을 실제로 충족시키는 방식으로 개발해 나가는 것이 바람직**하다.
* 반면, 이미 애플리케이션이 상당히 성숙한 상황이라면 이를 수정하기 전에 예상되는 동작을 검증하는 테스트가 있는지 우선 확인하는 것이 권장된다.
  * 이러한 기능 테스트는 최소한의 안전망으써, 임의의 기능에 대한 겉보기 동작이 변경 과정에서 유지되는 것을 보장할 수 있도록 지원한다.

## 2023-09-29 Fri
### 동시성 코드의 테스트 - 결론
```
> 애플리케이션의 안정성을 보장하는 유일한 방법은 제대로된 테스트를 작성하고, 이를 수행해보는 데에 있다.
```
* 동시성 코드를 테스트하는 경우에는 반드시 발생하지 않는 모든 상황에 대한 순진한 가정을 버리고, 기능 테스트를 작성하는 것이 바람직하다.
* 이미 발생한 버그를 수정하는 경우에는 반드시 이를 검증할 수 있는 테스트를 작성하고, 다른 곳에서도 재현될 수 있을지 확인하는 것이 바람직하다.
  * 나아가 애플리케이션의 복원력에 대한 요구사항 역시 설계와 테스트로 반영되어야 한다.
* 디버깅 난이도를 낮추기 위해서는 `-Dkotlinx.coroutines.debug`와 같은 플래그와 IDE의 지원을 적극적으로 활용하는 것이 권장된다.
  * 또한, 오래 지속되는 코루틴에는 적절한 이름을 명명하는 것 역시 고려할 수 있다.
  * 반면, 모든 코루틴을 테스트해야하는 경우에는 IDE가 지원하는 조건부 브레이크 포인트를 활용할 수 있다.
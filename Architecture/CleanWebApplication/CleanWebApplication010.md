# CleanWebApplication
## 2022-03-22 Tue

## 아키텍쳐의 경계를 강제하기
* 일정한 규모 이상의 모든 프로젝트에서는 시간이 지나며 프로젝트가 성숙함에 따라 아키텍쳐가 무너지기 쉽다.
* 계층 간의 경계는 약화되고, 테스트는 어려워지고, 새로운 기능을 구현하기도 어려워질 수 있다.

### 경계와 의존성
* **아키텍쳐의 경계를 강제하는 것은 의존성이 언제나 올바른 방향으로만 향할 수 있도록 강제하는 것**이다.
* 가장 안쪽의 계층은 도메인 엔티티이며, 애플리케이션 계층은 애플리케이션 서비스 내부에 유즈케이스를 구현하기 위해 이에 접근한다.
* 어댑터는 인커밍 포트를 통해 서비스에 접근하고, 서비스는 다시 아웃고잉 포트를 통해 어댑터를 호출한다.
* **가장 바깥 계층에는 어댑터와 서비스 객체를 생성하는 팩토리와 의존성 주입 메커니즘을 제공하는 설정 계층이 위치**한다.
* 이렇듯 인접한 계층 사이에는 명확한 경계가 존재하며, 계층 경계를 넘나드는 의존성은 의존성 규칙에 따라 방향이 정해진다.
```
> 의존성 규칙이란, 계층 경계를 넘는 모든 의존성이 항상 안 쪽 계층 방향을 향해야함을 의미한다.
```

### 접근 제한자를 사용하기
* 접근 제한자는 Java가 경계를 강제하기 위해 제공하는 가장 기본적인 도구이다.
* 접근 제한자에는 public, protected, private, package private이 존재하며, 특히 package private을 눈여겨볼만 하다.
  * **package private 접근 제한자는 Java의 패키지를 통해 클래스들을 응집적인 모듈로 만들어주기 때문에 매우 중요**하다.
* 모듈 내에 위치한 클래스들은 서로에게 접근 가능하지만 외부에서 접근할 수 없으므로 모듈의 응집도가 높아진다.
  * 외부로부터 진입이 필요한 경우, 모듈의 진입점으로 활용할 클래스만 public으로 정의한다.
* **접근 제한자를 적절히 사용하는 것으로 의존성이 잘못된 방향을 가리키며 의존성 규칙을 위반할 위험을 크게 줄일 수 있다**.
* package private 접근 제한자는 몇 개 정도의 클래스로만 구성된 작은 모듈에서 가장 효과적이다.
  * 반면, 클래스의 수가 어느 수준 이상을 넘어가면 하나의 패키지에 많은 클래스를 포함하는 것은 바람직하지 않을 수 있다.
* 패키지 하나에 너무 많은 클래스가 포함되는 경우, 코드를 쉽게 찾아낼 수 있도록 하위 패키지를 만들 수 있다.
* 그러나 Java는 하위 패키지를 별도의 패키지로 인식하므로, 상위 패키지의 멤버가 하위 패키지의 package private 멤버에 접근할 수 없다.
  * **때문에 부득이한 public 접근 제한자의 사용이 필수적이며, 이는 아키텍쳐가 의존성 규칙을 깰 수 있는 환경을 만들게 하는 단점**이 된다.

### 빌드 아티팩트
* 상술한 과정에서 아키텍쳐의 경계는 패키지로만 유일하게 구분지을 수 있었다.
* 빌드 아티펙태는 빌드 프로세스의 결과물이며, Java 생태계에서는 메이븐과 그래들이 가장 인기 있는 빌드 도구이다.
* 빌드 도구의 주요한 기능 중 하나는 의존성 해결이며, 어떤 코드베이스를 빌드 아티팩트로 변환하기 위해 빌드 도구는 다음과 같은 작업을 수행한다.
  1. 코드베이스가 의존하는 모든 아티팩트의 가용성을 확인한다.
  2. 사용 불가능한 의존성은 아티팩트 리포지토리로부터 가져오기 위해 페치를 시도한다.
  3. **상술한 과정이 실패하면 컴파일 이전에 빌드가 실패**한다.
* **이러한 특징을 활용하여 모듈과 아키텍쳐의 계층 간 의존성을 강제하는 것으로 경계 역시 강제할 수 있다**.
  * 예를 들어, 각 모듈 또는 계층에 대해 전용 코드베이스와, jar 파일과 같은 분리된 빌드 모듈인 빌드 아티팩트를 생성할 수 있다.
  * 각 모듈의 빌드 스크립트에서는 아키텍쳐에서 허용하는 의존성만을 지정하도록 한다.
* 이러한 방식을 따를 경우, **클래스들이 클래스패스에 존재하지 않는다면 컴파일 에러가 발생하므로 개발자들은 잘못된 의존성을 만들 수 조차 없게 된다**.
* **모듈을 세분화할수록 모듈 간 의존성을 더 쉽게 제어할 수 있지만, 더 많은 매핑 작업이 필요**하다.
* jar 파일과 같은 빌드 모듈을 통해 아키텍쳐 경계를 구분하는 것은 패키지로 구분하는 방식과 비교하여 다음과 같은 장점이 존재한다.
  1. 빌드 도구는 순환 의존성을 싫어하므로, 빌드 도구를 활용하면 빌드 모듈 간 순환 의존성이 없음을 확신할 수 있다.
     * 반면 Java 컴파일러는 두 개 혹은 그 이상의 패키지에서 발생하는 순환 의존성을 신경 쓰지 않는다.
  2. 빌드 모듈 방식은 다른 모듈을 신경쓰지 않고 임의의 모듈을 격리한 채로 변경할 수 있다.
     * 때문에 여러 개의 빌드 모듈은 각 모듈을 격리한 상태로 둘 수 있게 해준다.
     * 나아가, 각 모듈을 자체 리포지토리에 저장하여 서로 다른 팀이 유지보수하게 할 수 있다.
  3. **모듈 간 의존성이 빌드 스크립트에 명확하게 정의되므로, 새로운 의존성을 추가하는 일은 우연이 아닌 의식적인 행동이 될 수 있다**.
     * 팀원 중 한 명이 지금 당장 접근할 수 없는 클래스에 접근하고자 하는 경우에도 빌드 스크립트에 이를 명시하기 위해 다시 한 번 숙고하게 만든다.
* 반면, **빌드 스크립트를 유지보수하기 위한 비용 또한 수반되므로 아키텍쳐를 여러 빌드 모듈로 분할하기 전에 아키텍쳐가 안정된 상태임이 보장되어야 한다**.

### 아키텍쳐의 경계 강제와 유지보수 가능한 소프트웨어
* **기본적으로 소프트웨어 아키텍쳐는 아키텍쳐를 구성하는 요소 간의 의존성을 관리하는 것이 전부**이다.
  * 때문에 **아키텍쳐를 깨끗하게 유지하려면 의존성이 올바른 방향으로 향하는지 지속적으로 확인할 필요성이 있다**.
* 새로운 코드를 추가하거나 리팩토링하는 경우, 패키지 구조를 항상 염두에 두도록 한다.
  * 가능하다면 package private 접근 제한자를 적용하여 패키지 바깥으로부터의 부적절한 의존성이 발생하는 것을 방지한다.
* 하나의 빌드 모듈 안에서 경계를 강제하도록 한다. 
* 패키지 구조가 허용하지 않아 package private 접근 제한자를 사용할 수 없다면, ArchUnit과 같은 컴파일 후 체크 도구를 활용할 수 있다.
* **아키텍쳐가 충분히 안정적이라고 여겨지는 경우, 각 아키텍쳐 요소를 독립적인 빌드 모듈로 추출하여 관리**한다.
  * 이를 통해 의존성을 보다 분명하게 제어할 수 있게 된다.
* **아키텍쳐의 경계를 강제하고, 프로젝트가 성숙하면서도 유지보수성이 높은 코드를 작성하기 위해 상술한 방식 모두를 함께 조합하여 사용할 수도 있다**.
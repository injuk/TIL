# CleanWebApplication
## 2022-03-20 Sun

## 웹 어댑터의 구현
* 애플리케이션은 대부분 웹 브라우저를 통해 상호작용할 수 있는 UI나, 외부 시스템에서 애플리케이션을 호출할 수 있도록 HTTP API 등을 제공한다.
  * 이는 모두 웹 인터페이스에 해당한다.
* 또한 **육각형 아키텍쳐에서 외부 세계와의 모든 상호작용은 어댑터를 활용해야 하므로, 웹 인터페이스를 제공하는 것 역시 웹 어댑터의 형태**여야만 한다.

### 의존성의 역전
* **웹 어댑터는 인커밍 어댑터이며, 애플리케이션 서비스에 의해 구현된 인터페이스인 전용 인커밍 포트를 통해 애플리케이션 계층과 통신해야 한다**.
  * 즉, **웹 어댑터는 외부로부터 요청을 받아 애플리케이션의 코어를 호출하여 수행해야할 작업에 대해 알려주는 역할**을 한다.
* 애플리케이션 계층은 이러한 웹 어댑터가 통신할 수 있는 인커밍 포트를 제공해야 한다.
  * 애플리케이션 서비스는 인커밍 포트를 구현하고, 웹 어댑터는 인스턴스 멤버로서 인커밍 포트를 가져 이를 호출해야 한다.
* 이렇듯 **어댑터와 유즈케이스 사이에 포트라는 간접 계층을 작성해야하는 이유는, 애플리케이션 코어가 외부와 통신할 수 있는 지점의 명세가 포트이기 때문**이다.
  * 포트를 적절한 장소에 위치시킴으로써 외부와 어떤 통신이 발생하고 있는지 정확히 알 수 있다.
  * 그러나 웹 어댑터가 인커밍 포트를 생략하고 애플리케이션 서비스를 직접 호출하고 싶을 수도 있으며, 이는 추후에 다시 한 번 다루도록 한다.
* 반면, 애플리케이션 코어가 웹 소켓을 통해 브라우저로 능동적으로 정보를 전달하는 요구사항을 생각해볼 수 있다.
  * 이는 상호작용이 잦은 애플리케이션의 형태이며, 역시 별도의 포트가 반드시 필요하다.
  * **이러한 포트는 아웃고잉 포트로서 웹 어댑터에서 구현하고, 애플리케이션 코어에서 호출하는 형태로 작성되어야 한다**.
* **웹 어댑터는 인커밍 어댑터인 동시에 아웃고잉 어댑터일 수 있으며, 하나의 어댑터가 동시에 두가지 역할을 수행하지 못할 이유가 없다**.
  * 해당 요구사항에서, **웹소켓 컨트롤러는 웹소켓용 아웃고잉 포트를 구현하면서 인스턴스 멤버로서 유즈케이스를 사용하는 인커밍 포트 인터페이스를 호출**한다.

### 웹 어댑터의 책임
* 애플리케이션이 REST API를 제공한다면, 웹 어댑터의 책임은 일반적으로 다음과 같다.
  1. HTTP 요청을 Java 객체로 매핑 (역직렬화)
     * 웹 어댑터는 URL, 경로, HTTP 메소드, 콘텐츠 타입과 같은 사전 정의된 기준을 만족하는 HTTP 요청을 수신한 후, 이를 객체로 역직렬화해야 한다.
  2. 권한 검사
     * 일반적으로 웹 어댑터가 인증과 권한 부여를 수행하며, 실패시 에러를 반환해야 한다.
  3. 입력 유효성 검증
     * **유즈케이스 입력 모델 검증과 별도의 과정**이다.
     * 이 과정에서 **웹 어댑터는 입력 모델을 검증하며, 입력을 유즈케이스 입력으로 변환할 수 있다는 사실을 검증**해야 한다.
     * 이러한 변환이 불가능한 모든 경우에 대해 유효성 검증 에러를 반환해야 한다.
  4. 입력을 유즈케이스의 입력 모델로 매핑
  5. 매핑된 유즈케이스 입력 모델로 유즈케이스 호출
  6. 유즈케이스의 출력을 HTTP 응답으로 매핑 (직렬화)
  7. HTTP 응답을 반환
* **상술한 과정에서 한 군데라도 문제가 확인된다면 예외를 던지고, 웹 어댑터는 에러를 사용자에게 보여줄 메시지로 변환**해야 한다.
* 웹 어댑터는 HTTP 전반에서 발생할 수 있는 모든 문제를 검증해야하므로, 부여된 책임이 많다.
* 반면 **해당 책임은 애플리케이션 계층이 신경쓰지 말아야하는 것들이기도 하다**.
  * **외부에서 HTTP 계층과 관련된 처리를 수행한다는 사실을 애플리케이션 코어는 전혀 알지 못해야 한다**.
  * 이를 놓치게 된다면 또 다른 인커밍 어댑터의 요청에 대해 동일한 도메인 로직을 수행할 수 있는 선택지를 잃게 된다.
  * 좋은 아키텍쳐는 선택의 여지를 최대한 늦게까지 남겨두어야 한다.
* **웹 어댑터와 애플리케이션 사이의 경계는 웹 계층에서부터 개발을 시작하는 대신 도메인과 애플리케이션 계층부터 개발하는 경우에 자연스럽게 발생**하게 된다.
  * **임의의 인커밍 어댑터를 고려하는 것보다 앞서 유즈케이스를 구현하면 경계를 흐리게 만들 유혹에 빠지지 않는다**.

### 컨트롤러 나누기
* Spring 등의 웹 프레임워크에서는 상술한 책임을 수행할 수 있는 컨트롤러 클래스를 생성할 수 있다.
* 이러한 **컨트롤러는 반드시 하나일 필요는 없으며, 웹 어댑터는 하나 이상의 클래스로 구성해도 무방**하다.
  * 오히려 너무 적은 것보다는 너무 많은 것이 좋으며, 각 컨트롤러는 가능한 한 좁아야 한다.
  * **웹 어댑터는 각각의 컨트롤러가 다른 컨트롤러와 적게 공유하는 웹 어댑터 조각 역할을 수행하는 것이 이상적**이다. 
* 그러나 웹 어댑터를 구성하는 각각의 클래스는 같은 어댑터에 소속된다는 것을 표현하기 위해 동일한 패키지 수준에 배치하는 것이 좋다.
* 어떤 리소스에 관계된 모든 것을 하나의 클래스에 모아두면 괜찮아 보일지도 모르지만, 다음과 같은 단점이 수반된다.
  1. 코드를 파악하거나 테스트 코드를 찾기 어렵다.
     * **클래스 별 코드는 적을수록 좋고, 원하는 코드를 찾기가 쉽다**.
     * **아무리 메소드 별로 깔끔하게 분리되어 있더라도, 클래스 자체가 크다면 파악이 어렵다**.
     * 테스트 코드 역시 근본적으로 운영 코드보다 추상적이므로 더 파악이 어려운 특징을 갖기에, 테스트 코드는 찾기 쉬워야 하는 규칙에 위배된다.
  2. 모든 연산을 단일 컨트롤러에 모은다면 데이터 모델을 재활용하고 싶은 유혹에 빠지기 쉽다.
     * 해당 컨트롤러에 포함될 많은 연산이 같은 모델 클래스를 사용하기 쉬워지며, 이는 좋지 바람직하지 못한 현상이다.
* **인커밍 어댑터가 갖는 각 연산은 가급적이면 별도의 패키지 안에 별도의 컨트롤러로 작성하는 것이 이상적**이다.
  * **이 과정에서 메소드와 클래스 명은 유즈케이스를 최대한 반영해서 명명되어야 한다**.
* **분리된 각 컨트롤러는 컨트롤러 자체의 모델을 갖거나, 원시값을 받아 동작하는 것이 이상적**이다.
  * 이렇게 분리된 전용 모델 클래스는 package private하므로 다른 곳에서 실수로 재사용될 수가 없다.
* **컨트롤러와 서비스 이름에 대해서도 숙고하여 명명하는 것이 바람직**하다.
  * create, update, delete로 시작하는 일반적인 명명법만으로 유즈케이스의 의미가 전달될 수 있지만, register 등의 대체제를 사용해야하는 경우도 있다.
* **각 컨트롤러를 분리하여 작업할 경우, 서로 다른 연산에 대해 동시 작업이 쉬워진다**.
  * 예를 들어, 두 명의 개발자가 같은 유즈케이스의 서로 다른 연산을 작업하더라도 병합 충돌이 발생하지 않는다.

### 웹 어댑터의 구현과 유지보수 가능한 소프트웨어
* 웹 어댑터는 HTTP 요청을 애플리케이션 유즈케이스에 대한 메소드 호출로 변환하고, 결과를 다시 HTTP로 변환하여 반환한다.
  * **웹 어댑터는 이 과정에서 어떠한 도메인 로직도 수행하지 않는 어댑터라는 점을 명심하고 구현**해야 한다.
* 반면, 애플리케이션 계층은 HTTP에 대한 상세 정보를 알 수 없도록 HTTP와 관련된 작업을 수행하지 않아야 한다.
  * 이를 통해 필요시 웹 어댑터를 새로운 어댑터로 쉽게 교체할 수 있다.
* **웹 컨트롤러를 분할하는 과정에서, 모델을 공유하지 않는 작은 클래스를 여럿 만드는 상황을 두려워하지 않아야 한다**.
* 작게 분리된 컨트롤러 클래스는 다음과 같은 장점을 갖는다.
  1. 클래스 별 파악이 쉽다.
  2. 클래스 별 테스트가 쉽다.
  3. 클래스 별 동시 작업이 지원된다.
* **세분화된 컨트롤러를 작성하는 것은 프로젝트 초기에 비용이 더 들지만, 유지보수 과정에서 큰 이점을 얻을 수 있는 방식**이다.
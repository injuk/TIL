# CleanWebApplication
## 2022-03-19 Sat

## 코드의 구성
### 계층 형식으로 구성하기
* 코드를 구조화하는 첫 번째 방법으로, 전통적인 계층형 아키텍쳐를 구성하는 계층 별 구조화가 가능하다.
  * 예를 들어, 패키지는 domain, persistence, web 하위 패키지로 구성된다.
* **이러한 방식은 다음과 같은 이유에서 최적의 구조가 아니다**.
  1. 애플리케이션의 기능이나 특성에 따른 패키지 경계가 존재하지 않는다.
  2. 애플리케이션이 제공하는 유즈케이스를 파악할 수 없다.
  3. 패키지 구조만 보고서는 목표로 하는 아키텍쳐를 파악할 수 없다.

### 기능을 기준으로 구성하기
* 코드를 구조화하는 두 번째 방법으로, 기능을 대표하는 패키지를 하나 만들어 관련된 코드를 모두 옮겨두는 방법이 있다.
* 패키지 경계를 기준으로 코드가 구분되므로, package private 접근 수준을 활용하는 것으로 각 기능 사이의 불필요한 의존성을 방지할 수 있다.
* 그러나 이러한 패키징 방식은 계층 형식으로 구성된 패키징 방식보다 아키텍쳐의 가시성이 훨씬 떨어진다.
* 또한, **패키지 내부에서 계층 별 코드가 구분되지 않으므로 package private 접근 수준 만으로는 계층 간 의존성을 제어할 수 없다**.
* **이상적인 아키텍쳐는 육각형 아키텍쳐의 구성 요소를 선택했을 때 어떤 패키지에 코드가 포함되어 있을지 쉽게 유추가 가능해야 한다**. 

### 아키텍쳐적으로 표현력이 있는 패키지 구조
* 육각형 아키텍쳐에서 구조적으로 핵심적인 요소는 다음과 같다.
  1. 엔티티
  2. 유즈케이스
  3. 인커밍 / 아웃고잉 포트
  4. 인커밍 / 아웃고잉 어댑터: 또는 주도하는 어댑터 / 주도되는 어댑터
* 이를 토대로 요소를 각각 대응되는 패키지에 매핑할 수 있으며, 최상위 패키지의 이름은 유즈케이스 나타내는 이름을 작성한다.
```
.
└── account
    ├── adapter
    │   ├── in
    │   │   └── web
    │   └── out
    │       └── persistence
    ├── application
    │   └── port
    │       ├── in
    │       └── out
    └── domain
```
* 도메인 모델은 domain 패키지에 속한다.
* 도메인 모델을 둘러싼 서비스 계층은 application 패키지에 속한다.
* application 패키지에 위치한 service 클래스는 인커밍 포트 인터페이스를 구현하고, 아웃고잉 포트 인터페이스를 사용한다.
  * 아웃고잉 포트 인터페이스는 아웃고잉 어댑터인 영속성 어댑터에 의해 구현된다.
* 애플리케이션 계층의 인커밍 포트와 아웃고잉 포트 각각과 상호작용하는 어댑터는 adapter 패키지에 위치한다.
  * **인커밍 어댑터는 인커밍 포트를 호출하며, 아웃고잉 포트에 대한 구현은 아웃고잉 어댑터가 제공**한다.
* **이러한 패키지 구조는 아키텍쳐와 코드 사이의 간극을 효과적으로 다룰 수 있는 강력한 요소**가 된다.
  * 본래 아키텍쳐는 코드에 직접적으로 매핑되기 어려운 추상적인 개념이지만, 이러한 패키지 구조는 이러한 점을 상당 수 극복할 수 있게 한다.
  * **패키지 구조가 아키텍쳐를 반영할 수 없다면, 시간이 지나며 프로젝트가 성숙함에 따라 코드는 점점 목표하던 아키텍쳐로부터 멀어질 수 있다**.
* 상술한 패키지 구조는 각각의 도메인이 많은 패키지로 구성되므로, 다음과 같은 접근 수준 조절이 필요하다.
  1. 어댑터 패키지의 모든 클래스는 포트 패키지에 위치한 인터페이스를 통하지 않고서는 외부에서 호출되지 않으므로, package private로 둔다.
  2. 애플리케이션과 도메인 패키지 내부의 일부 클래스는 public으로 두어야 한다
     * 예를 들어, 의도적으로 어댑터에서 접근해야 하는 포트들은 public이어야 한다.
  3. 도메인 클래스 역시 서비스, 어댑터로부터 접근이 가능하도록 public이어야 한다.
  4. 서비스 클래스는 인커밍 포트의 인터페이스에 숨겨질 수 있으므로 public이 아니어도 좋다.
* 이러한 패키지 구조의 또 다른 장점으로는 다음을 생각해볼 수 있다.
  1. 하나의 어댑터 코드를 다른 구현으로 쉽게 교체할 수 있다.
  2. **도메인 주도 개발 개념에 직접적으로 대응**시킬 수 있다.
* 다른 모든 구조와 마찬가지로 패키지 구조를 프로젝트 내내 유지하기 위해서는 지켜야할 규칙이 있다.
  * 또한, 여의치 않은 경우 어쩔수 없이 아키텍쳐를 반영하지 못하는 패키지를 만들어야 하는 경우도 발생할 수 있다.
* **패키지 구조화에 완벽한 방법은 없지만, 표현력 있는 패키지 구조는 적어도 코드와 아키텍쳐 사이의 간극을 보다 좁힐 수 있도록 지원**한다.

### 의존성 주입의 역할
* 클린 아키텍쳐의 본질은 애플리케이션 계층이 인커밍 / 아웃고잉 어댑터에 의존성을 갖지 않는 것이다.
* **인커밍 어댑터의 경우, 제어 방향이 어댑터와 도메인 코드 사이의 의존성 방향과 같아 이를 준수하기 쉽다**.
  * **반면 영속성 어댑터와 같은 아웃고잉 어댑터의 경우, 제어 흐름의 반대 방향으로 의존성을 역전하기 위해 위존성 역전 원칙을 활용**해야 한다.
  * 이를 위해 애플리케이션 계층에 인터페이스를 만들고, 어댑터는 해당 인터페이스를 구현하는 클래스를 두어 사용한다.
  * **육각형 인터페이스에서는 이러한 역할을 수행하는 인터페이스가 포트**가 된다.
* 그러나 **이 과정에서 포트 인터페이스를 구현하는 실제 객체를 애플리케이션 계층에 제공하는 방법을 고려**해야 한다.
  * **포트를 애플리케이션 계층 내부의 코드에서 수동으로 초기화하게 되면, 애플리케이션 계층에서 어댑터에 대한 의존성이 추가되므로 바람직하지 않다**.
* **의존성 주입은 모든 계층에 의존하는 중립적인 컴포넌트를 도입하는 것으로 이러한 상황에서 유용하게 사용**될 수 있다.
* 이로 인해 각 **인터페이스의 실체는 스프링과 같은 의존성 주입 프레임워크에 의해 주입되며, 컴포넌트는 실체를 알 필요 없이도 동작이 가능**하게 된다.

### 패키지 구조와 유지보수 가능한 소프트웨어
* 상술한 패키지 구조는 코드에서 아키텍쳐의 특정한 요소를 더 찾기 쉽도록 지원한다.
* 이로 인해 구성원 간 의사소통은 물론 개발과 유지보수 과정 모두가 더 수월해질 수 있다.
# CleanWebApplication
## 2022-03-18 Fri

## 의존성 역전
### 단일 책임 원칙
* 단일 책임 원칙은 일반적으로 하나의 컴포넌트가 하나의 일만 똑바로 수행해야한다고 해석되지만, 해당 원칙이 내포하는 실제 의미는 다음과 같다.
```
> 컴포넌트를 변경하는 이유는 오직 하나 뿐이어야 한다.
```
* 단일 책임 원칙의 책임은 컴포넌트를 변경할 이유로 해석되어야 한다.
* **단일 책임 원칙에서 중요한 것은 변경할 이유가 오직 하나 뿐이라는 사실 자체**이다.
* 컴포넌트를 변경할 이유는 컴포넌트 간 의존성을 통해 너무나 쉽게 전파된다.
* 예를 들어, 어떠한 컴포넌트에도 의존하지 않는 임의의 컴포넌트는 오로지 새로운 요구사항에 의해 자신의 기능을 바꾸어야할 때만 변경하게 된다.
  * 반면, **컴포넌트가 다른 컴포넌트에 많이 의존할수록 다른 컴포넌트의 변경에 의해 자신도 함께 변경되어야 한다**.
* 대부분의 코드는 단일 책임 원칙을 위반하므로, 시간이 흐를수록 변경이 어려워져 변경의 비용이 커지므로 변경의 이유가 쌓여간다.
  * 변경의 이유가 충분히 많이 쌓인 후에는 컴포넌트를 수정하는 것이 다른 컴포넌트가 실패하는 원인이 될 수 있다.
```
결론: 단일 책임 원칙의 실제 의미는 컴포넌트를 변경하는 이유는 단 하나 뿐이어야 한다는 것이다.
```

### 의존성 역전 원칙
* 전통적인 계층형 아키텍쳐에서, 계층 간 의존성은 항상 아래 방향을 가리킨다.
  * 이는 곧 **단일 책임 원칙을 적용했을 때 상위 계층에 속하는 컴포넌트일수록 하위 계층 컴포넌트에 비해 변경의 이유가 많아짐을 의미**한다. 
* 즉, **도메인 계층이 영속성 계층에 의존하기 때문에 영속성 계층을 변경할 때마다 가장 중요한 도메인 계층에 잠재적인 변경 필요성이 수반**된다.
* **이러한 현상은 순전히 의존성 때문에 발생하며, 의존성 역전 원칙을 적용할 경우 이러한 의존성을 제거**할 수 있다.
* 의존성 역전 원칙의 실제 의미는 원칙의 이름과 동일하며, 다음과 같다.
```
> 코드 상에 존재하는 어떠한 의존성이든지 그 방향을 바꾸어 역전시킬 수 있다.
```
* 정확히 말해서, **의존성은 코드의 모든 제어권이 개발자에게 있을 때만 역전시킬 수 있다**.
  * 예를 들어, 두 컴포넌트 중 하나 이상이 서드파티 라이브러리라면 개발자는 라이브러리를 제어할 수 없으므로, 의존성도 역전시킬 수 없다.
* 도메인 계층의 서비스가 영속성 계층의 엔티티와 리포지토리에 의존하는 전통적인 계층형 아키텍쳐는 다음과 같이 의존성을 역전시킬 수 있다.
  1. 엔티티는 도메인 객체를 표현하고, 도메인 코드는 엔티티의 상태를 관리하는 것이 중심 로직이므로 엔티티를 도메인 계층으로 끌어올린다.
  2. **이 상태에서 서비스 > 리포지토리 > 엔티티 방향의 순환 의존성이 발생하는 부분에 의존성 역전 원칙을 적용**한다.
  3. 리포지토리에 대한 인터페이스를 도메인 계층에 작성하고, 영속성 계층에서는 해당 인터페이스를 실제로 구현하는 클래스를 작성한다.
* 상술한 과정에서 도메인 계층에 존재하던 영속성 계층에 대한 의존성은 모두 제거된다.
```
결론: 개발자가 제어권을 갖는 코드 상의 모든 의존성의 방향은 필요에 따라 역전시킬 수 있다.
```

### 로버트 C. 마틴의 클린 아키텍쳐
* 로버트 C. 마틴은 클린 아키텍쳐라는 용어를 동명의 책에서 정립하며, 다음과 같이 설명한다.
```
> 클린 아키텍쳐에서는 설계가 비즈니스 규칙의 테스트를 용이하게 하고, 비즈니스 규칙은 외부의 어떠한 세부 사항으로부터도 독립적인 상태로 존재할 수 있다.
```
* 이는 도메인 코드로부터 밖으로 향하는 의존성은 없어야 하며, 모든 의존성은 의존성 역전 원칙을 통해 도메인 코드를 향하는 방향이어야 한다는 의미를 내포한다.
* 클린 아키텍쳐에서, 계층들은 겹겹이 둘러쌓인 동심원 형태를 기반으로 내부로 향하는 의존성 방향을 갖는다.
* **클린 아키텍쳐의 내부에 위치한 도메인 코드에서는 영속성, UI 프레임워크에 대해 알 수 없으므로 특정한 프레임워크에 결합된 코드를 가질 수 없다**.
  * 때문에 도메인 코드는 오로지 비즈니스 규칙에만 집중할 수 있게 된다.
* 클린 아키텍쳐에서는 각 계층 간의 통신을 위한 엔티티를 양쪽 계층 모두가 가져야하는 대가가 따른다.
  * 예를 들어, **같은 기능에 대해 영속성 계층에서 사용되는 엔티티와 도메인 계층에서 사용되는 엔티티가 각각 만들어져 변환되는 과정이 필수적**이다.
  * 그러나 **이는 바람직한 현상이며, 이로 인해 도메인 코드가 프레임워크에 특화되는 문제로부터 해방**될 수 있다.
* 로버트 C. 마틴이 제창한 클린 아키텍쳐는 다소 추상적인 개념이므로, 이를 보다 구체화한 육각형 아키텍쳐를 이해할 필요가 있다.
```
결론: 클린 아키텍쳐는 의존성 역전 원칙을 활용하여 도메인 계층이 무엇에도 의존하지 않게 만들며, 오로지 비즈니스 규칙에만 집중할 수 있도록 지원한다.
```

### 육각형 아키텍쳐
* 육각형 아키텍쳐는 알리스테어 콕번이 만든 용어이며, 로버트 C. 마틴이 제창한 클릭 아키텍쳐를 조금 더 구체화한 후 동일한 원칙을 적용한다.
* 육각형 내부에는 서로 상호작용하는 도메인 엔티티와 유즈케이스가 존재한다.
  * 이는 **외부로 향하는 의존성을 갖지 않기 때문에, 클린 아키텍쳐의 의존성 규칙이 그대로 적용되어 모든 의존성이 코어 방향을 향한다**.
* 육각형 외부에는 애플리케이션과 상호작용하는 다양한 어댑터들이 배치된다.
  * 예를 들어, 웹 브라우저와 상호작용하는 웹 어댑터나 데이터베이스와 상호작용하는 영속성 어댑터 등이 존재할 수 있다.
* **육각형 아키텍쳐의 좌측에는 애플리케이션 코어를 호출하는, 주도적인 어댑터가 배치**된다.
* **육각형 아키텍쳐의 우측에는 애플리케이션 코어에 의해 호출되는, 주도되는 어댑터가 배치**된다.
* **애플리케이션 코어와 어댑터 간의 통신을 위해, 애플리케이션 코어는 각각의 포트를 제공**한다.
  * 이러한 특징으로 인해 육각형 아키텍쳐는 포트와 어댑터 아키텍쳐라고도 부를 수 있다.
  * **주도하는 어댑터는 포트 역할을 하는 인터페이스를 호출하고, 이 인터페이스는 유즈케이스 클래스에 의해 구현**된다.
  * **주도되는 어댑터는 포트 역할을 하는 인터페이스가 유즈케이스 클래스에 존재하며, 어댑터가 이를 구현하여 코어의 호출에 대비**한다.
* 클린 아키텍쳐와 마찬가지로, 육각형 아키텍쳐 역시 계층적으로 구성될 수 있다.
  * 가장 외부에 있는 계층은 애플리케이션과 외부 시스템 사이의 번역을 담당하는 어댑터로 구성된다.
  * **그 안쪽의 애플리케이션 계층은 포트와 유즈케이스 구현체가 결합된 형태로 존재하며, 이는 애플리케이션의 인터페이스를 정의**한다.
  * 가장 안쪽의 마지막 계층에는 도메인 엔티티가 위치한다.
```
결론: 육각형 아키텍쳐는 클린 아키텍쳐를 한결 더 구체화하며, 크게 다음으로 구성된다.
1. 도메인 엔티티와 유즈케이스로 구성되는 애플리케이션 코어
2. 애플리케이션이 외부 시스템, 세부사항과 상호작용하기 위한 어댑터
3. 애플리케이션 코어가 어댑터와 상호작용하기 위해 제공하는 포트 
```

### 클린 아키텍쳐, 육각형 아키텍쳐와 유지보수 가능한 소프트웨어
* 아키텍쳐는 의존성 역전을 통해 도메인 코드가 외부에 의존하지 않도록 설계되는 것으로 영속성, UI 등 모든 세부사항으로부터 독립될 수 있다.
* 클린 아키텍쳐를 통해 도메인 로직은 모든 세부사항의 문제로부터 결합이 제거되고, 그만큼 코드를 변경할 이유를 줄일 수 있다.
  * **코드를 변경할 이유를 줄일수록 유지보수성은 좋아진다**.
* **이로 인해 도메인 코드는 비즈니스 문제에 맞추어 모델링**될 수 있다.
  * 영속성과 UI 등의 세부사항도 자신의 문제에 맞추어 모델링될 수 있다.
# CleanWebApplication
## 2022-03-19 Sat

## 유즈케이스의 구현
* 이전까지의 아키텍쳐에서, 각 계층은 느슨하게 결합되므로 도메인 코드를 자유롭게 작성할 수 있다.
* 나아가 **육각형 아키텍쳐는 도메인 중심의 아키텍쳐에 적절하며, 도메인 엔티티를 만든 후에 도메인 엔티티를 중심으로 유즈케이스를 구현하는 것이 이상적**이다.

### 도메인 모델의 구현
* 도메인 엔티티를 구현한 후, 이를 중심으로 유즈케이스를 구현하기 위해 점차 바깥 방향으로 나아갈 수 있다.

### 유즈케이스란
* 유즈케이스는 일반적으로 다음과 같은 단계에 따라 수행된다.
  1. 입력을 받아서,
  2. 비즈니스 규칙을 검증하고,
  3. 모델의 상태를 조작한 후,
  4. 적절한 출력을 반환한다.
* **유즈케이스는 인커밍 어댑터로부터 입력을 받지만, 입력 유효성을 검증할 필요는 없다**.
  * 반면, 비즈니스 규칙을 검증할 책임은 도메인 엔티티와 공유한다.
* 비즈니스 규칙을 충족하면 유즈케이스는 입력을 기반으로 모델의 상태를 변경한다.
  * **일반적으로, 도메인 객체의 상태를 변경한 후 영속성 어댑터가 구현하는 포트로 이 상태를 전달하여 영속화**한다.
  * 또는 유즈케이스가 또 다른 아웃고잉 어댑터를 호출할 수도 있다.
* 마지막으로, **아웃고잉 어댑터에서 반환된 출력을 유즈케이스를 호출한 어댑터로 반환하기 위해 적절한 출력 객체로 변환**한다.
* **유즈케이스와 서비스 간의 관계는 다음과 같다**.
```
> 하나의 유즈케이스는 인터페이스 형태로 정의된다.
> 하나의 서비스는 하나의 유즈케이스 인터페이스를 구현한다.
> 하나의 서비스는 하나 이상의 아웃고잉 어댑터와 상호작용하기 위해 아웃고잉 포트를 인스턴스 멤버로 갖고, 호출한다.
```

### 입력 유효성 검증하기
* **입력 유효성 검증은 유즈케이스 클래스의 책임은 아니지만, 여전히 애플리케이션 계층의 책임에 속한다**.
* 인커밍 어댑터가 유즈케이스에 입력을 전달하기 전에 입력 유효성을 검증하는 로직은 다음과 같은 문제가 있다.
  1. 유즈케이스에서 필요한 모든 입력 유효성 검증을 인커밍 어댑터에서 완료했으리라고 신뢰할 수 없다.
  2. **유즈케이스는 하나 이상의 인커밍 어댑터에서 사용되므로, 모든 인커밍 어댑터에서 입력 유효성 검증 로직을 작성해야 한다**.
     * 이는 작성을 잊는 휴먼 에러로 이어지기 쉽다.
* **입력 유효성을 애플리케이션 계층에서 검증하는 이유는 애플리케이션 코어 외부로부터 유효하지 않은 입력을 받아 모델의 상태가 변조되는 것을 막기 위함**이다.
* 즉, 입력 유효성 검증은 유즈케이스 클래스도 아니고, 인커밍 어댑터에서 구현하기도 적절하지 않다.
* **따라서 입력 유효성의 검증은 입력 모델에서 구현하는 것이 적절**하다.
  * 생성자 등에서 객체를 생성할 때 입력 값의 유효성을 검증하고, 잘못된 경우 예외를 던져 객체 생성을 방지한다.
* 입력 모델은 유즈케이스 API의 일부이므로, 인커밍 포트와 같은 패키지에 위치한다.
  * 때문에 **유효성 검증 로직은 육각형 아키텍쳐의 내부인 애플리케이션의 코어 패키지에 남아있지만, 실제 유즈케이스 코드를 오염시키지는 못한다**.
* **유효성 검증 코드는 하나 하나 손수 입력할 수도 있지만, Java의 사실상 표준 라이브러리인 Bean Validation API를 활용하면 편리**하다.
* 입력 모델에 작성한 유효성 검증 코드를 통해 유즈케이스 구현체 주위에 사실상의 오류 방지 계층이 생성된다.
  * 이는 전통적인 계층형 아키텍쳐에서 말하는 계층이 아닌, 잘못된 입력을 호출자에게 반환하는 방패를 의미한다.

### 생성자의 힘
* 상술한 원칙을 준수하는 입력 모델은 생성자에 많은 책임이 지워지며, 유효하지 않은 상태의 객체를 만드는 것이 불가능하다.
* 파라미터가 많아질수록 빌더 패턴을 도입하고, 생성자와 입력 유효성 검증 로직을 빌더 패턴에 숨기고 싶은 유혹에 빠질 수 있다.
* 그러나 **빌더를 사용하는 경우, 신규 필드를 추가하는 과정에서 휴먼 에러가 발생하기 쉬우므로 생성자를 활용하는 것이 권장**된다.
  * 빌더 패턴의 경우, 런타임 시점에 에러가 발생하기 쉽지만 생성자를 사용하면 컴파일 시점에 에러가 발생한다.
  * 또한, 좋은 IDE는 긴 파라미터 목록을 갖는 생성자의 매개 변수 목록 순서 힌트를 제공한다.

### 유즈케이스마다 다른 입력 모델을 사용하기
* 유사한 유즈케이스에 동일한 입력 모델을 사용하고 싶은 유혹에 빠질 때가 있다.
* 이 경우, 각각의 유즈케이스에 요구되는 입력 모델이 미묘하게 다르다면 불변 객체의 필드에 null을 허용하는 code smell이 발생하기 쉽다.
* **각각의 유즈케이스 전용 입력 모델은 유즈케이스를 명확하게 하고, 다른 유즈케이스와의 결합을 제거하여 부수효과를 방지**한다.
  * 물론 이를 관리하기 위한 비용은 들지만, 그럼에도 전용의 입력 모델을 사용하는 것이 바람직하다.

### 비즈니스 규칙의 검증
* **입력 유효성 검증은 유즈케이스 로직의 일부가 아니지만, 비즈니스 규칙 검증은 유즈케이스 로직의 일부**이다.
* 특정 상황에 입력 유효성 검증과 비즈니스 규칙 검증 중 어떤 것을 활용할지 구분하는 방법은 다음과 같다.
  1. **비즈니스 규칙을 검증하려면 반드시 도메인 모델의 현재 상태에 접근해야 한다**.
  2. 입력 유효성 검증을 위해서는 도메인 모델에 접근할 필요가 없다.
* 예를 들어, 출금 계좌는 초과 출금될 수 없다는 규칙은 반드시 출금 계좌에 대한 정보가 필요하므로, 비즈니스 규칙에 해당한다.
* 반면, 송금되는 금액은 0보다 커야 한다는 규칙은 현재 도메인 모델에 접근하지 않고도 입력 모델만으로 검증이 가능하므로, 입력 유효성 검증으로 처리할 수 있다.
* 상술한 구분법은 논쟁의 여지가 있지만, 특정한 유효성 검증 로직을 코드 상의 어느 위치에 두거나, 어느 위치에서 찾아야하는지 결정하는 데에 큰 도움을 준다.
  * 검증 로직의 동작이 현재 도메인 모델 상태에 접근해야 하는지만 확인하면 되기 때문에 그렇다.
* 비즈니스 규칙 검증 로직을 구현하기로 결정했다면, 다음과 같은 위치에 구현을 고려할 수 있다.
  1. **가장 좋은 방법은 도메인 엔티티 내부의 필요한 위치에서 비즈니스 규칙을 검증하는 것**이다.
     * 또한, **도메인 모델을 로드해야 하는 경우 반드시 도메인 엔티티 내부에서 비즈니스 규칙을 구현**한다.
     * 이 경우, 규칙을 지켜야 하는 비즈니스 로직 옆에 검증 로직이 위치하므로 위치를 정하기도, 찾기도 쉽다.
  2. **도메인 엔티티 내부에서 비즈니스 규칙을 검증하기 쉽지 않은 경우, 유즈케이스 코드에서 도메인 엔티티를 사용하기 전에 검증해도 무방**하다.
* **비즈니스 규칙 유효성 검증이 실패한 경우 유효성 검증 전용의 예외를 던지며, 인커밍 어댑터는 이 예외를 받아 적절하게 처리**해야 한다.

### 풍부한 도메인 모델과 빈약한 도메인 모델
* 도메인 모델은 크게 DDD 철학을 따르는 풍부한 도메인 모델과 빈약한 도메인 모델로 나뉘며, 둘 중 어떤 것을 사용할지에 대한 정답은 없다.
* 풍부한 도메인 모델의 특징은 다음과 같다.
  1. 코어에 있는 엔티티에서 되도록이면 많은 도메인 로직이 구현된다.
  2. **유즈케이스는 도메인 모델의 진입점 역할만을 수행하며, 사용자의 의도를 실제 작업을 수행하는 도메인 엔티티 메소드로 전달**한다.
  3. 때문에, 대부분의 비즈니스 규칙은 유즈케이스 구현체가 아닌 엔티티에 위치한다.
* 빈약한 도메인 모델의 특징은 다음과 같다.
  1. **필드와 접근자 외에는 어떠한 도메인 로직도 갖지 않는, 굉장히 얇은 엔티티**를 가진다.
  2. 즉, 비즈니스 규칙을 검증하고, 엔티티 상태를 변경하고, 영속화를 위해 아웃고잉 포트에 엔티티를 전달하는 모두 도메인 로직은 유즈케이스 클래스에 구현된다.
     * 엔티티보다 유즈케이스가 풍부해지는 형태이다.
* **둘 중 필요에 맞는 스타일을 자유롭게 선택하여 사용해도 무방**하다.

### 유즈케이스마다 다른 출력 모델을 사용하기
* 유즈케이스가 비즈니스 로직을 마친 후에는 호출자에게 반환하기 위한 출력 모델을 사용해야 한다.
* **입력 모델과 마찬가지로, 출력 모델 역시 각각의 유즈케이스에 맞게 구체화하는 것이 바람직**하다.
  * 이 때, **출력 모델은 반드시 호출자에게 꼭 필요한 데이터만 최소한으로 가져야 한다**.
* 유즈케이스들이 출력 모델을 공유하게 되면, 유즈케이스들 역시 강하게 결합된다.
  * 이러한 공유 모델은 시간이 지날수록 갖가지 이유에서 점점 비대해지게 된다.
* **언제나 단일 책임 원칙을 적용하고, 모델을 분리해서 유지하는 것으로 유즈케이스의 결합을 제거하려고 노력**해야 한다.
  * **마찬가지 이유에서 도메인 엔티티를 출력 모델로 사용하고 싶은 유혹에 빠지지도 말아야 한다**.
  * 이는 도메인 엔티티를 변경할 이유가 무의미하게 많아지는 결과를 수반한다.

### 읽기 전용 유즈케이스
* 상술한 내용은 모델의 상태를 변경하는 유즈케이스의 구현 방법과 관련된 내용이다.
* 반면 단순한 읽기 전용 작업의 경우 유즈케이스라고 언급하는 것은 어폐가 있으며, 기존 유즈케이스 서비스에 포함되기에는 간단한 데이터 쿼리 작업이 전부이다.
  * **때문에 프로젝트 맥락에서 유즈케이스로 간주되기 어려우므로, 실제 유즈케이스 서비스와 구분하기 위해 쿼리 형태로 구현**할 수 있다.
* **단순히 데이터를 읽기만 하는 읽기 전용 유즈케이스 역시 다른 유즈케이스 서비스와 마찬가지 방식으로 구현하는 것이 바람직**하다.
  * **이러한 읽기 전용 유즈케이스는 쿼리 서비스라고 부를 수 있으며, 다른 유즈케이스와 마찬가지로 인커밍 포트를 구현하여 아웃고잉 포트를 호출**한다.
  * 쿼리 서비스는 아웃고잉 포트로 쿼리를 전달하는 것 외의 다른 작업을 수행하지 않는다.
* 이러한 읽기 전용 쿼리는 쓰기가 가능한 유즈케이스와 코드 상에서 명확하게 구분된다.

### 유즈케이스의 구현과 유지보수 가능한 소프트웨어
* 육각형 아키텍쳐에서는 도메인 로직을 개발자가 원하는대로 구현할 수 있지만, 입출력 모델을 독립적으로 모델링한다면 불필요한 부수효과를 피할 수 있다.
* 물론 유즈케이스 별 분리된 모델을 작성하는 것은 공유 모델에 비해 더 많은 작업이 필요하다.
  * 유즈케이스마다 별도의 모델을 작성하고, 모델과 엔티티를 매핑해야 한다.
* 그러나 유즈케이스 별로 분리된 모델은 유즈케이스를 명확히 이해할 수 있게 하며, 유지보수성도 향상되는 효과가 있다.
* 나아가 모델이 분리되므로 여러 개발자가 다른 사람이 작업 중인 유즈케이스에 영향을 주지 않는 상태로 여러 유즈케이스를 한 번에 작업할 수 있다.
* **꼼꼼한 입력 유효성의 검증과 유즈케이스 별 입출력 모델의 작성은 지속 가능한 코드를 작성하는 데에 큰 도움**이 된다.
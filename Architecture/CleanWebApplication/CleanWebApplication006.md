# CleanWebApplication
## 2022-03-20 Sun

## 영속성 어댑터의 구현 
### 의존성의 역전
* **전통적인 계층형 아키텍쳐의 영속성 계층 대신, 영속성 어댑터는 애플리케이션에 영속성 기능을 플러그인 형태로 제공**한다. 
* **애플리케이션 코어의 서비스는 영속성 어댑터에 접근하기 위해 아웃고잉 포트를 사용**한다.
  * **아웃고잉 포트는 실제로 영속성 작업을 수행하고, 데이터베이스와 통신하기 위한 책임을 갖는 영속성 어댑터 클래스에 의해 구현**된다.
* **육각형 아키텍쳐에서, 영속성 어댑터는 아웃고잉 어댑터이므로 애플리케이션에 의해 호출되지만 애플리케이션을 직접 호출하지는 않는다**.
* 아웃고잉 포트는 서비스와 영속성 코드 사이의 간접적인 계층으로 자리하며, 이로 인해 영속성 계층에 대한 코드 의존성을 제거할 수 있다.
* 런타임에서 의존성은 코어에서 아웃고잉 어댑터 방향으로 향하므로, 영속성 계층에서 버그가 발생한다면 애플리케이션 코어의 기능도 망가진다.
  * 하지만 **포트가 제 역할을 다 하는 이상, 코어에 영향을 주지 않으면서 영속성 코드를 수정하여 문제를 해결**할 수 있다.

### 영속성 어댑터의 책임
* 영속성 어댑터는 일반적으로 다음과 같은 일들을 수행할 책임이 있다.
  1. 애플리케이션 코어로부터 입력을 받는다.
     * 영속성 어댑터가 포트 인터페이스로부터 전달받는 입력은 인터페이스에 명시된 도메인 엔티티 또는 데이터베이스 연산 전용 객체이다.
  2. 입력을 데이터베이스에 적합한 포맷으로 매핑한다.
     * Java 프로젝트에서 일반적으로 JPA를 사용하므로, 입력 모델은 일반적으로 JPA 엔티티 객체로 매핑된다.
     * JPA 이외의 ORM 프레임워크를 사용하거나, 애당초 다른 기술을 사용해도 무방하다.
     * **중요한 것은 영속성 어댑터의 입력 모델은 어댑터가 포함하지 않고 코어가 포함하므로, 영속성 어댑터의 변경이 코어에 영향을 미치지 않는다는 것**이다.
  3. 데이터베이스에 입력을 전달한다.
     * 즉, 영속성 어댑터는 데이터베이스에 쿼리를 날리고 결과를 수신한다.
  4. 데이터베이스로부터의 출력을 애플리케이션에 걸맞는 포맷으로 매핑한다.
  5. 출력을 애플리케이션 코어에 반환한다.
     * **입력 모델과 마찬가지로 출력 모델 역시 영속성 어댑터가 아닌 애플리케이션 코어에 위치**한다.
* 입출력 모델이 영속성 어댑터 자체가 아닌 애플리케이션 코어에 포함된다는 점을 제외하고, 기본적인 책임은 전통적인 영속성 계층과 다르지 않다.

### 포트 인터페이스 분할하기
* **서비스를 구현하려면 데이터베이스 연산을 정의하는 포트 인터페이스를 어떻게 분할할 것인가 고려**해보아야 한다.
* 일반적으로, 특정한 엔티티가 필요로할 법한 모든 데이터베이스 연산을 하나의 리포지토리 인터페이스에 정의하곤 한다.
  * 즉, 이 경우 하나의 리포지토리 인터페이스에 엔티티와 관련된 CRUD 연산이 모두 포함된다.
* 그러나 이로 인해 **데이터베이스 연산에 의존하는 각 서비스는 인터페이스에서 단 하나의 메소드만 사용하더라도, 하나의 넓은 인터페이스에 의존성을 갖게 된다**.
  * 즉, 각 서비스는 실제로는 사용하지 않을 연산에 의존하게 된다.
* 이렇듯 맥락에 필요하지 않은 메소드에 대한 의존성은 코드를 이해하고, 테스트하기 어렵게 만드는 요인이 된다.
* **이러한 문제점은 다음과 같은 인터페이스 분리 원칙을 통해 해결**할 수 있다.
```
> 모든 클라이언트 코드는 자신이 필요로 하는 메소드만 알 수 있도록, 넓은 인터페이스를 작고 특화된 인터페이스로 분리해야 한다.
```
* 인터페이스 분리 원칙을 적용하는 것으로 불필요한 의존성을 제거하고, 기존의 의존성을 눈에 더 잘 띄게할 수 있다.
  * 이를 통해 각 서비스는 명확한 이름으로 표현된 포트와, 실제로 필요한 메소드에만 의존할 수 있다.
* 이렇듯 포트를 좁게 작성하는 것은 코딩을 플러그 앤 플래이 경험으로 만들어줄 수 있다.
  * 이 경우 **서비스 코드를 작성할 때는 필요한 포트에 꽂기만 하면 된다**.
* 물론 모든 상황에 포트 하나 당 하나의 메소드를 적용할 수는 없으며, 응집성이 높고 함께 사용되는 메소드가 많을 수 있다.
  * 즉, 하나의 인터페이스에 묶어야 하는 데이터베이스 연산이 여럿일 가능성이 높다.

### 영속성 어댑터 나누기
* 모든 영속성 포트는 하나의 영속성 어댑터가 아닌, 다수의 영속성 어댑터 클래스를 생성해도 무방하다.
  * 예를 들어, **영속성 연산이 필요한 도메인 클래스, 또는 애그리거트 하나당 하나의 영속성 어댑터를 구현할 수 있다**.
    * **애그리거트란, 불변식을 만족하여 하나의 단위로 취급될 수 있는 연관된 객체의 모음**을 말한다.
  * 나아가 영속성 어댑터는 훨씬 더 많은 클래스로 분할될 수도 있다.
* 도메인 코드는 영속성 포트에 의해 정의된 명세를 실제로 어떤 클래스가 충족하는지 알 수 없고, 알 필요도 없다.
* **애그리거트 당 하나의 영속성 어댑터를 작성하는 접근 방식은 여러 바운디드 컨텍스트의 영속성 요구사항을 분리하기 위해 좋은 토대**가 될 수 있다.
* 각각의 바운디드 컨텍스트는 영속성 어댑터를 각각 하나 이상 가질 수 있다.
* **바운디드 컨텍스트라는 표현은 경계를 암시하며, 각각의 바운디드 컨텍스트에 위치한 코드는 다른 바운디드 컨텍스트의 코드게 직접 접근하지 않아야 한다**.
  * **다른 맥락의 무언가에 접근해야하는 경우, 전용 인커밍 포트를 작성하여 접근하도록 한다**.

### 데이터베이스 트랜잭션
* **트랜잭션은 하나의 특정한 유즈케이스에 대해 발생하는 모든 쓰기 작업에 걸쳐 있는 것이 이상적**이다.
  * 이를 통해 하나라도 실패하는 경우 모두 롤백시킬 수 있게 된다.
* 반면 **영속성 어댑터는 어떠한 데이터베이스 연산이 같은 유즈케이스에 포함되는지 알 수 없으므로, 어떤 트랜잭션을 언제 여닫을지 결정할 수 없다**.
* **때문에 이러한 트랜잭션 책임은 영속성 어댑터를 호출하는 서비스에 위임**되어야 한다.
  * Java와 Spring을 예로 들어, @Transactional 어노테이션을 애플리케이션 서비스에 정의하는 것으로 모든 public 메소드를 트랜잭션으로 감쌀 수 있다.
  * 서비스가 해당 어노테이션으로 오염되지 않고 깔끔하게 유지되길 원하는 경우, AspectJ와 같은 도구를 도입하여 AOP를 사용해야 한다.

### 영속성 어댑터의 구현과 유지보수 가능한 소프트웨어
* 도메인 코드에 플러그인처럼 동작할 수 있는 영속성 어댑터를 작성하는 것으로, 도메인 코드가 영속성과 관련된 것들로부터 분리될 수 있다.
  * 이를 통해 풍부한 도메인 모델을 구현할 수 있다.
* **좁은 포트 인터페이스를 여럿 작성하는 것으로 포트마다 다른 방식으로 구현할 수 있는 유연함을 얻을 수 있다**.
  * 심지어, 포트 뒤에 위치한 영속성 기술을 애플리케이션이 알 필요 없이 변경할 수도 있다.
  * **포트의 명세만 지켜진다면 영속성 계층 전체의 교체도 가능**하다.
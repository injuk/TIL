# CleanWebApplication
## 2022-03-22 Tue

## 애플리케이션의 조립
### 왜 조립해야 하는가?
* **유즈케이스와 어댑터를 필요한 시점에 인스턴스화하지 않는 까닭은, 의존성이 항상 올바른 방향을 가리키게 하기 위해**서이다.
  * 모든 의존성은 안에 위치한 도메인 계층으로 향해야 도메인 코드가 외부의 변경으로부터 안전할 수 있다.
  * 유즈케이스가 영속성 어댑터를 직접 호출하거나, 스스로 인스턴스화한다면 이는 코드 의존성이 잘못된 방향을 향하는 것이다.
  * **유즈케이스는 인터페이스만 알아야 하고, 런타임에 인터페이스를 구현한 실체를 제공받을 수 있어야 한다**.
* **의존성 규칙을 어기지 않기 위해, 이러한 객체 인스턴스를 생성하고 제공할 책임은 새로운 구성 요소인 설정 컴포넌트에 있다**.
  * 설정 컴포넌트는 아키텍쳐에 중립적이고, 원활한 인스턴스 생성을 위해 모든 클래스에 의존성을 가져야 한다.
* **설정 컴포넌트는 개발자가 작성하여 제공한 코드 조각으로 애플리케이션을 조립하는 책임**을 갖는다.
  * 또한 설정 컴포넌트는 설정 파일이나 커맨드라인 파라미터 등과 같은 파라미터 소스에도 접근 가능해야 한다.
* 이렇듯 **설정 컴포넌트는 가진 책임이 매우 많으며, 실제로도 단일 책임 원칙을 위반**한다.
  * 그러나 **애플리케이션의 나머지 부분을 깔끔하게 유지하기 위해서는 이렇듯 구성 요소를 연결해주는 바깥 컴포넌트가 반드시 필요**하다.
  * 이 과정에서 설정 컴포넌트는 동작하는 애플리케이션으로 조립하는 책임을 완수하기 위해 애플리케이션의 모든 구성 요소를 알고있어야 한다.

### 플레인 Java로 구현하기
* 애플리케이션을 조립할 설정 컴포넌트를 구현하는 방법은 여럿 있으며, 의존성 주입 프레임워크의 도움 없이 평범한 코드로 작성할 수 있다.
* 이 경우, main 메소드 내부에서 웹 컨트롤러부터 영속성 어댑터까지 필요한 모든 인스턴스를 생성한 후 연결한다.
* 이러한 방식은 가장 기본적이지만, 다음과 같은 치명적인 단점이 존재한다.
  1. 적은 유즈케이스만 갖는 애플리케이션을 구축하는데도 많은 코드를 작성해야 한다.
  2. 각 클래스가 패키지 외부에서 호출되어 인스턴스화되므로, 반드시 public 접근 제한자를 가져야 한다.
* package private 의존성을 유지하면서도 지저분한 작업을 대신 해줄 수 있는 의존성 프레임워크들이 존재한다.
  * 예를 들어, 웹과 데이터베이스까지 지원해주는 Java 진영의 Spring 프레임워크가 있다.

### Spring의 클래스패스 스캐닝으로 조합하기
* **Spring 프레임워크를 활용하여 애플리케이션을 조립한 결과물은 애플리케이션 컨텍스트라는 이름으로 부를 수 있다**.
  * **애플리케이션 컨텍스트는 애플리케이션을 구성하는 모든 bean 객체를 포함**한다.
* **Spring은 클래스패스에서 접근 가능한 모든 클래스를 확인하여 @Component 어노테이션이 포함된 클래스를 찾아 인스턴스화**한다.
  * 이 때, 각 클래스는 Lombok의 @RequiredArgsConstructor와 같이 필요한 모든 필드를 인자로 받는 생성자를 가지고 있어야 한다.
  * 이러한 방식을 클래스패스 스캐닝이라고 한다.
* 클래스패스 스캐닝에 의해 인스턴스화된 객체는 모두 애플리케이션 컨텍스트에 추가되며, 이로 인해 매우 쉽게 애플리케이션을 조립할 수 있다.
* 그러나 클래스패스 스캐닝에도 다음과 같은 단점이 존재한다.
  1. 프레임워크에 특화된 어노테이션을 반드시 클래스에 정의해야하므로, 이는 매우 침투적인 방식이다.
     * 클린 아키텍쳐파는 이러한 방식으로 인해 애플리케이션이 프레임워크와 결합되므로, 지양해야 한다고 말한다.
     * 일반적인 애플리케이션에서는 하나의 클래스에 어노테이션 하나 정도는 용인될 수 있고, 리팩토링도 어렵지 않다.
     * 반면 라이브러리나 프레임워크를 제작하는 경우, 라이브러리 사용자에게 불필요한 의존성을 안겨주므로 지양해야 할 방법이다.
  2. 애플리케이션 컨텍스트에 실제로 올라가지 않아야할 클래스가 올라갈 수 있으며, 이러한 클래스가 애플리케이션 컨텍스트를 악의적으로 조작할 수도 있다.

### Spring의 Java Config를 활용하여 조합하기
* 해당 방식은 애플리케이션 컨텍스트에 추가할 빈을 생성하는 설정 클래스를 @Configuration 어노테이션을 활용하여 작성한다.
* 사실 **여전히 Spring의 클래스패스 스캐닝을 사용하는 방식이지만, 모든 빈을 가져오는 대신 설정 클래스만 선택하므로 제어하기는 훨씬 쉽다**.
* Bean 자체는 설정 클래스 내부에서 @Bean 어노테이션이 붙은 팩토리 메소드로 생성된다.
* 이렇게 만들어진 설정 클래스는 매우 한정적인 범위의 모듈이 되고, 클래스패스 스캐닝을 통해 자동으로 주입된다.
  * **나아가 어떤 Bean이 애플리케이션 컨텍스트에 적재될지 쉽게 제어**할 수 있다.
* 또한 해당 방식은 @Component 어노테이션을 코드 여기저기에 작성할 필요가 없다.
  * 닥분에 애플리케이션 계층은 Spring 프레임워크에 대한 의존성 없이 유지할 수 있게 된다.
* Java Config 방식에도 다음과 같은 문제점이 존재한다.
  1. 설정 클래스가 생성하는 Bean이 설정 클래스와 다른 패키지에 존재한다면, 반드시 public 접근 제한자를 사용해야 한다.

### 애플리케이션의 조립과 유지보수 가능한 소프트웨어
* Spring, Spring Boot 등의 프레임워크는 편리하게 개발할 수 있도록 하는 다양한 기능을 제공한다.
  * 대표적으로 개발자가 제공하는 부품을 활용하여 애플리케이션을 조립하는 기능이 있다.
* **클래스패스 스캐닝은 매우 편리하지만, 애플리케이션의 규모가 커질수록 투명성이 낮아지고 애플리케이션 컨텍스트의 제어가 어려워진다는 단점도 존재**한다.
* 반면 **애플리케이션 조립을 책임질 전용의 설정 컴포넌트를 작성하면 애플리케이션이 이러한 책임에서 자유로워질 수 있다**.
  * 이를 통해 서로 다른 모듈로부터 독립되어, 코드 상에서 쉽게 옮겨다닐 수 있는 응집도가 높은 모듈을 작성할 수 있다.
* 그러나 장점만 존재하는 기술은 존재하지 않듯, **설정 컴포넌트 역시 유지보수에 더 많은 시간을 들여야한다는 아쉬움**이 있다.
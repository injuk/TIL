# CleanWebApplication
## 2022-03-18 Fri

## 계층형 아키텍쳐의 문제점
* 계층형 아키텍쳐로 구성된 웹 애플리케이션은 여러 매체를 통해 개발자에게 주입되어 왔다.
  * 계층형 아키텍쳐는 일반적으로 웹 > 도메인 > 영속성 계층으로 의존하는 형태를 띈다.
  * 이 때, **도메인이란 해결하려는 문제와 요구사항을 나타내는 영역**이다.
* 계층형 아키텍쳐의 계층 별 역할은 크게 다음과 같다.
  1. 웹 계층: 사용자로부터 요청을 받아 도메인, 또는 비즈니스 계층의 서비스로 요청을 전달한다.
  2. 도메인 계층: 서비스에서 필요한 비즈니스 로직을 수행하고, 도메인 엔티티를 관리하기 위해 영속성 계층의 컴포넌트를 호출한다.
  3. 영속성 계층: 도메인 엔티티를 관리한다.
* **계층형 아키텍쳐는 견고한 패턴이며, 계층 별 역할을 잘 이해하고 구성하면 웹과 영속성 계층에 독립적인 도메인 계층을 정의**할 수 있다.
  * 즉, 필요시 도메인 계층에 영향을 주지 않고도 웹 계층과 영속성 계층에 사용되는 세부 사항을 변경할 수 있다.
* 잘 만들어진 계층형 아키텍쳐는 선택의 폭을 넓히고, 변화하는 요구사항과 외부 요인에 빠르게 적응할 수 있게 한다.
  * 이것이 로버트 C. 마틴이 제안하는 클린 아키텍쳐이다.
* 반면, **계층형 아키텍쳐는 시간이 지날수록 코드 품질이 낮아지거나 허점이 드러나기 쉬운 단점이 존재**한다.

### 데이터베이스 주도적인 설계를 유도하는 계층형 아키텍쳐
* **전통적인 계층형 아키텍쳐의 근간은 데이터베이스**일 수 밖에 없다.
  * 웹은 도메인에, 도메인은 영속성에 의존하므로, 결국 모든 것은 영속성 계층에 의존하는 꼴이다.
* 모든 것이 영속성 계층을 토대로 하는 계층형 아키텍쳐는 다양한 이유에서 문제가 발생하기 쉽다.
* **애플리케이션의 기본적인 목적은 비즈니스와 관련된 상태를 저장하는 것이 아니다**.
```
> 대부분의 애플리케이션의 목적은 비즈니스를 관장하는 규칙이나 정책을 반영하는 모델을 만들고, 사용자가 이러한 규칙과 정책을 편리하게 활용하도록 하는데에 있다. 
> 이 때, 상태는 중요한 요소이지만 행동이 상태를 바꾸는 주체이므로, 우리는 상태가 아닌 행동을 중심으로 모델링한다.
```
* 상술했듯 **행동이 상태를 바꾸는 주체이며, 그렇기에 행동이 비즈니스를 이끌어간다**.
* 그러나 우리의 개발 프로세스는 일반적으로 데이터베이스의 구조를 먼저 정의하고, 이를 토대로 도메인 로직을 구현하곤 한다.
  * 이는 전통적인 계층형 아키텍쳐에서는 의존성의 방향을 자연스럽게 따르므로 바람직할 수 있다.
  * 그러나 **비즈니스 측면에서는 전혀 올바르지 않은 접근 방법에 해당**한다!
* 이상적인 설계 흐름은 다음과 같아야 한다.
  1. 도메인 로직을 가장 먼저 설계한다.
  2. 도메인 로직이 올바른지 확인한다.
  3. 그 후에야 영속성 계층과 웹 계층을 작성한다.
* **데이터베이스 중심적인 아키텍쳐가 만들어지는 가장 큰 원인은 ORM 프레임워크**에 있다.
  * ORM은 강력하지만, 계층형 아키텍쳐에서는 비즈니스 규칙을 영속성 관점과 섞으려는 유혹을 받기 쉽다.
  * 도메인 계층에서의 데이터베이스 엔티티 사용은 영속성 계층과의 강한 결합을 유발할 수 밖에 없다.
* 엔티티는 일반적으로 영속성 계층에 위치하며, 도메인 계층이 이를 직접 사용하는 형태를 띈다.
  * **이로 인해 영속성 계층과 도메인 계층 사이의 결합은 강해지며, 도메인 계층의 서비스는 영속성 엔티티를 마치 비즈니스 모델처럼 사용**하게 된다.
  * 때문에 도메인 계층에서 영속성 계층을 뒷받침하기 위한 여러 작업들을 수행해야만 한다.
* 결국 영속성과 관련된 코드가 도메인에 녹아들어 둘 중 하나만 바꾸는 것이 어려워지며, 유연하고 선택의 폭을 넓혀주어야 할 목표를 달성할 수 없게 된다.
```
결론: 계층형 아키텍쳐는 영속성 계층을 근간으로 설계되기 쉽고, 이에 따라 도메인 계층과 영속성 계층 사이의 결합은 강해진다.
```

### 지름길을 택하기 쉬운 계층형 아키텍쳐
* 전통적인 계층형 아키텍쳐에서 강제되는 유일한 규칙은 다음과 같다.
  * **반대로 말하면, 아래의 규칙 외에 강제되는 규칙이 없다**!
```
> 특정한 계층에서는 자신보다 아래에 있는 계층의 컴포넌트, 적어도 같은 계층에 있는 컴포넌트에만 접근이 가능하다.
```
* 어떤 계층의 컴포넌트가 상위 계층의 컴포넌트에 접근할 일이 생긴다면, 해당 컴포넌트를 아래 계층으로 내려버리는 것이 가장 빠르고 깔끔한 해결책이다.
  * 그러나 장기적으로 좋은 방법은 아니다.
  * **계층형 아키텍쳐는 제한된 시간 등에 의해 이러한 선택을 하기 쉽고, 두 번째부터는 죄책감이 덜어지고, 이윽고 모두가 이러한 방식을 선택**하게 된다.
* **영속성 계층은 편의상의 이유로 아래로 내려지는 컴포넌트에 의해 장기간의 개발과 유지보수를 거치며 점점 비대해질 확률이 높다**.
* 이는 전통적인 계층형 아키텍쳐에서 강제되는 규칙이 적기 때문으로, 적어도 추가적인 규칙을 강제하지 않는 한 해결되지 않는다.
  * 이 때, **규칙이란 팀원 또는 시니어 개발자의 코드 리뷰가 아닌 위배되었을 때 빌드조차 할 수 없는 강력한 규칙을 의미**한다.
```
결론: 계층형 아키텍쳐는 강제되는 규칙이 적어 지름길 선택의 유혹에 빠지기 쉬우며, 강제적인 규칙을 추가하지 않는 이상 잠재적인 문제 발생 가능성을 떠안게 된다.
```

### 테스트하기 어려운 계층형 아키텍쳐
* 계층형 아키텍쳐를 사용할 때 일반적으로 나타나기 쉬운 변화는 계층을 건너뛰는 것이다.
  * 예를 들어, 간단한 엔티티의 조작은 도메인 계층을 통하지 않고 웹 계층에서 영속성 계층에 직접 접근하고 싶을 수 있다.
* 이러한 방식은 다음과 같은 문제점이 수반된다.
  1. 간단한 엔티티의 조작이더라도, 도메인 로직이 웹 계층에 구현된다.
     * 유즈케이스가 확장될 수록 이러한 작업이 늘어나며, **결국 애플리케이션 전반에 걸쳐 도메인 로직이 퍼져 책임이 섞이게 될 확률이 높다**.
  2. 웹 계층 테스트에서 도메인 계층 뿐만 아니라 영속성 계층까지 모킹해야 하므로, 단위 테스트의 복잡도가 높아진다.
     * 단위 테스트가 복잡해지는 것은 테스트 코드의 작성과 설정에 시간이 오래걸리므로, 테스트를 전혀 작성하지 않는 방향으로 가는 가장 빠른 방법이다.
* **웹 계층 컴포넌트의 규모가 커지면 많은 영속성 컴포넌트에 의존성이 쌓이고, 테스트의 복잡도는 높아진다**.
  * 어느 순간에는 실제 테스트 코드 작성보다 의존성을 이해하고, 모킹에 들이는 시간이 더 많아지게 된다.
```
결론: 계층형 아키텍쳐는 중간 계층을 건너뛰는 선택을 하기 쉬우며, 이러한 선택이 계속해서 쌓여가므로 테스트의 복잡성이 높아지기 쉽다.
```

### 유즈케이스를 숨기는 계층형 아키텍쳐
* 개발자들은 새로운 유즈케이스를 구현하는 코드를 짜는 것을 선호하지만, 실제로는 기존 코드를 변경하는 데에 더 많은 시간을 쏟는다.
  * 즉, **기능을 추가하거나 변경하기 위해 적절한 위치를 찾는 일이 빈번하게 발생하며, 아키텍쳐는 코드를 빠르게 탐색하는데에 도움을 주는 것이 이상적**이다.
  * **아키텍쳐에 의해 특화되고 좁은 도메인 서비스가 정의되고, 각각의 서비스가 하나의 유즈케이스를 담당한다면 작업 위치를 찾기 위해 필요한 시간은 줄어든다**.
* 그러나 상술한 바와 같이, **계층형 아키텍쳐는 도메인 로직이 웹, 영속성을 가리지 않고 흩어지기 쉬운 특징**을 갖는다.
  * **이러한 상황에 처한 계층형 아키텍쳐는 이미 적절한 코드의 위치, 즉 유즈케이스를 찾기 어려워진 상태**이다.
* 또한 **계층형 아키텍쳐는 상 하위 계층에 대한 규칙 이외에는 강제하는 것이 없으므로, 도메인 서비스의 너비가 제한되지 않는다**.
* 시간이 지남에 따라 **넓어진 도메인 계층의 서비스는 너무 많은 웹 계층 컴포넌트가 의존하고, 또 많은 영속성 계층 컴포넌트에 의존할 가능성이 높다**.
  * **넓은 서비스는 너무 많은 의존성 탓에 테스트하기 어렵고, 너무 많은 기능을 담당하는 탓에 필요할 때 적절한 서비스의 코드 위치를 찾기도 어렵다**.
```
결론: 계층형 아키텍쳐는 너비에 대한 강제성이 없으므로, 시간이 지날수록 서비스가 넓어져 계층간 결합이 강해지므로 점점 필요한 코드를 찾기 어려워진다.
```

### 동시 작업이 어려운 계층형 아키텍쳐
* **일반적인 소프트웨어 프로젝트에는 정해진 시한이 있고, 이를 지켜야한다는 것은 곧 여러 작업이 동시에 진행되어야 한다는 의미**이다.
* 적절한 규모의 프로젝트라면 인원이 더 투입될수록 작업 속도의 향상을 기대할 수 있다.
  * **이는 아키텍쳐가 동시 작업을 지원하는 형태로 정의되었음을 전제**로 한다.
  * 그러나 계층형 아키텍쳐는 동시 작업을 지원하는 측면에서 큰 도움을 기대할 수 없다.
* 만약 애플리케이션에 새로운 유즈케이스를 추가한다면, 이상적인 작업 방식은 다음과 같다.
  1. 몇몇은 웹 계층을 작업한다.
  2. 또 다른 몇몇은 도메인 계층을 작업한다.
  3. 나머지는 영속성 계층을 작업한다.
* 그러나 전통적인 계층형 아키텍쳐에서는 다음과 같은 이유에서 이러한 작업 방식이 불가능하다.
  1. 모든 것이 하위 계층을 토대로 존재할 수 있으므로, 영속성 > 도메인 > 웹 계층 순서로만 작업이 가능하다.
  2. **개발자들이 인터페이스를 사전 협의하고 선작업을 수행할 수도 있지만, 이는 데이터베이스 주도 설게에서 불가능한 방식**이다.
     * **데이터베이스 주도 설계는 영속성 로직과 도메인 로직이 섞이므로 각 계층 컴포넌트를 개별적으로 작업할 수 없기 때문**이다.
  3. 서비스가 이미 충분히 넓어졌다면, 서로 다른 유즈케이스를 위한 기능을 같은 서비스에서 작업하므로 병합 충돌이 발생하기 쉽다.
```
결론: 계층형 아키텍쳐에서는 영속성 계층에 대한 의존도가 크기 때문에 각 계층 별 동시 작업을 수행할 수 없다.
```

### 계층형 아키텍쳐와 유지보수 가능한 소프트웨어
* 올바르게 정의되고, 몇 가지 규칙을 추가로 강제한다면 계층형 아키텍쳐는 유지보수와 코드의 변경, 기능 추가가 쉽다.
* 그러나 계층형 아키텍쳐는 강제되는 규칙이 적어 잘못된 방향으로 흘러가기 쉬운 특징을 갖는다.
  * 따라서, 시간이 지날수록 소프트웨어 품질은 저하되고 유지보수하기도 어려워진다.
* **계층형 아키텍쳐, 또는 다른 아키텍쳐를 선택하더라도 계층형 아키텍쳐의 단점을 기억한다면 유지보수가 쉬운 솔루션을 정의하는 데에 큰 도움이 될 수 있다**.
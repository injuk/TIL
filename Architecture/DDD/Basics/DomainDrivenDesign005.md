# DomainDrivenDesign
## 2022-04-29 Fri

## 리포지토리
* 소프트웨어를 계속 성장시키려면 코드의 의도를 명확히 해야한다.
  * 반면, 데이터 저장소와 관련된 코드는 프로그램의 의도를 가리기 쉽다.
* 의도가 잘 드러나는 코드를 위해 데이터 저장소와 관련된 코드는 별도로 분리해야 하며, 리포지토리는 이러한 역할을 수행해준다.
* **리포지토리는 데이터 저장과 관련된 처리를 추상적으로 다룰 수 있게 하여 코드의 의도를 보다 명확히 드러내준다**.
  * 또한, 데이터 저장소를 교체할 때에도 리포지토리를 활용하면 변경에 대응하기 쉬우며, 결국 소프트웨어의 유연성에 기여하게 된다.

## 리포지토리란?
```
> 리포지토리는 데이터를 저장하고 복원하는 처리를 추상화하는 객체이다.
```
* 일반적인 의미와 마찬가지로, 개발에서 말하는 리포지토리 역시 데이터의 보관 장소를 의미한다.
* **소프트웨어로 도메인 개념을 표현했다고 해서 그대로 애플리케이션으로 사용 가능한 것은 아니며, 사용자를 위해 객체를 영속화할 필요가 생기기 마련**이다.
  * 예를 들어, 엔티티는 생명주기를 갖는 객체이지만 애플리케이션이 종료되면 그대로 사라지게 된다.
  * **엔티티와 같은 객체를 다시 이용하려면 데이터 저장소에 객체 데이터를 저장 또는 복원해야 할 필요**가 있다.
* **객체 인스턴스를 저장 및 복원하는 경우, 데이터 저장소에 직접 접근하는 대신 리포지토리에 저장과 복원 처리를 위임**할 수 있다.
  * 이렇듯 리포지토리를 통해 간접적으로 데이터를 처리하면 소프트웨어의 유연성은 크게 향상된다.
* **객체의 영속성과 관련된 처리를 리포지토리에 맡기는 것으로 길고 복잡한 영속성 코드로부터 해방되며, 비즈니스 로직은 더욱 순수하게 유지**할 수 있게 된다. 

### 리포지토리와 도메인 객체
* **리포지토리는 도메인의 특정 개념으로부터 유래한 개념이 아니므로, 도메인 객체가 아니며 도메인 객체와는 큰 차이가 있다**.
* 그러나 도메인 객체를 이용하여 소프트웨어를 구성하는 과정에서, 순수하게 기술적인 요소와 관련된 코드도 반드시 필요하다.
  * 이러한 **기술적인 코드가 도메인 객체와 섞이게 되면 코드의 원래 의도를 알아보기 어려워지게 된다**.
* 리포지토리는 기술적인 요소와 관련된 코드를 하나로 모아 문제 해결만을 위한 코드를 도메인 객체로부터 분리하며, 결과 도메인 객체가 더욱 돋보이게 한다.
* 즉, **도메인을 잘 드러내는 것이 목표인 도메인 주도 설계에서 리포지토리는 뗄래야 뗄 수 없는 구성 요소에 해당**한다.

## 리포지토리의 책임
```
> 리포지토리의 책임은 도메인 객체를 저장하고, 복원하는 영속성에 있다.
```
* 영속성의 기반 기술은 관계형 데이터베이스 이외에도 NoSQL 데이터베이스 등 다양하다.
* 그러나 **어떠한 기술을 사용하더라도 영속성을 구현하는 코드는 특정한 데이터 저장소를 사용하기 위한 세부사항에 결합**될 수 밖에 없다. 
  * 결과, 영속성과 관련된 코드는 도메인 객체를 침식하며 의도를 가리게 된다.
* 리포지토리의 책임은 어디까지나 객체의 영속화에 있으므로, 특정 속성의 중복 여부 등 도메인 규칙과 관련된 코드는 리포지토리의 책임을 벗어난다.
  * 즉, 리포지토리는 객체의 저장, 삭제, 수정, 복원 등의 코드만 담당할 수 있어야 한다.
  * 반면 **중복 여부 체크 등의 로직은 도메인 규칙에 가까우므로 차라리 도메인 서비스가 주체가 되는 것이 바람직**하다.

## 테스트로 검증하기
```
> 도메인의 변화에 맞추어 소프트웨어를 변경하려면 테스트 수트를 미리 갖추어두어야 한다.
```
* 소프트웨어는 개발자의 의도가 아닌 코드를 따라 동작하므로, 개발자는 코드가 의도한 대로 짜여졌는지 항상 확인할 필요가 있다.
* 테스트는 이를 확인하는 대표적인 방법이며, 잘 짜여진 테스트 수트는 동작을 확인하는 목적 외에 소프트웨어의 유연성을 크게 향상시키기도 한다.
  * 소프트웨어를 변경하는 것은 간단한 작업이 아니지만, 테스트 수트가 미리 갖추어져 있다면 코드를 변경한 후에도 기능의 동작성을 쉽게 확인할 수 있다.
  * 즉, **잘 짜여진 테스트 수트는 소프트웨어 변경에 대한 검증 비용을 줄여줄 수 있다**.
* 반면, 리포지토리는 데이터 저장소 처리를 담당하므로 테스트를 위해 로컬 데이터베이스를 구성하는데에 많은 비용이 들 수도 있다.
  * 테스트에 드는 수고가 점점 커질수록 개발자는 감과 기도에 의존하게 되며, 테스트를 수행하지 않게 될 수 있다.
* 이 경우, **테스트의 효율성을 위해 리포지토리 인터페이스를 구현하는 인메모리 리포지토리를 새로 정의하여 쉽게 테스트를 진행하는 방법을 택할 수 있다**.

## 리포지토리에 정의되는 행위
* 리포지토리에 정의되는 행위는 객체의 저장, 수정, 파기, 그리고 복원에 대한 것이다.
* 객체를 저장하는 행위는 save, store 등의 적절한 이름을 명명할 수 있다.
* **객체를 수정하는 메소드는 객체의 구성 요소가 아닌 객체 자체를 인자로 전달받아야 한다**.
  * 이 경우, 객체를 수정하는 과정에서 수 많은 메소드를 양산하게될 수 있다.
  * 따라서 **객체가 저장하고 있는 데이터를 수정하려면 애초에 객체 그 자체에 맡기는 것이 바람직**하다.
* 생명주기를 갖는 객체는 필요를 다한 시점에 파기되어야하며, 리포지토리는 delete와 같은 메소드를 통해 이를 지원해야 한다.
* 객체의 복원에서 가장 자주 사용되는 것은 식별자를 활용한 객체 검색 메소드이다.
  * 기본적으로는 식별자를 키로 사용하는 get, find 등의 이름을 갖는 메소드를 구현하지만, 필요에 따라 조건을 만족하는 모든 객체를 검색해야하는 경우도 있다.
  * 이러한 목록 검색 메소드는 복원되는 객체의 개수가 많을 경우 메모리와 같은 리소스를 과도하게 사용할 수 있으므로, 반드시 검색 조건을 적절히 제한해야 한다.
    * 예를 들어, username이 일치하는 목록을 검색하는 등 조건을 제한할 수 있다.

## 결론
* 코드가 특정한 인프라 기술에 의존하면 소프트웨어가 전체적으로 경직되는 현상이 발생한다.
  * **데이터 저장소를 예로 들어, 코드의 대부분이 데이터 저장소를 직접 다루는 내용으로 오염되어 코드의 의도가 가려지게 된다**.
* **중요한 것은 도메인 객체가 도메인 지식을 표현하는 데에 집중하는 것이며, 특정한 기술에 종속되는 게터와 세터 등을 도메인 객체에 추가하지 않는 것**이다.
* 리포지토리를 활용하는 것으로 데이터 영속화와 관련된 처리를 추상화할 수 있으며, 이를 통해 소프트웨어의 유연성을 크게 향상시킬 수 있다.
  * 예를 들어, **개발 초기에 소프트웨어에서 사용할 데이터 저장소가 결정되지 않았더라도 인메모리 데이터베이스를 활용하여 로직 구현을 시작**할 수 있다.
  * 또한, **목적에 더 적합한 데이터 저장소를 활용하고자 하는 경우 새로운 리포지토리를 구현하여 데이터 저장소를 쉽게 교체**할 수 있다.
  * 무엇보다 개발자가 원하는 시점에 언제든지 테스트를 실행할 수 있다는 것이 중요하다.
```
> 도메인 규칙과 비교하면 데이터 저장소의 실체는 사소한 문제에 지나지 않는다.
> 리포지토리를 잘 활용하여 데이터 처리 로직을 추상화하면 도메인 지식이 코드에 더 잘 드러나며, 훗날 프로젝트를 진행할 다른 개발자에게 큰 도움을 줄 수 있다.
```
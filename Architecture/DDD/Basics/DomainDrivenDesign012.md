# DomainDrivenDesign
## 2022-05-03 Tue

## 애그리게이트
* 애그리게이트는 변경의 단위이며, 데이터를 변경하는 단위로 다루어지는 객체의 모임을 말한다.
* 애그리게이트에는 루트 객체가 있으며, 모든 조작은 루트 객체를 통해 이루어진다.
  * 따라서 애그리게이트의 내부 객체에 대한 조작에는 제약이 따르고, 이를 통해 애그리게이트 내부의 불변 조건이 유지된다.
* 또한 애그리게이트는 데이터 변경의 단위이기도 하므로, 트랜잭션이나 로크와도 밀접한 관련이 있다.

## 애그리게이트란 무엇인가?
* **객체 지향에서는 여러 객체가 모여 하나의 의미 있는 객체를 이룰 수 있으며, 이렇게 모인 객체는 어떠한 불변 조건을 유지해야 한다**.
  * 그러나 객체가 갖는 데이터에 대한 변경을 무제한적으로 허용한다면 이러한 불변 조건을 유지하기 어렵다.
  * 즉, 불변 조건을 유지할 수 있도록 객체를 다루는 데에도 어떠한 질서가 필요한 셈이다.
* **애그리게이트란 불변 조건을 유지하는 단위로 꾸려지며, 객체 조작의 질서를 유지**한다.
* 애그리게이트는 경계와 루트를 갖는다.
  * 경계란, 애그리게이트에 포함되는 대상을 결정한다.
  * 루트란, 애그리게이트에 포함되는 객체 중 특정한 객체를 말한다.
* **외부에서 애그리게이트를 다루는 조작은 모두 루트를 거쳐야 한다**.
  * 반면, **애그리게이트에 포함되는 객체는 외부에 노출되지 않는 것으로 불변 조건을 유지**할 수 있다.

### 애그리게이트의 기본 구조
* **애그리게이트는 서로 연관된 객체를 감싸는 경계를 통해 정의**된다.
* 외부에서는 애그리게이트 내부에 위치한 객체를 직접 조작할 수 없다.
  * 대신, **애그리게이트 루트가 애그리게이트를 조작하는 직접적인 인터페이스가 되는 객체 역할을 수행**한다. 
  * 때문에 **애그리게이트 내부 객체의 변경은 애그리게이트 루트에 변경을 요청하는 형태를 취해야 한다**.
* 앞서 다룬 그룹과 사용자의 예시에서, 그룹과 사용자는 각각 별개의 애그리게이트에 해당한다.
  * 이 경우, 사용자 애그리게이트의 정보를 수정하는 조작은 그룹 애그리게이트를 통하지 않는다.
  * 반면, 그룹에 사용자를 추가하는 조작은 그룹 애그리게이트가 다루어야 한다.
* 이 경우, 그룹 내부에 사용자 추가 메소드를 정의하고 사용자 수 체크 로직을 구현하는 것으로 사용자 목록을 외부로 공개하지 않을 수 있다.
  * 이를 통해 **그룹 당 가능한 사용자 수의 상한과 관련한 불변 조건을 항상 유지할 수 있다**.
* 이렇듯 **객체 지향 프로그래밍에서는 외부에서 내부 객체를 직접 다루지 않고, 내부 객체를 감싸는 객체에 요청하는 형태를 취하곤 한다**.
  * 이러한 방식은 디미터 법칙으로 알려지며, 불변 조건을 유지하면서도 직관과 조금 더 일치하는 코드를 만들 수 있도록 한다.

### 애그리게이트와 다이어그램
* 그룹에는 사용자 목록이 포함되므로, 이를 정확히 다이어그램에 표현하고자 별개의 애그리게이트인 사용자를 그룹에 포함시키는 다이어그램을 그릴 수 있다.
* 그러나 이러한 표현은 항상 바른 것이 아니며, 실제로는 그룹이 사용자 목록을 그 때 그 때 데이터 저장소에서 읽어들여 만들 수도 있다.
* **애그리게이트를 다이어그램으로 나타내는 것은 애그리게이트의 경계와 경계 내부에 포함되는 모델을 명시하는 데에 그 목적**이 있다.
  * 즉, **코드를 정확히 다이어그램으로 나타내는 것이 목적이 아니므로 애그리게이트 다이어그램이 반드시 코드와 일치할 필요는 없다**.

### 객체를 다루는 조작의 기본 원칙
* 객체 간의 어떠한 질서 없이 메소드를 호출하는 경우 불변 조건을 유지하기 어려울 수 있다.
* 디미터의 법칙은 객체 간의 메소드 호출에 질서를 부여하기 위한 가이드라인이 되어줄 수 있다.
* **디미터의 법칙은 어떠한 컨텍스트에서 다음 객체의 메소드만을 호출할 수 있도록 제한**한다.
  1. 객체 자기 자신
  2. 인자로 전달받은 객체
  3. 인스턴스 변수
  4. 해당 컨텍스트에서 직접 생성한 객체
* 디미터의 법칙은 소프트웨어의 유지보수성을 향상시키고, 코드를 더욱 유연하게 한다.
  * 또한, 이는 애그리게이트의 목표와도 부합하는 특징이다.

### 디미터의 법칙은 왜 적용해야 하는가?
* 앞서 다룬 그룹 당 사용자 수의 상한과 관련된 불변 조건에서, 다음과 같은 코드를 애플리케이션 서비스에 작성할 수도 있다.
```
if(group.members.size() >= 29) 
  throw new GroupFullException(groupId);
```
* 이는 디미터의 법칙에서 제안하는 접근 가능한 객체의 범위를 벗어나므로, 디미터 법칙을 위배하는 전형적인 코드이다.
* **이러한 코드를 허용하는 경우, 그룹의 사용자 수 상한과 관련된 로직이 여기저기에 흩어지게 만드는 문제점이 수반될 수 밖에 없다**.
  * 때문에 그룹의 사용자 수를 조작하는 모든 기능에 해당 로직이 중복될 수 있다.
  * 만약 최대 인원 수가 수정되는 경우, 모든 중복 로직을 찾아 수정해야 한다.
* **이렇듯 규칙에 대한 코드가 원래 있을 곳을 벗어나 여러 곳에 흩어지는 것을 못 본 척하는 것은 결국 개발자 자신의 업보로 돌아오기 쉽다**.
* **해당 코드는 members를 private 속성으로 수정하고, 그룹에 멤버를 추가하는 메소드를 작성하여 메소드 내부에서 사용자 수를 확인하도록 수정할 수 있다**.
  * 가능하다면 그룹에 포함된 사용자 수의 상한을 체크하는 isFull과 같은 메소드를 작성하여 유지보수성과 가독성을 향상시킬 수 있다.
  * 이를 통해 **그룹의 사용자 수의 상한과 관련된 지식은 모두 isFull 메소드에 집중되며, 수정사항을 반영하기도 쉬워진다**.
* 가능하다면 게터를 만들지 말아야하는 이유도 여기에 있다.
  * **게터를 통해 필드를 공개하면 객체에 구현되어야할 규칙이 다른 곳에서 중복 구현되는 것을 완전히 막을 수 없기 때문**이다.

### 내부 데이터를 숨기기
* 객체 내부의 데이터는 함부로 외부에 공개하지 않아야 하지만, 리포지토리 등의 객체가 영속화를 위해 객체 내부의 데이터에 접근해야 하는 경우가 있다.
* 이 경우, 가장 단순하고 일반적인 해결책은 팀 내 합의에 의한 보호를 들 수 있다.
  * 즉, 리포지토리 객체 외에는 애그리게이트의 내부 데이터에 접근하는 코드를 함부로 작성하지 않기로 합의하되, 이를 준수하도록 한다.
  * 이러한 방법은 적은 비용으로도 효과를 거둘 수 있지만, 강제성이 없어 실수로 규칙이 깨지기 쉽다는 단점이 존재한다.
* 또 다른 방법은 노티피케이션 객체를 활용할 수 있다.
  * 해당 방법을 사용하는 것으로 객체 내부의 데이터는 비공개로 둔 상태로 외부에 데이터를 전달할 수 있게 된다.
  * 그러나 작성할 코드의 양이 크게 늘어난다는 단점이 수반되므로, 노티피케이션 객체 및 관련 코드를 한 번에 생성하는 도구를 만들어 사용하는 것이 바람직하다.

## 애그리게이트의 경계 지정하기
* **애그리게이트의 경계를 정하는 원칙 중 가장 흔히 사용되는 것은 변경의 단위를 고려하는 것**이다.
* 앞선 시나리오의 예시로 들어, 그룹과 사용자는 별개의 애그리게이트에 해당한다.
  * **애그리게이트는 변경의 단위이므로, 그룹이나 사용자를 변경해야 하는 경우 각각의 애그리게이트 내부로 변경이 제한되어야 한다**.
* **이러한 원칙을 어기고 애그리게이트가 자신의 경계를 넘어 다른 애그리게이트에 변경을 시도하고자 하는 경우, 중복된 로직이 양산되는 문제가 발생할 수 있다**.
* 그룹과 사용자의 예시를 들어, 그룹 애그리게이트에서 자신에게 포함된 사용자 목록의 이름을 일괄 변경하는 기능을 제공한다고 가정한다.
  * 이 경우, **그룹은 사용자 애그리게이트까지 변경을 시도하므로 변경의 단위를 벗어나게 된다**.
  * **변경의 단위를 벗어나는 코드의 문제점은 특히 리포지토리에서 그 영향이 두드러지게 나타난다**.
    * 그룹 애그리게이트가 내부 데이터만을 변경하는 원칙을 준수한다면 리포지토리가 그룹에 대한 정보만을 저장하면 된다.
    * 그러나 그룹의 로직 상 사용자 정보까지 변경하는 경우, 그룹 리포지토리에서 사용자 정보를 수정하는 로직을 처리해야 한다.
    * 결과 **그룹 리포지토리의 코드가 사용자 관련 처리로 오염될 뿐더러, 사용자 리포지토리의 로직과 상당 부분이 중복된다는 단점이 존재**한다.
    * 이러한 현상은 전적으로 변경의 단위를 넘어서는 변경을 시도하기 때문에 발생한다.
* **애그리게이트에 대한 변경은 해당 애그리게이트에만 맡기고, 영속화 요청 역시 애그리게이트 단위로 진행하는 것이 바람직**하다.
  * 같은 이유에서, **리포지토리 역시 애그리게이트마다 하나씩 작성되어야 한다**.

### 식별자를 활용한 컴포지션
* 그룹 객체가 사용자 객체 자체를 컬렉션으로 저장하고, 프로퍼티를 통해 해당 객체에 접근할 수 있는 것 자체가 문제일 수 있다.
* 때문에 **그룹 객체가 사용자 객체의 목록을 갖기보다, 사용자 엔티티의 식별자 목록을 갖게하는 방법을 고려**해볼 수 있다.
  * 이러한 방식은 애그리게이트의 경계를 넘지 않는 불문율을 만드는 것보다 더 좋은 방법일 수 있다.
* 사용자는 엔티티이므로 식별자가 존재하고, 그룹 객체가 식별자 목록을 갖게하면 사용자 목록 속성을 공개하더라도 사용자 객체에 접근할 수 없게 된다.
  * 즉, 사용자 객체의 메소드를 호출할 수도 없다.
* 또한, **객체 목록이 아닌 식별자 목록을 속성으로 갖기 때문에 메모리를 절약하게 되는 부수 효과도 얻을 수 있게 된다**.

### 엔티티 식별자와 게터
* 게터는 가능한 한 두지 않는 것이 좋지만, 식별자의 게터라면 경우가 다르다.
* **식별자는 엔티티를 나타내기 위한 필연적인 속성이며, 그 자체로 애그리게이트를 대체할 수 있는 편리한 수단으로서 기능**한다.
* **식별자를 직접 대상으로 하는 비즈니스 규칙은 그리 많지 않으므로, 일반적으로 식별자는 공개하는 이점이 단점보다 큰 경우가 많다**.

## 애그리게이트의 크기와 조작의 단위
* **트랜잭션은 데이터에 락을 거는 식으로 동작하며, 이 때 애그리게이트의 크기가 클수록 락의 적용 범위도 비례적으로 커지게 된다**.
  * 따라서 애그리게이트의 크기가 너무 커지면 그만큼 애그리게이트를 대상으로 하는 처리가 실패할 가능성이 높다.
* 상술한 이유에서, **애그리게이트의 크기는 가능한 한 작게 유지하는 것이 좋다**.
* 애그리게이트가 지나치게 크다고 생각되는 경우, 애그리게이트의 범위를 재검토할 수 있어야 한다.
* 나아가 **하나의 트랜잭션에서 여러 애그리게이트를 다루는 것은 지양**해야 한다.
  * **여러 애그리게이트에 걸친 트랜잭션은 범위가 큰 애그리게이트와 마찬가지로 광범위한 데이터에 락을 걸 가능성이 높다**.

## 결과 무결성 고려하기
* 수정은 애그리게이트 단위로 진행하는 것이 이상적이나, 때로는 여러 애그리게이트에 걸친 수정이 반드시 필요한 경우가 있다.
* 이러한 경우에는 결과 무결성을 유용하게 활용할 수 있다.
  * **트랜잭션 무결성은 모든 순간에 유지되는 무결성에 해당**한다.
  * 반면, **결과 무결성은 처리 도중에 한해 특정 시점의 모순을 허용**한다.
* **시스템이 필요로 하는 무결성을 따져보았을 때, 반드시 모든 순간에 유지되는 무결성이 필요한 경우는 많지 않다**.
  * 따라서 트랜잭션 무결성을 적용하는 데에 문제가 있는 경우, 결과 무결성을 고려할 수 있다.

## 결론
* 애그리게이트는 정해진 공식을 따라 정의되는 개념이 아니다.
  * **도메인의 개념은 애초에 서로 밀접하게 엮여 있는 개념이며, 이들을 구분하는 경계를 정의하는 것은 그 자체로 어려운 작업**이다.
* 애그리게이트의 경계선을 정하는 일은 크게 다음과 같이 분류되는 과정이다.
  1. 도메인 개념을 잘 파악한다.
  2. 이에 따르는 불변 조건을 제대로 유도한다.
  3. 도메인과 시스템이 균형을 이루는 최적의 지점을 찾는다. 
* 이 과정에서, 어느 한 쪽으로 지나치게 기울지 않는 균형 잡힌 지점을 찾을 수 있어야 한다.
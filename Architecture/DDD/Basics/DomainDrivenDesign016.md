## 2022-05-05 Thu

## 프로젝트 구성하기
* 소프트웨어 개발에서 가장 먼저 해야하는 작업은 프로젝트 구성을 결정하는 일이지만, 이는 매우 까다로운 작업이다.
  * 여기서 결정된 내용은 소프트웨어의 생명주기 전체에 영향을 미친다.
  * 개발자가 리팩토링을 진행할 수도 있지만, 프로젝트의 근본적인 구성을 변경하는 리팩토링은 쉬이 도전할 수 있는 작업이 아니다.
  * 때문에 **프로젝트의 구성을 결정하는 작업은 매우 중요한 작업으로 여겨진다**.

### 도메인 레이어의 패키지 구성
```
> 이하의 내용은 계층형 아키텍쳐를 따르는 경우의 패키지 구성에 해당한다.
```
* **해당 레이어는 기술적 라이브러리에 의존하지 않도록 구성되어야 한다**.
* 도메인 패키지의 이름은 컨텍스트의 명칭을 따르되, [컨텍스트].Models.[애그리게이트] 형태로 패키지를 구성할 수 있다.
  * 이 때, 해당 패키지에는 애그리게이트를 구성하는 값 객체와 엔티티는 물론 팩토리나 리포지토리, 명세를 포함시킨다.
  * 앞선 시나리오에서, 엔티티 객체의 생성자는 팩토리나 리포지토리로부터 호출되는 것을 전제로 정의되기 때문에 이를 같은 클래스에 두어 연관성을 명시한다.
  * **이러한 스타일이 항상 옳은 것은 아니지만, 패키지를 배치할 때 적어도 클래스의 성격보다는 의미적인 유사성을 더 고려하는 것이 바람직**하다.
* 같은 이유에서, 명세 역시 도메인 객체와 함께 배치한다.
  * 명세의 개수가 너무 많은 경우, 각 애그리게이트의 하위에 Specification과 같은 명세 전용 패키지를 두어도 무방하다.
* 서비스 패키지 역시 [컨텍스트].Service 형태의 패키지 구성을 따르되, 도메인 서비스를 배치한다.
  * **서비스 객체는 둘 이상의 도메인 객체를 다뤄야 하는 경우가 많으므로, 상대적으로 중립적인 [컨텍스트].Service 패키지에 배치하는 것이 이상적**이다.
  * 물론 **특정 애그리게이트의 엔티티와 밀접한 연관이 있는 도메인 서비스의 경우, 도메인 객체의 패키지에 함께 두어도 무방**하다.

### 애플리케이션 레이어의 패키지 구성
* 커맨드 객체를 사용할 수 있도록 애플리케이션 서비스마다 별도의 패키지를 둘 수 있다.
  * 이 때, 하나의 패키지에 파일이 너무 많이 배치되는 경우에는 하위 패키지를 만들어 정리할 수 있다.
* **패키지 명은 Application.Users 와 유사한 형태를 따르되, 클린 아키텍쳐를 따르는 경우 각 애그리게이트 패키지 하위에 유즈케이스 패키지를 생성**한다.

### 인프라 레이어의 패키지 구성
* 인프라는 의존하는 기술 기반마다 별도의 패키지를 두거나, 또는 같은 패키지에 두어도 무방하다.

## 프로젝트의 구성
* 프로젝트를 구성하는 전략은 크게 다음과 같다.
  1. 모두 하나의 모듈에 모아두기
  2. 모두 별도의 모듈에 분리하기
  3. 애플리케이션과 도메인만 같은 모듈에 모으기
* 이 중, 두 번째와 세 번째 방법을 택하는 것이 바람직하다.

### 모두 별도의 모듈에 분리하기
* 해당 패키지 구성은 도메인 레이어의 재사용을 고려한 결과이다.
  * 각 도메인 패키지는 모듈 외부에서 참조 가능하므로, 해당 패키지에 속한 객체를 재사용하는 애플리케이션을 쉽게 구현할 수 있다.
* 그러나 **애플리케이션 서비스와 도메인 객체가 별도의 모듈에 위치하므로, 도메인 객체의 메소드는 반드시 public으로 공개되어야 한다**.
* 메소드의 공개 범위를 확장하는 경우 애플리케이션 서비스에서만 사용하기로 했던 메소드를 다른 위치에서도 호출할 수 있게 된다.
  * 때문에 **애플리케이션 서비스에서만 작성되어야 할 코드가 프리젠테이션 레이어로까지 퍼져나갈 가능성을 배제할 수 없게 된다**.
  * 이러한 방식은 레이어 간에 데이터를 주고 받을 때 반드시 DTO를 활용하도록 합의할 수 있으나, 가능하다면 시스템 차원에서 이를 제한하는 것이 바람직하다.

### 애플리케이션과 도메인만 같은 모듈에 모으기
* 도메인 객체의 메소드를 호출하는 클라이언트를 애플리케이션 서비스로만 한정하고 싶은 경우, 둘을 같은 모듈에 둘 수 있다.
* 이러한 구성은 internal과 같은 접근 제어자를 적용하여 메소드의 공개 범위를 제한할 수 있도록 돕는다.
* **해당 구성을 통해 원치 않는 메소드의 호출은 시스템 차원에서 차단이 가능**하다. 
  * 그러나 모듈 내부에 정의된 도메인 객체를 그대로 재사용하는 별도의 애플리케이션을 구현할 수는 없게 된다.

### 특정한 언어의 기능이 미치는 영향
* **프로그래밍 언어 역시 각각의 특색이 존재하므로, 이러한 특색이 패키지 구성에도 영향**을 미친다.
  * 예를 들어 Java의 default 접근 제어자와 C#의 internal 접근 제어자는 호출 제한 범위가 다르며, default가 더 제한적이다.
* 그럼에도 **패키지의 구성 방법에 정답은 없으며, 어떠한 방식을 통해 프로젝트와 패키지를 구성하더라도 그 근거와 논리를 반드시 명확히 정의**해두어야 한다.

## 결론
```
> 개발자는 코드의 배치 방식과 그 근거를 항상 자문하며, 최적의 프로젝트 구성을 찾아가려는 마음가짐을 가져야 한다.
```
* 개발자는 코드 뿐만 아니라 코드의 구성, 구조에서도 아름다움을 발견할 수 있다.
* 신중히 고민하여 결정한 프로젝트의 구성에도 이러한 아름다움이 깃들어 있다.
* 추후에 팀에 합류할 개발자를 위한 힌트를 제공하거나, 의도치 않은 호출을 방지하기 위해 언어가 제공하는 기능을 활용하는 패키지 구성을 도출할 수 있다.
  * 또한, 이는 개발 업무의 즐거움 중 하나이기도 하다!
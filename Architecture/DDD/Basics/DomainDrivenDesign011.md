# DomainDrivenDesign
## 2022-05-02 Mon

## 애플리케이션 제작하기
* 앞서 다룬 패턴들을 토대로 다음과 같은 순서를 통해 애플리케이션에 새로운 기능을 추가할 수 있다.
  1. 우선 요구사항을 토대로 어떤 기능이 필요한지 확인한다.
  2. 추가할 기능을 결정했다면, 해당 기능의 기반이 될 유즈케이스를 수립한다.
     * 때때로 **기능을 구현하기 위한 유즈케이스가 여럿인 경우도 존재할 수 있다**.
  3. **유즈케이스를 모두 수립했다면, 도메인 개념과 규칙으로부터 다시 애플리케이션에 필요한 지식을 추출하여 도메인 객체를 정의**한다.
  4. 정의된 도메인 객체를 토대로 유즈케이스를 실제 기능으로 제공할 애플리케이션 서비스를 구현한다.
* 이후에는 사용자 등록을 마친 후 사용자 간의 교류를 위한 그룹을 만드는 시나리오를 통해 위 과정을 따르도록 한다.

## 어떤 기능이 필요한가?
* 그룹은 같은 취미를 갖는 사용자끼리 교류하기 위해 결성되는 개념이다.
* 그룹 기능을 구현하기 위해 최우선적으로 필요한 유즈케이스는 다음과 같다.
  1. 그룹 만들기
  2. 그룹에 가입하기
* 유즈케이스를 수립했다면, 각 유즈케이스에 적용되는 비즈니스 규칙을 확인한다.
  * 그룹 기능의 경우, 다음과 같은 비즈니스 규칙이 적용된다고 가정하고 진행한다.
  1. 그룹에는 이름을 할당할 수 있다.
  2. 그룹의 이름은 중복되지 않아야 한다.
  3. 그룹의 이름에는 최소 및 최대 길이 제한이 존재한다.
  4. 그룹에는 그룹을 생성한 그룹장과 그룹에 가입한 사용자 목록이 포함된다.
  5. 그룹에 소속될 수 있는 사용자의 수는 그룹장을 포함하는 상한이 존재한다.

## 그룹에 대한 지식을 담는 객체 정의하기
* 그룹과 관련된 지식과 규칙이 정해졌으므로, 이들을 코드로 나타낼 수 있어야 한다.
* 우선 그룹을 구성하는 요소를 다음과 같이 정의한다.
  1. 그룹은 생명주기를 갖는 객체이므로, 엔티티로 정의되어야 할 개념이다.
  2. **생명주기를 표현하려면 식별자가 필요하며, 식별자는 값이므로 값 객체로 정의**한다.
  3. 그룹에는 이름을 붙일 수 있으므로, 이름 역시 값 객체로 정의한다.
  4. 값 객체로 정의된 그룹 이름에 그룹 이름 길이 규칙을 적용한다.
     * 나아가 **그룹 이름의 중복성을 확인하는 규칙에 대비하여 equals, hashCode 메소드를 재정의**해둔다.
  5. 상술한 과정에서 **정의된 값 객체를 활용하여 생명주기를 갖는 그룹 엔티티를 실제로 구현**한다.
  6. **그룹 객체를 생성하거나 영속화할 리포지토리와 팩토리는 도메인 객체와 유즈케이스를 구현하는 단계에서부터 실제로 구현할 필요는 없다**.
     * 그러나 **도메인 서비스 등을 통해 활용될 수 있는 상태여야 하므로, 필요한 경우 각각의 인터페이스만 정의하고 진행**한다.
  7. **그룹 이름의 중복성을 체크하는 로직은 그룹 객체에 정의하는 것이 자연스럽지 못하므로, 그룹 도메인 서비스를 정의하여 처리**한다.

## 유즈케이스 구현하기
* 그룹 생성 유즈케이스부터 하나씩 구현하되, 다음과 같은 절차를 따르도록 한다.
  1. **그룹 생성에 필요한 그룹 이름, 그룹장 정보를 담는 생성 커맨드 객체를 정의**한다.
  2. **그룹 생성 커맨드 객체를 받아 실제로 그룹을 생성하는 그룹 애플리케이션 서비스의 생성 메소드를 다음과 같이 정의**한다.
     1. 트랜잭션 범위를 적용한다.
     2. 사용자 리포지토리를 활용하여 그룹장 역할을 맡을 사용자가 실제로 존재하는지 확인한다.
     3. 그룹장이 실제로 존재하는 사용자인 경우, 팩토리로 그룹 엔티티 객체를 생성하고 그룹 도메인 서비스를 활용하여 그룹 이름의 중복을 확인한다.
     4. 그룹이 중복되지 않는 경우, 그룹 리포지토리를 통해 그룹을 저장한다.
     5. 트랜잭션을 완료한다.
* 사용자의 가입 유즈케이스 역시 같은 절차를 통해 구현하도록 한다.
  1. 커맨드 객체를 정의한다.
  2. 그룹 애플리케이션 서비스에 사용자 가입 메소드를 적용한다.
     1. 트랜잭션 범위를 적용한다.
     2. 사용자 리포지토리를 활용하여 사용자가 실제로 존재하는지 확인한다.
     3. 실제로 존재하는 사용자인 경우, 가입 대상이 그룹 리포지토리를 통해 실제로 존재하는 그룹인지 확인한다.
     4. 실제로 존재하는 그룹인 경우, 가져온 정보를 토대로 사용자 수 제한 조건에 위배되는지 확인한다.
     5. 문제 없는 경우, 그룹에 사용자를 추가하고 그룹 리포지토리를 활용하여 저장한다.
     6. 트랜잭션을 완료한다.

## 코드에 남은 개선사항
* 상술한 과정을 통해서 구현된 기능은 정상 동작하지만, 사용자 가입시 사용자 수를 체크하는 로직이 다음과 같은 이유에서 부자연스럽다.
  1. **그룹장과 사용자를 포함한 인원의 상한이 존재한다는 사실은 도메인에서 중요도가 높은 규칙**이다.
  2. 도메인 규칙은 반드시 도메인 객체에 구현되어야 한다.
  3. 그러나 상술한 로직대로 구현된 코드는 도메인 규칙이 도메인 객체가 아닌 애플리케이션 서비스에 구현되어 있다.
  4. 따라서 추후 사용자 초대 유즈케이스가 추가되는 경우, 중복되는 코드가 발생할 수 밖에 없게 된다.
  5. **사용자 수 체크 로직이 이곳저곳에 중복되는 경우, 도메인 규칙의 변경으로 인해 상한이 변경되어야 하는 경우의 수정 난이도를 높인다**.
* 이렇듯 규칙을 나타내는 코드가 프로그램 여기저기에 위치한다면 규칙이 변경된 경우 수정사항을 반영하기 어렵다.
* **문제의 원인은 한 곳에서 관리되어야 할 도메인 규칙이 서비스에 작성된 탓에 여러 곳에 흩어졌기 때문**이다.
  * **애그리게이트는 이러한 문제를 해결하기 위해 필요한 개념**이다.

## 결론
* 상술한 시나리오는 앞서 다룬 여러 패턴을 실제로 활용하는 과정에 해당한다.
* **실제 소프트웨어를 개발하는 경우에도 필요한 기능은 하향식으로 발굴하되, 구현은 상향식으로 진행하는 과정**을 거친다.
  * 이 경우, 구현은 도메인 지식을 나타낼 도메인 객체를 정의한 후에 유즈케이스를 구현하는 식으로 진행된다.
* 애플리케이션을 새로 제작하거나 기능을 추가하는 경우에는 우선 주제로 삼을 기능을 정한다. 
  * **그 후에는 기능 별로 어떤 유즈케이스와 어떠한 지식이 필요한지 충분히 고려하고나서 코드를 구현**하도록 한다.
  * **중요한 것은, 이렇듯 전체적인 도메인 주도 설계 절차를 많이 반복하는 것이 개념을 더욱 깊게 이해할 수 있는 지름길이라는 사실을 이해하는 것**이다.
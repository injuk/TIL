# DomainDrivenDesign
## 2022-04-28 Thu

## 생명주기를 갖는 엔티티
* **엔티티는 값 객체와 마찬가지로 중요한 도메인 객체**이다.
* 엔티티는 데이터베이스 테이블 설계, ORM 등에서도 사용되는 등 소프트웨어 분야에서 자주 사용되는 용어이나, 도메인 주도 개발에서는 그 의미가 다르다.

## 엔티티란 무엇인가?
* 도메인 주도 개발의 **엔티티는 도메인 모델을 구현하는 도메인 객체를 의미**한다.
* 반면, **값 객체 역시 도메인 모델을 구현한 도메인 객체에 해당**한다.
* **엔티티와 값 객체의 주요한 차이점은 동일성을 통한 식별 가능성의 여부**이다.
* 예를 들어, 시스템의 사용자는 최초 가입 시점에 등록한 정보를 대부분의 경우 임의로 수정할 수 있다.
  * 그러나 사용자 정보가 수정되었다고 한들 해당 사용자가 다른 사용자가 되지는 않는다.
  * **이름이나 별명을 수정하더라도, 사용자의 정보가 수정된 것일 뿐 사용자 자체가 대체되지는 않는다**.
* 이렇듯 사용자는 속성의 값이 아닌 동일성으로 식별되므로, 하나의 엔티티로 이해할 수 있다.
  * 소프트웨어 시스템에는 수많은 엔티티가 존재하며, 소프트웨어 개발과 밀접한 관계를 갖는다.

## 엔티티의 성질
```
> 값 객체는 동일성이 아닌 속성으로 식별되는 객체인 반면, 엔티티는 속성이 아닌 동일성으로 식별되는 객체이다.
```
* 엔티티와 값 객체는 모두 도메인 모델을 구현하는 도메인 객체라는 공통점을 갖는다.
* 반면, 엔티티는 값 객체와 비교하여 다음과 같은 성질적인 차이를 보인다.
  1. 엔티티는 가변적이다.
  2. 엔티티는 속성이 같아도 구분할 수 있다.
  3. 엔티티는 동일성을 통해 구별된다.

### 엔티티는 가변적이다.
* 값 객체는 불변성을 갖는 반면, 엔티티는 가변성을 갖는 객체이므로 시간이 지남에 따라 엔티티의 속성은 변화할 수 있다.
* 값 객체는 불변성을 갖기에 객체를 교환하여 수정하지만, **엔티티는 수정을 위해 객체를 교환하지 않는다**.
  * 대신 엔티티의 속성을 수정하고자 하는 경우, 객체가 제공하는 행동을 통해 수정한다.
* **엔티티 객체의 모든 속성이 반드시 가변적일 필요는 없다**.
  * 엔티티는 필요에 따라 속성을 가변으로 만들 수 있는 객체에 지나지 않는다.
  * 반면, **가변 객체는 기본적으로 다루기 까다로우므로 객체는 가능한 한 불변으로 만드는 습관을 들이는 것이 바람직**하다.

### 엔티티는 속성이 같아도 구분할 수 있다.
* 값 객체는 속성이 같은 경우 같은 것으로 취급할 수 있으나, **엔티티는 속성이 같아도 각 엔티티를 다른 것으로 취급**한다.
  * 예를 들어, 이름이 같다고 해서 같은 사람인 것은 아니다.
* 서로 다른 엔티티를 구분하기 위해서는 주로 식별자를 사용한다.
* **시스템을 사용하는 사용자와 같은 엔티티는 등가성이 아닌 동일성을 통해 식별해야 한다**.

### 엔티티는 동일성을 통해 구별된다.
* 객체 중에도 속성이 다른 경우에도 동일한 객체로 판단해야하는 경우가 있으며, 이들은 모두 동일성을 통해 식별되는 객체이다.
* **프로그램은 각 엔티티가 동일한지 판단할 수 없으므로 이를 판단하기 위한 수단을 제공해야 하며, 주로 식별자가 수단으로서 기능**한다.
  * 이 경우, 식별자는 동일성의 실체에 해당한다.
  * 때문에 **식별자는 가변 필드일 피요가 없다**.
* **식별자는 필드 형태로 저장되는 것만으로는 의미가 없으므로, 동일성을 비교하기 위한 행위를 따로 정의**해야 한다.
  * 예를 들어, equals 메소드 등을 재정의할 수 있다.
* **엔티티의 비교는 식별자만을 대상으로 하며, 때문에 속성의 차이와 관계 없이 객체의 동일성을 비교할 수 있다**.

## 생명주기와 연속성
* **값 객체와 엔티티는 모두 도메인 개념을 나타내는 객체이며, 생명주기의 존재 여부와 생명주기의 연속성은 둘을 나누는 판단 기준**이 된다.
  * 예를 들어, 사용자가 가입 후 생성되는 사용자 객체는 사용자가 탈퇴하여 삭제될 때까지 생명주기를 갖고 연속성을 지니므로, 엔티티로 판단할 수 있다.
* 생명주기를 갖지 않거나, 생명주기를 나타내는 것이 무의미한 개념의 경우에는 우선 값 객체로 다루는 것이 바람직하다.
  * 소프트웨어는 그 특성상 정확함을 필요로 하므로, 가변 객체는 신중히 다루어야할 성가신 존재이다.
  * 따라서 **불변으로 남겨둘 수 있는 것은 최대한 불변 객체로 남겨두어야 시스템을 단순하게 유지**할 수 있다.

## 값 객체도 될 수 있고 엔티티도 될 수 있는 모델
* **일반적으로 사물은 한가지 면만 갖지 않으므로, 완전히 동일한 개념도 시스템에 따라 값 객체로 만들거나 엔티티로 만들 수 있다**.
  * 즉, 같은 대상이라도 대상의 환경에 따라 모델링 방법은 달라질 수 있다.
* 이렇듯 **값 객체와 엔티티 모두 될 수 있는 개념이 있으므로, 소프트웨어의 종류에 따라 어느 쪽으로 모델링하는 것이 더 적절한지 고려할 수 있어야 한다**.

## 도메인 객체를 정의하는 경우의 장점
* **엔티티와 값 객체는 서로 다른 성질을 갖지만, 둘 모두 도메인 모델을 나타내기 위한 도메인 객체라는 공통점이 존재**한다.
* 이렇듯 도메인 객체를 정의하는 경우의 장점은 크게 다음과 같다.
  1. 자기 서술적인 코드를 작성할 수 있다.
  2. 도메인에 변경사항이 발생한 경우, 코드에 반영하기 쉽다.
* **이러한 장점은 최초 개발 시점보다는 개발 완료 후에 있을 유지보수 과정에서 빛을 발할 수 있다**.

### 자기 서술적인 코드
* 개발자는 자신이 참여하고 있는 소프트웨어에 대한 모든 정보를 알 수는 없다.
  * 예를 들어, 프로젝트 중간에 참여하는 경우를 예로 들 수 있다.
  * 이렇듯 개발자는 많은 상황에서 내부를 전혀 알지 못하는 소프트웨어를 다루게 된다.
* 대부분의 경우, 소프트웨어를 파악하기 위해 기능명세서와 같은 문서를 활용하려고 한다.
  * 그러나 기능 명세서는 굵직한 기능을 파악할 수는 있어도 세세한 정보를 모두 파악하기에는 어려운 경우가 많다.
* 이렇듯 **소프트웨어를 파악하는 과정에 문서가 적절한 도움을 주지 못하는 경우, 개발자는 코드에 의존할 수 밖에 없다**.
* 이 경우, **자신이 준수해야 할 규칙을 잘 전달하는 코드를 작성해두면 개발자는 해당 코드를 힌트로 삼아 코드에 자연스럽게 녹여진 규칙을 이해**할 수 있다.
  * **이는 도메인 주도 설게가 도메인을 잘 익힌 후에 도메인 모델을 정립하고, 이를 도메인 객체로 구현하는 과정을 거치기 때문에 가능**하다.
  * 도메인 모델과 관련된 규칙은 모두 도메인 객체에 옮겨지며, 이렇게 옮겨진 규칙은 도메인 객체의 유효성을 보장한다.
* 구현 내용에 대한 힌트가 전혀 없는 코드는 도메인을 이해하는 과정에서 정립된 규칙과 유효성을 이해시키기 어렵게 할 수 있다.
  * 때문에 **구현 내용과 관련된 규칙이 준수되고 있는지에 대한 판단은 모두 코드에 녹여낼 수 있어야 한다**.

### 쉬운 변경사항의 반영
```
> 도메인 객체의 행동과 규칙을 코드로 작성한 경우, 도메인에서 발생한 변경을 코드에 반영하기도 쉬워진다.
```
* 도메인의 규칙에 변경이 일어나는 경우, 도메인 모델은 도메인의 변경에 따라 변화하게 된다.
  * 이 때, **도메인 규칙의 변화는 반드시 코드에도 반영**되어야 한다.
* 수정이 필요한 부분이 프로그램 이곳 저곳에 흩어진 경우, 수정이 필요한 지점을 모두 찾아내어 수정하기는 쉽지 않다.
  * 이는 단순한 구조체의 형태로 도메인 객체를 작성한 경우에 해당한다.
* 반면 **구현된 규칙을 코드가 직접 보여주는 경우, 도메인 모델의 규칙이 기술된 코드를 쉽게 구별할 수 있으므로 수정사항을 간단히 반영할 수 있다**.
* 이렇듯 **도메인 객체와 관련된 행동이나 규칙을 코드로 미리 작성해두는 경우, 도메인 모델로 전달된 도메인의 변화를 도메인 객체까지 쉽게 전달할 수 있다**.
* 사람의 일은 변하기 쉬우며, 도메인 역시 그러한 특징을 갖는다.
  * 또한, 소프트웨어는 도메인에서 살아가는 사용자를 위한 것이다.
  * 따라서 도메인이 변화할 때마다 소프트웨어 역시 그에 맞추어 쉽게 변화할 수 있어야 한다.
  * **소프트웨어가 미래에도 변화에 적절히 대응하며 성장해나갈 수 있도록 하려면 코드에 많은 정보를 담아둘 수 있어야 한다**.

## 결론
* **다양한 행동이 명시된 객체는 해당 소프트웨어가 어떠한 도메인 지식에 관심이 있고, 그 지식을 어떻게 식별하는지 드러낸다**.
* 이렇게 **정의된 객체들은 추후 프로젝트에 참여할 개발자들이 도메인을 이해하는 데에도 큰 도움**을 줄 수 있다.
* 도메인에 대한 통찰은 구현시에도 드러날 수 있다.
  * 예를 들어, 이러한 통찰은 소프트웨어가 사람이 정의한 규칙의 애매모호함을 받아들이지 못하는 경우에 더욱 두드러진다.
  * **엔티티를 구현하는 과정에서 애매함을 느끼게 되었다면, 도메인을 파악하는 방법을 바꾸어야 한다는 신호로 받아들이도록 해야 한다**.
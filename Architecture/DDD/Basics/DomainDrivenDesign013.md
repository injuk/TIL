# DomainDrivenDesign
## 2022-05-03 Tue

## 명세
* 명세는 객체를 평가하기 위해 존재하는 객체이다.
* 객체를 평가하기 위해 복잡한 절차가 필요한 경우가 있으며, 이러한 절차를 해당 객체의 메소드로 표현하면 객체를 정의한 취지가 잘 드러나지 않는다.

## 명세란?
* 객체를 평가하는 절차가 단순한 경우 해당 객체의 메소드로 정의할 수 있으나, 복잡한 평가 절차가 필요할 수도 있다.
  * 또는 평가 절차 자체가 평가 대상 객체의 메소드로 정의되는 것이 부자연스러운 경우도 있다.
  * 이 때, **평가란 객체가 만족해야하는 조건을 충족하는지 검사하는 로직 전반을 의미**한다.
* 반면, 객체에 대한 평가는 도메인 규칙 중에서도 중요도가 높은 편에 속한다.
  * 일반적으로 이러한 객체 평가 절차는 애플리케이션 서비스에 구현되기 쉬우나, **도메인 규칙은 서비스에 구현하기에는 적절하지 못하다**. 
* **명세는 이러한 경우의 대체제로 도입되며, 임의의 객체가 해당 객체의 복잡한 평가 기준을 만족하는지 판정하는 역할을 수행**한다.

### 객체의 복잡한 평가
* 일반적으로, 임의의 객체가 특정한 조건을 만족하는지 평가하는 코드는 해당 객체에 메소드 형태로 정의된다.
  * 예를 들어 앞선 그룹의 시나리오에서, **사용자 수가 상한을 초과하는지 확인하는 메소드 역시 객체의 평가에 속한다**.
  * 이 경우, **평가는 단순하며 단지 값의 크기를 비교하는데 그치는 점에서 해당 객체의 메소드로 구현되어도 무방**하다.
* 반면 **객체가 준수해야하는 조건이 복잡해지는 경우, 해당 객체를 평가하는 과정도 마찬가지로 복잡**해지게 된다.
* 요구사항이 변경되어 그룹의 최대 인원이 그룹에 포함된 프리미엉 사용자의 인원 수에 따라 결정되어야 한다고 가정한다.
  * 이 경우, 그룹 객체는 사용자의 식별자 목록만을 갖고 있으므로 프리미엄 여부를 확인하기 위해 리포지토리를 사용해야 한다.
  * 그러나 **그룹 객체 자체는 리포지토리를 갖지 않으므로, 해당 기능은 애플리케이션 서비스에 구현되기 쉽다**.
* 그러나 앞서 다룬바와 같이 **도메인 규칙에서 비롯한 로직은 서비스에 포함되지 않아야 한다**.
  * 그룹의 사용자 수를 확인하는 것은 전적으로 도메인 규칙을 준수하기 위한 과정이다.
  * 이를 **애플리케이션 서비스에서 체크하도록 허용하는 경우, 도메인 객체는 자신의 역할을 빼앗기며 서비스 코드 상에 중복된 도메인 규칙이 작성**된다.
* 도메인 규칙은 도메인 객체에 작성되어야 하지만, 그렇다고 복잡한 평가 절차를 도메인 객체에 억지로 끼워넣으려면 반드시 리포지토리를 전달받아야 하게 된다.
  * **리포지토리는 도메인 설계에 포함된다는 점에서는 도메인 객체에 해당하지만, 도메인 개념에서 비롯된 객체는 아니다**.
  * 그룹 클래스가 사용자 리포지토리를 갖게된다는 것은 그룹 클래스가 도메인 모델을 나타내는 데에 전념하지 못한다는 의미이다.
* 상술한 이유에서, **엔티티나 값 객체가 도메인 모델을 나타내는 데에만 전념할 수 있으려면 리포지토리를 다루는 것은 가능한 한 피해야할 일**이다.

### 해결책으로서의 명세
* 복잡한 평가 절차를 대리하는 명세 객체를 도입하는 경우, 엔티티나 값 객체가 리포지토리를 다루지 않으면서도 문제를 해결할 수 있다.
  * 이 경우, 명세 객체는 리포지토리를 생성자로 전달받아 생성된다.
* 명세는 객체가 임의의 조건을 만족하는지 평가하는 역할만을 수행한다.
* 명세 객체의 도입으로 인해 평가 대상 객체는 복잡한 평가 절차 코드에 파묻히는 일 없이 원래의 의도를 잘 드러낼 수 있다.
  * 즉, **복잡한 객체의 평가 로직을 캡슐화하여 원래 객체의 의도를 잘 드러낼 수 있게 된다**.

### 의도가 잘 드러나지 않는 객체
* 객체를 평가하는 로직을 해당 객체에 모두 구현하는 경우, 객체의 원래 의도가 잘 드러나지 않게될 수 있다.
  * 즉, **너무 많은 평가 메소드에 의해 객체가 근본적으로 무엇을 위한 것이고 어떤 역할을 하는지 알기 어렵다**.
* 또한 **객체 평가 메소드를 객체에 그대로 남겨두는 경우, 객체에 대한 의존이 무방비하게 증가하여 변경에 대응하기 어렵게 될 수 있다**.
* **객체가 임의의 조건을 만족하는지 확인하기 위한 수단이 해당 객체에만 있어야 하는 법은 없으며, 명세 객체로 분리하는 선택지가 있다는 점을 기억해야 한다**.

### 명세에서도 리포지토리의 사용은 지양하기
* **명세 역시 엄연한 도메인 객체이므로, 내부에서 일어나는 입출력을 최대한 지양해야한다는 의견도 있다**.
  * 이 때, 리포지토리는 대표적인 입출력에 해당한다.
* 이 경우, 일급 컬렉션을 도입하는 방법을 고려할 수 있다.
  * **일급 컬렉션이란, List 등의 제네릭 컬렉션 객체를 포함하는 특화된 컬렉션 객체**를 말한다.
  * **일급 컬렉션을 도입하는 경우, 일급 컬렉션 객체에 기존 컬렉션 객체는 물론 관련된 식별자나 처리 메소드를 추가할 수 있다**.
* 도메인 객체에서는 리포지토리와 같은 입출력을 최대한 배제해야 하므로, 일급 컬렉션을 통해 이러한 원칙을 준수할 수 있다. 

## 명세와 리포지토리의 조합
* 명세는 단독으로 사용되기도 하지만, 리포지토리와 조합하여 사용할 수도 있다.
  * 다시 말해, 리포지토리가 명세를 전달받아 명세에 정의된 조건에 맞는 객체를 검색하는 방법으로 활용할 수 있다.
* 리포지토리에는 검색을 수행하는 메소드가 포함되지만, 검색에도 중요한 규칙이 포함되는 경우가 있다.
  * 이 경우, 리포지토리의 검색 기능을 수행하는 메소드에 중요한 도메인 규칙이 명시되게 된다.
  * 이러한 **도메인 규칙은 명세로 정의하되, 리포지토리에 명세를 전달하여 중요 규칙을 구현하는 코드가 리포지토리의 구현체에 명시되는 것을 방지**할 수 있다.

### 추천 그룹 검색하기?
* 앞서 다룬 그룹과 사용자 시나리오에서, 사용자에게 추천 그룹을 표시하는 기능을 추가한다고 가정한다.
* 이 경우, 우선 추천 그룹의 기준은 무엇인지 명확히 정의하는 것이 전제되어야 한다.
  * 합의에 의해 추천 그룹의 정의를 다음과 같이 결정했다고 가정한다.
  1. 최근 1개월 이내에 생성된 그룹
  2. 포함된 사용자 수가 10명 이상인 그룹
* 여지껏 사용자 및 그룹 검색은 리포지토리가 담당해왔으므로, 해당 기능 역시 그룹 리포지토리에 정의하는 것을 고려할 수 있다.
  * 이 경우, **코드 자체는 잘 동작하지만 추천 그룹을 결정하는 조건이 리포지토리의 구현체에 유출되는 문제가 발생**한다.
* **추천 그룹의 조건은 중요도가 높은 도메인 규칙이나, 이러한 규칙이 세부사항에 불과한 리포지토리의 구현체에 종속되는 것은 바람직하지 않다**.
```
> 리포지토리는 강력한 패턴이나, 오히려 그 강력함으로 인해 도메인의 중요 규칙이 세부사항 영역에 유출될 수 있다는 점에 주의해야 한다.
```

### 명세를 활용하여 해결하기
```
> 도메인의 중요한 지식은 가능한 한 도메인 객체로 표현해야 한다.
```
* **추천 그룹을 판단하는 코드는 말 그대로 임의의 그룹 객체에 대한 평가에 해당하므로, 명세로 정의할 수 있다**.
* 이 때, 명세를 활용한 추천 그룹의 검색은 다음과 같은 방식으로 구현할 수 있다.
  1. 리포지토리를 통해 그룹 목록을 모두 가져온 후, 목록에 포함된 그룹 하나하나에 명세 메소드를 호출하여 확인하는 방식
  2. 리포지토리의 검색 메소드 자체에 명세 인터페이스를 정의하고, 검색시 명세를 넘겨 리포지토리가 만족하는 객체를 확인하는 처리를 수행하는 방식
* **명세 인터페이스를 활용하는 경우, 검색 조건마다 리포지토리에 새로운 메소드를 추가할 필요가 없다**.
  * 대신 인터페이스를 구현하는 검색 조건 객체를 만들고, 리포지토리 내부에서 해당 객체의 조건 처리 메소드를 호출하도록 구현할 수 있다.
* **명세를 이용하는 방식을 통해 추천 그룹을 선정하는 조건을 애플리케이션 서비스가 아닌 도메인 객체에 구현**할 수 있다.

### 명세와 리포지토리를 함께 사용하는 경우의 성능 문제
* 리포지토리에 명세 인터페이스를 적용하고 검색시 구현체를 전달하는 기법은 도메인 규칙을 도메인 객체에서 유출되지 않게하며, 확장성까지 높일 수 있는 방법이다.
* 그러나 명세에 정의된 조건과의 부합 여부는 객체를 복원하고, 생성한 다음 명세의 메소드를 통해 하나하나 대조하여 확인하는 과정이다.
  * 데이터 건수가 많지 않다면 문제가 없으나, 데이터가 수 만 건을 넘어가면 매우 느려질 수 밖에 없다.
* 이렇듯 **리포지토리에서 명세를 필터로 활용하는 방식은 항상 성능을 고려**해야 한다.
```
> 의문: 검색시 쿼리로 필터링할 수 있지 않나? 왜 SELECT * FROM 으로만 데이터를 복원하려고 하는가? 
```

### 복잡한 쿼리는 리드 모델을 활용하기
```
> 때로는 명세와 리포지토리를 결합하여 사용하는 패턴을 활용하지 않는 것을 고려할 수 있어야 한다.
```
* 추천 그룹 검색과 같이 특수한 조건을 만족하는 객체를 검색하는 기능은 편리한 소프트웨어에는 필수적으로 포함되는 기능이다.
  * **이러한 기능은 대부분 사용자 편의성을 위해 존재하며, 때문에 성능 면에서도 요구사항이 높은 경우가 많다**.
* **시스템의 존재 의의는 사용자의 문제를 해결하는 것이며, 이 점은 다른 모든 것이 변해도 변하지 않는 전제**이다.
* **도메인의 보호를 근거로 사용자에게 불편을 강요하는 것은 옳은 길이 아니며, 사용자에게 적대적인 시스템은 조용한 죽음을 맞게될 수 밖에 없다**.
  * 도메인 영역을 보호하는 것도 물론 중요하지만, 애플리케이션은 특히 시스템 사용자를 의미하는 프리젠테이션 영역을 의식하지 않을 수 없다.
  * **프리젠테이션 계층의 요구사항에 특화된 유즈케이스는 편의성에 신경을 쓰는 시스템이라면 거의 필수적으로 필요**하다.
* 이러한 문제는 특히 리포지토리를 활용한 데이터 복원 과정에서 발생하기 쉽다.
* 때문에 **복잡한 읽기 작업에서 성능 문제가 우려되는 경우, 이러한 부분에 한해서만 도메인 객체의 제약에서 벗어나는 방법을 적용해볼 수 있다**.
* 읽기 작업은 복잡하지만, 동작 내용 자체는 도메인 로직이라고 할 만한 것이 거의 없다.
  * 반면, 쓰기 작업은 도메인에 의한 제약이 있는 경우가 많다.
* 때문에 **쓰기 작업에서는 도메인과 결합을 느슨하게 하기 위해 도메인 객체를 적극적으로 활용하지만, 읽기 작업은 그렇지 않은 경우가 있다**.
  * **이러한 아이디어는 CQS 또는 CQRS 개념에서 온 것이며, 객체의 메소드를 성격에 따라 읽기(쿼리)와 쓰기(커맨드)로 나누어 다루는 것이 핵심**이다.
  * 이는 프리젠테이션 계층의 성능적인 요구를 만족하면서도 시스템의 통제를 늦추지 않게 하는 효과를 얻을 수 있게 한다.

### 지연실행을 활용하여 최적화하기
* 지연실행을 활용하면 리포지토리를 그대로 사용하면서도 성능 문제를 해결할 수 있다.
  * 지연실행을 지원하는 컬렉션 타입은 실제 요소에 접근하기 전까지는 컬렉션을 확정하지 않는다.
  * C#의 경우, 지연실행을 지원하는 컬렉션 타입은 IEnumerable 타입이다.
* **지연실행을 적용하면 쿼리 실행은 실제로 데이터가 필요한 시점까지 지연**된다.
  * 때문에 모든 데이터를 우선 받아온 후에야 조건을 붙여 필터링하는 로직을 효율적으로 실행할 수 있다.
* **많은 ORM이 이를 지원하지만, 이는 코드가 임의의 ORM에 종속된다는 단점을 수반**한다.
  * 때문에 **리포지토리 구현 클래스가 계속해서 해당 ORM을 활용한다면 문제가 없으나, 그렇지 않을 가능성이 존재한다면 신중히 결정해야 한다**.

## 결론
* **객체가 임의의 조건을 만족하는지 평가하는 작업은 그 자체만으로도 지식이며, 명세는 이렇듯 객체를 평가하는 조건과 절차를 모델링한 객체**이다.
* 객체의 평가를 해당 객체 자체에게 맡기는 방식도 있지만, 이러한 방법이 항상 바람직하지는 않다.
  * 오히려 **명세와 같은 외부 도메인 객체에게 평가를 맡기는 코드가 가독성이 높은 경우가 많다**.
* 리포지토리에 명세 객체를 전달하여 필터링을 수행하는 기법은 확장성이 높지만 잠재적인 성능 문제가 발생할 가능성이 있다.
* **읽기 작업은 단순하지만 최적화를 필요로하는 경우가 많으므로, 때로는 도메인의 제약보다 클라이언트의 편의성을 우선적으로 고려할 수도 있어야 한다**.
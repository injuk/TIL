# Architecture
## 2022-01-23 Sun

### 소리치는 아키텍쳐
* 건물의 청사진을 보고 건물의 용도를 알 수 있듯, 애플리케이션의 아키텍쳐를 보고 시스템의 용도를 알 수 있어야 한다.
* **좋은 아키텍쳐는 시스템의 유즈케이스를 지원하기 위한 구조이며, 유즈케이스를 아키텍쳐의 중심에** 두어야 한다.
* 좋은 아키텍쳐는 프레임워크, 도구, 환경에 구애받지 않고 유즈케이스를 지원할 수 있는 구조를 기술할 수 있어야 한다.
  * 이러한 세부사항은 아키텍쳐가 사용하는 도구일 뿐, 아키텍쳐가 준수해야만 하는 대상이 되어서는 안된다.
  * 아키텍쳐는 개발 환경 문제나 도구 등 세부사항에 대해서는 프로젝트 후반까지 결정을 미룰 수 있어야 한다.
    * 예를 들어 스프링, 하이버네이트, 톰캣, MySQL 등에 대한 결정을 당장 할 필요 없으며, **결정을 쉽게 번복할 수 있어야** 한다.
* 웹 역시 입출력 장치로서의 전달 메커니즘에 불과하며, 애플리케이션이 웹을 통해 전달된다는 사실 조차 세부사항에 해당한다.
  * 시스템 **아키텍쳐는 시스템이 어떻게 전달될지에 대해 가능하다면 아무것도 알 수 없어야** 한다.
  * 시스템은 근본적인 아키텍쳐를 고치는 일 없이 콘솔 앱, 웹 앱, 웹서비스 앱의 형식으로 전달할 수 있어야 한다.
* 아키텍쳐가 유즈케이스를 최우선으로 하고 프레임워크와는 거리를 둔다면, 프레임워크 없이 필요한 유즈케이스 전부에 대해 단위 테스트가 가능해야 한다.
  * 테스트를 위해 웹 서버나 데이터베이스가 반드시 필요한 상황이 되어서는 안된다.
  * 엔티티 객체는 반드시 plain old object여야 하며, 유즈케이스 객체에 의해 조작될 뿐 세부사항에 의존해서는 안된다.
  * 프레임워크로 인한 어려움 없이도 있는 그대로 모든 것을 테스트할 수 있어야 한다.
* 결국 **아키텍쳐는 시스템을 이야기해야 하며, 시스템에 적용된 프레임워크에 대해서 이야기해서는 안된다**.
  * 신입사원이 소스 코드만 보고서도 시스템의 모든 유즈케이스를 이해할 수 있는 것이 이상적이다.

### 클린 아키텍쳐
* 여러 시스템 아키텍쳐가 고안되었지만, 모두 **관심사의 분리**를 목표로 삼는다.
  * 각 아키텍쳐는 최소한 하나의 업무 규칙 계층과 사용자 / 시스템 인터페이스를 위한 또 다른 계층 하나를 반드시 포함한다.
* 이러한 아키텍쳐들은 모두 시스템이 다음과 같은 특징을 갖도록 한다.
  1. 프레임워크 독립성: 아키텍쳐는 프레임워크의 존재 여부에 의존하지 않는다.
  2. 테스트 용이성: 업무 규칙은 UI, 데이터베이스, 웹 서버 등 외부 요소 없이 테스트할 수 있다.
  3. UI 독립성: 시스템의 나머지 부분을 변경하지 않고도 UI를 쉽게 변경할 수 있다.
  4. 데이터베이스 독립성: 업무 규칙은 데이터베이스에 결합되지 않고, 필요시 다른 DB로 교체할 수 있다.
  5. 외부 에이전시 독립성: 업무 규칙은 외부 세계와의 인터페이스에 대해 전혀 알지 못한다.

## 클린 아키텍쳐 다이어그램
* 클린 아키텍쳐 다이어그램(가칭)은 다음의 4개의 동심원으로 구성된다.
  1. 엔티티: 가장 내부에 위치한 동심원이며, 고수준의 정책이다.
  2. 유즈케이스
  3. 인터페이스 어댑터: 컨트롤러, 게이트웨이, 프레젠터 등이 포함된다.
  4. 프레임워크와 드라이버: UI, 웹, 장치, DB, 외부 인터페이스 등이 포함되며, 가장 외부에 위치한 동심원이다.
* 위 아키텍쳐가 동작하도록 하는 **가장 중요한 규칙은 의존성 규칙**이다.
  * **소스 코드 의존성은 반드시 안 쪽에 위치한 고수준의 정책을 향해야** 한다.
* **내부 동심원에 속한 요소는 외부 원에 속한 무엇도 알지 못한다**.
  * 따라서 내부에 속한 코드는 외부에 선언된 무엇도 직접적으로 언급해서는 안된다.
  * 외부에서 선언된 데이터 형식 역시 내부에서 사용되어서는 안된다.
* 이는 예시이며, 추가적인 원을 배치할 수 있으나 **어떠한 경우에도 의존성 규칙은 적용**된다.
  * 소스 코드 의존성은 항상 안쪽을 향하며, 안쪽의 계층은 상대적으로 더 높은 추상화와 정책의 수준을 갖는다.
    * 반대로 외부의 계층은 구체적인 세부사항으로 구성된다.

### 엔티티
* 엔티티는 전사적인 핵심 업무 규칙을 캡슐화한다.
  * 메소드를 가지는 객체이거나, 일련의 데이터 구조와 함수의 집합일 수 있다.
* 외부의 변경 사항에 의해 엔티티 계층은 절대로 영향받지 않아야 한다.
* 운영 측면에서의 애플리케이션 변경 사항은 엔티티 계층에 영향을 주어서는 안된다.

### 유즈케이스
* 유즈케이스 계층의 소프트웨어는 애플리케이션에 특화된 업무 규칙을 포함한다.
* 또한 해당 계층의 소프트웨어는 시스템의 모든 유즈케이스를 캡슐화하고 구현한다.
* 유즈케이스는 엔티티로 들어오고 나가는 데이터 흐름을 조정한다.
  * 이를 통해 엔티티가 자신의 핵심 업무 규칙을 사용하여 유즈케이스의 목적을 달성하도록 조작한다.
* 외부 계층에서 발생한 변경 사항이 유즈케이스 계층에 영향을 줘서는 안되며, 유즈케이스의 변경이 엔티티에 영향을 주어서도 안된다.
* 운영 측면에서의 애플리케이션 변경 사항은 유즈케이스 계층에 위치한 소프트웨어에 영향을 주며, 변경을 유발한다.

### 인터페이스 어댑터
* 인터페이스 어댑터 계층은 일련의 어댑터로 구성된다.
* **어댑터는 데이터를 유즈케이스와 엔티티에게 가장 편리한 형식으로부터 DB, 웹 등 외부 에이전시에 편한 형식으로 변환**하는 일을 수행한다.
* 해당 계층은 데이터를 엔티티와 유즈케이스가 사용하기에 편리한 형식에서 영속성 계층에서 사용하는 프레임워크(= DB)가 이용하기 편리한 형식으로 변환한다.
  * 이 과정에서, **해당 계층에 속한 소프트웨어의 어떤 코드도 데이터베이스에 대해 알 수 없어야** 한다.
    * SQL 기반의 데이터베이스를 사용한다면, 모든 SQL은 이 계층에 위치한 데이터베이스를 담당하는 부분을 벗어나서는 안된다.
* 또한 데이터를 외부 서비스와 같은 외부적인 형식에서 유즈케이스나 엔티티가 사용하기 편리한 내부 형식으로 변환하는 별개의 어댑터도 필요하다.
* 예를 들어,인터페이스 어댑터 계층은 GUI의 MVC 아키텍쳐를 모두 포괄한다.
  * 프레젠터, 뷰, 컨트롤러는 모두 해당 계층에 속하며, 모델은 데이터 구조에 지나지 않는다.
    * 모델은 컨트롤러로부터 유즈케이스로 전달된다.
    * 모델은 다시 유즈케이스로부터 프레젠터와 뷰로 전달된다.

### 프레임워크와 드라이버
* 가장 바깥 계층이며, 데이터베이스나 웹 프레임워크와 같은 도구들로 구성된다.
* 일반적으로, 이 계층에서는 내부의 동심원과 통신하기 위한 코드 외에는 추가로 작성해야할 코드가 많지 않다.
* 해당 계층은 모든 세부사항이 위치하며, 웹과 데이터베이스 역시 세부사항으로 취급된다.
  * 아키텍쳐는 이러한 내용을 외부에 위치시키고, 피해를 미연에 방지하여 최소화한다.

### 경계의 횡단
* 예를 들어, 제어 흐름은 컨트롤러에서 시작하여 유즈케이스를 지나 프레젠터에서 실행되어야 한다.
* 이 경우, 소스 코드 의존성은 컨트롤러와 프레젠터 모두 유즈케이스 계층을 향해야 한다.
* 이렇듯 **제어흐름과 의존성의 방향이 반대여야 하는 경우, 의존성 역전 원칙을 적용하여 해결**할 수 있다.
  * Java의 경우, 제어흐름이 경계를 가로지르는 지점에 인터페이스와 상속을 적절히 배치하여 소스 코드 의존성을 제어 흐름과 반대되게 할 수 있다.
  * 별다른 조치를 취하지 않은 경우 제어흐름에 따라 구현된 코드는 내부의 코드가 외부의 코드를 호출한다.
    * 이 지점에 의존성 역전 원칙을 적용하여 외부의 코드가 내부의 코드를 호출하도록 만든다.
* 아키텍쳐 경계를 횡단할 때 언제라도 의존성 역전 기법을 활용할 수 있다.
  * 동적 **다형성을 통해 소스 코드 의존성을 제어흐름과 반대로 만들 수 있으므로, 제어흐름에 관계 없이 의존성 규칙을 준수할 수 있다**.

### 경계를 횡단하는 데이터 구조
* 경계를 가로지르는 데이터는 구조체나 데이터 전송 용 객체 등, 간단한 데이터 구조로 이루어져야 한다.
* 엔티티 객체나 데이터베이스의 row를 전달하는 것은 데이터 구조가 의존성을 갖게 되므로 바람직하지 않다.
* 예를 들어 데이터베이스 프레임워크는 쿼리 결과로 사용하기 편리한 데이터 포맷을 사용한다.
  * 그러나 이 구조가 경계를 넘어 내부로 그대로 전달된다면, 내부의 코드가 외부의 요소를 알게 된다.
  * 이러한 결과는 우리가 원하는 바가 아니며, **경게를 가로질러 전달되는 데이터는 항상 내부에서 사용하기 편리한 형태로 가공되어야 한다**.
* 외부 계층에서 구현해야 할 인터페이스와 사용할 데이터 구조는 내부 계층에 위치한다.

### 클린 아키텍쳐의 이점
* 상술한 규칙을 준수하는 일은 어렵지 않다.
* 소프트웨어를 계층으로 분리하고 의존성 규칙을 준수한다면 본질적으로 테스트가 쉬운 시스템이 만들어진다.
* 추후 데이터베이스와 웹 프레임워크와 같은 시스템 외부 요소에 대해 변경이 결정되더라도, 이를 어렵지 않게 교체할 수 있게 된다.

## 2022-01-24 Mon
## 험블 객체 패턴
* 험블 객체 패턴은 디자인 패턴 중 하나이며, 테스트하기 어려운 행위와 테스트하기 쉬운 행위를 단위 테스트 작성자가 분리하기 쉽게 하기 위해 고안된 방법이다.
* 험블 객체는 다음과 같은 순서에 따라 만들 수 있다.
  1. 각 행위를 두 개의 모듈 또는 클래스로 나누고, 두 모듈 중 하나를 험블 객체로 지정한다.
  2. 테스트하기 어려운 행위를 모두 험블 객체로 옮긴다.
  3, 남은 모듈에는 험블 객체에 속하지 않은, 테스트하기 쉬운 행위를 옮긴다.
* 험블 객체 패턴을 활용하여 **행위를 테스트하기 쉬운 부분과 어려운 부분으로 분리하면 자연스럽게 아키텍쳐의 경계가 정의**된다.
  * 험블 객체 패턴은 이를 통해 좋은 아키텍쳐의 특징인 '테스트 용이성'을 지니도록 한다.
  
### 프레젠터와 뷰
* 예를 들어 험블 객체 패턴을 사용하면 데이터를 화면에 표시하는 행위를 프레젠터와 뷰로 나눌 수 있다.
  * 프레젠터: 유즈케이스의 결과로 생성된 output 데이터를 화면에 표시할 수 있는 형식으로 재구성한다.
    * 테스트하기 쉬운 객체이며, 애플리케이션으로 데이터를 받아 화면에 표현할 수 있는 포맷으로 만드는 역할을 한다.
    * 프레젠터가 존재함으로 인해 뷰는 데이터를 화면에 전달하는 간단한 일만 수행하도록 한다.
  * 뷰: 험블 객체이며, 프레젠터로부터 전달 받은 데이터를 화면에 표시하기만 한다.
    * 험블 객체이므로 테스트가 어렵고, 따라서 데이터를 GUI로 옮기는 역할만 수행하도록 한다. 즉, 보잘것 없는(humble) 역할을 수행한다.
    * 험블 객체로서의 뷰는 데이터를 처리하는 작업을 포함하지 않는다.
* 상술한 논리에 따라, 프레젠터와 뷰 사이도 아키텍쳐의 경계가 된다.

### 데이터베이스 게이트웨이
* 유즈케이스와 데이터베이스 사이에는 데이터베이스 게이트웨이가 존재한다.
* **데이터베이스 게이트웨이는 다형적 인터페이스이며, 애플리케이션이 데이터베이스에 수행하는 CRUD와 관련된 모든 메소드를 포함**해야 한다.
* 유즈케이스 계층에 포함된 소프트웨어의 코드에는 SQL을 허용하지 않는다. 
  * 유즈케이스 계층은 필요한 메소드를 제공하는 게이트웨이 인터페이스를 호출할 뿐이다.
  * 게이트웨이 인터페이스의 구현체는 데이터베이스 계층에 위치하며, 이 역시 험블 객체에 해당한다.
  * 구현체는 SQL을 직접 사용하거나, 별도의 인터페이스를 통해 게이트웨이 인터페이스에서 요청한 데이터에 접근한다.
* 유즈케이스는 애플리케이션에 특화된 업무 규칙을 캡슐화하는 험블 객체이다.
  * 이 때, 게이트웨이는 스텁이나 모킹으로 교체될 수 있으므로 테스트가 쉽다.

### 데이터 매퍼
* ORM, 객체 관계 매퍼는 사실상 존재하지 않는다고 볼 수 있다. 이를 위해 객체와 데이터 구조를 구분해볼 필요가 있다.
* 객체란?
  * 사용하는 사람의 관점에서, 객체 사용자는 private한 데이터를 볼 수 없다. 
  * 사용하는 사람은 public 메소드만 볼 수 있으므로, **객체는 단순히 오퍼레이션의 집합**이다.
* 데이터 구조란?
  * 함축된 행위를 갖지 않는, **public한 데이터 변수의 집합**이다.
* 이에 따라, ORM이라는 용어보다는 데이터베이스로부터 가져온 데이터를 데이터 구조에 맞게 담아주는 데이터 매퍼라는 표현이 적절하다.
* 이러한 **ORM, 데이터 매퍼 시스템은 데이터베이스 계층에 위치**해야 한다.
  * ORM은 게이트웨이 인터페이스와 데이터베이스 사이에서 일종의 험블 객체 경계를 형성한다.

### 서비스 리스너
* 애플리케이션이 다른 서비스와 상호작용 하는 경우에도 험블 객체 패턴을 발견할 수 있다.
* 애플리케이션이 외부 서비스로 데이터를 제공하는 경우,
  * 데이터를 간단한 데이터 구조 형태로 로드하고, 경계를 가로질러 특정 모듈로 전달한다.
  * 해당 모듈은 데이터를 적절한 포맷으로 변경하여 외부 서비스로 전달한다.
* 애플리케이션이 외부 서비스로부터 데이터를 수신하는 경우,
  * 서비스 리스너가 서비스 인터페이스로부터 데이터를 수신한다.
  * 데이터를 애플리케이션에서 사용할 수 있는 구조로 변경한다.
  * 변경된 데이터 구조를 서비스 경계를 가로질러 내부로 전달한다.

### 험블 객체 패턴의 이점
* 아키텍쳐 **경계마다 경계 가까이에 험블 객체 패턴이 숨어 있다**.
* 경계를 넘나드는 통신은 거의 대부분 간단한 데이터 구조를 수반하며, 대개 그 경계는 테스트하기 어려운 개념과 쉬운 개념으로 분리된다.
* 이렇듯 아키텍쳐 **경계에서 발견된 험블 객체 패턴은 전체 시스템의 테스트 용이성을 크게 높여준다**.

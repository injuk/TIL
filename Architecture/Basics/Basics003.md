# Architecture
## 2022-01-20 Thu

## 컴포넌트 원칙
* 대규모 소프트웨어 시스템은 작은 컴포넌트들로 구성된다.
* SOLID 원칙이 벽과 방에 벽돌을 배치하는 방법을 알려준다면, 컴포넌트 원칙은 방을 배치하는 방법을 알려준다.

### 컴포넌트
* **컴포넌트는 시스템의 구성 요소로 배포할 수 있는 가장 작은 단위**이다.
  * Java의 jar, dotnet의 dll이 이에 해당한다.
* 잘 설계된 컴포넌트는 반드시 독립적으로 배포가 가능하고, 독립적으로 개발 가능한 능력을 갖춰야만 한다.
* 런타임에 플러그인 형태로 결합할 수 있는 동적 링크 파일이 소프트웨어 컴포넌트에 해당한다.
  * 예시: 마인크래프트의 모드를 생성하고 싶다면, 특정 폴더에 jar 파일만 추가하면 된다.
* 그렇다면 어떤 컴포넌트에 어떤 클래스를 포함시켜야 할까?

### REP - 재사용 / 릴리즈 등가 원칙
* 재사용 단위는 릴리즈 단위와 같아야 한다.
  * 하나의 컴포넌트로 묶인 클래스와 모듈은 반드시 함께 릴리즈할 수 있어야 한다.
  * 하나의 컴포넌트로 묶인 클래스와 모듈은 버전 번호가 같고, 동일한 릴리즈로 추적 관리되어야 한다.
  * 릴리즈 번호가 없다면 재사용 가능한 컴포넌트들이 서로 호환되는지 보증할 방법이 없다.
* 단일 컴포넌트는 응집성 높은 클래스와 모듈들로 구성되어야 한다.
  * 무작위 클래스와 모듈로 구성되어서는 안된다.
  * 하나의 컴포넌트로 구성된 모든 모듈은 서로 공유하는 중요한 테마나 목적이 있어야만 한다.
* REP는 다른 원칙에 비해 '어떤 클래스와 모듈을 단일 컴포넌트로 구성해야 하는지'를 설명하기가 어렵다.
  * 그러나 원칙 자체는 매우 중요하며, 약점은 CCP와 CRP의 강점으로 보완할 수 있다.

### CCP - 공통 폐쇄 원칙
```
- 동일한 이유로 동일한 시점에 변경되는 클래스는 같은 컴포넌트로 묶어야 한다.
- 서로 다른 이유로 서로 다른 시점에 변경되는 클래스는 다른 컴포넌트로 분리해야 한다.
```
* **공통 폐쇄 원칙은 단일 책임 원칙을 컴포넌트 관점에서 바라본 원칙**이다.
  * SRP: 단일 클래스는 변경의 이유가 여러 개 있어서는 안된다.
    * 서로 다른 이유로 변경되는 메소드는 서로 다른 클래스로 분리해야 한다.
  * CCP: 단일 컴포넌트는 변경의 이유가 여러 개 있어서는 안된다.
    * 서로 다른 이유로 변경되는 클래스는 서로 다른 컴포넌트로 분리해야 한다.
  * 두 원칙은 공통적으로 동일한 시점에 동일한 이유로 변경되는 것들을 한 곳에 묶는 것을 권장한다.
* 대다수의 애플리케이션에서 유지보수성은 재사용성보다 훨씬 중요하다.
  * 때문에 애플리케이션의 코드가 반드시 변경되어야 한다면, 여러 컴포넌트에 걸친 변경보다 단일 컴포넌트에서 변경되도록 제한하는 것이 좋다.
  * 단일 컴포넌트로 제한된 변경은 단일 컴포넌트의 재배포로 해결이 가능하다.
  * 변경된 컴포넌트에 의존하지 않는 컴포넌트는 재검증 / 재배포의 필요가 없다.
* 공통 폐쇄 원칙에 의해, **같은 이유로 변경될 가능성이 있는 클래스는 모두 하나의 컴포넌트로** 묶여야 한다.
  * 물리적 / 개념적 이유에서 강하게 결합되어 항상 함께 변경되는 클래스는 하나의 컴포넌트에 속해야 한다.
* 공통 폐쇄 원칙은 개방 폐쇄 원칙과도 밀접한 관련이 있다.
  * OCP: 클래스는 변경에는 닫혀 있고 확장에는 열려 있어야 한다.
  * CCP: 동일한 유형의 변경에 대해 닫혀 있는 클래스들은 하나의 컴포넌트로 묶어야 한다.
* 이로 인해 CCP가 적용된 경우, 변경 요구사항이 발생했을 때 변경이 영향을 주는 컴포넌트들이 최소한으로 한정될 수 있다.

### CRP - 공통 재사용 원칙
* 컴포넌트 사용자들이 필요하지 않은 것에 의존하도록 강요해서는 안된다.
* 같이 재사용되는 경향이 있는 클래스와 모듈들은 같은 컴포넌트에 포함되어야 한다.
  * 대체로 재사용이 가능한 클래스는 재사용 모듈의 일부로 해당 모듈의 다른 클래스와 상호작용하는 경우가 많다.
  * 이런 클래스들은 동일한 컴포넌트에 포함되어 있어야 한다.
* **강하게 결합되지 않은 클래스들은 동일한 컴포넌트에 포함시키지 말아야** 한다.
  * 어떤 컴포넌트에 의존하고 있다면, 해당 컴포넌트의 모든 클래스에 대해 의존하는 것을 인지해야 한다.
  * 한 컴포넌트에 속한 클래스들은 더 작게 분류할 수 없다.
    * 즉, 컴포넌트의 일부에만 의존하고 다른 클래스들과는 독립적일 수 없음을 알아야 한다.
* 공통 재사용 원칙은 인터페이스 분리 원칙의 포괄적인 버전이다.
  * ISP: 사용하지 않은 메소드가 있는 클래스에 의존해서는 안된다.
  * CRP: 사용하지 않은 클래스가 있는 컴포넌트에 의존해서는 안된다.
  * 즉, **필요하지 않은 것에 의존하지 않아야** 한다.

### REP, CCP, CRP의 관계
* 세 가지 원칙은 서로 상충된다.
  * REP와 CCP는 포함 원칙으로, 컴포넌트를 크게 만들고자 한다.
  * CRP는 배제 원칙으로, 컴포넌트를 작게 만들고자 한다.
* 세 원칙은 tradeoff 관계이며, 임의의 원칙에 중점을 두면 잃게 되는 비용이 있다.
  1. REP / CRP 중점: 유지보수성을 위한 포함 원칙인 CCP를 잃게 되므로, 컴포넌트 변경이 빈번해진다.
  2. REP / CCP 중점: 불필요한 릴리즈를 피하기 위한 배제 원칙인 CRP를 잃게 되므로, 불필요한 릴리즈가 빈번해진다.
  3. CCP / CRP 중점: 재사용성을 위한 포함 원칙인 REP를 잃게 되므로, 재사용성이 떨어지게 된다.
    * 이는 **프로젝트의 재사용성보다 개발가능성에 초점을 맞춘 형태**이다.
* 아키텍트는 자신이 속한 개발 팀이 관심을 기울이는 부분을 충족시키는 위치를 찾아야 한다.
  * 또한, 시간이 흐름에 따라 개발 팀이 관심을 갖는 부분이 변한다는 사실도 염두에 두어야 한다.
* 일반적으로 프로젝트 초기는 REP를 희생시킨 상태에서 시작하는 편이다.
  * 프로젝트가 성숙되고, 해당 프로젝트로부터 파생된 또 다른 프로젝트가 시작되면 점차 가치가 변하게 된다.
    * 시간의 흐름에 따라 프로젝트의 초점은 개발 가능성에서 재사용성으로 바뀌어 간다.
    * 이에 따라 컴포넌트의 구성 방식 또한 조금씩 흐트러지고, 또 진화한다.
  * 즉, **프로젝트의 컴포넌트 구조는 시간과 성숙도에 따라 가변적인 구조**이다.
* **컴포넌트 구조는 프로젝트가 실제로 수행하는 일보다 프로젝트가 발전되고 사용되는 방법과 더 관련**이 있다.
* 어느 클래스를 묶어서 컴포넌트로 만들지 결정할 때, '재사용성'과 '개발가능성' 이라는 상충하는 힘을 고려해야 한다.
  * 이들 사이에서 애플리케이션의 요규에 맞는 균형점을 잡는 일이 중요하며, 또한 균형점은 언제나 유동적이라는 사실을 인지해야 한다.

## 컴포넌트 결합
* 컴포넌트 사이의 관계를 설명할 수 있는 세 가지 원칙이 있다.
* 컴포넌트 결합과 관련된 원칙들 역시 개발 가능성과 논리적 설계 사이의 균형을 다룬다.

### ADP - 의존성 비순환 원칙
* 컴포넌트 의존성 그래프에는 순환이 있으면 안된다.
* 이상적인 컴포넌트 개발 환경은 다음과 같이 이루어진다.
  1. 개발 환경을 릴리즈 가능한 컴포넌트 단위로 분리하는 데에서 시작한다.
     * 이를 통해 컴포넌트는 개별 개발자, 또는 단일 개발 팀이 책임질 수 있는 작업 단위가 된다.
  2. 개발자는 자신이 담당하는 컴포넌트를 개발하여 동작 가능하게 만든 후, 릴리즈 번호를 부여한다.
  3. 다른 팀에서는 릴리즈 번호와 릴리즈 문서를 기준으로 새 릴리즈를 적용할지 결정한다.
     * 이 경우, 어떤 팀도 다른 팀의 개발 진행 상황에 의존하지 않게 된다.
  * 이러한 환경에서 시스템 통합은 작게, 점진적으로 이루어진다.
  * 이러한 방식은 단순하고 합리적이므로 널리 사용된다.
* 그러나 상술한 방식이 성공적으로 동작하려면 컴포넌트 사이의 의존성 구조가 관리되어야 한다.
  * 이 때, 컴포넌트 의존성 구조에 순환이 있어서는 안된다!
* 이상적인 개발 환경은 컴포넌트의 관계를 나타내는 컴포넌트 다이어그램에서, 의존성 관계를 따라가더라도 자신으로 돌아올 수 없어야 한다.
  * 이러한 다이어그램은 순환적인 구조를 포함하지 않으며, 비순환 방향 그래프(DAG)의 형태를 갖는다.
  * 이러한 구조는 시스템 절차를 릴리즈해야할 때 상향식으로 진행된다. 
    * 이렇듯 시스템 간의 의존성 관계를 파악하고 있으면 시스템의 빌드 방식도 알 수 있다.
* 순환 의존성이 발생한 경우,
  * 순환 구조를 갖는 컴포넌트들이 사실상 하나의 거대한 컴포넌트가 된다.
  * 순환 구조를 갖는 컴포넌트들은 항상 정확하게 동일한 릴리즈를 사용해야 한다.
  * 순환 구조를 갖는 컴포넌트 중 하나의 변경 사항이 다른 컴포넌트들의 빌드와 통합을 요구하게 된다.
  * 순환이 발생한 컴포넌트들은 분리가 어려워진다.
* 순환 끊기
  * 순환 의존성은 언제라도 끊을 수 있으며, 다시 DAG의 형태로 복구할 수 있다.
  * A > B 의존성이 발생한 경우를 가정하면 다음의 두 방식을 통해 의존성을 끊어낼 수 있다.
    1. 의존성 역전 원칙을 적용한다.
    * A가 의존하는 B의 메소드를 제공하는 인터페이스를 A에 생성한다.
    * B의 메소드가 포함된 클래스가 A에 생성된 인터페이스를 구현하도록 한다.
    * 이를 통해 의존성이 역전되며, 순환 구조 또한 끊어낼 수 있다.
    2. A와 B가 모두 의존하는 새로운 컴포넌트 C를 만든다.
    * 두 컴포넌트가 모두 의존하는 클래스를 새로운 컴포넌트 C에 이동시킨다.
* 2.의 방식에서 확인할 수 있듯이 **요구사항이 변경되면 컴포넌트 구조도 변경될 수 있으며, 이는 자연스러운 현상**이다.
* 애플리케이션이 성장함에 따라 컴포넌트 의존성 구조는 서서히 변경되고, 성장해 간다.
  * 때문에 의존성 구조의 순환은 항상 확인해야 하며, 순환 발생시 어떤 방식으로든 끊어 내야만 한다.
  * 이 과정에서 새로운 컴포넌트가 생성되거나, 의존성 구조가 더 커질 수 있다.
* 컴포넌트 구조는 하향식으로 설계될 수 없다. 컴포넌트는 시스템에서 가장 먼저 설계할 수 있는 대상이 아니다.
  * 컴포넌트 의존성 다이어그램을 구성하는 컴포넌트들은 애플리케이션의 기능을 대변하지 않는다.
  * 사실 컴포넌트 의존성 다이어 그램은 애플리케이션의 기능과는 관계가 없다.
* **컴포넌트 의존성 다이어그램은 애플리케이션의 빌드 가능성과 유지보수성을 보여주는 지도**이다.
  * 프로젝트 초기에는 빌드나 유지보수 할 소프트웨어가 없으므로, 컴포넌트 의존성 구조는 프로젝트 초기에 설계할 수 없다.
* 의존성 구조와 관련된 최우선 관심사는 변동성의 격리이다.
* 컴포넌트 의존성 구조는 시스템의 논리적 설계에 맞춰 성장하며, 진화해가야 한다.

### SDP - 안정된 의존성 원칙
```
더 안정된 쪽에 의존해야 한다.
```
* **안정된 의존성 원칙을 준수하면 변경하기 어려운 모듈이 변경하기 쉬운 모듈에 의존하지 않도록** 할 수 있다.
* 설계는 정적일 수 없으며, 변경은 불가피한 점을 인정해야 한다.
* 공통 폐쇄 원칙(CCP)을 준수하므로써 컴포넌트가 다른 유형의 변경에는 영향받지 않고, 특정한 변경에만 민감하게 만들 수 있다.
  * 이는 즉 컴포넌트 중 일부가 변동성을 지니도록 설계됨을 의미한다.
  * 변동성을 지니도록 설계된 컴포넌트는 언젠가 변경될 것임을 쉽게 예상할 수 있다.
* 이 때, **변경이 쉽지 않은 컴포넌트가 변동이 예상되는 컴포넌트에 의존해서는 절대 안된다**.
  * 반대로 한 번 의존성이 발생할 경우, 변동성이 큰 컴포넌트도 변경을 적용하기 어려워질 수 있다.
  * 변동성이 크도록 설계된 모듈을 다른 개발자가 의존하게 될 경우, 초기 계획과는 달리 모듈의 변경이 어려워지게 된다.
* 변경하기 어려운 컴포넌트란?
  * 컴포넌트의 크기, 복잡도, 간결함 등의 요인에 의해 컴포넌트는 변경이 어려울 수 있다.
  * 그러나 다른 컴포넌트들이 해당 컴포넌트를 의존하게 만드는 것은 컴포넌트의 변경을 어렵게 만드는 확실한 방법이다.
  * 컴포넌트로 돌아오는 의존성이 많아지면 안정적인 컴포넌트이다.
    * 사소한 변경도 의존하는 모든 컴포넌트를 만족시켜야하기 때문이다.
* 다른 컴포넌트들이 하나의 컴포넌트를 의존하는 경우,
  * 컴포넌트 A를 컴포넌트 B, C, D가 의존하는 경우를 가정하자.
    * 컴포넌트 A는 변경하지 말아야 하는 이유가 세 가지인 꼴이 된다.
  * 컴포넌트 A는 B, C, D를 책임지는 컴포넌트이다.
  * 컴포넌트 A가 의존하는 컴포넌트가 없는 경우, 컴포넌트 A를 변경시키는 외적인 영향이 없으므로 컴포넌트 A는 독립적이다.
* 컴포넌트가 다른 여러 컴포넌트에 의존하는 경우,
  * 컴포넌트 E가 다른 컴포넌트들에 의존하는 경우를 가정하자.
    * 컴포넌트 E는 변경되어야할 수 있는 잠재적인 외부 요인이 세 가지인 꼴이 된다.
  * 컴포넌트 E는 책임성이 없고, 의존적이다.
* 안정성 지표
  * Fan-in: 컴포넌트의 안으로 들어오는 의존성이며, 컴포넌트 내부의 클래스에 의존하는 컴포넌트 외부의 클래스 개수이다.
  * Fan-out: 컴포넌트의 밖으로 나가는 의존성이며, 컴포넌트 외부의 클래스에 의존하는 컴포넌트 내부의 클래스 개수이다.
  * 불안정성 지표 I = Fan-out / ( Fan-in + Fan-out )
    * I가 0일 경우, 최고로 안정적인 컴포넌트이다.
      * 해당 컴포넌트는 다른 컴포넌트들에 의해 의존되지만, 자신은 다른 컴포넌트에 의존하지 않는다.
      * 해당 컴포넌트는 다른 컴포넌트를 책임지며 독립적이다.
      * 다른 컴포넌트들을 책임지기 위해 해당 컴포넌트는 변경이 어렵지만, 해당 컴포넌트를 변경하도록 만드는 외부 요인도 없다.
    * I가 1일 경우, 최고로 불안정한 컴포넌트이다.
      * 어떤 컴포넌트도 해당 컴포넌트에 의존하지 않지만, 해당 컴포넌트는 외부 컴포넌트에 의존한다.
      * 해당 컴포넌트는 책임성이 없고 의존적이며, 변경하지 말아야 할 이유가 없다.
      * 다른 컴포넌트에 의존하므로, 언젠가는 해당 컴포넌트가 변경되어야 한다.
* 안정된 의존성 원칙에서, **컴포넌트의 지표 I는 그 컴포넌트가 의존하는 다른 컴포넌트들의 I보다 커야** 한다.
  * 의존성 방향으로 갈수록 I의 지표는 감소해야 하며, 점점 안정적인 컴포넌트에 의존해야 한다.
* 모든 컴포넌트가 항상 안정적이어야 하는 것은 아니다.
  * 모든 컴포넌트가 최고로 안정적이라면, 해당 시스템은 변경이 불가능하다.
  * 컴포넌트 구조의 설게에서 기대되는 것은 불안정한 컴포넌트와 안정된 컴포넌트가 함께 존재하는 상황이다.
* **안정된 의존성 원칙을 위배하는 경우, 의존성 역전 원칙을 통해 문제를 해결**할 수 있다.
  * 컴포넌트 A가 자신보다 불안정한 컴포넌트 B에 의존한다고 하자.
  * 새로운 컴포넌트 C를 만들어 컴포넌트 A가 의존하던 모든 메소드를 포함하는 인터페이스를 생성한다.
  * 컴포넌트 A가 의존하던 컴포넌트 B의 메소드들이 컴포넌트 C의 인터페이스를 구현하도록 한다.
  * 이 경우, 새로 생성된 컴포넌트 C는 추상 컴포넌트이며 I가 0이므로 가장 안정적이고, 안정된 의존성 원칙을 위배하지 않게 된다.
* 추상 컴포넌트?
  * 인터페이스만을 포함하는 컴포넌트이다.
  * **이러한 컴포넌트는 실행 가능한 코드가 없지만, 정적 타입 언어에서 아주 흔하게 사용되는 방식이며 꼭 필요한 전략**이기도 하다.
  * 추상 컴포넌트는 안정적이며, 덜 안정적인 컴포넌트가 의존할 수 있는 이상적인 대상이다.

### SAP - 안정된 추상화 원칙
* 컴포넌트는 안정된 정도만큼만 추상화되어야 한다.
* 시스템에는 고수준 아키텍쳐나 정책 결정 등, 자주 변경되지 않아야 하는 소프트웨어도 포함된다.
  * 이러한 업무 로직과 직접적인 관련이 있는 결정 사항에는 변동성이 없기를 기대한다.
* 시스템에서 고수준의 정책을 캡슐화하는 소프트웨어는 반드시 최고로 안정된 컴포넌트에 위치해야 한다.
* 반면 불안정한 컴포넌트는 반드시 변동성이 큰 소프트웨어, 쉽고 빠르게 변경할 수 있는 소프트웨어만을 포함해야 한다.
* 그러나 고수준 정책을 최고로 안정된 컴포넌트에 위치시키면 해당 정책을 포함하는 소스 코드는 수정이 어려워진다.
  * 이로 인해 시스템 전체가 유연성을 잃게 된다.
  * 컴포넌트가 최고로 안정된 상태이면서, 변경에 충분히 대응할 수 있도록 유연하게 하는 정답은 추상 클래스이다.
* 안정된 추상화 원칙은 안정성과 추상화 사이의 관계를 정의한다.
  1. 안정적인 컴포넌트는 추상 컴포넌트여야 하며, 이를 통해 안정성이 컴포넌트를 확장하는 일을 방해해서는 안 된다.
     * 안정적인 컴포넌트는 인터페이스와 추상 클래스로 구성되어 쉽게 확장할 수 있어야 한다.
     * 안정적인 컴포넌트가 확장이 가능해지면, 유연성을 얻으며 아키텍쳐를 과도하게 제약하지 않는다. 
  2. 불안정한 컴포넌트는 반드시 구체 컴포넌트여야 하며, 컴포넌트 내부의 구체적인 코드를 쉽게 변경할 수 있어야 한다.
* 안정된 추상화 원칙과 안정된 의존성 원칙을 결합하면 컴포넌트에 대한 의존성 역전 원칙과 마찬가지가 된다.
  1. SDP: 의존성의 방향은 안정성의 방향이어야 한다.
  2. SAP: 안정성은 추상화를 의미한다.
  * 따라서 의존성은 추상화의 방향으로 향해야 한다.
* 그러나 의존성 역전 원칙은 클래스에 대한 원칙이며, 클래스는 추상적이거나 구체적일 수 밖에 없다.
* 반면 SDP와 SAP의 조합은 컴포넌트에 대한 원칙이며, 컴포넌트는 추상적인 부분과 구체적인 부분이 섞여 있을 수 있다.
* 추상화 지표
  * 추상화 정도 A = 컴포넌트의 인터페이스 및 추상 클래스의 개수 / 컴포넌트의 전체 클래스 개수
    * A가 0인 경우, 컴포넌트에는 추상 클래스가 없다.
    * A가 1인 경우, 컴포넌트는 추상 클래스만으로 구성된다.
* 안정성 I와 추상화 정도 A의 관계
  * 그래프로 그렸을 때, 안정적이고 추상화된 컴포넌트는 0, 1에 위치한다.
  * 불안정하고 구체적인 컴포넌트는 1, 0에 위치한다.
  * 컴포넌트는 I와 A가 다양하므로, 항상 위 두 지점에 위치하지는 않고 그래프의 무작위 지점에 위치한다.
  * 모든 컴포넌트가 0, 1 또는 1, 0에 위치할 수 없으므로, 위치해서는 안되는 지점을 계산하는 것으로 이상적인 지점을 계산할 수 있다.
    * 이는 0, 1과 1, 0을 잇는 선분의 형태로 나타난다.
  * 컴포넌트의 안정성과 추상화 정도가 가장 이상적인 부분은 0, 1과 1, 0이다.
  * 그러나 소수의 컴포넌트는 완전히 추상적이거나 완전히 안정적일 수 없으므로, 선분에 가까운 지점에 위치하는 것이 바람직하다.
* 의존성 관리 지표
  * I / A 그래프에서 분석 대상 컴포넌트의 위치와 선분 사이의 거리를 말하는 지표이다.
  * D = |A + I - 1| 로 구해지며, 결과값은 0과 1 사시의 범위에 위치하게 된다.
  * D가 0인 경우, 선분 위에 위치함을 의미한다.
  * D가 1인 경우, 선분에서 가장 멀리 떨어진 위치임을 의미한다.
  * 해당 지표를 통해 컴포넌트 들을 분석할 수 있다. 예를 들어, 0에 가깝지 않은 컴포넌트는 재검토와 재구성할 수 있다.
    * 예를 들어, 의존하는 컴포넌트가 거의 없는데도 너무 추상적인 컴포넌트나 의존하는 컴포넌트가 많은데도 너무 구체적인 컴포넌트를 찾아낼 수 있다.
  * 의존성 관리 지표는 설계의 의존성과 추상화 정도가 적절한 패턴에 얼마나 부합하는지를 측정하는 지표이다.
    * 어디까지나 지표이므로 불완전하지만, 이러한 지표를 토대로 유의미한 결과를 찾을 수 있다.
# Architecture
## 2022-01-20 Thu

## 컴포넌트 원칙
* 대규모 소프트웨어 시스템은 작은 컴포넌트들로 구성된다.
* SOLID 원칙이 벽과 방에 벽돌을 배치하는 방법을 알려준다면, 컴포넌트 원칙은 방을 배치하는 방법을 알려준다.

### 컴포넌트
* **컴포넌트는 시스템의 구성 요소로 배포할 수 있는 가장 작은 단위**이다.
  * Java의 jar, dotnet의 dll이 이에 해당한다.
* 잘 설계된 컴포넌트는 반드시 독립적으로 배포가 가능하고, 독립적으로 개발 가능한 능력을 갖춰야만 한다.
* 런타임에 플러그인 형태로 결합할 수 있는 동적 링크 파일이 소프트웨어 컴포넌트에 해당한다.
  * 예시: 마인크래프트의 모드를 생성하고 싶다면, 특정 폴더에 jar 파일만 추가하면 된다.
* 그렇다면 어떤 컴포넌트에 어떤 클래스를 포함시켜야 할까?

### REP - 재사용 / 릴리즈 등가 원칙
* 재사용 단위는 릴리즈 단위와 같아야 한다.
  * 하나의 컴포넌트로 묶인 클래스와 모듈은 반드시 함께 릴리즈할 수 있어야 한다.
  * 하나의 컴포넌트로 묶인 클래스와 모듈은 버전 번호가 같고, 동일한 릴리즈로 추적 관리되어야 한다.
  * 릴리즈 번호가 없다면 재사용 가능한 컴포넌트들이 서로 호환되는지 보증할 방법이 없다.
* 단일 컴포넌트는 응집성 높은 클래스와 모듈들로 구성되어야 한다.
  * 무작위 클래스와 모듈로 구성되어서는 안된다.
  * 하나의 컴포넌트로 구성된 모든 모듈은 서로 공유하는 중요한 테마나 목적이 있어야만 한다.
* REP는 다른 원칙에 비해 '어떤 클래스와 모듈을 단일 컴포넌트로 구성해야 하는지'를 설명하기가 어렵다.
  * 그러나 원칙 자체는 매우 중요하며, 약점은 CCP와 CRP의 강점으로 보완할 수 있다.

### CCP - 공통 폐쇄 원칙
```
- 동일한 이유로 동일한 시점에 변경되는 클래스는 같은 컴포넌트로 묶어야 한다.
- 서로 다른 이유로 서로 다른 시점에 변경되는 클래스는 다른 컴포넌트로 분리해야 한다.
```
* **공통 폐쇄 원칙은 단일 책임 원칙을 컴포넌트 관점에서 바라본 원칙**이다.
  * SRP: 단일 클래스는 변경의 이유가 여러 개 있어서는 안된다.
    * 서로 다른 이유로 변경되는 메소드는 서로 다른 클래스로 분리해야 한다.
  * CCP: 단일 컴포넌트는 변경의 이유가 여러 개 있어서는 안된다.
    * 서로 다른 이유로 변경되는 클래스는 서로 다른 컴포넌트로 분리해야 한다.
  * 두 원칙은 공통적으로 동일한 시점에 동일한 이유로 변경되는 것들을 한 곳에 묶는 것을 권장한다.
* 대다수의 애플리케이션에서 유지보수성은 재사용성보다 훨씬 중요하다.
  * 때문에 애플리케이션의 코드가 반드시 변경되어야 한다면, 여러 컴포넌트에 걸친 변경보다 단일 컴포넌트에서 변경되도록 제한하는 것이 좋다.
  * 단일 컴포넌트로 제한된 변경은 단일 컴포넌트의 재배포로 해결이 가능하다.
  * 변경된 컴포넌트에 의존하지 않는 컴포넌트는 재검증 / 재배포의 필요가 없다.
* 공통 폐쇄 원칙에 의해, **같은 이유로 변경될 가능성이 있는 클래스는 모두 하나의 컴포넌트로** 묶여야 한다.
  * 물리적 / 개념적 이유에서 강하게 결합되어 항상 함께 변경되는 클래스는 하나의 컴포넌트에 속해야 한다.
* 공통 폐쇄 원칙은 개방 폐쇄 원칙과도 밀접한 관련이 있다.
  * OCP: 클래스는 변경에는 닫혀 있고 확장에는 열려 있어야 한다.
  * CCP: 동일한 유형의 변경에 대해 닫혀 있는 클래스들은 하나의 컴포넌트로 묶어야 한다.
* 이로 인해 CCP가 적용된 경우, 변경 요구사항이 발생했을 때 변경이 영향을 주는 컴포넌트들이 최소한으로 한정될 수 있다.

### CRP - 공통 재사용 원칙
* 컴포넌트 사용자들이 필요하지 않은 것에 의존하도록 강요해서는 안된다.
* 같이 재사용되는 경향이 있는 클래스와 모듈들은 같은 컴포넌트에 포함되어야 한다.
  * 대체로 재사용이 가능한 클래스는 재사용 모듈의 일부로 해당 모듈의 다른 클래스와 상호작용하는 경우가 많다.
  * 이런 클래스들은 동일한 컴포넌트에 포함되어 있어야 한다.
* **강하게 결합되지 않은 클래스들은 동일한 컴포넌트에 포함시키지 말아야** 한다.
  * 어떤 컴포넌트에 의존하고 있다면, 해당 컴포넌트의 모든 클래스에 대해 의존하는 것을 인지해야 한다.
  * 한 컴포넌트에 속한 클래스들은 더 작게 분류할 수 없다.
    * 즉, 컴포넌트의 일부에만 의존하고 다른 클래스들과는 독립적일 수 없음을 알아야 한다.
* 공통 재사용 원칙은 인터페이스 분리 원칙의 포괄적인 버전이다.
  * ISP: 사용하지 않은 메소드가 있는 클래스에 의존해서는 안된다.
  * CRP: 사용하지 않은 클래스가 있는 컴포넌트에 의존해서는 안된다.
  * 즉, **필요하지 않은 것에 의존하지 않아야** 한다.

### REP, CCP, CRP의 관계
* 세 가지 원칙은 서로 상충된다.
  * REP와 CCP는 포함 원칙으로, 컴포넌트를 크게 만들고자 한다.
  * CRP는 배제 원칙으로, 컴포넌트를 작게 만들고자 한다.
* 세 원칙은 tradeoff 관계이며, 임의의 원칙에 중점을 두면 잃게 되는 비용이 있다.
  1. REP / CRP 중점: 유지보수성을 위한 포함 원칙인 CCP를 잃게 되므로, 컴포넌트 변경이 빈번해진다.
  2. REP / CCP 중점: 불필요한 릴리즈를 피하기 위한 배제 원칙인 CRP를 잃게 되므로, 불필요한 릴리즈가 빈번해진다.
  3. CCP / CRP 중점: 재사용성을 위한 포함 원칙인 REP를 잃게 되므로, 재사용성이 떨어지게 된다.
    * 이는 **프로젝트의 재사용성보다 개발가능성에 초점을 맞춘 형태**이다.
* 아키텍트는 자신이 속한 개발 팀이 관심을 기울이는 부분을 충족시키는 위치를 찾아야 한다.
  * 또한, 시간이 흐름에 따라 개발 팀이 관심을 갖는 부분이 변한다는 사실도 염두에 두어야 한다.
* 일반적으로 프로젝트 초기는 REP를 희생시킨 상태에서 시작하는 편이다.
  * 프로젝트가 성숙되고, 해당 프로젝트로부터 파생된 또 다른 프로젝트가 시작되면 점차 가치가 변하게 된다.
    * 시간의 흐름에 따라 프로젝트의 초점은 개발 가능성에서 재사용성으로 바뀌어 간다.
    * 이에 따라 컴포넌트의 구성 방식 또한 조금씩 흐트러지고, 또 진화한다.
  * 즉, **프로젝트의 컴포넌트 구조는 시간과 성숙도에 따라 가변적인 구조**이다.
* **컴포넌트 구조는 프로젝트가 실제로 수행하는 일보다 프로젝트가 발전되고 사용되는 방법과 더 관련**이 있다.
* 어느 클래스를 묶어서 컴포넌트로 만들지 결정할 때, '재사용성'과 '개발가능성' 이라는 상충하는 힘을 고려해야 한다.
  * 이들 사이에서 애플리케이션의 요규에 맞는 균형점을 잡는 일이 중요하며, 또한 균형점은 언제나 유동적이라는 사실을 인지해야 한다.
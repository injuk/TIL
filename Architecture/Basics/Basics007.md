# Architecture
## 2022-01-24 Mon

### 부분적 경계
* YAGNI: You Aren't Goint to Need It, 필요하지 않은 종류의 선행적 설계는 YAGNI 원칙을 위배한다.
* 쌍방향 다형적 인터페이스 등, **아키텍쳐 경계를 완벽히하기 위한 컴포넌트 격리와 의존성 관리는 설계와 유지에 큰 노력을 필요**로 한다.
  * 아키텍트라면 이러한 경계를 만드는 비용이 크고 YAGNI를 위배한다고 생각하는 사람이 있을 수 있다.
  * 한편으로는 추후에 필요할 수 있을지도 모르므로 이러한 경계 확보를 미리 해두어야한다고 생각하는 사람도 있을 수 있다.
* 이러한 경우, 부분적 경계를 구현해볼 수 있다.
  1. 마지막 단계 건너뛰기: 독립적으로 컴파일하고 배포할 수 있도록 컴포넌트를 만드는 작업은 수행하지만, **단일 컴포넌트에 모두 모아둔다**.
    * 모든 것은 완전히 준비되어 있지만, 모든 것을 단일 컴포넌트로 컴파일하여 배포한다.
    * 이 경우에도 완벽한 경계를 만들기 위한 코드량과 사전 설계는 필요하지만, 최소한 다수의 컴포넌트를 관리하는 작업은 하지 않아도 된다.
    * 단점: 시간이 지나도 수요가 없어 컴포넌트를 분리하지 못한 경우, 경계의 관리가 소홀해져 의존성 규칙을 위배하기 쉽다.
  2. 일차원 경계: 전략(strategy) 패턴을 사용하며, 경계의 양방향 Boundary 인터페이스를 사용하지 않는다.
    * 추후에 필요할 아키텍쳐 경계를 작용하기 위한 의존성 역전을 통해 설계를 미리 적용해둘 수 있다. 
    * 단점: 그러나 이러한 분리 역시 개발자와 아키텍트가 성실하지 않은 경우 붕괴되기 쉽다.
  3. 파사드: 가장 **단순한 경계의 형태이며, 의존성 역전마저 희생하는 경우에 해당**한다.
    * 경계는 파사드 클래스로 정의되고, 파사드 클래스에는 모든 서비스 클래스를 메소드 형태로 정의한다.
    * 서비스 호출 발생시 파사드 클래스는 해당 서비스 클래스로 호출을 전달하기만 한다.
    * 단점: 클라이언트가 파사드에 의존하고, 파사드가 서비스에 의존하므로써 클라이언트가 서비스 클래스에 추이 종속성을 갖게 된다.
* 상술한 세 방식은 예시이며, 각각의 비용과 장점을 지닌다.
  * 각 접근법은 모두 해당 경계가 실제로 구체화되지 않으면 가치가 떨어진다.
* **아키텍트는 아키텍쳐 경계를 완벽히 구현할지 부분적으로 공간을 마련해둘지 결정할 책임**이 있다.

### 계층과 경계
* 아키텍쳐 경계는 어디에나 존재한다.
* 아키텍쳐 경계가 언제 필요한지는 신중히 파악해야될 내용이며, 이러한 경계를 제대로 구현하려면 큰 비용이 드는 사실을 인지해야 한다.
  * 경계가 무시되었다면, 추후에 경계를 추가하는 비용 역시 크다!
* 그러나 추상화가 반드시 필요할 것이라고 미리 예측하는 것도 좋지 않다.
  * **대체로 오버 엔지니어링이 언더 엔지니어링보다 나쁠 떄가 많다**.
* 완벽히 구현할 경계의 구현 비용이 경계를 무시해서 생기는 비용보다 적어지는 변곡점에서 경계를 구현할 수 있어야 한다.
  * 무시할 경계와 구현해야할 경계를 구분하기 위해 프로젝트를 계속해서 주시하고, 신중하게 관찰해야 한다.

### 메인 컴포넌트
* 시스템에는 최소한 하나의 컴포넌트(= 메인)가 존재하고, 이 컴포넌트가 다른 컴포넌트를 생성하거나 조정하고 관리한다.
  * 메인 컴포넌트는 고수준의 시스템을 위한 팩토리, 전략 등 모든 것을 로드한 후 제어권을 고수준의 시스템에게 넘기는 역할을 맡는다.
* **메인 컴포넌트는 궁극적인 세부사항**이고, 클린 아키텍쳐의 가장 바깥 원에 위치하는 저수준 모듈이다.
* **메인 컴포넌트 역시 애플리케이션의 초기 설정을 구성하고 외부 자원을 수집한 후 제어권을 넘기는, 하나의 플러그인으로 생각**할 수 있다.
  * 이 때, 메인 컴포넌트 역시 플러그인이므로 애플리케이션의 설정 별로 둘 이상의 메인 컴포넌트를 만들 수 있다.
  * 메인 컴포넌트를 플러그인으로 여긴다면 아키텍쳐 경계 바깥에 위치시킴으로써 설정 문제를 훨씬 쉽게 해결할 수 있다.

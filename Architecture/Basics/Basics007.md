# Architecture
## 2022-01-24 Mon

### 부분적 경계
* YAGNI: You Aren't Goint to Need It, 필요하지 않은 종류의 선행적 설계는 YAGNI 원칙을 위배한다.
* 쌍방향 다형적 인터페이스 등, **아키텍쳐 경계를 완벽히하기 위한 컴포넌트 격리와 의존성 관리는 설계와 유지에 큰 노력을 필요**로 한다.
  * 아키텍트라면 이러한 경계를 만드는 비용이 크고 YAGNI를 위배한다고 생각하는 사람이 있을 수 있다.
  * 한편으로는 추후에 필요할 수 있을지도 모르므로 이러한 경계 확보를 미리 해두어야한다고 생각하는 사람도 있을 수 있다.
* 이러한 경우, 부분적 경계를 구현해볼 수 있다.
  1. 마지막 단계 건너뛰기: 독립적으로 컴파일하고 배포할 수 있도록 컴포넌트를 만드는 작업은 수행하지만, **단일 컴포넌트에 모두 모아둔다**.
    * 모든 것은 완전히 준비되어 있지만, 모든 것을 단일 컴포넌트로 컴파일하여 배포한다.
    * 이 경우에도 완벽한 경계를 만들기 위한 코드량과 사전 설계는 필요하지만, 최소한 다수의 컴포넌트를 관리하는 작업은 하지 않아도 된다.
    * 단점: 시간이 지나도 수요가 없어 컴포넌트를 분리하지 못한 경우, 경계의 관리가 소홀해져 의존성 규칙을 위배하기 쉽다.
  2. 일차원 경계: 전략(strategy) 패턴을 사용하며, 경계의 양방향 Boundary 인터페이스를 사용하지 않는다.
    * 추후에 필요할 아키텍쳐 경계를 적용하기 위한 의존성 역전을 통해 설계를 미리 적용해둘 수 있다. 
    * 단점: 그러나 이러한 분리 역시 개발자와 아키텍트가 성실하지 않은 경우 붕괴되기 쉽다.
  3. 파사드: 가장 **단순한 경계의 형태이며, 의존성 역전마저 희생하는 경우에 해당**한다.
    * 경계는 파사드 클래스로 정의되고, 파사드 클래스에는 모든 서비스 클래스를 메소드 형태로 정의한다.
    * 서비스 호출 발생시 파사드 클래스는 해당 서비스 클래스로 호출을 전달하기만 한다.
    * 단점: 클라이언트가 파사드에 의존하고, 파사드가 서비스에 의존하므로써 클라이언트가 서비스 클래스에 추이 종속성을 갖게 된다.
* 상술한 세 방식은 예시이며, 각각의 비용과 장점을 지닌다.
  * 각 접근법은 모두 해당 경계가 실제로 구체화되지 않으면 가치가 떨어진다.
* **아키텍트는 아키텍쳐 경계를 완벽히 구현할지 부분적으로 공간을 마련해둘지 결정할 책임**이 있다.

### 계층과 경계
* 아키텍쳐 경계는 어디에나 존재한다.
* 아키텍쳐 경계가 언제 필요한지는 신중히 파악해야될 내용이며, 이러한 경계를 제대로 구현하려면 큰 비용이 드는 사실을 인지해야 한다.
  * 경계가 무시되었다면, 추후에 경계를 추가하는 비용 역시 크다!
* 그러나 추상화가 반드시 필요할 것이라고 미리 예측하는 것도 좋지 않다.
  * **대체로 오버 엔지니어링이 언더 엔지니어링보다 나쁠 때가 많다**.
* 완벽히 구현할 경계의 구현 비용이 경계를 무시해서 생기는 비용보다 적어지는 변곡점에서 경계를 구현할 수 있어야 한다.
  * 무시할 경계와 구현해야할 경계를 구분하기 위해 프로젝트를 계속해서 주시하고, 신중하게 관찰해야 한다.

### 메인 컴포넌트
* 시스템에는 최소한 하나의 컴포넌트(= 메인)가 존재하고, 이 컴포넌트가 다른 컴포넌트를 생성하거나 조정하고 관리한다.
  * 메인 컴포넌트는 고수준의 시스템을 위한 팩토리, 전략 등 모든 것을 로드한 후 제어권을 고수준의 시스템에게 넘기는 역할을 맡는다.
* **메인 컴포넌트는 궁극적인 세부사항**이고, 클린 아키텍쳐의 가장 바깥 원에 위치하는 저수준 모듈이다.
* **메인 컴포넌트 역시 애플리케이션의 초기 설정을 구성하고 외부 자원을 수집한 후 제어권을 넘기는, 하나의 플러그인으로 생각**할 수 있다.
  * 이 때, 메인 컴포넌트 역시 플러그인이므로 애플리케이션의 설정 별로 둘 이상의 메인 컴포넌트를 만들 수 있다.
  * 메인 컴포넌트를 플러그인으로 여긴다면 아키텍쳐 경계 바깥에 위치시킴으로써 설정 문제를 훨씬 쉽게 해결할 수 있다.

## 2022-01-25 Tue
## 서비스 아키텍쳐
* 서비스를 사용하면 상호 결합이 분리되고 개발과 배포 독립성을 지원하는 것처럼 '보인다'!
* **서비스를 사용하는 것은 본질적으로 아키텍쳐에 해당하지 않는다**.
  * **시스템 아키텍쳐는 의존성 규칙을 준수하고, 고수준 정책을 저수준 세부사항으로부터 분리하는 경계에 의해 정의**된다.
  * **단순히 애플리케이션의 행위를 분리한 서비스는 값비싼 함수 호출**에 지나지 않는다.
* **서비스 그 자체로서는 아키텍쳐를 정의하지 않는다**는 점을 이해해야 한다.
  * 시스템에서 아키텍쳐를 정의하는 요소는 의존성 규칙을 따르며 아키텍쳐 경계를 넘나드는 함수 호출들이다.
    * 이외의 많은 함수들은 행위를 분리할 뿐이며, 아키텍쳐적으로는 중요하지 않나.
    * 서비스 역시 아키텍쳐적으로 중요한 서비스가 있지만, 중요하지 않은 서비스도 존재한다.

### 서비스의 이점?
* 서비스 아키텍쳐의 이점으로 손꼽히는 것은 다음과 같다.
  1. 결합 분리: 시스템을 서비스로 분리하면 서비스 사이의 결합은 확실히 분리된다.
    * 서비스 개별 변수 수준에서는 결합이 분리되나, 프로세서 내부 또는 네트워크 상의 공유 자원 때문에 결합될 가능성이 여전히 존재한다.
    * 서비스 사이를 오가는 데이터 레코드에 새로운 필드가 추가된다면, 이 필드를 사용하는 모든 서비스도 변경되어야 한다.
    * 이 경우, 서비스들은 데이터 레코드에 강하게 결합되며 서비스끼리도 간접적으로 결합된다.
  2. 개발 및 배포 독립성: DevOps 전략의 일환으로 서비스별 담당 팀에서 서비스를 작성하고, 유지보수하고, 운영하는 책임을 질 수 있다.
    * 이러한 개발 및 배포 독립성은 확장성 있는 시스템의 특징으로 간주된다.
    * 그러나 상술한 이점을 누릴 수 있는 것은 극히 일부에 불과하다.
    * 대규모 시스템은 서비스 기반 시스템 이외에도 구축할 수 있다. 즉, **서비스는 확장성 있는 시스템을 구축하는 유일한 방법이 아니다**.
    * 또한 서비스라고 해서 항상 독립적으로 개발하고, 배포하고, 운영할 수 있는 것은 아니다.
      * 서비스 자체가 서로 긴밀하게 결합되어 있는 경우, 변경 사항에 대해 독립적으로 개발하고 배포하거나 유지보수할 수 없다.

### 컴포넌트 기반 서비스
* **서비스 역시 앞서 살펴보았던 클린 아키텍쳐의 이점을 적용할 수 있다**.
* 서비스는 SOLID 원칙대로 설계할 수 있고, 컴포넌트 구조를 갖출 수도 있다.
  * 이를 통해 서비스 내의 기존 컴포넌트를 변경하지 않고 새로운 컴포넌트를 추가할 수 있다.
* **Java의 경우, 서비스를 하나 이상의 jar 파일에 포함되는 추상 클래스의 집합이라고 생각**해야 한다.
  * 새로운 기능 추가, 또는 기능 확장은 새로운 jar 파일로 만들어야 한다.
    * 새로운 jar 파일을 구성하는 클래스들은 기존 jar 파일에 정의된 추상 클래스들을 확장한다.
  * 이를 통해 새로운 기능 배포는 서비스를 재배포하는 문제가 아니라, 서비스를 로드하는 경로에 새로운 jar 파일을 추가하는 문제가 된다.
  * 즉, 새로운 기능을 추가하는 행위가 개방 폐쇄 원칙을 준수하게 된다.
* 각 서비스의 내부는 자신만킈 컴포넌트 설계를 갖고, 파생된 클래스를 만드는 식으로 신규 기능을 추가할 수 있게 된다.

### 결론
* **아키텍쳐 경계는 서비스 사이에 있지 않다**.
  * 오히려 서비스를 관통하며, 서비스를 컴포넌트 단위로 분할한다.
* 서비스 내부는 의존성 규칙도 준수하는 컴포넌트 아키텍쳐로 설계되어야 한다.
  * 이러한 서비스는 아키텍쳐 경계를 정의하지 않는다.
  * **아키텍쳐 경계는 서비스 내에 위치한 컴포넌트에 의해 정의**된다.
    * 즉, 서비스는 일반적으로 여러 아키텍쳐 경계로 분리된 다수의 컴포넌트로 구성된다.
    * 물론 서비스는 단 하나의 아키텍쳐 경계로 둘러쌓인 단일 컴포넌트로 구성될 수도 있다!
* 결국 서비스는 시스템의 확장성과 개발 가능성 측면에서 유용하지만, 그 자체적으로 아키텍쳐가 되는 것이 아니다.
  * **시스템 아키텍쳐는 시스템 내부에 그어진 경계와, 경계를 넘나드는 의존성에 의해 정의**된다.
  * 시스템의 구성 요소가 통신하고 실행되는 물리적인 메커니즘에 의해 아키텍쳐가 정의되는 것은 아니다.

## 테스트 경계
* **테스트는 시스템의 일부이며, 아키텍쳐에도 관여**한다.
* **아키텍쳐 관점에서 모든 테스트 방식은 동일**하다.
* 테스트는 항상 테스트 대상이 되는 코드에 의존하므로, **태생적으로 의존성 규칙을 따른다**.
  * 즉, 테스트는 세부적이고 구체적인 것으로, 아키텍쳐에서 가장 바깥 원에 위치한다.
* 테스트는 독립적으로 배포 가능하며, 심지어 배포 독립성이 필요하지 않은 경우에도 독립적이다.
* 테스트는 시스템 컴포넌트 중 가장 고립되어 있는 컴포넌트이다.
  * 테스트는 운영에 꼭 필요한 컴포넌트가 아니며, 그 목적은 개발을 지원하는데에 있다.
* 상술한 특징을 갖지만, **테스트는 여전히 시스템 컴포넌트**이다.

### 테스트를 고려하는 설계
* 테스트가 지니는 극단적인 고립성과, 테스트를 상용 시스템에 배포하지 않는다는 사실은 테스트가 시스템 설계 범위 밖에 있다고 여겨지도록 한다.
  * **그러나 이는 아주 잘못된 접근 방식**에 해당한다.
  * 테스트가 시스템 설계와 통합되지 않으면 테스트는 깨지기 쉽고, 시스템은 변경하기 어려워진다.
* **깨지기 쉬운 테스트 문제**
  1. 시스템에 강하게 결합된 테스트는 시스템이 변경될 때 함께 변경되어야 한다.
  2. 따라서 시스템 컴포넌트에 생긴 사소한 변경은 이와 결합된 수많은 테스트를 망가트린다.
  3. 심각한 경우, 시스템의 공통 컴포넌트가 변경되면 수백 / 수천 개의 테스트 케이스가 망가질 수 있다.
  4. 시스템의 간단한 변경이 대량의 테스트 실패로 이어진다는 사실을 깨닫게 되면, 개발자는 변경을 하지 않으려고 하게 된다.
    * 이는 깨지기 쉬운 테스트로 인해 시스템이 뻣뻣해지는 부작용을 낳게 된다.
* 깨지기 쉬운 테스트 문제를 해결하기 위해서는 **테스트를 고려한 설계가 선행되어야** 한다.
  * 소프트웨어 설계의 첫 번째 규칙은 '변동성이 있는 것에 의존하지 말아야 한다'는 점이다.
  * 예를 들어 GUI를 토대로 설계된 테스트는 변동성이 큰 GUI에 의존하므로 깨지기 쉽다.
  * 따라서 시스템과 테스트를 설계할 때, 변동성이 큰 GUI를 사용하지 않고도 업무 규칙을 테스트할 수 있어야 한다.
* 상술한 목표를 달성하기 위해, 테스트가 모든 업무 규칙을 검증하기 위해 사용할 수 있도록 특화된 API를 만들 수 있다.
  * 이는 UI가 사용하는 인터랙터와 인터페이스 어댑터들의 상위 집합이 되며, **시스템을 테스트 가능한 상태로 강제하는 힘을 지녀야** 한다.
  * 이렇듯 강력한 API는 테스트를 애플리케이션으로부터 분리할 목적으로 사용한다.
    * 단순히 UI와 테스트를 분리하는 것이 아닌, 테스트 구조와 애플리케이션 구조의 결합을 분리해야 한다.

### 구조적 결합과 분리
* 구조적 결합은 테스트 결합 중 가장 강하고 은밀하다.
* 모든 상용 클래스와 메소드에 엮인 테스트 클래스와 메소드가 있다고 가정할 때,
  1. 이러한 테스트 스위트는 애플리케이션에 강하게 결합된다.
  2. 상용 클래스나 메소드 중 하나라도 변경되면 이에 엮인 다수의 테스트가 수정되어야 한다. 즉, 테스트가 꺠지기 쉬워진다.
* **테스트 API는 애플리케이션의 구조를 테스트로부터 숨기는 데에 의의**가 있다.
  * 테스트 API를 활용하는 경우, 상용 클래스의 리팩토링과 확장이 테스트에 영향을 주지 못한다.
  * 반대로 테스트 코드 자체의 리팩토링과 확장도 상용 클래스에 영향을 주지 않는다.
* **적절한 테스트 API의 구현은 테스트 코드와 상용 코드 간의 구조적 결합을 분리하고, 상용 코드의 범용성과 유연성을 향상**시킨다.
* 테스트 API는 강력한 힘을 지니므로, 운영 시스템에 배포되어서는 안된다.
  * 때문에 테스트 API 자체와 테스트 API 중 위험한 부분의 구현부는 독립적으로 배포될 수 있는 컴포넌트로 분리되어야만 한다.

### 결론
* 테스트는 시스템의 일부임을 인지하고 설계되어야 한다.
* 그렇지 못한 테스트는 깨지기 쉽고, 유지보수가 너무나도 어려워 버려질 수 있다.

## 2022-01-26 Wed
## 세부사항
### 데이터베이스
* **데이터베이스는 세부사항**이며, 아키텍쳐의 구성 요소 수준으로 끌어올릴 수 없다.
* 데이터의 구조는 아키텍쳐에서 중요하지만, 데이터베이스는 데이터 구조가 아닌 데이터에 접근할 방법을 제공하는 유틸리티이다.
  * 유틸리티는 저수준의 세부사항에 불과하며, 아키텍쳐와는 관계가 없다.
  * 체계화된 데이터 구조와 데이터 모델은 아키텍쳐적으로 중요하다.
  * 그러나 데이터 자체를 물리적으로 옮길 뿐인 기술과 시스템은 아키텍쳐적으로 중요하지 않다.
* RDB의 경우, 데이터가 행 단위로 저장된다는 사실은 아키텍쳐적으로 중요하지 않다.
  * 유즈케이스는 이러한 방식을 알아서도, 관여해서도 안된다.
  * 오직 아키텍쳐의 외부 원에 위치한 최하위 수준의 유틸리티 함수만 이 사실을 알아야 한다.
* **아키텍쳐는 디스크 자체가 존재한다는 사실도 인식할 필요가 없다**.
```
데이터는 중요하다.
데이터베이스는 세부사항이다.
```

### 웹
* **GUI는 세부사항이며, 웹은 GUI이다. 따라서 웹은 세부사항**이다.
* 세부사항은 핵심 업무 규칙으로부터 분리하여 경계의 바깥에 두어야 한다.

### 프레임워크
* 프레임워크 제작자는 특정한 문제를 해결하기 위해 프레임워크를 개발한다.
  * **우리가 직면한 문제를 해결하기 위해 프레임워크가 만들어지지는 않는다**.
* 우리는 프레임워크에게 큰 헌신을 해야하지만, 프레임워크 제작자는 우리를 위해 어떠한 헌신도 하지 않는다.
* 프레임워크 제작자는 프레임워크 사용자가 프레임워크와 강력히 결합되어 분리되지 못하고, 사용자가 많아지는 일을 반긴다.
* 프레임워크의 아키텍쳐는 그다지 깔끔하지 않은 경우가 많고, 의존성 규칙을 위반하는 경향이 있다.
* 프레임워크는 애플리케이션의 초기 기능을 만드는 데에 도움이 되지만, 제품이 성숙해짐에 따라 프레임워크가 제공하는 기능과 틀을 벗어나게 된다.
* 프레임워크는 우리에게 도움되지 않는 방향으로 진화할 수 있다. 사용하지 않을 기능을 포함하는 신규 버전을 적용하느라 개발이 지연될 수 있다.
* 따라서 **프레임워크를 사용하되, 결합되지 않도록 거리를 두어야** 한다.
  * 프레임워크는 아키텍쳐의 바깥 원에 속하는 세부사항으로 취급되어야 한다.
  * 프레임워크가 핵심 코드 안에 들어오도록 하는 대신, 핵심 코드에 플러그인할 수 있는 컴포넌트에 프레임워크를 통합하고 의존성을 준수한다.
* 스프링을 예로 들어, @Autowired 어노테이션이 업무 객체에 존재해서는 안 된다.
  * 업무 객체는 절대 스프링에 대해 알아서는 안된다.
  * 업무 객체보다는 Main 컴포넌트에서 스프링을 사용하여 의존성을 주입하자.
    * Main은 아키텍쳐에서 가장 지저분한, 최저 수준의 컴포넌트이므로 스프링을 알아도 무방하다.
* C++의 STL이나 Java의 표준 라이브러리처럼 **반드시 사용해야 하는 프레임워크가 존재할 수 있다**.
  * **이러한 관계는 정상적이지만, 선택적이어야** 한다.
  * 애플리케이션과 프레임워크 간의 **강한 결합을 허용했다면, 애플리케이션의 생애 주기 동안 항상 프레임워크와 함께해야 한다는 사실을 명심**해야 한다.
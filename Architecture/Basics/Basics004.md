# Architecture
## 2022-01-21 Fri

### 아키텍쳐
* **아키텍쳐란 시스템을 구축했던 사람들이 만들어낸 시스템의 형태**이다.
* 시스템의 형태는 컴포넌트로 분할하는 방법, 분할된 컴포넌트를 배치하는 방법, 컴포넌트가 서로 상호작용하는 방식에 따라 정해진다.
  * 그리고 **형태는 아키텍쳐 안에 담긴 소프트웨어 시스템이 쉽게 개발, 배포, 운영, 유지보수되도록 만들어진다**.
* 시스템 **아키텍쳐는 시스템의 동작 여부와는 거의 관련이 없다**.
  * 아키텍쳐는 시스템이 제대로 동작하도록 지원하는 데에 아무런 역할을 하지 않는 것은 아니다.
    * 그러나 이러한 역할은 수동적이며 피상적인 것에 해당한다. 능동적이고 본질적인 것이 아니다!
  * 형편없는 아키텍쳐를 갖는 시스템도 대체로 운영에서는 문제를 겪지 않는다.
  * 그러나 그러한 시스템들은 배포, 유지보수, 계속되는 개발 과정에서 어려움을 겪는다.
* 아키텍쳐의 목적은 **시스템의 생명주기를 지원하는 것**이다.
  * 아키텍쳐의 궁극적인 목표는 시스템의 수명과 관련된 비용을 최소화하고, 프로그래머의 생산성을 최대화하는데에 있다.

## 시스템 아키텍쳐의 역할
### 개발
* 시스템 아키텍쳐는 개발팀들이 시스템을 쉽게 개발할 수 있도록 뒷받침해야 한다.
* 개발자가 적은 팀은 잘 정의된 컴포넌트나 인터페이스가 없더라도 모놀리틱 시스템을 개발할 수도 있다.
* 개발자 여럿이 다수의 팀으로 구성된 개발 조직은 시스템을 잘 설계된 컴포넌트로 분리하지 않으면 개발이 진척되지 않는다.
  * 다른 요소를 고려하지 않는다면 시스템의 아키텍쳐는 팀 당 하나의 컴포넌트로 발전될 가능성이 높다.
  * 그러나 팀별 단일 컴포넌트를 갖는 아키텍쳐가 시스템의 배포, 운영, 유지보수에 최적일 가능성은 거의 없다.

### 배포
* 소프트웨어 시스템이 사용될 수 있으려면 반드시 배포될 수 있어야 한다.
* 배포 비용이 높을 수록 시스템의 유용성은 떨어진다.
* 아키텍쳐는 시스템을 단 한 번에 손쉽게 배포할 수 있도록 만드는 데에 목표를 두어야 한다.
  * 초기 개발 단계에서는 배포 전략을 고려하지 않는 경우가 많다.
  * 이러한 상태를 방치하면 개발은 쉽지만 배포가 어려운 아키텍쳐가 만들어지게 된다.

### 운영
* 아키텍쳐는 개발, 배포, 유지보수에 미치는 영향보다 운영에 미치는 영향이 더 적은 편이다.
  * 운영에서 발생하는 어려움은 대부분의 경우 아키텍쳐 변경 없이 추가 하드웨어 투입으로 해결되곤 한다.
  * 운영을 방해하는 아키텍쳐가 개발, 배포, 유지보수를 방해하는 아키텍쳐보다는 비용을 덜 소모한다.
* 시스템 운영시 아키텍쳐는 개발자에게 시스템의 운영 방식을 상세히 알려주는 역할을 한다.
  * 아키텍쳐는 use case, 기능, 시스템의 필수 행위가 개발자에게 주요 목표로 인식되도록 해야한다.
  * 이를 통해 개발자가 시스템을 이해하기 쉬워지며, 개발과 유지보수에도 간접적으로 큰 도움을 준다.

### 유지보수
* 유지보수는 모든 측면에서 봤을 때 시스템에서 비용이 가장 많이 든다.
* 유지보수의 가장 큰 비용은 탐사와, 탐사에서 기인한 위험부담이다.
  * 탐사란 기존 소프트웨어에 새로운 기능을 추가하거나 결함을 수정할 때 소프트웨어의 어디를, 어떤 전략으로 고치는 것이 최적일지 결정할 때 드는 비용이다.
  * 또한 이러한 변경사항을 반영할 때 의도치 않은 결함이 발생할 가능성은 항상 존재하며, 이러한 위험부담 비용이 추가된다.
* 신중하게 설계된 아키텍쳐는 이러한 비용을 크게 줄일 수 있다.
  * 시스템을 컴포넌트 단위로 분리하고, 안정된 인터페이스를 두어 서로 격리해야 한다.
  * 이러한 아키텍쳐는 추가될 기능에는 개방적이고, 의도치 않은 장애가 발생할 위험을 크게 줄여준다.

### 선택사항 열어두기
* 소프트웨어는 기계의 행위를 빠르고 쉽게 변경하기 위해 필요했지만, 이러한 유연성은 시스템의 형태에 크게 의존한다.
* 소프트웨어를 부드럽게 유지하는 방법은 선택사항을 가능한 한 많이, 오래 열어두는 것이다.
  * 이 때, 열어두어야 할 선택사항은 '중요치 않은 세부사항'이다.
* 모든 소프트웨어 시스템은 두 가지 구성요소로 분해된다.
  1. 정책: 모든 업무 규칙과 업무 절차를 구체화한다. 시스템의 진정한 가치를 대변한다.
  2. 세부사항: 정책과 소통하기 위해 필요한 요소지만, 정책이 갖는 행위에는 전혀 영향을 주지 않는다.
     * 입출력 장치, 데이터베이스, 웹 시스템, 서버, 프레임워크, 통신 프로토콜 등이 해당된다.
* 아키텍트의 목표는 **시스템에서 정책을 가장 핵심적인 요소로 식별하고, 세부사항은 정책에 무관한 형태의 시스템을 구축하는 것**이다.
  * 이를 토대로 세부사항의 결정은 미루거나 연기할 수 있게 된다.
  1. 개발 초기에는 데이터베이스 시스템을 선택할 필요가 없다.
     * 고수준의 정책은 데이터베이스가 관계형인지, 분산형인지 관련이 없어야 한다.
  2. 개발 초기에는 웹 서버를 선택할 필요가 없다.
     * 웹 개발 기술들에 대해 고수준의 정책이 전혀 알지 못하게 만드는 것으로, 프로젝트 후반까지 어떤 종류의 웹 시스템을 사용할지 결정할 필요가 없다.
  3. 개발 초기에는 REST를 적용할 필요가 없다.
     * 고수준의 정책은 외부 세계로의 인터페이스와 독립적이어야 한다.
     * 마이크로서비스 / SOA도 적용할 필요가 없다. 고수준의 정책은 이러한 내용을 신경쓸 필요가 없다.
  4. 개발 초기에는 의존성 주입 프레임워크를 적용할 필요가 없다.
     * 고수준의 정책은 의존성을 해석하는 방식에 대해 신경쓸 필요가 없다.
* **세부사항의 결정을 오랫동안 참는다면 더 많은 정보를 얻어 이를 기초로 한 결정을 내릴 수 있다**.
* 상술한 상황이 가능한 경우, 여러 세부사항 후보를 테스트하여 적용 가능성과 성능을 검토해볼 수 있다.
* 좋은 아키텍트는 시스템의 정책과 세부사항을 가려내고, 두 요소가 결합되지 않도록 엄격하게 분리한다.
  * 이를 통해 정책은 세부사항에 대해 아무것도 모르는 상태를 유지하며, 어떠한 경우에도 세부사항에 의존하지 않게 된다.
  * 이러한 이유에서 세부사항에 대한 결정은 가능한 한 오랫동안 미룰 수 있는 방향으로 정책을 설계해야 한다.

### 좋은 아키텍쳐
* 좋은 아키테쳐는 유즈케이스, 운영, 개발, 배포를 지원할 수 있어야 한다.
* 유즈케이스를 지원하는 아키텍쳐란,
  * 시스템 아키텍쳐는 **시스템의 의도를 지원**해야 한다.
  * 아키텍쳐는 시스템의 행위에 큰 영향을 주지 않지만, **아키텍쳐 수준에서 시스템의 의도를 파악**할 수 있어야 한다.
* 운영을 지원하는 아키텍쳐란,
  * 아키텍쳐는 시스템의 요구사항, 유즈케이스에 걸맞는 처리량과 응답시간을 보장하는 구조여야 한다.
    * **반드시 요구사항에 맞는 운영 작업을 허용할 수 있는 형태로 아키텍쳐를 구조화**해야 한다.
  * **요구사항의 처리 방법은 아키텍쳐에서 오랫동안 열어두어야 하는 선택사항** 중 하나이다.
    * 예를 들어, 처음부터 모놀리틱으로 고정해버리면 추후 다중 프로세스, 다중 스레드, 마이크로서비스 형태가 필요해질 때 개선이 어렵다.
    * 아키텍쳐에서 컴포넌트를 적절히 격리하여 유지하고, 컴포넌트 간 통신 방식을 제한하지 않는다면 요구사항 변경에 대응하기가 더 쉬워진다.
* 개발을 지원하는 아키텍쳐란, 
  * 여러 팀으로 구성된 개발 조직은 각 팀 별로 독립적으로 행동하기 편한 아키텍쳐를 확보할 수 있어야 한다.
  * 이러한 아키텍쳐를 위해서는 잘 격리되고, 독립적으로 개발 가능한 컴포넌트 단위로 시스템을 분할할 수 있어야 한다.
    * 그래야만 이들 컴포넌트 각각을 독립적으로 작업할 수 있는 팀에 할당할 수 있다.
  * 아키텍쳐는 개발 환경 지원에 있어 핵심적인 역할을 수행한다.
* 배포를 지원하는 아키텍쳐란,
  * **좋은 아키텍쳐는 시스템이 빌드된 후 즉각적으로 배포할 수 있도록 지원**해야 한다.
    * 좋은 아키텍쳐라면 배포마다 스크립트 또는 속성 파일을 수정하거나, 필요한 디렉토리나 파일을 수작업으로 생성하게 두지 않는다.
  * 아키텍쳐는 배포 용이성을 결정하는데에 중요한 역할을 한다.
  * 이러한 아키텍쳐 역시 적절히 분할되고 격리된 컴포넌트 구조를 전제로 한다.
    * 마스터 컴포넌트도 이러한 조건에 해당되며, 적절히 분할되고 격리되어야 한다.
    * 마스터 컴포넌트는 시스템 전체를 하나로 묶고, 각 컴포넌트를 올바르게 구동하고 통합 / 관리해야 한다.

## 선택사항 열어놓기
* 좋은 아키텍쳐는 상술한 모든 관심사들 사이에서 균형을 맞추고, 모든 관심사를 만족한다.
  * 또한, **좋은 아키텍쳐는 선택사항을 열어둠으로써 향후에 있을 변경 사항에 쉽게 대응할 수 있도록** 한다.
* 그러나 현실에서는 이러한 균형을 잡기가 매우 어렵다.
  * 우리가 도달하려는 목표는 뚜렷하지 않고, 시시각각 변해 간다.
* 그러나 컴포넌트를 적절히 격리하고 분할하는데 도움이 되고, 관심사 사이의 균형점을 찾아내는 데에 도움이 되는 몇 가지 원칙이 있다.
  이들 원칙은 구현 비용이 비교적 싸게 들고, 선택사항을 가능한 많이 / 오랫동안 열어둘 수 있게 도와준다.

### 계층 결합 분리
* 유즈케이스 측면에서, 아키텍트는 시스템의 모든 유즈케이스를 알 수는 없다.
* 그러나 시스템의 기본적인 의도는 분명히 알 수 있다.
* 이 점을 토대로 단일 책임 원칙과 공통 폐쇄 원칙을 적용하여 다른 이유로 변경되는 것들을 분리하고, 동일한 이유로 변경되는 것들을 묶는다.
* 서로 다른 이유로 변경되는 것이란?
  * 대표적으로, UI의 변경 이유는 업무 규칙과는 아무런 관련이 없다.
    * 업무 규칙과 그 이외의 요소는 서로 다른 속도로, 각자 다른 이유로 변경된다.
    * 따라서 유즈케이스가 이 둘을 모두 포함한다면, 이는 분리되어야 한다.
    * 이를 통해 두 요소는 여전히 가시적으로 유지되지만, 서로 독립적으로 변경할 수 있게 된다.
  * 심지어 데이터베이스 스키마 조차 기술적인 세부사항이며, 업무 규칙이나 UI와는 관련이 없다.
    * 아키텍트는 이들을 시스템의 나머지 부분으로부터 분리하고, 독립적으로 변경될 수 있도록 보장해야 한다.
* 시스템을 서로 결합되지 않는 수평적인 계층으로 분리할 수 있는 요소의 예시는 다음과 같다.
  * 이는 즉 서로 다른 이유로 변경되는 요소들을 말한다.
  1. UI
  2. 애플리케이션 특화 업무 규칙(입력 필드 유효성 검사, 등)
  3. 애플리케이션에 독립적인 업무 규칙(재고품 집계 방법, 이자 계산 방법, 등)
  4. 데이터베이스 시스템

### 유즈케이스 결합 분리
* 유즈케이스 그 자체 또한 서로 다른 이유로 변경될 수 있다.
* 예를 들어, 주문을 추가하는 유즈케이스와 주문을 삭제하는 유즈케이스는 '주문'이라는 하나의 유즈케이스가 아닌, 분명히 별개의 유즈케이스이다.
  * 두 유즈케이스는 반드시 서로 다른 속도로, 서로 다른 이유에서 변경된다.
* 유즈케이스는 시스템을 분할하는 자연스러운 방법이지만, 수평적인 계층이 아닌 수직의 조각으로 분리한다.
  * 각각의 유즈케이스는 UI일부, 애플리케이션 특화 업무 규칙의 일부, 독립된 업무 규칙 일부, 데이터베이스 일부를 사용한다.
* 즉, **우리는 시스템을 수평적 계층 뿐만 아니라 각 수평 계층을 가로지르는 수직 계층인 유즈케이스로 분할**할 수 있다.
* 결합된 **유즈케이스를 분리할 때는 수평적으로 분할된 각 계층에서 겹치지 않도록 해야 한다**.
* 여기에서 패턴을 볼 수 있다!
```
시스템에서 서로 다른 이유로 변경되는 요소들의 결합을 분리하면, 기존 요소에 지장을 주지 않고도 새로운 유즈케이스를 계속해서 추가할 수 있다.
```
* 이 때, 수직적으로 분할하는 유즈케이스에는 관점이라는 표현을 사용할 수 있다.
  * 관점 지향 프로그래밍: 횡단 관심사를 분리하여 모듈화를 높이는 프로그래밍 패러다임이다.
  * 각 유즈케이스가 서로 다른 관점을 사용하게 되면, 새로운 유즈케이스가 추가되더라도 기존 유즈케이스에는 거의 영향을 주지 않는다.

### 결합 분리 모드
* 유즈케이스에서 서로 다른 관점들이 분리되었다면, 이는 이미 높은 처리량을 요구하는 유즈케이스와 그렇지 않은 유즈케이스가 분리되었다는 것을 의미한다.
* 예를 들어 UI와 데이터베이스, 업무 규칙 각각의 계층이 분리되었다면, 각 계층은 별도의 서버에서 실행될 수 있다.
* 이렇듯 유즈케이스를 위해 수행하는 결합 분리 작업이 운영에도 도움을 주는 것을 알 수 있다.
* 운영 측면에서의 이점을 더 살리기 위해서, 결합을 분리할 때 모드를 선택해야 한다.
  * 분리된 컴포넌트를 서로 다른 서버에서 실행해야 하는 상황이라면, 컴포넌트들은 단일 프로세서의 동일한 주소 공간을 활용하는 형태로 만들어져서는 안된다.
  * 즉, 분리된 컴포넌트 각각이 독립된 서비스가 되어 서로 네트워크를 통해 통신해야 한다.
  * 이러한 아키텍쳐는 서비스 지향 아키텍쳐라고 부른다.

### 개발 독립성
* 컴포넌트가 완전히 분리되면 팀 간의 간섭은 줄어들 수 밖에 없다.
* 유즈케이스 역시 결합이 분리되면 각 유즈케이스를 담당하는 팀 간의 개입 가능성은 없어진다.
* 개발 조직은 각 팀이 담당하는 유형에 따라 기능팀, 계층팀, 컴포넌트팀 또는 그 이외의 형태로 팀을 구성할 수 있다.
  * 그러나 **어떤 형태의 팀이더라도 계층과 유즈케이스의 결합이 분리되는 한 아키텍쳐는 각 팀의 구조를 뒷받침**하여 개발에 도움을 준다.

### 배포 독립성
* 유즈케이스와 계층의 결합이 성공적으로 분리되었다면, 배포 측면에서도 큰 유연성이 생긴다.
  * 성공적으로 결합이 분리되었다면 운영 중인 시스템에서도 계층과 유즈케이스를 교체할 수 있다.
  * 이는 hot-swap에 해당하며, 운영 중인 상태의 시스템에서 나머지 부분에 영향을 주지 않고 런타임에 jar나 서비스를 추가할 수 있는 능력을 말한다.

### 중복
* 소프트웨어에서 중복은 일반적으로 나쁜 것이다.
  * 코드의 중복을 발견한 경우, 일반적인 경우에 중복은 줄이거나 제거되어야 한다.
* 그러나 **중복에도 종류가 있다**.
  1. 진짜 중복: 하나의 인스턴스가 변경되면, 반드시 해당 인스턴스의 모든 복사본에도 변경을 적용해야 한다.
  2. 우발적 중복: 중복으로 보이는 두 영역의 코드가 각자의 상황에 맞게 발전할 수 있는 경우를 말한다.
* **우발적 중복의 경우, 각 영역이 서로 다른 속도와 다른 이유로 변경된다면 사실 진짜 중복이 아니다**.
* 예시: 별개의 유즈케이스를 담당하는 두 개의 화면 구조가 매우 유사한 경우
  * 일반적으로, 우리는 이러한 중복을 하나로 통합하고 싶은 유혹에 빠진다.
  * 그러나 이는 우발적 중복일 가능성이 높으며, 시간이 지나고 시스템이 성장함에 따라 각 화면은 서로 다른 방향으로 분기하여 매우 달라질 가능성이 높다.
  * 이러한 우발적 중복은 통합하지 않도록 주의해야 한다.
* **우발적 중복마저 모두 통합한다면, 추후 코드를 분리하기 위한 큰 수고를 감내해야 하는 상황**이 생기게 된다.
* 유즈케이스를 분리할 때 예시와 같은 상황을 많이 발견하게 될 것이며, 중복이 진짜 중복인지 확인하는 습관을 길러야 한다.

### 결합 분리 모드 II
* 계층과 유즈케이스의 결합을 분리하는 방법, 모드는 다양하다.
1. 소스 코드 수준 분리 모드(모놀리틱 구조)
   * 소스 코드에 포함된 모듈 사이의 의존성을 제어한다.
   * 하나의 모듈이 변경되더라도 다른 모듈을 변경하거나 재컴파일하지 않아도 된다.
   * 모든 컴포넌트는 같은 주소 공간에서 실행된다.
   * 컴포넌트 간 통신은 간단한 함수 호출을 사용한다.
   * 컴퓨터 메모리에는 하나의 실행 파일이 로드된다.
2. 배포 수준 분리 모드
   * jar, dll, 공유 라이브러리 등 배포 가능한 단위 사이에서 의존성을 제어한다.
   * 한 모듈의 소스 코드가 변경되더라도 다른 모듈을 재빌드하거나 재컴파일할 필요가 없어진다.
   * 많은 컴포넌트가 여전히 같은 메모리 공간에 상주하고, 서로 함수 호출을 통해 통신한다.
   * 일부의 컴포넌트는 다른 프로세스에 상주하고, 프로세스간 통신 또는 소켓, 공유 메모리를 통해 통신할 수 있다.
   * 결합이 분리된 컴포넌트가 jar, dll 등 독립적으로 배포 가능한 단위로 분할되었다는 점이 특징이다.
3. 서비스 수준 분리 모드(서비스 또는 마이크로서비스)
   * 의존 수준을 데이터 구조 단위까지 낮출 수 있다.
   * 각 컴포넌트는 네트워크 패킷을 통해서만 통신한다.
   * 모든 실행 가능한 단위는 소스와 바이너리 변경에 대해 완전히 독립적이게 된다.
* 프로젝트가 성숙해짐에 따라 최적인 모드는 점차 달라진다.
  1. 시스템 초기에는 한 서버에서 동작하는 것을 목표로 소스 수준에서의 분리만으로 충분하다.
  2. 그럼에도 컴포넌트 결합을 충분히 분리하고, 서비스에 대한 선택권을 충분히 열어두도록 해야 한다.
* 단순히 처음부터 서비스 수준까지 분리하는 것을 기본 정책으로 삼으면 프로젝트의 비용이 늘어나게 된다.
* 컴포넌트는 분리하되, 만약 컴포넌트가 서비스화될 가능성이 있다면 서비스화 직전에 멈추는 방식을 적용할 수 있다.
  * 이를 통해 서비스에 대한 선택권을 열어둘 수 있다.
* 좋은 아키텍쳐는 시스템이 모놀리틱 구조로 태어나서 단일 파일로 배포되었더라도, 
  1. 이후에는 독립적으로 배포 가능한 단위들로 성장하고,
  2. 필요하다면 독립적으로 배포 가능한 단위들 중 독립적인 서비스나 마이크로서비스로 전환할 배포 단위를 선택한 뒤 대응할 수 있어야 한다.
  3. 또한, 유사시 다시 모놀리틱 구조로 되돌릴 수도 있어야 한다.
* **좋은 아키텍쳐는 결합 분리 모드의 변경에 대해 소스 코드 대부분을 보호하고, 이를 선택사항으로 남겨두어 배포 규모에 따라 가장 적합한 모드를 선택할 수 있도록 한다**.
  * 물론 이를 성취하기는 어렵지만, 시스템의 결합 분리 모드는 프로젝트의 성장에 따라 바뀌기 쉬움을 인지하고 변경을 예측하여 대응할 수 있도록 준비해야 한다.
# Architecture
## 2022-01-21 Fri

## 아키텍쳐
* **아키텍쳐란 시스템을 구축했던 사람들이 만들어낸 시스템의 형태**이다.
* 시스템의 형태는 컴포넌트로 분할하는 방법, 분할된 컴포넌트를 배치하는 방법, 컴포넌트가 서로 상호작용하는 방식에 따라 정해진다.
  * 그리고 **형태는 아키텍쳐 안에 담긴 소프트웨어 시스템이 쉽게 개발, 배포, 운영, 유지보수되도록 만들어진다**.
* 시스템 **아키텍쳐는 시스템의 동작 여부와는 거의 관련이 없다**.
  * 아키텍쳐는 시스템이 제대로 동작하도록 지원하는 데에 아무런 역할을 하지 않는 것은 아니다.
    * 그러나 이러한 역할은 수동적이며 피상적인 것에 해당한다. 능동적이고 본질적인 것이 아니다!
  * 형편없는 아키텍쳐를 갖는 시스템도 대체로 운영에서는 문제를 겪지 않는다.
  * 그러나 그러한 시스템들은 배포, 유지보수, 계속되는 개발 과정에서 어려움을 겪는다.
* 아키텍쳐의 목적은 **시스템의 생명주기를 지원하는 것**이다.
  * 아키텍쳐의 궁극적인 목표는 시스템의 수명과 관련된 비용을 최소화하고, 프로그래머의 생산성을 최대화하는데에 있다.

## 시스템 아키텍쳐의 역할
### 개발
* 시스템 아키텍쳐는 개발팀들이 시스템을 쉽게 개발할 수 있도록 뒷받침해야 한다.
* 개발자가 적은 팀은 잘 정의된 컴포넌트나 인터페이스가 없더라도 모놀리틱 시스템을 개발할 수도 있다.
* 개발자 여럿이 다수의 팀으로 구성된 개발 조직은 시스템을 잘 설계된 컴포넌트로 분리하지 않으면 개발이 진척되지 않는다.
  * 다른 요소를 고려하지 않는다면 시스템의 아키텍쳐는 팀 당 하나의 컴포넌트로 발전될 가능성이 높다.
  * 그러나 팀별 단일 컴포넌트를 갖는 아키텍쳐가 시스템의 배포, 운영, 유지보수에 최적일 가능성은 거의 없다.

### 배포
* 소프트웨어 시스템이 사용될 수 있으려면 반드시 배포될 수 있어야 한다.
* 배포 비용이 높을 수록 시스템의 유용성은 떨어진다.
* 아키텍쳐는 시스템을 단 한 번에 손쉽게 배포할 수 있도록 만드는 데에 목표를 두어야 한다.
  * 초기 개발 단계에서는 배포 전략을 고려하지 않는 경우가 많다.
  * 이러한 상태를 방치하면 개발은 쉽지만 배포가 어려운 아키텍쳐가 만들어지게 된다.

### 운영
* 아키텍쳐는 개발, 배포, 유지보수에 미치는 영향보다 운영에 미치는 영향이 더 적은 편이다.
  * 운영에서 발생하는 어려움은 대부분의 경우 아키텍쳐 변경 없이 추가 하드웨어 투입으로 해결되곤 한다.
  * 운영을 방해하는 아키텍쳐가 개발, 배포, 유지보수를 방해하는 아키텍쳐보다는 비용을 덜 소모한다.
* 시스템 운영시 아키텍쳐는 개발자에게 시스템의 운영 방식을 상세히 알려주는 역할을 한다.
  * 아키텍쳐는 use case, 기능, 시스템의 필수 행위가 개발자에게 주요 목표로 인식되도록 해야한다.
  * 이를 통해 개발자가 시스템을 이해하기 쉬워지며, 개발과 유지보수에도 간접적으로 큰 도움을 준다.

### 유지보수
* 유지보수는 모든 측면에서 봤을 때 시스템에서 비용이 가장 많이 든다.
* 유지보수의 가장 큰 비용은 탐사와, 탐사에서 기인한 위험부담이다.
  * 탐사란 기존 소프트웨어에 새로운 기능을 추가하거나 결함을 수정할 때 소프트웨어의 어디를, 어떤 전략으로 고치는 것이 최적일지 결정할 때 드는 비용이다.
  * 또한 이러한 변경사항을 반영할 때 의도치 않은 결함이 발생할 가능성은 항상 존재하며, 이러한 위험부담 비용이 추가된다.
* 신중하게 설계된 아키텍쳐는 이러한 비용을 크게 줄일 수 있다.
  * 시스템을 컴포넌트 단위로 분리하고, 안정된 인터페이스를 두어 서로 격리해야 한다.
  * 이러한 아키텍쳐는 추가될 기능에는 개방적이고, 의도치 않은 장애가 발생할 위험을 크게 줄여준다.

### 선택사항 열어두기
* 소프트웨어는 기계의 행위를 빠르고 쉽게 변경하기 위해 필요했지만, 이러한 유연성은 시스템의 형태에 크게 의존한다.
* 소프트웨어를 부드럽게 유지하는 방법은 선택사항을 가능한 한 많이, 오래 열어두는 것이다.
  * 이 때, 열어두어야 할 선택사항은 '중요치 않은 세부사항'이다.
* 모든 소프트웨어 시스템은 두 가지 구성요소로 분해된다.
  1. 정책: 모든 업무 규칙과 업무 절차를 구체화한다. 시스템의 진정한 가치를 대변한다.
  2. 세부사항: 정책과 소통하기 위해 필요한 요소지만, 정책이 갖는 행위에는 전혀 영향을 주지 않는다.
     * 입출력 장치, 데이터베이스, 웹 시스템, 서버, 프레임워크, 통신 프로토콜 등이 해당된다.
* 아키텍트의 목표는 **시스템에서 정책을 가장 핵심적인 요소로 식별하고, 세부사항은 정책에 무관한 형태의 시스템을 구축하는 것**이다.
  * 이를 토대로 세부사항의 결정은 미루거나 연기할 수 있게 된다.
  1. 개발 초기에는 데이터베이스 시스템을 선택할 필요가 없다.
     * 고수준의 정책은 데이터베이스가 관계형인지, 분산형인지 관련이 없어야 한다.
  2. 개발 초기에는 웹 서버를 선택할 필요가 없다.
     * 웹 개발 기술들에 대해 고수준의 정책이 전혀 알지 못하게 만드는 것으로, 프로젝트 후반까지 어떤 종류의 웹 시스템을 사용할지 결정할 필요가 없다.
  3. 개발 초기에는 REST를 적용할 필요가 없다.
     * 고수준의 정책은 외부 세계로의 인터페이스와 독립적이어야 한다.
     * 마이크로서비스 / SOA도 적용할 필요가 없다. 고수준의 정책은 이러한 내용을 신경쓸 필요가 없다.
  4. 개발 초기에는 의존성 주입 프레임워크를 적용할 필요가 없다.
     * 고수준의 정책은 의존성을 해석하는 방식에 대해 신경쓸 필요가 없다.
* **세부사항의 결정을 오랫동안 참는다면 더 많은 정보를 얻어 이를 기초로 한 결정을 내릴 수 있다**.
* 상술한 상황이 가능한 경우, 여러 세부사항 후보를 테스트하여 적용 가능성과 성능을 검토해볼 수 있다.
* 좋은 아키텍트는 시스템의 정책과 세부사항을 가려내고, 두 요소가 결합되지 않도록 엄격하게 분리한다.
  * 이를 통해 정책은 세부사항에 대해 아무것도 모르는 상태를 유지하며, 어떠한 경우에도 세부사항에 의존하지 않게 된다.
  * 이러한 이유에서 세부사항에 대한 결정은 가능한 한 오랫동안 미룰 수 있는 방향으로 정책을 설계해야 한다.
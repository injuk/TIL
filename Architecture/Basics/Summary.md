# Architecture - summary
## 2023-03-07 Tue
### 좋은 아키텍쳐, 나쁜 아키텍쳐
```
> 좋은 아키텍쳐를 만드는 원칙은 보편적이고 불변하며, 이는 곧 소프트웨어의 핵심 역시 변하지 않음을 의미한다.
> 그러나 아키텍쳐 자체는 끝이 있는 결과물이 아닌 소프트웨어의 부드러움을 보존해나가는 탐구 과정이다.
```
* 소프트웨어 아키텍쳐의 목표는 필요한 시스템을 만들되, 유지보수에 필요한 공수를 최소화하는 데에 있다.
  * 따라서 아키텍쳐의 품질은 새로운 요구사항을 충족하기 위한 비용으로 판단할 수 있으며, 고도화 과정에 낮은 비용을 유지할 수 있는 것이 좋은 설계이다.
* 반면, 나쁜 아키텍쳐는 많은 경우에 '언제든지 재설계할 수 있다' 또는 '계속해서 생산성을 높게 유지할 수 있다' 따위의 자기 과신에서 비롯된다.

## 2023-03-08 Wed
### 소프트웨어 개발자의 책임
```
> 관리자는 구조의 중요성을 평가하지 못하는 경우가 많으므로, 개발자는 코드 작성이라는 '행위'의 긴급성보다 '아키텍쳐'의 중요성을 충분히 전달할 책임을 갖는다.
```
* 모든 소프트웨어는 요구사항을 코드로 구체화하는 `행위`와 소프트웨어의 유연성을 유지하는 `아키텍쳐` 라는 두 가지 가치를 제공한다.
  * 개발자들은 실질적인 코드를 의미하는 `행위`에 집중하기 쉬우나, 실제로는 요구사항에 쉽게 대응할 수 있도록 하는 `아키텍쳐`에 더 관심을 기울여야 한다.
  * 대부분의 경우, 이러한 오판은 한시가 급하지만 중요하지는 않은 `행위`와 / 중요하지만 급하지는 않은 `아키텍쳐`의 특성에서 기인한다.

### 세 가지 프로그래밍 패러다임과 구조적 프로그래밍
```
> 패러다임이란 곧 프로그래밍하는 방법이며, 지금까지 그래왔듯 앞으로도 구조적 / 객체 지향 / 함수형의 세 가지로 분류할 수 있다.
> 상술한 패러다임들은 각각 개발자의 goto문의 남용 / 함수 포인터 / 할당문을 박탈하는 식으로 코드의 작성을 제약하며, 결과 '무엇을 하지 말아야할지' 제시한다.  
```
* 구조적 프로그래밍을 토대로 시스템은 여러 기능적인 모듈과 컴포넌트로 분할될 수 있게 되었다.
* 구조적 프로그래밍은 시스템을 증명할 수 있는 `세부적인 기능 집합`으로 분해하고, 테스트를 통해 각 기능을 반증(=거짓을 증명)할 것을 권장한다.
  * 이러한 테스트는 시스템의 참이 아닌 거짓을 증명하는 데에 의의를 두는 반면, 많은 테스트를 통해 세부적인 기능들은 충분히 참이라고 여겨질 수 있게 된다.
* 즉, 구조적 프로그래밍은 시스템을 반증 가능한 단위로 분할할 수 있는 능력으로 인해 그 가치를 갖는다.

### 객체 지향 프로그래밍이란?
```
> 좋은 아키텍쳐의 시작은 객체 지향 설계 원칙을 이해하고, 응용하는 데에서 출발한다.
```
* 객체 지향 프로그래밍의 본질은 캡슐화나 상속이 아닌 다형성에 있으며, 이를 통해 제어 흐름을 간접적으로 전환하도록 권장한다.
* 다형성은 이를 적절히 활용한 시스템이 기능을 확장하는 과정에서 기존 코드를 수정할 필요가 없게 하는 데에 가치를 갖는다.
* 객체 지향 언어가 다형성을 지원한다는 사실은 곧 코드의 의존성을 어디서나 원하는대로 역전시킬 수 있다는 점을 시사한다.
  * 결국 객체 지향 프로그래밍을 통해 코드 의존성 수립의 절대적인 제어 권한을 개발자가 소유하며, 이는 객체 지향이 제공하는 힘이자 지향점이기도 하다.
* 개발자는 객체 지향을 통해 플러그인 아키텍쳐를 구현할 수 있으며, 이를 토대로 고수준의 모듈(=정책)을 저수준의 모듈(=세부사항)으로부터 독립시킬 수 있다.
  * 예를 들어, 저수준의 세부사항은 중요도가 낮은 플러그인 모듈로 정의하여 고수준의 정책은과 독립적으로 개발하고 배포할 수 있다.

## 2023-03-09 Thu
### 함수형 프로그래밍이란?
```
> 함수형 프로그래밍은 불변성을 보장하며, 이는 race condition 등 가변적인 변수의 성질에서 기인하는 모든 문제를 방지할 수 있도록 한다.
```
* 시스템은 변수가 변경될 수 있는 가변 컴포넌트와, 그렇지 않은 불변 컴포넌트로 구조화될 수 있다.
  * 이 경우, 불변 컴포넌트는 순수한 함수형 방식으로 작성되어 하나 이상의 가변 컴포넌트와 통신하는 식으로 동작하게 된다.
  * 좋은 설계자는 가능한 한 많은 로직을 불변 컴포넌트에 정의하는 반면, 가변 컴포넌트에서는 코드를 최대한 제거한다.
* 이벤트 소싱은 가변적인 상태를 사용하는 대신 상태의 시작점부터 모든 작업을 처리하는 트랜잭션을 저장하는 전략에 해당하며, 높은 하드웨어 자원을 필요로 한다.
  * 이 경우 애플리케이션은 CR만을 수행하므로 동시성 문제가 발생하지 않으며, 좋은 하드웨어 자원이 보장되므로 필요한 가변 상태는 적어진다.
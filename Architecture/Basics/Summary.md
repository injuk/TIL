# Architecture - summary
## 2023-03-07 Tue
### 좋은 아키텍쳐, 나쁜 아키텍쳐
```
> 좋은 아키텍쳐를 만드는 원칙은 보편적이고 불변하며, 이는 곧 소프트웨어의 핵심 역시 변하지 않음을 의미한다.
> 그러나 아키텍쳐 자체는 끝이 있는 결과물이 아닌 소프트웨어의 부드러움을 보존해나가는 탐구 과정이다.
```
* 소프트웨어 아키텍쳐의 목표는 필요한 시스템을 만들되, 유지보수에 필요한 공수를 최소화하는 데에 있다.
  * 따라서 아키텍쳐의 품질은 새로운 요구사항을 충족하기 위한 비용으로 판단할 수 있으며, 고도화 과정에 낮은 비용을 유지할 수 있는 것이 좋은 설계이다.
* 반면, 나쁜 아키텍쳐는 많은 경우에 '언제든지 재설계할 수 있다' 또는 '계속해서 생산성을 높게 유지할 수 있다' 따위의 자기 과신에서 비롯된다.

## 2023-03-08 Wed
### 소프트웨어 개발자의 책임
```
> 관리자는 구조의 중요성을 평가하지 못하는 경우가 많으므로, 개발자는 코드 작성이라는 '행위'의 긴급성보다 '아키텍쳐'의 중요성을 충분히 전달할 책임을 갖는다.
```
* 모든 소프트웨어는 요구사항을 코드로 구체화하는 `행위`와 소프트웨어의 유연성을 유지하는 `아키텍쳐` 라는 두 가지 가치를 제공한다.
  * 개발자들은 실질적인 코드를 의미하는 `행위`에 집중하기 쉬우나, 실제로는 요구사항에 쉽게 대응할 수 있도록 하는 `아키텍쳐`에 더 관심을 기울여야 한다.
  * 대부분의 경우, 이러한 오판은 한시가 급하지만 중요하지는 않은 `행위`와 / 중요하지만 급하지는 않은 `아키텍쳐`의 특성에서 기인한다.

### 세 가지 프로그래밍 패러다임과 구조적 프로그래밍
```
> 패러다임이란 곧 프로그래밍하는 방법이며, 지금까지 그래왔듯 앞으로도 구조적 / 객체 지향 / 함수형의 세 가지로 분류할 수 있다.
> 상술한 패러다임들은 각각 개발자의 goto문의 남용 / 함수 포인터 / 할당문을 박탈하는 식으로 코드의 작성을 제약하며, 결과 '무엇을 하지 말아야할지' 제시한다.  
```
* 구조적 프로그래밍을 토대로 시스템은 여러 기능적인 모듈과 컴포넌트로 분할될 수 있게 되었다.
* 구조적 프로그래밍은 시스템을 증명할 수 있는 `세부적인 기능 집합`으로 분해하고, 테스트를 통해 각 기능을 반증(=거짓을 증명)할 것을 권장한다.
  * 이러한 테스트는 시스템의 참이 아닌 거짓을 증명하는 데에 의의를 두는 반면, 많은 테스트를 통해 세부적인 기능들은 충분히 참이라고 여겨질 수 있게 된다.
* 즉, 구조적 프로그래밍은 시스템을 반증 가능한 단위로 분할할 수 있는 능력으로 인해 그 가치를 갖는다.

### 객체 지향 프로그래밍이란?
```
> 좋은 아키텍쳐의 시작은 객체 지향 설계 원칙을 이해하고, 응용하는 데에서 출발한다.
```
* 객체 지향 프로그래밍의 본질은 캡슐화나 상속이 아닌 다형성에 있으며, 이를 통해 제어 흐름을 간접적으로 전환하도록 권장한다.
* 다형성은 이를 적절히 활용한 시스템이 기능을 확장하는 과정에서 기존 코드를 수정할 필요가 없게 하는 데에 가치를 갖는다.
* 객체 지향 언어가 다형성을 지원한다는 사실은 곧 코드의 의존성을 어디서나 원하는대로 역전시킬 수 있다는 점을 시사한다.
  * 결국 객체 지향 프로그래밍을 통해 코드 의존성 수립의 절대적인 제어 권한을 개발자가 소유하며, 이는 객체 지향이 제공하는 힘이자 지향점이기도 하다.
* 개발자는 객체 지향을 통해 플러그인 아키텍쳐를 구현할 수 있으며, 이를 토대로 고수준의 모듈(=정책)을 저수준의 모듈(=세부사항)으로부터 독립시킬 수 있다.
  * 예를 들어, 저수준의 세부사항은 중요도가 낮은 플러그인 모듈로 정의하여 고수준의 정책은과 독립적으로 개발하고 배포할 수 있다.

## 2023-03-09 Thu
### 함수형 프로그래밍이란?
```
> 함수형 프로그래밍은 불변성을 보장하며, 이는 race condition 등 가변적인 변수의 성질에서 기인하는 모든 문제를 방지할 수 있도록 한다.
```
* 시스템은 변수가 변경될 수 있는 가변 컴포넌트와, 그렇지 않은 불변 컴포넌트로 구조화될 수 있다.
  * 이 경우, 불변 컴포넌트는 순수한 함수형 방식으로 작성되어 하나 이상의 가변 컴포넌트와 통신하는 식으로 동작하게 된다.
  * 좋은 설계자는 가능한 한 많은 로직을 불변 컴포넌트에 정의하는 반면, 가변 컴포넌트에서는 코드를 최대한 제거한다.
* 이벤트 소싱은 가변적인 상태를 사용하는 대신 상태의 시작점부터 모든 작업을 처리하는 트랜잭션을 저장하는 전략에 해당하며, 높은 하드웨어 자원을 필요로 한다.
  * 이 경우 애플리케이션은 CR만을 수행하므로 동시성 문제가 발생하지 않으며, 좋은 하드웨어 자원이 보장되므로 필요한 가변 상태는 적어진다.

### SOLID 원칙이란?
```
> SOLID는 깔끔한 코드를 기반으로 좋은 아키텍쳐를 정의하는 원칙이며, 여러 함수와 데이터 구조를 클래스로 배치하고 이들을 결합하는 방법을 제시한다.
```
* SOLID 원칙은 변경에 가독성이 높으면서도 재사용성과 유지보수성이 높은 소프트웨어 구조를 설계하기 위해 존재한다.
* SOLID 원칙은 코드보다는 더 높은 계층에서 적용되며, 모듈 또는 컴포넌트 등에서 사용되는 소프트웨어 구조를 정의하는 데에 도움을 준다.

### 단일 책임 원칙
```
> SRP는 단일 모듈이 변경되어야 할 이유는 반드시 하나 뿐이어야 한다는 점을 강조한다.
> SRP는 메소드와 클래스 수준의 원칙으로, SOLID의 다른 원칙에 비해 더 저수준에서 적용되어야 하는 원칙이다.
```
* SRP 관점에서 변경의 이유는 사용자 또는 이해 관계자로 구성된 하나의 집단인 `액터`로부터 기인한다.
  * 즉, **SRP는 하나의 모듈이 책임지는 것은 오직 하나의 액터만이 되어야 함을 의미**한다.
* 단일 `액터`를 책임질 코드들을 한데 모으는 힘은 응집성이므로, 서로 다른 `액터`들이 의존하는 코드는 각각 분리되어야 한다.
* **SRP를 위배하는 사례가 발견된 경우, 가장 단순하면서도 확실한 해결법은 데이터와 메소드를 분리**하는 데에 있다.

## 2023-03-10 Fri
### 개방 폐쇄 원칙
```
> 객체의 행위는 확장에 열려 있되, 객체 자체의 변경에는 폐쇄적이어야 한다.
> OCP는 소프트웨어 아키텍쳐를 공부하는 가장 근본적인 이유에 해당한다.
```
* OCP는 클래스 또는 모듈 설계 수준 뿐만이 아닌, 아키텍쳐 컴포넌트 수준에서도 큰 의미를 갖는다.
* OCP는 서로 다른 목적으로 변경되는 요소를 분리하고(SRP), 분리된 요소 사이의 의존성을 정리하는 것(DIP)으로 성취할 수 있다.
  * 이를 토대로 분리된 책임 중 하나가 수정될 때, 다른 요소는 변경되지 않는 식으로 기능 확장으로부터 비롯되는 변경량을 최소화해야 한다.
* OCP를 준수하는 아키텍쳐의 경우, 변경으로부터 보호되어야 하는 객체는 의존 대상이 되어야 한다.
  * 이 관점에서, 시스템의 가장 중요한 요소인 정책을 의미하는 컴포넌트는 다른 무엇에도 의존하지 않아야 한다.
  * 반면, 가장 중요하지 않은 문제를 처리하는 컴포넌트는 고수준의 컴포넌트로부터 전파되는 변경으로부터 거의 보호받지 못한다.
* 개발자는 요구사항에 따라 기능을 분리한 후 이들을 컴포넌트 계층 구조로 조직화하여 고수준의 컴포넌트를 보호할 수 있어야 한다.
* **OCP를 통해 시스템은 의존성 계층 구조를 갖추며, 이에 따라 변경에 대응하기 위한 높은 유연성을 갖게 된다**.

### 리스코프 치환 원칙
```
> LSP는 상속 뿐만 아니라 임의의 인터페이스와 이를 구현하는 구현체에도 적용 가능한 설계 원칙이다.
```
* 코드 상에서 두 클래스 사이의 치환 가능성을 의미하는 **LSP는 아키텍쳐 수준으로도 확장 가능**하며, 반드시 확장되어야만 한다.

## 2023-03-11 Sat
### 인터페이스 분리 원칙
```
> 일반적으로 필요한 이상으로 많은 기능을 포함하는 모듈에 의존하는 것은 나쁘며, 이는 아키텍쳐 수준에서도 마찬가지이다.
```
* 정적 타입 언어로 구성된 시스템 상에서, 여러 클래스가 단일 클래스에 의존할수록 자신과 관련 없는 메소드의 수정으로 인해 불필요한 컴파일이 발생하기 쉽다.
* 이러한 문제를 해결하는 방법은 너무 무거운 클래스에 포함되는 여러 기능을 여러 개의 인터페이스로 분할하여 ISP를 준수하는 데에 있다.
* 반면, ISP는 모든 프로그래밍 언어에 동일한 영향을 주는 원칙은 아니다.
  * 예를 들어, 동적 타입 언어의 경우 높은 유연성과 낮은 결합도를 유지하기 쉽기에 이러한 문제는 발생하지 않아 ISP로부터 일정 부분 자유로울 수 있다.

### 의존성 역전 원칙
```
> 안정적인 아키텍쳐는 변동성이 큰 세부 사항에 의존하는 대신 안정적인 추상 인터페이스를 선호한다.
> 즉, 시스템의 유연성을 극대화하고자 하는 경우 소스 코드의 의존성은 반드시 구체적인 세부 사항이 아닌 추상에 의존해야 한다.
> 의존성 규칙이란, 추상 컴포넌트와 구체 컴포넌트를 분리하는 기준으로서 의존성이 항상 더 추상적인 개념으로 향하도록 권장한다.
```
* 이상적으로, Java의 경우 import 구문을 통해 발생하는 의존성은 오로지 인터페이스 또는 추상 클래스에만 국한되어야 한다.
* 반면 구체적인 세부 사항은 곧 잠재적인 변동성을 의미하므로, 변경이 잦을 수 밖에 없는 구체적인 모듈에는 의존하지 않아야 한다.
  * 그러나 시스템은 현실적으로 많은 구체에 의존하게 되며, 예를 들어 String과 같은 충분히 안정적인 구체 클래스에는 의존성이 발생해도 무방하다.
  * 즉, **DIP는 코드 뿐만 아니라 OS 등 충분히 안정성이 보장되고 변경이 엄격하게 통제되는 환경에서는 위배되어도 무방**하다.
* 그러나 **대부분의 경우 객체를 생성하는 과정에서 해당 객체에 의존하게 되므로, 이러한 문제를 해결하기 위해 추상 팩토리의 사용이 권장**된다.
  * 이렇듯 추상 팩토리를 적절히 활용하면 시스템은 고수준의 규칙을 포함하는 추상 컴포넌트와 규칙을 다루기 위한 세부 사항인 구체 컴포넌트로 나뉘어질 수 있다.
* **DIP를 준수하는 경우, 코드 의존성은 제어 흐름과는 반대 방향으로 역전되어 설정**될 수 있다.
* 현실적으로 **DIP를 위배하지 않을 수는 없으나, 최소한 이를 위배하는 클래스를 몇몇 구체 컴포넌트에 모아 시스템의 다른 부분으로부터 격리해둘 수 있다**.
  * 예를 들어, 대부분의 시스템은 main 함수를 포함하는 구체 컴포넌트(=Main 컴포넌트)를 최소한 하나는 포함할 수 밖에 없다. 

## 2023-03-12 Sun
### 컴포넌트 원칙이란?
```
> 컴포넌트는 시스템의 구성 요소로 배포할 수 있는 가장 작은 단위이며, 예를 들어 jar 또는 dll 등이 있다.
> SOLID 원칙이 컴포넌트를 설계하는 방법을 제시한다면, 컴포넌트 원칙은 시스템을 구성하는 컴포넌트들을 배치하는 방법을 제시한다.
```
* 잘 설계된 컴포넌트는 언제나 독립적으로 개발 가능하며, 배포 역시 가능하다.
* 또한, 컴포넌트는 런타임에 플러그인 형태로 결합할 수 있는 동적인 링크 파일을 포함한다.

### 재사용 / 릴리즈 등가 원칙
```
> 재사용 단위는 곧 릴리즈 단위와 같아야 하며, 하나의 컴포넌트로 묶인 클래스와 모듈들은 반드시 함께 릴리즈될 수 있어야 한다.
```
* **단일 컴포넌트는 응집성이 높은 클래스와 모듈들로 구성되어야 하며, 서로 공유하는 중요한 목적이 있어야 한다**.
* REP는 다른 컴포넌트 원칙들만큼 `어떤 클래스와 어떤 모듈을 단일 컴포넌트로 구성해야 하는지`를 설명하지는 못하지만, 원칙 자체는 매우 중요하다.

### 공통 폐쇄 원칙
```
> 동일한 이유로 동일한 시점에 변경되는 클래스는 같은 컴포넌트에 배치되어야 하는 반면, 서로 다른 이유로 변경되는 클래스는 분리되어야 한다.
> 시스템에 CCP가 올바르게 적용된 경우, 변경이 발생했을 때 영향을 받는 컴포넌트들이 최소화될 수 있다.
```
* CCP는 SRP 원칙을 컴포넌트 관점에서 바라본 원칙으로, 단일 컴포넌트의 변경의 이유를 제한한다.
  * 즉, **CCP를 준수하기 위해서는 서로 다른 이유로 변경되는 클래스들을 서로 다른 컴포넌트에 분리**해야 한다.
  * 이렇듯 **두 원칙은 기본적으로 동일한 시점에 동일한 이유로 변경되는 요소들을 하나로 묶을 것을 권장**한다.
* 시스템의 유지보수성은 대부분의 경우에 재사용성보다 훨씬 중요하며, 변경은 가능한 한 단일 컴포넌트에서만 발생되는 것이 바람직하다.
* **CCP는 또한 OCP와도 밀접한 관련이 있으며, 동일한 유형의 변경에 대해 닫혀 있는 클래스들을 하나의 컴포넌트에 배치할 것을 권장**한다.

### 공통 재사용 원칙
```
> 함께 재사용되는 경향이 있는 클래스와 모듈들은 단일 컴포넌트에 배치하는 반면, 컴포넌트 사용자 관점에서 필요하지 않은 것에 의존할 필요는 없어야 한다.
```
* 어떤 **컴포넌트에 의존한다면 이에 포함되는 모든 클래스에 의존하게 되므로, 강하게 결합되지 않은 클래스들은 같은 컴포넌트에 배치되지 않아야 한다**.
  * 즉, 컴포넌트의 일부에만 의존하고 나머지 부분에 포함되는 클래스들과는 독립적인 상황은 기본적으로 발생할 수 없다.
* CRP는 컴포넌트 관점에서의 ISP이며, 두 원칙은 모두 필요하지 않은 것에 의존하지 않아야 함을 시사한다.
  * 또한, 컴포넌트에 속한 클래스들 역시 더 작은 단위로 분류될 수 있다.

## 2023-03-13 Mon
### REP / CCP / CRP의 관계
```
> REP와 CCP는 컴포넌트를 크게 만들고자 하는 반면, CRP는 컴포넌트를 작게 만들고자 하므로 서로 상충되는 면이 있다.
> 때문에 개발자는 팀의 요구사항을 충분히 충족시키는 위치를 찾되, 프로젝트가 성숙함에 따라 가치는 변경될 수 있다는 사실을 이해하는 것이 바람직하다.
```
* 상술한 세 원칙은 일종의 tradeoff 관계에 있으며, 일반적으로 다음과 같은 결과를 얻게 된다.
  1. 유지보수를 위한 CCP를 위배하는 경우, 컴포넌트의 변경이 빈번해질 수 있다.
  2. 불필요한 배포를 회피하기 위한 CRP를 위배하는 경우, 불필요한 릴리즈가 빈번히 발생할 수 있다.
  3. 재사용성을 향상시키기 위한 REP를 위배하는 경우, 재사용성보다는 개발 가능성에 초점을 맞추므로 컴포넌트의 재사용성은 낮아지게 된다.
* 일반적으로는 프로젝트 초기에 REP를 희생하되, 프로젝트가 성숙함에 따라 개발 가능성 대신 재사용성에 초점을 옮기는 방식으로 진행하게 된다.
  * 이렇듯 **컴포넌트의 구성 방식은 시간과 프로젝트의 성숙도에 영향을 받아 점점 변화하며 진화하는 가변적인 구조에 해당**한다.
* **개발자는 컴포넌트를 어떤 클래스를 묶어 만들지 결정하는 경우, 재사용성과 개발 가능성이라는 tradeoff를 항상 고려**할 수 있어야 한다.

### 컴포넌트 결합 원칙과 의존성 비순환 원칙
```
> 컴포넌트 간의 관계를 설명하는 세 원칙이 그렇듯, 컴포넌트의 결합과 관련된 원칙 역시 개발 가능성과 논리적인 설계 사이의 균형을 다룬다.
> 예를 들어 컴포넌트 의존성 그래프에는 순환이 없어야 하며, 의존성 관계를 따라갔을 때 컴포넌트 자신으로 회귀할 수 없는 구조가 권장된다.
> 컴포넌트의 의존성 구조는 시스템의 논리적인 설계에 맞추어 성장하며, 또 진화해나가야만 한다.
```
* 컴포넌트 사이의 순환 의존성이 발생하는 경우, 이러한 컴포넌트들은 사실상 동일한 릴리즈를 필요로 하는 거대한 컴포넌트가 될 수 있다.
  * 이러한 구조는 분리가 어렵고 하나의 변경 사항이 다른 컴포넌트들의 빌드와 통합을 요구로 하는 등 영향을 주게 된다.
  * 따라서 컴포넌트 사이의 의존성 관계는 비순환 방향 그래프인 `DAG`의 형태를 가져야 한다.
* **순환 의존성이 발생한 경우, DIP를 적용하거나 추상적인 새로운 컴포넌트를 도입하는 것으로 의존성을 역전시켜 언제든지 순환을 끊어낼 수 있다**.
  * 바꿔 말해 요구사항의 변경에 따라 컴포넌트 구조가 변경될 수 있음을 의미하며, 이는 시스템이 성숙해나가는 과정에서 자연스러운 현상이기도 하다.
* 컴포넌트 의존성 다이어그램은 시스템의 빌드 가능성과 유지보수성을 보여주는 반면, 프로젝트 초기에는 유지보수할 컴포넌트가 없으므로 이를 설계할 수 없다.

## 2023-03-14 Tue
### 안정된 의존성 원칙
```
> 변경은 불기파하므로 설계는 동적이며, 최소한 더 안정된 모듈에 의존하도록 해야 한다. 
> 즉, 안정된 컴포넌트는 변경되기 쉽도록 설계된 컴포넌트에 절대로 의존하지 않아야 한다.
> 모든 컴포넌트가 항상 안정적일 필요는 없으며, 이상적인 컴포넌트 구조에서는 안정적인 컴포넌트와 불안정한 컴포넌트가 공존한다.
```
* CCP를 준수하는 것으로 컴포넌트가 특정한 변경에만 반응하도록 만들 수 있으며, 이는 곧 컴포넌트 중 일부는 의도적으로 변동성을 갖도록 설계됨을 의미한다.
  * 다시 말해, 의도적으로 변동성을 지니도록 설계된 컴포넌트는 언젠가 변경될 것임을 쉽게 기억할 수 있다.
* 컴포넌트는 크기나 복잡도 또는 간결성 등의 요인에 따라 변경이 어려울 수 있으나, 가장 확실한 방법은 많은 컴포넌트들이 해당 컴포넌트에 의존하도록 하는 것이다.
  * 바꿔 말해, **다른 컴포넌트들로부터 의존되는 컴포넌트는 사소한 변경으로도 모든 컴포넌트를 만족시켜야하므로 안정적**이다.
  * 반면, **여러 컴포넌트에 의존되나 다른 컴포넌트에 의존하지 않는 컴포넌트는 이를 변경시키는 외부적 요인이 없으므로 독립적인 반면, 많은 책임을 갖는다**.
* 컴포넌트는 의존하는 컴포넌트와 책임지는 컴포넌트의 개수에 따라 다음과 같이 안정성이 결정된다.
  1. 최고로 안정적인 경우, 다른 컴포넌트들을 책임지지만 자신은 의존하지 않으므로 변경이 어려운 반면 자신은 변경을 일으키는 요인이 없어 독립적이다.
  2. 최고로 불안정한 경우, 어떠한 컴포넌트도 책임지지 않는 반면 자신은 외부 컴포넌트에 의존하므로 변경이 쉽고 잦게 발생한다.
* SDP가 위배된 상황에는 DIP를 적용하는 것으로 문제를 해결할 수 있으며, 이 과정에서 인터페이스만을 포함하는 추상 컴포넌트를 도입할 수 있다.
  * 이러한 추상 컴포넌트는 비록 실행 가능한 코드를 포함하지는 않으나, 안정적이므로 정적 타입 언어에서는 필수적인 전략에 해당한다.

### 안정된 추상화 원칙
```
> 시스템에는 정책 등 자주 변경되지 않아야 하는 컴포넌트가 포함되나, 너무 안정적인 경우 수정 자체가 어려워져 유연성을 얻게될 수 있다.
> 해당 원칙은 안정성과 추상화 사이의 관계를 정의하며, 안정적인 컴포넌트가 추상 컴포넌트일 것을 권장한다.
```
* 안정적인 컴포넌트는 인터페이스 또는 추상 클래스로 정의되어 쉽게 확장될 수 있어야 한다.
  * 이로 인해 설계는 유연성을 얻으며, 안정적인 컴포넌트가 갖는 안정성으로 인해 아키텍쳐가 제약되는 일이 방지된다.
* 반면, 불안정한 컴포넌트는 반드시 구체 컴포넌트로 구현되어 내부의 구체적인 코드를 쉽게 변경할 수 있어야 한다.
* SAP는 안정성이 추상화와 직결됨을 강조하며, 의존성의 방향이 곧 안정성의 방향이어야 함을 강조하는 SDP와 결합되는 것으로 DIP와 같은 바를 시사한다.
  * 그러나 DIP가 클래스와 관련된 원칙이라면, SDP와 SAP의 조합은 컴포넌트에 대한 원칙인 점에서 차이가 있다.
  * 예를 들어 클래스는 추상적이거나 구체적이지만, 컴포넌트는 추상적인 부분과 구체적인 부분이 혼재될 수 있다.

## 2023-03-15 Wed
### 다시, 아키텍쳐란?
```
> 아키텍쳐는 시스템을 구축하는 개발자들이 만들어낸 시스템의 형태이며, 컴포넌트들이 분할되어 각각 배치된 후 서로 상호작용하는 방법으로 결정된다.
> 또한 시스템의 형태는 아키텍쳐 안에 담긴 시스템이 쉽게 개발이나 배포 및 운영, 유지보수되도록 정의된다.
```
* **아키텍쳐의 궁극적인 목적은 시스템 자체의 정상 동작이 아닌, 생산성을 최대화하고 시스템의 생명주기를 최소비용으로서 지원**하는 데에 있다.
  * 아키텍쳐가 시스템의 정상성에 아무런 기여하지 않는 것은 아니지만, 이는 본질적인 것이 아니다.

### 시스템 아키텍쳐의 역할
* 시스템 아키텍쳐의 역할은 크게 다음과 같이 나누어 생각해볼 수 있다.
  1. 개발 관점에서: 시스템 아키텍쳐는 개발 팀이 시스템을 쉽게 개발할 수 있도록 지원해야 한다.
  2. 배포 관점에서: 시스템은 반드시 배포 가능해야 하며, 배포 비용이 높아질수록 시스템의 유용성은 낮아지므로 아키텍쳐는 손쉬운 배포를 지원할 수 있어야 한다.
  3. 운영 관점에서: 시스템 운영시 아키텍쳐는 usecase나 기능, 행위 등으로 하여금 개발자에게 시스템의 운영 방식을 상세히 알려줄 수 있어야 한다.
     * 이를 토대로 개발자는 시스템을 손쉽게 이해할 수 있게 되며, 이는 개발 및 유지보수에도 간접적인 도움을 줄 수 있다.
     * 반면, 아키텍쳐가 개발이나 배포 및 유지보수에 미치는 영향보다는 운영에 미치는 영향이 적은 편이다.
  4. 유지보수 관점에서: 유지보수는 모든 관점과 비교하여 시스템 상 비용을 가장 많이 소모하는 반면, 좋은 아키텍쳐는 이러한 비용을 크게 줄여줄 수 있다.
     * 예를 들어 시스템을 컴포넌트 단위로 분리하되, 안정적인 인터페이스를 두어 서로 격리하는 것으로 확장에는 개방적인 상태를 유지할 수 있다.

### 선택사항은 열어둘 것
```
> 소프트웨어는 기계의 행위를 빠르고 쉽고 변경하게 하지만, 이러한 유연성은 시스템의 형태에 크게 의존한다.
> 또한, 소프트웨어를 부드럽게 유지하는 방법은 여러 중요하지 않은 세부사항인 선택지들을 가능한 한 오래 열어두는 데에 있다.
> 좋은 개발자는 시스템에서 정책과 세부사항을 가려내어 두 요소가 결합되지 않도록 엄격하게 관리하며, 이를 토대로 정책이 세부사항을 모르는 상태를 오래 유지한다.  
```
* 모든 시스템은 다음과 같은 두 가지 요소로 분류된다.
  1. 정책: 모든 업무 규칙과 절차를 구체화하며, 시스템의 진정한 가치를 의미한다.
  2. 세부사항: 정책과 상호작용하기 위해서는 필수적이나, 정책이 갖는 행위에는 전혀 영향을 주지 않는 데이터베이스 등에 해당한다.
* **개발자는 시스템 상에서 정책을 가장 핵심적인 요소로서 식별하되, 세부사항은 정책과 무관한 형태의 시스템을 구축하는 것이 바람직**하다.
  * 이를 토대로 세부사항의 결정은 연기되며, 시스템은 오랜 동안 안정된 상태를 유지하고 개발 과정에서 얻어진 정보를 토대로 더 좋은 결정을 내릴 수 있다.
* 즉, **개발 초기에는 고수준의 정책과는 무관한 데이터베이스 또는 웹 서버나 심지어 RESTful API까지도 적용할 필요가 없다**.

## 2023-03-16 Thu
### 계층 결합 분리
```
> 개발자는 시스템의 모든 유즈케이스를 알 수는 없으나, 시스템의 기본적인 의도는 알 수 있으므로 이를 토대로 컴포넌트들을 구조화할 수 있다.
```
* UI와 같은 **세부 사항이 변경되는 이유는 고수준의 정책과는 아무런 관련이 없으므로, 정책과 그 이외의 요소는 서로 다른 이유로 변경되어야 한다**.
  * 개발자는 이러한 정책과 세부 사항들이 각각 시스템으로부터 분리되어 서로에게 독립적으로 변경될 수 있도록 보장해야 한다.

### 유즈케이스 결합 분리
```
> 여러 유즈케이스 또한 각각 서로 다른 이유로 변경될 수 있으며, 때문에 시스템은 수평적인 계층 뿐만 아니라 수직적인 계층인 유즈케이스로도 분할될 수 있다.
> 수직적으로 분할되는 유즈케이스에는 관점이라는 표현을 사용할 수 있으며, 이는 다시 횡단 관심사를 분리하는 관점 지향 프로그래밍으로 발전할 수 있다.  
```
* 시스템에 유즈케이스가 결합된 경우, 이를 분리하는 과정에서는 수평적으로 분할된 각 계층에서 겹치는 일이 없도록 주의해야 한다.
  * 이 때, 각각의 유즈케이스는 UI의 일부 및 애플리케이션 특화 업무 규칙의 일부, 애플리케이션 독립적인 업무 규칙의 일부와 데이터베이스의 일부를 사용한다.
* 이렇듯 **시스템에서 서로 다른 이유로 변경되는 요소들의 결합을 분리하면 기존 요소에는 영향을 주지 않으면서도 새로운 유즈케이스를 추가해나갈 수 있다**.
  * AOP를 토대로 각각의 유즈케이스가 서로 다른 관점을 사용한다면 새로운 유즈케이스가 추가되더라도 기존 유즈케이스는 거의 영향받지 않을 수 있다.

### 결합 분리하기
```
> 유즈케이스에서 서로 다른 관점들이 분리된 경우, 이 과정에서 높은 처리량을 요구하는 유즈케이스와 그렇지 않은 유즈케이스들은 분리된다.
```
* UI와 데이터베이스, 업무 규칙 등등이 각 계층으로 분리되었다면 이들은 서로 다른 서버에서 실행될 수 있으므로 운영 상의 이점이 발생한다.
  * 이렇듯 분리된 컴포넌트를 서로 다른 서버에서 실행하는 경우, 컴포넌트들은 단일 프로세서의 주소 공간을 활용하는 형태로 제작될 수 없다.
  * 대신 분리된 컴포넌트는 각각 독립된 서비스로서 통신하며, 이러한 접근 방식은 서비스 지향 아키텍쳐로 발전한다.

## 2023-03-17 Fri
### 개발 독립성, 배포 독립성
* 유즈케이스 결합이 분리되면 각 유즈케이스를 담당하는 팀 간의 개입 가능성은 없어지므로, 개발 독립성이 보장될 수 있다.
  * 이로 인해 개발 조직은 각 팀이 담당하는 유형에 따라 기능 팀과 계층 팀, 컴포넌트 팀 등등의 형태로 구성될 수 있다.
* 유즈케이스와 계층의 결합이 분리된 경우, 이는 배포 측면에서도 큰 유연성을 부여하므로 운영 중인 시스템에서도 계층과 유즈케이스를 교체하는 것이 가능해진다.
  * 이는 핫 스왑에 해당하며, 운영 중인 상태의 시스템에서 다른 컴포넌트에 영향을 주지 않고도 jar 등을 추가할 수 있는 능력을 의미한다.

### 진짜 중복과 우발적 중복
```
> 소프트웨어의 중복은 일반적으로 나쁘지만, 중복에도 종류가 있어 항상 나쁘다고 볼 수는 없다.
> 우발적 중복은 유즈케이스를 분리하는 과정에서 많이 발견될 수 있으며, 이를 진짜 중복으로 착각하지 않으려는 노력을 기울이는 것이 바람직하다.
```
* **중복은 매 수정마다 모든 중복 지점에 같은 변경을 가해야 하는 `진짜 중복`과 각각의 영역이 서로 다르게 발전할 수 있는 `우발적 중복`으로 분류**된다.
  * 특히 `우발적 중복`의 경우, 중복으로 보이는 두 영역이 서로 다른 이유에서 변경된다면 사실은 진짜 중복으로 볼 수 없다.
* `우발적 중복`마저 제거하는 경우, 추후 코드를 분리하기 위해 큰 수고를 감당해야할 수 있으므로 항상 중복이 `진짜 중복`인지 확인하는 습관을 길러야 한다.

### 결합 분리 모드
```
> 좋은 아키텍쳐는 모놀리틱 구조로 시작한 시스템도 추후에는 독립적인 배포 단위들로 성장하고, 필요한 경우 일부를 서비스로 전환할 수 있는 여지를 남겨둔다.
> 좋은 아키텍쳐는 결합 분리 모드의 변경에 대해 코드 대부분을 보호하고, 선택사항을 남겨 상황에 따라 적절한 모드를 선택할 수 있도록 한다.
```
* 계층과 유즈케이스 간의 결합을 분리하는 방법은 크게 다음과 같이 분류될 수 있다.
  1. 소스 코드 수준의 분리: 소스 코드에 포함되는 모듈 사이의 의존성만을 제어한다.
  2. 배포 수준의 분리: jar나 dll, 공유 라이브러리 등 배포 단위 사이에서 의존성을 제어한다.
  3. 서비스 수준의 분리: 각 컴포넌트가 네트워크를 통해서만 통신할 수 있도록 하며, 모든 실행 가능한 단위는 코드의 변경으로부터 완전히 독립된다.
* 결합을 분리하는 방법인 `모드`에 정답은 없으며, 프로젝트에 최적화된 모드는 프로젝트가 성숙해가는 과정에서 바뀌어갈 수 있다.
  * 예를 들어 프로젝트 초기에는 소스 코드 수준의 분리로 충분하지만, 언제든지 모드를 변경할 수 있는 여지를 남겨두는 방향으로 개발하는 것이 바람직하다.
* 결합 분리 모드를 자유자재로 변경하는 아키텍쳐를 제작하는 것은 어렵지만, 그럼에도 모드가 상황에 따라 가변적임을 인지하고 변경에 대응할 수 있도록 해야 한다.

## 2023-03-18 Sat
### 소프트웨어 안의 경계
```
> 아키텍쳐는 소프트웨어 요소를 분리하기 위해 경계를 긋는 기술이며, 분리된 요소는 경계 너머에 어떤 요소가 있는지 알 수 없어야 한다.
> 좋은 아키텍쳐는 세부사항의 결정이 부수적이고 연기할 수 있는 아키텍쳐이며, 소프트웨어에 경계를 긋는 작업은 결정을 늦추는 데에 큰 도움을 준다.
```
* **설계의 목표는 시스템의 제작 및 유지보수 비용을 최소화하는 데에 있는 반면, 일반적으로 비용을 높이는 것은 너무 이른 `결정`으로 인한 결합의 발생**에 있다.
  * 예를 들여, 시스템의 요구사항 또는 유즈케이스와는 아무런 관련이 없는 세부사항에 대한 결정은 미룰 수록 좋다.
* 좋은 시스템 아키텍쳐는 세부적인 결정 사항에 전혀 의존하지 않고 최후에 결정을 내리도록 하며, 이에 따른 영향도 크지 않게 만들어줄 수 있다.

### 경계를 위한 선 긋기
```
> 예를 들어 업무 규칙과 데이터베이스의 결정은 본질적으로 관련이 없으므로, 두 요소 사이에는 선이 그어져야 한다.
> 이러한 '선'은 인터페이스로 표현되며, 업무 규칙의 관점에서 인터페이스를 통해서만 데이터에 접근하고 데이터베이스에 대한 정보는 숨겨질 수 있다.
```
* 관련이 있는 것을 묶고 관련 없는 것과는 선이 그어져야 하며, 상술한 업무 규칙과 데이터베이스는 좋은 예시에 해당한다.
  * 이 경우, 업무 규칙은 데이터베이스 컴포넌트에 의존하지 않지만 데이터베이스 컴포넌트는 업무 규칙 없이는 존재할 수 없다.
  * 또한, **두 컴포넌트 사이에 그어진 인터페이스로 인해 세부적인 데이터베이스의 종류를 결정하는 것은 최대한 미루어질 수 있다**.
* 이러한 소프트웨어 경계선은 `변경의 축`이 있는 지점에 그어지며, 경계의 양측에 위치한 각 요소는 서로 다른 이유로 인해 서로 다른 속도로 변경될 수 있다.
  * 이 역시 일종의 SRP에 해당하며, SRP는 경계가 필요한 지점을 결정하는 데에 큰 도움을 줄 수 있다.
* 경계를 표현하기 위해서는 우선 시스템이 컴포넌트 단위로 분할될 필요가 있으며, 이후에는 분할된 컴포넌트들이 핵심 업무 컴포넌트에 의존하도록 선을 긋는다.
  * **이는 전적으로 DIP와 SAP를 응용한 것으로, 의존성 방향은 항상 저수준의 세부사항에서 고수준의 추상화를 향하도록 배치**되어야 한다.

## 2023-03-19 Sun
### 플러그인 아키텍쳐란?
```
> 소프트웨어 개발의 역사는 플러그인을 쉽게 생성하고, 확장성과 유지보수성이 높은 시스템 아키텍쳐를 확립하기 위해 발전해왔다.
> 예를 들어 핵심적인 업무 규칙은 선택적이거나 여러 형태로 구현될 수 있는 컴포넌트들로부터 반드시 분리되어, 독립적인 형태를 유지해야 한다.
```
* 예를 들어 세부사항인 데이터베이스와 UI 컴포넌트는 플러그인 아키텍쳐를 토대로 핵심 업무 규칙을 수정하지 않고 변경이 가능해야 한다.
  * 나아가 임의의 모듈에 대한 변경 사항이 다른 모듈에 영향을 주지 않아야 하며, 플러그인 아키텍쳐를 토대로 변경이 전파되지 않도록 방화벽을 확립할 수 있다.

### 경계의 횡단
```
> 런타임 시점에서 경계를 횡단하는 것은 곧 경계 한 편에서 반대 편의 코드를 호출하거나 데이터를 전달하는 것을 의미한다.
```
* 경계는 코드 변경의 전파를 막는 방화벽을 구축하고 관리하는 수단이며, 적시에 경계를 횡단할 수 있기 위해서는 코드 의존성 관리에 주의해야 한다.

### 1. 모놀리식 구조
```
> 모놀리식은 함수와 데이터가 단일 프로세서의 같은 주소 공간을 공유하며, 이 과정에서 나름의 규칙에 따라 분리되어 있는 형태를 의미한다.
> 모놀리식 아키텍쳐에서는 동적 다형성을 토대로 내부 의존성을 관리하며, 예를 들어 모든 의존성과 제어 흐름은 저수준 컴포넌트에서 고수준 컴포넌트로 향한다.
```
* 해당 구조는 컴포넌트 수준의 분리를 적용하지 않으므로, 배포 관점에서는 jar나 exe 파일 등의 커다란 단일 실행 파일을 활용한다.
  * 이렇듯 모놀리식 구조에서는 배포 관점에서 경계가 드러나지 않으나, 실제로는 충분히 유의미한 경계가 존재한다.
* 동적 다형성을 활용하면 제어 흐름과는 반대되는 방향으로 의존성을 역전시킬 수 있으며, 고수준의 클라이언트는 인터페이스를 토대로 저수준 컴포넌트를 호출한다.
  * 이 경우, 데이터 구조 역시 서비스를 호출하는 고수준 클라이언트 컴포넌트 측에 위치하게 된다.
* 모놀리식 아키텍쳐 역시 DIP를 활용하여 구조를 분리하는 것은 프로젝트의 개발 및 테스트, 그리고 배포에 도움을 줄 수 있다.
  * 예를 들어 고수준 컴포넌트는 저수준 세부사항으로부터 독립적으로 유지되므로, 개발 팀은 자신의 담당 컴포넌트에 대해 독립적으로 작업을 적용할 수 있다.

## 2023-03-20 Mon
### 2. 배포형 컴포넌트 
* 아키텍쳐의 경계가 jar 또는 dll 등 동적 링크 라이브러리와 같은 물리적인 형태로 드러나며, 이러한 컴포넌트들은 바이너리와 함께 배포 가능한 형태를 유지한다.
* 이러한 방식은 배포 과정에서의 차이만 있을 뿐, 동일한 프로세서의 주소 공간에 위치하는 등 본질적으로는 모놀리식 구조와 차이가 없다.

### 3. 로컬 프로세스
* 동일한 프로세서 또는 멀티 코어 시스템에 속한 여러 프로세서에서 실행되며, 주로 명령행 또는 이와 유사한 형태의 시스템 호출을 통해 생성된다.
  * 즉, 각각이 독립적인 주소 공간에서 실행되며 소켓 또는 메시지 큐 등을 통해 통신하게 된다.
* 해당 방식은 모놀리식 또는 동적으로 링크된 컴포넌트들로 구성될 수 있으며, 컴포넌트 간 의존성을 동적 다형성을 통해 관리하는 저수준 컴포넌트로 구성된다.
  * 때문에 해당 방식 역시 의존성 화살표는 항상 고수준 컴포넌트를 향하는 방향으로 경계를 횡단하게 된다.
  * 또한 저수준 프로세스는 고수준 프로세스의 플러그인처럼 동작하도록 만드는 것이 해당 아키텍쳐 관점의 목표이기도 하다.

### 4. 서비스
* 경계가 물리적인 형태를 띄는 가장 강력한 분류이며, 서비스는 자신의 물리적인 위치에 구애되지 않는다.
  * 때문에 서비스들은 동일한 프로세서나 멀티 코어 상에서 동작할 수도 있고, 아닐 수도 있으나 기본적으로 네트워크를 통해 통신할 것을 가정한다.
* 네트워크 통신을 사용하므로 함수 호출에 비해 느리며, 이로 인해 가능한 한 서비스 간의 통신을 줄이는 것이 바람직하다.
* 기본적으로 **서비스 역시 로컬 프로세스와 동일한 규칙을 적용받으며, 여전히 저수준 서비스는 고수준 서비스에 플러그인 되는 형식**이어야 한다.
  * 또한 고수준 서비스의 코드 상에는 임의의 저수준 서비스를 특정하는 물리적인 정보가 절대 포함되지 않아야 한다.

### 혼합된 경계선 형태
* 모놀리식 경계 형태를 제외한 대부분의 시스템은 하나 이상의 경계 전략을 사용한다.
  * 예를 들어, 일반적으로 하나의 시스템 안에서도 통신이 잦은 로컬 경계와 지연을 중요한 고려 사항으로 다루어야 하는 경계 형태가 혼합되곤 한다.

### 정책, 그리고 수준
```
> 소프트웨어 시스템은 사실상 정책을 기술한 것과 같다.
> 또한, 대부분의 시스템에서 하나의 정책은 더 작은 정책들로 분할될 수 있다.
```
* 아키텍쳐 개발 기술에는 시스템의 정책을 분리하고, 프로젝트의 변화에 따라 정책을 재편성하는 작업이 포함된다.
  * 앞서 다룬 바에 따라, 동일한 이유로 같은 시점에 변경되는 정책은 동일한 수준과 동일한 컴포넌트에 속해야 한다.
* **좋은 아키텍쳐는 컴포넌트 연결 시 의존성 방향이 각 컴포넌트의 수준을 기반으로 연결되되, 저수준 컴포넌트가 고수준 컴포넌트에 의존하도록 설계**되어야 한다.
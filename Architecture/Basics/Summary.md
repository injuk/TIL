# Architecture - summary
## 2023-03-07 Tue
### 좋은 아키텍쳐, 나쁜 아키텍쳐
```
> 좋은 아키텍쳐를 만드는 원칙은 보편적이고 불변하며, 이는 곧 소프트웨어의 핵심 역시 변하지 않음을 의미한다.
> 그러나 아키텍쳐 자체는 끝이 있는 결과물이 아닌 소프트웨어의 부드러움을 보존해나가는 탐구 과정이다.
```
* 소프트웨어 아키텍쳐의 목표는 필요한 시스템을 만들되, 유지보수에 필요한 공수를 최소화하는 데에 있다.
  * 따라서 아키텍쳐의 품질은 새로운 요구사항을 충족하기 위한 비용으로 판단할 수 있으며, 고도화 과정에 낮은 비용을 유지할 수 있는 것이 좋은 설계이다.
* 반면, 나쁜 아키텍쳐는 많은 경우에 '언제든지 재설계할 수 있다' 또는 '계속해서 생산성을 높게 유지할 수 있다' 따위의 자기 과신에서 비롯된다.

## 2023-03-08 Wed
### 소프트웨어 개발자의 책임
```
> 관리자는 구조의 중요성을 평가하지 못하는 경우가 많으므로, 개발자는 코드 작성이라는 '행위'의 긴급성보다 '아키텍쳐'의 중요성을 충분히 전달할 책임을 갖는다.
```
* 모든 소프트웨어는 요구사항을 코드로 구체화하는 `행위`와 소프트웨어의 유연성을 유지하는 `아키텍쳐` 라는 두 가지 가치를 제공한다.
  * 개발자들은 실질적인 코드를 의미하는 `행위`에 집중하기 쉬우나, 실제로는 요구사항에 쉽게 대응할 수 있도록 하는 `아키텍쳐`에 더 관심을 기울여야 한다.
  * 대부분의 경우, 이러한 오판은 한시가 급하지만 중요하지는 않은 `행위`와 / 중요하지만 급하지는 않은 `아키텍쳐`의 특성에서 기인한다.

### 세 가지 프로그래밍 패러다임과 구조적 프로그래밍
```
> 패러다임이란 곧 프로그래밍하는 방법이며, 지금까지 그래왔듯 앞으로도 구조적 / 객체 지향 / 함수형의 세 가지로 분류할 수 있다.
> 상술한 패러다임들은 각각 개발자의 goto문의 남용 / 함수 포인터 / 할당문을 박탈하는 식으로 코드의 작성을 제약하며, 결과 '무엇을 하지 말아야할지' 제시한다.  
```
* 구조적 프로그래밍을 토대로 시스템은 여러 기능적인 모듈과 컴포넌트로 분할될 수 있게 되었다.
* 구조적 프로그래밍은 시스템을 증명할 수 있는 `세부적인 기능 집합`으로 분해하고, 테스트를 통해 각 기능을 반증(=거짓을 증명)할 것을 권장한다.
  * 이러한 테스트는 시스템의 참이 아닌 거짓을 증명하는 데에 의의를 두는 반면, 많은 테스트를 통해 세부적인 기능들은 충분히 참이라고 여겨질 수 있게 된다.
* 즉, 구조적 프로그래밍은 시스템을 반증 가능한 단위로 분할할 수 있는 능력으로 인해 그 가치를 갖는다.

### 객체 지향 프로그래밍이란?
```
> 좋은 아키텍쳐의 시작은 객체 지향 설계 원칙을 이해하고, 응용하는 데에서 출발한다.
```
* 객체 지향 프로그래밍의 본질은 캡슐화나 상속이 아닌 다형성에 있으며, 이를 통해 제어 흐름을 간접적으로 전환하도록 권장한다.
* 다형성은 이를 적절히 활용한 시스템이 기능을 확장하는 과정에서 기존 코드를 수정할 필요가 없게 하는 데에 가치를 갖는다.
* 객체 지향 언어가 다형성을 지원한다는 사실은 곧 코드의 의존성을 어디서나 원하는대로 역전시킬 수 있다는 점을 시사한다.
  * 결국 객체 지향 프로그래밍을 통해 코드 의존성 수립의 절대적인 제어 권한을 개발자가 소유하며, 이는 객체 지향이 제공하는 힘이자 지향점이기도 하다.
* 개발자는 객체 지향을 통해 플러그인 아키텍쳐를 구현할 수 있으며, 이를 토대로 고수준의 모듈(=정책)을 저수준의 모듈(=세부사항)으로부터 독립시킬 수 있다.
  * 예를 들어, 저수준의 세부사항은 중요도가 낮은 플러그인 모듈로 정의하여 고수준의 정책은과 독립적으로 개발하고 배포할 수 있다.

## 2023-03-09 Thu
### 함수형 프로그래밍이란?
```
> 함수형 프로그래밍은 불변성을 보장하며, 이는 race condition 등 가변적인 변수의 성질에서 기인하는 모든 문제를 방지할 수 있도록 한다.
```
* 시스템은 변수가 변경될 수 있는 가변 컴포넌트와, 그렇지 않은 불변 컴포넌트로 구조화될 수 있다.
  * 이 경우, 불변 컴포넌트는 순수한 함수형 방식으로 작성되어 하나 이상의 가변 컴포넌트와 통신하는 식으로 동작하게 된다.
  * 좋은 설계자는 가능한 한 많은 로직을 불변 컴포넌트에 정의하는 반면, 가변 컴포넌트에서는 코드를 최대한 제거한다.
* 이벤트 소싱은 가변적인 상태를 사용하는 대신 상태의 시작점부터 모든 작업을 처리하는 트랜잭션을 저장하는 전략에 해당하며, 높은 하드웨어 자원을 필요로 한다.
  * 이 경우 애플리케이션은 CR만을 수행하므로 동시성 문제가 발생하지 않으며, 좋은 하드웨어 자원이 보장되므로 필요한 가변 상태는 적어진다.

### SOLID 원칙이란?
```
> SOLID는 깔끔한 코드를 기반으로 좋은 아키텍쳐를 정의하는 원칙이며, 여러 함수와 데이터 구조를 클래스로 배치하고 이들을 결합하는 방법을 제시한다.
```
* SOLID 원칙은 변경에 가독성이 높으면서도 재사용성과 유지보수성이 높은 소프트웨어 구조를 설계하기 위해 존재한다.
* SOLID 원칙은 코드보다는 더 높은 계층에서 적용되며, 모듈 또는 컴포넌트 등에서 사용되는 소프트웨어 구조를 정의하는 데에 도움을 준다.

### 단일 책임 원칙
```
> SRP는 단일 모듈이 변경되어야 할 이유는 반드시 하나 뿐이어야 한다는 점을 강조한다.
> SRP는 메소드와 클래스 수준의 원칙으로, SOLID의 다른 원칙에 비해 더 저수준에서 적용되어야 하는 원칙이다.
```
* SRP 관점에서 변경의 이유는 사용자 또는 이해 관계자로 구성된 하나의 집단인 `액터`로부터 기인한다.
  * 즉, **SRP는 하나의 모듈이 책임지는 것은 오직 하나의 액터만이 되어야 함을 의미**한다.
* 단일 `액터`를 책임질 코드들을 한데 모으는 힘은 응집성이므로, 서로 다른 `액터`들이 의존하는 코드는 각각 분리되어야 한다.
* **SRP를 위배하는 사례가 발견된 경우, 가장 단순하면서도 확실한 해결법은 데이터와 메소드를 분리**하는 데에 있다.

## 2023-03-10 Fri
### 개방 폐쇄 원칙
```
> 객체의 행위는 확장에 열려 있되, 객체 자체의 변경에는 폐쇄적이어야 한다.
> OCP는 소프트웨어 아키텍쳐를 공부하는 가장 근본적인 이유에 해당한다.
```
* OCP는 클래스 또는 모듈 설계 수준 뿐만이 아닌, 아키텍쳐 컴포넌트 수준에서도 큰 의미를 갖는다.
* OCP는 서로 다른 목적으로 변경되는 요소를 분리하고(SRP), 분리된 요소 사이의 의존성을 정리하는 것(DIP)으로 성취할 수 있다.
  * 이를 토대로 분리된 책임 중 하나가 수정될 때, 다른 요소는 변경되지 않는 식으로 기능 확장으로부터 비롯되는 변경량을 최소화해야 한다.
* OCP를 준수하는 아키텍쳐의 경우, 변경으로부터 보호되어야 하는 객체는 의존 대상이 되어야 한다.
  * 이 관점에서, 시스템의 가장 중요한 요소인 정책을 의미하는 컴포넌트는 다른 무엇에도 의존하지 않아야 한다.
  * 반면, 가장 중요하지 않은 문제를 처리하는 컴포넌트는 고수준의 컴포넌트로부터 전파되는 변경으로부터 거의 보호받지 못한다.
* 개발자는 요구사항에 따라 기능을 분리한 후 이들을 컴포넌트 계층 구조로 조직화하여 고수준의 컴포넌트를 보호할 수 있어야 한다.
* **OCP를 통해 시스템은 의존성 계층 구조를 갖추며, 이에 따라 변경에 대응하기 위한 높은 유연성을 갖게 된다**.

### 리스코프 치환 원칙
```
> LSP는 상속 뿐만 아니라 임의의 인터페이스와 이를 구현하는 구현체에도 적용 가능한 설계 원칙이다.
```
* 코드 상에서 두 클래스 사이의 치환 가능성을 의미하는 **LSP는 아키텍쳐 수준으로도 확장 가능**하며, 반드시 확장되어야만 한다.

## 2023-03-11 Sat
### 인터페이스 분리 원칙
```
> 일반적으로 필요한 이상으로 많은 기능을 포함하는 모듈에 의존하는 것은 나쁘며, 이는 아키텍쳐 수준에서도 마찬가지이다.
```
* 정적 타입 언어로 구성된 시스템 상에서, 여러 클래스가 단일 클래스에 의존할수록 자신과 관련 없는 메소드의 수정으로 인해 불필요한 컴파일이 발생하기 쉽다.
* 이러한 문제를 해결하는 방법은 너무 무거운 클래스에 포함되는 여러 기능을 여러 개의 인터페이스로 분할하여 ISP를 준수하는 데에 있다.
* 반면, ISP는 모든 프로그래밍 언어에 동일한 영향을 주는 원칙은 아니다.
  * 예를 들어, 동적 타입 언어의 경우 높은 유연성과 낮은 결합도를 유지하기 쉽기에 이러한 문제는 발생하지 않아 ISP로부터 일정 부분 자유로울 수 있다.

### 의존성 역전 원칙
```
> 안정적인 아키텍쳐는 변동성이 큰 세부 사항에 의존하는 대신 안정적인 추상 인터페이스를 선호한다.
> 즉, 시스템의 유연성을 극대화하고자 하는 경우 소스 코드의 의존성은 반드시 구체적인 세부 사항이 아닌 추상에 의존해야 한다.
> 의존성 규칙이란, 추상 컴포넌트와 구체 컴포넌트를 분리하는 기준으로서 의존성이 항상 더 추상적인 개념으로 향하도록 권장한다.
```
* 이상적으로, Java의 경우 import 구문을 통해 발생하는 의존성은 오로지 인터페이스 또는 추상 클래스에만 국한되어야 한다.
* 반면 구체적인 세부 사항은 곧 잠재적인 변동성을 의미하므로, 변경이 잦을 수 밖에 없는 구체적인 모듈에는 의존하지 않아야 한다.
  * 그러나 시스템은 현실적으로 많은 구체에 의존하게 되며, 예를 들어 String과 같은 충분히 안정적인 구체 클래스에는 의존성이 발생해도 무방하다.
  * 즉, **DIP는 코드 뿐만 아니라 OS 등 충분히 안정성이 보장되고 변경이 엄격하게 통제되는 환경에서는 위배되어도 무방**하다.
* 그러나 **대부분의 경우 객체를 생성하는 과정에서 해당 객체에 의존하게 되므로, 이러한 문제를 해결하기 위해 추상 팩토리의 사용이 권장**된다.
  * 이렇듯 추상 팩토리를 적절히 활용하면 시스템은 고수준의 규칙을 포함하는 추상 컴포넌트와 규칙을 다루기 위한 세부 사항인 구체 컴포넌트로 나뉘어질 수 있다.
* **DIP를 준수하는 경우, 코드 의존성은 제어 흐름과는 반대 방향으로 역전되어 설정**될 수 있다.
* 현실적으로 **DIP를 위배하지 않을 수는 없으나, 최소한 이를 위배하는 클래스를 몇몇 구체 컴포넌트에 모아 시스템의 다른 부분으로부터 격리해둘 수 있다**.
  * 예를 들어, 대부분의 시스템은 main 함수를 포함하는 구체 컴포넌트(=Main 컴포넌트)를 최소한 하나는 포함할 수 밖에 없다. 

## 2023-03-12 Sun
### 컴포넌트 원칙
```
> 컴포넌트는 시스템의 구성 요소로 배포할 수 있는 가장 작은 단위이며, 예를 들어 jar 또는 dll 등이 있다.
> SOLID 원칙이 컴포넌트를 설계하는 방법을 제시한다면, 컴포넌트 원칙은 시스템을 구성하는 컴포넌트들을 배치하는 방법을 제시한다.
```
* 잘 설계된 컴포넌트는 언제나 독립적으로 개발 가능하며, 배포 역시 가능하다.
* 또한, 컴포넌트는 런타임에 플러그인 형태로 결합할 수 있는 동적인 링크 파일을 포함한다.

### 재사용 / 릴리즈 등가 원칙
```
> 재사용 단위는 곧 릴리즈 단위와 같아야 하며, 하나의 컴포넌트로 묶인 클래스와 모듈들은 반드시 함께 릴리즈될 수 있어야 한다.
```
* **단일 컴포넌트는 응집성이 높은 클래스와 모듈들로 구성되어야 하며, 서로 공유하는 중요한 목적이 있어야 한다**.
* REP는 다른 컴포넌트 원칙들만큼 `어떤 클래스와 어떤 모듈을 단일 컴포넌트로 구성해야 하는지`를 설명하지는 못하지만, 원칙 자체는 매우 중요하다.
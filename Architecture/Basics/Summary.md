# Architecture - summary
## 2023-03-07 Tue
### 좋은 아키텍쳐, 나쁜 아키텍쳐
```
> 좋은 아키텍쳐를 만드는 원칙은 보편적이고 불변하며, 이는 곧 소프트웨어의 핵심 역시 변하지 않음을 의미한다.
> 그러나 아키텍쳐 자체는 끝이 있는 결과물이 아닌 소프트웨어의 부드러움을 보존해나가는 탐구 과정이다.
```
* 소프트웨어 아키텍쳐의 목표는 필요한 시스템을 만들되, 유지보수에 필요한 공수를 최소화하는 데에 있다.
  * 따라서 아키텍쳐의 품질은 새로운 요구사항을 충족하기 위한 비용으로 판단할 수 있으며, 고도화 과정에 낮은 비용을 유지할 수 있는 것이 좋은 설계이다.
* 반면, 나쁜 아키텍쳐는 많은 경우에 '언제든지 재설계할 수 있다' 또는 '계속해서 생산성을 높게 유지할 수 있다' 따위의 자기 과신에서 비롯된다.

## 2023-03-08 Wed
### 소프트웨어 개발자의 책임
```
> 관리자는 구조의 중요성을 평가하지 못하는 경우가 많으므로, 개발자는 코드 작성이라는 '행위'의 긴급성보다 '아키텍쳐'의 중요성을 충분히 전달할 책임을 갖는다.
```
* 모든 소프트웨어는 요구사항을 코드로 구체화하는 `행위`와 소프트웨어의 유연성을 유지하는 `아키텍쳐` 라는 두 가지 가치를 제공한다.
  * 개발자들은 실질적인 코드를 의미하는 `행위`에 집중하기 쉬우나, 실제로는 요구사항에 쉽게 대응할 수 있도록 하는 `아키텍쳐`에 더 관심을 기울여야 한다.
  * 대부분의 경우, 이러한 오판은 한시가 급하지만 중요하지는 않은 `행위`와 / 중요하지만 급하지는 않은 `아키텍쳐`의 특성에서 기인한다.

### 세 가지 프로그래밍 패러다임과 구조적 프로그래밍
```
> 패러다임이란 곧 프로그래밍하는 방법이며, 지금까지 그래왔듯 앞으로도 구조적 / 객체 지향 / 함수형의 세 가지로 분류할 수 있다.
> 상술한 패러다임들은 각각 개발자의 goto문의 남용 / 함수 포인터 / 할당문을 박탈하는 식으로 코드의 작성을 제약하며, 결과 '무엇을 하지 말아야할지' 제시한다.  
```
* 구조적 프로그래밍을 토대로 시스템은 여러 기능적인 모듈과 컴포넌트로 분할될 수 있게 되었다.
* 구조적 프로그래밍은 시스템을 증명할 수 있는 `세부적인 기능 집합`으로 분해하고, 테스트를 통해 각 기능을 반증(=거짓을 증명)할 것을 권장한다.
  * 이러한 테스트는 시스템의 참이 아닌 거짓을 증명하는 데에 의의를 두는 반면, 많은 테스트를 통해 세부적인 기능들은 충분히 참이라고 여겨질 수 있게 된다.
* 즉, 구조적 프로그래밍은 시스템을 반증 가능한 단위로 분할할 수 있는 능력으로 인해 그 가치를 갖는다.
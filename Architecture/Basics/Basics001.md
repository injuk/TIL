# Architecture
## 2022-01-18 Tue

* 좋은 소프트웨어 아키텍쳐를 만드는 원칙은 보편적이고, 불변하다.
* 아키텍쳐는 시간 / 비용 / 노력과 같은 척도와 같은 기준에 의해 좋고 나쁨이 결정될 수 있다.
* 어떻게 미래의 변경 사항에 지금 대비할 것인가?
  * 변경 자체를 묵살하고 제거할 것인가?
  * 가능한 모든 기능 확장에 의한 변경 사항에 대비할 것인가?
* 깔끔한 길
  1. 소프트웨어가 지닌 부드러움을 인지한다.
  2. 이러한 부드러움을 시스템에서 최우선으로 보존하는 것을 목표로 한다.
  3. 우리의 행동은 불완전한 지식에 기초한다는 것을 인정한다.
* **아키텍쳐는 설계의 종착지가 아닌 여정이며, 결과는 고정된 산출물이 아니라 계속된 탐구**여야만 한다.

### 설계와 아키텍쳐
* 일반적으로 설계와 아키텍쳐는 다음과 같이 구분된다.
  1. 설계: 저수준의 세부사항
  2. 아키텍쳐: 고수준의 구조
* 그러나 두 요소 모두 소프트웨어 전체 설계의 구성요소로서, 둘을 구분짓는 경계가 뚜렷하지 않다.
  * 실재하는 것은 고수준에서 저수준으로의 연속된 의사결정이다. 
  * 이러한 점에서 **설계와 아키텍쳐는 차이가 없다**고 볼 수 있다.
* 그렇다면 좋은 의사결정, 즉 소프트웨어 아키텍쳐의 목표란 무엇일까?
```
소프트웨어 아키텍쳐의 목표는 필요한 시스템을 만들고, 
유지보수하는데 투입되는 인력을 최소화하는 데에 있다.
```
* **설계의 품질을 나타내는 척도는 고객의 요구사항을 충족하는 비용을 재는 척도와 다름이 없다**.
  * 비용이 낮고, 시스템의 수명이 다할 때까지 낮은 비용을 유지할 수 있다면 좋은 설계이다.
  * 반대로 새로운 기능, 유지보수 건마다 비용이 증가한다면 나쁜 설계이다.
* 잘못의 원인
  1. 개발자는 제품 출시를 코드 개선보다 우선하곤 한다.
  2. 개발자는 지저분한 코드가 단기간의 생산성이 더 높다고 보곤 한다.
  3. 개발자는 프로젝트의 초기부터 계속해서 자신이 생산성을 유지할 수 있다고 믿곤 한다.
  4. 개발자는 때로 전체 시스템을 재설계하는 것이 해답이라고 믿곤 한다.
  * 그러나 엉망인 코드는 항상 잘 설계된 코드보다 생산성이 낮다.
  * 자신을 과신하는 개발자는 코드를 재설계하더라도 원래의 프로젝트의 문제점을 개선하지 못한다.
* 때문에 개발 조직은 언제나 자신들의 과신을 인지하여 방지하고, 소프트웨어 아키텍쳐의 품질을 고민해야 한다.

### 두 가지 가치
* 모든 소프트웨어 시스템은 서로 다른 두 가지 가치를 제공한다.
  1. 행위: 요구사항을 구체화하고, 코드를 작성하거나 디버깅을 하는 것
  2. 구조: 아키텍쳐이며, 언제든지 변경이 가능하도록 소프트웨어를 '부드럽게' 하는 것
* 개발자는 두 가치 모두 높은 품질을 유지해야 하는 책임이 있다.
  * 그러나 대부분의 개발자는 '행위'가 자신이 맡은 일의 전부라고 생각하며 '구조'에는 집중하지 않는 경향이 있다.
* 소프트웨어의 '부드러움'이란?
  * 기계의 행위를 쉽게 변경할 수 있는 특징을 말한다.
  * 부드러운 소프트웨어는 변경이 쉬우므로, 요구사항의 추가 또는 변경에 빠르게 대처가 가능하다.
* 지금 당장 동작하는 소프트웨어와 추후에 있을 변경 사항에 유연하게 대처하는 소프트웨어 중 어떤 것이 더 가치 있을까?
  * 각각의 가치는 행위와 구조를 대변한다.
    * 행위는 긴급하지만, 항상 중요하지는 않다.
    * 반면 구조는 중요하지만, 즉각적인 긴급성을 띄지 않는다.
* 여러 가치들 사이에서 아키텍쳐가 후순위를 갖게 되는 경우, 시스템에는 다음과 같은 문제점이 발생한다.
  1. 시스템을 개발하는 비용이 더 많이 든다.
  2. 시스템의 변경이 현실적으로 불가능해진다.
* 아쉽게도 관리자는 보통 아키텍쳐의 중요성을 평가할 수 없는 경우가 많다.
  * 때문에 개발자는 기능의 **긴급성보다 아키텍쳐의 중요성을 설득해야할 책임**이 있다.
  * 자신의 팀의 가치를 우선시하는 다른 팀과의 논쟁에 스스로 뛰어들어 소프트웨어 개발팀의 가치를 지키는 것 또한 개발자의 역할이자 책무이다.

### 패러다임
* 패러다임이란 프로그래밍을 하는 방법이다.
* 패러다임은 임의의 프로그래밍 언어에 독립적이다.
* 패러다임은 언제 어떤 프로그래밍 구조를 사용할지 결정한다.
* 패러다임은 크게 다음의 세 가지로 나눌 수 있다.
  1. 구조적 프로그래밍
  2. 객체 지향 프로그래밍
  3. 함수형 프로그래밍
```
> 구조적 프로그래밍은 제어 흐름의 직접적인 전환에 대해 규칙을 부과한다.

> 객체 지향 프로그래밍은 제어 흐름의 간접적인 전환에 대해 규칙을 부과한다.

> 함수형 프로그래밍은 할당문에 대해 규칙을 부과한다.
```
* 각 패러다임은 개발자의 어떤 권한을 박탈한다. 어떤 패러다임도 새로운 권한을 부여하지 않는다.
  * 예를 들어, 구조적 프로그래밍은 무분별한 goto의 남용을 박탈한다.
  * 객체 지향 프로그래밍은 함수 포인터를 박탈한다.
  * 함수형 프로그래밍은 할당문을 박탈한다.
  * 이렇듯 **패러다임은 무엇을 해야 할지 보다 무엇을 하지 말아야 할지를 말**해준다.
* 앞으로도 프로그래밍 패러다임은 이 세가지가 전부일 것이다.
  * 각 패러다임이 우리에게서 가져간 것 이외에도 더 이상은 가져갈, 즉 권한을 박탈할 것이 없다.
* **세가지 패러다임과 아키텍쳐의 세가지 관심사인 함수, 컴포넌트 분리, 데이터 관리는 밀접한 연관**이 있다.

### 구조적 프로그래밍
* 구조적 프로그래밍을 통해 모듈을 증명 가능한 더 작은 단위로, 재귀적으로 분해할 수 있게 되었다.
  * 이는 모듈을 기능적으로 분해할 수 있다는 말과 같다.
* 구조적 프로그래밍을 기반으로 한 구조적 분석, 설계 기법을 통해 대규모 시스템을 모듈과 컴포넌트로 나눌 수 있게 되어었다.
  * 나아가 모듈과 컴포넌트는 다시 증명 가능한 아주 작은 기능들로 세분화할 수 있다.
* 다익스트라에 따르면, 테스트는 버그가 있음을 보여줄 뿐, 버그가 없음을 보장할 수 없다.
  * 우리는 테스트를 통해 프로그램의 잘못을 입증할 수 있지만, 프로그램이 맞다고 증명할 수 없다.
* 구조적 프로그래밍은 **프로그램을 증명 가능한 세부 기능 집합으로 재귀적으로 분해할 것을 강요**한다.
  * 이후 **테스트를 통해 증명 가능한 세부 기능들이 거짓인지 증명하려고 시도**한다.
  * 거짓임을 증명하는 테스트에 실패한다면 세부 기능들은 목표에 부합할만큼 충분히 참이라고 여길 수 있게 된다.
* 구조적 프로그래밍이 가치 있는 이유는 **반증 가능한 단위를 만들어낼 수 있는 능력** 때문이다.
  * 또한 아키텍쳐 관점에서도 기능적 분해를 최고의 실천법 중 하나로 여긴다.
* 가장 작은 기능에서부터 큰 컴포넌트까지, 모든 수준의 소프트웨어는 과학과 같고 반증 가능성에 의해 주도된다.
  * 소프트웨어 아키텍트는 모든 수준의 소프트웨어를 쉽게 반증(=테스트)할 수 있도록 만들기 위해 노력해야 한다.

### 객체 지향 프로그래밍
* 좋은 아키텍쳐를 만드는 일은 객체 지향 설계 원칙을 이해하고 응용하는데에서 출발한다.
* 객체 지향 프로그래밍의 본질은 무엇일까?
  1. 캡슐화? 
      * 많은 객체 지향 언어들은 캡슐화를 약화시켜 왔고, 캡슐화를 거의 강제하지 않는다.
  2. 상속? 
      * 상속이란 단순히 변수와 함수를 하나의 유효한 범위로 묶어 재정의하는 일에 불과하다. 
      * 비록 C와 같은 언어에서의 눈속임(과 같은 방식)을 이용한 상속은 가능했으나, 이를 편하게 만들었다는 점에서 객체 지향적인 기능으로 볼 수는 있다.
      * 그러나 여전히 객체 지향 프로그래밍의 본질이라고 생각하기에는 아쉬운 점이 있다.
  3. 다형성?
      * 다형성의 근간은 함수 포인터이다. 프로그래머는 다형적인 행위를 구현하기 위해 함수 포인터를 사용해 왔다.
      * 그러나 함수 포인터는 위험하다. 함수 포인터를 사용하기 위해 지켜야 할 관례를 따르지 못한 데에서 기인하는 버그는 해결하기가 매우 어렵다.
      * 객체 지향은 이러한 관례를 없애주며, 프로그래머가 실수할 수 있는 가능성을 없애준다.
      * 이는 즉 **객체 지향은 제어 흐름을 간접적으로 전환하는 규칙을 부과**한다고 볼 수 있다.
* 다형성은 왜 좋은가?
  * 플러그인 아키텍쳐와 같이, 다형성이 적용된 프로그램은 확장에 대해 기존 코드를 수정할 필요가 없다.
  * 플러그인 아키텍쳐: 입출력 장치 독립성을 지원하기 위해 고안된 개념으로, 입출력 장치를 사용하는 프로그램이 입출력 드라이버에 의존하지 않게 한다.
      * 이는 거의 모든 OS에서 구현되었지만, 객체 지향 이전에는 함수 포인터의 위험성 때문에 대다수의 프로그래머들이 플러그인 아키텍쳐를 잘 적용하지 못했다.
      * 그러나 객체 지향의 등장으로 언제 어디서든 플러그인 아키텍쳐를 적용할 수 있게 되었다.
* 다형성을 쉽게 사용할 수 없었던 시절의 소프트웨어
  * 전형적인 방식의 호출 트리는 main 함수 > 고수준 함수 > 중간 수준 함수 > 저수준 함수 와 같은 형태로 흐른다.
      * 이러한 호출 트리에서, 소스 코드 의존성은 제어 흐름과 같다. 
      * main 함수는 고수준 함수에 의존하고, 중간 수준 함수는 저수준 함수에 의존한다.
* 다형성을 쉽게 사용할 수 있는 현재의 소프트웨어
  * 인터페이스를 예로 들어, 소스 코드상에서는 고수준의 모듈이 인터페이스의 함수를 호출한다.
  * 그러나 런타임에서 인터페이스는 실재하지 않으며, 실제로는 고수준의 모듈이 중수준의 모듈(인터페이스를 구현한)이 갖는 함수를 호출한다.
      * 이 때, 제어 흐름은 고수준 모듈 > 인터페이스 > 중수준 모듈이다.
      * 그러나 코드 의존성은 고수준 모듈 > 인터페이스 < 중수준 모듈이다. 
      * 이렇듯 **코드 의존성과 제어 흐름이 반대인 시점이 존재**한다!
* 의존성 역전: 제어 흐름과 소스 코드 의존성이 반대인 상황을 말한다.
  * **객체 지향 언어가 다형성을 제공한다는 사실은 소스 코드 의존성을 언제 어디서든 역전시킬 수 있다는 점을 의미**한다.
  * **객체 지향 언어에서는 소프트웨어 아키텍트가 원하는 방향으로 소스 코드 의존성을 설정**할 수 있게 된다.
      * 소스 코드 의존성이 더 이상 제어 흐름과 일치되는 방향을 가져야만 하는 제한을 갖지 않는다.
  * 이러한 점은 객체 지향이 지향하는 점이며, 객체 지향이 아키텍트에게 제공하는 힘이기도 하다.
      * 이러한 힘을 통해 컴포넌트들이 개별적이고 독립적으로 배포 가능한 '배포 독립성'을 가질 수 있게 설계할 수 있다.
      * '배포 독립성'이 있는 경우, 각 모듈은 별개의 팀에서 개발이 가능하다. 이는 '개발 독립성'으로 대표된다.
* 결국 객체 지향 프로그래밍은 다형성을 이용하여 전체 시스템의 모든 소스 코드 의존성에 대한 절대적인 제어 권한을 획득할 수 있는 능력이다.
* 아키텍트는 객체 지향 프로그래밍을 통해 플러그인 아키텍쳐를 구성할 수 있다. 
  * 또한 이를 통해 고수준의 정책을 포함하는 모듈은 저수준의 세부사항을 포함하는 모듈에 대해 독립성을 보장할 수 있다.
  * 저수준의 세부사항은 중요도가 낮은 플러그인 모듈로 만들 수 있고, 고수준의 정책을 포함하는 모듈과 독립적으로 개발하고 배포할 수 있다.

## 2022-01-19 Wed
### 함수형 프로그래밍
* 함수형 언어에서의 변수는 한 번 초기화된 후로는 값이 변경되지 않는다. 즉, 불변적이다.
* 아키텍쳐에서 불변성은 왜 중요한가?
  * race condition, deadlock 등 동시성 애플리케이션에서 마주할 수 있는 모든 문제는 가변적인 변수의 성질에서 기인하기 때문이다.
* 불변성은 정말 실현 가능한가?
  * 저장 공간이 무한하고 프로세서의 속도가 무한히 빠를 때 가능하다.
  * 그렇지 않다면, 불변성을 실현하기 위해 '가변성의 분리'와 같은 일종의 타협이 필요하다.
* 가변성의 분리
  * 애플리케이션을 제대로 구조화하려면 변수를 변경하는 가변 컴포넌트와 변경하지 않는 불변 컴포넌트로 분리한다.
      * 불변 컴포넌트는 순수한 함수형 방식으로 작업하고, 어떠한 가변 변수도 사용하지 않는다.
      * 불변 컴포넌트는 하나 이상의 다른 가변 컴포넌트(순수 함수형 컴포넌트가 아닌 컴포넌트)와 통신한다.
  * 이러한 컴포넌트의 분리는 반드시 가변 변수를 보호하기 위한 적절한 수단이 뒷받침되어야 한다.
  * **현명한 아키텍트는 가능한 한 많은 처리를 불변 컴포넌트로 옮기고, 가변 컴포넌트에서는 가능한 많은 코드를 제거**해야 한다.
* 이벤트 소싱
  * 더 많은 메모리를 확보하고, 머신이 더 빨라질수록 필요한 가변 상태는 더 적어진다.
  * 이벤트 소싱은 가변적인 상태가 아닌 트랜잭션을 저장하는 전략이다. 
      * 상태가 필요하면 단순히 상태의 시작점부터 모든 트랜잭션을 처리한다.
  * 이벤트 소싱을 활용할 경우, 데이터 저장소에서 삭제되거나 변경되는 점이 없다.
      * 애플리케이션은 CRUD가 아닌 CR만을 수행한다.
      * 수정과 삭제 작업이 없으므로, 동시성 문제 또한 발생하지 않는다.
  * 이렇듯 저장 공간과 처리 능력이 충분하다는 전제 하에 완전한 함수형 애플리케이션을 만들 수 있다.

### 결론
```
> 구조적 프로그래밍은 제어 흐름의 직접적인 전환에 부과되는 규율이다.

> 객체 지향 프로그래밍은 제어 흐름의 간접적인 전환에 부과되는 규율이다.

> 함수형 프로그래밍은 변수 할당에 부과되는 규율이다.
```
* 세 방식은 모두 개발자에게서 무언가를 빼앗아가며, 우리의 코드 작성 방식의 형태를 한정시켰다.
  * 어떠한 패러다임도 우리의 권한이나 능력에 무언가를 더해주지 않는다.
  * 대신 우리가 **지난 반세기 동안 배운 것은 '해서는 안되는 것'**에 대해서이다.
* 소프트웨어는 급격히 발전하는 기술이 아니다. 
  * 도구는 달라지고 하드웨어는 향상되었지만, **소프트웨어의 핵심은 달라지지 않는다**.
  * 소프트웨어는 여전히 순차, 분기, 반복, 참조로 구성된다.

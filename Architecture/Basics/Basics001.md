# Architecture
## 2022-01-18 Tue

* 좋은 소프트웨어 아키텍쳐를 만드는 원칙은 보편적이고, 불변하다.
* 아키텍쳐는 시간 / 비용 / 노력과 같은 척도와 같은 기준에 의해 좋고 나쁨이 결정될 수 있다.
* 어떻게 미래의 변경 사항에 지금 대비할 것인가?
  * 변경 자체를 묵살하고 제거할 것인가?
  * 가능한 모든 기능 확장에 의한 변경 사항에 대비할 것인가?
* 깔끔한 길
  1. 소프트웨어가 지닌 부드러움을 인지한다.
  2. 이러한 부드러움을 시스템에서 최우선으로 보존하는 것을 목표로 한다.
  3. 우리의 행동은 불완전한 지식에 기초한다는 것을 인정한다.
* **아키텍쳐는 설계의 종착지가 아닌 여정이며, 결과는 고정된 산출물이 아니라 계속된 탐구**여야만 한다.

### 설계와 아키텍쳐
* 일반적으로 설계와 아키텍쳐는 다음과 같이 구분된다.
  1. 설계: 저수준의 세부사항
  2. 아키텍쳐: 고수준의 구조
* 그러나 두 요소 모두 소프트웨어 전체 설계의 구성요소로서, 둘을 구분짓는 경계가 뚜렷하지 않다.
  * 실재하는 것은 고수준에서 저수준으로의 연속된 의사결정이다. 
  * 이러한 점에서 **설계와 아키텍쳐는 차이가 없다**고 볼 수 있다.
* 그렇다면 좋은 의사결정, 즉 소프트웨어 아키텍쳐의 목표란 무엇일까?
```
소프트웨어 아키텍쳐의 목표는 필요한 시스템을 만들고, 
유지보수하는데 투입되는 인력을 최소화하는 데에 있다.
```
* **설계의 품질을 나타내는 척도는 고객의 요구사항을 충족하는 비용을 재는 척도와 다름이 없다**.
  * 비용이 낮고, 시스템의 수명이 다할 때까지 낮은 비용을 유지할 수 있다면 좋은 설계이다.
  * 반대로 새로운 기능, 유지보수 건마다 비용이 증가한다면 나쁜 설계이다.
* 잘못의 원인
  1. 개발자는 제품 출시를 코드 개선보다 우선하곤 한다.
  2. 개발자는 지저분한 코드가 단기간의 생산성이 더 높다고 보곤 한다.
  3. 개발자는 프로젝트의 초기부터 계속해서 자신이 생산성을 유지할 수 있다고 믿곤 한다.
  4. 개발자는 때로 전체 시스템을 재설계하는 것이 해답이라고 믿곤 한다.
  * 그러나 엉망인 코드는 항상 잘 설계된 코드보다 생산성이 낮다.
  * 자신을 과신하는 개발자는 코드를 재설계하더라도 원래의 프로젝트의 문제점을 개선하지 못한다.
* 때문에 개발 조직은 언제나 자신들의 과신을 인지하여 방지하고, 소프트웨어 아키텍쳐의 품질을 고민해야 한다.

### 두 가지 가치
* 모든 소프트웨어 시스템은 서로 다른 두 가지 가치를 제공한다.
  1. 행위: 요구사항을 구체화하고, 코드를 작성하거나 디버깅을 하는 것
  2. 구조: 아키텍쳐이며, 언제든지 변경이 가능하도록 소프트웨어를 '부드럽게' 하는 것
* 개발자는 두 가치 모두 높은 품질을 유지해야 하는 책임이 있다.
  * 그러나 대부분의 개발자는 '행위'가 자신이 맡은 일의 전부라고 생각하며 '구조'에는 집중하지 않는 경향이 있다.
* 소프트웨어의 '부드러움'이란?
  * 기계의 행위를 쉽게 변경할 수 있는 특징을 말한다.
  * 부드러운 소프트웨어는 변경이 쉬우므로, 요구사항의 추가 또는 변경에 빠르게 대처가 가능하다.
* 지금 당장 동작하는 소프트웨어와 추후에 있을 변경 사항에 유연하게 대처하는 소프트웨어 중 어떤 것이 더 가치 있을까?
  * 각각의 가치는 행위와 구조를 대변한다.
    * 행위는 긴급하지만, 항상 중요하지는 않다.
    * 반면 구조는 중요하지만, 즉각적인 긴급성을 띄지 않는다.
* 여러 가치들 사이에서 아키텍쳐가 후순위를 갖게 되는 경우, 시스템에는 다음과 같은 문제점이 발생한다.
  1. 시스템을 개발하는 비용이 더 많이 든다.
  2. 시스템의 변경이 현실적으로 불가능해진다.
* 아쉽게도 관리자는 보통 아키텍쳐의 중요성을 평가할 수 없는 경우가 많다.
  * 때문에 개발자는 기능의 **긴급성보다 아키텍쳐의 중요성을 설득해야할 책임**이 있다.
  * 자신의 팀의 가치를 우선시하는 다른 팀과의 논쟁에 스스로 뛰어들어 소프트웨어 개발팀의 가치를 지키는 것 또한 개발자의 역할이자 책무이다.

### 패러다임
* 패러다임이란 프로그래밍을 하는 방법이다.
* 패러다임은 임의의 프로그래밍 언어에 독립적이다.
* 패러다임은 언제 어떤 프로그래밍 구조를 사용할지 결정한다.
* 패러다임은 크게 다음의 세 가지로 나눌 수 있다.
  1. 구조적 프로그래밍
  2. 객체 지향 프로그래밍
  3. 함수형 프로그래밍
```
> 구조적 프로그래밍은 제어 흐름의 직접적인 전환에 대해 규칙을 부과한다.

> 객체 지향 프로그래밍은 제어 흐름의 간접적인 전환에 대해 규칙을 부과한다.

> 함수형 프로그래밍은 할당문에 대해 규칙을 부과한다.
```
* 각 패러다임은 개발자의 어떤 권한을 박탈한다. 어떤 패러다임도 새로운 권한을 부여하지 않는다.
  * 예를 들어, 구조적 프로그래밍은 무분별한 goto의 남용을 박탈한다.
  * 객체 지향 프로그래밍은 함수 포인터를 박탈한다.
  * 함수형 프로그래밍은 할당문을 박탈한다.
  * 이렇듯 **패러다임은 무엇을 해야 할지 보다 무엇을 하지 말아야 할지를 말**해준다.
* 앞으로도 프로그래밍 패러다임은 이 세가지가 전부일 것이다.
  * 각 패러다임이 우리에게서 가져간 것 이외에도 더 이상은 가져갈, 즉 권한을 박탈할 것이 없다.
* **세가지 패러다임과 아키텍쳐의 세가지 관심사인 함수, 컴포넌트 분리, 데이터 관리는 밀접한 연관**이 있다.

### 구조적 프로그래밍
* 구조적 프로그래밍을 통해 모듈을 증명 가능한 더 작은 단위로, 재귀적으로 분해할 수 있게 되었다.
  * 이는 모듈을 기능적으로 분해할 수 있다는 말과 같다.
* 구조적 프로그래밍을 기반으로 한 구조적 분석, 설계 기법을 통해 대규모 시스템을 모듈과 컴포넌트로 나눌 수 있게 되어었다.
  * 나아가 모듈과 컴포넌트는 다시 증명 가능한 아주 작은 기능들로 세분화할 수 있다.
* 다익스트라에 따르면, 테스트는 버그가 있음을 보여줄 뿐, 버그가 없음을 보장할 수 없다.
  * 우리는 테스트를 통해 프로그램의 잘못을 입증할 수 있지만, 프로그램이 맞다고 증명할 수 없다.
* 구조적 프로그래밍은 **프로그램을 증명 가능한 세부 기능 집합으로 재귀적으로 분해할 것을 강요**한다.
  * 이후 **테스트를 통해 증명 가능한 세부 기능들이 거짓인지 증명하려고 시도**한다.
  * 거짓임을 증명하는 테스트에 실패한다면 세부 기능들은 목표에 부합할만큼 충분히 참이라고 여길 수 있게 된다.
* 구조적 프로그래밍이 가치 있는 이유는 **반증 가능한 단위를 만들어낼 수 있는 능력** 때문이다.
  * 또한 아키텍쳐 관점에서도 기능적 분해를 최고의 실천법 중 하나로 여긴다.
* 가장 작은 기능에서부터 큰 컴포넌트까지, 모든 수준의 소프트웨어는 과학과 같고 반증 가능성에 의해 주도된다.
  * 소프트웨어 아키텍트는 모든 수준의 소프트웨어를 쉽게 반증(=테스트)할 수 있도록 만들기 위해 노력해야 한다.

### 객체 지향 프로그래밍
* 좋은 아키텍쳐를 만드는 일은 객체 지향 설계 원칙을 이해하고 응용하는데에서 출발한다.
* 객체 지향 프로그래밍은 다형성을 이용하여 전체 시스템의 모든 소스 코드 의존성에 대한 절대적인 제어 권한을 획득할 수 있는 능력이다.
* 아키텍트는 객체 지향 프로그래밍을 통해 플러그인 아키텍쳐를 구성할 수 있다. 
  * 또한 이를 통해 고수준의 정책을 포함하는 모듈은 저수준의 세부 사항을 포함하는 모듈에 대해 독립성을 보장할 수 있다.
  * 저수준의 세부 사항은 중요도가 낮은 플러그인 모듈로 만들 수 있고, 고수준의 정책을 포함하는 모듈과 독립적으로 개발하고 배포할 수 있다.
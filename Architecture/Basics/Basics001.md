# Architecture
## 2022-01-18 Tue

* 좋은 소프트웨어 아키텍쳐를 만드는 원칙은 보편적이고, 불변하다.
* 아키텍쳐는 시간 / 비용 / 노력과 같은 척도와 같은 기준에 의해 좋고 나쁨이 결정될 수 있다.
* 어떻게 미래의 변경 사항에 지금 대비할 것인가?
  * 변경 자체를 묵살하고 제거할 것인가?
  * 가능한 모든 기능 확장에 의한 변경 사항에 대비할 것인가?
* 깔끔한 길
  1. 소프트웨어가 지닌 부드러움을 인지한다.
  2. 이러한 부드러움을 시스템에서 최우선으로 보존하는 것을 목표로 한다.
  3. 우리의 행동은 불완전한 지식에 기초한다는 것을 인정한다.
* **아키텍쳐는 설계의 종착지가 아닌 여정이며, 결과는 고정된 산출물이 아니라 계속된 탐구**여야만 한다.

### 설계와 아키텍쳐
* 일반적으로 설계와 아키텍쳐는 다음과 같이 구분된다.
  1. 설계: 저수준의 세부사항
  2. 아키텍쳐: 고수준의 구조
* 그러나 두 요소 모두 소프트웨어 전체 설계의 구성요소로서, 둘을 구분짓는 경계가 뚜렷하지 않다.
  * 실재하는 것은 고수준에서 저수준으로의 연속된 의사결정이다. 
  * 이러한 점에서 **설계와 아키텍쳐는 차이가 없다**고 볼 수 있다.
* 그렇다면 좋은 의사결정, 즉 소프트웨어 아키텍쳐의 목표란 무엇일까?
```
소프트웨어 아키텍쳐의 목표는 필요한 시스템을 만들고, 
유지보수하는데 투입되는 인력을 최소화하는 데에 있다.
```
* **설계의 품질을 나타내는 척도는 고객의 요구사항을 충족하는 비용을 재는 척도와 다름이 없다**.
  * 비용이 낮고, 시스템의 수명이 다할 때까지 낮은 비용을 유지할 수 있다면 좋은 설계이다.
  * 반대로 새로운 기능, 유지보수 건마다 비용이 증가한다면 나쁜 설계이다.
* 잘못의 원인
  1. 개발자는 제품 출시를 코드 개선보다 우선하곤 한다.
  2. 개발자는 지저분한 코드가 단기간의 생산성이 더 높다고 보곤 한다.
  3. 개발자는 프로젝트의 초기부터 계속해서 자신이 생산성을 유지할 수 있다고 믿곤 한다.
  4. 개발자는 때로 전체 시스템을 재설계하는 것이 해답이라고 믿곤 한다.
  * 그러나 엉망인 코드는 항상 잘 설계된 코드보다 생산성이 낮다.
  * 자신을 과신하는 개발자는 코드를 재설계하더라도 원래의 프로젝트의 문제점을 개선하지 못한다.
* 때문에 개발 조직은 언제나 자신들의 과신을 인지하여 방지하고, 소프트웨어 아키텍쳐의 품질을 고민해야 한다.

### 두 가지 가치
* 모든 소프트웨어 시스템은 서로 다른 두 가지 가치를 제공한다.
  1. 행위: 요구사항을 구체화하고, 코드를 작성하거나 디버깅을 하는 것
  2. 구조: 아키텍쳐이며, 언제든지 변경이 가능하도록 소프트웨어를 '부드럽게' 하는 것
* 개발자는 두 가치 모두 높은 품질을 유지해야 하는 책임이 있다.
  * 그러나 대부분의 개발자는 '행위'가 자신이 맡은 일의 전부라고 생각하며 '구조'에는 집중하지 않는 경향이 있다.
* 소프트웨어의 '부드러움'이란?
  * 기계의 행위를 쉽게 변경할 수 있는 특징을 말한다.
  * 부드러운 소프트웨어는 변경이 쉬우므로, 요구사항의 추가 또는 변경에 빠르게 대처가 가능하다.
* 지금 당장 동작하는 소프트웨어와 추후에 있을 변경 사항에 유연하게 대처하는 소프트웨어 중 어떤 것이 더 가치 있을까?
  * 각각의 가치는 행위와 구조를 대변한다.
    * 행위는 긴급하지만, 항상 중요하지는 않다.
    * 반면 구조는 중요하지만, 즉각적인 긴급성을 띄지 않는다.
* 여러 가치들 사이에서 아키텍쳐가 후순위를 갖게 되는 경우, 시스템에는 다음과 같은 문제점이 발생한다.
  1. 시스템을 개발하는 비용이 더 많이 든다.
  2. 시스템의 변경이 현실적으로 불가능해진다.
* 아쉽게도 관리자는 보통 아키텍쳐의 중요성을 평가할 수 없는 경우가 많다.
  * 때문에 개발자는 기능의 **긴급성보다 아키텍쳐의 중요성을 설득해야할 책임**이 있다.
  * 자신의 팀의 가치를 우선시하는 다른 팀과의 논쟁에 스스로 뛰어들어 소프트웨어 개발팀의 가치를 지키는 것 또한 개발자의 역할이자 책무이다.

### 패러다임
* 패러다임이란 프로그래밍을 하는 방법이다.
* 패러다임은 임의의 프로그래밍 언어에 독립적이다.
* 패러다임은 언제 어떤 프로그래밍 구조를 사용할지 결정한다.
* 패러다임은 크게 다음의 세 가지로 나눌 수 있다.
  1. 구조적 프로그래밍
  2. 객체 지향 프로그래밍
  3. 함수형 프로그래밍
```
> 구조적 프로그래밍은 제어 흐름의 직접적인 전환에 대해 규칙을 부과한다.

> 객체 지향 프로그래밍은 제어 흐름의 간접적인 전환에 대해 규칙을 부과한다.

> 함수형 프로그래밍은 할당문에 대해 규칙을 부과한다.
```
* 각 패러다임은 개발자의 어떤 권한을 박탈한다. 어떤 패러다임도 새로운 권한을 부여하지 않는다.
  * 예를 들어, 구조적 프로그래밍은 무분별한 goto의 남용을 박탈한다.
  * 객체 지향 프로그래밍은 함수 포인터를 박탈한다.
  * 함수형 프로그래밍은 할당문을 박탈한다.
  * 이렇듯 **패러다임은 무엇을 해야 할지 보다 무엇을 하지 말아야 할지를 말**해준다.
* 앞으로도 프로그래밍 패러다임은 이 세가지가 전부일 것이다.
  * 각 패러다임이 우리에게서 가져간 것 이외에도 더 이상은 가져갈, 즉 권한을 박탈할 것이 없다.
* **세가지 패러다임과 아키텍쳐의 세가지 관심사인 함수, 컴포넌트 분리, 데이터 관리는 밀접한 연관**이 있다.
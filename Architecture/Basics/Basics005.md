# Architecture
## 2022-01-22 Sat

### 경계선
* 아키텍쳐는 소프트웨어 요소를 분리하는 경계선을 긋는 기술이다.
* 경계선에 의해 분리된 요소는 서로 분리되어 경계선 너머의 요소에 대해 알 수 없어야 한다.
* 아키텍트의 목표는 필요한 시스템을 만들고 유지하는 데 드는 인적 자원을 최소화하는 것이다.
  * 이 때, 인적 자원의 **효율을 떨어트리는 것은 너무 이른 결정에 따른 결합**이다.
  * 이른 결정이란, 시스템의 요구사항이나 유즈케이스와 아무런 관련이 없는 결정이다.
    * 대표적으로 프레임워크, 데이터베이스, 웹 서버, 등이 포함된다.
* 좋은 아키텍쳐는 이러한 결정이 부수적이고, 결정을 연기할 수 있는 아키텍쳐이다.
  * 즉, 좋은 시스템 아키텍쳐는 이러한 결정 사항에 전혀 의존하지 않고 최후의 순간에 결정을 내릴 수 있도록 한다.
  * 나아가 최후의 순간에 내려진 결정에 따른 영향도 크지 않게 만들어 준다.
* 경계선을 긋는 행위는 결정을 늦추고 연기하는 데에 큰 도움이 되고, 좋은 아키텍쳐에는 필수적이다.

### 선긋기
* 관련이 있는 것과 없는 것 사이에 선을 긋는다.
* 예를 들어, 업무 규칙과 데이터베이스는 관련이 없으므로 선을 그어야 한다.
  * 데이터베이스는 업무 규칙이 간접적으로 사용하는 도구에 불과하다.
  * 업무 규칙이 알아야하는 것은 **데이터를 가져오고 저장하기 위해 사용할 수 있는 함수 집합인 인터페이스가 있다는 사실이 전부**이다.
  * 이러한 함수 집합을 활용하여 우리는 인터페이스 뒤에 데이터베이스를 숨기고, 업무 규칙이 알 수 없도록 할 수 있다.
  * 업무 규칙은 함수 집합인 인터페이스를 활용하여 데이터에 접근하고, 실제 데이터베이스에 접근하기 위한 클래스는 해당 인터페이스를 구현한다.
  * 이 때, 경계선은 상속 관계를 횡단하며 클래스와 인터페이스 사이에 그어진다.
  * 업무 규칙 컴포넌트는 데이터베이스 컴포넌트와 얽힌 문제가 없지만, 데이터베이스 컴포넌트는 업무 규칙 컴포넌트 없이는 존재할 수 없다.
* 업무 규칙과 데이터베이스, 두 컴포넌트 사이에 그어진 경계선에 의해 업무 규칙 컴포넌트는 어떤 종류의 데이터베이스도 사용할 수 있게 된다.
  * 데이터베이스 컴포넌트는 다양한 구현체로 교체될 수 있게 되었다. 이에 업무 규칙 컴포넌트는 전혀 신경쓰지 않아도 된다!
  * 이는 곧 데이터베이스에 대한 결정을 연기할 수 있음을 의미하며, 데이터베이스를 결정하기에 앞서 업무 규칙을 먼저 작성하고 테스트에 집중할 수 있음을 의미한다.
* 경계선은 '변경의 축'이 있는 지점에 그어진다.
  * **경계의 한 쪽에 위치한 컴포넌트는 경계의 반대편에 위치한 컴포넌트와는 다른 속도로, 다른 이유에 의해 변경**된다.
  * 이 역시 **순전히 단일 책임 원칙에 해당**한다. 단일 책임 원칙은 어디에 경계가 필요한지를 명확하게 전달해준다.
* 아키텍쳐에서 경계선을 그리려면, 우선 시스템을 컴포넌트 단위로 분할해야 한다.
  * 일부 컴포넌트는 핵심 업무 규칙일 것이며, 나머지 컴포넌트는 플러그인의 형태를 띄어 핵심 업무 규칙과 직접적인 연관이 없지만 필수 기능을 포함하게 된다.
  * 이후 컴포넌트 사이의 화살표가 핵심 업무를 향하도록 컴포넌트를 배치한다.
  * **이는 전적으로 의존성 역전 원칙과 안정된 추상화 원칙을 응용한 것에 해당**한다.
    * **의존성 화살표는 항상 저수준 세부사항에서 고수준의 추상화를 향하도록 배치**되어야 한다.

### 플러그인 아키텍쳐
* 소프트웨어 개발 기술의 역사는 플러그인을 손쉽게 생성하고, 확장 가능하고 유지보수가 쉬운 시스템 아키텍쳐를 확립할 수 있도록 만드는 방법이다.
* 선택적이거나 **다양한 형태로 구현될 수 있는 컴포넌트들로부터 핵심적인 업무 규칙 컴포넌트는 분리되어 있고, 독립적이어야 한다**.
* 상술한 예시에서, 데이터베이스는 플러그인 형태로 고려되었기에 어떠한 형태의 데이터베이스도 적용할 수 있다. 또한, 필요시 대체할 수도 있다.
  * 마찬가지로 UI 컴포넌트 역시 플러그인 아키텍쳐를 구현함으로써 웹 기반, 클라이언트 - 서버 기반, SOA나 콘솔 기반 등 어떠한 인터페이스 기술도 적용할 수 있을 것이다.
* UI 또는 데이터베이스 컴포넌트 교체 작업이 사소하지 않더라도, 경계선을 통한 플러그인 아키텍쳐의 확립은 이러한 변경 작업을 현실성 있게 만든다.
* 우리는 시스템에서 한 부분이 변경되더라도, 관련 없는 나머지 부분이 망가지기를 원하지 않는다.
  * 즉, 특정 모듈이 나머지 모듈에 영향받지 않아야 한다.
  * 시스템을 플러그인 아키텍쳐로 배치하면 변경 사항이 전파될 수 없는 가상의 방화벽을 만들 수 있다.
  * 상술한 예시에서, 데이터베이스는 업무 규칙에 플러그인 형태로 연결되었으므로 절대 업무 규칙에 영향을 줄 수 없다.

## 경계의 형태
* **런타임에서 경계를 횡단하는 것은 경계 한쪽의 기능에서 반대편 기능을 호출하고 데이터를 전달하는 것**이다.
* 적절한 위치에서 경계를 횡단하는 비결은 소스 코드 의존성 관리에 있다.
* 경계는 소스 코드의 변경이 전파되는 것을 막는 방화벽을 구축하고 관리하는 수단으로 존재한다.

### 형태 1. 단일체
* 함수와 데이터가 단일 프로세서에서 같은 주소 공간을 공유하며, 나름의 규칙에 따라 분리되어 있는 형태이다.
* 결합 분리 모드 관점에서는 소스 수준 분리 모드이며, **배포 관점에서는 모놀리틱(단일체)라고 불리우는 단일 실행 파일**이다.
  * 단일 싱행 파일: jar, exe 파일, 등
* 배포 관점에서 단일체는 컴포넌트 수준으로 분리되지 않으므로 개별 컴포넌트 배포 대신 커다란 하나의 실행 파일을 배포하게 된다.
  * 즉, **배포 관점에서 단일체는 그 경계가 드러나지 않는다**.
* 그러나 **단일체에서도 드러나지 않을 뿐, 실제로는 유의미한 경계가 존재**한다.
* 단일체 아키텍쳐는 동적 다형성에 의존하여 내부 의존성을 관리한다.
  1. 저수준 클라이언트 > 고수준 서비스로의 함수 호출
    * 런타임 의존성과 컴파일타임 의존성, 제어 흐름은 모두 저수준 컴포넌트에서 고수준 컴포넌트로 향한다.
    * 경계에서 호출되는 쪽인 고수준 서비스 쪽에 데이터 정의가 위치하게 된다.
  2. 고수준 클라이언트 > 저수준 서비스로의 함수 호출
    * 동적 다형성을 활용하여 제어흐름과 반대 방향으로 의존성을 역전시킬 수 있다.
    * 고수준 클라이언트는 Service 인터페이스를 통해 저수준의 ServiceImpl 클래스의 메소드를 호출한다.
    * 이러한 형태는 경계를 횡단할 때 의존성이 저수준에서 고수준 컴포넌트를 향하게 한다.
    * 데이터 구조 역시 서비스를 호출하는, 고수준 클라이언트 측에 위치하게 된다.
* **단일체 구조 또한 상술한 방식으로 구조를 분리하는 것은 프로젝트의 개발, 테스트, 배포에 큰 도움**을 준다.
  * 개발 팀은 자신이 담당하는 컴포넌트를 독립적으로 작업할 수 있다.
  * 고수준 컴포넌트는 저수준 세부사항으로부터 독립적으로 유지된다.
* 이러한 시스템에서 컴포넌트는 소스 코드 형태로 전달된다.

### 형태 2. 배포형 컴포넌트
* 아키텍쳐의 경계가 물리적으로 드러나는 형태이다.
  * jar, dll, 등 동적 링크 라이브러리가 그 예시가 된다.
* 이러한 형태로 배포된 컴포넌트는 바이너리와 같이 배포 가능한 형태로 전달되며, 이는 배포 수준 결합 분리 모드에 해당한다.
* 이러한 **배포 과정에서만 차이가 있을 뿐, 본질적으로 단일체와 동일**하다.
  * 모든 함수가 동일한 프로세서와 주소 공간에 위치하고, 컴포넌트의 분리와 의존성 관리 전략도 단일체와 동일하다.

### 형태 3. 로컬 프로세스
* 주로 명령행이나 그와 유사한 형태의 시스템 호출을 통해 생성된다.
* 동일한 프로세서 또는 멀티 코어 시스템에 속한 여러 프로세서에서 실행된다.
* 각각이 독립적인 주소 공간에서 실행된다. 일반적으로는 메모리 보호를 위해 프로세스들이 메모리를 공유하지 못한다.
  * 로컬 프로세스 간 통신은 소켓이나 메시지 큐 등 운영체제 차원에서 제공되는 기능을 활용한다.
* 로컬 프로세스는 단일체이거나 동적으로 링크된 여러 컴포넌트로 구성될 수 있다.
* 로컬 프로세스는 컴포넌트 간 의존성을 동적 다형성을 통해 관리하는 저수준 컴포넌트로 구성된다.
* **로컬 프로세스 간 분리 전략은 단일체나 배포형 컴포넌트의 경우와 동일**하다.
  * 소스 코드 의존성 화살표는 항상 고수준 컴포넌트를 향하는 방향으로 경계를 횡단한다.
  * 때문에 고수준 프로세스의 소스 코드가 저수준 프로세스의 이름, 물리 주소 등을 포함해서는 안된다.
  * **저수준 프로세스는 고수준 프로세스의 플러그인이 되도록 만드는 것이 아키텍쳐 관점의 목표**에 해당한다.

### 형태 4. 서비스
* 물리적인 형태를 띄는 가장 강력한 경계이다.
* **서비스는 자신의 물리적 위치에 구애받지 않는다**.
  * 서비스들은 동일한 프로세서나 멀티코어에서 동작할 수도 있고, 아닐 수도 있다.
  * 그러나 서비스들은 모든 통신이 네트워크를 통해 이뤄질 것을 가정한다.
* **서비스 경계를 지나는 통신은 함수 호출에 비해 매우 느리다**.
  * 따라서 주의를 기울이고, 가능하다면 빈번하게 통신하는 일을 피해야 한다.
  * 서비스 수준의 통신에서는 지연에 따른 문제를 고수준에서 처리할 수 있어야 한다.
* 기본적으로 로컬 프로세스에 적용된 규칙은 서비스에도 동일하게 적용된다.
  * **저수준 서비스는 고수준 서비스에 플러그인되어야 한다**.
  * **고수준 서비스의 소스 코드에는 저수준 서비스를 특정 짓는, URL과 같은 물리적인 정보가 절대로 포함되서는 안된다**.

### 경계선의 형태 혼합
* 단일체를 제외한 대다수의 시스템은 한 가지 이상의 경계 전략을 사용한다.
  * 예를 들어, 서비스 경계를 활용하는 시스템은 실제로는 일련의 로컬 프로세스 파사드인 경우가 많다.
  * 또한 개별 서비스 또는 로컬 프로세스는 대부분 소스 코드 컴포넌트로 구성된 단일체이거나, 동적으로 링크된 배포형 컴포넌트의 집합이다.
* 대체로 **한 시스템 안에서도 통신이 빈번한 로컬 경계와, 지연을 중요하게 고려해야 하는 경계가 혼합**된다.

## 2022-01-23 Sun
## 정책과 수준
* 소프트웨어 시스템은 정책을 기술한 것이다.
* 대다수의 **시스템에서 하나의 정책은 더 작은 정책들로 쪼갤 수 있다**.
* 아키텍쳐를 개발하는 기술에는 이러한 정책을 분리하고, 변경 양상에 따라 정책을 재편성하는 일도 포함된다.
  * 동일한 이유로 동일한 시점에 변경되는 정책은 동일한 수준에 위치하며, 동일한 컴포넌트에 속해야 한다.
  * 서로 다른 이유로 다른 시점에 변경되는 정책들은 서로 다른 수준에 위치하며, 다른 컴포넌트로 분리되어야 한다.
* **좋은 아키텍쳐는 컴포넌트를 연결할 때 의존성의 방향이 컴포넌트 수준을 기반으로 연결**되어야 한다.
  * 이 때, 저수준 컴포넌트가 고수준 컴포넌트에 의존하도록 설계되어야 한다.

### 수준이란?
* 수준(level)이란 입력과 출력까지의 거리이다.
  * **입력과 출력 모두로부터 멀리에 위치할수록 정책의 수준은 높아**진다.
  * **입력과 출력을 다루는 정책은 시스템에서 가장 낮은 수준**에 위치한다.
* **시스템에서 데이터의 흐름과 소스 코드 의존성은 항상 같은 방향을 가리켜야하는 것이 아니다**.
  * 소프트웨어 아키텍쳐의 예술 중 하나이다.
  * 소스 코드 의존성은 그 '수준'에 따라 결합되어야 하며, **데이터 흐름을 기준으로 결합되지 말아야** 한다.
* **정책을 컴포넌트로 묶는 기준은 정책이 변경되는 방식과 관련**이 있다.
  * SRP와 CCP에 따르면, 동일한 시점에 변경되는 정책은 함께 묶여야 한다.
  * 입출력으로부터 멀리 떨어진 고수준 정책은 저수준 정책에 의해 덜 변경되고, 훨씬 중요한 이유에서 변경되곤 한다.
  * 저수준의 정책 변경은 더 빈번하고, 긴급하며, 덜 중요한 이유로 변경되곤 한다.
* 모든 **소스 코드 의존성이 고수준 정책을 향하는 방향을 갖도록 정책을 분리했다면 변경의 영향은 최소화**된다.
  * 시스템의 최저 수준에서 중요하지 않지만 긴급한 변경이 발생하더라도 상대적으로 고수준인 정책에 미치는 영향은 거의 없어진다.
  * 이러한 사실은 앞서 다루었듯, 저수준 컴포넌트가 고수준 컴포넌트에 플러그인 되어야 한다는 관점과도 부합한다.

## 업무 규칙
* 업무 규칙은 **사업적으로 수익을 얻거나, 비용을 줄일 수 있는 규칙 또는 절차**를 말한다.
  * 업무 규칙은 소프트웨어로 구현되어 있는지와 관계 없이, 사업적인 수익 또는 비용 절감과 관련된 일이라면 수동 작업도 포함한다.
* 예를 들어, 은행이 대출에 대해 N%의 이자를 부여하는 것은 은행이 돈을 버는 방식이므로, 업무 규칙에 해당한다.
  * 이러한 이자 계산은 소프트웨어적으로 구현되든, 계산기를 직접 두드리든 관계 없이 업무 규칙이다.
* 핵심 업무 규칙이란, 다음의 특징을 갖는 규칙을 말한다.
  1. **사업 자체에 핵심적이고**, 
  2. **규칙을 자동화하는 시스템이 없더라도 업무 규칙이 그대로 존재**하는 경우
* 핵심 업무 규칙은 일반적으로 데이터를 요구한다. 이러한 데이터를 **핵심 업무 데이터**라고 부를 수 있다.
  * 핵심 업무 데이터 역시 시스템 자동화와 관계 없이 존재한다.
* **핵심 업무 규칙과 핵심 업무 데이터는 본질적으로 결합되어 있으므로, 객체로 만들기에 좋은 후보가 된다**.
  * 이러한 유형의 객체는 **엔티티**라고 부를 수 있다.

### 엔티티
* 엔티티는 시스템 내부의 객체를 가리키는 용어이다.
* **엔티티는 핵심 업무 데이터를 기반으로 동작하는 핵심 업무 규칙을 구체화**한다.
  * 엔티티는 핵심 업무 데이터를 스스로 포함하거나, 핵심 업무 데이터에 쉽게 접근할 수 있다.
  * **엔티티의 인터페이스는 핵심 업무 데이터를 기반으로 동작하는 핵심 업무 규칙을 구현한 함수들로 구성**된다.
* **엔티티는 업무의 대표자이며, 순전히 업무에 대한 것**이다.
  * 엔티티는 독립적으로 존재하며, **데이터베이스, UI, 프레임워크 등 세부사항으로 인해 절대 오염되지 않아야** 한다.
  * 엔티티는 **어떠한 시스템에서도 업무를 수행할 수 있고, 시스템의 표현 방식이나 저장 방식과도 무관**해야 한다.
* 엔티티의 요구조건은 핵심 업무 데이터와 핵심 업무 규칙을 하나로 묶은 별도의 소프트웨어 모듈이기만 하면 된다는 사실이다.
  * 즉, 반드시 객체 지향 언어의 클래스일 필요는 없다.

### 유즈케이스
* 모든 업무 규칙이 엔티티처럼 순수하지 않으며, **어떤 규칙은 자동화된 시스템의 요소로 존재해야만 의미가 있다**.
  * 이러한 업무 규칙을 유즈케이스라고 부를 수 있다.
* 유즈케이스는 다음과 같은 내용을 포함하며 **자동화된 시스템이 사용되는 방법을 설명**한다.
  1. 사용자가 제공해야하는 입력,
  2. 사용자에게 보여줄 출력,
  3. 사용자에세 보여줄 출력을 생성하기 위한 처리 단계의 기술
* **핵심 업무 규칙과는 달리 유즈케이스는 애플리케이션에 특화된 업무 규칙을 설명**한다.
* **유즈케이스는 엔티티 내부에 위치한 핵심 업무 규칙을 어떻게, 언제 호출할지 명시하는 규칙을 포함**한다.
  * 즉, 유즈케이스는 엔티티의 제어 방법을 명시한다.
* **유즈케이스는 UI를 기술하지 않으며, 시스템이 사용자에게 어떻게 보여야하는지 설명하지 않는다**.
  * 즉, **유즈케이스는 사용자와 엔티티 사이의 상호작용을 규정**한다.
* 유즈케이스는 객체이며, 객체로서 다음을 제공한다.
  1. 애플리케이션에 특화된 업무 규칙을 구현하는 하나 이상의 함수
  2. 입력 데이터, 출력 데이터, 유즈케이스가 상호작용하는 엔티티에 대한 참조 데이터 등의 데이터

### 엔티티와 유즈케이스
* 엔티티는 유즈케이스에 의해 제어되지만, 유즈케이스에 대해 아무것도 알지 못해야 한다.
  * 엔티티의 독립성: **엔티티는 고수준의 개념이므로 유즈케이스와 같은 저수준 개념에 대해 알 필요가 없다**.
  * 유즈케이스의 의존성: 반면 저수준 개념인 유즈케이스는 고수준 개념인 엔티티에 대한 정보를 알고 있어야 한다.
* **엔티티는 다양한 애플리케이션에서 사용될 수 있도록 일반화된 내용**이므로, 시스템의 입력과 출력에서 멀리 떨어져 있으므로 고수준의 개념이다.
* 유즈케이스는 단일 애플리케이션에 특화된 개념이며, **시스템의 입력과 출력에 보다 가깝게 위치하므로 엔티티보다 저수준의 개념**이다.

### 요청 / 응답 모델
* 유즈케이스는 입력에 대한 출력을 생성하지만, **데이터를 사용자나 또 다른 컴포넌트와 주고 받는 방식에 대해 의존적이지 않아야** 한다.
* 유즈케이스가 사용하는 요청 / 응답 데이터 구조는 어떤 것에도 의존하지 않아야 한다.
  * 심지어 HttpRequest / HttpResponse와 같은 표준 프레임워크 인터페이스로부터 파생되지 않는다. 웹에 대해서도 알 필요가 없다.
  * 웹 뿐만 아니라, 나아가 어떠한 UI에도 종속되지 않는다.
* 요청 / 응답 **모델이 독립적이지 않다면, 이에 의존하는 유즈케이스도 모델이 갖는 의존성에 간접적으로 결합**되게 된다.
* 엔티티와 요청 / 응답 데이터 모델은 많은 데이터를 공유할 확률이 높다.
  * **그렇다고 해서 엔티티의 참조를 요청 / 응답 데이터 모델에 포함하는 것은 잘못된 접근**이다!
  * **두 객체의 목적은 완전히 다르며, 시간이 지나면 두 객체는 완전히 다른 이유에서, 다른 시점에 변경될 것**이다.
    * 때문에 두 객체를 하나로 묶는 행위는 SRP와 CCP를 위배하게 된다.

### 요약
* 업무 규칙은 소프트웨어 시스템이 존재하는 이유이며, 핵심적인 기능이다.
* 업무 규칙은 수익을 내고 비용을 줄이는 코드를 갖는다.
* 업무 규칙은 UI나 DB와 같은 저수준의 세부사항에 의해 오염되어서는 안되며, 항상 그 모습 그대로 남아 있어야 한다.
* **업무 규칙을 표현하는 코드는 시스템의 심장부에 위치**하는 것이 이상적이며, **덜 중요한 코드는 심장부에 플러그인**되어야 한다.
* **업무 규칙은 시스템에서 가장 독립적이고, 가장 많이 재사용될 수 있는 코드여야** 한다.

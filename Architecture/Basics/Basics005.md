# Architecture
## 2022-01-22 Sat

### 경계선
* 아키텍쳐는 소프트웨어 요소를 분리하는 경계선을 긋는 기술이다.
* 경계선에 의해 분리된 요소는 서로 분리되어 경계선 너머의 요소에 대해 알 수 없어야 한다.
* 아키텍트의 목표는 필요한 시스템을 만들고 유지하는 데 드는 인적 자원을 최소화하는 것이다.
  * 이 때, 인적 자원의 **효율을 떨어트리는 것은 너무 이른 결정에 따른 결합**이다.
  * 이른 결정이란, 시스템의 요구사항이나 유즈케이스와 아무런 관련이 없는 결정이다.
    * 대표적으로 프레임워크, 데이터베이스, 웹 서버, 등이 포함된다.
* 좋은 아키텍쳐는 이러한 결정이 부수적이고, 결정을 연기할 수 있는 아키텍쳐이다.
  * 즉, 좋은 시스템 아키텍쳐는 이러한 결정 사항에 전혀 의존하지 않고 최후의 순간에 결정을 내릴 수 있도록 한다.
  * 나아가 최후의 순간에 내려진 결정에 따른 영향도 크지 않게 만들어 준다.
* 경계선을 긋는 행위는 결정을 늦추고 연기하는 데에 큰 도움이 되고, 좋은 아키텍쳐에는 필수적이다.

### 선긋기
* 관련이 있는 것과 없는 것 사이에 선을 긋는다.
* 예를 들어, 업무 규칙과 데이터베이스는 관련이 없으므로 선을 그어야 한다.
  * 데이터베이스는 업무 규칙이 간접적으로 사용하는 도구에 불과하다.
  * 업무 규칙이 알아야하는 것은 **데이터를 가져오고 저장하기 위해 사용할 수 있는 함수 집합인 인터페이스가 있다는 사실이 전부**이다.
  * 이러한 함수 집합을 활용하여 우리는 인터페이스 뒤에 데이터베이스를 숨기고, 업무 규칙이 알 수 없도록 할 수 있다.
  * 업무 규칙은 함수 집합인 인터페이스를 활용하여 데이터에 접근하고, 실제 데이터베이스에 접근하기 위한 클래스는 해당 인터페이스를 구현한다.
  * 이 때, 경계선은 상속 관계를 횡단하며 클래스와 인터페이스 사이에 그어진다.
  * 업무 규칙 컴포넌트는 데이터베이스 컴포넌트와 얽힌 문제가 없지만, 데이터베이스 컴포넌트는 업무 규칙 컴포넌트 없이는 존재할 수 없다.
* 업무 규칙과 데이터베이스, 두 컴포넌트 사이에 그어진 경계선에 의해 업무 규칙 컴포넌트는 어떤 종류의 데이터베이스도 사용할 수 있게 된다.
  * 데이터베이스 컴포넌트는 다양한 구현체로 교체될 수 있게 되었다. 이에 업무 규칙 컴포넌트는 전혀 신경쓰지 않아도 된다!
  * 이는 곧 데이터베이스에 대한 결정을 연기할 수 있음을 의미하며, 데이터베이스를 결정하기에 앞서 업무 규칙을 먼저 작성하고 테스트에 집중할 수 있음을 의미한다.
* 경계선은 '변경의 축'이 있는 지점에 그어진다.
  * **경계의 한 쪽에 위치한 컴포넌트는 경계의 반대편에 위치한 컴포넌트와는 다른 속도로, 다른 이유에 의해 변경**된다.
  * 이 역시 **순전히 단일 책임 원칙에 해당**한다. 단일 책임 원칙은 어디에 경계가 필요한지를 명확하게 전달해준다.
* 아키텍쳐에서 경계선을 그리려면, 우선 시스템을 컴포넌트 단위로 분할해야 한다.
  * 일부 컴포넌트는 핵심 업무 규칙일 것이며, 나머지 컴포넌트는 플러그인의 형태를 띄어 핵심 업무 규칙과 직접적인 연관이 없지만 필수 기능을 포함하게 된다.
  * 이후 컴포넌트 사이의 화살표가 핵심 업무를 향하도록 컴포넌트를 배치한다.
  * **이는 전적으로 의존성 역전 원칙과 안정된 추상화 원칙을 응용한 것에 해당**한다.
    * **의존성 화살표는 항상 저수준 세부사항에서 고수준의 추상화를 향하도록 배치**되어야 한다.

### 플러그인 아키텍쳐
* 소프트웨어 개발 기술의 역사는 플러그인을 손쉽게 생성하고, 확장 가능하고 유지보수가 쉬운 시스템 아키텍쳐를 확립할 수 있도록 만드는 방법이다.
* 선택적이거나 **다양한 형태로 구현될 수 있는 컴포넌트들로부터 핵심적인 업무 규칙 컴포넌트는 분리되어 있고, 독립적이어야 한다**.
* 상술한 예시에서, 데이터베이스는 플러그인 형태로 고려되었기에 어떠한 형태의 데이터베이스도 적용할 수 있다. 또한, 필요시 대체할 수도 있다.
  * 마찬가지로 UI 컴포넌트 역시 플러그인 아키텍쳐를 구현함으로써 웹 기반, 클라이언트 - 서버 기반, SOA나 콘솔 기반 등 어떠한 인터페이스 기술도 적용할 수 있을 것이다.
* UI 또는 데이터베이스 컴포넌트 교체 작업이 사소하지 않더라도, 경계선을 통한 플러그인 아키텍쳐의 확립은 이러한 변경 작업을 현실성 있게 만든다.
* 우리는 시스템에서 한 부분이 변경되더라도, 관련 없는 나머지 부분이 망가지기를 원하지 않는다.
  * 즉, 특정 모듈이 나머지 모듈에 영향받지 않아야 한다.
  * 시스템을 플러그인 아키텍쳐로 배치하면 변경 사항이 전파될 수 없는 가상의 방화벽을 만들 수 있다.
  * 상술한 예시에서, 데이터베이스는 업무 규칙에 플러그인 형태로 연결되었으므로 절대 업무 규칙에 영향을 줄 수 없다.

## 경계의 형태
* **런타임에서 경계를 횡단하는 것은 경계 한쪽의 기능에서 반대편 기능을 호출하고 데이터를 전달하는 것**이다.
* 적절한 위치에서 경계를 횡단하는 비결은 소스 코드 의존성 관리에 있다.
* 경계는 소스 코드의 변경이 전파되는 것을 막는 방화벽을 구축하고 관리하는 수단으로 존재한다.

### 형태 1. 단일체
* 함수와 데이터가 단일 프로세서에서 같은 주소 공간을 공유하며, 나름의 규칙에 따라 분리되어 있는 형태이다.
* 결합 분리 모드 관점에서는 소스 수준 분리 모드이며, **배포 관점에서는 모놀리틱(단일체)라고 불리우는 단일 실행 파일**이다.
  * 단일 싱행 파일: jar, exe 파일, 등
* 배포 관점에서 단일체는 컴포넌트 수준으로 분리되지 않으므로 개별 컴포넌트 배포 대신 커다란 하나의 실행 파일을 배포하게 된다.
  * 즉, **배포 관점에서 단일체는 그 경계가 드러나지 않는다**.
* 그러나 **단일체에서도 드러나지 않을 뿐, 실제로는 유의미한 경계가 존재**한다.
* 단일체 아키텍쳐는 동적 다형성에 의존하여 내부 의존성을 관리한다.
  1. 저수준 클라이언트 > 고수준 서비스로의 함수 호출
    * 런타임 의존성과 컴파일타임 의존성, 제어 흐름은 모두 저수준 컴포넌트에서 고수준 컴포넌트로 향한다.
    * 경계에서 호출되는 쪽인 고수준 서비스 쪽에 데이터 정의가 위치하게 된다.
  2. 고수준 클라이언트 > 저수준 서비스로의 함수 호출
    * 동적 다형성을 활용하여 제어흐름과 반대 방향으로 의존성을 역전시킬 수 있다.
    * 고수준 클라이언트는 Service 인터페이스를 통해 저수준의 ServiceImpl 클래스의 메소드를 호출한다.
    * 이러한 형태는 경계를 횡단할 때 의존성이 저수준에서 고수준 컴포넌트를 향하게 한다.
    * 데이터 구조 역시 서비스를 호출하는, 고수준 클라이언트 측에 위치하게 된다.
* **단일체 구조 또한 상술한 방식으로 구조를 분리하는 것은 프로젝트의 개발, 테스트, 배포에 큰 도움**을 준다.
  * 개발 팀은 자신이 담당하는 컴포넌트를 독립적으로 작업할 수 있다.
  * 고수준 컴포넌트는 저수준 세부사항으로부터 독립적으로 유지된다.
* 이러한 시스템에서 컴포넌트는 소스 코드 형태로 전달된다.

### 형태 2. 배포형 컴포넌트
* 아키텍쳐의 경계가 물리적으로 드러나는 형태이다.
  * jar, dll, 등 동적 링크 라이브러리가 그 예시가 된다.
* 이러한 형태로 배포된 컴포넌트는 바이너리와 같이 배포 가능한 형태로 전달되며, 이는 배포 수준 결합 분리 모드에 해당한다.
* 이러한 **배포 과정에서만 차이가 있을 뿐, 본질적으로 단일체와 동일**하다.
  * 모든 함수가 동일한 프로세서와 주소 공간에 위치하고, 컴포넌트의 분리와 의존성 관리 전략도 단일체와 동일하다.

### 형태 3. 로컬 프로세스
* 주로 명령행이나 그와 유사한 형태의 시스템 호출을 통해 생성된다.
* 동일한 프로세서 또는 멀티 코어 시스템에 속한 여러 프로세서에서 실행된다.
* 각각이 독립적인 주소 공간에서 실행된다. 일반적으로는 메모리 보호를 위해 프로세스들이 메모리를 공유하지 못한다.
  * 로컬 프로세스 간 통신은 소켓이나 메시지 큐 등 운영체제 차원에서 제공되는 기능을 활용한다.
* 로컬 프로세스는 단일체이거나 동적으로 링크된 여러 컴포넌트로 구성될 수 있다.
* 로컬 프로세스는 컴포넌트 간 의존성을 동적 다형성을 통해 관리하는 저수준 컴포넌트로 구성된다.
* **로컬 프로세스 간 분리 전략은 단일체나 배포형 컴포넌트의 경우와 동일**하다.
  * 소스 코드 의존성 화살표는 항상 고수준 컴포넌트를 향하는 방향으로 경계를 횡단한다.
  * 때문에 고수준 프로세스의 소스 코드가 저수준 프로세스의 이름, 물리 주소 등을 포함해서는 안된다.
  * **저수준 프로세스는 고수준 프로세스의 플러그인이 되도록 만드는 것이 아키텍쳐 관점의 목표**에 해당한다.

### 형태 4. 서비스
* 물리적인 형태를 띄는 가장 강력한 경계이다.
* **서비스는 자신의 물리적 위치에 구애받지 않는다**.
  * 서비스들은 동일한 프로세서나 멀티코어에서 동작할 수도 있고, 아닐 수도 있다.
  * 그러나 서비스들은 모든 통신이 네트워크를 통해 이뤄질 것을 가정한다.
* **서비스 경계를 지나는 통신은 함수 호출에 비해 매우 느리다**.
  * 따라서 주의를 기울이고, 가능하다면 빈번하게 통신하는 일을 피해야 한다.
  * 서비스 수준의 통신에서는 지연에 따른 문제를 고수준에서 처리할 수 있어야 한다.
* 기본적으로 로컬 프로세스에 적용된 규칙은 서비스에도 동일하게 적용된다.
  * **저수준 서비스는 고수준 서비스에 플러그인되어야 한다**.
  * **고수준 서비스의 소스 코드에는 저수준 서비스를 특정 짓는, URL과 같은 물리적인 정보가 절대로 포함되서는 안된다**.

### 결론
* 단일체를 제외한 대다수의 시스템은 한 가지 이상의 경계 전략을 사용한다.
  * 예를 들어, 서비스 경계를 활용하는 시스템은 실제로는 일련의 로컬 프로세스 파사드인 경우가 많다.
  * 또한 개별 서비스 또는 로컬 프로세스는 대부분 소스 코드 컴포넌트로 구성된 단일체이거나, 동적으로 링크된 배포형 컴포넌트의 집합이다.
* 대체로 **한 시스템 안에서도 통신이 빈번한 로컬 경계와, 지연을 중요하게 고려해야 하는 경계가 혼합**된다.

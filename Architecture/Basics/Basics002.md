# Architecture
## 2022-01-19 Wed

## SOLID 원칙
* SOLID: 깔끔한 코드로 좋은 아키텍쳐를 정의하는 원칙이다.
  * SOLID는 함수와 데이터 구조를 클래스로 배치하는 방법과,
  * 클래스들을 서로 결합하는 방법을 설명한다.
  * 여기서 클래스는 단순한 함수와 데이터의 집합을 말하며, 객체 지향의 클래스만 지칭하는 개념이 아니다.
* SOLID 원칙의 목적은 다음과 같다:
  1. 중간 수준의 소프트웨어 구조가 변경에 유연해지고,
  2. 이해가 쉽고,
  3. 많은 소프트웨어 시스템에 사용할 수 있는 컴포넌트의 기반이 되도록 한다.
* SOLID 원칙은 코드 수준보다는 상위에서 적용되며, 모듈과 컴포넌트 내부에서 사용되는 소프트웨어 구조의 정의에 도움을 준다.

### SRP - 단일 책임 원칙
* SOLID 중 의미가 잘 전달되지 않은 원칙이다.
* 오해: 단일 책임 원칙은 모든 모듈이 하나의 일만 해야한다는 원칙이다.
  * 실제로는 함수는 반드시 하나의 일만 해야한다는 원칙이다.
  * 해당 원칙은 SOLID 원칙이 적용되는 수준보다 저수준에서 적용되어야 하는 원칙이다.
* 사실: 단일 책임 원칙은 '**단일 모듈은 변경의 이유가 오직 하나 뿐이어야 한다**'로 기술된다.
* 변경의 이유란?
  * SRP에서 변경의 이유는 사용자와 이해 관계자이다.
    * 일반적으로 사용자, 이해 관계자는 집단이다. 
  * 따라서 변경의 이유란 시스템이 동일한 방향으로 변경되길 바라는 하나의 집단(액터)을 말한다.
* 변경의 이유의 의미를 토대로, 단일 책임 원칙은 다음과 같이 풀어쓸 수 있다.
```
하나의 모듈은 오직 하나의 액터에 대해서만 책임져야 한다.
```
* 하나의 모듈이란, 소스 파일 또는 함수와 데이터 구조로 구성된 '**응집된 집합**'이다.
* **단일 액터를 책임지는 코드들을 하나로 묶어주는 힘은 응집성**이다.
* 단일 책임 원칙은 다음과 같이 말한다.
  * **서로 다른 액터가 의존하는 코드를 너무 가까이 배치해서는 안되며, 서로 분리**되어야 한다.
* 단일 책임 원칙을 위배하여 서로 다른 액터를 책임지는 메소드들이 하나의 파일에 포함된 경우, 머지 충돌이 자주 발생할 가능성이 있다.
  * 충돌은 그 자체로도 위험하며, 어떤 도구도 충돌을 원천 차단할 수 없다.
* 단일 책임 원칙을 위배하는 사례에서, 가장 **확실한 해결책은 데이터와 메소드를 분리**하는 것이다.
  * 여러 액터가 공유하는 데이터는 Data 클래스로 만들고, 이를 사용하는 소스 코드를 별도의 클래스의 메소드로 작성한다.
  * 액터 별 클래스의 인스턴스화와 추적이 어려워진다면, 요청을 받아 요청을 해결할 책임이 있는 메소드를 호출하여 위임하는 **파사드 패턴**을 적용해볼 수 있다.
* 단일 책임 원칙은 메소드와 클래스 수준의 원칙이다.
  * 이러한 원칙은 이보다 상위 수준인 컴포넌트 수준에서는 공통 폐쇄 원칙, 아키텍쳐 수준에서는 변경의 축이라는 원칙으로 나타난다.

### OCP - 개방 폐쇄 원칙
```
소프트웨어 개체(artifact)는 확장에는 열려 있어야 하고, 변경에는 닫혀 있어야 한다.
```
* 즉, 소프트웨어 개체의 **행위는 확장 가능해야 하지만, 이 때 개체를 변경해서는 안됨**을 의미한다.
* 이는 소프트웨어 아키텍쳐를 공부하는 가장 근본적인 이유이다!
  * 요구사항을 살짝 확장하는 데에 엄청난 수정이 필요한 경우를 미연에 방지한다.
* 오해: OCP는 클래스와 모듈 설계에'만' 도움이 되는 원칙이다?
* 사실: OCP는 아키텍쳐 컴포넌트 수준에서 고려할 때 훨씬 중요한 의미를 갖는 원칙이다.
* OCP는 어떻게 달성할 수 있을까?
  1. SRP: 서로 다른 목적으로 변경되는 요소를 적절히 분리한다.
  2. DI: 분리된 요소 사이의 의존성을 체계적으로 정리한다.
     * 결과 분리된 책임 중 하나에서 변경이 발생하더라도, 다른 요소는 변경되지 않아야 한다.
  * 이를 토대로 요구사항 확장에 대한 변경량을 최소화할 수 있다.
* OCP를 위배하지 않는 아키텍쳐에서, **의존 관계를 나타내는 클래스의 사용 / 상속 / 구현 관계는 보호하려는 컴포넌트를 향해야** 한다.
  * 예를 들어, 클래스 A의 변경 사항으로부터 클래스 B를 보호하려면 클래스 A가 클래스 B에 의존해야 한다.
* 애플리케이션 전체적으로 봤을 때 **가장 높은 수준의 정책을 포함하는 컴포넌트는 가장 중요한 문제의 처리를 담당**한다고 볼 수 있다.
* 각 컴포넌트가 담당하는 문제의 중요도는 우선 순위를 나눌 수 있다.
  * 가장 중요한 문제를 처리하는 컴포넌트는 다른 모든 컴포넌트로부터 보호받아야 한다.
    * 즉, 다른 컴포넌트들이 중요한 문제를 처리하는 컴포넌트에 의존해야 한다.
  * 가장 덜 중요한 문제를 처리하는 컴포넌트는 다른 컴포넌트의 변경에서 사실상 보호를 받지 못한다.
    * 즉, 해당 컴포넌트는 다른 컴포넌트들에 의존한다.
* OCP는 상술한 방식으로 아키텍쳐 수준에서 동작한다.
  * 아키텍트는 **기능이 어떻게, 왜, 언제 발생하는지에 따라 기능을 분리**하고,
  * **분리한 기능을 컴포넌트 계층 구조로 조직화**한다.
  * **적절히 계층 구조를 정의한 아키텍쳐는 저수준 컴포넌트에서 발생한 변경 사항에서 고수준 컴포넌트가 보호**된다.
* 더 **중요한 컴포넌트가 변경으로부터 보호되는 것의 우선 순위가 가장 높지만, 상대적으로 덜 중요한 컴포넌트가 변경으로부터 보호받을 필요가 전혀 없다는 의미는 아니다**.
* OCP의 목표는 다음과 같다.
  1. OCP는 쉬운 시스템 변경을 뒷받침한다.
  2. OCP는 변경으로 인해 시스템에 가해지는 영향을 최소화한다.
* OCP의 목표를 위해서는, 
  1. 시스템을 컴포넌트 단위로 분리하고, 
  2. 저수준 컴포넌트에서 발생한 변경으로부터 고수준 컴포넌트가 보호받을 수 있는 형태로,
  * 의존성 계층 구조가 만들어져야 한다.

### LSP - 리스코프 치환 원칙
```
- S타입 객체 o1
- T타입 객체 o2
- T타입 객체를 이용해 만들어진 프로그램 P
에서, P의 o2를 모두 o1으로 치환하더라도 P의 행위가 변경되지 않는다면 S는 T의 하위 타입이다.
```
* 초창기의 LSP는 상속을 사용하기 위해 참고할 만한 가이드 정도로 간주되었다.
* 시간이 흐르면서 LSP는 인터페이스와 이를 구현한 구현체에도 적용되는 광범위한 소프트웨어 설계 원칙이 되었다.
* LSP는 아키텍쳐 수준까지 확장할 수 있고, 반드시 확장되어야만 한다.
* 치환 가능성이 오염되면 시스템 아키텍쳐 전체가 오염되고, 이를 위한 별도의 핸들링 메커니즘이 추가되어야 하는 상황이 만들어진다.

## 2022-01-20 Thu
### ISP - 인터페이스 분리 원칙
* 다수의 클래스가 하나의 클래스에 의존하는 경우, 정적 타입 언어라면 자신과 관계 없는 메소드의 변경으로 인해 불필요한 컴파일과 배포가 유발된다.
* 이러한 문제는 무거운 클래스에 포함된 여러 기능을 인터페이스 단위로 분리하는 것이다.
* 정적 타입 언어는 사용자가 import, use, include와 같은 타입 선언문을 사용하도록 강제한다.
  * 따라서 소스 코드 의존성이 발생하고, 불필요한 재컴파일 또는 재배포가 강제되는 상황이 반드시 발생한다.
* 반면 동적 타입 언어는 타입 선언문이 존재하지 않고, 런타임 시점에 추론이 발생하므로 소스 코드 의존성이 없다.
  * 따라서 불필요한 재컴파일과 재배포가 발생하지 않으며, 이로 인해 동적 타입 언어로 구성된 시스템은 유연하고 결합도가 낮은 경우가 많다.
* 상술한 설명은 모든 언어에 적용되는 개념이 아니다. 때문에 **인터페이스 분리 원칙은 언어 종류에 따라 영향받는 정도가 다르다**.
* 일반적으로, 필요 이상으로 많은 기능을 포함하는 모듈에 의존하는 것은 해롭다.
  * 이는 아키텍쳐 수준에서도 같은 상황이 발생할 수 있다.
  * 불필요한 기능을 갖는 무언가에 의존하면 예상치 못한 문제에 빠지기 쉽다.

### DIP - 의존성 역전 원칙
* 유연성이 극대화된 시스템: 소스 코드 의존성이 '추상'에만 의존하고 '구체'에는 의존하지 않는 시스템이다.
* 예를 들어, Java와 같은 정적 타입 언어는 **import 구문을 통해 오직 인터페이스나 추상 클래스 같은 추상적인 선언만을 참조해야** 한다.
  * 구체적인 대상에는 절대 의존하지 말아야 한다.
* DIP의 비현실성
  * 소프트웨어 시스템은 충분히 많은 구체에 의존할 수 밖에 없다.
  * 예를 들어, String 클래스는 구체 클래스이지만 이를 애써 추상 클래스로 만들려는 것은 비현실적이다.
    * 그러나 String 클래스는 매우 안정적이고, 변경은 엄격하게 통제된다.
* 위와 같은 이유에서, **의존성 역전 원칙은 운영체제, 플랫폼 등 충분히 안정성이 보장된 환경에 대해서는 무시**할 수 있다.
  * 즉, 이러한 환경에 대해서는 의존성을 용납한다.
  * **변경되지 않는다면 의존할 수 있다**.
* 우리가 **의존하지 않아야 하는 것은 변동성이 큰 구체 요소**이다.
  * 대표적인 구체 요소는 우리가 절찬리에 개발하고 있는 도중인, 변경이 잦을 수 밖에 없는 모듈들이다.
```
- 추상 인터페이스에 변경이 생기면, 이를 구현한 클래스들도 수정되어야 한다.
- 반대로 구체화된 클래스에 변경이 생기더라도, 해당 클래스가 구현한 인터페이스는 대부분의 경우 수정될 필요가 없다.
- 따라서, 인터페이스는 구현체보다 변동성이 낮다.
```
* 안정된 소프트웨어 아키텍쳐: **변동성이 큰 구현체에 의존하는 일을 지양하고, 안정적인 추상 인터페이스를 선호하는 아키텍쳐**를 말한다.
* 의존성 역전 원칙을 위배하지 않으려면,
  1. **변동성이 큰 구체 클래스를 참조하지 말아야 한다.**
     1. 대신 추상 인터페이스를 참조한다.
     2. 이는 객체 생성 방식을 강하게 제약하며, 일반적으로 추상 팩토리의 사용을 강제한다.
  2. **변동성이 큰 구체 클래스로부터 파생하지 말아야 한다. 즉, 상속받지 않아야 한다.**
     1. 정적 타입 언어에서의 상속은 소스 코드 상의 모든 관계 중에서 가장 강력하지만, 동시에 변경이 어렵다.
     2. 상속은 신중에 신중을 기한 후에 사용해야 한다.
  3. **구체 함수를 재정의하지 않아야 한다.**
     1. 일반적으로 구체 함수는 소스 코드 의존성을 필요로 한다.
     2. 때문에 구체 함수를 오버라이드할 경우, 이러한 의존성을 제거할 수 없게 된다. 실제로는 그 의존성을 상속받게 된다!
     3. 차라리 **추상 함수로 선언하고, 구현체들이 각자의 용도에 맞게 구현**하도록 해야 한다.
* **구체적이며, 동시에 변동성이 크다면 이름도 언급하지 말아야** 한다!
* 상술한 세 가지 규칙을 준수하려면, 변동성이 큰 구체적인 객체는 주의를 기울여 생성해야 한다.
  * 그러나 대부분의 언어에서, 객체를 생성하려면 해당 객체를 구체적으로 정의한 코드에 대해 소스 코드 의존성이 발생한다.
  * Java와 같은 객체 지향 언어에서, 이처럼 **바람직하지 않은 의존성을 처리할 때 추상 팩토리의 사용을 고려**할 수 있다.
* 추상 팩토리를 적절히 사용하면 시스템의 컴포넌트를 추상 컴포넌트와 구체 컴포넌트로 나눌 수 있다.
  * 추상 컴포넌트는 시스템의 모든 고수준의 규칙을 포함한다.
  * 구체 컴포넌트는 시스템의 모든 고수준의 규칙을 다루기 위해 필요한 세부 사항을 포함한다.
* **의존성 역전 원칙을 준수하면 소스 코드 의존성은 제어 흐름과는 반대 방향**으로 흐른다. 역전된다.
* 의존성 역전 원칙의 위배를 모두 없앨 수는 없다.
  * 그러나 의존성 역전 원칙을 위배하는 클래스를 적은 수의 구체 컴포넌트 내부로 모을 수 있다.
  * 이를 통해 시스템의 나머지 부분과 분리할 수 있게 된다.
  * 대다수의 시스템은 main 함수를 포함하는 구체 컴포넌트를 최소한 하나는 포함하며, 이를 Main 컴포넌트라고 부른다.
* 의존성 규칙: **추상 컴포넌트와 구체 컴포넌트를 나누는 경계를 기준으로, 의존성은 항상 더 추상적인 엔티티 쪽으로만 향해야 한다**.
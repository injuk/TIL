# Architecture
## 2022-01-19 Wed

* SOLID: 깔끔한 코드로 좋은 아키텍쳐를 정의하는 원칙이다.
  * SOLID는 함수와 데이터 구조를 클래스로 배치하는 방법과,
  * 클래스들을 서로 결합하는 방법을 설명한다.
  * 여기서 클래스는 단순한 함수와 데이터의 집합을 말하며, 객체 지향의 클래스만 지칭하는 개념이 아니다.
* SOLID 원칙의 목적은 다음과 같다:
  1. 중간 수준의 소프트웨어 구조가 변경에 유연해지고,
  2. 이해가 쉽고,
  3. 많은 소프트웨어 시스템에 사용할 수 있는 컴포넌트의 기반이 되도록 한다.
* SOLID 원칙은 코드 수준보다는 상위에서 적용되며, 모듈과 컴포넌트 내부에서 사용되는 소프트웨어 구조의 정의에 도움을 준다.

### SRP - 단일 책임 원칙
* SOLID 중 의미가 잘 전달되지 않은 원칙이다.
* 오해: 단일 책임 원칙은 모든 모듈이 하나의 일만 해야한다는 원칙이다.
  * 실제로는 함수는 반드시 하나의 일만 해야한다는 원칙이다.
  * 해당 원칙은 SOLID 원칙이 적용되는 수준보다 저수준에서 적용되어야 하는 원칙이다.
* 사실: 단일 책임 원칙은 '**단일 모듈은 변경의 이유가 오직 하나 뿐이어야 한다**'로 기술된다.
* 변경의 이유란?
  * SRP에서 변경의 이유는 사용자와 이해 관계자이다.
    * 일반적으로 사용자, 이해 관계자는 집단이다. 
  * 따라서 변경의 이유란 시스템이 동일한 방향으로 변경되길 바라는 하나의 집단(액터)을 말한다.
* 변경의 이유의 의미를 토대로, 단일 책임 원칙은 다음과 같이 풀어쓸 수 있다.
```
하나의 모듈은 오직 하나의 액터에 대해서만 책임져야 한다.
```
* 하나의 모듈이란, 소스 파일 또는 함수와 데이터 구조로 구성된 '**응집된 집합**'이다.
* **단일 액터를 책임지는 코드들을 하나로 묶어주는 힘은 응집성**이다.
* 단일 책임 원칙은 다음과 같이 말한다.
  * **서로 다른 액터가 의존하는 코드를 너무 가까이 배치해서는 안되며, 서로 분리**되어야 한다.
* 단일 책임 원칙을 위배하여 서로 다른 액터를 책임지는 메소드들이 하나의 파일에 포함된 경우, 머지 충돌이 자주 발생할 가능성이 있다.
  * 충돌은 그 자체로도 위험하며, 어떤 도구도 충돌을 원천 차단할 수 없다.
* 단일 책임 원칙을 위배하는 사례에서, 가장 **확실한 해결책은 데이터와 메소드를 분리**하는 것이다.
  * 여러 액터가 공유하는 데이터는 Data 클래스로 만들고, 이를 사용하는 소스 코드를 별도의 클래스의 메소드로 작성한다.
  * 액터 별 클래스의 인스턴스화와 추적이 어려워진다면, 요청을 받아 요청을 해결할 책임이 있는 메소드를 호출하여 위임하는 **파사드 패턴**을 적용해볼 수 있다.
* 단일 책임 원칙은 메소드와 클래스 수준의 원칙이다.
  * 이러한 원칙은 이보다 상위 수준인 컴포넌트 수준에서는 공통 폐쇄 원칙, 아키텍쳐 수준에서는 변경의 축이라는 원칙으로 나타난다.

### OCP - 개방 폐쇄 원칙
```
소프트웨어 개체(artifact)는 확장에는 열려 있어야 하고, 변경에는 닫혀 있어야 한다.
```
* 즉, 소프트웨어 개체의 **행위는 확장 가능해야 하지만, 이 때 개체를 변경해서는 안됨**을 의미한다.
* 이는 소프트웨어 아키텍쳐를 공부하는 가장 근본적인 이유이다!
  * 요구사항을 살짝 확장하는 데에 엄청난 수정이 필요한 경우를 미연에 방지한다.
* 오해: OCP는 클래스와 모듈 설계에'만' 도움이 되는 원칙이다?
* 사실: OCP는 아키텍쳐 컴포넌트 수준에서 고려할 때 훨씬 중요한 의미를 갖는 원칙이다.
* OCP는 어떻게 달성할 수 있을까?
  1. SRP: 서로 다른 목적으로 변경되는 요소를 적절히 분리한다.
  2. DI: 분리된 요소 사이의 의존성을 체계적으로 정리한다.
     * 결과 분리된 책임 중 하나에서 변경이 발생하더라도, 다른 요소는 변경되지 않아야 한다.
  * 이를 토대로 요구사항 확장에 대한 변경량을 최소화할 수 있다.
* OCP를 위배하지 않는 아키텍쳐에서, **의존 관계를 나타내는 클래스의 사용 / 상속 / 구현 관계는 보호하려는 컴포넌트를 향해야** 한다.
  * 예를 들어, 클래스 A의 변경 사항으로부터 클래스 B를 보호하려면 클래스 A가 클래스 B에 의존해야 한다.
* 애플리케이션 전체적으로 봤을 때 **가장 높은 수준의 정책을 포함하는 컴포넌트는 가장 중요한 문제의 처리를 담당**한다고 볼 수 있다.
* 각 컴포넌트가 담당하는 문제의 중요도는 우선 순위를 나눌 수 있다.
  * 가장 중요한 문제를 처리하는 컴포넌트는 다른 모든 컴포넌트로부터 보호받아야 한다.
    * 즉, 다른 컴포넌트들이 중요한 문제를 처리하는 컴포넌트에 의존해야 한다.
  * 가장 덜 중요한 문제를 처리하는 컴포넌트는 다른 컴포넌트의 변경에서 사실상 보호를 받지 못한다.
    * 즉, 해당 컴포넌트는 다른 컴포넌트들에 의존한다.
* OCP는 상술한 방식으로 아키텍쳐 수준에서 동작한다.
  * 아키텍트는 **기능이 어떻게, 왜, 언제 발생하는지에 따라 기능을 분리**하고,
  * **분리한 기능을 컴포넌트 계층 구조로 조직화**한다.
  * **적절히 계층 구조를 정의한 아키텍쳐는 저수준 컴포넌트에서 발생한 변경 사항에서 고수준 컴포넌트가 보호**된다.
* 더 **중요한 컴포넌트가 변경으로부터 보호되는 것의 우선 순위가 가장 높지만, 상대적으로 덜 중요한 컴포넌트가 변경으로부터 보호받을 필요가 전혀 없다는 의미는 아니다**.
* OCP의 목표는 다음과 같다.
  1. OCP는 쉬운 시스템 변경을 뒷받침한다.
  2. OCP는 변경으로 인해 시스템에 가해지는 영향을 최소화한다.
* OCP의 목표를 위해서는, 
  1. 시스템을 컴포넌트 단위로 분리하고, 
  2. 저수준 컴포넌트에서 발생한 변경으로부터 고수준 컴포넌트가 보호받을 수 있는 형태로,
  * 의존성 계층 구조가 만들어져야 한다.

### LSP - 리스코프 치환 원칙
```
- S타입 객체 o1
- T타입 객체 o2
- T타입 객체를 이용해 만들어진 프로그램 P
에서, P의 o2를 모두 o1으로 치환하더라도 P의 행위가 변경되지 않는다면 S는 T의 하위 타입이다.
```
* 초창기의 LSP는 상속을 사용하기 위해 참고할 만한 가이드 정도로 간주되었다.
* 시간이 흐르면서 LSP는 인터페이스와 이를 구현한 구현체에도 적용되는 광범위한 소프트웨어 설계 원칙이 되었다.
* LSP는 아키텍쳐 수준까지 확장할 수 있고, 반드시 확장되어야만 한다.
* 치환 가능성이 오염되면 시스템 아키텍쳐 전체가 오염되고, 이를 위한 별도의 핸들링 메커니즘이 추가되어야 하는 상황이 만들어진다.
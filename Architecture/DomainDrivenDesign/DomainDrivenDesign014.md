# DomainDrivenDesign
## 2022-05-04 Wed

## 아키텍쳐
```
> 도메인 주도 설계에서, 아키텍쳐는 주역이 될 수 없다.
```
* 도메인 주도 설계는 도메인에 주목하고, 도메인 모델을 코드에 녹여 도메인과 코드를 연결하는 개발 기법이다.
  * 때문에 도메인 주도 설계 자체는 특정한 아키텍쳐를 전제로 하지 않는다.
* 반면, 소프트웨어가 지속적으로 사용자에게 유용할 수 있으려면 끊임없는 개선을 버틸 수 있어야 한다.
* **아키텍쳐는 지식을 표현하는 코드를 적소에 배치하는 원칙이며, 이를 통해 도메인 규칙이 제자리를 벗어나는 것을 방지하여 한 곳에 모을 수 있다**.
  * 이러한 이유에서 도메인 주도 설계와 아키텍쳐는 밀접한 관계를 갖는다.

### 안티패턴 - 스마트 UI
* 스마트 UI는 비즈니스 로직이 UI에 구현된 패턴이며, 시스템의 유연성을 치명적으로 저해하는 안티패턴이다.
  * 스마트 UI는 도메인 객체에 위치해야 할 중요한 규칙 구현 코드를 UI에 이끌려 나오도록 한다.
  * 이러한 패턴은 도메인을 분리하기에 적합하지 않은 애플리케이션에서 자주 발견되곤 한다.
* 덜 문제가 되는 상황은 스마트 UI는 여러 UI에서 동일한 로직을 처리하는 경우, 중복된 코드가 늘어나 수정지점을 늘리는 것이다.
  * 애초에 세 화면을 동시에 작업한 경우, 일반적으로 개발자는 중복되는 로직을 한 곳으로 모으려고 할 것이다.
* **정말 문제가 되는 것은 처음에는 하나의 화면으로 시작하여 점점 시스템이 성장하는 경우**이다.
  * 이 경우, 개발자는 로직을 따로 뽑아둘 필요가 없다고 오판할 수 있다.
  * 개발자는 모든 일이 중요하다고 생각하지 않고, 언젠가 리팩토링을 할 수 있을 것이라고 낙관하곤 한다.
* **UI의 책임은 근본적으로 사용자의 입력을 받아 출력을 보여주는 것 뿐이며, 비즈니스 로직은 UI에 구현되지 않아야 한다**.
  * 즉, UI에는 최소한의 로직만 존재해야 한다.
  * UI가 '스마트'해질수록 수정 비용은 높아지며, 수정 작업 역시 괴로워진다.
* **스마트한 UI를 작성하는 대신 비즈니스 로직을 한 곳에 모아두면 이러한 문제점에서 해방될 수 있으며, 다가올 수정사항을 반영하기도 쉬워진다**.
* 최우선적으로 해야할 일은 지금 작업하고 있는 소프트웨어가 단순한 것이라는 편견을 버리는 것이다.
```
> 소프트웨어가 단순하여 UI에 비즈니스 로직을 구현해도 되겠다고 판단한 순간, 도메인 모델을 성장시켜가는 밝은 미래는 사라진다.
```

### 도메인 주도 설계가 아키텍쳐에게 바라는 것
```
> 도메인 주도 설계가 아키텍쳐에게 원하는 것은 도메인 객체가 서로 얽힌 레이어를 분리하고, 소프트웨어 구현에 필요한 사정으로부터 도메인 객체를 지키는 것이다.
```
* 스마트 UI 패턴을 따르지 않을 것을 결심했더라도, 이를 실천하기는 어려운 문제이다.
  * 비즈니스 로직이 정말 있어야할 위치에 있도록 배치하는 것은 비즈니스 로직을 잘 알고 있는 개발자로서도 어려운 일이다.
  * 때문에 **개발자는 이를 쉽게 수행할 수 있도록 하는 방법을 강구해야 하며, 아키텍쳐는 적절한 해결책이 되어줄 수 있다**.
* 아키텍쳐란, 코드를 구성하는 원칙이다.
  * 아키텍쳐는 어떤 내용을 구현하는 코드가 어디에 배치되어야 하는지 명확히 제시하며, 로직이 무질서하게 흩어지는 것을 방지한다.
  * **개발자는 아키텍쳐가 제시하는 원칙을 따르는 것으로 어떤 로직을 어디에 구현할지 고민하지 않아도 된다**.
  * 이는 **개발자가 도메인 주도 설계의 본질인 도메인을 파악하고 잘 표현하는 것에 집중할 수 있도록 해준다**.

## 아키텍쳐 II
* 일반적으로 도메인 주도 설계는 다음의 아키텍쳐와 함께 언급되곤 한다.
  1. 계층형 아키텍쳐
  2. 육각형 아키텍쳐
  3. 클린 아키텍쳐
* 그러나 **도메인 주도 설계에서 중요한 것은 도메인을 적절히 분리하는 것이지, 반드시 어떤 아키텍쳐를 따라야한다는 것은 아니다**. 
  * 나아가 어떤 아키텍쳐를 잘 따른다고 해서 도메인 주도 설계를 제대로 실천하는 것으로 볼 수도 없다.
  * **중요한 것은 도메인의 본질에 집중할 수 있을만한 환경을 구성하는 것**이다.

### 계층형 아키텍쳐
* 계층형 아키텍쳐는 도메인 주도 설계와 함께 언급되는 아키텍쳐 중에서 가장 전통적이고 유명한 아키텍쳐에 해당한다.
* 계층형 아키텍쳐는 이름 그대로 다음과 같은 여러 층으로 구성되는 구조로 나타낼 수 있다.
  1. 프리젠테이션 계층(사용자 인터페이스 계층)
  2. 애플리케이션 계층
  3. 도메인 계층
  4. 인프라 계층
* 가장 중요한 것은 도메인 계층이다.
  1. 도메인 계층은 소프트웨어가 적용될 분야에서 문제 해결에 필요한 지식을 담는 계층이다.
  2. 해당 계층에 도메인 객체를 분리해두며, 다른 계층으로 벗어나지 않게 해야 한다.
  3. **도메인 모델을 표현하는 코드는 모두 도메인 계층에 존재해야 한다**.
  4. 또한, **도메인 객체를 지원하는 팩토리나 리포지토리의 인터페이스도 해당 계층에 포함**되어야 한다.
* 애플리케이션 계층은 도메인 계층의 요소를 지휘하는 요소가 모이는 계층이며, 애플리케이션 서비스는 해당 계층에 포함된다.
  1. 애플리케이션 서비스는 도메인 객체의 직접적인 클라이언트가 되며, 유즈케이스를 구현하는 진행자를 맡는다.
  2. **도메인 계층의 요소는 도메인을 나타내는 데에 전념해야 하므로, 애플리케이션으로 기능하기 위해 애플리케이션 계층 요소가 도메인 객체를 지휘**해야 한다.
  3. 애플리케이션 계층의 목적은 애플리케이션 서비스의 목적과 같다.
     * 즉, 문제를 해결하기 위해 도메인 객체의 행위를 진행하거나 관리한다.
     * 이 과정에서, 상황에 따라 필요한 경우 다른 서비스와 협조할 수도 있다.
  4. **애플리케이션 계층에서는 도메인 규칙이나 동작을 직접 구현하지 않도록 주의**해야 한다.
* 프리젠테이션 계층은 사용자 인터페이스와 애플리케이션이 연결되는 계층이다.
  1. **주요 책임은 출력의 표시와 입력의 해석**이다.
  2. 시스템 사용자가 이해할 수 있도록 출력을 변환하고, 사용자의 입력을 해석할 수 있어야 한다.
* 인프라 계층은 자신 이외의 계층을 지지하는 기술적인 기반에 대한 접근을 제공한다.
  1. 예를 들어 메시지 송신, 영속성 제공 모듈 등이 해당 계층에 포함된다.
* **계층형 아키텍쳐에서 의존의 방향은 항상 위에서 아래를 향해야 하며, 이를 거스르는 의존은 허용되지 않는다**.

### 육각형 아키텍쳐
* **육각형 아키텍쳐는 애플리케이션과 그 외의 인터페이스, 저장 매체 등을 플러그 인 형식으로 구현하는 것을 목표**로 한다.
  * 육각형 아키텍쳐는 어댑터가 포트의 모양만 맞으면 동작하는 것과 같다고 해서 포트 앤 어댑터라고도 부를 수 있다.
* 육각형 아키텍쳐는 애플리케이션 이외의 모듈을 마치 게임 컨트롤러처럼 다른 것으로 바꿔끼울 수 있도록 한다.
* 이러한 **준비가 되어 있는 경우, 인터페이스나 저장매체가 변경되더라도 코어가 되는 애플리케이션에는 영향을 주지 않는다**.
* **애플리케이션에 대한 입력을 받는 포트와 어댑터는 각각 프라이머리 포트와 프라이머리 어댑터**라고 한다.
  * 반면 **애플리케이션으로부터 외부와 상호작용하는 포트는 세컨더리 포트라고 하며, 이를 구현한 객체를 세컨더리 어댑터**라고 한다.
* **계층형 아키텍쳐와의 차이는 인터페이스를 이용하여 의존성을 관리한다는 점**이다.
  * 계층형 아키텍쳐는 논리적인 계층 분리만 되어 있으며, 인터페이스의 사용 여부를 강제하지 않는다.

### 클린 아키텍쳐
* 클린 아키텍쳐는 다음과 같은 순서로 구성된 4가지의 동심원이 있는 형태로 설명되는 아키텍쳐에 해당한다.
  1. 디바이스, 웹, 데이터베이스, 등
  2. 컨트롤러, 게이트웨이, 프리젠터, 등
  3. 유즈케이스
  4. 엔티티: 도메인 주도 설계의 엔티티와는 다른 개념이다.
* **클린 아키텍쳐의 요점은 비즈니스 규칙을 캡슐화하는 모듈을 중심에 두는 것**이다.
  * 이 때, 엔티티는 비즈니스 규칙을 캡슐화한 객체 또는 데이터 구조와 함수를 묶은 것을 가리킨다.
  * 굳이 따지자면 앞서 다룬 도메인 객체에 가까운 개념이다.
* 클린 아키텍쳐는 UI나 데이터베이스와 같은 세부사항을 외부로 밀어내고, 의존성을 안쪽으로 향하게 하는 것으로 세부사항이 추상적인 개념에 의존하도록 한다.
  * 때문에 육각형 아키텍쳐와 그 목적이 같다.
* **클린 아키텍쳐의 핵심은 비즈니스 모듈을 캡슐화하는 모듈을 중심에 두고, 의존성의 방향을 절대적으로 제어하는 데에 있다**.

## 결론
```
> 아키텍쳐에서 공통적으로 강조하는 것은 한 번에 너무 많은 것을 생각할 필요가 없다는 것이다.
```
* 사람은 한 번에 많은 것을 동시에 생각하기 어렵고, 하나씩 순서대로 처리할 때 작업 효율이 높다.
* **아키텍쳐는 이러한 원칙을 제시해주며, 원칙을 준수하는 것으로 매번 같은 고민을 할 필요 없이 선택지를 줄일 수 있다**. 
  * 결과, 개발자는 언제나 더 중요한 일에 집중할 수 있게 된다.
* **할 일이 명확해질 때 생각할 수 있는 여유도 생기기 마련이며, 아키텍쳐를 선정하는 것으로 모델을 고찰하는 데에 시간을 더 들일 수 있다**.
* **어떠한 아키텍쳐를 사용하더라도, 도메인 주도 설계에서 중요한 것은 도메인을 적절히 분리하는 것**이다.
  * 때문에 도메인을 적절히 분리할 수 있는 수단이라면 어떠한 아키텍쳐를 적용해도 무방하다.
  * **모든 기술적 세부사항이 도메인에 의존하도록 하는 것으로 소프트웨어의 주도권을 중요도가 높은 도메인에 둘 수 있다**.
* 소프트웨어에서 가장 중요한 것은 언제나 다음과 같다.
  1. 사용자의 요구사항을 만족시키고,
  2. 사용자의 문제를 해결해줄 수 있어야 한다.
* **적절한 아키텍쳐는 개발자가 이러한 소프트웨어의 본질에 집중할 수 있도록 돕는다**.
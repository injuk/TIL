# DomainDrivenDesign
## 2022-04-30 Sat

## 애플리케이션 서비스
### 애플리케이션 서비스란?
```
> 애플리케이션 서비스는 유즈케이스를 구현하는 객체이다.
```
* 애플리케이션은 일반적으로 사용자의 목적에 부응하는 프로그램 전반을 의미한다.
  * 이 때, 애플리케이션의 목표는 사용자의 요구사항을 만족시키고 목적을 달성하는 데에 있다.
* 반면, 값 객체나 엔티티와 같은 도메인 객체는 도메인을 코드로 옮긴 것이지만 그것 만으로는 사용자의 문제나 요구사항이 해결되지 않는다.
* **사용자의 요구사항을 만족시키거나 문제를 해결하려면 반드시 도메인 객체의 힘을 하나로 적절히 조합하여 올바른 방향으로 이끌어야 한다**.
* 애플리케이션 서비스는 이러한 역할을 수행하며, 도메인 객체를 조작하여 사용자의 목적을 달성하도록 이끌어준다.

### 애플리케이션 서비스의 예시
* 예를 들어, 사용자 등록을 수행하는 시스템에서의 **사용자 기능 구현은 사용자 등록하기 또는 사용자 정보 수정하기 유즈케이스를 필요**로 한다.
* 이 때, **사용자 기능 애플리케이션 서비스는 유즈케이스에 따라 사용자 등록하기와 사용자 정보 수정하기와 같은 행위를 정의**한다.
    * 이 때, 각각의 행위는 도메인 객체를 실제로 조합하여 실행되는 일종의 스크립트가 된다.

## 유즈케이스의 수립
* 일반적으로 소프트웨어의 기능을 코드로 구현하기 위해서는 다음의 절차를 따를 수 있다.
  1. 시스템에 포함될 기능을 유즈케이스로 정의한다.
  2. 애플리케이션 서비스가 다룰 도메인 객체를 준비한다.
  3. 필요한 로직 중 도메인 객체에서 다루기 부자연스러운 부분을 처리할 도메인 서비스를 구현한다.
  4. 도메인 객체의 영속화가 필요한 경우, 리포지토리를 인터페이스 형태로 구현한다.
  5. 각 유즈케이스 별로 필요한 로직을 애플리케이션 서비스 형태로 구현한다.

### 애플리케이션 서비스에서 DTO를 반환하기
* 애플리케이션 서비스가 저장된 정보로부터 복원된 도메인 객체 그대로 반환하는 것은 다음과 같은 위험을 수반한다.
  1. 애플리케이션 서비스가 아닌 객체가 도메인 객체의 직접적인 클라이언트가 되어, 도메인 객체를 자유롭게 조작한다.
  2. 도메인 객체에 대한 의존이 코드 이곳저곳에 흩어진다.
* 이를 해결하기 위해 접근제어자를 수정할 수 있지만, 클라이언트가 도메인 객체와 같은 패키지라면 해당 방법 역시 한계가 있다.
* 또는 개발 팀의 합의를 통해 도메인 객체의 메소드를 호출하지 않을 수 있으나, 이 방법은 강제성이 없다.
* **이상적인 방법은 애플리케이션 서비스가 도메인 객체를 그대로 반환하지 않도록 하는 대신, DTO를 사용하는 방식**이다.
  * DTO는 오로지 데이터 전송만을 위한 객체이며, 복원된 도메인 객체의 정보를 토대로 DTO 인스턴스를 만들어 반환하는 것으로 문제를 해결할 수 있다.
  * 이를 통해 **복원된 도메인 객체가 외부로 노출되지 않으므로, 애플리케이션 서비스를 사용하는 클라이언트는 도메인 객체의 메소드를 직접 호출할 수 없다**.
* DTO를 사용하는 경우, DTO를 정의하기 위한 수고와 데이터를 옮겨 담는 데에서 기인하는 성능 저하가 수반된다.
  * 그러나 성능 저하는 많은 양의 데이터를 옮기지 않는 한 무시 가능하며, 오히려 불필요한 의존을 줄이고 도메인 객체의 변경을 방해받지 않는 장점이 더 크다.
* **중요한 것은 도메인 객체를 외부에 공개할지 결정하는 것이 소프트웨어 관점에서의 큰 분기점이라는 사실을 이해하는 것**이다.
  * 도메인 객체를 공개해도 즉각 문제가 발생하지는 않으며, 도메인 객체를 공개하지 않는 것이 더 큰 비용이 들어가기도 한다.
  * 가능하다면 프로젝트에 사전 정의된 정책을 따르도록 한다.

## 도메인 규칙의 유출 방지하기
* **애플리케이션 서비스는 도메인 객체가 수행하는 행위를 조율하는 데에만 집중해야 하며, 도메인 규칙을 작성하지 않아야 한다**.
  * 도메인 규칙이 애플리케이션 서비스에 작성되는 경우, 같은 코드가 여러 위치에 중복되는 현상이 발생할 수 있다.
* 이렇듯 중복된 로직은 결국 수정사항을 반영하는 과정에서 수정할 지점을 빠트려 버그를 발생시키는 원인이 될 수 있다.
* **이러한 문제는 도메인 규칙을 애플리케이션 서비스에 구현하지 않고, 도메인 객체에만 구현하는 방식으로 간단히 해결**할 수 있다.
  * 도메인 객체에 도메인 규칙을 구현하면 코드가 중복 구현되는 것을 방지하고, 수정사항 발생시 수정이 필요한 지점이 누락되는 불상사를 방지할 수 있다.
```
> 도메인 규칙은 도메인 객체에만 구현한다.
> 애플리케이션 서비스는 도메인 객체를 사용하는 역할만을 수행해야 한다.
```

## 애플리케이션 서비스와 응집도
* 소프트웨어에서의 응집도란 모듈의 책임 범위가 얼마나 집중되어 있는지 나타내는 척도이다.
* 응집도가 높을수록 모듈은 하나의 관심사에만 집중하므로, 모듈의 견고성과 신뢰성, 재사용성과 가독성 측면에서 이점이 있다.
* **응집도는 클래스 내부에 정의된 인스턴스 변수와 메소드를 기준으로, 인스턴스 변수가 많은 메소드에서 사용될수록 높다고 판단**할 수 있다.
  * 즉, 모든 인스턴스 변수가 모든 메소드에서 사용되는 경우에 해당 클래스의 응집도는 매우 높다고 판단할 수 있다.
* **언제나 응집도를 최대로 유지하는 것이 좋은 것은 아니며, 코드의 맥락과 환경에 따라 응집도를 낮춰야하는 경우도 발생할 수 있다**.
* **그럼에도 응집도는 클래스를 설계하는 과정에서 한 번쯤은 고려해봐야할 척도임을 부정할 수는 없다**.

### 애플리케이션 서비스의 응집도 높이기
* 사용자 처리를 위한 애플리케이션 서비스를 예로 들어, 가입과 탈퇴가 같은 애플리케이션 서비스에 정의되어 있을 수 있다.
  * 이 때, 가입시 중복된 계정을 확인하기 위해 도메인 서비스를 사용한다고 가정한다.
* 해당 애플리케이션 서비스의 모든 메소드는 사용자를 추가하거나 제거하기 위해 리포지토리를 사용하지만, 제거시에는 중복 계정을 확인할 필요가 없다.
* 따라서 **응집도 측면에서 바람직한 상태가 아니므로, 애플리케이션 서비스를 사용자 추가와 제거 용도로 쪼개어 응집도를 높일 수 있다**.
  * 즉, UserRegisterService와 UserDeleteService로 나누어지는 셈이다.
* 그러나 **이는 책임을 명확히 분리하기 위해 클래스를 분리하는 경우에 해당하지만, 이로 인해 코드를 전체적으로 파악하기는 어려워질 수 있다**.
* 이런 경우, **관련된 코드를 한 곳에 모아두어 전체적인 파악을 쉽게 할 수 있도록 제공되는 기능이 패키지**이다. 
  * 패키지를 활용하여 클래스를 한 곳에 모아두면 개발자가 사용자와 관련된 처리를 찾기 쉬워질 수 있다.
* 중요한 것은 반드시 유즈케이스마다 애플리케이션 서비스를 분리하라는 것이 아니다.
  * 오히려 **같은 도메인에 속한다고 해서 매우 커다란 단일 애플리케이션 서비스를 작성할 필요가 없다는 사실을 기억해야 한다**.
  * **응집도는 모든 상황에서의 절대적인 지표가 아니며, 단지 개별 클래스가 건전한 상태인지 확인하는 과정에서 참고할 수 있는 척도 중 하나**이다.

## 애플리케이션 서비스와 인터페이스
* 더 유연한 코드를 구현하기 위해 애플리케이션 서비스에 정의된 각 행위를 정의하는 인터페이스를 작성할 수 있다.
* **인터페이스를 활용하는 경우, 목업 객체를 새로 정의하여 활용할 수 있으므로 다음과 같은 성황에서 클라이언트 측의 편의성이 높아질 수 있다**.
  1. 클라이언트 코드와 애플리케이션 서비스를 개발하는 과정에서 각 개발자가 분업하는 경우, 클라이언트 측은 인터페이스를 호출하므로 선작업이 가능하다.
  2. 애플리케이션 서비스에서 예외가 발생한 경우, 예외를 발생시키거나 처리하는 과정을 테스트하기 쉽다.

## 서비스란 무엇인가?
* 서비스는 클라이언트를 위해서 무엇인가를 해주는 존재이다.
  * 예를 들어, 값 객체와 엔티티는 오로지 자신만을 위한 행동이 정의된다.
  * 반면, **서비스에 정의된 행동은 자신을 위한 것이 아닌 무언가를 해주기 위한 행동**이다.
* 서비스의 이러한 특성 탓에, 서비스는 어떠한 사물보다는 행동이나 활동을 나타내는 경우가 많다.
* 서비스는 어떠한 영역에도 존재할 수 있으며, 이러한 관점에서 도메인 서비스와 애플리케이션 서비스는 다음과 같이 생각해볼 수 있다.
  1. 도메인 서비스는 도메인과 관련된 활동을 제공한다.
     * 도메인 서비스는 도메인 지식을 나타내는 도메인 객체이며, 도메인 규칙과 관련된 기능을 제공한다.
  2. 애플리케이션 서비스는 애플리케이션과 관련된 활동을 제공한다.
     * **모든 소프트웨어는 사용자의 문제를 해결하기 위해 제공하는 자신만의 기능이 존재하며, 이러한 기능을 처리하는 것은 애플리케이션 서비스의 역할**이다.
* 때문에 본질적으로 도메인 서비스와 애플리케이션 서비스는 같으며, 단지 그 방향성이 도메인인지 애플리케이션인지에 따라 나뉘는 차이만이 존재한다.

### 서비스는 무상태이다
* 서비스는 자신의 행동을 변화시키는 것을 목적으로 하는 상태를 갖지 않아야 한다.
  * 예를 들어, 애플리케이션 서비스는 일반적으로 리포지토리를 속성으로 갖지만 해당 속성으로 인해 자신의 상태나 동작이 변화하지는 않는다.
  * **서비스가 상태를 갖지 않는 경우, 서비스의 현재 상태를 고려할 필요가 없다는 장점이 존재**한다.
  * 그러나 **서비스가 전혀 상태를 가질 수 없는 것은 아니며, 구현에 따라서는 서비스의 행동에 영향을 주는 상태를 가질 수도 있다**.
* 서비스에 자신의 행동을 변화시키기 위한 상태가 존재하는 경우, 이에 영향을 받는 메소드를 사용할 때에는 서비스 인스턴스의 상태에 주의해야 한다.
  * 이렇듯 서비스가 갖는 상태는 그 복잡성으로 인해 개발자를 혼란스럽게 하기 쉽다.
```
> 서비스에 절대로 상태가 존재할 수 없는 것은 아니지만, 가능하다면 상태를 만들지 않을만한 방법을 우선 생각하는 것이 바람직하다.
```

## 결론
* 도메인 모델을 표현하는 것만으로는 애플리케이션을 완성할 수 없다. 
* 때문에 도메인 객체의 힘을 끌어내고 도메인의 문제를 해결할 수 있도록 하는 애플리케이션 서비스를 정의하여 유즈케이스를 구현하도록 할 수 있다.
  * **애플리케이션 서비스는 오로지 도메인 객체를 다루는데에만 집중하며, 유즈케이스를 구현하는데에 그 목적**이 있다.
* **애플리케이션 서비스를 구현하는 경우, 도메인 규칙에 대한 내용이 코드에 포함되지 않도록 주의**해야 한다.
  * 애플리케이션 서비스에 도메인 지식이 포함되는 경우, 장기적으로 도메인 지식의 변경에 대응하기 어려워질 수 있다.
  * 즉, **도메인 규칙은 도메인 객체에만 정의되는 것이 바람직**하다.
# DomainDrivenDesign
## 2022-04-27 Wed

## 값 객체
* 프로그래밍 언어에는 원시 데이터 타입이 있으나, 때로는 시스템에서 사용하기 위한 특유의 값을 정의해야할 수 있다.
* **값 객체란, 이렇듯 시스템 특유의 값을 표현하기 위해 개발자가 새로 정의하는 객체**이다.
  * 시스템에서 필요로 하는 값이 항상 원시 데이터 타입이 아닐 수 있으므로 값 객체를 정의하여 사용할 수 있다.
```
> 도메인 주도 설계의 관점에서 값 객체는 시스템 특유의 값을 나타내는 객체이다.
```

## 값의 성질
* 개발자는 값을 자주 사용하지만, 값에도 특정 성질이 존재한다는 사실을 인지 못하는 경우가 많다.
* **값 객체를 이해하기 위해 값의 성질을 아는 것은 매우 중요**하며, 값의 성질은 크게 다음과 같이 생각해볼 수 있다.
  1. 값은 변하지 않는다.
  2. 값은 주고 받을 수 있다.
  3. 값은 등가성을 비교할 수 있다.
```
> 값 객체는 시스템 특유의 값을 표현하는 값 객체의 일종이므로, 값의 성질은 값 객체에도 그대로 적용되어야 한다.
```

### 값의 불변성
```
> 값은 변화하지 않는 성질을 갖는다.
```
* 재대입이 가능한 변수에 새로운 값을 대입한다고 해서, 실제로 '값'을 수정하는 것은 아니다.
  * 이 때, **수정되는 것은 변수의 내용이지 값 그 자체가 아니다**.
* 값이 변할 수 있다면 다음과 같은 상황이 발생할 수 있으므로, 값은 초기화된 처음부터 끝까지 변하지 않아야 한다.
```
// 함수 내부에서 실제 '값'을 바꾼다고 가정한다.
String.prototype.changeValue(to) { ... }
// 값을 출력한다: Hello
console.log("Hello"); 
// Hello의 실제 값을 World로 변경한다.
"Hello".changeValue("World"); 
// Hello의 실제 값은 changeValue에 의해 World로 변경되었으므로, 변경된 값이 출력된다: World
console.log("Hello"); 
```
* 이렇듯 **값 그 자체를 수정할 수 있다면 개발자는 안심하고 값을 사용할 수 없게 된다**.
  * 즉, **변하지 않는 값은 그 자체로 미덕**이다!
* 이러한 관점에서, Person 이라는 값 객체를 다음과 같이 정의한 것은 문제가 있다.
```
class Main {
    public static void main(String[] args) {
        Person person = new Person("ingnoh", 10);
        System.out.println(person);
        // 값 객체는 불변해야하지만, 세터를 제공하므로 멤버 변수를 수정하고 있다.
        person.setName("injuk");
        person.setAge(3);
        System.out.println(person);
    }
}

class Person {
    private String name;
    private int age;
    
    public Person(String name, int age) { 
        this.name = name;
        this.age = age;
    }
    
    public String getName() { return this.name; }
    public void setName(String name) { this.name = name; }
    
    public int getAge() { return this.age; }
    public void setAge(int age) { this.age = age; }
    
    @Override public String toString() { return "[name: " + this.name + ", age: " + this.age + "]"; }
}
```
* **상술한 Person이 시스템 특유의 값을 표현하는 값 객체로 취급되려면 불변성을 보장해야 하므로, 어떠한 세터도 제공하지 말아야 한다**.

### 불변값의 장점과 단점
* **개발 과정에서 발생할 수 있는 버그는 매우 다양하지만, 버그 발생 원인의 많은 부분을 차지하는 것은 상태의 변화**이다. 
  * 예를 들어, 개발자 자신도 모르는 사이에 상태값이 수정되어 의도치 않은 동작을 낳는 경우가 있다.
* 이러한 **상태의 변화를 원인으로 하는 버거를 방지하는 가장 단순한 방법은 애초에 상태가 변화하지 않도록 강제하는 것**이다.
* 즉, 모르는 새에 상태가 변화하는 것을 방지하려면 처음부터 값이 변하지 않도록 한다.
* 또한, 물리적인 메모리가 부족한 경우에도 객체를 캐싱하는 전략을 취할 수 있다.
  * 예를 들어, **객체의 값이 변하지 않으므로 완전히 같은 상태를 갖는 객체는 여럿 생성하는 것보다 캐싱하여 돌려쓰는 것이 리소스 측면에서 더 효율적**이다.
* 반면, **상태가 변하지 않으므로 상태를 수정하고 싶을 때 매 번 새로운 객체를 생성해야한다는 단점도 존재**한다.
```
> 가변 객체를 불변 객체로 바꾸는 것보다 불변 객체를 가변 객체로 바꾸는 것이 훨씬 더 쉽다.
> 따라서, 둘 중 무엇을 택할지 결정하기 어려운 경우에는 일단 불변 객체를 적용하는 것이 바람직하다.
```
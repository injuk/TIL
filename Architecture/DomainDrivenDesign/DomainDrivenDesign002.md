# DomainDrivenDesign
## 2022-04-27 Wed

## 값 객체
* 프로그래밍 언어에는 원시 데이터 타입이 있으나, 때로는 시스템에서 사용하기 위한 특유의 값을 정의해야할 수 있다.
* **값 객체란, 이렇듯 시스템 특유의 값을 표현하기 위해 개발자가 새로 정의하는 객체**이다.
  * 시스템에서 필요로 하는 값이 항상 원시 데이터 타입이 아닐 수 있으므로 값 객체를 정의하여 사용할 수 있다.
```
> 도메인 주도 설계의 관점에서 값 객체는 시스템 특유의 값을 나타내는 객체이다.
```

## 값의 성질
* 개발자는 값을 자주 사용하지만, 값에도 특정 성질이 존재한다는 사실을 인지 못하는 경우가 많다.
* **값 객체를 이해하기 위해 값의 성질을 아는 것은 매우 중요**하며, 값의 성질은 크게 다음과 같이 생각해볼 수 있다.
  1. 값은 변하지 않는다.
  2. 값은 주고 받을 수 있다.
  3. 값은 등가성을 비교할 수 있다.
```
> 값 객체는 시스템 특유의 값을 표현하는 값 객체의 일종이므로, 값의 성질은 값 객체에도 그대로 적용되어야 한다.
```

### 값의 불변성
```
> 값은 변화하지 않는 성질을 갖는다.
```
* 재대입이 가능한 변수에 새로운 값을 대입한다고 해서, 실제로 '값'을 수정하는 것은 아니다.
  * 이 때, **수정되는 것은 변수의 내용이지 값 그 자체가 아니다**.
* 값이 변할 수 있다면 다음과 같은 상황이 발생할 수 있으므로, 값은 초기화된 처음부터 끝까지 변하지 않아야 한다.
```
// 함수 내부에서 실제 '값'을 바꾼다고 가정한다.
String.prototype.changeValue(to) { ... }
// 값을 출력한다: Hello
console.log("Hello"); 
// Hello의 실제 값을 World로 변경한다.
"Hello".changeValue("World"); 
// Hello의 실제 값은 changeValue에 의해 World로 변경되었으므로, 변경된 값이 출력된다: World
console.log("Hello"); 
```
* 이렇듯 **값 그 자체를 수정할 수 있다면 개발자는 안심하고 값을 사용할 수 없게 된다**.
  * 즉, **변하지 않는 값은 그 자체로 미덕**이다!
* 이러한 관점에서, Person 이라는 값 객체를 다음과 같이 정의한 것은 문제가 있다.
```
class Main {
    public static void main(String[] args) {
        Person person = new Person("ingnoh", 10);
        System.out.println(person);
        // 값 객체는 불변해야하지만, 세터를 제공하므로 멤버 변수를 수정하고 있다.
        person.setName("injuk");
        person.setAge(3);
        System.out.println(person);
    }
}

class Person {
    private String name;
    private int age;
    
    public Person(String name, int age) { 
        this.name = name;
        this.age = age;
    }
    
    public String getName() { return this.name; }
    public void setName(String name) { this.name = name; }
    
    public int getAge() { return this.age; }
    public void setAge(int age) { this.age = age; }
    
    @Override public String toString() { return "[name: " + this.name + ", age: " + this.age + "]"; }
}
```
* **상술한 Person이 시스템 특유의 값을 표현하는 값 객체로 취급되려면 불변성을 보장해야 하므로, 어떠한 세터도 제공하지 말아야 한다**.

### 불변값의 장점과 단점
* **개발 과정에서 발생할 수 있는 버그는 매우 다양하지만, 버그 발생 원인의 많은 부분을 차지하는 것은 상태의 변화**이다. 
  * 예를 들어, 개발자 자신도 모르는 사이에 상태값이 수정되어 의도치 않은 동작을 낳는 경우가 있다.
* 이러한 **상태의 변화를 원인으로 하는 버거를 방지하는 가장 단순한 방법은 애초에 상태가 변화하지 않도록 강제하는 것**이다.
* 즉, 모르는 새에 상태가 변화하는 것을 방지하려면 처음부터 값이 변하지 않도록 한다.
* 또한, 물리적인 메모리가 부족한 경우에도 객체를 캐싱하는 전략을 취할 수 있다.
  * 예를 들어, **객체의 값이 변하지 않으므로 완전히 같은 상태를 갖는 객체는 여럿 생성하는 것보다 캐싱하여 돌려쓰는 것이 리소스 측면에서 더 효율적**이다.
* 반면, **상태가 변하지 않으므로 상태를 수정하고 싶을 때 매 번 새로운 객체를 생성해야한다는 단점도 존재**한다.
```
> 가변 객체를 불변 객체로 바꾸는 것보다 불변 객체를 가변 객체로 바꾸는 것이 훨씬 더 쉽다.
> 따라서, 둘 중 무엇을 택할지 결정하기 어려운 경우에는 일단 불변 객체를 적용하는 것이 바람직하다.
```

### 교환 가능한 값
* 값은 불변이나, 수정을 전혀 하지 않고 목적을 달성하는 소프트웨어를 작성하는 것은 매우 어려운 일이다.
  * 즉, 값은 불변이나 수정할 필요는 있다는 모순이 존재한다.
  * 변하지 않는 성질을 갖는 값은 그 자체의 실제 값을 수정할 수 없으며, 값 객체 역시 마찬가지의 특징을 갖는다.
* **값 객체의 수정은 대입분을 활용하는 값의 수정과 마찬가지로 대입을 활용한 교환의 형식으로 표현**된다.
  * 값 객체는 불변이므로, 대입을 활용한 값의 교환 이외의 방법으로 수정을 나타낼 수 없다.
```
Person person = new Person("ingnoh", 10);
person = new Person("ingnoh", 3);
```

### 등가성 비교가 가능한 값
* 같은 유형의 값끼리는 다음과 같이 비교가 가능하다.
```
const a = 1;
const b = 1;
console.log(a === b); // true
```
* 상술한 코드에서, a와 b는 물리적으로는 다른 공간에 위치하지만 동일한 것으로 취급된다.
* 즉, **값은 자기 자신이 아닌 자신이 포함하는 속성을 통해 비교가 가능하다는 특징을 알 수 있다**.
  * **시스템 고유의 값을 나타내기 위해 정의한 값 객체 역시 값 객체를 구성하는 속성인 인스턴스 변수를 통해 비교할 수 있어야 한다**.
* **시스템 고유의 값을 나타내는 값 객체 역시 결국에는 값이므로, 값의 속성을 꺼내어 비교하는 것보다는 값 객체 자체를 비교하는 방식이 자연스럽다**.
  * ==, equals 메소드 등의 자연스러운 코드를 활용하여 값 객체를 비교하려면 관련된 메소드를 제공해야 한다.
  * 이 경우, 새로운 멤버 변수가 추가되는 경우에 필요할 때마다 객체의 속성을 꺼내어 비교하는 방식보다 수정사항을 반영하기 훨씬 쉬워진다.
* 이렇듯 **값 객체에 새로운 속성이 추가되더라도 수정 범위는 클래스 내부로 제한되므로, 값의 속성을 다루는 처리는 값 객체 자체에서 제공하는 것이 바람직**하다.

## 값 객체가 되기 위한 기준
* 시스템에서 사용되는 개념 중 어디까지 값 객체로 정의해야하는지 결정하는 것은 어려운 문제이다.
  * 단순히 도메인 모델로 정의된 개념은 값 객체로 정의할 수 있으나, 그렇지 않은 경우에는 혼란을 낳을 수 있다.
* 도메인 모델로 선정되지 못한 개념을 값 객체로 정의해야할지 결정하는 기준으로 다음과 같은 예시를 들 수 있다.
  1. 개념에 규칙이 존재하는가?
  2. 개념이 낱개로 다루어져야 하는가?
  * 상술한 규칙에 모두 충족하는 경우, 값 객체로 정의하는 것을 고려할 수 있다.
* 임의의 속성을 값 객체로 만들기로 결정한 경우, 각 속성을 별도의 타입으로 나눌지 하나의 타입으로 다룰지 역시 고려해야 한다.
  * 이름을 예로 들어, 성과 이름을 값 객체로 다루기로 했다면 각각을 별도의 타입으로 정의할지 또는 하나의 Name 타입으로 정의할지 고려한다.
* 이러한 **판단 기준에 의해 값 객체로 정의할 만한 가치가 있는 개념을 구현 과정에서 발견한 경우, 이를 반드시 도메인 모델로 피드백해야 한다**.
  * **도메인 주도 설계의 목적인 반복적인 개발은 이렇듯 구현 중에 발견한 새로운 사실을 통해 이루어진다**.
```
> 중요한 것은 도메인 모델을 제외한 개념을 값 객체로 정의하는 것을 피하는게 아니다.
> 값 객체로 정의할 필요가 있는지를 판단하고, 만약 그렇다면 이를 행동으로 옮겨야 한다.
> 이렇게 발견한 새로운 사실은 반드시 도메인 모델로 피드백해야 한다.
```

## 행동이 정의되는 값 객체
```
> 값 객체는 데이터만을 저장하는 컨테이너가 아닌, 행동을 가질 수 있는 객체이다.
```
* **값 객체에서 중요한 것 중 하나는 독자적인 행위를 정의할 수 있다는 사실**이다.
* **값 객체는 데이터를 담아두기 위한 것 뿐만 아니라, 데이터와 관련된 행동을 모아두어 자신만의 규칙을 갖는 도메인 객체가 되어야 한다**.
* 값 객체를 사용하는 클라이언트는 값 객체에 정의된 행위를 통해 해당 객체가 무엇을 할 수 있고, 무엇을 할 수 없는지 구분할 수 있다.

## 값 객체를 도입했을 경우의 장점
* 시스템 고유의 값을 객체로 나타내는 방식은 많은 클래스를 정의하게 되므로, 이에 거부감을 느낄 수도 있다.
* 값 객체를 도입한 경우의 장점을 통해 왜 값 객체가 필요한지를 이해한다면 이를 해소할 수 있으며, 장점은 크게 다음과 같이 나누어볼 수 있다.
  1. 표현력이 증가한다: 값 객체는 자기 정의를 통해 자신이 무엇인지에 대한 정보를 제공할 수 있으며, 자기 문서화를 돕는다. 
  2. 무결성이 유지된다: 시스템에는 각 값이 준수해야할 규칙이 있으며, 값 객체를 사용하면 이곳 저곳 방어 코드를 작성하지 않고도 무결성을 유지할 수 있다.
  3. 잘못된 대입을 미연에 방지한다.
  4. 중복된 로직이 이곳 저곳에 흩어지는 것을 방지할 수 있다.

### 잘못된 대입의 방지
* 대입은 일상적으로 자주 사용되지만, 코드가 사용되는 컨텍스트 없이는 대입이 항상 옳다고 판단하기 어렵다.
  * 코드가 올바름을 확신하려면 시스템의 동작 명세를 이해해야 하고, 이를 위해 관계자의 기억이나 문서에 의존해야 한다.
* 반면, **코드가 올바른지 아닌지를 코드를 통해 설명할 수 있다면 이러한 상황을 미연에 방지할 수 있게 된다**.
  * 이 경우, 값 객체는 그 자체로 잘 정리된 문서와 같아진다.
  * 또한, 잘못된 코드의 대입은 에러의 형태로 컴파일러에 의해 사전에 검출될 수 있다.
```
> 값 객체를 정의하면 타입 시스템의 도움을 받을 수 있으며, 찾기 어려운 에러가 숨어들만한 곳을 제한할 수 있다.
```

### 중복된 로직의 방지
* **중복된 코드가 많아지면 코드를 수정하는 난이도가 크게 오르므로, 코드의 중복을 방지하는 일은 언제나 중요**하다.
  * 중복 코드의 단점은 언제나 요구사항이 수정되어 코드에 반영해야하는 상황에 극대화된다.
* **이상적인 상황은 코드의 요구사항을 한 곳에만 반영하는 것이며, 값과 관련된 요구사항이라면 값 객체를 통해 이를 실현**할 수 있다.
* 이 경우, **시스템의 고유 값과 관련된 규칙은 해당 값 객체 내부에 정의되므로 수정사항을 반영할 위치 역시 값 객체의 클래스 내부로 제한**된다.
  * 규칙을 기술한 장소가 코드 상에서 한 곳 뿐이므로, 수정할 곳 역시 한 곳 뿐이다.
  * 소프트웨어가 변경을 쉽게 받아들일 수 있도록 유연해지기 위해서는 이러한 작업이 필수적이다.

## 결론
* 값 객체의 개념은 시스템 고유의 값을 정의한 것이다.
  * **시스템에서는 해당 시스템에서만 사용되는 값이 존재할 수 밖에 없다**.
  * 원시 타입만으로도 소프트웨어를 만들 수 있으나, 원시 타입은 지나치게 범용적이므로 표현력이 약하다.
* 도메인에는 다양한 규칙이 포함되며, 값 객체를 정의하는 것으로 이러한 규칙을 값 객체 내부에 기술할 수 있다.
  * 이 경우, 값 객체는 그 자체로 하나의 문서가 되므로 별도의 시스템 명세서를 작성할 필요를 없애준다.
* 값 객체는 도메인 지식을 코드에 반영하는 도메인 주도 설계의 기본 패턴이다.
  * **도메인 개념을 객체로 정의하는 경우, 우선 값 객체에 적합한 개념인지 검토하는 것이 바람직**하다.
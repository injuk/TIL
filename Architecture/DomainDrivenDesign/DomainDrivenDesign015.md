# DomainDrivenDesign
## 2022-05-04 Wed

## 경량 DDD에서 한 발 더 나아가기 
```
> 도메인 주도 설게에서 가장 중요한 것은 도메인의 본질을 파악하는 것이다.
```
* **경량 DDD란, 도메인 주도 설계에서 사용되는 패턴만 도입하는 것**을 말한다.
* 경량 DDD에 포함된 패턴은 코드 스타일에 한정되므로 개발 단계에서 실천이 쉽고, 단기적으로 제품에 일정 수준 이상의 품질을 갖추게 할 수 있다.
  * 때문에 비용 대비 효과가 높은 것처럼 느껴지며, 패턴을 답습하는 데에서 만족하기 쉽다.
* 그러나 **도메인 주도 설계의 진짜 목표는 패턴을 적용하는 것으로 끝나는 것이 아니다**.
  * 이렇듯 패턴을 모든 문제의 해결책으로 삼으려는 태도는 기술만으로 모든 문제를 해결하려는 자세와 다름이 없다.
* **패턴은 절대적인 답이 아니며, 도메인을 잘 파악하고 이를 코드로 표현하는 것을 돕는 보조 수단에 불과**하다.
* **언제나 어떻게 구현할 것인가, 또는 어떻게 표현할 것인가에 집중하게 되는 경우, 도메인을 제대로 파악할 여유는 절대로 생기지 않는다**.
  * **패턴은 이러한 고민에 들이는 시간을 절약해주므로, 패턴을 활용하여 얻어낸 시간으로 다시 도메인에 집중할 수 있어야 한다**.
* 도메인과 구현을 연결하는 모델링 기법도 도메인 주도 설계의 주요한 테마이다.
```
> 망치를 들면 모든 것이 못으로 보인다는 말이 있듯, 패턴을 익히고 나면 패턴을 적용할 곳을 찾아다니는 자신을 발견하게 된다.
> 도메인을 잘 나타내기 위한 수단으로서의 패턴을 자유로이 구사할 수 있는 수준이 되었다면, 때로는 패턴을 버릴 줄도 알아야 한다.
```

## 도메인 전문가와 함께하기
* 두 사람이 어떠한 대상에 관해 이야기를 나눌 때 인식이 어긋나는 경우가 종종 발생할 수 있다.
* 사람은 대화의 전문가이므로, 대부분의 경우에 자신의 경험에 비추어 그 의미를 추측하므로 의사소통에는 문제가 없는 경우가 많다.
* 그러나 **복잡하고 섬세한 개념에 대한 대화의 경우, 개발자가 사용하는 언어가 시스템의 관점에 가까울수록 도메인 전문가와의 대화는 어려워진다**.
  * 최악의 경우는 도메인 전문가가 대화를 포기하고 싶어지는 정도의 단절이 발생하는 것이며, 상대적으로 도메인을 모르는 개발자가 모든 것을 결정하게 된다.
* 이렇듯 **언어의 차이로 서로 간의 이해를 포기하는 경우, 도메인과 코드는 단절될 수 밖에 없다**.
  * 추후 **도메인의 개념이 왜곡되더라도 대화의 단절로 인해 이를 눈치채지 못하며, 수정조차 불가능해질 수 있다**. 
* 때문에 개발자는 반드시 도메인 전문가와 함께하며, 대화를 나누어야만 한다.
  * 이 때, **도메인 전문가란 단순한 이해관계자가 아닌 실제로 도메인을 실천하는 사람**이다.
  * 도메인을 제대로 이해하려면 도메인 전문가가 속하는 세계와, 그들의 관점에서 보이는 것을 이해해야 한다.
* **개발자는 시스템 관점의 언어를 도메인 전문가의 언어로 통역하기보다는 도메인 개념을 왜곡하지 않는 공통의 언어로 소통한다는 마음을 가져야한다**.

### 해결이 필요한 진짜 문제에 집중하기
```
> 대화란 서로 주고 받는 것이다.
> 도메인 전문가와 개발자는 서로 협력하며, 도메인 개념 중에서 유용한 지식을 골라 도메인 모델로 승화시켜야 한다.
```
* **도메인 전문가와의 대화에서 소프트웨어의 방향성을 결정하는데에 도움을 받을 수 있으나, 이는 무조건적으로 도메인 전문가의 의견을 따라야한다는 것은 아니다**.
  * 도메인 전문가가 문제로 보는 사안은 실제로는 사소한 문제이고, 정말 해결해야 할 문제는 다른 곳에 있는 경우도 많다.
  * 이러한 **'정말 해결해야 할 문제'는 도메인 전문가와 개발자의 대화를 통해서 발견된다**.
* **개발자는 도메인 전문가와 협력하여 유익한 도메인의 개념을 추출할 수 있어야 하며, 이렇게 뽑아낸 개념이 도메인 모델**이 된다.
  * 중요한 것은, 도메인 전문가가 모든 도메인 개념을 안다고 생각하지 않아야 한다는 점이다.
  * **시스템에 대한 지식이 없는 도메인 전문가는 소프트웨어가 도메인 활동에 어떠한 도움을 줄 수 있는지 이해하지 못하는 경우가 많다**.
  * 또한, **도메인 전문가는 방대한 지식을 갖고 있지만 그 중 어떠한 지식이 시스템에 유용할지 알지 못한다**.
  * 이를 잘 알 수 있으려면 결국 시스템이 어떤 일을 할 수 있는지 이해해야 하며, 개발자의 역할은 여기에서 시작된다.
* **개발자의 임무는 도메인 전문가와의 대화에서 시스템에 유용한 개념과 지식을 뽑아내는 것**이다.
  * 때문에 경우에 따라서는 오히려 개발자가 도메인 전문가에게 시스템에 필요한 것이 무엇인지 설득해야할 수도 있다.
* 반면, 도메인 전문가를 보조하는 소프트웨어를 만드는 데에도 도메인 전문가가 전혀 관여하지 않는 프로젝트도 많다.
  * 이 경우, 도메인 전문가 없이 개발자와 이해관계자의 회의를 통해 모든 사항이 결정되곤 한다.
  * 당연스럽게도 이러한 경우에는 가치 있는 도메인 모델을 뽑아내기 어려우므로, 결과로 만들어진 소프트웨어는 무용지물인 경우가 많다.
* **지식을 추출하는 작업은 반드시 개발자와 도메인 전문가의 공동 작업이어야 한다**. 
  * 그래야만 **개발자는 도메인 전문가가 겪는 진짜 문제를 이해하고, 애플리케이션이 무엇을 할 수 있어야하는지 구별해낼 수 있다**.
  * 결국 이러한 과정을 통해서 개발자는 문제 해결에 한 발짝 더 다가설 수 있다.
* 자신이 프로젝트 책임자 또는 이해관계자인 경우, 도메인 전문가와의 인터뷰를 전달하는 식으로 대화를 중개하는 역할을 맡지 말아야 한다.
  * 대신 개발자가 도메인 전문가와 더 많은 대화를 나눌 수 있도록 하여 비즈니스의 관점을 이해하는 주체가 되도록 돕는 역할을 맡아야 한다.

### 도메인과 코드를 연결하는 모델
* 소프트웨어의 최종 결과물은 코드의 형태이며, 모델은 이러한 코드와 도메인을 연결하는 다리 역할을 수행한다.
* **설계 및 구현 단계에서도 도메인의 새로운 면을 이해하고 발견하는 경우가 종종 있으며, 이렇게 발견된 내용으로 피드백을 통해 모델을 개선해야 한다**.
* **도메인과 코드는 모델을 통해 연결되므로, 두 개념은 모델을 통해 항상 소통하며 소프트웨어가 도메인을 더욱 잘 표현하는 모델을 가질 수 있도록 해야 한다**.

## 보편적 언어
* 사람은 언어를 통해 의사소통하므로, 하나의 개념에 여러 이름이 붙는다면 당연히 의사소통은 어려워진다.
  * 예를 들어, 같은 기능인데도 도메인 전문가와 개발자의 표현은 다를 수 있다.
  * 이렇듯 도메인 전문가와 개발자가 사용하는 언어가 완전히 다른 경우, 의사소통에는 심각한 장해가 발생한다.
  * **개발자는 도메인 전문가로부터 가치 있는 도메인 모델을 추출할 수 있어야 하므로, 이를 위해서는 응당 도메인 전문가와 같은 언어로 대화해야 한다**.
  * 또한, 개발자 사이에서도 사용하는 언어가 달라 의사소통에 방해를 겪는 경우가 있다.
* 이렇듯 미묘한 언어의 차이가 불러오는 작은 스트레스는 쌓이고 쌓여 막대한 비용으로 돌아온다.
* 언어를 변환하려는 노력을 더욱 본질적인 개념에 집중할 수 있다면 더욱 좋은 결과를 얻을 수 있을 것이므로, 의사소통에는 공통의 언어를 사용하는 것이 바람직하다.
  * **언어의 차이로 인한 비용을 절감하려면 프로젝트에 참가하는 인원의 공통 언어를 만들 필요성이 있으며, 이러한 공통 언어가 보편 언어**가 된다.
* **보편 언어는 프로젝트 내 모든 곳에서 사용되어야 할 언어이며, 도메인 전문가와의 대화는 물론이고 개발자 간의 의사소통 및 코드에도 적용**되어야 한다.
* 대화 도중 단어의 정의가 정확하지 않거나 애매한 경우을 발견하면 반드시 더 적합한 표현을 찾아야 한다.
  * 이 때, **개발자와 도메인 전문가 누구라도 단어를 지적하고 새로운 표현을 제안할 수 있다**.
  * 양측에서 언어를 다듬어가는 과정을 통해 개발자는 도메인을 더욱 깊이 이해할 수 있고, 도메인 전문가는 개발자가 필요로 하는 지식에 대한 감각을 익힐 수 있다.

### 깊이 통찰하기
* **모델에 대해 깊이 통찰할 수 있으려면 보편 언어에 기반한 대화가 필수적**이다.
  * 보편 언어가 사용되지 않는 프로젝트는 항상 통역을 거쳐 대화해야 하는 상황과도 같다.
* 개발자와 도메인 전문가 간의 어중간한 이해나 오해는 프로젝트가 진행됨에 따라 심각한 문제를 일으키기 쉽다.
* 때문에 같은 비용을 들여야 한다면, 서로의 오해를 통역하는 비용 대신 프로젝트 내에서 사용될 보편 언어를 만들고 유지하는 것이 훨씬 더 좋은 결과를 낸다.
* 보편 언어로 대화하는 과정에서, 도메인 개념을 설명할 때 제대로 전달하기 어려운 용어나 애매한 단어를 발견할 수 있다.
  * 이런 **애매모호함들은 언제나 깊은 통찰로 이어지는 계기**가 될 수 있다.
* **왜 전달하기 어렵고 애매한지 개발자와 도메인 전문가가 서로 지적해가는 과정에서 모델은 좀 더 정제되고, 비로소 도메인 지식을 제대로 표현할 수 있게 된다**.

### 코드에서의 보편 언어
* **보편 언어는 대화나 문서는 물론, 최종 결과물인 코드에 이르기까지 어디에서든지 이용**된다.
* 코드가 도메인 모델을 적절히 반영하는 경우, 도메인에 일어난 변화는 그대로 코드에 적용이 가능하다.
  * 때문에 **모델을 코드로 옮기는 과정에서 보편 언어를 사용하는 것은 설계와 코드를 연결하는 중요한 작업**이다.
* 예외적으로 코드 상의 클래스나 메소드 정의 등은 프로그래밍 언어인 만큼 영문자로 작성되어야 한다.
  * 이 과정에서 우리의 언어와 영어 사이에 존재하는 벽이 문제가 될 수 있다.
  * 대화는 우리의 언어로 하되, 내용을 번역하여 클래스나 메소드에 명명하는 현실적인 타협안은 언제나 적절한 영문명이 무엇인지 고민하게 하는 과제이다.

## 컨텍스트 경계 결정하기
* 컨텍스트의 경계를 결정하는 것은 보편 언어만큼 중요한 주제이다.
  * **도메인에도 경계가 존재하며, 이러한 경계를 넘어서면 사용되는 보편 언어도 달라질 수 있다**.
* 비즈니스가 동질적인 한 덩어리로만 구성되는 경우는 드물다.
* 때문에 보편 언어를 정의하고 비즈니스에 대한 이해를 깊이 하는 과정에서, 다음과 같은 상황과 마주할 수 있다.
  1. 같은 대상을 가리키는 서로 다른 단어가 존재하는 경우
  2. 같은 단어가 하나 이상의 의미를 갖는 경우
* 그러나 **이는 꼭 보편 언어에서 정의한 단어의 의미가 불분명하기 때문만은 아니며, 여러 컨텍스트의 경계 위에 있을 가능성을 고려해야 한다**.
* 앞선 시나리오를 예로 들어, 사용자 가입과 그룹 생성에서 표현되는 사용자는 각각 이름은 같지만 다른 의미를 갖는다.
  * 가입된 사용자는 비밀번호 정보를 가질 수 있지만, 그룹에 포함된 사용자는 그럴 필요가 없다.
  * 이러한 경우, **서로 다른 개념을 같은 객체로 우겨넣기 보다는 동명의 서로 다른 객체로 정의하는 것이 바람직**하다.

### 패키지로 분할하기
* 하나의 패키지 안에서 같은 이름의 클래스를 정의할 수는 없으므로, 컨텍스트의 경계가 나뉘면 패키지도 분할해야 한다.
  * 이 경우, 각 패키지는 같은 도메인이지만 서로 다른 시스템이 된다.
* **서로 다른 컨텍스트는 별개의 시스템이므로, 같은 데이터 소스를 사용하더라도 기술 세부사항은 서로 달라질 수 있다**.
* 시스템의 규모가 커질수록 통일된 모델을 유지하기는 어렵다.
  * 통일된 모델을 억지로 유지하는 코드는 오히려 거대하고 제약이 많은 객체가 되는 경우가 많다.
* **변경에 유연하게 대처할 수 있도록 하려면 모델을 포착하는 방식이 달라지는 지점에서 시스템을 분할**할 수 있어야 한다.
  * 이렇게 분할된 영역마다 보편 언어를 통일한다.
  * **영역을 분할한다는 것은 새로운 경계를 긋는 것과 같으며, 이렇게 그어진 경계가 컨텍스트 경계**가 된다.

## 컨텍스트 맵
* 경계를 그어 컨텍스트를 분할하면 각각의 컨텍스트를 쉽게 이해할 수 있다.
  * 그러나, 모든 컨텍스트가 연결되는 전체 도메인을 읽기는 더 어려워진다.
  * 소프트웨어를 변경하는 경우, 특정한 컨텍스트에 너무 집중하면 다른 나머지 컨텍스트와의 관계는 놓치기 쉽다.
* 앞선 시나리오를 예로 들어, 사용자 가입 측에서 사용자 객체에 변경을 가할 경우 이는 동일한 명세를 갖는 그룹의 사용자 객체에도 반영되어야 한다.
  * 이는 즉 **컨텍스트가 분리됨에 따라 다른 컨텍스트에 영향을 미치는 것을 잊기 쉬워진다는 사실을 의미**한다.
* 이러한 혼란을 피하기 위해서는 컨텍스트 간의 관계를 정의하고, 전체 도메인을 볼 수 있는 컨텍스트 맵을 작성할 수 있어야 한다.
* **개발자는 이렇게 작성된 컨텍스트 맵을 통해 모델 간의 관계를 파악한 후에 작업을 시작하는 것이 바람직**하다.

### 팀과 팀 사이를 이어주는 테스트
* 시스템의 성장에 따라 개발 팀의 규모도 커지지만, 모든 개발자가 거대한 하나의 도메인을 상대하기에는 효율이 떨어진다.
  * 따라서 **팀을 분할하게 되며, 이 때 컨텍스트의 경계는 팀을 나누는 윤곽 역할을 수행**한다.
* 자신의 컨텍스트에서 변경이 필요한 경우 우선 컨텍스트 맵을 확인하고, 인접한 컨텍스트에 미치는 영향이 있는 경우에 해당 컨텍스트를 관리하는 팀과 소통해야 한다.
* 상황에 따라서는 컨텍스트 간의 관계에 상류와 하류가 발생할 수 있다.
* 상류 팀은 항상 자신들의 위치가 주요한 경로임을 이해해야 하며, 하류 팀의 요청을 들어줄 의무가 있음을 기억해야 한다.
  * 그러나 인원 부족 등의 현실적인 문제로 모든 팀의 요청을 동시에 만족시키기는 불가능한 상황이 발생할 수 있다.
* 이 때 **적절히 작성된 테스트는 팀 간의 연결다리 역할을 수행**할 수 있다.
  * 하류 팀은 우선 상류 팀과 협력하여 원하는 명세를 검증하는 테스트를 작성한다.
  * 상류 팀은 수정에 따른 영향이 프로그램을 파괴하더라도, 하류 팀이 작성한 테스트를 통해 이를 조기에 파악할 수 있다.
* 이상적인 것은 하류 팀이 상류 팀을 의식하지 않고 자유롭게 작업을 진행하는 것이다. 
  * 이러한 상황이 실현되지 않는 경우, 지속적인 모델 수정 작업은 허황된 꿈에 지나지 않게 된다.

## 상향식 도메인 주도 설계
* 도메인 주도 설계는 하향식보다는 상향식에 가까운 것으로 이해할 수 있다.
* 도메인 주도 설계의 주역은 언제나 도메인이며, 어떠한 소프트웨어를 작성할지는 그 다음의 문제이다.
  * 그 증거로, 도메인 전문가가 필요하다고 생각했던 요소가 판단 착오로 결론나는 경우도 많이 발생한다.
  * 이는 **도메인 전문가가 필요하다고 생각했던 요소에 맞추어 무엇이 필요한지 파악하는 하향식 접근 방법에 오류가 있을 수 있다는 사실을 시사**한다.
* **산출물 중심이 아니라 어떠한 문제를 해결할지부터 시작하는 접근법은 상향식 스타일**에 가깝다.
```
> 어떠한 지식을 얻기 위해 사전 지식이 필요한 경우가 많다.
> 지식은 사슬과도 같이 이어지므로, 상향식으로 지식을 쌓아 올려가다 보면 반드시 이해에 도달할 수 있다.
```

## 결론
* 상향식으로 도메인 주도 설계를 적용하려 시도하는 것만으로 코드는 놀랄만큼 변화하며, 소프트웨어의 앞날은 그만큼 밝아진다.
* **도메인 주도 설계의 목적은 모델을 통해 도메인과 코드를 연결하고, 이를 반복적으로 개선해나가는 것**이다.
  * 때문에 패턴만을 맹목적으로 따르려고 하는 것은 주객이 전도된 것과 같다.
* 사용자에게 정말로 유용한 소프트웨어를 작성하려면 우선 그 사용자가 처한 상황과 환경에 대해 잘 알아야 한다.
  * **도메인에 관한 문제는 도메인을 둘러싸는 환경을 이해하지 못하는 한, 완전히 이해했다고 볼 수 없다**.
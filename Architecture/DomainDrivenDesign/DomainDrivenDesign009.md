# DomainDrivenDesign
## 2022-05-01 Sun

## 팩토리 패턴
* 팩토리는 객체를 만드는 지식에 특화된 객체이다.
  * **도구를 만드는 것과 사용하는 것은 별개의 지식이듯, 객체를 생성하는 책임을 굳이 도메인 모델을 나타내기 위한 객체에 맡길 필요가 없다**.
* 객체를 만드는 작업 자체가 복잡한 경우가 있으며, 이를 객체 내부에 구현하는 것보다는 객체 생성 과정 자체를 별도의 팩토리로 만들어두는 것이 더 명확하다. 

## 팩토리의 목적은 무엇인가?
* 사람이 상상하는 모든 것에 대해 도구가 고안되며, 도구는 사용 방법만 알면 구조를 몰라도 장점을 그대로 누릴 수 있다.
  * 도구의 이러한 특징은 강력하며, 이는 프로그래밍에서도 그대로 발현된다.
  * 예를 들어 **객체 지향 프로그래밍에서의 클래스는 도구 그 자체이며, 메소드의 사용 방법만 알면 내부 구조를 몰라도 누구나 사용이 가능**하다.
* 그러나 도구는 편리할수록 복잡한 구조를 갖기 쉽고, 실세계에서도 복잡한 도구는 그만큼 만드는 과정도 복잡해진다.
  * 이러한 측면에서 도구를 만드는 과정 역시 도구를 사용하는 것과는 별개로 존재하는 지식으로 이해할 수 있다.
* 프로그래밍에서도 이러한 특징은 마찬가지이며, 복잡한 객체는 객체를 생성하는 처리도 복잡해지기 쉽다.
  * 즉, **복잡한 객체를 생성하기 위한 복잡한 처리는 도메인 모델을 나타내기 위한 객체의 취지를 불분명하게 만들 수 있다**.
  * 그렇다고 해서 객체 생성을 무조건 클라이언트에서 처리하는 것은 다음과 같은 이유에서 능사가 아니다.
* **객체를 생성하는 과정 자체는 도메인에 의미가 없으나, 여전히 도메인을 나타내기 위한 계층의 책임**이다.
* 이로 인해 객체 생성 과정을 정의하는 또 다른 객체를 정의할 필요가 생긴다.
  * 이렇듯 객체 생성을 책임지는 객체는 마치 도구를 찍어내는 공장과 같다는 의미에서 팩토리라는 이름을 붙인다.
```
> 팩토리는 객체의 생성 과정과 관련된 지식이 정리된 객체이다.
```

### 팩토리의 존재감 인식시키기
* 팩토리를 정의한다고 해서 다른 개발자들 역시 객체 생성에 반드시 팩토리를 사용하리라는 보장은 없다.
* 이는 도메인 객체 클래스만 봐서는 팩토리의 존재감을 느끼기 어렵기 때문이며, 이를 제대로 인식시키기 위해 패키지를 사용할 수 있다.
  * 예를 들어, 팩토리가 생성하는 도메인 객체 클래스와 같은 패키지에 팩토리 또는 팩토리 인터페이스를 위치시킨다.
  * 추후 개발 과정에 참여하는 개발자는 해당 도메인 객체 패키지를 열어보는 것으로 팩토리의 존재를 즉시 인지할 수 있게 된다.

## 팩토리 메소드
* 클래스 자체가 아닌 메소드가 팩토리 역할을 하는 경우도 있다.
* **이러한 방법은 객체 내부의 데이터를 이용하여 인스턴스를 생성할 필요가 있을 때 흔히 사용**된다.
  * 예를 들어 어떤 객체를 생성하기 위해 도메인 객체의 게터를 추가해야하는 경우, 대신 도메인 객체 자체에 팩토리 메소드를 정의할 수 있다.
  * 게터는 마냥 쉽게 추가하여 사용할만한 개념은 아니므로, 게터를 외부로 공개하는 대신 메소드로 새로운 객체를 생성하여 반환하도록 한다.
  * **이러한 방법은 인스턴스 내부의 정보를 공개하지 않을 수 있지만, 도메인이 어떤 관점에서 모델링되었는지에 따라 옳고 그름이 나뉠 수 있다**.
  * 즉, 해당 도메인 객체가 해당 객체를 생성하는 것이 도메인 객체에 정의된 행위가 맞다면 이는 옳은 구현에 해당한다. 

## 복잡한 객체 생성 절차의 캡슐화
* 팩토리는 다형성의 장점을 누리기 위해 정의되곤 한다.
  * 그러나 **단순히 생성 절차가 복잡한 인스턴스를 만드는 코드를 모아두기 위해 팩토리를 정의하는 것도 좋은 습관**이다.
* **객체의 초기화는 기본적으로 생성자 메소드의 역할이지만, 생성자 메소드는 단순함을 유지해야 한다**.
  * 생성자 메소드가 복잡해지면 팩토리를 정의하는 것이 바람직하다.
  * 이 때, 팩토리의 당위성은 생성자 메소드 내부에서 새로운 객체를 생성하는지 여부를 기준으로 삼을 수 있다.
  * 예를 들어 생성자 메소드가 다른 객체를 생성하는 역할까지 수행하는 경우, 해당 객체가 변경되었을 때 생성자 메소드도 함께 변경되어야 한다.
  * 이는 **다른 객체의 인스턴스를 생성하는 것에 지나지 않더라도 생성자 메소드의 복잡도를 상승**시킨다. 
* 물론 모든 인스턴스를 팩토리로 생성할 필요는 없으며, 생성 절차가 간단한 객체는 생성자 메소드를 활용하는 것이 바람직하다.
  * **중요한 것은, 언제나 생성자를 통해서만 객체를 생성하지 말고 항상 팩토리의 필요성을 검토하는 습관을 들이는 것**이다.

### 도메인 설계와 팩토리, 리포지토리
```
> 도메인을 모델에 녹여내고, 코드로 다시 모델을 표현하는 과정인 도메인 설계를 완성하려면 도메인 모델을 표현하지 않는 요소도 반드시 필요하다.
```
* 팩토리와 리포지토리는 도메인에서 유래한 객체는 아니지만, 도메인과 완전히 무관한 존재는 아니다.
* **객체의 생성이나 영속화는 도메인에서 유래한 것이 아니지만, 도메인을 표현하기 위해 필요한 요소에 해당**한다.
  * 따라서 도메인을 표현하는 데에 도움을 주는 팩토리와 리포지토리 역시 도메인 설계를 구성하는 요소가 된다.

## 결론
* 팩토리는 객체의 생명주기의 시작 단계에서 자신의 역할을 수행한다.
* 팩토리를 통해 생성 절차가 복잡한 객체를 생성하는 경우, 다음과 같은 이점을 누릴 수 있다.
  1. 복잡한 객체 생성 절차를 위임하므로, 코드의 원래 의도를 더 분명히 드러낼 수 있다.
  2. **복잡한 객체 생성 절차가 코드의 이곳저곳에 중복되는 것을 미연에 방지할 수 있다**.
* **팩토리를 이용하여 객체 생성 절차를 캡슐화하면 로직의 의도를 더욱 명확히 드러내면서도 유연성을 확보할 수 있다**.